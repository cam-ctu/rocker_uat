
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:21:56.654] plan(): Setting new future strategy stack:
[10:21:56.655] List of future strategies:
[10:21:56.655] 1. sequential:
[10:21:56.655]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.655]    - tweaked: FALSE
[10:21:56.655]    - call: future::plan("sequential")
[10:21:56.668] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** multisession() ...")
*** multisession() ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   ## No global variables
+   f <- multisession({
+     42L
+   })
+   print(f)
+   stopifnot(inherits(f, "ClusterFuture") || (inherits(f, "SequentialFuture") && f$lazy))
+ 
+   print(resolved(f))
+   y <- value(f)
+   print(y)
+   stopifnot(y == 42L)
+ 
+ 
+   ## A global variable
+   a <- 0
+   f <- multisession({
+     b <- 3
+     c <- 2
+     a * b * c
+   }, globals = TRUE)
+   print(f)
+ 
+ 
+   ## A multisession future is evaluated in a separate
+   ## R session process.  Changing the value of a global
+   ## variable should not affect the result of the
+   ## future.
+   a <- 7  ## Make sure globals are frozen
+   v <- value(f)
+   print(v)
+   stopifnot(v == 0)
+ 
+ 
+   message("*** multisession() with globals and blocking")
+   x <- listenv()
+   for (ii in 2:1) {
+     message(sprintf(" - Creating multisession future #%d ...", ii))
+     x[[ii]] <- multisession({ ii }, globals = TRUE)
+   }
+   message(sprintf(" - Resolving %d multisession futures", length(x)))
+   v <- sapply(x, FUN = value)
+   stopifnot(all(v == 1:2))
+ 
+ 
+   message("*** multisession() - workers inherit .libPaths()")
+ 
+   libs <- value(future(.libPaths()))
+   str(list(
+     main = .libPaths(),
+     workers = libs
+   ))
+   stopifnot(identical(libs, .libPaths()))
+ 
+   message("*** multisession() and errors")
+   f <- multisession({
+     stop("Whoops!")
+     1
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "simpleError"))
+ 
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Error is repeated
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Custom error class
+   f <- multisession({
+     stop(structure(list(message = "boom"),
+                    class = c("MyError", "error", "condition")))
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+ 
+   ## Make sure error is signaled
+   res <- tryCatch(value(f), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   ## Issue #200: Custom condition class attributes are lost
+   ## https://github.com/HenrikBengtsson/Wishlist-for-R/issues/57
+   ## stopifnot(inherits(res, "MyError"))    
+ 
+   ## Make sure to stop these cluster processes to avoid triggering
+   ## checking for detritus in the temp directory ... NOTE
+   ClusterRegistry(action = "stop")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
[10:21:56.725] getGlobalsAndPackages() ...
[10:21:56.725] Searching for globals...
[10:21:56.728] - globals found: [1] ‘{’
[10:21:56.728] Searching for globals ... DONE
[10:21:56.728] Resolving globals: FALSE
[10:21:56.729] 
[10:21:56.729] 
[10:21:56.729] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 46d13282-a26d-1c6f-65b7-056826eaeb73
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:56.731] Packages needed by the future expression (n = 0): <none>
[10:21:56.731] Packages needed by future strategies (n = 0): <none>
[10:21:56.731] {
[10:21:56.731]     {
[10:21:56.731]         {
[10:21:56.731]             ...future.startTime <- base::Sys.time()
[10:21:56.731]             {
[10:21:56.731]                 {
[10:21:56.731]                   {
[10:21:56.731]                     base::local({
[10:21:56.731]                       has_future <- base::requireNamespace("future", 
[10:21:56.731]                         quietly = TRUE)
[10:21:56.731]                       if (has_future) {
[10:21:56.731]                         ns <- base::getNamespace("future")
[10:21:56.731]                         version <- ns[[".package"]][["version"]]
[10:21:56.731]                         if (is.null(version)) 
[10:21:56.731]                           version <- utils::packageVersion("future")
[10:21:56.731]                       }
[10:21:56.731]                       else {
[10:21:56.731]                         version <- NULL
[10:21:56.731]                       }
[10:21:56.731]                       if (!has_future || version < "1.8.0") {
[10:21:56.731]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:56.731]                           "", base::R.version$version.string), 
[10:21:56.731]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:56.731]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:56.731]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:56.731]                             "release", "version")], collapse = " "), 
[10:21:56.731]                           hostname = base::Sys.info()[["nodename"]])
[10:21:56.731]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:56.731]                           info)
[10:21:56.731]                         info <- base::paste(info, collapse = "; ")
[10:21:56.731]                         if (!has_future) {
[10:21:56.731]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:56.731]                             info)
[10:21:56.731]                         }
[10:21:56.731]                         else {
[10:21:56.731]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:56.731]                             info, version)
[10:21:56.731]                         }
[10:21:56.731]                         base::stop(msg)
[10:21:56.731]                       }
[10:21:56.731]                     })
[10:21:56.731]                   }
[10:21:56.731]                   ...future.strategy.old <- future::plan("list")
[10:21:56.731]                   options(future.plan = NULL)
[10:21:56.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:56.731]                 }
[10:21:56.731]                 ...future.workdir <- getwd()
[10:21:56.731]             }
[10:21:56.731]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:56.731]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:56.731]         }
[10:21:56.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:56.731]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:56.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:56.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:56.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:56.731]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:56.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:56.731]             base::names(...future.oldOptions))
[10:21:56.731]     }
[10:21:56.731]     if (FALSE) {
[10:21:56.731]     }
[10:21:56.731]     else {
[10:21:56.731]         if (TRUE) {
[10:21:56.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:56.731]                 open = "w")
[10:21:56.731]         }
[10:21:56.731]         else {
[10:21:56.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:56.731]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:56.731]         }
[10:21:56.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:56.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:56.731]             base::sink(type = "output", split = FALSE)
[10:21:56.731]             base::close(...future.stdout)
[10:21:56.731]         }, add = TRUE)
[10:21:56.731]     }
[10:21:56.731]     ...future.frame <- base::sys.nframe()
[10:21:56.731]     ...future.conditions <- base::list()
[10:21:56.731]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:56.731]     if (FALSE) {
[10:21:56.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:56.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:56.731]     }
[10:21:56.731]     ...future.result <- base::tryCatch({
[10:21:56.731]         base::withCallingHandlers({
[10:21:56.731]             ...future.value <- base::withVisible(base::local({
[10:21:56.731]                 42L
[10:21:56.731]             }))
[10:21:56.731]             future::FutureResult(value = ...future.value$value, 
[10:21:56.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.731]                   ...future.rng), globalenv = if (FALSE) 
[10:21:56.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:56.731]                     ...future.globalenv.names))
[10:21:56.731]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:56.731]         }, condition = base::local({
[10:21:56.731]             c <- base::c
[10:21:56.731]             inherits <- base::inherits
[10:21:56.731]             invokeRestart <- base::invokeRestart
[10:21:56.731]             length <- base::length
[10:21:56.731]             list <- base::list
[10:21:56.731]             seq.int <- base::seq.int
[10:21:56.731]             signalCondition <- base::signalCondition
[10:21:56.731]             sys.calls <- base::sys.calls
[10:21:56.731]             `[[` <- base::`[[`
[10:21:56.731]             `+` <- base::`+`
[10:21:56.731]             `<<-` <- base::`<<-`
[10:21:56.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:56.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:56.731]                   3L)]
[10:21:56.731]             }
[10:21:56.731]             function(cond) {
[10:21:56.731]                 is_error <- inherits(cond, "error")
[10:21:56.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:56.731]                   NULL)
[10:21:56.731]                 if (is_error) {
[10:21:56.731]                   sessionInformation <- function() {
[10:21:56.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:56.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:56.731]                       search = base::search(), system = base::Sys.info())
[10:21:56.731]                   }
[10:21:56.731]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:56.731]                     cond$call), session = sessionInformation(), 
[10:21:56.731]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:56.731]                   signalCondition(cond)
[10:21:56.731]                 }
[10:21:56.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:56.731]                 "immediateCondition"))) {
[10:21:56.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:56.731]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:56.731]                   if (TRUE && !signal) {
[10:21:56.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.731]                     {
[10:21:56.731]                       inherits <- base::inherits
[10:21:56.731]                       invokeRestart <- base::invokeRestart
[10:21:56.731]                       is.null <- base::is.null
[10:21:56.731]                       muffled <- FALSE
[10:21:56.731]                       if (inherits(cond, "message")) {
[10:21:56.731]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.731]                         if (muffled) 
[10:21:56.731]                           invokeRestart("muffleMessage")
[10:21:56.731]                       }
[10:21:56.731]                       else if (inherits(cond, "warning")) {
[10:21:56.731]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.731]                         if (muffled) 
[10:21:56.731]                           invokeRestart("muffleWarning")
[10:21:56.731]                       }
[10:21:56.731]                       else if (inherits(cond, "condition")) {
[10:21:56.731]                         if (!is.null(pattern)) {
[10:21:56.731]                           computeRestarts <- base::computeRestarts
[10:21:56.731]                           grepl <- base::grepl
[10:21:56.731]                           restarts <- computeRestarts(cond)
[10:21:56.731]                           for (restart in restarts) {
[10:21:56.731]                             name <- restart$name
[10:21:56.731]                             if (is.null(name)) 
[10:21:56.731]                               next
[10:21:56.731]                             if (!grepl(pattern, name)) 
[10:21:56.731]                               next
[10:21:56.731]                             invokeRestart(restart)
[10:21:56.731]                             muffled <- TRUE
[10:21:56.731]                             break
[10:21:56.731]                           }
[10:21:56.731]                         }
[10:21:56.731]                       }
[10:21:56.731]                       invisible(muffled)
[10:21:56.731]                     }
[10:21:56.731]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.731]                   }
[10:21:56.731]                 }
[10:21:56.731]                 else {
[10:21:56.731]                   if (TRUE) {
[10:21:56.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.731]                     {
[10:21:56.731]                       inherits <- base::inherits
[10:21:56.731]                       invokeRestart <- base::invokeRestart
[10:21:56.731]                       is.null <- base::is.null
[10:21:56.731]                       muffled <- FALSE
[10:21:56.731]                       if (inherits(cond, "message")) {
[10:21:56.731]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.731]                         if (muffled) 
[10:21:56.731]                           invokeRestart("muffleMessage")
[10:21:56.731]                       }
[10:21:56.731]                       else if (inherits(cond, "warning")) {
[10:21:56.731]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.731]                         if (muffled) 
[10:21:56.731]                           invokeRestart("muffleWarning")
[10:21:56.731]                       }
[10:21:56.731]                       else if (inherits(cond, "condition")) {
[10:21:56.731]                         if (!is.null(pattern)) {
[10:21:56.731]                           computeRestarts <- base::computeRestarts
[10:21:56.731]                           grepl <- base::grepl
[10:21:56.731]                           restarts <- computeRestarts(cond)
[10:21:56.731]                           for (restart in restarts) {
[10:21:56.731]                             name <- restart$name
[10:21:56.731]                             if (is.null(name)) 
[10:21:56.731]                               next
[10:21:56.731]                             if (!grepl(pattern, name)) 
[10:21:56.731]                               next
[10:21:56.731]                             invokeRestart(restart)
[10:21:56.731]                             muffled <- TRUE
[10:21:56.731]                             break
[10:21:56.731]                           }
[10:21:56.731]                         }
[10:21:56.731]                       }
[10:21:56.731]                       invisible(muffled)
[10:21:56.731]                     }
[10:21:56.731]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.731]                   }
[10:21:56.731]                 }
[10:21:56.731]             }
[10:21:56.731]         }))
[10:21:56.731]     }, error = function(ex) {
[10:21:56.731]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:56.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.731]                 ...future.rng), started = ...future.startTime, 
[10:21:56.731]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:56.731]             version = "1.8"), class = "FutureResult")
[10:21:56.731]     }, finally = {
[10:21:56.731]         if (!identical(...future.workdir, getwd())) 
[10:21:56.731]             setwd(...future.workdir)
[10:21:56.731]         {
[10:21:56.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:56.731]                 ...future.oldOptions$nwarnings <- NULL
[10:21:56.731]             }
[10:21:56.731]             base::options(...future.oldOptions)
[10:21:56.731]             if (.Platform$OS.type == "windows") {
[10:21:56.731]                 old_names <- names(...future.oldEnvVars)
[10:21:56.731]                 envs <- base::Sys.getenv()
[10:21:56.731]                 names <- names(envs)
[10:21:56.731]                 common <- intersect(names, old_names)
[10:21:56.731]                 added <- setdiff(names, old_names)
[10:21:56.731]                 removed <- setdiff(old_names, names)
[10:21:56.731]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:56.731]                   envs[common]]
[10:21:56.731]                 NAMES <- toupper(changed)
[10:21:56.731]                 args <- list()
[10:21:56.731]                 for (kk in seq_along(NAMES)) {
[10:21:56.731]                   name <- changed[[kk]]
[10:21:56.731]                   NAME <- NAMES[[kk]]
[10:21:56.731]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.731]                     next
[10:21:56.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.731]                 }
[10:21:56.731]                 NAMES <- toupper(added)
[10:21:56.731]                 for (kk in seq_along(NAMES)) {
[10:21:56.731]                   name <- added[[kk]]
[10:21:56.731]                   NAME <- NAMES[[kk]]
[10:21:56.731]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.731]                     next
[10:21:56.731]                   args[[name]] <- ""
[10:21:56.731]                 }
[10:21:56.731]                 NAMES <- toupper(removed)
[10:21:56.731]                 for (kk in seq_along(NAMES)) {
[10:21:56.731]                   name <- removed[[kk]]
[10:21:56.731]                   NAME <- NAMES[[kk]]
[10:21:56.731]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.731]                     next
[10:21:56.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.731]                 }
[10:21:56.731]                 if (length(args) > 0) 
[10:21:56.731]                   base::do.call(base::Sys.setenv, args = args)
[10:21:56.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:56.731]             }
[10:21:56.731]             else {
[10:21:56.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:56.731]             }
[10:21:56.731]             {
[10:21:56.731]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:56.731]                   0L) {
[10:21:56.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:56.731]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:56.731]                   base::options(opts)
[10:21:56.731]                 }
[10:21:56.731]                 {
[10:21:56.731]                   {
[10:21:56.731]                     NULL
[10:21:56.731]                     RNGkind("Mersenne-Twister")
[10:21:56.731]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:56.731]                       inherits = FALSE)
[10:21:56.731]                   }
[10:21:56.731]                   options(future.plan = NULL)
[10:21:56.731]                   if (is.na(NA_character_)) 
[10:21:56.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:56.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:56.731]                     .init = FALSE)
[10:21:56.731]                 }
[10:21:56.731]             }
[10:21:56.731]         }
[10:21:56.731]     })
[10:21:56.731]     if (TRUE) {
[10:21:56.731]         base::sink(type = "output", split = FALSE)
[10:21:56.731]         if (TRUE) {
[10:21:56.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:56.731]         }
[10:21:56.731]         else {
[10:21:56.731]             ...future.result["stdout"] <- base::list(NULL)
[10:21:56.731]         }
[10:21:56.731]         base::close(...future.stdout)
[10:21:56.731]         ...future.stdout <- NULL
[10:21:56.731]     }
[10:21:56.731]     ...future.result$conditions <- ...future.conditions
[10:21:56.731]     ...future.result$finished <- base::Sys.time()
[10:21:56.731]     ...future.result
[10:21:56.731] }
[10:21:56.733] plan(): Setting new future strategy stack:
[10:21:56.733] List of future strategies:
[10:21:56.733] 1. sequential:
[10:21:56.733]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.733]    - tweaked: FALSE
[10:21:56.733]    - call: NULL
[10:21:56.734] plan(): nbrOfWorkers() = 1
[10:21:56.735] plan(): Setting new future strategy stack:
[10:21:56.735] List of future strategies:
[10:21:56.735] 1. sequential:
[10:21:56.735]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.735]    - tweaked: FALSE
[10:21:56.735]    - call: future::plan("sequential")
[10:21:56.736] plan(): nbrOfWorkers() = 1
[10:21:56.736] SequentialFuture started (and completed)
[10:21:56.736] resolved() for ‘SequentialFuture’ ...
[10:21:56.736] - state: ‘finished’
[10:21:56.736] - run: TRUE
[10:21:56.736] - result: ‘FutureResult’
[10:21:56.737] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
[10:21:56.738] getGlobalsAndPackages() ...
[10:21:56.738] Searching for globals...
[10:21:56.745] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[10:21:56.745] Searching for globals ... DONE
[10:21:56.745] Resolving globals: FALSE
[10:21:56.746] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:56.747] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:56.747] - globals: [1] ‘a’
[10:21:56.747] 
[10:21:56.747] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 39 bytes (numeric ‘a’ of 39 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 46d13282-a26d-1c6f-65b7-056826eaeb73
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:56.748] Packages needed by the future expression (n = 0): <none>
[10:21:56.748] Packages needed by future strategies (n = 0): <none>
[10:21:56.748] {
[10:21:56.748]     {
[10:21:56.748]         {
[10:21:56.748]             ...future.startTime <- base::Sys.time()
[10:21:56.748]             {
[10:21:56.748]                 {
[10:21:56.748]                   {
[10:21:56.748]                     base::local({
[10:21:56.748]                       has_future <- base::requireNamespace("future", 
[10:21:56.748]                         quietly = TRUE)
[10:21:56.748]                       if (has_future) {
[10:21:56.748]                         ns <- base::getNamespace("future")
[10:21:56.748]                         version <- ns[[".package"]][["version"]]
[10:21:56.748]                         if (is.null(version)) 
[10:21:56.748]                           version <- utils::packageVersion("future")
[10:21:56.748]                       }
[10:21:56.748]                       else {
[10:21:56.748]                         version <- NULL
[10:21:56.748]                       }
[10:21:56.748]                       if (!has_future || version < "1.8.0") {
[10:21:56.748]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:56.748]                           "", base::R.version$version.string), 
[10:21:56.748]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:56.748]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:56.748]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:56.748]                             "release", "version")], collapse = " "), 
[10:21:56.748]                           hostname = base::Sys.info()[["nodename"]])
[10:21:56.748]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:56.748]                           info)
[10:21:56.748]                         info <- base::paste(info, collapse = "; ")
[10:21:56.748]                         if (!has_future) {
[10:21:56.748]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:56.748]                             info)
[10:21:56.748]                         }
[10:21:56.748]                         else {
[10:21:56.748]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:56.748]                             info, version)
[10:21:56.748]                         }
[10:21:56.748]                         base::stop(msg)
[10:21:56.748]                       }
[10:21:56.748]                     })
[10:21:56.748]                   }
[10:21:56.748]                   ...future.strategy.old <- future::plan("list")
[10:21:56.748]                   options(future.plan = NULL)
[10:21:56.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:56.748]                 }
[10:21:56.748]                 ...future.workdir <- getwd()
[10:21:56.748]             }
[10:21:56.748]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:56.748]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:56.748]         }
[10:21:56.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:56.748]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:56.748]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:56.748]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:56.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:56.748]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:56.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:56.748]             base::names(...future.oldOptions))
[10:21:56.748]     }
[10:21:56.748]     if (FALSE) {
[10:21:56.748]     }
[10:21:56.748]     else {
[10:21:56.748]         if (TRUE) {
[10:21:56.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:56.748]                 open = "w")
[10:21:56.748]         }
[10:21:56.748]         else {
[10:21:56.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:56.748]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:56.748]         }
[10:21:56.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:56.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:56.748]             base::sink(type = "output", split = FALSE)
[10:21:56.748]             base::close(...future.stdout)
[10:21:56.748]         }, add = TRUE)
[10:21:56.748]     }
[10:21:56.748]     ...future.frame <- base::sys.nframe()
[10:21:56.748]     ...future.conditions <- base::list()
[10:21:56.748]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:56.748]     if (FALSE) {
[10:21:56.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:56.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:56.748]     }
[10:21:56.748]     ...future.result <- base::tryCatch({
[10:21:56.748]         base::withCallingHandlers({
[10:21:56.748]             ...future.value <- base::withVisible(base::local({
[10:21:56.748]                 b <- 3
[10:21:56.748]                 c <- 2
[10:21:56.748]                 a * b * c
[10:21:56.748]             }))
[10:21:56.748]             future::FutureResult(value = ...future.value$value, 
[10:21:56.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.748]                   ...future.rng), globalenv = if (FALSE) 
[10:21:56.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:56.748]                     ...future.globalenv.names))
[10:21:56.748]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:56.748]         }, condition = base::local({
[10:21:56.748]             c <- base::c
[10:21:56.748]             inherits <- base::inherits
[10:21:56.748]             invokeRestart <- base::invokeRestart
[10:21:56.748]             length <- base::length
[10:21:56.748]             list <- base::list
[10:21:56.748]             seq.int <- base::seq.int
[10:21:56.748]             signalCondition <- base::signalCondition
[10:21:56.748]             sys.calls <- base::sys.calls
[10:21:56.748]             `[[` <- base::`[[`
[10:21:56.748]             `+` <- base::`+`
[10:21:56.748]             `<<-` <- base::`<<-`
[10:21:56.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:56.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:56.748]                   3L)]
[10:21:56.748]             }
[10:21:56.748]             function(cond) {
[10:21:56.748]                 is_error <- inherits(cond, "error")
[10:21:56.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:56.748]                   NULL)
[10:21:56.748]                 if (is_error) {
[10:21:56.748]                   sessionInformation <- function() {
[10:21:56.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:56.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:56.748]                       search = base::search(), system = base::Sys.info())
[10:21:56.748]                   }
[10:21:56.748]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:56.748]                     cond$call), session = sessionInformation(), 
[10:21:56.748]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:56.748]                   signalCondition(cond)
[10:21:56.748]                 }
[10:21:56.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:56.748]                 "immediateCondition"))) {
[10:21:56.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:56.748]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:56.748]                   if (TRUE && !signal) {
[10:21:56.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.748]                     {
[10:21:56.748]                       inherits <- base::inherits
[10:21:56.748]                       invokeRestart <- base::invokeRestart
[10:21:56.748]                       is.null <- base::is.null
[10:21:56.748]                       muffled <- FALSE
[10:21:56.748]                       if (inherits(cond, "message")) {
[10:21:56.748]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.748]                         if (muffled) 
[10:21:56.748]                           invokeRestart("muffleMessage")
[10:21:56.748]                       }
[10:21:56.748]                       else if (inherits(cond, "warning")) {
[10:21:56.748]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.748]                         if (muffled) 
[10:21:56.748]                           invokeRestart("muffleWarning")
[10:21:56.748]                       }
[10:21:56.748]                       else if (inherits(cond, "condition")) {
[10:21:56.748]                         if (!is.null(pattern)) {
[10:21:56.748]                           computeRestarts <- base::computeRestarts
[10:21:56.748]                           grepl <- base::grepl
[10:21:56.748]                           restarts <- computeRestarts(cond)
[10:21:56.748]                           for (restart in restarts) {
[10:21:56.748]                             name <- restart$name
[10:21:56.748]                             if (is.null(name)) 
[10:21:56.748]                               next
[10:21:56.748]                             if (!grepl(pattern, name)) 
[10:21:56.748]                               next
[10:21:56.748]                             invokeRestart(restart)
[10:21:56.748]                             muffled <- TRUE
[10:21:56.748]                             break
[10:21:56.748]                           }
[10:21:56.748]                         }
[10:21:56.748]                       }
[10:21:56.748]                       invisible(muffled)
[10:21:56.748]                     }
[10:21:56.748]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.748]                   }
[10:21:56.748]                 }
[10:21:56.748]                 else {
[10:21:56.748]                   if (TRUE) {
[10:21:56.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.748]                     {
[10:21:56.748]                       inherits <- base::inherits
[10:21:56.748]                       invokeRestart <- base::invokeRestart
[10:21:56.748]                       is.null <- base::is.null
[10:21:56.748]                       muffled <- FALSE
[10:21:56.748]                       if (inherits(cond, "message")) {
[10:21:56.748]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.748]                         if (muffled) 
[10:21:56.748]                           invokeRestart("muffleMessage")
[10:21:56.748]                       }
[10:21:56.748]                       else if (inherits(cond, "warning")) {
[10:21:56.748]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.748]                         if (muffled) 
[10:21:56.748]                           invokeRestart("muffleWarning")
[10:21:56.748]                       }
[10:21:56.748]                       else if (inherits(cond, "condition")) {
[10:21:56.748]                         if (!is.null(pattern)) {
[10:21:56.748]                           computeRestarts <- base::computeRestarts
[10:21:56.748]                           grepl <- base::grepl
[10:21:56.748]                           restarts <- computeRestarts(cond)
[10:21:56.748]                           for (restart in restarts) {
[10:21:56.748]                             name <- restart$name
[10:21:56.748]                             if (is.null(name)) 
[10:21:56.748]                               next
[10:21:56.748]                             if (!grepl(pattern, name)) 
[10:21:56.748]                               next
[10:21:56.748]                             invokeRestart(restart)
[10:21:56.748]                             muffled <- TRUE
[10:21:56.748]                             break
[10:21:56.748]                           }
[10:21:56.748]                         }
[10:21:56.748]                       }
[10:21:56.748]                       invisible(muffled)
[10:21:56.748]                     }
[10:21:56.748]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.748]                   }
[10:21:56.748]                 }
[10:21:56.748]             }
[10:21:56.748]         }))
[10:21:56.748]     }, error = function(ex) {
[10:21:56.748]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:56.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.748]                 ...future.rng), started = ...future.startTime, 
[10:21:56.748]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:56.748]             version = "1.8"), class = "FutureResult")
[10:21:56.748]     }, finally = {
[10:21:56.748]         if (!identical(...future.workdir, getwd())) 
[10:21:56.748]             setwd(...future.workdir)
[10:21:56.748]         {
[10:21:56.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:56.748]                 ...future.oldOptions$nwarnings <- NULL
[10:21:56.748]             }
[10:21:56.748]             base::options(...future.oldOptions)
[10:21:56.748]             if (.Platform$OS.type == "windows") {
[10:21:56.748]                 old_names <- names(...future.oldEnvVars)
[10:21:56.748]                 envs <- base::Sys.getenv()
[10:21:56.748]                 names <- names(envs)
[10:21:56.748]                 common <- intersect(names, old_names)
[10:21:56.748]                 added <- setdiff(names, old_names)
[10:21:56.748]                 removed <- setdiff(old_names, names)
[10:21:56.748]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:56.748]                   envs[common]]
[10:21:56.748]                 NAMES <- toupper(changed)
[10:21:56.748]                 args <- list()
[10:21:56.748]                 for (kk in seq_along(NAMES)) {
[10:21:56.748]                   name <- changed[[kk]]
[10:21:56.748]                   NAME <- NAMES[[kk]]
[10:21:56.748]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.748]                     next
[10:21:56.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.748]                 }
[10:21:56.748]                 NAMES <- toupper(added)
[10:21:56.748]                 for (kk in seq_along(NAMES)) {
[10:21:56.748]                   name <- added[[kk]]
[10:21:56.748]                   NAME <- NAMES[[kk]]
[10:21:56.748]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.748]                     next
[10:21:56.748]                   args[[name]] <- ""
[10:21:56.748]                 }
[10:21:56.748]                 NAMES <- toupper(removed)
[10:21:56.748]                 for (kk in seq_along(NAMES)) {
[10:21:56.748]                   name <- removed[[kk]]
[10:21:56.748]                   NAME <- NAMES[[kk]]
[10:21:56.748]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.748]                     next
[10:21:56.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.748]                 }
[10:21:56.748]                 if (length(args) > 0) 
[10:21:56.748]                   base::do.call(base::Sys.setenv, args = args)
[10:21:56.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:56.748]             }
[10:21:56.748]             else {
[10:21:56.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:56.748]             }
[10:21:56.748]             {
[10:21:56.748]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:56.748]                   0L) {
[10:21:56.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:56.748]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:56.748]                   base::options(opts)
[10:21:56.748]                 }
[10:21:56.748]                 {
[10:21:56.748]                   {
[10:21:56.748]                     NULL
[10:21:56.748]                     RNGkind("Mersenne-Twister")
[10:21:56.748]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:56.748]                       inherits = FALSE)
[10:21:56.748]                   }
[10:21:56.748]                   options(future.plan = NULL)
[10:21:56.748]                   if (is.na(NA_character_)) 
[10:21:56.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:56.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:56.748]                     .init = FALSE)
[10:21:56.748]                 }
[10:21:56.748]             }
[10:21:56.748]         }
[10:21:56.748]     })
[10:21:56.748]     if (TRUE) {
[10:21:56.748]         base::sink(type = "output", split = FALSE)
[10:21:56.748]         if (TRUE) {
[10:21:56.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:56.748]         }
[10:21:56.748]         else {
[10:21:56.748]             ...future.result["stdout"] <- base::list(NULL)
[10:21:56.748]         }
[10:21:56.748]         base::close(...future.stdout)
[10:21:56.748]         ...future.stdout <- NULL
[10:21:56.748]     }
[10:21:56.748]     ...future.result$conditions <- ...future.conditions
[10:21:56.748]     ...future.result$finished <- base::Sys.time()
[10:21:56.748]     ...future.result
[10:21:56.748] }
[10:21:56.750] assign_globals() ...
[10:21:56.750] List of 1
[10:21:56.750]  $ a: num 0
[10:21:56.750]  - attr(*, "where")=List of 1
[10:21:56.750]   ..$ a:<environment: R_EmptyEnv> 
[10:21:56.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:56.750]  - attr(*, "resolved")= logi FALSE
[10:21:56.750]  - attr(*, "total_size")= num 39
[10:21:56.754] - copied ‘a’ to environment
[10:21:56.754] assign_globals() ... done
[10:21:56.754] plan(): Setting new future strategy stack:
[10:21:56.754] List of future strategies:
[10:21:56.754] 1. sequential:
[10:21:56.754]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.754]    - tweaked: FALSE
[10:21:56.754]    - call: NULL
[10:21:56.755] plan(): nbrOfWorkers() = 1
[10:21:56.756] plan(): Setting new future strategy stack:
[10:21:56.756] List of future strategies:
[10:21:56.756] 1. sequential:
[10:21:56.756]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.756]    - tweaked: FALSE
[10:21:56.756]    - call: future::plan("sequential")
[10:21:56.756] plan(): nbrOfWorkers() = 1
[10:21:56.756] SequentialFuture started (and completed)
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[10:21:56.758] getGlobalsAndPackages() ...
[10:21:56.758] Searching for globals...
[10:21:56.758] - globals found: [2] ‘{’, ‘ii’
[10:21:56.759] Searching for globals ... DONE
[10:21:56.759] Resolving globals: FALSE
[10:21:56.759] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:56.759] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:56.759] - globals: [1] ‘ii’
[10:21:56.760] 
[10:21:56.760] getGlobalsAndPackages() ... DONE
 - Creating multisession future #1 ...
[10:21:56.761] getGlobalsAndPackages() ...
[10:21:56.761] Searching for globals...
[10:21:56.762] - globals found: [2] ‘{’, ‘ii’
[10:21:56.762] Searching for globals ... DONE
[10:21:56.762] Resolving globals: FALSE
[10:21:56.763] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:56.763] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:56.763] - globals: [1] ‘ii’
[10:21:56.763] 
[10:21:56.763] getGlobalsAndPackages() ... DONE
 - Resolving 2 multisession futures
[10:21:56.764] Packages needed by the future expression (n = 0): <none>
[10:21:56.764] Packages needed by future strategies (n = 0): <none>
[10:21:56.764] {
[10:21:56.764]     {
[10:21:56.764]         {
[10:21:56.764]             ...future.startTime <- base::Sys.time()
[10:21:56.764]             {
[10:21:56.764]                 {
[10:21:56.764]                   {
[10:21:56.764]                     base::local({
[10:21:56.764]                       has_future <- base::requireNamespace("future", 
[10:21:56.764]                         quietly = TRUE)
[10:21:56.764]                       if (has_future) {
[10:21:56.764]                         ns <- base::getNamespace("future")
[10:21:56.764]                         version <- ns[[".package"]][["version"]]
[10:21:56.764]                         if (is.null(version)) 
[10:21:56.764]                           version <- utils::packageVersion("future")
[10:21:56.764]                       }
[10:21:56.764]                       else {
[10:21:56.764]                         version <- NULL
[10:21:56.764]                       }
[10:21:56.764]                       if (!has_future || version < "1.8.0") {
[10:21:56.764]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:56.764]                           "", base::R.version$version.string), 
[10:21:56.764]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:56.764]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:56.764]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:56.764]                             "release", "version")], collapse = " "), 
[10:21:56.764]                           hostname = base::Sys.info()[["nodename"]])
[10:21:56.764]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:56.764]                           info)
[10:21:56.764]                         info <- base::paste(info, collapse = "; ")
[10:21:56.764]                         if (!has_future) {
[10:21:56.764]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:56.764]                             info)
[10:21:56.764]                         }
[10:21:56.764]                         else {
[10:21:56.764]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:56.764]                             info, version)
[10:21:56.764]                         }
[10:21:56.764]                         base::stop(msg)
[10:21:56.764]                       }
[10:21:56.764]                     })
[10:21:56.764]                   }
[10:21:56.764]                   ...future.strategy.old <- future::plan("list")
[10:21:56.764]                   options(future.plan = NULL)
[10:21:56.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:56.764]                 }
[10:21:56.764]                 ...future.workdir <- getwd()
[10:21:56.764]             }
[10:21:56.764]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:56.764]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:56.764]         }
[10:21:56.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:56.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:56.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:56.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:56.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:56.764]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:56.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:56.764]             base::names(...future.oldOptions))
[10:21:56.764]     }
[10:21:56.764]     if (FALSE) {
[10:21:56.764]     }
[10:21:56.764]     else {
[10:21:56.764]         if (TRUE) {
[10:21:56.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:56.764]                 open = "w")
[10:21:56.764]         }
[10:21:56.764]         else {
[10:21:56.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:56.764]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:56.764]         }
[10:21:56.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:56.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:56.764]             base::sink(type = "output", split = FALSE)
[10:21:56.764]             base::close(...future.stdout)
[10:21:56.764]         }, add = TRUE)
[10:21:56.764]     }
[10:21:56.764]     ...future.frame <- base::sys.nframe()
[10:21:56.764]     ...future.conditions <- base::list()
[10:21:56.764]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:56.764]     if (FALSE) {
[10:21:56.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:56.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:56.764]     }
[10:21:56.764]     ...future.result <- base::tryCatch({
[10:21:56.764]         base::withCallingHandlers({
[10:21:56.764]             ...future.value <- base::withVisible(base::local({
[10:21:56.764]                 ii
[10:21:56.764]             }))
[10:21:56.764]             future::FutureResult(value = ...future.value$value, 
[10:21:56.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.764]                   ...future.rng), globalenv = if (FALSE) 
[10:21:56.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:56.764]                     ...future.globalenv.names))
[10:21:56.764]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:56.764]         }, condition = base::local({
[10:21:56.764]             c <- base::c
[10:21:56.764]             inherits <- base::inherits
[10:21:56.764]             invokeRestart <- base::invokeRestart
[10:21:56.764]             length <- base::length
[10:21:56.764]             list <- base::list
[10:21:56.764]             seq.int <- base::seq.int
[10:21:56.764]             signalCondition <- base::signalCondition
[10:21:56.764]             sys.calls <- base::sys.calls
[10:21:56.764]             `[[` <- base::`[[`
[10:21:56.764]             `+` <- base::`+`
[10:21:56.764]             `<<-` <- base::`<<-`
[10:21:56.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:56.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:56.764]                   3L)]
[10:21:56.764]             }
[10:21:56.764]             function(cond) {
[10:21:56.764]                 is_error <- inherits(cond, "error")
[10:21:56.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:56.764]                   NULL)
[10:21:56.764]                 if (is_error) {
[10:21:56.764]                   sessionInformation <- function() {
[10:21:56.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:56.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:56.764]                       search = base::search(), system = base::Sys.info())
[10:21:56.764]                   }
[10:21:56.764]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:56.764]                     cond$call), session = sessionInformation(), 
[10:21:56.764]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:56.764]                   signalCondition(cond)
[10:21:56.764]                 }
[10:21:56.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:56.764]                 "immediateCondition"))) {
[10:21:56.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:56.764]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:56.764]                   if (TRUE && !signal) {
[10:21:56.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.764]                     {
[10:21:56.764]                       inherits <- base::inherits
[10:21:56.764]                       invokeRestart <- base::invokeRestart
[10:21:56.764]                       is.null <- base::is.null
[10:21:56.764]                       muffled <- FALSE
[10:21:56.764]                       if (inherits(cond, "message")) {
[10:21:56.764]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.764]                         if (muffled) 
[10:21:56.764]                           invokeRestart("muffleMessage")
[10:21:56.764]                       }
[10:21:56.764]                       else if (inherits(cond, "warning")) {
[10:21:56.764]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.764]                         if (muffled) 
[10:21:56.764]                           invokeRestart("muffleWarning")
[10:21:56.764]                       }
[10:21:56.764]                       else if (inherits(cond, "condition")) {
[10:21:56.764]                         if (!is.null(pattern)) {
[10:21:56.764]                           computeRestarts <- base::computeRestarts
[10:21:56.764]                           grepl <- base::grepl
[10:21:56.764]                           restarts <- computeRestarts(cond)
[10:21:56.764]                           for (restart in restarts) {
[10:21:56.764]                             name <- restart$name
[10:21:56.764]                             if (is.null(name)) 
[10:21:56.764]                               next
[10:21:56.764]                             if (!grepl(pattern, name)) 
[10:21:56.764]                               next
[10:21:56.764]                             invokeRestart(restart)
[10:21:56.764]                             muffled <- TRUE
[10:21:56.764]                             break
[10:21:56.764]                           }
[10:21:56.764]                         }
[10:21:56.764]                       }
[10:21:56.764]                       invisible(muffled)
[10:21:56.764]                     }
[10:21:56.764]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.764]                   }
[10:21:56.764]                 }
[10:21:56.764]                 else {
[10:21:56.764]                   if (TRUE) {
[10:21:56.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.764]                     {
[10:21:56.764]                       inherits <- base::inherits
[10:21:56.764]                       invokeRestart <- base::invokeRestart
[10:21:56.764]                       is.null <- base::is.null
[10:21:56.764]                       muffled <- FALSE
[10:21:56.764]                       if (inherits(cond, "message")) {
[10:21:56.764]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.764]                         if (muffled) 
[10:21:56.764]                           invokeRestart("muffleMessage")
[10:21:56.764]                       }
[10:21:56.764]                       else if (inherits(cond, "warning")) {
[10:21:56.764]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.764]                         if (muffled) 
[10:21:56.764]                           invokeRestart("muffleWarning")
[10:21:56.764]                       }
[10:21:56.764]                       else if (inherits(cond, "condition")) {
[10:21:56.764]                         if (!is.null(pattern)) {
[10:21:56.764]                           computeRestarts <- base::computeRestarts
[10:21:56.764]                           grepl <- base::grepl
[10:21:56.764]                           restarts <- computeRestarts(cond)
[10:21:56.764]                           for (restart in restarts) {
[10:21:56.764]                             name <- restart$name
[10:21:56.764]                             if (is.null(name)) 
[10:21:56.764]                               next
[10:21:56.764]                             if (!grepl(pattern, name)) 
[10:21:56.764]                               next
[10:21:56.764]                             invokeRestart(restart)
[10:21:56.764]                             muffled <- TRUE
[10:21:56.764]                             break
[10:21:56.764]                           }
[10:21:56.764]                         }
[10:21:56.764]                       }
[10:21:56.764]                       invisible(muffled)
[10:21:56.764]                     }
[10:21:56.764]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.764]                   }
[10:21:56.764]                 }
[10:21:56.764]             }
[10:21:56.764]         }))
[10:21:56.764]     }, error = function(ex) {
[10:21:56.764]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:56.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.764]                 ...future.rng), started = ...future.startTime, 
[10:21:56.764]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:56.764]             version = "1.8"), class = "FutureResult")
[10:21:56.764]     }, finally = {
[10:21:56.764]         if (!identical(...future.workdir, getwd())) 
[10:21:56.764]             setwd(...future.workdir)
[10:21:56.764]         {
[10:21:56.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:56.764]                 ...future.oldOptions$nwarnings <- NULL
[10:21:56.764]             }
[10:21:56.764]             base::options(...future.oldOptions)
[10:21:56.764]             if (.Platform$OS.type == "windows") {
[10:21:56.764]                 old_names <- names(...future.oldEnvVars)
[10:21:56.764]                 envs <- base::Sys.getenv()
[10:21:56.764]                 names <- names(envs)
[10:21:56.764]                 common <- intersect(names, old_names)
[10:21:56.764]                 added <- setdiff(names, old_names)
[10:21:56.764]                 removed <- setdiff(old_names, names)
[10:21:56.764]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:56.764]                   envs[common]]
[10:21:56.764]                 NAMES <- toupper(changed)
[10:21:56.764]                 args <- list()
[10:21:56.764]                 for (kk in seq_along(NAMES)) {
[10:21:56.764]                   name <- changed[[kk]]
[10:21:56.764]                   NAME <- NAMES[[kk]]
[10:21:56.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.764]                     next
[10:21:56.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.764]                 }
[10:21:56.764]                 NAMES <- toupper(added)
[10:21:56.764]                 for (kk in seq_along(NAMES)) {
[10:21:56.764]                   name <- added[[kk]]
[10:21:56.764]                   NAME <- NAMES[[kk]]
[10:21:56.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.764]                     next
[10:21:56.764]                   args[[name]] <- ""
[10:21:56.764]                 }
[10:21:56.764]                 NAMES <- toupper(removed)
[10:21:56.764]                 for (kk in seq_along(NAMES)) {
[10:21:56.764]                   name <- removed[[kk]]
[10:21:56.764]                   NAME <- NAMES[[kk]]
[10:21:56.764]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.764]                     next
[10:21:56.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.764]                 }
[10:21:56.764]                 if (length(args) > 0) 
[10:21:56.764]                   base::do.call(base::Sys.setenv, args = args)
[10:21:56.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:56.764]             }
[10:21:56.764]             else {
[10:21:56.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:56.764]             }
[10:21:56.764]             {
[10:21:56.764]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:56.764]                   0L) {
[10:21:56.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:56.764]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:56.764]                   base::options(opts)
[10:21:56.764]                 }
[10:21:56.764]                 {
[10:21:56.764]                   {
[10:21:56.764]                     NULL
[10:21:56.764]                     RNGkind("Mersenne-Twister")
[10:21:56.764]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:56.764]                       inherits = FALSE)
[10:21:56.764]                   }
[10:21:56.764]                   options(future.plan = NULL)
[10:21:56.764]                   if (is.na(NA_character_)) 
[10:21:56.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:56.764]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:56.764]                     .init = FALSE)
[10:21:56.764]                 }
[10:21:56.764]             }
[10:21:56.764]         }
[10:21:56.764]     })
[10:21:56.764]     if (TRUE) {
[10:21:56.764]         base::sink(type = "output", split = FALSE)
[10:21:56.764]         if (TRUE) {
[10:21:56.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:56.764]         }
[10:21:56.764]         else {
[10:21:56.764]             ...future.result["stdout"] <- base::list(NULL)
[10:21:56.764]         }
[10:21:56.764]         base::close(...future.stdout)
[10:21:56.764]         ...future.stdout <- NULL
[10:21:56.764]     }
[10:21:56.764]     ...future.result$conditions <- ...future.conditions
[10:21:56.764]     ...future.result$finished <- base::Sys.time()
[10:21:56.764]     ...future.result
[10:21:56.764] }
[10:21:56.766] assign_globals() ...
[10:21:56.766] List of 1
[10:21:56.766]  $ ii: int 1
[10:21:56.766]  - attr(*, "where")=List of 1
[10:21:56.766]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:56.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:56.766]  - attr(*, "resolved")= logi FALSE
[10:21:56.766]  - attr(*, "total_size")= num 35
[10:21:56.768] - copied ‘ii’ to environment
[10:21:56.768] assign_globals() ... done
[10:21:56.768] plan(): Setting new future strategy stack:
[10:21:56.768] List of future strategies:
[10:21:56.768] 1. sequential:
[10:21:56.768]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.768]    - tweaked: FALSE
[10:21:56.768]    - call: NULL
[10:21:56.769] plan(): nbrOfWorkers() = 1
[10:21:56.769] plan(): Setting new future strategy stack:
[10:21:56.770] List of future strategies:
[10:21:56.770] 1. sequential:
[10:21:56.770]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.770]    - tweaked: FALSE
[10:21:56.770]    - call: future::plan("sequential")
[10:21:56.770] plan(): nbrOfWorkers() = 1
[10:21:56.770] SequentialFuture started (and completed)
[10:21:56.770] Packages needed by the future expression (n = 0): <none>
[10:21:56.771] Packages needed by future strategies (n = 0): <none>
[10:21:56.771] {
[10:21:56.771]     {
[10:21:56.771]         {
[10:21:56.771]             ...future.startTime <- base::Sys.time()
[10:21:56.771]             {
[10:21:56.771]                 {
[10:21:56.771]                   {
[10:21:56.771]                     base::local({
[10:21:56.771]                       has_future <- base::requireNamespace("future", 
[10:21:56.771]                         quietly = TRUE)
[10:21:56.771]                       if (has_future) {
[10:21:56.771]                         ns <- base::getNamespace("future")
[10:21:56.771]                         version <- ns[[".package"]][["version"]]
[10:21:56.771]                         if (is.null(version)) 
[10:21:56.771]                           version <- utils::packageVersion("future")
[10:21:56.771]                       }
[10:21:56.771]                       else {
[10:21:56.771]                         version <- NULL
[10:21:56.771]                       }
[10:21:56.771]                       if (!has_future || version < "1.8.0") {
[10:21:56.771]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:56.771]                           "", base::R.version$version.string), 
[10:21:56.771]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:56.771]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:56.771]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:56.771]                             "release", "version")], collapse = " "), 
[10:21:56.771]                           hostname = base::Sys.info()[["nodename"]])
[10:21:56.771]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:56.771]                           info)
[10:21:56.771]                         info <- base::paste(info, collapse = "; ")
[10:21:56.771]                         if (!has_future) {
[10:21:56.771]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:56.771]                             info)
[10:21:56.771]                         }
[10:21:56.771]                         else {
[10:21:56.771]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:56.771]                             info, version)
[10:21:56.771]                         }
[10:21:56.771]                         base::stop(msg)
[10:21:56.771]                       }
[10:21:56.771]                     })
[10:21:56.771]                   }
[10:21:56.771]                   ...future.strategy.old <- future::plan("list")
[10:21:56.771]                   options(future.plan = NULL)
[10:21:56.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:56.771]                 }
[10:21:56.771]                 ...future.workdir <- getwd()
[10:21:56.771]             }
[10:21:56.771]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:56.771]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:56.771]         }
[10:21:56.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:56.771]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:56.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:56.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:56.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:56.771]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:56.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:56.771]             base::names(...future.oldOptions))
[10:21:56.771]     }
[10:21:56.771]     if (FALSE) {
[10:21:56.771]     }
[10:21:56.771]     else {
[10:21:56.771]         if (TRUE) {
[10:21:56.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:56.771]                 open = "w")
[10:21:56.771]         }
[10:21:56.771]         else {
[10:21:56.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:56.771]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:56.771]         }
[10:21:56.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:56.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:56.771]             base::sink(type = "output", split = FALSE)
[10:21:56.771]             base::close(...future.stdout)
[10:21:56.771]         }, add = TRUE)
[10:21:56.771]     }
[10:21:56.771]     ...future.frame <- base::sys.nframe()
[10:21:56.771]     ...future.conditions <- base::list()
[10:21:56.771]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:56.771]     if (FALSE) {
[10:21:56.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:56.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:56.771]     }
[10:21:56.771]     ...future.result <- base::tryCatch({
[10:21:56.771]         base::withCallingHandlers({
[10:21:56.771]             ...future.value <- base::withVisible(base::local({
[10:21:56.771]                 ii
[10:21:56.771]             }))
[10:21:56.771]             future::FutureResult(value = ...future.value$value, 
[10:21:56.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.771]                   ...future.rng), globalenv = if (FALSE) 
[10:21:56.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:56.771]                     ...future.globalenv.names))
[10:21:56.771]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:56.771]         }, condition = base::local({
[10:21:56.771]             c <- base::c
[10:21:56.771]             inherits <- base::inherits
[10:21:56.771]             invokeRestart <- base::invokeRestart
[10:21:56.771]             length <- base::length
[10:21:56.771]             list <- base::list
[10:21:56.771]             seq.int <- base::seq.int
[10:21:56.771]             signalCondition <- base::signalCondition
[10:21:56.771]             sys.calls <- base::sys.calls
[10:21:56.771]             `[[` <- base::`[[`
[10:21:56.771]             `+` <- base::`+`
[10:21:56.771]             `<<-` <- base::`<<-`
[10:21:56.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:56.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:56.771]                   3L)]
[10:21:56.771]             }
[10:21:56.771]             function(cond) {
[10:21:56.771]                 is_error <- inherits(cond, "error")
[10:21:56.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:56.771]                   NULL)
[10:21:56.771]                 if (is_error) {
[10:21:56.771]                   sessionInformation <- function() {
[10:21:56.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:56.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:56.771]                       search = base::search(), system = base::Sys.info())
[10:21:56.771]                   }
[10:21:56.771]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:56.771]                     cond$call), session = sessionInformation(), 
[10:21:56.771]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:56.771]                   signalCondition(cond)
[10:21:56.771]                 }
[10:21:56.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:56.771]                 "immediateCondition"))) {
[10:21:56.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:56.771]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:56.771]                   if (TRUE && !signal) {
[10:21:56.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.771]                     {
[10:21:56.771]                       inherits <- base::inherits
[10:21:56.771]                       invokeRestart <- base::invokeRestart
[10:21:56.771]                       is.null <- base::is.null
[10:21:56.771]                       muffled <- FALSE
[10:21:56.771]                       if (inherits(cond, "message")) {
[10:21:56.771]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.771]                         if (muffled) 
[10:21:56.771]                           invokeRestart("muffleMessage")
[10:21:56.771]                       }
[10:21:56.771]                       else if (inherits(cond, "warning")) {
[10:21:56.771]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.771]                         if (muffled) 
[10:21:56.771]                           invokeRestart("muffleWarning")
[10:21:56.771]                       }
[10:21:56.771]                       else if (inherits(cond, "condition")) {
[10:21:56.771]                         if (!is.null(pattern)) {
[10:21:56.771]                           computeRestarts <- base::computeRestarts
[10:21:56.771]                           grepl <- base::grepl
[10:21:56.771]                           restarts <- computeRestarts(cond)
[10:21:56.771]                           for (restart in restarts) {
[10:21:56.771]                             name <- restart$name
[10:21:56.771]                             if (is.null(name)) 
[10:21:56.771]                               next
[10:21:56.771]                             if (!grepl(pattern, name)) 
[10:21:56.771]                               next
[10:21:56.771]                             invokeRestart(restart)
[10:21:56.771]                             muffled <- TRUE
[10:21:56.771]                             break
[10:21:56.771]                           }
[10:21:56.771]                         }
[10:21:56.771]                       }
[10:21:56.771]                       invisible(muffled)
[10:21:56.771]                     }
[10:21:56.771]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.771]                   }
[10:21:56.771]                 }
[10:21:56.771]                 else {
[10:21:56.771]                   if (TRUE) {
[10:21:56.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.771]                     {
[10:21:56.771]                       inherits <- base::inherits
[10:21:56.771]                       invokeRestart <- base::invokeRestart
[10:21:56.771]                       is.null <- base::is.null
[10:21:56.771]                       muffled <- FALSE
[10:21:56.771]                       if (inherits(cond, "message")) {
[10:21:56.771]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.771]                         if (muffled) 
[10:21:56.771]                           invokeRestart("muffleMessage")
[10:21:56.771]                       }
[10:21:56.771]                       else if (inherits(cond, "warning")) {
[10:21:56.771]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.771]                         if (muffled) 
[10:21:56.771]                           invokeRestart("muffleWarning")
[10:21:56.771]                       }
[10:21:56.771]                       else if (inherits(cond, "condition")) {
[10:21:56.771]                         if (!is.null(pattern)) {
[10:21:56.771]                           computeRestarts <- base::computeRestarts
[10:21:56.771]                           grepl <- base::grepl
[10:21:56.771]                           restarts <- computeRestarts(cond)
[10:21:56.771]                           for (restart in restarts) {
[10:21:56.771]                             name <- restart$name
[10:21:56.771]                             if (is.null(name)) 
[10:21:56.771]                               next
[10:21:56.771]                             if (!grepl(pattern, name)) 
[10:21:56.771]                               next
[10:21:56.771]                             invokeRestart(restart)
[10:21:56.771]                             muffled <- TRUE
[10:21:56.771]                             break
[10:21:56.771]                           }
[10:21:56.771]                         }
[10:21:56.771]                       }
[10:21:56.771]                       invisible(muffled)
[10:21:56.771]                     }
[10:21:56.771]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.771]                   }
[10:21:56.771]                 }
[10:21:56.771]             }
[10:21:56.771]         }))
[10:21:56.771]     }, error = function(ex) {
[10:21:56.771]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:56.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.771]                 ...future.rng), started = ...future.startTime, 
[10:21:56.771]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:56.771]             version = "1.8"), class = "FutureResult")
[10:21:56.771]     }, finally = {
[10:21:56.771]         if (!identical(...future.workdir, getwd())) 
[10:21:56.771]             setwd(...future.workdir)
[10:21:56.771]         {
[10:21:56.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:56.771]                 ...future.oldOptions$nwarnings <- NULL
[10:21:56.771]             }
[10:21:56.771]             base::options(...future.oldOptions)
[10:21:56.771]             if (.Platform$OS.type == "windows") {
[10:21:56.771]                 old_names <- names(...future.oldEnvVars)
[10:21:56.771]                 envs <- base::Sys.getenv()
[10:21:56.771]                 names <- names(envs)
[10:21:56.771]                 common <- intersect(names, old_names)
[10:21:56.771]                 added <- setdiff(names, old_names)
[10:21:56.771]                 removed <- setdiff(old_names, names)
[10:21:56.771]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:56.771]                   envs[common]]
[10:21:56.771]                 NAMES <- toupper(changed)
[10:21:56.771]                 args <- list()
[10:21:56.771]                 for (kk in seq_along(NAMES)) {
[10:21:56.771]                   name <- changed[[kk]]
[10:21:56.771]                   NAME <- NAMES[[kk]]
[10:21:56.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.771]                     next
[10:21:56.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.771]                 }
[10:21:56.771]                 NAMES <- toupper(added)
[10:21:56.771]                 for (kk in seq_along(NAMES)) {
[10:21:56.771]                   name <- added[[kk]]
[10:21:56.771]                   NAME <- NAMES[[kk]]
[10:21:56.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.771]                     next
[10:21:56.771]                   args[[name]] <- ""
[10:21:56.771]                 }
[10:21:56.771]                 NAMES <- toupper(removed)
[10:21:56.771]                 for (kk in seq_along(NAMES)) {
[10:21:56.771]                   name <- removed[[kk]]
[10:21:56.771]                   NAME <- NAMES[[kk]]
[10:21:56.771]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.771]                     next
[10:21:56.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.771]                 }
[10:21:56.771]                 if (length(args) > 0) 
[10:21:56.771]                   base::do.call(base::Sys.setenv, args = args)
[10:21:56.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:56.771]             }
[10:21:56.771]             else {
[10:21:56.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:56.771]             }
[10:21:56.771]             {
[10:21:56.771]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:56.771]                   0L) {
[10:21:56.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:56.771]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:56.771]                   base::options(opts)
[10:21:56.771]                 }
[10:21:56.771]                 {
[10:21:56.771]                   {
[10:21:56.771]                     NULL
[10:21:56.771]                     RNGkind("Mersenne-Twister")
[10:21:56.771]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:56.771]                       inherits = FALSE)
[10:21:56.771]                   }
[10:21:56.771]                   options(future.plan = NULL)
[10:21:56.771]                   if (is.na(NA_character_)) 
[10:21:56.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:56.771]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:56.771]                     .init = FALSE)
[10:21:56.771]                 }
[10:21:56.771]             }
[10:21:56.771]         }
[10:21:56.771]     })
[10:21:56.771]     if (TRUE) {
[10:21:56.771]         base::sink(type = "output", split = FALSE)
[10:21:56.771]         if (TRUE) {
[10:21:56.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:56.771]         }
[10:21:56.771]         else {
[10:21:56.771]             ...future.result["stdout"] <- base::list(NULL)
[10:21:56.771]         }
[10:21:56.771]         base::close(...future.stdout)
[10:21:56.771]         ...future.stdout <- NULL
[10:21:56.771]     }
[10:21:56.771]     ...future.result$conditions <- ...future.conditions
[10:21:56.771]     ...future.result$finished <- base::Sys.time()
[10:21:56.771]     ...future.result
[10:21:56.771] }
[10:21:56.773] assign_globals() ...
[10:21:56.773] List of 1
[10:21:56.773]  $ ii: int 2
[10:21:56.773]  - attr(*, "where")=List of 1
[10:21:56.773]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:56.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:56.773]  - attr(*, "resolved")= logi FALSE
[10:21:56.773]  - attr(*, "total_size")= num 35
[10:21:56.775] - copied ‘ii’ to environment
[10:21:56.775] assign_globals() ... done
[10:21:56.775] plan(): Setting new future strategy stack:
[10:21:56.775] List of future strategies:
[10:21:56.775] 1. sequential:
[10:21:56.775]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.775]    - tweaked: FALSE
[10:21:56.775]    - call: NULL
[10:21:56.776] plan(): nbrOfWorkers() = 1
[10:21:56.776] plan(): Setting new future strategy stack:
[10:21:56.776] List of future strategies:
[10:21:56.776] 1. sequential:
[10:21:56.776]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.776]    - tweaked: FALSE
[10:21:56.776]    - call: future::plan("sequential")
[10:21:56.777] plan(): nbrOfWorkers() = 1
[10:21:56.777] SequentialFuture started (and completed)
*** multisession() - workers inherit .libPaths()
[10:21:56.777] getGlobalsAndPackages() ...
[10:21:56.777] Searching for globals...
[10:21:56.778] - globals found: [1] ‘.libPaths’
[10:21:56.778] Searching for globals ... DONE
[10:21:56.778] Resolving globals: FALSE
[10:21:56.780] 
[10:21:56.780] 
[10:21:56.781] getGlobalsAndPackages() ... DONE
[10:21:56.781] run() for ‘Future’ ...
[10:21:56.781] - state: ‘created’
[10:21:56.781] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:56.781] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:56.782] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:56.782]   - Field: ‘label’
[10:21:56.782]   - Field: ‘local’
[10:21:56.782]   - Field: ‘owner’
[10:21:56.782]   - Field: ‘envir’
[10:21:56.782]   - Field: ‘packages’
[10:21:56.782]   - Field: ‘gc’
[10:21:56.782]   - Field: ‘conditions’
[10:21:56.782]   - Field: ‘expr’
[10:21:56.782]   - Field: ‘uuid’
[10:21:56.783]   - Field: ‘seed’
[10:21:56.783]   - Field: ‘version’
[10:21:56.783]   - Field: ‘result’
[10:21:56.783]   - Field: ‘asynchronous’
[10:21:56.783]   - Field: ‘calls’
[10:21:56.783]   - Field: ‘globals’
[10:21:56.783]   - Field: ‘stdout’
[10:21:56.783]   - Field: ‘earlySignal’
[10:21:56.783]   - Field: ‘lazy’
[10:21:56.783]   - Field: ‘state’
[10:21:56.783] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:56.784] - Launch lazy future ...
[10:21:56.784] Packages needed by the future expression (n = 0): <none>
[10:21:56.784] Packages needed by future strategies (n = 0): <none>
[10:21:56.784] {
[10:21:56.784]     {
[10:21:56.784]         {
[10:21:56.784]             ...future.startTime <- base::Sys.time()
[10:21:56.784]             {
[10:21:56.784]                 {
[10:21:56.784]                   {
[10:21:56.784]                     base::local({
[10:21:56.784]                       has_future <- base::requireNamespace("future", 
[10:21:56.784]                         quietly = TRUE)
[10:21:56.784]                       if (has_future) {
[10:21:56.784]                         ns <- base::getNamespace("future")
[10:21:56.784]                         version <- ns[[".package"]][["version"]]
[10:21:56.784]                         if (is.null(version)) 
[10:21:56.784]                           version <- utils::packageVersion("future")
[10:21:56.784]                       }
[10:21:56.784]                       else {
[10:21:56.784]                         version <- NULL
[10:21:56.784]                       }
[10:21:56.784]                       if (!has_future || version < "1.8.0") {
[10:21:56.784]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:56.784]                           "", base::R.version$version.string), 
[10:21:56.784]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:56.784]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:56.784]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:56.784]                             "release", "version")], collapse = " "), 
[10:21:56.784]                           hostname = base::Sys.info()[["nodename"]])
[10:21:56.784]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:56.784]                           info)
[10:21:56.784]                         info <- base::paste(info, collapse = "; ")
[10:21:56.784]                         if (!has_future) {
[10:21:56.784]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:56.784]                             info)
[10:21:56.784]                         }
[10:21:56.784]                         else {
[10:21:56.784]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:56.784]                             info, version)
[10:21:56.784]                         }
[10:21:56.784]                         base::stop(msg)
[10:21:56.784]                       }
[10:21:56.784]                     })
[10:21:56.784]                   }
[10:21:56.784]                   ...future.strategy.old <- future::plan("list")
[10:21:56.784]                   options(future.plan = NULL)
[10:21:56.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:56.784]                 }
[10:21:56.784]                 ...future.workdir <- getwd()
[10:21:56.784]             }
[10:21:56.784]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:56.784]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:56.784]         }
[10:21:56.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:56.784]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:56.784]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:56.784]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:56.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:56.784]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:56.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:56.784]             base::names(...future.oldOptions))
[10:21:56.784]     }
[10:21:56.784]     if (FALSE) {
[10:21:56.784]     }
[10:21:56.784]     else {
[10:21:56.784]         if (TRUE) {
[10:21:56.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:56.784]                 open = "w")
[10:21:56.784]         }
[10:21:56.784]         else {
[10:21:56.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:56.784]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:56.784]         }
[10:21:56.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:56.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:56.784]             base::sink(type = "output", split = FALSE)
[10:21:56.784]             base::close(...future.stdout)
[10:21:56.784]         }, add = TRUE)
[10:21:56.784]     }
[10:21:56.784]     ...future.frame <- base::sys.nframe()
[10:21:56.784]     ...future.conditions <- base::list()
[10:21:56.784]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:56.784]     if (FALSE) {
[10:21:56.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:56.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:56.784]     }
[10:21:56.784]     ...future.result <- base::tryCatch({
[10:21:56.784]         base::withCallingHandlers({
[10:21:56.784]             ...future.value <- base::withVisible(base::local(.libPaths()))
[10:21:56.784]             future::FutureResult(value = ...future.value$value, 
[10:21:56.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.784]                   ...future.rng), globalenv = if (FALSE) 
[10:21:56.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:56.784]                     ...future.globalenv.names))
[10:21:56.784]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:56.784]         }, condition = base::local({
[10:21:56.784]             c <- base::c
[10:21:56.784]             inherits <- base::inherits
[10:21:56.784]             invokeRestart <- base::invokeRestart
[10:21:56.784]             length <- base::length
[10:21:56.784]             list <- base::list
[10:21:56.784]             seq.int <- base::seq.int
[10:21:56.784]             signalCondition <- base::signalCondition
[10:21:56.784]             sys.calls <- base::sys.calls
[10:21:56.784]             `[[` <- base::`[[`
[10:21:56.784]             `+` <- base::`+`
[10:21:56.784]             `<<-` <- base::`<<-`
[10:21:56.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:56.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:56.784]                   3L)]
[10:21:56.784]             }
[10:21:56.784]             function(cond) {
[10:21:56.784]                 is_error <- inherits(cond, "error")
[10:21:56.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:56.784]                   NULL)
[10:21:56.784]                 if (is_error) {
[10:21:56.784]                   sessionInformation <- function() {
[10:21:56.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:56.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:56.784]                       search = base::search(), system = base::Sys.info())
[10:21:56.784]                   }
[10:21:56.784]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:56.784]                     cond$call), session = sessionInformation(), 
[10:21:56.784]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:56.784]                   signalCondition(cond)
[10:21:56.784]                 }
[10:21:56.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:56.784]                 "immediateCondition"))) {
[10:21:56.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:56.784]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:56.784]                   if (TRUE && !signal) {
[10:21:56.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.784]                     {
[10:21:56.784]                       inherits <- base::inherits
[10:21:56.784]                       invokeRestart <- base::invokeRestart
[10:21:56.784]                       is.null <- base::is.null
[10:21:56.784]                       muffled <- FALSE
[10:21:56.784]                       if (inherits(cond, "message")) {
[10:21:56.784]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.784]                         if (muffled) 
[10:21:56.784]                           invokeRestart("muffleMessage")
[10:21:56.784]                       }
[10:21:56.784]                       else if (inherits(cond, "warning")) {
[10:21:56.784]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.784]                         if (muffled) 
[10:21:56.784]                           invokeRestart("muffleWarning")
[10:21:56.784]                       }
[10:21:56.784]                       else if (inherits(cond, "condition")) {
[10:21:56.784]                         if (!is.null(pattern)) {
[10:21:56.784]                           computeRestarts <- base::computeRestarts
[10:21:56.784]                           grepl <- base::grepl
[10:21:56.784]                           restarts <- computeRestarts(cond)
[10:21:56.784]                           for (restart in restarts) {
[10:21:56.784]                             name <- restart$name
[10:21:56.784]                             if (is.null(name)) 
[10:21:56.784]                               next
[10:21:56.784]                             if (!grepl(pattern, name)) 
[10:21:56.784]                               next
[10:21:56.784]                             invokeRestart(restart)
[10:21:56.784]                             muffled <- TRUE
[10:21:56.784]                             break
[10:21:56.784]                           }
[10:21:56.784]                         }
[10:21:56.784]                       }
[10:21:56.784]                       invisible(muffled)
[10:21:56.784]                     }
[10:21:56.784]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.784]                   }
[10:21:56.784]                 }
[10:21:56.784]                 else {
[10:21:56.784]                   if (TRUE) {
[10:21:56.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.784]                     {
[10:21:56.784]                       inherits <- base::inherits
[10:21:56.784]                       invokeRestart <- base::invokeRestart
[10:21:56.784]                       is.null <- base::is.null
[10:21:56.784]                       muffled <- FALSE
[10:21:56.784]                       if (inherits(cond, "message")) {
[10:21:56.784]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.784]                         if (muffled) 
[10:21:56.784]                           invokeRestart("muffleMessage")
[10:21:56.784]                       }
[10:21:56.784]                       else if (inherits(cond, "warning")) {
[10:21:56.784]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.784]                         if (muffled) 
[10:21:56.784]                           invokeRestart("muffleWarning")
[10:21:56.784]                       }
[10:21:56.784]                       else if (inherits(cond, "condition")) {
[10:21:56.784]                         if (!is.null(pattern)) {
[10:21:56.784]                           computeRestarts <- base::computeRestarts
[10:21:56.784]                           grepl <- base::grepl
[10:21:56.784]                           restarts <- computeRestarts(cond)
[10:21:56.784]                           for (restart in restarts) {
[10:21:56.784]                             name <- restart$name
[10:21:56.784]                             if (is.null(name)) 
[10:21:56.784]                               next
[10:21:56.784]                             if (!grepl(pattern, name)) 
[10:21:56.784]                               next
[10:21:56.784]                             invokeRestart(restart)
[10:21:56.784]                             muffled <- TRUE
[10:21:56.784]                             break
[10:21:56.784]                           }
[10:21:56.784]                         }
[10:21:56.784]                       }
[10:21:56.784]                       invisible(muffled)
[10:21:56.784]                     }
[10:21:56.784]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.784]                   }
[10:21:56.784]                 }
[10:21:56.784]             }
[10:21:56.784]         }))
[10:21:56.784]     }, error = function(ex) {
[10:21:56.784]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:56.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.784]                 ...future.rng), started = ...future.startTime, 
[10:21:56.784]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:56.784]             version = "1.8"), class = "FutureResult")
[10:21:56.784]     }, finally = {
[10:21:56.784]         if (!identical(...future.workdir, getwd())) 
[10:21:56.784]             setwd(...future.workdir)
[10:21:56.784]         {
[10:21:56.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:56.784]                 ...future.oldOptions$nwarnings <- NULL
[10:21:56.784]             }
[10:21:56.784]             base::options(...future.oldOptions)
[10:21:56.784]             if (.Platform$OS.type == "windows") {
[10:21:56.784]                 old_names <- names(...future.oldEnvVars)
[10:21:56.784]                 envs <- base::Sys.getenv()
[10:21:56.784]                 names <- names(envs)
[10:21:56.784]                 common <- intersect(names, old_names)
[10:21:56.784]                 added <- setdiff(names, old_names)
[10:21:56.784]                 removed <- setdiff(old_names, names)
[10:21:56.784]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:56.784]                   envs[common]]
[10:21:56.784]                 NAMES <- toupper(changed)
[10:21:56.784]                 args <- list()
[10:21:56.784]                 for (kk in seq_along(NAMES)) {
[10:21:56.784]                   name <- changed[[kk]]
[10:21:56.784]                   NAME <- NAMES[[kk]]
[10:21:56.784]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.784]                     next
[10:21:56.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.784]                 }
[10:21:56.784]                 NAMES <- toupper(added)
[10:21:56.784]                 for (kk in seq_along(NAMES)) {
[10:21:56.784]                   name <- added[[kk]]
[10:21:56.784]                   NAME <- NAMES[[kk]]
[10:21:56.784]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.784]                     next
[10:21:56.784]                   args[[name]] <- ""
[10:21:56.784]                 }
[10:21:56.784]                 NAMES <- toupper(removed)
[10:21:56.784]                 for (kk in seq_along(NAMES)) {
[10:21:56.784]                   name <- removed[[kk]]
[10:21:56.784]                   NAME <- NAMES[[kk]]
[10:21:56.784]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.784]                     next
[10:21:56.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.784]                 }
[10:21:56.784]                 if (length(args) > 0) 
[10:21:56.784]                   base::do.call(base::Sys.setenv, args = args)
[10:21:56.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:56.784]             }
[10:21:56.784]             else {
[10:21:56.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:56.784]             }
[10:21:56.784]             {
[10:21:56.784]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:56.784]                   0L) {
[10:21:56.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:56.784]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:56.784]                   base::options(opts)
[10:21:56.784]                 }
[10:21:56.784]                 {
[10:21:56.784]                   {
[10:21:56.784]                     NULL
[10:21:56.784]                     RNGkind("Mersenne-Twister")
[10:21:56.784]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:56.784]                       inherits = FALSE)
[10:21:56.784]                   }
[10:21:56.784]                   options(future.plan = NULL)
[10:21:56.784]                   if (is.na(NA_character_)) 
[10:21:56.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:56.784]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:56.784]                     .init = FALSE)
[10:21:56.784]                 }
[10:21:56.784]             }
[10:21:56.784]         }
[10:21:56.784]     })
[10:21:56.784]     if (TRUE) {
[10:21:56.784]         base::sink(type = "output", split = FALSE)
[10:21:56.784]         if (TRUE) {
[10:21:56.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:56.784]         }
[10:21:56.784]         else {
[10:21:56.784]             ...future.result["stdout"] <- base::list(NULL)
[10:21:56.784]         }
[10:21:56.784]         base::close(...future.stdout)
[10:21:56.784]         ...future.stdout <- NULL
[10:21:56.784]     }
[10:21:56.784]     ...future.result$conditions <- ...future.conditions
[10:21:56.784]     ...future.result$finished <- base::Sys.time()
[10:21:56.784]     ...future.result
[10:21:56.784] }
[10:21:56.786] plan(): Setting new future strategy stack:
[10:21:56.786] List of future strategies:
[10:21:56.786] 1. sequential:
[10:21:56.786]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.786]    - tweaked: FALSE
[10:21:56.786]    - call: NULL
[10:21:56.787] plan(): nbrOfWorkers() = 1
[10:21:56.787] plan(): Setting new future strategy stack:
[10:21:56.787] List of future strategies:
[10:21:56.787] 1. sequential:
[10:21:56.787]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.787]    - tweaked: FALSE
[10:21:56.787]    - call: future::plan("sequential")
[10:21:56.788] plan(): nbrOfWorkers() = 1
[10:21:56.788] SequentialFuture started (and completed)
[10:21:56.788] - Launch lazy future ... done
[10:21:56.788] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[10:21:56.791] getGlobalsAndPackages() ...
[10:21:56.791] Searching for globals...
[10:21:56.792] - globals found: [2] ‘{’, ‘stop’
[10:21:56.792] Searching for globals ... DONE
[10:21:56.792] Resolving globals: FALSE
[10:21:56.792] 
[10:21:56.792] 
[10:21:56.792] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 46d13282-a26d-1c6f-65b7-056826eaeb73
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:56.793] Packages needed by the future expression (n = 0): <none>
[10:21:56.793] Packages needed by future strategies (n = 0): <none>
[10:21:56.793] {
[10:21:56.793]     {
[10:21:56.793]         {
[10:21:56.793]             ...future.startTime <- base::Sys.time()
[10:21:56.793]             {
[10:21:56.793]                 {
[10:21:56.793]                   {
[10:21:56.793]                     base::local({
[10:21:56.793]                       has_future <- base::requireNamespace("future", 
[10:21:56.793]                         quietly = TRUE)
[10:21:56.793]                       if (has_future) {
[10:21:56.793]                         ns <- base::getNamespace("future")
[10:21:56.793]                         version <- ns[[".package"]][["version"]]
[10:21:56.793]                         if (is.null(version)) 
[10:21:56.793]                           version <- utils::packageVersion("future")
[10:21:56.793]                       }
[10:21:56.793]                       else {
[10:21:56.793]                         version <- NULL
[10:21:56.793]                       }
[10:21:56.793]                       if (!has_future || version < "1.8.0") {
[10:21:56.793]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:56.793]                           "", base::R.version$version.string), 
[10:21:56.793]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:56.793]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:56.793]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:56.793]                             "release", "version")], collapse = " "), 
[10:21:56.793]                           hostname = base::Sys.info()[["nodename"]])
[10:21:56.793]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:56.793]                           info)
[10:21:56.793]                         info <- base::paste(info, collapse = "; ")
[10:21:56.793]                         if (!has_future) {
[10:21:56.793]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:56.793]                             info)
[10:21:56.793]                         }
[10:21:56.793]                         else {
[10:21:56.793]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:56.793]                             info, version)
[10:21:56.793]                         }
[10:21:56.793]                         base::stop(msg)
[10:21:56.793]                       }
[10:21:56.793]                     })
[10:21:56.793]                   }
[10:21:56.793]                   ...future.strategy.old <- future::plan("list")
[10:21:56.793]                   options(future.plan = NULL)
[10:21:56.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:56.793]                 }
[10:21:56.793]                 ...future.workdir <- getwd()
[10:21:56.793]             }
[10:21:56.793]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:56.793]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:56.793]         }
[10:21:56.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:56.793]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:56.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:56.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:56.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:56.793]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:56.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:56.793]             base::names(...future.oldOptions))
[10:21:56.793]     }
[10:21:56.793]     if (FALSE) {
[10:21:56.793]     }
[10:21:56.793]     else {
[10:21:56.793]         if (TRUE) {
[10:21:56.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:56.793]                 open = "w")
[10:21:56.793]         }
[10:21:56.793]         else {
[10:21:56.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:56.793]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:56.793]         }
[10:21:56.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:56.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:56.793]             base::sink(type = "output", split = FALSE)
[10:21:56.793]             base::close(...future.stdout)
[10:21:56.793]         }, add = TRUE)
[10:21:56.793]     }
[10:21:56.793]     ...future.frame <- base::sys.nframe()
[10:21:56.793]     ...future.conditions <- base::list()
[10:21:56.793]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:56.793]     if (FALSE) {
[10:21:56.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:56.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:56.793]     }
[10:21:56.793]     ...future.result <- base::tryCatch({
[10:21:56.793]         base::withCallingHandlers({
[10:21:56.793]             ...future.value <- base::withVisible(base::local({
[10:21:56.793]                 stop("Whoops!")
[10:21:56.793]                 1
[10:21:56.793]             }))
[10:21:56.793]             future::FutureResult(value = ...future.value$value, 
[10:21:56.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.793]                   ...future.rng), globalenv = if (FALSE) 
[10:21:56.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:56.793]                     ...future.globalenv.names))
[10:21:56.793]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:56.793]         }, condition = base::local({
[10:21:56.793]             c <- base::c
[10:21:56.793]             inherits <- base::inherits
[10:21:56.793]             invokeRestart <- base::invokeRestart
[10:21:56.793]             length <- base::length
[10:21:56.793]             list <- base::list
[10:21:56.793]             seq.int <- base::seq.int
[10:21:56.793]             signalCondition <- base::signalCondition
[10:21:56.793]             sys.calls <- base::sys.calls
[10:21:56.793]             `[[` <- base::`[[`
[10:21:56.793]             `+` <- base::`+`
[10:21:56.793]             `<<-` <- base::`<<-`
[10:21:56.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:56.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:56.793]                   3L)]
[10:21:56.793]             }
[10:21:56.793]             function(cond) {
[10:21:56.793]                 is_error <- inherits(cond, "error")
[10:21:56.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:56.793]                   NULL)
[10:21:56.793]                 if (is_error) {
[10:21:56.793]                   sessionInformation <- function() {
[10:21:56.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:56.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:56.793]                       search = base::search(), system = base::Sys.info())
[10:21:56.793]                   }
[10:21:56.793]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:56.793]                     cond$call), session = sessionInformation(), 
[10:21:56.793]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:56.793]                   signalCondition(cond)
[10:21:56.793]                 }
[10:21:56.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:56.793]                 "immediateCondition"))) {
[10:21:56.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:56.793]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:56.793]                   if (TRUE && !signal) {
[10:21:56.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.793]                     {
[10:21:56.793]                       inherits <- base::inherits
[10:21:56.793]                       invokeRestart <- base::invokeRestart
[10:21:56.793]                       is.null <- base::is.null
[10:21:56.793]                       muffled <- FALSE
[10:21:56.793]                       if (inherits(cond, "message")) {
[10:21:56.793]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.793]                         if (muffled) 
[10:21:56.793]                           invokeRestart("muffleMessage")
[10:21:56.793]                       }
[10:21:56.793]                       else if (inherits(cond, "warning")) {
[10:21:56.793]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.793]                         if (muffled) 
[10:21:56.793]                           invokeRestart("muffleWarning")
[10:21:56.793]                       }
[10:21:56.793]                       else if (inherits(cond, "condition")) {
[10:21:56.793]                         if (!is.null(pattern)) {
[10:21:56.793]                           computeRestarts <- base::computeRestarts
[10:21:56.793]                           grepl <- base::grepl
[10:21:56.793]                           restarts <- computeRestarts(cond)
[10:21:56.793]                           for (restart in restarts) {
[10:21:56.793]                             name <- restart$name
[10:21:56.793]                             if (is.null(name)) 
[10:21:56.793]                               next
[10:21:56.793]                             if (!grepl(pattern, name)) 
[10:21:56.793]                               next
[10:21:56.793]                             invokeRestart(restart)
[10:21:56.793]                             muffled <- TRUE
[10:21:56.793]                             break
[10:21:56.793]                           }
[10:21:56.793]                         }
[10:21:56.793]                       }
[10:21:56.793]                       invisible(muffled)
[10:21:56.793]                     }
[10:21:56.793]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.793]                   }
[10:21:56.793]                 }
[10:21:56.793]                 else {
[10:21:56.793]                   if (TRUE) {
[10:21:56.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.793]                     {
[10:21:56.793]                       inherits <- base::inherits
[10:21:56.793]                       invokeRestart <- base::invokeRestart
[10:21:56.793]                       is.null <- base::is.null
[10:21:56.793]                       muffled <- FALSE
[10:21:56.793]                       if (inherits(cond, "message")) {
[10:21:56.793]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.793]                         if (muffled) 
[10:21:56.793]                           invokeRestart("muffleMessage")
[10:21:56.793]                       }
[10:21:56.793]                       else if (inherits(cond, "warning")) {
[10:21:56.793]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.793]                         if (muffled) 
[10:21:56.793]                           invokeRestart("muffleWarning")
[10:21:56.793]                       }
[10:21:56.793]                       else if (inherits(cond, "condition")) {
[10:21:56.793]                         if (!is.null(pattern)) {
[10:21:56.793]                           computeRestarts <- base::computeRestarts
[10:21:56.793]                           grepl <- base::grepl
[10:21:56.793]                           restarts <- computeRestarts(cond)
[10:21:56.793]                           for (restart in restarts) {
[10:21:56.793]                             name <- restart$name
[10:21:56.793]                             if (is.null(name)) 
[10:21:56.793]                               next
[10:21:56.793]                             if (!grepl(pattern, name)) 
[10:21:56.793]                               next
[10:21:56.793]                             invokeRestart(restart)
[10:21:56.793]                             muffled <- TRUE
[10:21:56.793]                             break
[10:21:56.793]                           }
[10:21:56.793]                         }
[10:21:56.793]                       }
[10:21:56.793]                       invisible(muffled)
[10:21:56.793]                     }
[10:21:56.793]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.793]                   }
[10:21:56.793]                 }
[10:21:56.793]             }
[10:21:56.793]         }))
[10:21:56.793]     }, error = function(ex) {
[10:21:56.793]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:56.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.793]                 ...future.rng), started = ...future.startTime, 
[10:21:56.793]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:56.793]             version = "1.8"), class = "FutureResult")
[10:21:56.793]     }, finally = {
[10:21:56.793]         if (!identical(...future.workdir, getwd())) 
[10:21:56.793]             setwd(...future.workdir)
[10:21:56.793]         {
[10:21:56.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:56.793]                 ...future.oldOptions$nwarnings <- NULL
[10:21:56.793]             }
[10:21:56.793]             base::options(...future.oldOptions)
[10:21:56.793]             if (.Platform$OS.type == "windows") {
[10:21:56.793]                 old_names <- names(...future.oldEnvVars)
[10:21:56.793]                 envs <- base::Sys.getenv()
[10:21:56.793]                 names <- names(envs)
[10:21:56.793]                 common <- intersect(names, old_names)
[10:21:56.793]                 added <- setdiff(names, old_names)
[10:21:56.793]                 removed <- setdiff(old_names, names)
[10:21:56.793]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:56.793]                   envs[common]]
[10:21:56.793]                 NAMES <- toupper(changed)
[10:21:56.793]                 args <- list()
[10:21:56.793]                 for (kk in seq_along(NAMES)) {
[10:21:56.793]                   name <- changed[[kk]]
[10:21:56.793]                   NAME <- NAMES[[kk]]
[10:21:56.793]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.793]                     next
[10:21:56.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.793]                 }
[10:21:56.793]                 NAMES <- toupper(added)
[10:21:56.793]                 for (kk in seq_along(NAMES)) {
[10:21:56.793]                   name <- added[[kk]]
[10:21:56.793]                   NAME <- NAMES[[kk]]
[10:21:56.793]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.793]                     next
[10:21:56.793]                   args[[name]] <- ""
[10:21:56.793]                 }
[10:21:56.793]                 NAMES <- toupper(removed)
[10:21:56.793]                 for (kk in seq_along(NAMES)) {
[10:21:56.793]                   name <- removed[[kk]]
[10:21:56.793]                   NAME <- NAMES[[kk]]
[10:21:56.793]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.793]                     next
[10:21:56.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.793]                 }
[10:21:56.793]                 if (length(args) > 0) 
[10:21:56.793]                   base::do.call(base::Sys.setenv, args = args)
[10:21:56.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:56.793]             }
[10:21:56.793]             else {
[10:21:56.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:56.793]             }
[10:21:56.793]             {
[10:21:56.793]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:56.793]                   0L) {
[10:21:56.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:56.793]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:56.793]                   base::options(opts)
[10:21:56.793]                 }
[10:21:56.793]                 {
[10:21:56.793]                   {
[10:21:56.793]                     NULL
[10:21:56.793]                     RNGkind("Mersenne-Twister")
[10:21:56.793]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:56.793]                       inherits = FALSE)
[10:21:56.793]                   }
[10:21:56.793]                   options(future.plan = NULL)
[10:21:56.793]                   if (is.na(NA_character_)) 
[10:21:56.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:56.793]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:56.793]                     .init = FALSE)
[10:21:56.793]                 }
[10:21:56.793]             }
[10:21:56.793]         }
[10:21:56.793]     })
[10:21:56.793]     if (TRUE) {
[10:21:56.793]         base::sink(type = "output", split = FALSE)
[10:21:56.793]         if (TRUE) {
[10:21:56.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:56.793]         }
[10:21:56.793]         else {
[10:21:56.793]             ...future.result["stdout"] <- base::list(NULL)
[10:21:56.793]         }
[10:21:56.793]         base::close(...future.stdout)
[10:21:56.793]         ...future.stdout <- NULL
[10:21:56.793]     }
[10:21:56.793]     ...future.result$conditions <- ...future.conditions
[10:21:56.793]     ...future.result$finished <- base::Sys.time()
[10:21:56.793]     ...future.result
[10:21:56.793] }
[10:21:56.795] plan(): Setting new future strategy stack:
[10:21:56.795] List of future strategies:
[10:21:56.795] 1. sequential:
[10:21:56.795]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.795]    - tweaked: FALSE
[10:21:56.795]    - call: NULL
[10:21:56.796] plan(): nbrOfWorkers() = 1
[10:21:56.797] plan(): Setting new future strategy stack:
[10:21:56.797] List of future strategies:
[10:21:56.797] 1. sequential:
[10:21:56.797]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.797]    - tweaked: FALSE
[10:21:56.797]    - call: future::plan("sequential")
[10:21:56.797] plan(): nbrOfWorkers() = 1
[10:21:56.797] SequentialFuture started (and completed)
[10:21:56.798] signalConditions() ...
[10:21:56.798]  - include = ‘immediateCondition’
[10:21:56.798]  - exclude = 
[10:21:56.798]  - resignal = FALSE
[10:21:56.798]  - Number of conditions: 1
[10:21:56.798] signalConditions() ... done
[10:21:56.798] signalConditions() ...
[10:21:56.798]  - include = ‘immediateCondition’
[10:21:56.798]  - exclude = 
[10:21:56.798]  - resignal = FALSE
[10:21:56.798]  - Number of conditions: 1
[10:21:56.799] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:21:56.799] signalConditions() ...
[10:21:56.799]  - include = ‘immediateCondition’
[10:21:56.799]  - exclude = 
[10:21:56.799]  - resignal = FALSE
[10:21:56.799]  - Number of conditions: 1
[10:21:56.799] signalConditions() ... done
[10:21:56.799] Future state: ‘finished’
[10:21:56.800] signalConditions() ...
[10:21:56.800]  - include = ‘condition’
[10:21:56.800]  - exclude = ‘immediateCondition’
[10:21:56.800]  - resignal = TRUE
[10:21:56.800]  - Number of conditions: 1
[10:21:56.800]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:56.800] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:21:56.800] signalConditions() ...
[10:21:56.800]  - include = ‘immediateCondition’
[10:21:56.801]  - exclude = 
[10:21:56.801]  - resignal = FALSE
[10:21:56.801]  - Number of conditions: 1
[10:21:56.801] signalConditions() ... done
[10:21:56.801] Future state: ‘finished’
[10:21:56.801] signalConditions() ...
[10:21:56.801]  - include = ‘condition’
[10:21:56.801]  - exclude = ‘immediateCondition’
[10:21:56.801]  - resignal = TRUE
[10:21:56.801]  - Number of conditions: 1
[10:21:56.801]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:56.802] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[10:21:56.803] getGlobalsAndPackages() ...
[10:21:56.803] Searching for globals...
[10:21:56.804] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[10:21:56.805] Searching for globals ... DONE
[10:21:56.805] Resolving globals: FALSE
[10:21:56.805] 
[10:21:56.805] 
[10:21:56.805] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 46d13282-a26d-1c6f-65b7-056826eaeb73
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:56.806] Packages needed by the future expression (n = 0): <none>
[10:21:56.806] Packages needed by future strategies (n = 0): <none>
[10:21:56.806] {
[10:21:56.806]     {
[10:21:56.806]         {
[10:21:56.806]             ...future.startTime <- base::Sys.time()
[10:21:56.806]             {
[10:21:56.806]                 {
[10:21:56.806]                   {
[10:21:56.806]                     base::local({
[10:21:56.806]                       has_future <- base::requireNamespace("future", 
[10:21:56.806]                         quietly = TRUE)
[10:21:56.806]                       if (has_future) {
[10:21:56.806]                         ns <- base::getNamespace("future")
[10:21:56.806]                         version <- ns[[".package"]][["version"]]
[10:21:56.806]                         if (is.null(version)) 
[10:21:56.806]                           version <- utils::packageVersion("future")
[10:21:56.806]                       }
[10:21:56.806]                       else {
[10:21:56.806]                         version <- NULL
[10:21:56.806]                       }
[10:21:56.806]                       if (!has_future || version < "1.8.0") {
[10:21:56.806]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:56.806]                           "", base::R.version$version.string), 
[10:21:56.806]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:56.806]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:56.806]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:56.806]                             "release", "version")], collapse = " "), 
[10:21:56.806]                           hostname = base::Sys.info()[["nodename"]])
[10:21:56.806]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:56.806]                           info)
[10:21:56.806]                         info <- base::paste(info, collapse = "; ")
[10:21:56.806]                         if (!has_future) {
[10:21:56.806]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:56.806]                             info)
[10:21:56.806]                         }
[10:21:56.806]                         else {
[10:21:56.806]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:56.806]                             info, version)
[10:21:56.806]                         }
[10:21:56.806]                         base::stop(msg)
[10:21:56.806]                       }
[10:21:56.806]                     })
[10:21:56.806]                   }
[10:21:56.806]                   ...future.strategy.old <- future::plan("list")
[10:21:56.806]                   options(future.plan = NULL)
[10:21:56.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:56.806]                 }
[10:21:56.806]                 ...future.workdir <- getwd()
[10:21:56.806]             }
[10:21:56.806]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:56.806]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:56.806]         }
[10:21:56.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:56.806]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:56.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:56.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:56.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:56.806]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:56.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:56.806]             base::names(...future.oldOptions))
[10:21:56.806]     }
[10:21:56.806]     if (FALSE) {
[10:21:56.806]     }
[10:21:56.806]     else {
[10:21:56.806]         if (TRUE) {
[10:21:56.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:56.806]                 open = "w")
[10:21:56.806]         }
[10:21:56.806]         else {
[10:21:56.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:56.806]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:56.806]         }
[10:21:56.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:56.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:56.806]             base::sink(type = "output", split = FALSE)
[10:21:56.806]             base::close(...future.stdout)
[10:21:56.806]         }, add = TRUE)
[10:21:56.806]     }
[10:21:56.806]     ...future.frame <- base::sys.nframe()
[10:21:56.806]     ...future.conditions <- base::list()
[10:21:56.806]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:56.806]     if (FALSE) {
[10:21:56.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:56.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:56.806]     }
[10:21:56.806]     ...future.result <- base::tryCatch({
[10:21:56.806]         base::withCallingHandlers({
[10:21:56.806]             ...future.value <- base::withVisible(base::local({
[10:21:56.806]                 stop(structure(list(message = "boom"), class = c("MyError", 
[10:21:56.806]                   "error", "condition")))
[10:21:56.806]             }))
[10:21:56.806]             future::FutureResult(value = ...future.value$value, 
[10:21:56.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.806]                   ...future.rng), globalenv = if (FALSE) 
[10:21:56.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:56.806]                     ...future.globalenv.names))
[10:21:56.806]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:56.806]         }, condition = base::local({
[10:21:56.806]             c <- base::c
[10:21:56.806]             inherits <- base::inherits
[10:21:56.806]             invokeRestart <- base::invokeRestart
[10:21:56.806]             length <- base::length
[10:21:56.806]             list <- base::list
[10:21:56.806]             seq.int <- base::seq.int
[10:21:56.806]             signalCondition <- base::signalCondition
[10:21:56.806]             sys.calls <- base::sys.calls
[10:21:56.806]             `[[` <- base::`[[`
[10:21:56.806]             `+` <- base::`+`
[10:21:56.806]             `<<-` <- base::`<<-`
[10:21:56.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:56.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:56.806]                   3L)]
[10:21:56.806]             }
[10:21:56.806]             function(cond) {
[10:21:56.806]                 is_error <- inherits(cond, "error")
[10:21:56.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:56.806]                   NULL)
[10:21:56.806]                 if (is_error) {
[10:21:56.806]                   sessionInformation <- function() {
[10:21:56.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:56.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:56.806]                       search = base::search(), system = base::Sys.info())
[10:21:56.806]                   }
[10:21:56.806]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:56.806]                     cond$call), session = sessionInformation(), 
[10:21:56.806]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:56.806]                   signalCondition(cond)
[10:21:56.806]                 }
[10:21:56.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:56.806]                 "immediateCondition"))) {
[10:21:56.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:56.806]                   ...future.conditions[[length(...future.conditions) + 
[10:21:56.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:56.806]                   if (TRUE && !signal) {
[10:21:56.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.806]                     {
[10:21:56.806]                       inherits <- base::inherits
[10:21:56.806]                       invokeRestart <- base::invokeRestart
[10:21:56.806]                       is.null <- base::is.null
[10:21:56.806]                       muffled <- FALSE
[10:21:56.806]                       if (inherits(cond, "message")) {
[10:21:56.806]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.806]                         if (muffled) 
[10:21:56.806]                           invokeRestart("muffleMessage")
[10:21:56.806]                       }
[10:21:56.806]                       else if (inherits(cond, "warning")) {
[10:21:56.806]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.806]                         if (muffled) 
[10:21:56.806]                           invokeRestart("muffleWarning")
[10:21:56.806]                       }
[10:21:56.806]                       else if (inherits(cond, "condition")) {
[10:21:56.806]                         if (!is.null(pattern)) {
[10:21:56.806]                           computeRestarts <- base::computeRestarts
[10:21:56.806]                           grepl <- base::grepl
[10:21:56.806]                           restarts <- computeRestarts(cond)
[10:21:56.806]                           for (restart in restarts) {
[10:21:56.806]                             name <- restart$name
[10:21:56.806]                             if (is.null(name)) 
[10:21:56.806]                               next
[10:21:56.806]                             if (!grepl(pattern, name)) 
[10:21:56.806]                               next
[10:21:56.806]                             invokeRestart(restart)
[10:21:56.806]                             muffled <- TRUE
[10:21:56.806]                             break
[10:21:56.806]                           }
[10:21:56.806]                         }
[10:21:56.806]                       }
[10:21:56.806]                       invisible(muffled)
[10:21:56.806]                     }
[10:21:56.806]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.806]                   }
[10:21:56.806]                 }
[10:21:56.806]                 else {
[10:21:56.806]                   if (TRUE) {
[10:21:56.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:56.806]                     {
[10:21:56.806]                       inherits <- base::inherits
[10:21:56.806]                       invokeRestart <- base::invokeRestart
[10:21:56.806]                       is.null <- base::is.null
[10:21:56.806]                       muffled <- FALSE
[10:21:56.806]                       if (inherits(cond, "message")) {
[10:21:56.806]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:56.806]                         if (muffled) 
[10:21:56.806]                           invokeRestart("muffleMessage")
[10:21:56.806]                       }
[10:21:56.806]                       else if (inherits(cond, "warning")) {
[10:21:56.806]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:56.806]                         if (muffled) 
[10:21:56.806]                           invokeRestart("muffleWarning")
[10:21:56.806]                       }
[10:21:56.806]                       else if (inherits(cond, "condition")) {
[10:21:56.806]                         if (!is.null(pattern)) {
[10:21:56.806]                           computeRestarts <- base::computeRestarts
[10:21:56.806]                           grepl <- base::grepl
[10:21:56.806]                           restarts <- computeRestarts(cond)
[10:21:56.806]                           for (restart in restarts) {
[10:21:56.806]                             name <- restart$name
[10:21:56.806]                             if (is.null(name)) 
[10:21:56.806]                               next
[10:21:56.806]                             if (!grepl(pattern, name)) 
[10:21:56.806]                               next
[10:21:56.806]                             invokeRestart(restart)
[10:21:56.806]                             muffled <- TRUE
[10:21:56.806]                             break
[10:21:56.806]                           }
[10:21:56.806]                         }
[10:21:56.806]                       }
[10:21:56.806]                       invisible(muffled)
[10:21:56.806]                     }
[10:21:56.806]                     muffleCondition(cond, pattern = "^muffle")
[10:21:56.806]                   }
[10:21:56.806]                 }
[10:21:56.806]             }
[10:21:56.806]         }))
[10:21:56.806]     }, error = function(ex) {
[10:21:56.806]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:56.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:56.806]                 ...future.rng), started = ...future.startTime, 
[10:21:56.806]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:56.806]             version = "1.8"), class = "FutureResult")
[10:21:56.806]     }, finally = {
[10:21:56.806]         if (!identical(...future.workdir, getwd())) 
[10:21:56.806]             setwd(...future.workdir)
[10:21:56.806]         {
[10:21:56.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:56.806]                 ...future.oldOptions$nwarnings <- NULL
[10:21:56.806]             }
[10:21:56.806]             base::options(...future.oldOptions)
[10:21:56.806]             if (.Platform$OS.type == "windows") {
[10:21:56.806]                 old_names <- names(...future.oldEnvVars)
[10:21:56.806]                 envs <- base::Sys.getenv()
[10:21:56.806]                 names <- names(envs)
[10:21:56.806]                 common <- intersect(names, old_names)
[10:21:56.806]                 added <- setdiff(names, old_names)
[10:21:56.806]                 removed <- setdiff(old_names, names)
[10:21:56.806]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:56.806]                   envs[common]]
[10:21:56.806]                 NAMES <- toupper(changed)
[10:21:56.806]                 args <- list()
[10:21:56.806]                 for (kk in seq_along(NAMES)) {
[10:21:56.806]                   name <- changed[[kk]]
[10:21:56.806]                   NAME <- NAMES[[kk]]
[10:21:56.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.806]                     next
[10:21:56.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.806]                 }
[10:21:56.806]                 NAMES <- toupper(added)
[10:21:56.806]                 for (kk in seq_along(NAMES)) {
[10:21:56.806]                   name <- added[[kk]]
[10:21:56.806]                   NAME <- NAMES[[kk]]
[10:21:56.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.806]                     next
[10:21:56.806]                   args[[name]] <- ""
[10:21:56.806]                 }
[10:21:56.806]                 NAMES <- toupper(removed)
[10:21:56.806]                 for (kk in seq_along(NAMES)) {
[10:21:56.806]                   name <- removed[[kk]]
[10:21:56.806]                   NAME <- NAMES[[kk]]
[10:21:56.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:56.806]                     next
[10:21:56.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:56.806]                 }
[10:21:56.806]                 if (length(args) > 0) 
[10:21:56.806]                   base::do.call(base::Sys.setenv, args = args)
[10:21:56.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:56.806]             }
[10:21:56.806]             else {
[10:21:56.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:56.806]             }
[10:21:56.806]             {
[10:21:56.806]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:56.806]                   0L) {
[10:21:56.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:56.806]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:56.806]                   base::options(opts)
[10:21:56.806]                 }
[10:21:56.806]                 {
[10:21:56.806]                   {
[10:21:56.806]                     NULL
[10:21:56.806]                     RNGkind("Mersenne-Twister")
[10:21:56.806]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:56.806]                       inherits = FALSE)
[10:21:56.806]                   }
[10:21:56.806]                   options(future.plan = NULL)
[10:21:56.806]                   if (is.na(NA_character_)) 
[10:21:56.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:56.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:56.806]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:56.806]                     .init = FALSE)
[10:21:56.806]                 }
[10:21:56.806]             }
[10:21:56.806]         }
[10:21:56.806]     })
[10:21:56.806]     if (TRUE) {
[10:21:56.806]         base::sink(type = "output", split = FALSE)
[10:21:56.806]         if (TRUE) {
[10:21:56.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:56.806]         }
[10:21:56.806]         else {
[10:21:56.806]             ...future.result["stdout"] <- base::list(NULL)
[10:21:56.806]         }
[10:21:56.806]         base::close(...future.stdout)
[10:21:56.806]         ...future.stdout <- NULL
[10:21:56.806]     }
[10:21:56.806]     ...future.result$conditions <- ...future.conditions
[10:21:56.806]     ...future.result$finished <- base::Sys.time()
[10:21:56.806]     ...future.result
[10:21:56.806] }
[10:21:56.808] plan(): Setting new future strategy stack:
[10:21:56.808] List of future strategies:
[10:21:56.808] 1. sequential:
[10:21:56.808]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.808]    - tweaked: FALSE
[10:21:56.808]    - call: NULL
[10:21:56.809] plan(): nbrOfWorkers() = 1
[10:21:56.810] plan(): Setting new future strategy stack:
[10:21:56.810] List of future strategies:
[10:21:56.810] 1. sequential:
[10:21:56.810]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:56.810]    - tweaked: FALSE
[10:21:56.810]    - call: future::plan("sequential")
[10:21:56.810] plan(): nbrOfWorkers() = 1
[10:21:56.810] SequentialFuture started (and completed)
[10:21:56.810] signalConditions() ...
[10:21:56.810]  - include = ‘immediateCondition’
[10:21:56.811]  - exclude = 
[10:21:56.811]  - resignal = FALSE
[10:21:56.811]  - Number of conditions: 1
[10:21:56.811] signalConditions() ... done
[10:21:56.811] signalConditions() ...
[10:21:56.811]  - include = ‘immediateCondition’
[10:21:56.811]  - exclude = 
[10:21:56.811]  - resignal = FALSE
[10:21:56.811]  - Number of conditions: 1
[10:21:56.811] signalConditions() ... done
<MyError: boom>
[10:21:56.812] signalConditions() ...
[10:21:56.812]  - include = ‘immediateCondition’
[10:21:56.812]  - exclude = 
[10:21:56.812]  - resignal = FALSE
[10:21:56.814]  - Number of conditions: 1
[10:21:56.814] signalConditions() ... done
[10:21:56.814] Future state: ‘finished’
[10:21:56.814] signalConditions() ...
[10:21:56.814]  - include = ‘condition’
[10:21:56.814]  - exclude = ‘immediateCondition’
[10:21:56.814]  - resignal = TRUE
[10:21:56.814]  - Number of conditions: 1
[10:21:56.815]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:21:56.815] signalConditions() ... done
Testing with 1 cores ... DONE
Testing with 2 cores ...
[10:21:56.818] getGlobalsAndPackages() ...
[10:21:56.818] 
[10:21:56.818] - globals: [0] <none>
[10:21:56.818] getGlobalsAndPackages() ... DONE
[10:21:57.324] Packages needed by the future expression (n = 0): <none>
[10:21:57.325] Packages needed by future strategies (n = 0): <none>
[10:21:57.325] {
[10:21:57.325]     {
[10:21:57.325]         {
[10:21:57.325]             ...future.startTime <- base::Sys.time()
[10:21:57.325]             {
[10:21:57.325]                 {
[10:21:57.325]                   {
[10:21:57.325]                     {
[10:21:57.325]                       base::local({
[10:21:57.325]                         has_future <- base::requireNamespace("future", 
[10:21:57.325]                           quietly = TRUE)
[10:21:57.325]                         if (has_future) {
[10:21:57.325]                           ns <- base::getNamespace("future")
[10:21:57.325]                           version <- ns[[".package"]][["version"]]
[10:21:57.325]                           if (is.null(version)) 
[10:21:57.325]                             version <- utils::packageVersion("future")
[10:21:57.325]                         }
[10:21:57.325]                         else {
[10:21:57.325]                           version <- NULL
[10:21:57.325]                         }
[10:21:57.325]                         if (!has_future || version < "1.8.0") {
[10:21:57.325]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:57.325]                             "", base::R.version$version.string), 
[10:21:57.325]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:57.325]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:57.325]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:57.325]                               "release", "version")], collapse = " "), 
[10:21:57.325]                             hostname = base::Sys.info()[["nodename"]])
[10:21:57.325]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:57.325]                             info)
[10:21:57.325]                           info <- base::paste(info, collapse = "; ")
[10:21:57.325]                           if (!has_future) {
[10:21:57.325]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:57.325]                               info)
[10:21:57.325]                           }
[10:21:57.325]                           else {
[10:21:57.325]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:57.325]                               info, version)
[10:21:57.325]                           }
[10:21:57.325]                           base::stop(msg)
[10:21:57.325]                         }
[10:21:57.325]                       })
[10:21:57.325]                     }
[10:21:57.325]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:57.325]                     base::options(mc.cores = 1L)
[10:21:57.325]                   }
[10:21:57.325]                   ...future.strategy.old <- future::plan("list")
[10:21:57.325]                   options(future.plan = NULL)
[10:21:57.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:57.325]                 }
[10:21:57.325]                 ...future.workdir <- getwd()
[10:21:57.325]             }
[10:21:57.325]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:57.325]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:57.325]         }
[10:21:57.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:57.325]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:57.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:57.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:57.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:57.325]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:57.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:57.325]             base::names(...future.oldOptions))
[10:21:57.325]     }
[10:21:57.325]     if (FALSE) {
[10:21:57.325]     }
[10:21:57.325]     else {
[10:21:57.325]         if (TRUE) {
[10:21:57.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:57.325]                 open = "w")
[10:21:57.325]         }
[10:21:57.325]         else {
[10:21:57.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:57.325]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:57.325]         }
[10:21:57.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:57.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:57.325]             base::sink(type = "output", split = FALSE)
[10:21:57.325]             base::close(...future.stdout)
[10:21:57.325]         }, add = TRUE)
[10:21:57.325]     }
[10:21:57.325]     ...future.frame <- base::sys.nframe()
[10:21:57.325]     ...future.conditions <- base::list()
[10:21:57.325]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:57.325]     if (FALSE) {
[10:21:57.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:57.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:57.325]     }
[10:21:57.325]     ...future.result <- base::tryCatch({
[10:21:57.325]         base::withCallingHandlers({
[10:21:57.325]             ...future.value <- base::withVisible(base::local({
[10:21:57.325]                 ...future.makeSendCondition <- base::local({
[10:21:57.325]                   sendCondition <- NULL
[10:21:57.325]                   function(frame = 1L) {
[10:21:57.325]                     if (is.function(sendCondition)) 
[10:21:57.325]                       return(sendCondition)
[10:21:57.325]                     ns <- getNamespace("parallel")
[10:21:57.325]                     if (exists("sendData", mode = "function", 
[10:21:57.325]                       envir = ns)) {
[10:21:57.325]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:57.325]                         envir = ns)
[10:21:57.325]                       envir <- sys.frame(frame)
[10:21:57.325]                       master <- NULL
[10:21:57.325]                       while (!identical(envir, .GlobalEnv) && 
[10:21:57.325]                         !identical(envir, emptyenv())) {
[10:21:57.325]                         if (exists("master", mode = "list", envir = envir, 
[10:21:57.325]                           inherits = FALSE)) {
[10:21:57.325]                           master <- get("master", mode = "list", 
[10:21:57.325]                             envir = envir, inherits = FALSE)
[10:21:57.325]                           if (inherits(master, c("SOCKnode", 
[10:21:57.325]                             "SOCK0node"))) {
[10:21:57.325]                             sendCondition <<- function(cond) {
[10:21:57.325]                               data <- list(type = "VALUE", value = cond, 
[10:21:57.325]                                 success = TRUE)
[10:21:57.325]                               parallel_sendData(master, data)
[10:21:57.325]                             }
[10:21:57.325]                             return(sendCondition)
[10:21:57.325]                           }
[10:21:57.325]                         }
[10:21:57.325]                         frame <- frame + 1L
[10:21:57.325]                         envir <- sys.frame(frame)
[10:21:57.325]                       }
[10:21:57.325]                     }
[10:21:57.325]                     sendCondition <<- function(cond) NULL
[10:21:57.325]                   }
[10:21:57.325]                 })
[10:21:57.325]                 withCallingHandlers({
[10:21:57.325]                   {
[10:21:57.325]                     42L
[10:21:57.325]                   }
[10:21:57.325]                 }, immediateCondition = function(cond) {
[10:21:57.325]                   sendCondition <- ...future.makeSendCondition()
[10:21:57.325]                   sendCondition(cond)
[10:21:57.325]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.325]                   {
[10:21:57.325]                     inherits <- base::inherits
[10:21:57.325]                     invokeRestart <- base::invokeRestart
[10:21:57.325]                     is.null <- base::is.null
[10:21:57.325]                     muffled <- FALSE
[10:21:57.325]                     if (inherits(cond, "message")) {
[10:21:57.325]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:57.325]                       if (muffled) 
[10:21:57.325]                         invokeRestart("muffleMessage")
[10:21:57.325]                     }
[10:21:57.325]                     else if (inherits(cond, "warning")) {
[10:21:57.325]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:57.325]                       if (muffled) 
[10:21:57.325]                         invokeRestart("muffleWarning")
[10:21:57.325]                     }
[10:21:57.325]                     else if (inherits(cond, "condition")) {
[10:21:57.325]                       if (!is.null(pattern)) {
[10:21:57.325]                         computeRestarts <- base::computeRestarts
[10:21:57.325]                         grepl <- base::grepl
[10:21:57.325]                         restarts <- computeRestarts(cond)
[10:21:57.325]                         for (restart in restarts) {
[10:21:57.325]                           name <- restart$name
[10:21:57.325]                           if (is.null(name)) 
[10:21:57.325]                             next
[10:21:57.325]                           if (!grepl(pattern, name)) 
[10:21:57.325]                             next
[10:21:57.325]                           invokeRestart(restart)
[10:21:57.325]                           muffled <- TRUE
[10:21:57.325]                           break
[10:21:57.325]                         }
[10:21:57.325]                       }
[10:21:57.325]                     }
[10:21:57.325]                     invisible(muffled)
[10:21:57.325]                   }
[10:21:57.325]                   muffleCondition(cond)
[10:21:57.325]                 })
[10:21:57.325]             }))
[10:21:57.325]             future::FutureResult(value = ...future.value$value, 
[10:21:57.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.325]                   ...future.rng), globalenv = if (FALSE) 
[10:21:57.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:57.325]                     ...future.globalenv.names))
[10:21:57.325]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:57.325]         }, condition = base::local({
[10:21:57.325]             c <- base::c
[10:21:57.325]             inherits <- base::inherits
[10:21:57.325]             invokeRestart <- base::invokeRestart
[10:21:57.325]             length <- base::length
[10:21:57.325]             list <- base::list
[10:21:57.325]             seq.int <- base::seq.int
[10:21:57.325]             signalCondition <- base::signalCondition
[10:21:57.325]             sys.calls <- base::sys.calls
[10:21:57.325]             `[[` <- base::`[[`
[10:21:57.325]             `+` <- base::`+`
[10:21:57.325]             `<<-` <- base::`<<-`
[10:21:57.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:57.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:57.325]                   3L)]
[10:21:57.325]             }
[10:21:57.325]             function(cond) {
[10:21:57.325]                 is_error <- inherits(cond, "error")
[10:21:57.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:57.325]                   NULL)
[10:21:57.325]                 if (is_error) {
[10:21:57.325]                   sessionInformation <- function() {
[10:21:57.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:57.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:57.325]                       search = base::search(), system = base::Sys.info())
[10:21:57.325]                   }
[10:21:57.325]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:57.325]                     cond$call), session = sessionInformation(), 
[10:21:57.325]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:57.325]                   signalCondition(cond)
[10:21:57.325]                 }
[10:21:57.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:57.325]                 "immediateCondition"))) {
[10:21:57.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:57.325]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:57.325]                   if (TRUE && !signal) {
[10:21:57.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.325]                     {
[10:21:57.325]                       inherits <- base::inherits
[10:21:57.325]                       invokeRestart <- base::invokeRestart
[10:21:57.325]                       is.null <- base::is.null
[10:21:57.325]                       muffled <- FALSE
[10:21:57.325]                       if (inherits(cond, "message")) {
[10:21:57.325]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.325]                         if (muffled) 
[10:21:57.325]                           invokeRestart("muffleMessage")
[10:21:57.325]                       }
[10:21:57.325]                       else if (inherits(cond, "warning")) {
[10:21:57.325]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.325]                         if (muffled) 
[10:21:57.325]                           invokeRestart("muffleWarning")
[10:21:57.325]                       }
[10:21:57.325]                       else if (inherits(cond, "condition")) {
[10:21:57.325]                         if (!is.null(pattern)) {
[10:21:57.325]                           computeRestarts <- base::computeRestarts
[10:21:57.325]                           grepl <- base::grepl
[10:21:57.325]                           restarts <- computeRestarts(cond)
[10:21:57.325]                           for (restart in restarts) {
[10:21:57.325]                             name <- restart$name
[10:21:57.325]                             if (is.null(name)) 
[10:21:57.325]                               next
[10:21:57.325]                             if (!grepl(pattern, name)) 
[10:21:57.325]                               next
[10:21:57.325]                             invokeRestart(restart)
[10:21:57.325]                             muffled <- TRUE
[10:21:57.325]                             break
[10:21:57.325]                           }
[10:21:57.325]                         }
[10:21:57.325]                       }
[10:21:57.325]                       invisible(muffled)
[10:21:57.325]                     }
[10:21:57.325]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.325]                   }
[10:21:57.325]                 }
[10:21:57.325]                 else {
[10:21:57.325]                   if (TRUE) {
[10:21:57.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.325]                     {
[10:21:57.325]                       inherits <- base::inherits
[10:21:57.325]                       invokeRestart <- base::invokeRestart
[10:21:57.325]                       is.null <- base::is.null
[10:21:57.325]                       muffled <- FALSE
[10:21:57.325]                       if (inherits(cond, "message")) {
[10:21:57.325]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.325]                         if (muffled) 
[10:21:57.325]                           invokeRestart("muffleMessage")
[10:21:57.325]                       }
[10:21:57.325]                       else if (inherits(cond, "warning")) {
[10:21:57.325]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.325]                         if (muffled) 
[10:21:57.325]                           invokeRestart("muffleWarning")
[10:21:57.325]                       }
[10:21:57.325]                       else if (inherits(cond, "condition")) {
[10:21:57.325]                         if (!is.null(pattern)) {
[10:21:57.325]                           computeRestarts <- base::computeRestarts
[10:21:57.325]                           grepl <- base::grepl
[10:21:57.325]                           restarts <- computeRestarts(cond)
[10:21:57.325]                           for (restart in restarts) {
[10:21:57.325]                             name <- restart$name
[10:21:57.325]                             if (is.null(name)) 
[10:21:57.325]                               next
[10:21:57.325]                             if (!grepl(pattern, name)) 
[10:21:57.325]                               next
[10:21:57.325]                             invokeRestart(restart)
[10:21:57.325]                             muffled <- TRUE
[10:21:57.325]                             break
[10:21:57.325]                           }
[10:21:57.325]                         }
[10:21:57.325]                       }
[10:21:57.325]                       invisible(muffled)
[10:21:57.325]                     }
[10:21:57.325]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.325]                   }
[10:21:57.325]                 }
[10:21:57.325]             }
[10:21:57.325]         }))
[10:21:57.325]     }, error = function(ex) {
[10:21:57.325]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:57.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.325]                 ...future.rng), started = ...future.startTime, 
[10:21:57.325]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:57.325]             version = "1.8"), class = "FutureResult")
[10:21:57.325]     }, finally = {
[10:21:57.325]         if (!identical(...future.workdir, getwd())) 
[10:21:57.325]             setwd(...future.workdir)
[10:21:57.325]         {
[10:21:57.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:57.325]                 ...future.oldOptions$nwarnings <- NULL
[10:21:57.325]             }
[10:21:57.325]             base::options(...future.oldOptions)
[10:21:57.325]             if (.Platform$OS.type == "windows") {
[10:21:57.325]                 old_names <- names(...future.oldEnvVars)
[10:21:57.325]                 envs <- base::Sys.getenv()
[10:21:57.325]                 names <- names(envs)
[10:21:57.325]                 common <- intersect(names, old_names)
[10:21:57.325]                 added <- setdiff(names, old_names)
[10:21:57.325]                 removed <- setdiff(old_names, names)
[10:21:57.325]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:57.325]                   envs[common]]
[10:21:57.325]                 NAMES <- toupper(changed)
[10:21:57.325]                 args <- list()
[10:21:57.325]                 for (kk in seq_along(NAMES)) {
[10:21:57.325]                   name <- changed[[kk]]
[10:21:57.325]                   NAME <- NAMES[[kk]]
[10:21:57.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.325]                     next
[10:21:57.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.325]                 }
[10:21:57.325]                 NAMES <- toupper(added)
[10:21:57.325]                 for (kk in seq_along(NAMES)) {
[10:21:57.325]                   name <- added[[kk]]
[10:21:57.325]                   NAME <- NAMES[[kk]]
[10:21:57.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.325]                     next
[10:21:57.325]                   args[[name]] <- ""
[10:21:57.325]                 }
[10:21:57.325]                 NAMES <- toupper(removed)
[10:21:57.325]                 for (kk in seq_along(NAMES)) {
[10:21:57.325]                   name <- removed[[kk]]
[10:21:57.325]                   NAME <- NAMES[[kk]]
[10:21:57.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.325]                     next
[10:21:57.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.325]                 }
[10:21:57.325]                 if (length(args) > 0) 
[10:21:57.325]                   base::do.call(base::Sys.setenv, args = args)
[10:21:57.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:57.325]             }
[10:21:57.325]             else {
[10:21:57.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:57.325]             }
[10:21:57.325]             {
[10:21:57.325]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:57.325]                   0L) {
[10:21:57.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:57.325]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:57.325]                   base::options(opts)
[10:21:57.325]                 }
[10:21:57.325]                 {
[10:21:57.325]                   {
[10:21:57.325]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:57.325]                     NULL
[10:21:57.325]                   }
[10:21:57.325]                   options(future.plan = NULL)
[10:21:57.325]                   if (is.na(NA_character_)) 
[10:21:57.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:57.325]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:57.325]                     .init = FALSE)
[10:21:57.325]                 }
[10:21:57.325]             }
[10:21:57.325]         }
[10:21:57.325]     })
[10:21:57.325]     if (TRUE) {
[10:21:57.325]         base::sink(type = "output", split = FALSE)
[10:21:57.325]         if (TRUE) {
[10:21:57.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:57.325]         }
[10:21:57.325]         else {
[10:21:57.325]             ...future.result["stdout"] <- base::list(NULL)
[10:21:57.325]         }
[10:21:57.325]         base::close(...future.stdout)
[10:21:57.325]         ...future.stdout <- NULL
[10:21:57.325]     }
[10:21:57.325]     ...future.result$conditions <- ...future.conditions
[10:21:57.325]     ...future.result$finished <- base::Sys.time()
[10:21:57.325]     ...future.result
[10:21:57.325] }
[10:21:57.378] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 46d13282-a26d-1c6f-65b7-056826eaeb73
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] FALSE
[10:21:57.400] result() for ClusterFuture ...
[10:21:57.401] receiveMessageFromWorker() for ClusterFuture ...
[10:21:57.401] - Validating connection of MultisessionFuture
[10:21:57.409] - received message: FutureResult
[10:21:57.409] - Received FutureResult
[10:21:57.412] - Erased future from FutureRegistry
[10:21:57.412] result() for ClusterFuture ...
[10:21:57.412] - result already collected: FutureResult
[10:21:57.412] result() for ClusterFuture ... done
[10:21:57.412] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:57.412] result() for ClusterFuture ... done
[10:21:57.412] result() for ClusterFuture ...
[10:21:57.412] - result already collected: FutureResult
[10:21:57.412] result() for ClusterFuture ... done
[1] 42
[10:21:57.414] getGlobalsAndPackages() ...
[10:21:57.414] Searching for globals...
[10:21:57.416] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[10:21:57.416] Searching for globals ... DONE
[10:21:57.416] Resolving globals: FALSE
[10:21:57.416] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:57.417] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:57.417] - globals: [1] ‘a’
[10:21:57.417] 
[10:21:57.417] getGlobalsAndPackages() ... DONE
[10:21:57.430] Packages needed by the future expression (n = 0): <none>
[10:21:57.430] Packages needed by future strategies (n = 0): <none>
[10:21:57.430] {
[10:21:57.430]     {
[10:21:57.430]         {
[10:21:57.430]             ...future.startTime <- base::Sys.time()
[10:21:57.430]             {
[10:21:57.430]                 {
[10:21:57.430]                   {
[10:21:57.430]                     {
[10:21:57.430]                       base::local({
[10:21:57.430]                         has_future <- base::requireNamespace("future", 
[10:21:57.430]                           quietly = TRUE)
[10:21:57.430]                         if (has_future) {
[10:21:57.430]                           ns <- base::getNamespace("future")
[10:21:57.430]                           version <- ns[[".package"]][["version"]]
[10:21:57.430]                           if (is.null(version)) 
[10:21:57.430]                             version <- utils::packageVersion("future")
[10:21:57.430]                         }
[10:21:57.430]                         else {
[10:21:57.430]                           version <- NULL
[10:21:57.430]                         }
[10:21:57.430]                         if (!has_future || version < "1.8.0") {
[10:21:57.430]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:57.430]                             "", base::R.version$version.string), 
[10:21:57.430]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:57.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:57.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:57.430]                               "release", "version")], collapse = " "), 
[10:21:57.430]                             hostname = base::Sys.info()[["nodename"]])
[10:21:57.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:57.430]                             info)
[10:21:57.430]                           info <- base::paste(info, collapse = "; ")
[10:21:57.430]                           if (!has_future) {
[10:21:57.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:57.430]                               info)
[10:21:57.430]                           }
[10:21:57.430]                           else {
[10:21:57.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:57.430]                               info, version)
[10:21:57.430]                           }
[10:21:57.430]                           base::stop(msg)
[10:21:57.430]                         }
[10:21:57.430]                       })
[10:21:57.430]                     }
[10:21:57.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:57.430]                     base::options(mc.cores = 1L)
[10:21:57.430]                   }
[10:21:57.430]                   ...future.strategy.old <- future::plan("list")
[10:21:57.430]                   options(future.plan = NULL)
[10:21:57.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:57.430]                 }
[10:21:57.430]                 ...future.workdir <- getwd()
[10:21:57.430]             }
[10:21:57.430]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:57.430]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:57.430]         }
[10:21:57.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:57.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:57.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:57.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:57.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:57.430]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:57.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:57.430]             base::names(...future.oldOptions))
[10:21:57.430]     }
[10:21:57.430]     if (FALSE) {
[10:21:57.430]     }
[10:21:57.430]     else {
[10:21:57.430]         if (TRUE) {
[10:21:57.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:57.430]                 open = "w")
[10:21:57.430]         }
[10:21:57.430]         else {
[10:21:57.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:57.430]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:57.430]         }
[10:21:57.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:57.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:57.430]             base::sink(type = "output", split = FALSE)
[10:21:57.430]             base::close(...future.stdout)
[10:21:57.430]         }, add = TRUE)
[10:21:57.430]     }
[10:21:57.430]     ...future.frame <- base::sys.nframe()
[10:21:57.430]     ...future.conditions <- base::list()
[10:21:57.430]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:57.430]     if (FALSE) {
[10:21:57.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:57.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:57.430]     }
[10:21:57.430]     ...future.result <- base::tryCatch({
[10:21:57.430]         base::withCallingHandlers({
[10:21:57.430]             ...future.value <- base::withVisible(base::local({
[10:21:57.430]                 ...future.makeSendCondition <- base::local({
[10:21:57.430]                   sendCondition <- NULL
[10:21:57.430]                   function(frame = 1L) {
[10:21:57.430]                     if (is.function(sendCondition)) 
[10:21:57.430]                       return(sendCondition)
[10:21:57.430]                     ns <- getNamespace("parallel")
[10:21:57.430]                     if (exists("sendData", mode = "function", 
[10:21:57.430]                       envir = ns)) {
[10:21:57.430]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:57.430]                         envir = ns)
[10:21:57.430]                       envir <- sys.frame(frame)
[10:21:57.430]                       master <- NULL
[10:21:57.430]                       while (!identical(envir, .GlobalEnv) && 
[10:21:57.430]                         !identical(envir, emptyenv())) {
[10:21:57.430]                         if (exists("master", mode = "list", envir = envir, 
[10:21:57.430]                           inherits = FALSE)) {
[10:21:57.430]                           master <- get("master", mode = "list", 
[10:21:57.430]                             envir = envir, inherits = FALSE)
[10:21:57.430]                           if (inherits(master, c("SOCKnode", 
[10:21:57.430]                             "SOCK0node"))) {
[10:21:57.430]                             sendCondition <<- function(cond) {
[10:21:57.430]                               data <- list(type = "VALUE", value = cond, 
[10:21:57.430]                                 success = TRUE)
[10:21:57.430]                               parallel_sendData(master, data)
[10:21:57.430]                             }
[10:21:57.430]                             return(sendCondition)
[10:21:57.430]                           }
[10:21:57.430]                         }
[10:21:57.430]                         frame <- frame + 1L
[10:21:57.430]                         envir <- sys.frame(frame)
[10:21:57.430]                       }
[10:21:57.430]                     }
[10:21:57.430]                     sendCondition <<- function(cond) NULL
[10:21:57.430]                   }
[10:21:57.430]                 })
[10:21:57.430]                 withCallingHandlers({
[10:21:57.430]                   {
[10:21:57.430]                     b <- 3
[10:21:57.430]                     c <- 2
[10:21:57.430]                     a * b * c
[10:21:57.430]                   }
[10:21:57.430]                 }, immediateCondition = function(cond) {
[10:21:57.430]                   sendCondition <- ...future.makeSendCondition()
[10:21:57.430]                   sendCondition(cond)
[10:21:57.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.430]                   {
[10:21:57.430]                     inherits <- base::inherits
[10:21:57.430]                     invokeRestart <- base::invokeRestart
[10:21:57.430]                     is.null <- base::is.null
[10:21:57.430]                     muffled <- FALSE
[10:21:57.430]                     if (inherits(cond, "message")) {
[10:21:57.430]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:57.430]                       if (muffled) 
[10:21:57.430]                         invokeRestart("muffleMessage")
[10:21:57.430]                     }
[10:21:57.430]                     else if (inherits(cond, "warning")) {
[10:21:57.430]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:57.430]                       if (muffled) 
[10:21:57.430]                         invokeRestart("muffleWarning")
[10:21:57.430]                     }
[10:21:57.430]                     else if (inherits(cond, "condition")) {
[10:21:57.430]                       if (!is.null(pattern)) {
[10:21:57.430]                         computeRestarts <- base::computeRestarts
[10:21:57.430]                         grepl <- base::grepl
[10:21:57.430]                         restarts <- computeRestarts(cond)
[10:21:57.430]                         for (restart in restarts) {
[10:21:57.430]                           name <- restart$name
[10:21:57.430]                           if (is.null(name)) 
[10:21:57.430]                             next
[10:21:57.430]                           if (!grepl(pattern, name)) 
[10:21:57.430]                             next
[10:21:57.430]                           invokeRestart(restart)
[10:21:57.430]                           muffled <- TRUE
[10:21:57.430]                           break
[10:21:57.430]                         }
[10:21:57.430]                       }
[10:21:57.430]                     }
[10:21:57.430]                     invisible(muffled)
[10:21:57.430]                   }
[10:21:57.430]                   muffleCondition(cond)
[10:21:57.430]                 })
[10:21:57.430]             }))
[10:21:57.430]             future::FutureResult(value = ...future.value$value, 
[10:21:57.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.430]                   ...future.rng), globalenv = if (FALSE) 
[10:21:57.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:57.430]                     ...future.globalenv.names))
[10:21:57.430]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:57.430]         }, condition = base::local({
[10:21:57.430]             c <- base::c
[10:21:57.430]             inherits <- base::inherits
[10:21:57.430]             invokeRestart <- base::invokeRestart
[10:21:57.430]             length <- base::length
[10:21:57.430]             list <- base::list
[10:21:57.430]             seq.int <- base::seq.int
[10:21:57.430]             signalCondition <- base::signalCondition
[10:21:57.430]             sys.calls <- base::sys.calls
[10:21:57.430]             `[[` <- base::`[[`
[10:21:57.430]             `+` <- base::`+`
[10:21:57.430]             `<<-` <- base::`<<-`
[10:21:57.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:57.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:57.430]                   3L)]
[10:21:57.430]             }
[10:21:57.430]             function(cond) {
[10:21:57.430]                 is_error <- inherits(cond, "error")
[10:21:57.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:57.430]                   NULL)
[10:21:57.430]                 if (is_error) {
[10:21:57.430]                   sessionInformation <- function() {
[10:21:57.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:57.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:57.430]                       search = base::search(), system = base::Sys.info())
[10:21:57.430]                   }
[10:21:57.430]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:57.430]                     cond$call), session = sessionInformation(), 
[10:21:57.430]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:57.430]                   signalCondition(cond)
[10:21:57.430]                 }
[10:21:57.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:57.430]                 "immediateCondition"))) {
[10:21:57.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:57.430]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:57.430]                   if (TRUE && !signal) {
[10:21:57.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.430]                     {
[10:21:57.430]                       inherits <- base::inherits
[10:21:57.430]                       invokeRestart <- base::invokeRestart
[10:21:57.430]                       is.null <- base::is.null
[10:21:57.430]                       muffled <- FALSE
[10:21:57.430]                       if (inherits(cond, "message")) {
[10:21:57.430]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.430]                         if (muffled) 
[10:21:57.430]                           invokeRestart("muffleMessage")
[10:21:57.430]                       }
[10:21:57.430]                       else if (inherits(cond, "warning")) {
[10:21:57.430]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.430]                         if (muffled) 
[10:21:57.430]                           invokeRestart("muffleWarning")
[10:21:57.430]                       }
[10:21:57.430]                       else if (inherits(cond, "condition")) {
[10:21:57.430]                         if (!is.null(pattern)) {
[10:21:57.430]                           computeRestarts <- base::computeRestarts
[10:21:57.430]                           grepl <- base::grepl
[10:21:57.430]                           restarts <- computeRestarts(cond)
[10:21:57.430]                           for (restart in restarts) {
[10:21:57.430]                             name <- restart$name
[10:21:57.430]                             if (is.null(name)) 
[10:21:57.430]                               next
[10:21:57.430]                             if (!grepl(pattern, name)) 
[10:21:57.430]                               next
[10:21:57.430]                             invokeRestart(restart)
[10:21:57.430]                             muffled <- TRUE
[10:21:57.430]                             break
[10:21:57.430]                           }
[10:21:57.430]                         }
[10:21:57.430]                       }
[10:21:57.430]                       invisible(muffled)
[10:21:57.430]                     }
[10:21:57.430]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.430]                   }
[10:21:57.430]                 }
[10:21:57.430]                 else {
[10:21:57.430]                   if (TRUE) {
[10:21:57.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.430]                     {
[10:21:57.430]                       inherits <- base::inherits
[10:21:57.430]                       invokeRestart <- base::invokeRestart
[10:21:57.430]                       is.null <- base::is.null
[10:21:57.430]                       muffled <- FALSE
[10:21:57.430]                       if (inherits(cond, "message")) {
[10:21:57.430]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.430]                         if (muffled) 
[10:21:57.430]                           invokeRestart("muffleMessage")
[10:21:57.430]                       }
[10:21:57.430]                       else if (inherits(cond, "warning")) {
[10:21:57.430]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.430]                         if (muffled) 
[10:21:57.430]                           invokeRestart("muffleWarning")
[10:21:57.430]                       }
[10:21:57.430]                       else if (inherits(cond, "condition")) {
[10:21:57.430]                         if (!is.null(pattern)) {
[10:21:57.430]                           computeRestarts <- base::computeRestarts
[10:21:57.430]                           grepl <- base::grepl
[10:21:57.430]                           restarts <- computeRestarts(cond)
[10:21:57.430]                           for (restart in restarts) {
[10:21:57.430]                             name <- restart$name
[10:21:57.430]                             if (is.null(name)) 
[10:21:57.430]                               next
[10:21:57.430]                             if (!grepl(pattern, name)) 
[10:21:57.430]                               next
[10:21:57.430]                             invokeRestart(restart)
[10:21:57.430]                             muffled <- TRUE
[10:21:57.430]                             break
[10:21:57.430]                           }
[10:21:57.430]                         }
[10:21:57.430]                       }
[10:21:57.430]                       invisible(muffled)
[10:21:57.430]                     }
[10:21:57.430]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.430]                   }
[10:21:57.430]                 }
[10:21:57.430]             }
[10:21:57.430]         }))
[10:21:57.430]     }, error = function(ex) {
[10:21:57.430]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:57.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.430]                 ...future.rng), started = ...future.startTime, 
[10:21:57.430]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:57.430]             version = "1.8"), class = "FutureResult")
[10:21:57.430]     }, finally = {
[10:21:57.430]         if (!identical(...future.workdir, getwd())) 
[10:21:57.430]             setwd(...future.workdir)
[10:21:57.430]         {
[10:21:57.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:57.430]                 ...future.oldOptions$nwarnings <- NULL
[10:21:57.430]             }
[10:21:57.430]             base::options(...future.oldOptions)
[10:21:57.430]             if (.Platform$OS.type == "windows") {
[10:21:57.430]                 old_names <- names(...future.oldEnvVars)
[10:21:57.430]                 envs <- base::Sys.getenv()
[10:21:57.430]                 names <- names(envs)
[10:21:57.430]                 common <- intersect(names, old_names)
[10:21:57.430]                 added <- setdiff(names, old_names)
[10:21:57.430]                 removed <- setdiff(old_names, names)
[10:21:57.430]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:57.430]                   envs[common]]
[10:21:57.430]                 NAMES <- toupper(changed)
[10:21:57.430]                 args <- list()
[10:21:57.430]                 for (kk in seq_along(NAMES)) {
[10:21:57.430]                   name <- changed[[kk]]
[10:21:57.430]                   NAME <- NAMES[[kk]]
[10:21:57.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.430]                     next
[10:21:57.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.430]                 }
[10:21:57.430]                 NAMES <- toupper(added)
[10:21:57.430]                 for (kk in seq_along(NAMES)) {
[10:21:57.430]                   name <- added[[kk]]
[10:21:57.430]                   NAME <- NAMES[[kk]]
[10:21:57.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.430]                     next
[10:21:57.430]                   args[[name]] <- ""
[10:21:57.430]                 }
[10:21:57.430]                 NAMES <- toupper(removed)
[10:21:57.430]                 for (kk in seq_along(NAMES)) {
[10:21:57.430]                   name <- removed[[kk]]
[10:21:57.430]                   NAME <- NAMES[[kk]]
[10:21:57.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.430]                     next
[10:21:57.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.430]                 }
[10:21:57.430]                 if (length(args) > 0) 
[10:21:57.430]                   base::do.call(base::Sys.setenv, args = args)
[10:21:57.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:57.430]             }
[10:21:57.430]             else {
[10:21:57.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:57.430]             }
[10:21:57.430]             {
[10:21:57.430]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:57.430]                   0L) {
[10:21:57.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:57.430]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:57.430]                   base::options(opts)
[10:21:57.430]                 }
[10:21:57.430]                 {
[10:21:57.430]                   {
[10:21:57.430]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:57.430]                     NULL
[10:21:57.430]                   }
[10:21:57.430]                   options(future.plan = NULL)
[10:21:57.430]                   if (is.na(NA_character_)) 
[10:21:57.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:57.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:57.430]                     .init = FALSE)
[10:21:57.430]                 }
[10:21:57.430]             }
[10:21:57.430]         }
[10:21:57.430]     })
[10:21:57.430]     if (TRUE) {
[10:21:57.430]         base::sink(type = "output", split = FALSE)
[10:21:57.430]         if (TRUE) {
[10:21:57.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:57.430]         }
[10:21:57.430]         else {
[10:21:57.430]             ...future.result["stdout"] <- base::list(NULL)
[10:21:57.430]         }
[10:21:57.430]         base::close(...future.stdout)
[10:21:57.430]         ...future.stdout <- NULL
[10:21:57.430]     }
[10:21:57.430]     ...future.result$conditions <- ...future.conditions
[10:21:57.430]     ...future.result$finished <- base::Sys.time()
[10:21:57.430]     ...future.result
[10:21:57.430] }
[10:21:57.433] Exporting 1 global objects (306 bytes) to cluster node #1 ...
[10:21:57.433] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:57.433] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:57.433] Exporting 1 global objects (306 bytes) to cluster node #1 ... DONE
[10:21:57.434] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 39 bytes (numeric ‘a’ of 39 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 46d13282-a26d-1c6f-65b7-056826eaeb73
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:57.445] result() for ClusterFuture ...
[10:21:57.445] receiveMessageFromWorker() for ClusterFuture ...
[10:21:57.445] - Validating connection of MultisessionFuture
[10:21:57.476] - received message: FutureResult
[10:21:57.476] - Received FutureResult
[10:21:57.476] - Erased future from FutureRegistry
[10:21:57.476] result() for ClusterFuture ...
[10:21:57.477] - result already collected: FutureResult
[10:21:57.477] result() for ClusterFuture ... done
[10:21:57.477] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:57.477] result() for ClusterFuture ... done
[10:21:57.477] result() for ClusterFuture ...
[10:21:57.477] - result already collected: FutureResult
[10:21:57.477] result() for ClusterFuture ... done
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[10:21:57.479] getGlobalsAndPackages() ...
[10:21:57.479] Searching for globals...
[10:21:57.479] - globals found: [2] ‘{’, ‘ii’
[10:21:57.480] Searching for globals ... DONE
[10:21:57.480] Resolving globals: FALSE
[10:21:57.480] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:57.480] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:57.480] - globals: [1] ‘ii’
[10:21:57.481] 
[10:21:57.481] getGlobalsAndPackages() ... DONE
[10:21:57.496] Packages needed by the future expression (n = 0): <none>
[10:21:57.496] Packages needed by future strategies (n = 0): <none>
[10:21:57.496] {
[10:21:57.496]     {
[10:21:57.496]         {
[10:21:57.496]             ...future.startTime <- base::Sys.time()
[10:21:57.496]             {
[10:21:57.496]                 {
[10:21:57.496]                   {
[10:21:57.496]                     {
[10:21:57.496]                       base::local({
[10:21:57.496]                         has_future <- base::requireNamespace("future", 
[10:21:57.496]                           quietly = TRUE)
[10:21:57.496]                         if (has_future) {
[10:21:57.496]                           ns <- base::getNamespace("future")
[10:21:57.496]                           version <- ns[[".package"]][["version"]]
[10:21:57.496]                           if (is.null(version)) 
[10:21:57.496]                             version <- utils::packageVersion("future")
[10:21:57.496]                         }
[10:21:57.496]                         else {
[10:21:57.496]                           version <- NULL
[10:21:57.496]                         }
[10:21:57.496]                         if (!has_future || version < "1.8.0") {
[10:21:57.496]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:57.496]                             "", base::R.version$version.string), 
[10:21:57.496]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:57.496]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:57.496]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:57.496]                               "release", "version")], collapse = " "), 
[10:21:57.496]                             hostname = base::Sys.info()[["nodename"]])
[10:21:57.496]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:57.496]                             info)
[10:21:57.496]                           info <- base::paste(info, collapse = "; ")
[10:21:57.496]                           if (!has_future) {
[10:21:57.496]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:57.496]                               info)
[10:21:57.496]                           }
[10:21:57.496]                           else {
[10:21:57.496]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:57.496]                               info, version)
[10:21:57.496]                           }
[10:21:57.496]                           base::stop(msg)
[10:21:57.496]                         }
[10:21:57.496]                       })
[10:21:57.496]                     }
[10:21:57.496]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:57.496]                     base::options(mc.cores = 1L)
[10:21:57.496]                   }
[10:21:57.496]                   ...future.strategy.old <- future::plan("list")
[10:21:57.496]                   options(future.plan = NULL)
[10:21:57.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:57.496]                 }
[10:21:57.496]                 ...future.workdir <- getwd()
[10:21:57.496]             }
[10:21:57.496]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:57.496]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:57.496]         }
[10:21:57.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:57.496]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:57.496]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:57.496]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:57.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:57.496]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:57.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:57.496]             base::names(...future.oldOptions))
[10:21:57.496]     }
[10:21:57.496]     if (FALSE) {
[10:21:57.496]     }
[10:21:57.496]     else {
[10:21:57.496]         if (TRUE) {
[10:21:57.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:57.496]                 open = "w")
[10:21:57.496]         }
[10:21:57.496]         else {
[10:21:57.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:57.496]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:57.496]         }
[10:21:57.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:57.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:57.496]             base::sink(type = "output", split = FALSE)
[10:21:57.496]             base::close(...future.stdout)
[10:21:57.496]         }, add = TRUE)
[10:21:57.496]     }
[10:21:57.496]     ...future.frame <- base::sys.nframe()
[10:21:57.496]     ...future.conditions <- base::list()
[10:21:57.496]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:57.496]     if (FALSE) {
[10:21:57.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:57.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:57.496]     }
[10:21:57.496]     ...future.result <- base::tryCatch({
[10:21:57.496]         base::withCallingHandlers({
[10:21:57.496]             ...future.value <- base::withVisible(base::local({
[10:21:57.496]                 ...future.makeSendCondition <- base::local({
[10:21:57.496]                   sendCondition <- NULL
[10:21:57.496]                   function(frame = 1L) {
[10:21:57.496]                     if (is.function(sendCondition)) 
[10:21:57.496]                       return(sendCondition)
[10:21:57.496]                     ns <- getNamespace("parallel")
[10:21:57.496]                     if (exists("sendData", mode = "function", 
[10:21:57.496]                       envir = ns)) {
[10:21:57.496]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:57.496]                         envir = ns)
[10:21:57.496]                       envir <- sys.frame(frame)
[10:21:57.496]                       master <- NULL
[10:21:57.496]                       while (!identical(envir, .GlobalEnv) && 
[10:21:57.496]                         !identical(envir, emptyenv())) {
[10:21:57.496]                         if (exists("master", mode = "list", envir = envir, 
[10:21:57.496]                           inherits = FALSE)) {
[10:21:57.496]                           master <- get("master", mode = "list", 
[10:21:57.496]                             envir = envir, inherits = FALSE)
[10:21:57.496]                           if (inherits(master, c("SOCKnode", 
[10:21:57.496]                             "SOCK0node"))) {
[10:21:57.496]                             sendCondition <<- function(cond) {
[10:21:57.496]                               data <- list(type = "VALUE", value = cond, 
[10:21:57.496]                                 success = TRUE)
[10:21:57.496]                               parallel_sendData(master, data)
[10:21:57.496]                             }
[10:21:57.496]                             return(sendCondition)
[10:21:57.496]                           }
[10:21:57.496]                         }
[10:21:57.496]                         frame <- frame + 1L
[10:21:57.496]                         envir <- sys.frame(frame)
[10:21:57.496]                       }
[10:21:57.496]                     }
[10:21:57.496]                     sendCondition <<- function(cond) NULL
[10:21:57.496]                   }
[10:21:57.496]                 })
[10:21:57.496]                 withCallingHandlers({
[10:21:57.496]                   {
[10:21:57.496]                     ii
[10:21:57.496]                   }
[10:21:57.496]                 }, immediateCondition = function(cond) {
[10:21:57.496]                   sendCondition <- ...future.makeSendCondition()
[10:21:57.496]                   sendCondition(cond)
[10:21:57.496]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.496]                   {
[10:21:57.496]                     inherits <- base::inherits
[10:21:57.496]                     invokeRestart <- base::invokeRestart
[10:21:57.496]                     is.null <- base::is.null
[10:21:57.496]                     muffled <- FALSE
[10:21:57.496]                     if (inherits(cond, "message")) {
[10:21:57.496]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:57.496]                       if (muffled) 
[10:21:57.496]                         invokeRestart("muffleMessage")
[10:21:57.496]                     }
[10:21:57.496]                     else if (inherits(cond, "warning")) {
[10:21:57.496]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:57.496]                       if (muffled) 
[10:21:57.496]                         invokeRestart("muffleWarning")
[10:21:57.496]                     }
[10:21:57.496]                     else if (inherits(cond, "condition")) {
[10:21:57.496]                       if (!is.null(pattern)) {
[10:21:57.496]                         computeRestarts <- base::computeRestarts
[10:21:57.496]                         grepl <- base::grepl
[10:21:57.496]                         restarts <- computeRestarts(cond)
[10:21:57.496]                         for (restart in restarts) {
[10:21:57.496]                           name <- restart$name
[10:21:57.496]                           if (is.null(name)) 
[10:21:57.496]                             next
[10:21:57.496]                           if (!grepl(pattern, name)) 
[10:21:57.496]                             next
[10:21:57.496]                           invokeRestart(restart)
[10:21:57.496]                           muffled <- TRUE
[10:21:57.496]                           break
[10:21:57.496]                         }
[10:21:57.496]                       }
[10:21:57.496]                     }
[10:21:57.496]                     invisible(muffled)
[10:21:57.496]                   }
[10:21:57.496]                   muffleCondition(cond)
[10:21:57.496]                 })
[10:21:57.496]             }))
[10:21:57.496]             future::FutureResult(value = ...future.value$value, 
[10:21:57.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.496]                   ...future.rng), globalenv = if (FALSE) 
[10:21:57.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:57.496]                     ...future.globalenv.names))
[10:21:57.496]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:57.496]         }, condition = base::local({
[10:21:57.496]             c <- base::c
[10:21:57.496]             inherits <- base::inherits
[10:21:57.496]             invokeRestart <- base::invokeRestart
[10:21:57.496]             length <- base::length
[10:21:57.496]             list <- base::list
[10:21:57.496]             seq.int <- base::seq.int
[10:21:57.496]             signalCondition <- base::signalCondition
[10:21:57.496]             sys.calls <- base::sys.calls
[10:21:57.496]             `[[` <- base::`[[`
[10:21:57.496]             `+` <- base::`+`
[10:21:57.496]             `<<-` <- base::`<<-`
[10:21:57.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:57.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:57.496]                   3L)]
[10:21:57.496]             }
[10:21:57.496]             function(cond) {
[10:21:57.496]                 is_error <- inherits(cond, "error")
[10:21:57.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:57.496]                   NULL)
[10:21:57.496]                 if (is_error) {
[10:21:57.496]                   sessionInformation <- function() {
[10:21:57.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:57.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:57.496]                       search = base::search(), system = base::Sys.info())
[10:21:57.496]                   }
[10:21:57.496]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:57.496]                     cond$call), session = sessionInformation(), 
[10:21:57.496]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:57.496]                   signalCondition(cond)
[10:21:57.496]                 }
[10:21:57.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:57.496]                 "immediateCondition"))) {
[10:21:57.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:57.496]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:57.496]                   if (TRUE && !signal) {
[10:21:57.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.496]                     {
[10:21:57.496]                       inherits <- base::inherits
[10:21:57.496]                       invokeRestart <- base::invokeRestart
[10:21:57.496]                       is.null <- base::is.null
[10:21:57.496]                       muffled <- FALSE
[10:21:57.496]                       if (inherits(cond, "message")) {
[10:21:57.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.496]                         if (muffled) 
[10:21:57.496]                           invokeRestart("muffleMessage")
[10:21:57.496]                       }
[10:21:57.496]                       else if (inherits(cond, "warning")) {
[10:21:57.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.496]                         if (muffled) 
[10:21:57.496]                           invokeRestart("muffleWarning")
[10:21:57.496]                       }
[10:21:57.496]                       else if (inherits(cond, "condition")) {
[10:21:57.496]                         if (!is.null(pattern)) {
[10:21:57.496]                           computeRestarts <- base::computeRestarts
[10:21:57.496]                           grepl <- base::grepl
[10:21:57.496]                           restarts <- computeRestarts(cond)
[10:21:57.496]                           for (restart in restarts) {
[10:21:57.496]                             name <- restart$name
[10:21:57.496]                             if (is.null(name)) 
[10:21:57.496]                               next
[10:21:57.496]                             if (!grepl(pattern, name)) 
[10:21:57.496]                               next
[10:21:57.496]                             invokeRestart(restart)
[10:21:57.496]                             muffled <- TRUE
[10:21:57.496]                             break
[10:21:57.496]                           }
[10:21:57.496]                         }
[10:21:57.496]                       }
[10:21:57.496]                       invisible(muffled)
[10:21:57.496]                     }
[10:21:57.496]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.496]                   }
[10:21:57.496]                 }
[10:21:57.496]                 else {
[10:21:57.496]                   if (TRUE) {
[10:21:57.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.496]                     {
[10:21:57.496]                       inherits <- base::inherits
[10:21:57.496]                       invokeRestart <- base::invokeRestart
[10:21:57.496]                       is.null <- base::is.null
[10:21:57.496]                       muffled <- FALSE
[10:21:57.496]                       if (inherits(cond, "message")) {
[10:21:57.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.496]                         if (muffled) 
[10:21:57.496]                           invokeRestart("muffleMessage")
[10:21:57.496]                       }
[10:21:57.496]                       else if (inherits(cond, "warning")) {
[10:21:57.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.496]                         if (muffled) 
[10:21:57.496]                           invokeRestart("muffleWarning")
[10:21:57.496]                       }
[10:21:57.496]                       else if (inherits(cond, "condition")) {
[10:21:57.496]                         if (!is.null(pattern)) {
[10:21:57.496]                           computeRestarts <- base::computeRestarts
[10:21:57.496]                           grepl <- base::grepl
[10:21:57.496]                           restarts <- computeRestarts(cond)
[10:21:57.496]                           for (restart in restarts) {
[10:21:57.496]                             name <- restart$name
[10:21:57.496]                             if (is.null(name)) 
[10:21:57.496]                               next
[10:21:57.496]                             if (!grepl(pattern, name)) 
[10:21:57.496]                               next
[10:21:57.496]                             invokeRestart(restart)
[10:21:57.496]                             muffled <- TRUE
[10:21:57.496]                             break
[10:21:57.496]                           }
[10:21:57.496]                         }
[10:21:57.496]                       }
[10:21:57.496]                       invisible(muffled)
[10:21:57.496]                     }
[10:21:57.496]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.496]                   }
[10:21:57.496]                 }
[10:21:57.496]             }
[10:21:57.496]         }))
[10:21:57.496]     }, error = function(ex) {
[10:21:57.496]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:57.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.496]                 ...future.rng), started = ...future.startTime, 
[10:21:57.496]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:57.496]             version = "1.8"), class = "FutureResult")
[10:21:57.496]     }, finally = {
[10:21:57.496]         if (!identical(...future.workdir, getwd())) 
[10:21:57.496]             setwd(...future.workdir)
[10:21:57.496]         {
[10:21:57.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:57.496]                 ...future.oldOptions$nwarnings <- NULL
[10:21:57.496]             }
[10:21:57.496]             base::options(...future.oldOptions)
[10:21:57.496]             if (.Platform$OS.type == "windows") {
[10:21:57.496]                 old_names <- names(...future.oldEnvVars)
[10:21:57.496]                 envs <- base::Sys.getenv()
[10:21:57.496]                 names <- names(envs)
[10:21:57.496]                 common <- intersect(names, old_names)
[10:21:57.496]                 added <- setdiff(names, old_names)
[10:21:57.496]                 removed <- setdiff(old_names, names)
[10:21:57.496]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:57.496]                   envs[common]]
[10:21:57.496]                 NAMES <- toupper(changed)
[10:21:57.496]                 args <- list()
[10:21:57.496]                 for (kk in seq_along(NAMES)) {
[10:21:57.496]                   name <- changed[[kk]]
[10:21:57.496]                   NAME <- NAMES[[kk]]
[10:21:57.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.496]                     next
[10:21:57.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.496]                 }
[10:21:57.496]                 NAMES <- toupper(added)
[10:21:57.496]                 for (kk in seq_along(NAMES)) {
[10:21:57.496]                   name <- added[[kk]]
[10:21:57.496]                   NAME <- NAMES[[kk]]
[10:21:57.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.496]                     next
[10:21:57.496]                   args[[name]] <- ""
[10:21:57.496]                 }
[10:21:57.496]                 NAMES <- toupper(removed)
[10:21:57.496]                 for (kk in seq_along(NAMES)) {
[10:21:57.496]                   name <- removed[[kk]]
[10:21:57.496]                   NAME <- NAMES[[kk]]
[10:21:57.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.496]                     next
[10:21:57.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.496]                 }
[10:21:57.496]                 if (length(args) > 0) 
[10:21:57.496]                   base::do.call(base::Sys.setenv, args = args)
[10:21:57.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:57.496]             }
[10:21:57.496]             else {
[10:21:57.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:57.496]             }
[10:21:57.496]             {
[10:21:57.496]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:57.496]                   0L) {
[10:21:57.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:57.496]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:57.496]                   base::options(opts)
[10:21:57.496]                 }
[10:21:57.496]                 {
[10:21:57.496]                   {
[10:21:57.496]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:57.496]                     NULL
[10:21:57.496]                   }
[10:21:57.496]                   options(future.plan = NULL)
[10:21:57.496]                   if (is.na(NA_character_)) 
[10:21:57.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:57.496]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:57.496]                     .init = FALSE)
[10:21:57.496]                 }
[10:21:57.496]             }
[10:21:57.496]         }
[10:21:57.496]     })
[10:21:57.496]     if (TRUE) {
[10:21:57.496]         base::sink(type = "output", split = FALSE)
[10:21:57.496]         if (TRUE) {
[10:21:57.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:57.496]         }
[10:21:57.496]         else {
[10:21:57.496]             ...future.result["stdout"] <- base::list(NULL)
[10:21:57.496]         }
[10:21:57.496]         base::close(...future.stdout)
[10:21:57.496]         ...future.stdout <- NULL
[10:21:57.496]     }
[10:21:57.496]     ...future.result$conditions <- ...future.conditions
[10:21:57.496]     ...future.result$finished <- base::Sys.time()
[10:21:57.496]     ...future.result
[10:21:57.496] }
[10:21:57.502] Exporting 1 global objects (304 bytes) to cluster node #1 ...
[10:21:57.503] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[10:21:57.503] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[10:21:57.503] Exporting 1 global objects (304 bytes) to cluster node #1 ... DONE
[10:21:57.504] MultisessionFuture started
 - Creating multisession future #1 ...
[10:21:57.505] getGlobalsAndPackages() ...
[10:21:57.505] Searching for globals...
[10:21:57.506] - globals found: [2] ‘{’, ‘ii’
[10:21:57.506] Searching for globals ... DONE
[10:21:57.507] Resolving globals: FALSE
[10:21:57.507] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:57.507] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:57.507] - globals: [1] ‘ii’
[10:21:57.508] 
[10:21:57.508] getGlobalsAndPackages() ... DONE
[10:21:57.521] Packages needed by the future expression (n = 0): <none>
[10:21:57.521] Packages needed by future strategies (n = 0): <none>
[10:21:57.521] {
[10:21:57.521]     {
[10:21:57.521]         {
[10:21:57.521]             ...future.startTime <- base::Sys.time()
[10:21:57.521]             {
[10:21:57.521]                 {
[10:21:57.521]                   {
[10:21:57.521]                     {
[10:21:57.521]                       base::local({
[10:21:57.521]                         has_future <- base::requireNamespace("future", 
[10:21:57.521]                           quietly = TRUE)
[10:21:57.521]                         if (has_future) {
[10:21:57.521]                           ns <- base::getNamespace("future")
[10:21:57.521]                           version <- ns[[".package"]][["version"]]
[10:21:57.521]                           if (is.null(version)) 
[10:21:57.521]                             version <- utils::packageVersion("future")
[10:21:57.521]                         }
[10:21:57.521]                         else {
[10:21:57.521]                           version <- NULL
[10:21:57.521]                         }
[10:21:57.521]                         if (!has_future || version < "1.8.0") {
[10:21:57.521]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:57.521]                             "", base::R.version$version.string), 
[10:21:57.521]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:57.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:57.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:57.521]                               "release", "version")], collapse = " "), 
[10:21:57.521]                             hostname = base::Sys.info()[["nodename"]])
[10:21:57.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:57.521]                             info)
[10:21:57.521]                           info <- base::paste(info, collapse = "; ")
[10:21:57.521]                           if (!has_future) {
[10:21:57.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:57.521]                               info)
[10:21:57.521]                           }
[10:21:57.521]                           else {
[10:21:57.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:57.521]                               info, version)
[10:21:57.521]                           }
[10:21:57.521]                           base::stop(msg)
[10:21:57.521]                         }
[10:21:57.521]                       })
[10:21:57.521]                     }
[10:21:57.521]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:57.521]                     base::options(mc.cores = 1L)
[10:21:57.521]                   }
[10:21:57.521]                   ...future.strategy.old <- future::plan("list")
[10:21:57.521]                   options(future.plan = NULL)
[10:21:57.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:57.521]                 }
[10:21:57.521]                 ...future.workdir <- getwd()
[10:21:57.521]             }
[10:21:57.521]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:57.521]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:57.521]         }
[10:21:57.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:57.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:57.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:57.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:57.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:57.521]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:57.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:57.521]             base::names(...future.oldOptions))
[10:21:57.521]     }
[10:21:57.521]     if (FALSE) {
[10:21:57.521]     }
[10:21:57.521]     else {
[10:21:57.521]         if (TRUE) {
[10:21:57.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:57.521]                 open = "w")
[10:21:57.521]         }
[10:21:57.521]         else {
[10:21:57.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:57.521]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:57.521]         }
[10:21:57.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:57.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:57.521]             base::sink(type = "output", split = FALSE)
[10:21:57.521]             base::close(...future.stdout)
[10:21:57.521]         }, add = TRUE)
[10:21:57.521]     }
[10:21:57.521]     ...future.frame <- base::sys.nframe()
[10:21:57.521]     ...future.conditions <- base::list()
[10:21:57.521]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:57.521]     if (FALSE) {
[10:21:57.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:57.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:57.521]     }
[10:21:57.521]     ...future.result <- base::tryCatch({
[10:21:57.521]         base::withCallingHandlers({
[10:21:57.521]             ...future.value <- base::withVisible(base::local({
[10:21:57.521]                 ...future.makeSendCondition <- base::local({
[10:21:57.521]                   sendCondition <- NULL
[10:21:57.521]                   function(frame = 1L) {
[10:21:57.521]                     if (is.function(sendCondition)) 
[10:21:57.521]                       return(sendCondition)
[10:21:57.521]                     ns <- getNamespace("parallel")
[10:21:57.521]                     if (exists("sendData", mode = "function", 
[10:21:57.521]                       envir = ns)) {
[10:21:57.521]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:57.521]                         envir = ns)
[10:21:57.521]                       envir <- sys.frame(frame)
[10:21:57.521]                       master <- NULL
[10:21:57.521]                       while (!identical(envir, .GlobalEnv) && 
[10:21:57.521]                         !identical(envir, emptyenv())) {
[10:21:57.521]                         if (exists("master", mode = "list", envir = envir, 
[10:21:57.521]                           inherits = FALSE)) {
[10:21:57.521]                           master <- get("master", mode = "list", 
[10:21:57.521]                             envir = envir, inherits = FALSE)
[10:21:57.521]                           if (inherits(master, c("SOCKnode", 
[10:21:57.521]                             "SOCK0node"))) {
[10:21:57.521]                             sendCondition <<- function(cond) {
[10:21:57.521]                               data <- list(type = "VALUE", value = cond, 
[10:21:57.521]                                 success = TRUE)
[10:21:57.521]                               parallel_sendData(master, data)
[10:21:57.521]                             }
[10:21:57.521]                             return(sendCondition)
[10:21:57.521]                           }
[10:21:57.521]                         }
[10:21:57.521]                         frame <- frame + 1L
[10:21:57.521]                         envir <- sys.frame(frame)
[10:21:57.521]                       }
[10:21:57.521]                     }
[10:21:57.521]                     sendCondition <<- function(cond) NULL
[10:21:57.521]                   }
[10:21:57.521]                 })
[10:21:57.521]                 withCallingHandlers({
[10:21:57.521]                   {
[10:21:57.521]                     ii
[10:21:57.521]                   }
[10:21:57.521]                 }, immediateCondition = function(cond) {
[10:21:57.521]                   sendCondition <- ...future.makeSendCondition()
[10:21:57.521]                   sendCondition(cond)
[10:21:57.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.521]                   {
[10:21:57.521]                     inherits <- base::inherits
[10:21:57.521]                     invokeRestart <- base::invokeRestart
[10:21:57.521]                     is.null <- base::is.null
[10:21:57.521]                     muffled <- FALSE
[10:21:57.521]                     if (inherits(cond, "message")) {
[10:21:57.521]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:57.521]                       if (muffled) 
[10:21:57.521]                         invokeRestart("muffleMessage")
[10:21:57.521]                     }
[10:21:57.521]                     else if (inherits(cond, "warning")) {
[10:21:57.521]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:57.521]                       if (muffled) 
[10:21:57.521]                         invokeRestart("muffleWarning")
[10:21:57.521]                     }
[10:21:57.521]                     else if (inherits(cond, "condition")) {
[10:21:57.521]                       if (!is.null(pattern)) {
[10:21:57.521]                         computeRestarts <- base::computeRestarts
[10:21:57.521]                         grepl <- base::grepl
[10:21:57.521]                         restarts <- computeRestarts(cond)
[10:21:57.521]                         for (restart in restarts) {
[10:21:57.521]                           name <- restart$name
[10:21:57.521]                           if (is.null(name)) 
[10:21:57.521]                             next
[10:21:57.521]                           if (!grepl(pattern, name)) 
[10:21:57.521]                             next
[10:21:57.521]                           invokeRestart(restart)
[10:21:57.521]                           muffled <- TRUE
[10:21:57.521]                           break
[10:21:57.521]                         }
[10:21:57.521]                       }
[10:21:57.521]                     }
[10:21:57.521]                     invisible(muffled)
[10:21:57.521]                   }
[10:21:57.521]                   muffleCondition(cond)
[10:21:57.521]                 })
[10:21:57.521]             }))
[10:21:57.521]             future::FutureResult(value = ...future.value$value, 
[10:21:57.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.521]                   ...future.rng), globalenv = if (FALSE) 
[10:21:57.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:57.521]                     ...future.globalenv.names))
[10:21:57.521]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:57.521]         }, condition = base::local({
[10:21:57.521]             c <- base::c
[10:21:57.521]             inherits <- base::inherits
[10:21:57.521]             invokeRestart <- base::invokeRestart
[10:21:57.521]             length <- base::length
[10:21:57.521]             list <- base::list
[10:21:57.521]             seq.int <- base::seq.int
[10:21:57.521]             signalCondition <- base::signalCondition
[10:21:57.521]             sys.calls <- base::sys.calls
[10:21:57.521]             `[[` <- base::`[[`
[10:21:57.521]             `+` <- base::`+`
[10:21:57.521]             `<<-` <- base::`<<-`
[10:21:57.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:57.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:57.521]                   3L)]
[10:21:57.521]             }
[10:21:57.521]             function(cond) {
[10:21:57.521]                 is_error <- inherits(cond, "error")
[10:21:57.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:57.521]                   NULL)
[10:21:57.521]                 if (is_error) {
[10:21:57.521]                   sessionInformation <- function() {
[10:21:57.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:57.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:57.521]                       search = base::search(), system = base::Sys.info())
[10:21:57.521]                   }
[10:21:57.521]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:57.521]                     cond$call), session = sessionInformation(), 
[10:21:57.521]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:57.521]                   signalCondition(cond)
[10:21:57.521]                 }
[10:21:57.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:57.521]                 "immediateCondition"))) {
[10:21:57.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:57.521]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:57.521]                   if (TRUE && !signal) {
[10:21:57.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.521]                     {
[10:21:57.521]                       inherits <- base::inherits
[10:21:57.521]                       invokeRestart <- base::invokeRestart
[10:21:57.521]                       is.null <- base::is.null
[10:21:57.521]                       muffled <- FALSE
[10:21:57.521]                       if (inherits(cond, "message")) {
[10:21:57.521]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.521]                         if (muffled) 
[10:21:57.521]                           invokeRestart("muffleMessage")
[10:21:57.521]                       }
[10:21:57.521]                       else if (inherits(cond, "warning")) {
[10:21:57.521]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.521]                         if (muffled) 
[10:21:57.521]                           invokeRestart("muffleWarning")
[10:21:57.521]                       }
[10:21:57.521]                       else if (inherits(cond, "condition")) {
[10:21:57.521]                         if (!is.null(pattern)) {
[10:21:57.521]                           computeRestarts <- base::computeRestarts
[10:21:57.521]                           grepl <- base::grepl
[10:21:57.521]                           restarts <- computeRestarts(cond)
[10:21:57.521]                           for (restart in restarts) {
[10:21:57.521]                             name <- restart$name
[10:21:57.521]                             if (is.null(name)) 
[10:21:57.521]                               next
[10:21:57.521]                             if (!grepl(pattern, name)) 
[10:21:57.521]                               next
[10:21:57.521]                             invokeRestart(restart)
[10:21:57.521]                             muffled <- TRUE
[10:21:57.521]                             break
[10:21:57.521]                           }
[10:21:57.521]                         }
[10:21:57.521]                       }
[10:21:57.521]                       invisible(muffled)
[10:21:57.521]                     }
[10:21:57.521]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.521]                   }
[10:21:57.521]                 }
[10:21:57.521]                 else {
[10:21:57.521]                   if (TRUE) {
[10:21:57.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.521]                     {
[10:21:57.521]                       inherits <- base::inherits
[10:21:57.521]                       invokeRestart <- base::invokeRestart
[10:21:57.521]                       is.null <- base::is.null
[10:21:57.521]                       muffled <- FALSE
[10:21:57.521]                       if (inherits(cond, "message")) {
[10:21:57.521]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.521]                         if (muffled) 
[10:21:57.521]                           invokeRestart("muffleMessage")
[10:21:57.521]                       }
[10:21:57.521]                       else if (inherits(cond, "warning")) {
[10:21:57.521]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.521]                         if (muffled) 
[10:21:57.521]                           invokeRestart("muffleWarning")
[10:21:57.521]                       }
[10:21:57.521]                       else if (inherits(cond, "condition")) {
[10:21:57.521]                         if (!is.null(pattern)) {
[10:21:57.521]                           computeRestarts <- base::computeRestarts
[10:21:57.521]                           grepl <- base::grepl
[10:21:57.521]                           restarts <- computeRestarts(cond)
[10:21:57.521]                           for (restart in restarts) {
[10:21:57.521]                             name <- restart$name
[10:21:57.521]                             if (is.null(name)) 
[10:21:57.521]                               next
[10:21:57.521]                             if (!grepl(pattern, name)) 
[10:21:57.521]                               next
[10:21:57.521]                             invokeRestart(restart)
[10:21:57.521]                             muffled <- TRUE
[10:21:57.521]                             break
[10:21:57.521]                           }
[10:21:57.521]                         }
[10:21:57.521]                       }
[10:21:57.521]                       invisible(muffled)
[10:21:57.521]                     }
[10:21:57.521]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.521]                   }
[10:21:57.521]                 }
[10:21:57.521]             }
[10:21:57.521]         }))
[10:21:57.521]     }, error = function(ex) {
[10:21:57.521]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:57.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.521]                 ...future.rng), started = ...future.startTime, 
[10:21:57.521]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:57.521]             version = "1.8"), class = "FutureResult")
[10:21:57.521]     }, finally = {
[10:21:57.521]         if (!identical(...future.workdir, getwd())) 
[10:21:57.521]             setwd(...future.workdir)
[10:21:57.521]         {
[10:21:57.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:57.521]                 ...future.oldOptions$nwarnings <- NULL
[10:21:57.521]             }
[10:21:57.521]             base::options(...future.oldOptions)
[10:21:57.521]             if (.Platform$OS.type == "windows") {
[10:21:57.521]                 old_names <- names(...future.oldEnvVars)
[10:21:57.521]                 envs <- base::Sys.getenv()
[10:21:57.521]                 names <- names(envs)
[10:21:57.521]                 common <- intersect(names, old_names)
[10:21:57.521]                 added <- setdiff(names, old_names)
[10:21:57.521]                 removed <- setdiff(old_names, names)
[10:21:57.521]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:57.521]                   envs[common]]
[10:21:57.521]                 NAMES <- toupper(changed)
[10:21:57.521]                 args <- list()
[10:21:57.521]                 for (kk in seq_along(NAMES)) {
[10:21:57.521]                   name <- changed[[kk]]
[10:21:57.521]                   NAME <- NAMES[[kk]]
[10:21:57.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.521]                     next
[10:21:57.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.521]                 }
[10:21:57.521]                 NAMES <- toupper(added)
[10:21:57.521]                 for (kk in seq_along(NAMES)) {
[10:21:57.521]                   name <- added[[kk]]
[10:21:57.521]                   NAME <- NAMES[[kk]]
[10:21:57.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.521]                     next
[10:21:57.521]                   args[[name]] <- ""
[10:21:57.521]                 }
[10:21:57.521]                 NAMES <- toupper(removed)
[10:21:57.521]                 for (kk in seq_along(NAMES)) {
[10:21:57.521]                   name <- removed[[kk]]
[10:21:57.521]                   NAME <- NAMES[[kk]]
[10:21:57.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.521]                     next
[10:21:57.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.521]                 }
[10:21:57.521]                 if (length(args) > 0) 
[10:21:57.521]                   base::do.call(base::Sys.setenv, args = args)
[10:21:57.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:57.521]             }
[10:21:57.521]             else {
[10:21:57.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:57.521]             }
[10:21:57.521]             {
[10:21:57.521]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:57.521]                   0L) {
[10:21:57.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:57.521]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:57.521]                   base::options(opts)
[10:21:57.521]                 }
[10:21:57.521]                 {
[10:21:57.521]                   {
[10:21:57.521]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:57.521]                     NULL
[10:21:57.521]                   }
[10:21:57.521]                   options(future.plan = NULL)
[10:21:57.521]                   if (is.na(NA_character_)) 
[10:21:57.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:57.521]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:57.521]                     .init = FALSE)
[10:21:57.521]                 }
[10:21:57.521]             }
[10:21:57.521]         }
[10:21:57.521]     })
[10:21:57.521]     if (TRUE) {
[10:21:57.521]         base::sink(type = "output", split = FALSE)
[10:21:57.521]         if (TRUE) {
[10:21:57.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:57.521]         }
[10:21:57.521]         else {
[10:21:57.521]             ...future.result["stdout"] <- base::list(NULL)
[10:21:57.521]         }
[10:21:57.521]         base::close(...future.stdout)
[10:21:57.521]         ...future.stdout <- NULL
[10:21:57.521]     }
[10:21:57.521]     ...future.result$conditions <- ...future.conditions
[10:21:57.521]     ...future.result$finished <- base::Sys.time()
[10:21:57.521]     ...future.result
[10:21:57.521] }
[10:21:57.574] Exporting 1 global objects (304 bytes) to cluster node #2 ...
[10:21:57.574] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[10:21:57.574] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[10:21:57.575] Exporting 1 global objects (304 bytes) to cluster node #2 ... DONE
[10:21:57.575] MultisessionFuture started
 - Resolving 2 multisession futures
[10:21:57.576] result() for ClusterFuture ...
[10:21:57.576] receiveMessageFromWorker() for ClusterFuture ...
[10:21:57.576] - Validating connection of MultisessionFuture
[10:21:57.646] - received message: FutureResult
[10:21:57.647] - Received FutureResult
[10:21:57.647] - Erased future from FutureRegistry
[10:21:57.647] result() for ClusterFuture ...
[10:21:57.647] - result already collected: FutureResult
[10:21:57.647] result() for ClusterFuture ... done
[10:21:57.647] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:57.647] result() for ClusterFuture ... done
[10:21:57.647] result() for ClusterFuture ...
[10:21:57.648] - result already collected: FutureResult
[10:21:57.648] result() for ClusterFuture ... done
[10:21:57.648] result() for ClusterFuture ...
[10:21:57.648] receiveMessageFromWorker() for ClusterFuture ...
[10:21:57.648] - Validating connection of MultisessionFuture
[10:21:57.648] - received message: FutureResult
[10:21:57.648] - Received FutureResult
[10:21:57.649] - Erased future from FutureRegistry
[10:21:57.649] result() for ClusterFuture ...
[10:21:57.649] - result already collected: FutureResult
[10:21:57.649] result() for ClusterFuture ... done
[10:21:57.649] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:57.649] result() for ClusterFuture ... done
[10:21:57.649] result() for ClusterFuture ...
[10:21:57.649] - result already collected: FutureResult
[10:21:57.649] result() for ClusterFuture ... done
*** multisession() - workers inherit .libPaths()
[10:21:57.650] getGlobalsAndPackages() ...
[10:21:57.650] Searching for globals...
[10:21:57.650] - globals found: [1] ‘.libPaths’
[10:21:57.651] Searching for globals ... DONE
[10:21:57.651] Resolving globals: FALSE
[10:21:57.651] 
[10:21:57.651] 
[10:21:57.651] getGlobalsAndPackages() ... DONE
[10:21:57.652] run() for ‘Future’ ...
[10:21:57.652] - state: ‘created’
[10:21:57.652] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:57.652] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:57.652] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:57.653]   - Field: ‘label’
[10:21:57.653]   - Field: ‘local’
[10:21:57.653]   - Field: ‘owner’
[10:21:57.653]   - Field: ‘envir’
[10:21:57.653]   - Field: ‘packages’
[10:21:57.653]   - Field: ‘gc’
[10:21:57.653]   - Field: ‘conditions’
[10:21:57.653]   - Field: ‘expr’
[10:21:57.653]   - Field: ‘uuid’
[10:21:57.654]   - Field: ‘seed’
[10:21:57.654]   - Field: ‘version’
[10:21:57.654]   - Field: ‘result’
[10:21:57.654]   - Field: ‘asynchronous’
[10:21:57.654]   - Field: ‘calls’
[10:21:57.654]   - Field: ‘globals’
[10:21:57.654]   - Field: ‘stdout’
[10:21:57.654]   - Field: ‘earlySignal’
[10:21:57.654]   - Field: ‘lazy’
[10:21:57.655]   - Field: ‘state’
[10:21:57.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:57.655] - Launch lazy future ...
[10:21:57.655] Packages needed by the future expression (n = 0): <none>
[10:21:57.655] Packages needed by future strategies (n = 0): <none>
[10:21:57.656] {
[10:21:57.656]     {
[10:21:57.656]         {
[10:21:57.656]             ...future.startTime <- base::Sys.time()
[10:21:57.656]             {
[10:21:57.656]                 {
[10:21:57.656]                   {
[10:21:57.656]                     base::local({
[10:21:57.656]                       has_future <- base::requireNamespace("future", 
[10:21:57.656]                         quietly = TRUE)
[10:21:57.656]                       if (has_future) {
[10:21:57.656]                         ns <- base::getNamespace("future")
[10:21:57.656]                         version <- ns[[".package"]][["version"]]
[10:21:57.656]                         if (is.null(version)) 
[10:21:57.656]                           version <- utils::packageVersion("future")
[10:21:57.656]                       }
[10:21:57.656]                       else {
[10:21:57.656]                         version <- NULL
[10:21:57.656]                       }
[10:21:57.656]                       if (!has_future || version < "1.8.0") {
[10:21:57.656]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:57.656]                           "", base::R.version$version.string), 
[10:21:57.656]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:57.656]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:57.656]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:57.656]                             "release", "version")], collapse = " "), 
[10:21:57.656]                           hostname = base::Sys.info()[["nodename"]])
[10:21:57.656]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:57.656]                           info)
[10:21:57.656]                         info <- base::paste(info, collapse = "; ")
[10:21:57.656]                         if (!has_future) {
[10:21:57.656]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:57.656]                             info)
[10:21:57.656]                         }
[10:21:57.656]                         else {
[10:21:57.656]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:57.656]                             info, version)
[10:21:57.656]                         }
[10:21:57.656]                         base::stop(msg)
[10:21:57.656]                       }
[10:21:57.656]                     })
[10:21:57.656]                   }
[10:21:57.656]                   ...future.strategy.old <- future::plan("list")
[10:21:57.656]                   options(future.plan = NULL)
[10:21:57.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:57.656]                 }
[10:21:57.656]                 ...future.workdir <- getwd()
[10:21:57.656]             }
[10:21:57.656]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:57.656]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:57.656]         }
[10:21:57.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:57.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:57.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:57.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:57.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:57.656]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:57.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:57.656]             base::names(...future.oldOptions))
[10:21:57.656]     }
[10:21:57.656]     if (FALSE) {
[10:21:57.656]     }
[10:21:57.656]     else {
[10:21:57.656]         if (TRUE) {
[10:21:57.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:57.656]                 open = "w")
[10:21:57.656]         }
[10:21:57.656]         else {
[10:21:57.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:57.656]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:57.656]         }
[10:21:57.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:57.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:57.656]             base::sink(type = "output", split = FALSE)
[10:21:57.656]             base::close(...future.stdout)
[10:21:57.656]         }, add = TRUE)
[10:21:57.656]     }
[10:21:57.656]     ...future.frame <- base::sys.nframe()
[10:21:57.656]     ...future.conditions <- base::list()
[10:21:57.656]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:57.656]     if (FALSE) {
[10:21:57.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:57.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:57.656]     }
[10:21:57.656]     ...future.result <- base::tryCatch({
[10:21:57.656]         base::withCallingHandlers({
[10:21:57.656]             ...future.value <- base::withVisible(base::local(.libPaths()))
[10:21:57.656]             future::FutureResult(value = ...future.value$value, 
[10:21:57.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.656]                   ...future.rng), globalenv = if (FALSE) 
[10:21:57.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:57.656]                     ...future.globalenv.names))
[10:21:57.656]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:57.656]         }, condition = base::local({
[10:21:57.656]             c <- base::c
[10:21:57.656]             inherits <- base::inherits
[10:21:57.656]             invokeRestart <- base::invokeRestart
[10:21:57.656]             length <- base::length
[10:21:57.656]             list <- base::list
[10:21:57.656]             seq.int <- base::seq.int
[10:21:57.656]             signalCondition <- base::signalCondition
[10:21:57.656]             sys.calls <- base::sys.calls
[10:21:57.656]             `[[` <- base::`[[`
[10:21:57.656]             `+` <- base::`+`
[10:21:57.656]             `<<-` <- base::`<<-`
[10:21:57.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:57.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:57.656]                   3L)]
[10:21:57.656]             }
[10:21:57.656]             function(cond) {
[10:21:57.656]                 is_error <- inherits(cond, "error")
[10:21:57.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:57.656]                   NULL)
[10:21:57.656]                 if (is_error) {
[10:21:57.656]                   sessionInformation <- function() {
[10:21:57.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:57.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:57.656]                       search = base::search(), system = base::Sys.info())
[10:21:57.656]                   }
[10:21:57.656]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:57.656]                     cond$call), session = sessionInformation(), 
[10:21:57.656]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:57.656]                   signalCondition(cond)
[10:21:57.656]                 }
[10:21:57.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:57.656]                 "immediateCondition"))) {
[10:21:57.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:57.656]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:57.656]                   if (TRUE && !signal) {
[10:21:57.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.656]                     {
[10:21:57.656]                       inherits <- base::inherits
[10:21:57.656]                       invokeRestart <- base::invokeRestart
[10:21:57.656]                       is.null <- base::is.null
[10:21:57.656]                       muffled <- FALSE
[10:21:57.656]                       if (inherits(cond, "message")) {
[10:21:57.656]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.656]                         if (muffled) 
[10:21:57.656]                           invokeRestart("muffleMessage")
[10:21:57.656]                       }
[10:21:57.656]                       else if (inherits(cond, "warning")) {
[10:21:57.656]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.656]                         if (muffled) 
[10:21:57.656]                           invokeRestart("muffleWarning")
[10:21:57.656]                       }
[10:21:57.656]                       else if (inherits(cond, "condition")) {
[10:21:57.656]                         if (!is.null(pattern)) {
[10:21:57.656]                           computeRestarts <- base::computeRestarts
[10:21:57.656]                           grepl <- base::grepl
[10:21:57.656]                           restarts <- computeRestarts(cond)
[10:21:57.656]                           for (restart in restarts) {
[10:21:57.656]                             name <- restart$name
[10:21:57.656]                             if (is.null(name)) 
[10:21:57.656]                               next
[10:21:57.656]                             if (!grepl(pattern, name)) 
[10:21:57.656]                               next
[10:21:57.656]                             invokeRestart(restart)
[10:21:57.656]                             muffled <- TRUE
[10:21:57.656]                             break
[10:21:57.656]                           }
[10:21:57.656]                         }
[10:21:57.656]                       }
[10:21:57.656]                       invisible(muffled)
[10:21:57.656]                     }
[10:21:57.656]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.656]                   }
[10:21:57.656]                 }
[10:21:57.656]                 else {
[10:21:57.656]                   if (TRUE) {
[10:21:57.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.656]                     {
[10:21:57.656]                       inherits <- base::inherits
[10:21:57.656]                       invokeRestart <- base::invokeRestart
[10:21:57.656]                       is.null <- base::is.null
[10:21:57.656]                       muffled <- FALSE
[10:21:57.656]                       if (inherits(cond, "message")) {
[10:21:57.656]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.656]                         if (muffled) 
[10:21:57.656]                           invokeRestart("muffleMessage")
[10:21:57.656]                       }
[10:21:57.656]                       else if (inherits(cond, "warning")) {
[10:21:57.656]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.656]                         if (muffled) 
[10:21:57.656]                           invokeRestart("muffleWarning")
[10:21:57.656]                       }
[10:21:57.656]                       else if (inherits(cond, "condition")) {
[10:21:57.656]                         if (!is.null(pattern)) {
[10:21:57.656]                           computeRestarts <- base::computeRestarts
[10:21:57.656]                           grepl <- base::grepl
[10:21:57.656]                           restarts <- computeRestarts(cond)
[10:21:57.656]                           for (restart in restarts) {
[10:21:57.656]                             name <- restart$name
[10:21:57.656]                             if (is.null(name)) 
[10:21:57.656]                               next
[10:21:57.656]                             if (!grepl(pattern, name)) 
[10:21:57.656]                               next
[10:21:57.656]                             invokeRestart(restart)
[10:21:57.656]                             muffled <- TRUE
[10:21:57.656]                             break
[10:21:57.656]                           }
[10:21:57.656]                         }
[10:21:57.656]                       }
[10:21:57.656]                       invisible(muffled)
[10:21:57.656]                     }
[10:21:57.656]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.656]                   }
[10:21:57.656]                 }
[10:21:57.656]             }
[10:21:57.656]         }))
[10:21:57.656]     }, error = function(ex) {
[10:21:57.656]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:57.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.656]                 ...future.rng), started = ...future.startTime, 
[10:21:57.656]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:57.656]             version = "1.8"), class = "FutureResult")
[10:21:57.656]     }, finally = {
[10:21:57.656]         if (!identical(...future.workdir, getwd())) 
[10:21:57.656]             setwd(...future.workdir)
[10:21:57.656]         {
[10:21:57.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:57.656]                 ...future.oldOptions$nwarnings <- NULL
[10:21:57.656]             }
[10:21:57.656]             base::options(...future.oldOptions)
[10:21:57.656]             if (.Platform$OS.type == "windows") {
[10:21:57.656]                 old_names <- names(...future.oldEnvVars)
[10:21:57.656]                 envs <- base::Sys.getenv()
[10:21:57.656]                 names <- names(envs)
[10:21:57.656]                 common <- intersect(names, old_names)
[10:21:57.656]                 added <- setdiff(names, old_names)
[10:21:57.656]                 removed <- setdiff(old_names, names)
[10:21:57.656]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:57.656]                   envs[common]]
[10:21:57.656]                 NAMES <- toupper(changed)
[10:21:57.656]                 args <- list()
[10:21:57.656]                 for (kk in seq_along(NAMES)) {
[10:21:57.656]                   name <- changed[[kk]]
[10:21:57.656]                   NAME <- NAMES[[kk]]
[10:21:57.656]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.656]                     next
[10:21:57.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.656]                 }
[10:21:57.656]                 NAMES <- toupper(added)
[10:21:57.656]                 for (kk in seq_along(NAMES)) {
[10:21:57.656]                   name <- added[[kk]]
[10:21:57.656]                   NAME <- NAMES[[kk]]
[10:21:57.656]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.656]                     next
[10:21:57.656]                   args[[name]] <- ""
[10:21:57.656]                 }
[10:21:57.656]                 NAMES <- toupper(removed)
[10:21:57.656]                 for (kk in seq_along(NAMES)) {
[10:21:57.656]                   name <- removed[[kk]]
[10:21:57.656]                   NAME <- NAMES[[kk]]
[10:21:57.656]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.656]                     next
[10:21:57.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.656]                 }
[10:21:57.656]                 if (length(args) > 0) 
[10:21:57.656]                   base::do.call(base::Sys.setenv, args = args)
[10:21:57.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:57.656]             }
[10:21:57.656]             else {
[10:21:57.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:57.656]             }
[10:21:57.656]             {
[10:21:57.656]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:57.656]                   0L) {
[10:21:57.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:57.656]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:57.656]                   base::options(opts)
[10:21:57.656]                 }
[10:21:57.656]                 {
[10:21:57.656]                   {
[10:21:57.656]                     NULL
[10:21:57.656]                     RNGkind("Mersenne-Twister")
[10:21:57.656]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:57.656]                       inherits = FALSE)
[10:21:57.656]                   }
[10:21:57.656]                   options(future.plan = NULL)
[10:21:57.656]                   if (is.na(NA_character_)) 
[10:21:57.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:57.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:57.656]                     .init = FALSE)
[10:21:57.656]                 }
[10:21:57.656]             }
[10:21:57.656]         }
[10:21:57.656]     })
[10:21:57.656]     if (TRUE) {
[10:21:57.656]         base::sink(type = "output", split = FALSE)
[10:21:57.656]         if (TRUE) {
[10:21:57.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:57.656]         }
[10:21:57.656]         else {
[10:21:57.656]             ...future.result["stdout"] <- base::list(NULL)
[10:21:57.656]         }
[10:21:57.656]         base::close(...future.stdout)
[10:21:57.656]         ...future.stdout <- NULL
[10:21:57.656]     }
[10:21:57.656]     ...future.result$conditions <- ...future.conditions
[10:21:57.656]     ...future.result$finished <- base::Sys.time()
[10:21:57.656]     ...future.result
[10:21:57.656] }
[10:21:57.658] plan(): Setting new future strategy stack:
[10:21:57.658] List of future strategies:
[10:21:57.658] 1. sequential:
[10:21:57.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:57.658]    - tweaked: FALSE
[10:21:57.658]    - call: NULL
[10:21:57.659] plan(): nbrOfWorkers() = 1
[10:21:57.659] plan(): Setting new future strategy stack:
[10:21:57.660] List of future strategies:
[10:21:57.660] 1. sequential:
[10:21:57.660]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:57.660]    - tweaked: FALSE
[10:21:57.660]    - call: future::plan("sequential")
[10:21:57.660] plan(): nbrOfWorkers() = 1
[10:21:57.660] SequentialFuture started (and completed)
[10:21:57.660] - Launch lazy future ... done
[10:21:57.661] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[10:21:57.663] getGlobalsAndPackages() ...
[10:21:57.664] 
[10:21:57.664] - globals: [0] <none>
[10:21:57.664] getGlobalsAndPackages() ... DONE
[10:21:57.677] Packages needed by the future expression (n = 0): <none>
[10:21:57.677] Packages needed by future strategies (n = 0): <none>
[10:21:57.678] {
[10:21:57.678]     {
[10:21:57.678]         {
[10:21:57.678]             ...future.startTime <- base::Sys.time()
[10:21:57.678]             {
[10:21:57.678]                 {
[10:21:57.678]                   {
[10:21:57.678]                     {
[10:21:57.678]                       base::local({
[10:21:57.678]                         has_future <- base::requireNamespace("future", 
[10:21:57.678]                           quietly = TRUE)
[10:21:57.678]                         if (has_future) {
[10:21:57.678]                           ns <- base::getNamespace("future")
[10:21:57.678]                           version <- ns[[".package"]][["version"]]
[10:21:57.678]                           if (is.null(version)) 
[10:21:57.678]                             version <- utils::packageVersion("future")
[10:21:57.678]                         }
[10:21:57.678]                         else {
[10:21:57.678]                           version <- NULL
[10:21:57.678]                         }
[10:21:57.678]                         if (!has_future || version < "1.8.0") {
[10:21:57.678]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:57.678]                             "", base::R.version$version.string), 
[10:21:57.678]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:57.678]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:57.678]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:57.678]                               "release", "version")], collapse = " "), 
[10:21:57.678]                             hostname = base::Sys.info()[["nodename"]])
[10:21:57.678]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:57.678]                             info)
[10:21:57.678]                           info <- base::paste(info, collapse = "; ")
[10:21:57.678]                           if (!has_future) {
[10:21:57.678]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:57.678]                               info)
[10:21:57.678]                           }
[10:21:57.678]                           else {
[10:21:57.678]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:57.678]                               info, version)
[10:21:57.678]                           }
[10:21:57.678]                           base::stop(msg)
[10:21:57.678]                         }
[10:21:57.678]                       })
[10:21:57.678]                     }
[10:21:57.678]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:57.678]                     base::options(mc.cores = 1L)
[10:21:57.678]                   }
[10:21:57.678]                   ...future.strategy.old <- future::plan("list")
[10:21:57.678]                   options(future.plan = NULL)
[10:21:57.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:57.678]                 }
[10:21:57.678]                 ...future.workdir <- getwd()
[10:21:57.678]             }
[10:21:57.678]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:57.678]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:57.678]         }
[10:21:57.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:57.678]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:57.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:57.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:57.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:57.678]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:57.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:57.678]             base::names(...future.oldOptions))
[10:21:57.678]     }
[10:21:57.678]     if (FALSE) {
[10:21:57.678]     }
[10:21:57.678]     else {
[10:21:57.678]         if (TRUE) {
[10:21:57.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:57.678]                 open = "w")
[10:21:57.678]         }
[10:21:57.678]         else {
[10:21:57.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:57.678]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:57.678]         }
[10:21:57.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:57.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:57.678]             base::sink(type = "output", split = FALSE)
[10:21:57.678]             base::close(...future.stdout)
[10:21:57.678]         }, add = TRUE)
[10:21:57.678]     }
[10:21:57.678]     ...future.frame <- base::sys.nframe()
[10:21:57.678]     ...future.conditions <- base::list()
[10:21:57.678]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:57.678]     if (FALSE) {
[10:21:57.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:57.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:57.678]     }
[10:21:57.678]     ...future.result <- base::tryCatch({
[10:21:57.678]         base::withCallingHandlers({
[10:21:57.678]             ...future.value <- base::withVisible(base::local({
[10:21:57.678]                 ...future.makeSendCondition <- base::local({
[10:21:57.678]                   sendCondition <- NULL
[10:21:57.678]                   function(frame = 1L) {
[10:21:57.678]                     if (is.function(sendCondition)) 
[10:21:57.678]                       return(sendCondition)
[10:21:57.678]                     ns <- getNamespace("parallel")
[10:21:57.678]                     if (exists("sendData", mode = "function", 
[10:21:57.678]                       envir = ns)) {
[10:21:57.678]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:57.678]                         envir = ns)
[10:21:57.678]                       envir <- sys.frame(frame)
[10:21:57.678]                       master <- NULL
[10:21:57.678]                       while (!identical(envir, .GlobalEnv) && 
[10:21:57.678]                         !identical(envir, emptyenv())) {
[10:21:57.678]                         if (exists("master", mode = "list", envir = envir, 
[10:21:57.678]                           inherits = FALSE)) {
[10:21:57.678]                           master <- get("master", mode = "list", 
[10:21:57.678]                             envir = envir, inherits = FALSE)
[10:21:57.678]                           if (inherits(master, c("SOCKnode", 
[10:21:57.678]                             "SOCK0node"))) {
[10:21:57.678]                             sendCondition <<- function(cond) {
[10:21:57.678]                               data <- list(type = "VALUE", value = cond, 
[10:21:57.678]                                 success = TRUE)
[10:21:57.678]                               parallel_sendData(master, data)
[10:21:57.678]                             }
[10:21:57.678]                             return(sendCondition)
[10:21:57.678]                           }
[10:21:57.678]                         }
[10:21:57.678]                         frame <- frame + 1L
[10:21:57.678]                         envir <- sys.frame(frame)
[10:21:57.678]                       }
[10:21:57.678]                     }
[10:21:57.678]                     sendCondition <<- function(cond) NULL
[10:21:57.678]                   }
[10:21:57.678]                 })
[10:21:57.678]                 withCallingHandlers({
[10:21:57.678]                   {
[10:21:57.678]                     stop("Whoops!")
[10:21:57.678]                     1
[10:21:57.678]                   }
[10:21:57.678]                 }, immediateCondition = function(cond) {
[10:21:57.678]                   sendCondition <- ...future.makeSendCondition()
[10:21:57.678]                   sendCondition(cond)
[10:21:57.678]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.678]                   {
[10:21:57.678]                     inherits <- base::inherits
[10:21:57.678]                     invokeRestart <- base::invokeRestart
[10:21:57.678]                     is.null <- base::is.null
[10:21:57.678]                     muffled <- FALSE
[10:21:57.678]                     if (inherits(cond, "message")) {
[10:21:57.678]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:57.678]                       if (muffled) 
[10:21:57.678]                         invokeRestart("muffleMessage")
[10:21:57.678]                     }
[10:21:57.678]                     else if (inherits(cond, "warning")) {
[10:21:57.678]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:57.678]                       if (muffled) 
[10:21:57.678]                         invokeRestart("muffleWarning")
[10:21:57.678]                     }
[10:21:57.678]                     else if (inherits(cond, "condition")) {
[10:21:57.678]                       if (!is.null(pattern)) {
[10:21:57.678]                         computeRestarts <- base::computeRestarts
[10:21:57.678]                         grepl <- base::grepl
[10:21:57.678]                         restarts <- computeRestarts(cond)
[10:21:57.678]                         for (restart in restarts) {
[10:21:57.678]                           name <- restart$name
[10:21:57.678]                           if (is.null(name)) 
[10:21:57.678]                             next
[10:21:57.678]                           if (!grepl(pattern, name)) 
[10:21:57.678]                             next
[10:21:57.678]                           invokeRestart(restart)
[10:21:57.678]                           muffled <- TRUE
[10:21:57.678]                           break
[10:21:57.678]                         }
[10:21:57.678]                       }
[10:21:57.678]                     }
[10:21:57.678]                     invisible(muffled)
[10:21:57.678]                   }
[10:21:57.678]                   muffleCondition(cond)
[10:21:57.678]                 })
[10:21:57.678]             }))
[10:21:57.678]             future::FutureResult(value = ...future.value$value, 
[10:21:57.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.678]                   ...future.rng), globalenv = if (FALSE) 
[10:21:57.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:57.678]                     ...future.globalenv.names))
[10:21:57.678]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:57.678]         }, condition = base::local({
[10:21:57.678]             c <- base::c
[10:21:57.678]             inherits <- base::inherits
[10:21:57.678]             invokeRestart <- base::invokeRestart
[10:21:57.678]             length <- base::length
[10:21:57.678]             list <- base::list
[10:21:57.678]             seq.int <- base::seq.int
[10:21:57.678]             signalCondition <- base::signalCondition
[10:21:57.678]             sys.calls <- base::sys.calls
[10:21:57.678]             `[[` <- base::`[[`
[10:21:57.678]             `+` <- base::`+`
[10:21:57.678]             `<<-` <- base::`<<-`
[10:21:57.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:57.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:57.678]                   3L)]
[10:21:57.678]             }
[10:21:57.678]             function(cond) {
[10:21:57.678]                 is_error <- inherits(cond, "error")
[10:21:57.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:57.678]                   NULL)
[10:21:57.678]                 if (is_error) {
[10:21:57.678]                   sessionInformation <- function() {
[10:21:57.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:57.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:57.678]                       search = base::search(), system = base::Sys.info())
[10:21:57.678]                   }
[10:21:57.678]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:57.678]                     cond$call), session = sessionInformation(), 
[10:21:57.678]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:57.678]                   signalCondition(cond)
[10:21:57.678]                 }
[10:21:57.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:57.678]                 "immediateCondition"))) {
[10:21:57.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:57.678]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:57.678]                   if (TRUE && !signal) {
[10:21:57.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.678]                     {
[10:21:57.678]                       inherits <- base::inherits
[10:21:57.678]                       invokeRestart <- base::invokeRestart
[10:21:57.678]                       is.null <- base::is.null
[10:21:57.678]                       muffled <- FALSE
[10:21:57.678]                       if (inherits(cond, "message")) {
[10:21:57.678]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.678]                         if (muffled) 
[10:21:57.678]                           invokeRestart("muffleMessage")
[10:21:57.678]                       }
[10:21:57.678]                       else if (inherits(cond, "warning")) {
[10:21:57.678]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.678]                         if (muffled) 
[10:21:57.678]                           invokeRestart("muffleWarning")
[10:21:57.678]                       }
[10:21:57.678]                       else if (inherits(cond, "condition")) {
[10:21:57.678]                         if (!is.null(pattern)) {
[10:21:57.678]                           computeRestarts <- base::computeRestarts
[10:21:57.678]                           grepl <- base::grepl
[10:21:57.678]                           restarts <- computeRestarts(cond)
[10:21:57.678]                           for (restart in restarts) {
[10:21:57.678]                             name <- restart$name
[10:21:57.678]                             if (is.null(name)) 
[10:21:57.678]                               next
[10:21:57.678]                             if (!grepl(pattern, name)) 
[10:21:57.678]                               next
[10:21:57.678]                             invokeRestart(restart)
[10:21:57.678]                             muffled <- TRUE
[10:21:57.678]                             break
[10:21:57.678]                           }
[10:21:57.678]                         }
[10:21:57.678]                       }
[10:21:57.678]                       invisible(muffled)
[10:21:57.678]                     }
[10:21:57.678]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.678]                   }
[10:21:57.678]                 }
[10:21:57.678]                 else {
[10:21:57.678]                   if (TRUE) {
[10:21:57.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.678]                     {
[10:21:57.678]                       inherits <- base::inherits
[10:21:57.678]                       invokeRestart <- base::invokeRestart
[10:21:57.678]                       is.null <- base::is.null
[10:21:57.678]                       muffled <- FALSE
[10:21:57.678]                       if (inherits(cond, "message")) {
[10:21:57.678]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.678]                         if (muffled) 
[10:21:57.678]                           invokeRestart("muffleMessage")
[10:21:57.678]                       }
[10:21:57.678]                       else if (inherits(cond, "warning")) {
[10:21:57.678]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.678]                         if (muffled) 
[10:21:57.678]                           invokeRestart("muffleWarning")
[10:21:57.678]                       }
[10:21:57.678]                       else if (inherits(cond, "condition")) {
[10:21:57.678]                         if (!is.null(pattern)) {
[10:21:57.678]                           computeRestarts <- base::computeRestarts
[10:21:57.678]                           grepl <- base::grepl
[10:21:57.678]                           restarts <- computeRestarts(cond)
[10:21:57.678]                           for (restart in restarts) {
[10:21:57.678]                             name <- restart$name
[10:21:57.678]                             if (is.null(name)) 
[10:21:57.678]                               next
[10:21:57.678]                             if (!grepl(pattern, name)) 
[10:21:57.678]                               next
[10:21:57.678]                             invokeRestart(restart)
[10:21:57.678]                             muffled <- TRUE
[10:21:57.678]                             break
[10:21:57.678]                           }
[10:21:57.678]                         }
[10:21:57.678]                       }
[10:21:57.678]                       invisible(muffled)
[10:21:57.678]                     }
[10:21:57.678]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.678]                   }
[10:21:57.678]                 }
[10:21:57.678]             }
[10:21:57.678]         }))
[10:21:57.678]     }, error = function(ex) {
[10:21:57.678]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:57.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.678]                 ...future.rng), started = ...future.startTime, 
[10:21:57.678]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:57.678]             version = "1.8"), class = "FutureResult")
[10:21:57.678]     }, finally = {
[10:21:57.678]         if (!identical(...future.workdir, getwd())) 
[10:21:57.678]             setwd(...future.workdir)
[10:21:57.678]         {
[10:21:57.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:57.678]                 ...future.oldOptions$nwarnings <- NULL
[10:21:57.678]             }
[10:21:57.678]             base::options(...future.oldOptions)
[10:21:57.678]             if (.Platform$OS.type == "windows") {
[10:21:57.678]                 old_names <- names(...future.oldEnvVars)
[10:21:57.678]                 envs <- base::Sys.getenv()
[10:21:57.678]                 names <- names(envs)
[10:21:57.678]                 common <- intersect(names, old_names)
[10:21:57.678]                 added <- setdiff(names, old_names)
[10:21:57.678]                 removed <- setdiff(old_names, names)
[10:21:57.678]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:57.678]                   envs[common]]
[10:21:57.678]                 NAMES <- toupper(changed)
[10:21:57.678]                 args <- list()
[10:21:57.678]                 for (kk in seq_along(NAMES)) {
[10:21:57.678]                   name <- changed[[kk]]
[10:21:57.678]                   NAME <- NAMES[[kk]]
[10:21:57.678]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.678]                     next
[10:21:57.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.678]                 }
[10:21:57.678]                 NAMES <- toupper(added)
[10:21:57.678]                 for (kk in seq_along(NAMES)) {
[10:21:57.678]                   name <- added[[kk]]
[10:21:57.678]                   NAME <- NAMES[[kk]]
[10:21:57.678]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.678]                     next
[10:21:57.678]                   args[[name]] <- ""
[10:21:57.678]                 }
[10:21:57.678]                 NAMES <- toupper(removed)
[10:21:57.678]                 for (kk in seq_along(NAMES)) {
[10:21:57.678]                   name <- removed[[kk]]
[10:21:57.678]                   NAME <- NAMES[[kk]]
[10:21:57.678]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.678]                     next
[10:21:57.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.678]                 }
[10:21:57.678]                 if (length(args) > 0) 
[10:21:57.678]                   base::do.call(base::Sys.setenv, args = args)
[10:21:57.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:57.678]             }
[10:21:57.678]             else {
[10:21:57.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:57.678]             }
[10:21:57.678]             {
[10:21:57.678]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:57.678]                   0L) {
[10:21:57.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:57.678]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:57.678]                   base::options(opts)
[10:21:57.678]                 }
[10:21:57.678]                 {
[10:21:57.678]                   {
[10:21:57.678]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:57.678]                     NULL
[10:21:57.678]                   }
[10:21:57.678]                   options(future.plan = NULL)
[10:21:57.678]                   if (is.na(NA_character_)) 
[10:21:57.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:57.678]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:57.678]                     .init = FALSE)
[10:21:57.678]                 }
[10:21:57.678]             }
[10:21:57.678]         }
[10:21:57.678]     })
[10:21:57.678]     if (TRUE) {
[10:21:57.678]         base::sink(type = "output", split = FALSE)
[10:21:57.678]         if (TRUE) {
[10:21:57.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:57.678]         }
[10:21:57.678]         else {
[10:21:57.678]             ...future.result["stdout"] <- base::list(NULL)
[10:21:57.678]         }
[10:21:57.678]         base::close(...future.stdout)
[10:21:57.678]         ...future.stdout <- NULL
[10:21:57.678]     }
[10:21:57.678]     ...future.result$conditions <- ...future.conditions
[10:21:57.678]     ...future.result$finished <- base::Sys.time()
[10:21:57.678]     ...future.result
[10:21:57.678] }
[10:21:57.681] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 46d13282-a26d-1c6f-65b7-056826eaeb73
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:57.692] result() for ClusterFuture ...
[10:21:57.692] receiveMessageFromWorker() for ClusterFuture ...
[10:21:57.693] - Validating connection of MultisessionFuture
[10:21:57.724] - received message: FutureResult
[10:21:57.724] - Received FutureResult
[10:21:57.724] - Erased future from FutureRegistry
[10:21:57.725] result() for ClusterFuture ...
[10:21:57.725] - result already collected: FutureResult
[10:21:57.725] result() for ClusterFuture ... done
[10:21:57.725] signalConditions() ...
[10:21:57.725]  - include = ‘immediateCondition’
[10:21:57.725]  - exclude = 
[10:21:57.725]  - resignal = FALSE
[10:21:57.725]  - Number of conditions: 1
[10:21:57.726] signalConditions() ... done
[10:21:57.726] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:57.726] result() for ClusterFuture ... done
[10:21:57.726] result() for ClusterFuture ...
[10:21:57.726] - result already collected: FutureResult
[10:21:57.726] result() for ClusterFuture ... done
[10:21:57.726] signalConditions() ...
[10:21:57.726]  - include = ‘immediateCondition’
[10:21:57.726]  - exclude = 
[10:21:57.726]  - resignal = FALSE
[10:21:57.727]  - Number of conditions: 1
[10:21:57.727] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:21:57.727] result() for ClusterFuture ...
[10:21:57.727] - result already collected: FutureResult
[10:21:57.727] result() for ClusterFuture ... done
[10:21:57.727] result() for ClusterFuture ...
[10:21:57.728] - result already collected: FutureResult
[10:21:57.728] result() for ClusterFuture ... done
[10:21:57.728] signalConditions() ...
[10:21:57.728]  - include = ‘immediateCondition’
[10:21:57.728]  - exclude = 
[10:21:57.728]  - resignal = FALSE
[10:21:57.728]  - Number of conditions: 1
[10:21:57.728] signalConditions() ... done
[10:21:57.728] Future state: ‘finished’
[10:21:57.729] result() for ClusterFuture ...
[10:21:57.729] - result already collected: FutureResult
[10:21:57.729] result() for ClusterFuture ... done
[10:21:57.729] signalConditions() ...
[10:21:57.729]  - include = ‘condition’
[10:21:57.729]  - exclude = ‘immediateCondition’
[10:21:57.729]  - resignal = TRUE
[10:21:57.729]  - Number of conditions: 1
[10:21:57.729]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:57.730] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:21:57.730] result() for ClusterFuture ...
[10:21:57.730] - result already collected: FutureResult
[10:21:57.730] result() for ClusterFuture ... done
[10:21:57.730] result() for ClusterFuture ...
[10:21:57.730] - result already collected: FutureResult
[10:21:57.731] result() for ClusterFuture ... done
[10:21:57.731] signalConditions() ...
[10:21:57.731]  - include = ‘immediateCondition’
[10:21:57.731]  - exclude = 
[10:21:57.731]  - resignal = FALSE
[10:21:57.731]  - Number of conditions: 1
[10:21:57.731] signalConditions() ... done
[10:21:57.731] Future state: ‘finished’
[10:21:57.731] result() for ClusterFuture ...
[10:21:57.732] - result already collected: FutureResult
[10:21:57.732] result() for ClusterFuture ... done
[10:21:57.732] signalConditions() ...
[10:21:57.732]  - include = ‘condition’
[10:21:57.732]  - exclude = ‘immediateCondition’
[10:21:57.732]  - resignal = TRUE
[10:21:57.732]  - Number of conditions: 1
[10:21:57.732]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:57.732] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[10:21:57.734] getGlobalsAndPackages() ...
[10:21:57.735] 
[10:21:57.735] - globals: [0] <none>
[10:21:57.735] getGlobalsAndPackages() ... DONE
[10:21:57.748] Packages needed by the future expression (n = 0): <none>
[10:21:57.748] Packages needed by future strategies (n = 0): <none>
[10:21:57.749] {
[10:21:57.749]     {
[10:21:57.749]         {
[10:21:57.749]             ...future.startTime <- base::Sys.time()
[10:21:57.749]             {
[10:21:57.749]                 {
[10:21:57.749]                   {
[10:21:57.749]                     {
[10:21:57.749]                       base::local({
[10:21:57.749]                         has_future <- base::requireNamespace("future", 
[10:21:57.749]                           quietly = TRUE)
[10:21:57.749]                         if (has_future) {
[10:21:57.749]                           ns <- base::getNamespace("future")
[10:21:57.749]                           version <- ns[[".package"]][["version"]]
[10:21:57.749]                           if (is.null(version)) 
[10:21:57.749]                             version <- utils::packageVersion("future")
[10:21:57.749]                         }
[10:21:57.749]                         else {
[10:21:57.749]                           version <- NULL
[10:21:57.749]                         }
[10:21:57.749]                         if (!has_future || version < "1.8.0") {
[10:21:57.749]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:57.749]                             "", base::R.version$version.string), 
[10:21:57.749]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:57.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:57.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:57.749]                               "release", "version")], collapse = " "), 
[10:21:57.749]                             hostname = base::Sys.info()[["nodename"]])
[10:21:57.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:57.749]                             info)
[10:21:57.749]                           info <- base::paste(info, collapse = "; ")
[10:21:57.749]                           if (!has_future) {
[10:21:57.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:57.749]                               info)
[10:21:57.749]                           }
[10:21:57.749]                           else {
[10:21:57.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:57.749]                               info, version)
[10:21:57.749]                           }
[10:21:57.749]                           base::stop(msg)
[10:21:57.749]                         }
[10:21:57.749]                       })
[10:21:57.749]                     }
[10:21:57.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:57.749]                     base::options(mc.cores = 1L)
[10:21:57.749]                   }
[10:21:57.749]                   ...future.strategy.old <- future::plan("list")
[10:21:57.749]                   options(future.plan = NULL)
[10:21:57.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:57.749]                 }
[10:21:57.749]                 ...future.workdir <- getwd()
[10:21:57.749]             }
[10:21:57.749]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:57.749]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:57.749]         }
[10:21:57.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:57.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:57.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:57.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:57.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:57.749]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:57.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:57.749]             base::names(...future.oldOptions))
[10:21:57.749]     }
[10:21:57.749]     if (FALSE) {
[10:21:57.749]     }
[10:21:57.749]     else {
[10:21:57.749]         if (TRUE) {
[10:21:57.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:57.749]                 open = "w")
[10:21:57.749]         }
[10:21:57.749]         else {
[10:21:57.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:57.749]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:57.749]         }
[10:21:57.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:57.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:57.749]             base::sink(type = "output", split = FALSE)
[10:21:57.749]             base::close(...future.stdout)
[10:21:57.749]         }, add = TRUE)
[10:21:57.749]     }
[10:21:57.749]     ...future.frame <- base::sys.nframe()
[10:21:57.749]     ...future.conditions <- base::list()
[10:21:57.749]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:57.749]     if (FALSE) {
[10:21:57.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:57.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:57.749]     }
[10:21:57.749]     ...future.result <- base::tryCatch({
[10:21:57.749]         base::withCallingHandlers({
[10:21:57.749]             ...future.value <- base::withVisible(base::local({
[10:21:57.749]                 ...future.makeSendCondition <- base::local({
[10:21:57.749]                   sendCondition <- NULL
[10:21:57.749]                   function(frame = 1L) {
[10:21:57.749]                     if (is.function(sendCondition)) 
[10:21:57.749]                       return(sendCondition)
[10:21:57.749]                     ns <- getNamespace("parallel")
[10:21:57.749]                     if (exists("sendData", mode = "function", 
[10:21:57.749]                       envir = ns)) {
[10:21:57.749]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:57.749]                         envir = ns)
[10:21:57.749]                       envir <- sys.frame(frame)
[10:21:57.749]                       master <- NULL
[10:21:57.749]                       while (!identical(envir, .GlobalEnv) && 
[10:21:57.749]                         !identical(envir, emptyenv())) {
[10:21:57.749]                         if (exists("master", mode = "list", envir = envir, 
[10:21:57.749]                           inherits = FALSE)) {
[10:21:57.749]                           master <- get("master", mode = "list", 
[10:21:57.749]                             envir = envir, inherits = FALSE)
[10:21:57.749]                           if (inherits(master, c("SOCKnode", 
[10:21:57.749]                             "SOCK0node"))) {
[10:21:57.749]                             sendCondition <<- function(cond) {
[10:21:57.749]                               data <- list(type = "VALUE", value = cond, 
[10:21:57.749]                                 success = TRUE)
[10:21:57.749]                               parallel_sendData(master, data)
[10:21:57.749]                             }
[10:21:57.749]                             return(sendCondition)
[10:21:57.749]                           }
[10:21:57.749]                         }
[10:21:57.749]                         frame <- frame + 1L
[10:21:57.749]                         envir <- sys.frame(frame)
[10:21:57.749]                       }
[10:21:57.749]                     }
[10:21:57.749]                     sendCondition <<- function(cond) NULL
[10:21:57.749]                   }
[10:21:57.749]                 })
[10:21:57.749]                 withCallingHandlers({
[10:21:57.749]                   {
[10:21:57.749]                     stop(structure(list(message = "boom"), class = c("MyError", 
[10:21:57.749]                       "error", "condition")))
[10:21:57.749]                   }
[10:21:57.749]                 }, immediateCondition = function(cond) {
[10:21:57.749]                   sendCondition <- ...future.makeSendCondition()
[10:21:57.749]                   sendCondition(cond)
[10:21:57.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.749]                   {
[10:21:57.749]                     inherits <- base::inherits
[10:21:57.749]                     invokeRestart <- base::invokeRestart
[10:21:57.749]                     is.null <- base::is.null
[10:21:57.749]                     muffled <- FALSE
[10:21:57.749]                     if (inherits(cond, "message")) {
[10:21:57.749]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:57.749]                       if (muffled) 
[10:21:57.749]                         invokeRestart("muffleMessage")
[10:21:57.749]                     }
[10:21:57.749]                     else if (inherits(cond, "warning")) {
[10:21:57.749]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:57.749]                       if (muffled) 
[10:21:57.749]                         invokeRestart("muffleWarning")
[10:21:57.749]                     }
[10:21:57.749]                     else if (inherits(cond, "condition")) {
[10:21:57.749]                       if (!is.null(pattern)) {
[10:21:57.749]                         computeRestarts <- base::computeRestarts
[10:21:57.749]                         grepl <- base::grepl
[10:21:57.749]                         restarts <- computeRestarts(cond)
[10:21:57.749]                         for (restart in restarts) {
[10:21:57.749]                           name <- restart$name
[10:21:57.749]                           if (is.null(name)) 
[10:21:57.749]                             next
[10:21:57.749]                           if (!grepl(pattern, name)) 
[10:21:57.749]                             next
[10:21:57.749]                           invokeRestart(restart)
[10:21:57.749]                           muffled <- TRUE
[10:21:57.749]                           break
[10:21:57.749]                         }
[10:21:57.749]                       }
[10:21:57.749]                     }
[10:21:57.749]                     invisible(muffled)
[10:21:57.749]                   }
[10:21:57.749]                   muffleCondition(cond)
[10:21:57.749]                 })
[10:21:57.749]             }))
[10:21:57.749]             future::FutureResult(value = ...future.value$value, 
[10:21:57.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.749]                   ...future.rng), globalenv = if (FALSE) 
[10:21:57.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:57.749]                     ...future.globalenv.names))
[10:21:57.749]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:57.749]         }, condition = base::local({
[10:21:57.749]             c <- base::c
[10:21:57.749]             inherits <- base::inherits
[10:21:57.749]             invokeRestart <- base::invokeRestart
[10:21:57.749]             length <- base::length
[10:21:57.749]             list <- base::list
[10:21:57.749]             seq.int <- base::seq.int
[10:21:57.749]             signalCondition <- base::signalCondition
[10:21:57.749]             sys.calls <- base::sys.calls
[10:21:57.749]             `[[` <- base::`[[`
[10:21:57.749]             `+` <- base::`+`
[10:21:57.749]             `<<-` <- base::`<<-`
[10:21:57.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:57.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:57.749]                   3L)]
[10:21:57.749]             }
[10:21:57.749]             function(cond) {
[10:21:57.749]                 is_error <- inherits(cond, "error")
[10:21:57.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:57.749]                   NULL)
[10:21:57.749]                 if (is_error) {
[10:21:57.749]                   sessionInformation <- function() {
[10:21:57.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:57.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:57.749]                       search = base::search(), system = base::Sys.info())
[10:21:57.749]                   }
[10:21:57.749]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:57.749]                     cond$call), session = sessionInformation(), 
[10:21:57.749]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:57.749]                   signalCondition(cond)
[10:21:57.749]                 }
[10:21:57.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:57.749]                 "immediateCondition"))) {
[10:21:57.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:57.749]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:57.749]                   if (TRUE && !signal) {
[10:21:57.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.749]                     {
[10:21:57.749]                       inherits <- base::inherits
[10:21:57.749]                       invokeRestart <- base::invokeRestart
[10:21:57.749]                       is.null <- base::is.null
[10:21:57.749]                       muffled <- FALSE
[10:21:57.749]                       if (inherits(cond, "message")) {
[10:21:57.749]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.749]                         if (muffled) 
[10:21:57.749]                           invokeRestart("muffleMessage")
[10:21:57.749]                       }
[10:21:57.749]                       else if (inherits(cond, "warning")) {
[10:21:57.749]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.749]                         if (muffled) 
[10:21:57.749]                           invokeRestart("muffleWarning")
[10:21:57.749]                       }
[10:21:57.749]                       else if (inherits(cond, "condition")) {
[10:21:57.749]                         if (!is.null(pattern)) {
[10:21:57.749]                           computeRestarts <- base::computeRestarts
[10:21:57.749]                           grepl <- base::grepl
[10:21:57.749]                           restarts <- computeRestarts(cond)
[10:21:57.749]                           for (restart in restarts) {
[10:21:57.749]                             name <- restart$name
[10:21:57.749]                             if (is.null(name)) 
[10:21:57.749]                               next
[10:21:57.749]                             if (!grepl(pattern, name)) 
[10:21:57.749]                               next
[10:21:57.749]                             invokeRestart(restart)
[10:21:57.749]                             muffled <- TRUE
[10:21:57.749]                             break
[10:21:57.749]                           }
[10:21:57.749]                         }
[10:21:57.749]                       }
[10:21:57.749]                       invisible(muffled)
[10:21:57.749]                     }
[10:21:57.749]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.749]                   }
[10:21:57.749]                 }
[10:21:57.749]                 else {
[10:21:57.749]                   if (TRUE) {
[10:21:57.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.749]                     {
[10:21:57.749]                       inherits <- base::inherits
[10:21:57.749]                       invokeRestart <- base::invokeRestart
[10:21:57.749]                       is.null <- base::is.null
[10:21:57.749]                       muffled <- FALSE
[10:21:57.749]                       if (inherits(cond, "message")) {
[10:21:57.749]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.749]                         if (muffled) 
[10:21:57.749]                           invokeRestart("muffleMessage")
[10:21:57.749]                       }
[10:21:57.749]                       else if (inherits(cond, "warning")) {
[10:21:57.749]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.749]                         if (muffled) 
[10:21:57.749]                           invokeRestart("muffleWarning")
[10:21:57.749]                       }
[10:21:57.749]                       else if (inherits(cond, "condition")) {
[10:21:57.749]                         if (!is.null(pattern)) {
[10:21:57.749]                           computeRestarts <- base::computeRestarts
[10:21:57.749]                           grepl <- base::grepl
[10:21:57.749]                           restarts <- computeRestarts(cond)
[10:21:57.749]                           for (restart in restarts) {
[10:21:57.749]                             name <- restart$name
[10:21:57.749]                             if (is.null(name)) 
[10:21:57.749]                               next
[10:21:57.749]                             if (!grepl(pattern, name)) 
[10:21:57.749]                               next
[10:21:57.749]                             invokeRestart(restart)
[10:21:57.749]                             muffled <- TRUE
[10:21:57.749]                             break
[10:21:57.749]                           }
[10:21:57.749]                         }
[10:21:57.749]                       }
[10:21:57.749]                       invisible(muffled)
[10:21:57.749]                     }
[10:21:57.749]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.749]                   }
[10:21:57.749]                 }
[10:21:57.749]             }
[10:21:57.749]         }))
[10:21:57.749]     }, error = function(ex) {
[10:21:57.749]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:57.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.749]                 ...future.rng), started = ...future.startTime, 
[10:21:57.749]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:57.749]             version = "1.8"), class = "FutureResult")
[10:21:57.749]     }, finally = {
[10:21:57.749]         if (!identical(...future.workdir, getwd())) 
[10:21:57.749]             setwd(...future.workdir)
[10:21:57.749]         {
[10:21:57.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:57.749]                 ...future.oldOptions$nwarnings <- NULL
[10:21:57.749]             }
[10:21:57.749]             base::options(...future.oldOptions)
[10:21:57.749]             if (.Platform$OS.type == "windows") {
[10:21:57.749]                 old_names <- names(...future.oldEnvVars)
[10:21:57.749]                 envs <- base::Sys.getenv()
[10:21:57.749]                 names <- names(envs)
[10:21:57.749]                 common <- intersect(names, old_names)
[10:21:57.749]                 added <- setdiff(names, old_names)
[10:21:57.749]                 removed <- setdiff(old_names, names)
[10:21:57.749]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:57.749]                   envs[common]]
[10:21:57.749]                 NAMES <- toupper(changed)
[10:21:57.749]                 args <- list()
[10:21:57.749]                 for (kk in seq_along(NAMES)) {
[10:21:57.749]                   name <- changed[[kk]]
[10:21:57.749]                   NAME <- NAMES[[kk]]
[10:21:57.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.749]                     next
[10:21:57.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.749]                 }
[10:21:57.749]                 NAMES <- toupper(added)
[10:21:57.749]                 for (kk in seq_along(NAMES)) {
[10:21:57.749]                   name <- added[[kk]]
[10:21:57.749]                   NAME <- NAMES[[kk]]
[10:21:57.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.749]                     next
[10:21:57.749]                   args[[name]] <- ""
[10:21:57.749]                 }
[10:21:57.749]                 NAMES <- toupper(removed)
[10:21:57.749]                 for (kk in seq_along(NAMES)) {
[10:21:57.749]                   name <- removed[[kk]]
[10:21:57.749]                   NAME <- NAMES[[kk]]
[10:21:57.749]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.749]                     next
[10:21:57.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.749]                 }
[10:21:57.749]                 if (length(args) > 0) 
[10:21:57.749]                   base::do.call(base::Sys.setenv, args = args)
[10:21:57.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:57.749]             }
[10:21:57.749]             else {
[10:21:57.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:57.749]             }
[10:21:57.749]             {
[10:21:57.749]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:57.749]                   0L) {
[10:21:57.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:57.749]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:57.749]                   base::options(opts)
[10:21:57.749]                 }
[10:21:57.749]                 {
[10:21:57.749]                   {
[10:21:57.749]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:57.749]                     NULL
[10:21:57.749]                   }
[10:21:57.749]                   options(future.plan = NULL)
[10:21:57.749]                   if (is.na(NA_character_)) 
[10:21:57.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:57.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:57.749]                     .init = FALSE)
[10:21:57.749]                 }
[10:21:57.749]             }
[10:21:57.749]         }
[10:21:57.749]     })
[10:21:57.749]     if (TRUE) {
[10:21:57.749]         base::sink(type = "output", split = FALSE)
[10:21:57.749]         if (TRUE) {
[10:21:57.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:57.749]         }
[10:21:57.749]         else {
[10:21:57.749]             ...future.result["stdout"] <- base::list(NULL)
[10:21:57.749]         }
[10:21:57.749]         base::close(...future.stdout)
[10:21:57.749]         ...future.stdout <- NULL
[10:21:57.749]     }
[10:21:57.749]     ...future.result$conditions <- ...future.conditions
[10:21:57.749]     ...future.result$finished <- base::Sys.time()
[10:21:57.749]     ...future.result
[10:21:57.749] }
[10:21:57.752] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 46d13282-a26d-1c6f-65b7-056826eaeb73
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:57.763] result() for ClusterFuture ...
[10:21:57.763] receiveMessageFromWorker() for ClusterFuture ...
[10:21:57.763] - Validating connection of MultisessionFuture
[10:21:57.794] - received message: FutureResult
[10:21:57.795] - Received FutureResult
[10:21:57.795] - Erased future from FutureRegistry
[10:21:57.795] result() for ClusterFuture ...
[10:21:57.795] - result already collected: FutureResult
[10:21:57.795] result() for ClusterFuture ... done
[10:21:57.795] signalConditions() ...
[10:21:57.795]  - include = ‘immediateCondition’
[10:21:57.795]  - exclude = 
[10:21:57.796]  - resignal = FALSE
[10:21:57.796]  - Number of conditions: 1
[10:21:57.796] signalConditions() ... done
[10:21:57.796] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:57.796] result() for ClusterFuture ... done
[10:21:57.796] result() for ClusterFuture ...
[10:21:57.796] - result already collected: FutureResult
[10:21:57.796] result() for ClusterFuture ... done
[10:21:57.796] signalConditions() ...
[10:21:57.796]  - include = ‘immediateCondition’
[10:21:57.797]  - exclude = 
[10:21:57.797]  - resignal = FALSE
[10:21:57.797]  - Number of conditions: 1
[10:21:57.797] signalConditions() ... done
<MyError: boom>
[10:21:57.797] result() for ClusterFuture ...
[10:21:57.797] - result already collected: FutureResult
[10:21:57.797] result() for ClusterFuture ... done
[10:21:57.797] result() for ClusterFuture ...
[10:21:57.798] - result already collected: FutureResult
[10:21:57.798] result() for ClusterFuture ... done
[10:21:57.798] signalConditions() ...
[10:21:57.798]  - include = ‘immediateCondition’
[10:21:57.798]  - exclude = 
[10:21:57.798]  - resignal = FALSE
[10:21:57.798]  - Number of conditions: 1
[10:21:57.798] signalConditions() ... done
[10:21:57.798] Future state: ‘finished’
[10:21:57.798] result() for ClusterFuture ...
[10:21:57.799] - result already collected: FutureResult
[10:21:57.799] result() for ClusterFuture ... done
[10:21:57.799] signalConditions() ...
[10:21:57.799]  - include = ‘condition’
[10:21:57.799]  - exclude = ‘immediateCondition’
[10:21:57.799]  - resignal = TRUE
[10:21:57.799]  - Number of conditions: 1
[10:21:57.799]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[10:21:57.799] signalConditions() ... done
Testing with 2 cores ... DONE
> 
> 
> message("*** multisession() - too large globals ... DONE")
*** multisession() - too large globals ... DONE
> 
> message("*** multisession(..., workers = 1L) ...")
*** multisession(..., workers = 1L) ...
> 
> a <- 2
> b <- 3
> yTruth <- a * b
> 
> f <- multisession({ a * b }, globals = TRUE, workers = 1L)
[10:21:57.800] getGlobalsAndPackages() ...
[10:21:57.803] Searching for globals...
[10:21:57.805] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[10:21:57.805] Searching for globals ... DONE
[10:21:57.805] Resolving globals: FALSE
[10:21:57.806] The total size of the 2 globals is 78 bytes (78 bytes)
[10:21:57.806] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 78 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘b’ (39 bytes of class ‘numeric’)
[10:21:57.806] - globals: [2] ‘a’, ‘b’
[10:21:57.806] 
[10:21:57.807] getGlobalsAndPackages() ... DONE
> rm(list = c("a", "b"))
> 
> v <- value(f)
[10:21:57.807] Packages needed by the future expression (n = 0): <none>
[10:21:57.807] Packages needed by future strategies (n = 0): <none>
[10:21:57.808] {
[10:21:57.808]     {
[10:21:57.808]         {
[10:21:57.808]             ...future.startTime <- base::Sys.time()
[10:21:57.808]             {
[10:21:57.808]                 {
[10:21:57.808]                   {
[10:21:57.808]                     base::local({
[10:21:57.808]                       has_future <- base::requireNamespace("future", 
[10:21:57.808]                         quietly = TRUE)
[10:21:57.808]                       if (has_future) {
[10:21:57.808]                         ns <- base::getNamespace("future")
[10:21:57.808]                         version <- ns[[".package"]][["version"]]
[10:21:57.808]                         if (is.null(version)) 
[10:21:57.808]                           version <- utils::packageVersion("future")
[10:21:57.808]                       }
[10:21:57.808]                       else {
[10:21:57.808]                         version <- NULL
[10:21:57.808]                       }
[10:21:57.808]                       if (!has_future || version < "1.8.0") {
[10:21:57.808]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:57.808]                           "", base::R.version$version.string), 
[10:21:57.808]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:57.808]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:57.808]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:57.808]                             "release", "version")], collapse = " "), 
[10:21:57.808]                           hostname = base::Sys.info()[["nodename"]])
[10:21:57.808]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:57.808]                           info)
[10:21:57.808]                         info <- base::paste(info, collapse = "; ")
[10:21:57.808]                         if (!has_future) {
[10:21:57.808]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:57.808]                             info)
[10:21:57.808]                         }
[10:21:57.808]                         else {
[10:21:57.808]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:57.808]                             info, version)
[10:21:57.808]                         }
[10:21:57.808]                         base::stop(msg)
[10:21:57.808]                       }
[10:21:57.808]                     })
[10:21:57.808]                   }
[10:21:57.808]                   ...future.strategy.old <- future::plan("list")
[10:21:57.808]                   options(future.plan = NULL)
[10:21:57.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:57.808]                 }
[10:21:57.808]                 ...future.workdir <- getwd()
[10:21:57.808]             }
[10:21:57.808]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:57.808]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:57.808]         }
[10:21:57.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:57.808]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:57.808]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:57.808]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:57.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:57.808]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:57.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:57.808]             base::names(...future.oldOptions))
[10:21:57.808]     }
[10:21:57.808]     if (FALSE) {
[10:21:57.808]     }
[10:21:57.808]     else {
[10:21:57.808]         if (TRUE) {
[10:21:57.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:57.808]                 open = "w")
[10:21:57.808]         }
[10:21:57.808]         else {
[10:21:57.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:57.808]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:57.808]         }
[10:21:57.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:57.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:57.808]             base::sink(type = "output", split = FALSE)
[10:21:57.808]             base::close(...future.stdout)
[10:21:57.808]         }, add = TRUE)
[10:21:57.808]     }
[10:21:57.808]     ...future.frame <- base::sys.nframe()
[10:21:57.808]     ...future.conditions <- base::list()
[10:21:57.808]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:57.808]     if (FALSE) {
[10:21:57.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:57.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:57.808]     }
[10:21:57.808]     ...future.result <- base::tryCatch({
[10:21:57.808]         base::withCallingHandlers({
[10:21:57.808]             ...future.value <- base::withVisible(base::local({
[10:21:57.808]                 a * b
[10:21:57.808]             }))
[10:21:57.808]             future::FutureResult(value = ...future.value$value, 
[10:21:57.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.808]                   ...future.rng), globalenv = if (FALSE) 
[10:21:57.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:57.808]                     ...future.globalenv.names))
[10:21:57.808]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:57.808]         }, condition = base::local({
[10:21:57.808]             c <- base::c
[10:21:57.808]             inherits <- base::inherits
[10:21:57.808]             invokeRestart <- base::invokeRestart
[10:21:57.808]             length <- base::length
[10:21:57.808]             list <- base::list
[10:21:57.808]             seq.int <- base::seq.int
[10:21:57.808]             signalCondition <- base::signalCondition
[10:21:57.808]             sys.calls <- base::sys.calls
[10:21:57.808]             `[[` <- base::`[[`
[10:21:57.808]             `+` <- base::`+`
[10:21:57.808]             `<<-` <- base::`<<-`
[10:21:57.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:57.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:57.808]                   3L)]
[10:21:57.808]             }
[10:21:57.808]             function(cond) {
[10:21:57.808]                 is_error <- inherits(cond, "error")
[10:21:57.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:57.808]                   NULL)
[10:21:57.808]                 if (is_error) {
[10:21:57.808]                   sessionInformation <- function() {
[10:21:57.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:57.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:57.808]                       search = base::search(), system = base::Sys.info())
[10:21:57.808]                   }
[10:21:57.808]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:57.808]                     cond$call), session = sessionInformation(), 
[10:21:57.808]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:57.808]                   signalCondition(cond)
[10:21:57.808]                 }
[10:21:57.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:57.808]                 "immediateCondition"))) {
[10:21:57.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:57.808]                   ...future.conditions[[length(...future.conditions) + 
[10:21:57.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:57.808]                   if (TRUE && !signal) {
[10:21:57.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.808]                     {
[10:21:57.808]                       inherits <- base::inherits
[10:21:57.808]                       invokeRestart <- base::invokeRestart
[10:21:57.808]                       is.null <- base::is.null
[10:21:57.808]                       muffled <- FALSE
[10:21:57.808]                       if (inherits(cond, "message")) {
[10:21:57.808]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.808]                         if (muffled) 
[10:21:57.808]                           invokeRestart("muffleMessage")
[10:21:57.808]                       }
[10:21:57.808]                       else if (inherits(cond, "warning")) {
[10:21:57.808]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.808]                         if (muffled) 
[10:21:57.808]                           invokeRestart("muffleWarning")
[10:21:57.808]                       }
[10:21:57.808]                       else if (inherits(cond, "condition")) {
[10:21:57.808]                         if (!is.null(pattern)) {
[10:21:57.808]                           computeRestarts <- base::computeRestarts
[10:21:57.808]                           grepl <- base::grepl
[10:21:57.808]                           restarts <- computeRestarts(cond)
[10:21:57.808]                           for (restart in restarts) {
[10:21:57.808]                             name <- restart$name
[10:21:57.808]                             if (is.null(name)) 
[10:21:57.808]                               next
[10:21:57.808]                             if (!grepl(pattern, name)) 
[10:21:57.808]                               next
[10:21:57.808]                             invokeRestart(restart)
[10:21:57.808]                             muffled <- TRUE
[10:21:57.808]                             break
[10:21:57.808]                           }
[10:21:57.808]                         }
[10:21:57.808]                       }
[10:21:57.808]                       invisible(muffled)
[10:21:57.808]                     }
[10:21:57.808]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.808]                   }
[10:21:57.808]                 }
[10:21:57.808]                 else {
[10:21:57.808]                   if (TRUE) {
[10:21:57.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:57.808]                     {
[10:21:57.808]                       inherits <- base::inherits
[10:21:57.808]                       invokeRestart <- base::invokeRestart
[10:21:57.808]                       is.null <- base::is.null
[10:21:57.808]                       muffled <- FALSE
[10:21:57.808]                       if (inherits(cond, "message")) {
[10:21:57.808]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:57.808]                         if (muffled) 
[10:21:57.808]                           invokeRestart("muffleMessage")
[10:21:57.808]                       }
[10:21:57.808]                       else if (inherits(cond, "warning")) {
[10:21:57.808]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:57.808]                         if (muffled) 
[10:21:57.808]                           invokeRestart("muffleWarning")
[10:21:57.808]                       }
[10:21:57.808]                       else if (inherits(cond, "condition")) {
[10:21:57.808]                         if (!is.null(pattern)) {
[10:21:57.808]                           computeRestarts <- base::computeRestarts
[10:21:57.808]                           grepl <- base::grepl
[10:21:57.808]                           restarts <- computeRestarts(cond)
[10:21:57.808]                           for (restart in restarts) {
[10:21:57.808]                             name <- restart$name
[10:21:57.808]                             if (is.null(name)) 
[10:21:57.808]                               next
[10:21:57.808]                             if (!grepl(pattern, name)) 
[10:21:57.808]                               next
[10:21:57.808]                             invokeRestart(restart)
[10:21:57.808]                             muffled <- TRUE
[10:21:57.808]                             break
[10:21:57.808]                           }
[10:21:57.808]                         }
[10:21:57.808]                       }
[10:21:57.808]                       invisible(muffled)
[10:21:57.808]                     }
[10:21:57.808]                     muffleCondition(cond, pattern = "^muffle")
[10:21:57.808]                   }
[10:21:57.808]                 }
[10:21:57.808]             }
[10:21:57.808]         }))
[10:21:57.808]     }, error = function(ex) {
[10:21:57.808]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:57.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:57.808]                 ...future.rng), started = ...future.startTime, 
[10:21:57.808]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:57.808]             version = "1.8"), class = "FutureResult")
[10:21:57.808]     }, finally = {
[10:21:57.808]         if (!identical(...future.workdir, getwd())) 
[10:21:57.808]             setwd(...future.workdir)
[10:21:57.808]         {
[10:21:57.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:57.808]                 ...future.oldOptions$nwarnings <- NULL
[10:21:57.808]             }
[10:21:57.808]             base::options(...future.oldOptions)
[10:21:57.808]             if (.Platform$OS.type == "windows") {
[10:21:57.808]                 old_names <- names(...future.oldEnvVars)
[10:21:57.808]                 envs <- base::Sys.getenv()
[10:21:57.808]                 names <- names(envs)
[10:21:57.808]                 common <- intersect(names, old_names)
[10:21:57.808]                 added <- setdiff(names, old_names)
[10:21:57.808]                 removed <- setdiff(old_names, names)
[10:21:57.808]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:57.808]                   envs[common]]
[10:21:57.808]                 NAMES <- toupper(changed)
[10:21:57.808]                 args <- list()
[10:21:57.808]                 for (kk in seq_along(NAMES)) {
[10:21:57.808]                   name <- changed[[kk]]
[10:21:57.808]                   NAME <- NAMES[[kk]]
[10:21:57.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.808]                     next
[10:21:57.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.808]                 }
[10:21:57.808]                 NAMES <- toupper(added)
[10:21:57.808]                 for (kk in seq_along(NAMES)) {
[10:21:57.808]                   name <- added[[kk]]
[10:21:57.808]                   NAME <- NAMES[[kk]]
[10:21:57.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.808]                     next
[10:21:57.808]                   args[[name]] <- ""
[10:21:57.808]                 }
[10:21:57.808]                 NAMES <- toupper(removed)
[10:21:57.808]                 for (kk in seq_along(NAMES)) {
[10:21:57.808]                   name <- removed[[kk]]
[10:21:57.808]                   NAME <- NAMES[[kk]]
[10:21:57.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:57.808]                     next
[10:21:57.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:57.808]                 }
[10:21:57.808]                 if (length(args) > 0) 
[10:21:57.808]                   base::do.call(base::Sys.setenv, args = args)
[10:21:57.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:57.808]             }
[10:21:57.808]             else {
[10:21:57.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:57.808]             }
[10:21:57.808]             {
[10:21:57.808]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:57.808]                   0L) {
[10:21:57.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:57.808]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:57.808]                   base::options(opts)
[10:21:57.808]                 }
[10:21:57.808]                 {
[10:21:57.808]                   {
[10:21:57.808]                     NULL
[10:21:57.808]                     RNGkind("Mersenne-Twister")
[10:21:57.808]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:57.808]                       inherits = FALSE)
[10:21:57.808]                   }
[10:21:57.808]                   options(future.plan = NULL)
[10:21:57.808]                   if (is.na(NA_character_)) 
[10:21:57.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:57.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:57.808]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:57.808]                     .init = FALSE)
[10:21:57.808]                 }
[10:21:57.808]             }
[10:21:57.808]         }
[10:21:57.808]     })
[10:21:57.808]     if (TRUE) {
[10:21:57.808]         base::sink(type = "output", split = FALSE)
[10:21:57.808]         if (TRUE) {
[10:21:57.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:57.808]         }
[10:21:57.808]         else {
[10:21:57.808]             ...future.result["stdout"] <- base::list(NULL)
[10:21:57.808]         }
[10:21:57.808]         base::close(...future.stdout)
[10:21:57.808]         ...future.stdout <- NULL
[10:21:57.808]     }
[10:21:57.808]     ...future.result$conditions <- ...future.conditions
[10:21:57.808]     ...future.result$finished <- base::Sys.time()
[10:21:57.808]     ...future.result
[10:21:57.808] }
[10:21:57.810] assign_globals() ...
[10:21:57.810] List of 2
[10:21:57.810]  $ a: num 2
[10:21:57.810]  $ b: num 3
[10:21:57.810]  - attr(*, "where")=List of 2
[10:21:57.810]   ..$ a:<environment: R_EmptyEnv> 
[10:21:57.810]   ..$ b:<environment: R_EmptyEnv> 
[10:21:57.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:57.810]  - attr(*, "resolved")= logi FALSE
[10:21:57.810]  - attr(*, "total_size")= num 78
[10:21:57.813] - copied ‘a’ to environment
[10:21:57.813] - copied ‘b’ to environment
[10:21:57.813] assign_globals() ... done
[10:21:57.814] plan(): Setting new future strategy stack:
[10:21:57.814] List of future strategies:
[10:21:57.814] 1. sequential:
[10:21:57.814]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:57.814]    - tweaked: FALSE
[10:21:57.814]    - call: NULL
[10:21:57.814] plan(): nbrOfWorkers() = 1
[10:21:57.815] plan(): Setting new future strategy stack:
[10:21:57.815] List of future strategies:
[10:21:57.815] 1. sequential:
[10:21:57.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:57.815]    - tweaked: FALSE
[10:21:57.815]    - call: future::plan("sequential")
[10:21:57.815] plan(): nbrOfWorkers() = 1
[10:21:57.816] SequentialFuture started (and completed)
> print(v)
[1] 6
> stopifnot(v == yTruth)
> 
> message("*** multisession(..., workers = 1L) ... DONE")
*** multisession(..., workers = 1L) ... DONE
> 
> 
> message("*** multisession(..., gc = TRUE) ...")
*** multisession(..., gc = TRUE) ...
> plan(multisession, workers = 2L)
[10:21:57.816] plan(): Setting new future strategy stack:
[10:21:57.817] List of future strategies:
[10:21:57.817] 1. multisession:
[10:21:57.817]    - args: function (..., workers = 2L, envir = parent.frame())
[10:21:57.817]    - tweaked: TRUE
[10:21:57.817]    - call: plan(multisession, workers = 2L)
[10:21:57.827] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:57.827] multisession:
[10:21:57.827] - args: function (..., workers = 2L, envir = parent.frame())
[10:21:57.827] - tweaked: TRUE
[10:21:57.827] - call: plan(multisession, workers = 2L)
[10:21:57.828] getGlobalsAndPackages() ...
[10:21:57.828] Not searching for globals
[10:21:57.828] - globals: [0] <none>
[10:21:57.828] getGlobalsAndPackages() ... DONE
[10:21:58.093] Packages needed by the future expression (n = 0): <none>
[10:21:58.094] Packages needed by future strategies (n = 0): <none>
[10:21:58.094] {
[10:21:58.094]     {
[10:21:58.094]         {
[10:21:58.094]             ...future.startTime <- base::Sys.time()
[10:21:58.094]             {
[10:21:58.094]                 {
[10:21:58.094]                   {
[10:21:58.094]                     {
[10:21:58.094]                       base::local({
[10:21:58.094]                         has_future <- base::requireNamespace("future", 
[10:21:58.094]                           quietly = TRUE)
[10:21:58.094]                         if (has_future) {
[10:21:58.094]                           ns <- base::getNamespace("future")
[10:21:58.094]                           version <- ns[[".package"]][["version"]]
[10:21:58.094]                           if (is.null(version)) 
[10:21:58.094]                             version <- utils::packageVersion("future")
[10:21:58.094]                         }
[10:21:58.094]                         else {
[10:21:58.094]                           version <- NULL
[10:21:58.094]                         }
[10:21:58.094]                         if (!has_future || version < "1.8.0") {
[10:21:58.094]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:58.094]                             "", base::R.version$version.string), 
[10:21:58.094]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:58.094]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:58.094]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:58.094]                               "release", "version")], collapse = " "), 
[10:21:58.094]                             hostname = base::Sys.info()[["nodename"]])
[10:21:58.094]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:58.094]                             info)
[10:21:58.094]                           info <- base::paste(info, collapse = "; ")
[10:21:58.094]                           if (!has_future) {
[10:21:58.094]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:58.094]                               info)
[10:21:58.094]                           }
[10:21:58.094]                           else {
[10:21:58.094]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:58.094]                               info, version)
[10:21:58.094]                           }
[10:21:58.094]                           base::stop(msg)
[10:21:58.094]                         }
[10:21:58.094]                       })
[10:21:58.094]                     }
[10:21:58.094]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:58.094]                     base::options(mc.cores = 1L)
[10:21:58.094]                   }
[10:21:58.094]                   ...future.strategy.old <- future::plan("list")
[10:21:58.094]                   options(future.plan = NULL)
[10:21:58.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:58.094]                 }
[10:21:58.094]                 ...future.workdir <- getwd()
[10:21:58.094]             }
[10:21:58.094]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:58.094]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:58.094]         }
[10:21:58.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:58.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:58.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:58.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:58.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:58.094]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:58.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:58.094]             base::names(...future.oldOptions))
[10:21:58.094]     }
[10:21:58.094]     if (FALSE) {
[10:21:58.094]     }
[10:21:58.094]     else {
[10:21:58.094]         if (TRUE) {
[10:21:58.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:58.094]                 open = "w")
[10:21:58.094]         }
[10:21:58.094]         else {
[10:21:58.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:58.094]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:58.094]         }
[10:21:58.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:58.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:58.094]             base::sink(type = "output", split = FALSE)
[10:21:58.094]             base::close(...future.stdout)
[10:21:58.094]         }, add = TRUE)
[10:21:58.094]     }
[10:21:58.094]     ...future.frame <- base::sys.nframe()
[10:21:58.094]     ...future.conditions <- base::list()
[10:21:58.094]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:58.094]     if (FALSE) {
[10:21:58.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:58.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:58.094]     }
[10:21:58.094]     ...future.result <- base::tryCatch({
[10:21:58.094]         base::withCallingHandlers({
[10:21:58.094]             ...future.value <- base::withVisible(base::local({
[10:21:58.094]                 ...future.makeSendCondition <- base::local({
[10:21:58.094]                   sendCondition <- NULL
[10:21:58.094]                   function(frame = 1L) {
[10:21:58.094]                     if (is.function(sendCondition)) 
[10:21:58.094]                       return(sendCondition)
[10:21:58.094]                     ns <- getNamespace("parallel")
[10:21:58.094]                     if (exists("sendData", mode = "function", 
[10:21:58.094]                       envir = ns)) {
[10:21:58.094]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:58.094]                         envir = ns)
[10:21:58.094]                       envir <- sys.frame(frame)
[10:21:58.094]                       master <- NULL
[10:21:58.094]                       while (!identical(envir, .GlobalEnv) && 
[10:21:58.094]                         !identical(envir, emptyenv())) {
[10:21:58.094]                         if (exists("master", mode = "list", envir = envir, 
[10:21:58.094]                           inherits = FALSE)) {
[10:21:58.094]                           master <- get("master", mode = "list", 
[10:21:58.094]                             envir = envir, inherits = FALSE)
[10:21:58.094]                           if (inherits(master, c("SOCKnode", 
[10:21:58.094]                             "SOCK0node"))) {
[10:21:58.094]                             sendCondition <<- function(cond) {
[10:21:58.094]                               data <- list(type = "VALUE", value = cond, 
[10:21:58.094]                                 success = TRUE)
[10:21:58.094]                               parallel_sendData(master, data)
[10:21:58.094]                             }
[10:21:58.094]                             return(sendCondition)
[10:21:58.094]                           }
[10:21:58.094]                         }
[10:21:58.094]                         frame <- frame + 1L
[10:21:58.094]                         envir <- sys.frame(frame)
[10:21:58.094]                       }
[10:21:58.094]                     }
[10:21:58.094]                     sendCondition <<- function(cond) NULL
[10:21:58.094]                   }
[10:21:58.094]                 })
[10:21:58.094]                 withCallingHandlers({
[10:21:58.094]                   NA
[10:21:58.094]                 }, immediateCondition = function(cond) {
[10:21:58.094]                   sendCondition <- ...future.makeSendCondition()
[10:21:58.094]                   sendCondition(cond)
[10:21:58.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.094]                   {
[10:21:58.094]                     inherits <- base::inherits
[10:21:58.094]                     invokeRestart <- base::invokeRestart
[10:21:58.094]                     is.null <- base::is.null
[10:21:58.094]                     muffled <- FALSE
[10:21:58.094]                     if (inherits(cond, "message")) {
[10:21:58.094]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:58.094]                       if (muffled) 
[10:21:58.094]                         invokeRestart("muffleMessage")
[10:21:58.094]                     }
[10:21:58.094]                     else if (inherits(cond, "warning")) {
[10:21:58.094]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:58.094]                       if (muffled) 
[10:21:58.094]                         invokeRestart("muffleWarning")
[10:21:58.094]                     }
[10:21:58.094]                     else if (inherits(cond, "condition")) {
[10:21:58.094]                       if (!is.null(pattern)) {
[10:21:58.094]                         computeRestarts <- base::computeRestarts
[10:21:58.094]                         grepl <- base::grepl
[10:21:58.094]                         restarts <- computeRestarts(cond)
[10:21:58.094]                         for (restart in restarts) {
[10:21:58.094]                           name <- restart$name
[10:21:58.094]                           if (is.null(name)) 
[10:21:58.094]                             next
[10:21:58.094]                           if (!grepl(pattern, name)) 
[10:21:58.094]                             next
[10:21:58.094]                           invokeRestart(restart)
[10:21:58.094]                           muffled <- TRUE
[10:21:58.094]                           break
[10:21:58.094]                         }
[10:21:58.094]                       }
[10:21:58.094]                     }
[10:21:58.094]                     invisible(muffled)
[10:21:58.094]                   }
[10:21:58.094]                   muffleCondition(cond)
[10:21:58.094]                 })
[10:21:58.094]             }))
[10:21:58.094]             future::FutureResult(value = ...future.value$value, 
[10:21:58.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.094]                   ...future.rng), globalenv = if (FALSE) 
[10:21:58.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:58.094]                     ...future.globalenv.names))
[10:21:58.094]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:58.094]         }, condition = base::local({
[10:21:58.094]             c <- base::c
[10:21:58.094]             inherits <- base::inherits
[10:21:58.094]             invokeRestart <- base::invokeRestart
[10:21:58.094]             length <- base::length
[10:21:58.094]             list <- base::list
[10:21:58.094]             seq.int <- base::seq.int
[10:21:58.094]             signalCondition <- base::signalCondition
[10:21:58.094]             sys.calls <- base::sys.calls
[10:21:58.094]             `[[` <- base::`[[`
[10:21:58.094]             `+` <- base::`+`
[10:21:58.094]             `<<-` <- base::`<<-`
[10:21:58.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:58.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:58.094]                   3L)]
[10:21:58.094]             }
[10:21:58.094]             function(cond) {
[10:21:58.094]                 is_error <- inherits(cond, "error")
[10:21:58.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:58.094]                   NULL)
[10:21:58.094]                 if (is_error) {
[10:21:58.094]                   sessionInformation <- function() {
[10:21:58.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:58.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:58.094]                       search = base::search(), system = base::Sys.info())
[10:21:58.094]                   }
[10:21:58.094]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:58.094]                     cond$call), session = sessionInformation(), 
[10:21:58.094]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:58.094]                   signalCondition(cond)
[10:21:58.094]                 }
[10:21:58.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:58.094]                 "immediateCondition"))) {
[10:21:58.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:58.094]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:58.094]                   if (TRUE && !signal) {
[10:21:58.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.094]                     {
[10:21:58.094]                       inherits <- base::inherits
[10:21:58.094]                       invokeRestart <- base::invokeRestart
[10:21:58.094]                       is.null <- base::is.null
[10:21:58.094]                       muffled <- FALSE
[10:21:58.094]                       if (inherits(cond, "message")) {
[10:21:58.094]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.094]                         if (muffled) 
[10:21:58.094]                           invokeRestart("muffleMessage")
[10:21:58.094]                       }
[10:21:58.094]                       else if (inherits(cond, "warning")) {
[10:21:58.094]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.094]                         if (muffled) 
[10:21:58.094]                           invokeRestart("muffleWarning")
[10:21:58.094]                       }
[10:21:58.094]                       else if (inherits(cond, "condition")) {
[10:21:58.094]                         if (!is.null(pattern)) {
[10:21:58.094]                           computeRestarts <- base::computeRestarts
[10:21:58.094]                           grepl <- base::grepl
[10:21:58.094]                           restarts <- computeRestarts(cond)
[10:21:58.094]                           for (restart in restarts) {
[10:21:58.094]                             name <- restart$name
[10:21:58.094]                             if (is.null(name)) 
[10:21:58.094]                               next
[10:21:58.094]                             if (!grepl(pattern, name)) 
[10:21:58.094]                               next
[10:21:58.094]                             invokeRestart(restart)
[10:21:58.094]                             muffled <- TRUE
[10:21:58.094]                             break
[10:21:58.094]                           }
[10:21:58.094]                         }
[10:21:58.094]                       }
[10:21:58.094]                       invisible(muffled)
[10:21:58.094]                     }
[10:21:58.094]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.094]                   }
[10:21:58.094]                 }
[10:21:58.094]                 else {
[10:21:58.094]                   if (TRUE) {
[10:21:58.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.094]                     {
[10:21:58.094]                       inherits <- base::inherits
[10:21:58.094]                       invokeRestart <- base::invokeRestart
[10:21:58.094]                       is.null <- base::is.null
[10:21:58.094]                       muffled <- FALSE
[10:21:58.094]                       if (inherits(cond, "message")) {
[10:21:58.094]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.094]                         if (muffled) 
[10:21:58.094]                           invokeRestart("muffleMessage")
[10:21:58.094]                       }
[10:21:58.094]                       else if (inherits(cond, "warning")) {
[10:21:58.094]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.094]                         if (muffled) 
[10:21:58.094]                           invokeRestart("muffleWarning")
[10:21:58.094]                       }
[10:21:58.094]                       else if (inherits(cond, "condition")) {
[10:21:58.094]                         if (!is.null(pattern)) {
[10:21:58.094]                           computeRestarts <- base::computeRestarts
[10:21:58.094]                           grepl <- base::grepl
[10:21:58.094]                           restarts <- computeRestarts(cond)
[10:21:58.094]                           for (restart in restarts) {
[10:21:58.094]                             name <- restart$name
[10:21:58.094]                             if (is.null(name)) 
[10:21:58.094]                               next
[10:21:58.094]                             if (!grepl(pattern, name)) 
[10:21:58.094]                               next
[10:21:58.094]                             invokeRestart(restart)
[10:21:58.094]                             muffled <- TRUE
[10:21:58.094]                             break
[10:21:58.094]                           }
[10:21:58.094]                         }
[10:21:58.094]                       }
[10:21:58.094]                       invisible(muffled)
[10:21:58.094]                     }
[10:21:58.094]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.094]                   }
[10:21:58.094]                 }
[10:21:58.094]             }
[10:21:58.094]         }))
[10:21:58.094]     }, error = function(ex) {
[10:21:58.094]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:58.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.094]                 ...future.rng), started = ...future.startTime, 
[10:21:58.094]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:58.094]             version = "1.8"), class = "FutureResult")
[10:21:58.094]     }, finally = {
[10:21:58.094]         if (!identical(...future.workdir, getwd())) 
[10:21:58.094]             setwd(...future.workdir)
[10:21:58.094]         {
[10:21:58.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:58.094]                 ...future.oldOptions$nwarnings <- NULL
[10:21:58.094]             }
[10:21:58.094]             base::options(...future.oldOptions)
[10:21:58.094]             if (.Platform$OS.type == "windows") {
[10:21:58.094]                 old_names <- names(...future.oldEnvVars)
[10:21:58.094]                 envs <- base::Sys.getenv()
[10:21:58.094]                 names <- names(envs)
[10:21:58.094]                 common <- intersect(names, old_names)
[10:21:58.094]                 added <- setdiff(names, old_names)
[10:21:58.094]                 removed <- setdiff(old_names, names)
[10:21:58.094]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:58.094]                   envs[common]]
[10:21:58.094]                 NAMES <- toupper(changed)
[10:21:58.094]                 args <- list()
[10:21:58.094]                 for (kk in seq_along(NAMES)) {
[10:21:58.094]                   name <- changed[[kk]]
[10:21:58.094]                   NAME <- NAMES[[kk]]
[10:21:58.094]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.094]                     next
[10:21:58.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.094]                 }
[10:21:58.094]                 NAMES <- toupper(added)
[10:21:58.094]                 for (kk in seq_along(NAMES)) {
[10:21:58.094]                   name <- added[[kk]]
[10:21:58.094]                   NAME <- NAMES[[kk]]
[10:21:58.094]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.094]                     next
[10:21:58.094]                   args[[name]] <- ""
[10:21:58.094]                 }
[10:21:58.094]                 NAMES <- toupper(removed)
[10:21:58.094]                 for (kk in seq_along(NAMES)) {
[10:21:58.094]                   name <- removed[[kk]]
[10:21:58.094]                   NAME <- NAMES[[kk]]
[10:21:58.094]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.094]                     next
[10:21:58.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.094]                 }
[10:21:58.094]                 if (length(args) > 0) 
[10:21:58.094]                   base::do.call(base::Sys.setenv, args = args)
[10:21:58.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:58.094]             }
[10:21:58.094]             else {
[10:21:58.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:58.094]             }
[10:21:58.094]             {
[10:21:58.094]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:58.094]                   0L) {
[10:21:58.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:58.094]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:58.094]                   base::options(opts)
[10:21:58.094]                 }
[10:21:58.094]                 {
[10:21:58.094]                   {
[10:21:58.094]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:58.094]                     NULL
[10:21:58.094]                   }
[10:21:58.094]                   options(future.plan = NULL)
[10:21:58.094]                   if (is.na(NA_character_)) 
[10:21:58.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:58.094]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:58.094]                     .init = FALSE)
[10:21:58.094]                 }
[10:21:58.094]             }
[10:21:58.094]         }
[10:21:58.094]     })
[10:21:58.094]     if (TRUE) {
[10:21:58.094]         base::sink(type = "output", split = FALSE)
[10:21:58.094]         if (TRUE) {
[10:21:58.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:58.094]         }
[10:21:58.094]         else {
[10:21:58.094]             ...future.result["stdout"] <- base::list(NULL)
[10:21:58.094]         }
[10:21:58.094]         base::close(...future.stdout)
[10:21:58.094]         ...future.stdout <- NULL
[10:21:58.094]     }
[10:21:58.094]     ...future.result$conditions <- ...future.conditions
[10:21:58.094]     ...future.result$finished <- base::Sys.time()
[10:21:58.094]     ...future.result
[10:21:58.094] }
[10:21:58.146] MultisessionFuture started
[10:21:58.146] result() for ClusterFuture ...
[10:21:58.146] receiveMessageFromWorker() for ClusterFuture ...
[10:21:58.146] - Validating connection of MultisessionFuture
[10:21:58.177] - received message: FutureResult
[10:21:58.177] - Received FutureResult
[10:21:58.177] - Erased future from FutureRegistry
[10:21:58.177] result() for ClusterFuture ...
[10:21:58.177] - result already collected: FutureResult
[10:21:58.178] result() for ClusterFuture ... done
[10:21:58.178] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:58.178] result() for ClusterFuture ... done
[10:21:58.178] result() for ClusterFuture ...
[10:21:58.178] - result already collected: FutureResult
[10:21:58.178] result() for ClusterFuture ... done
[10:21:58.178] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:58.178] plan(): nbrOfWorkers() = 2
> 
> f <- future({ gc() })
[10:21:58.179] getGlobalsAndPackages() ...
[10:21:58.179] Searching for globals...
[10:21:58.179] - globals found: [2] ‘{’, ‘gc’
[10:21:58.180] Searching for globals ... DONE
[10:21:58.180] Resolving globals: FALSE
[10:21:58.180] 
[10:21:58.180] 
[10:21:58.180] getGlobalsAndPackages() ... DONE
[10:21:58.180] run() for ‘Future’ ...
[10:21:58.181] - state: ‘created’
[10:21:58.181] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:58.193] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:58.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:58.194]   - Field: ‘node’
[10:21:58.194]   - Field: ‘label’
[10:21:58.194]   - Field: ‘local’
[10:21:58.194]   - Field: ‘owner’
[10:21:58.194]   - Field: ‘envir’
[10:21:58.194]   - Field: ‘workers’
[10:21:58.194]   - Field: ‘packages’
[10:21:58.194]   - Field: ‘gc’
[10:21:58.194]   - Field: ‘conditions’
[10:21:58.195]   - Field: ‘persistent’
[10:21:58.195]   - Field: ‘expr’
[10:21:58.195]   - Field: ‘uuid’
[10:21:58.195]   - Field: ‘seed’
[10:21:58.195]   - Field: ‘version’
[10:21:58.195]   - Field: ‘result’
[10:21:58.195]   - Field: ‘asynchronous’
[10:21:58.195]   - Field: ‘calls’
[10:21:58.195]   - Field: ‘globals’
[10:21:58.195]   - Field: ‘stdout’
[10:21:58.195]   - Field: ‘earlySignal’
[10:21:58.195]   - Field: ‘lazy’
[10:21:58.196]   - Field: ‘state’
[10:21:58.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:58.196] - Launch lazy future ...
[10:21:58.196] Packages needed by the future expression (n = 0): <none>
[10:21:58.196] Packages needed by future strategies (n = 0): <none>
[10:21:58.197] {
[10:21:58.197]     {
[10:21:58.197]         {
[10:21:58.197]             ...future.startTime <- base::Sys.time()
[10:21:58.197]             {
[10:21:58.197]                 {
[10:21:58.197]                   {
[10:21:58.197]                     {
[10:21:58.197]                       base::local({
[10:21:58.197]                         has_future <- base::requireNamespace("future", 
[10:21:58.197]                           quietly = TRUE)
[10:21:58.197]                         if (has_future) {
[10:21:58.197]                           ns <- base::getNamespace("future")
[10:21:58.197]                           version <- ns[[".package"]][["version"]]
[10:21:58.197]                           if (is.null(version)) 
[10:21:58.197]                             version <- utils::packageVersion("future")
[10:21:58.197]                         }
[10:21:58.197]                         else {
[10:21:58.197]                           version <- NULL
[10:21:58.197]                         }
[10:21:58.197]                         if (!has_future || version < "1.8.0") {
[10:21:58.197]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:58.197]                             "", base::R.version$version.string), 
[10:21:58.197]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:58.197]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:58.197]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:58.197]                               "release", "version")], collapse = " "), 
[10:21:58.197]                             hostname = base::Sys.info()[["nodename"]])
[10:21:58.197]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:58.197]                             info)
[10:21:58.197]                           info <- base::paste(info, collapse = "; ")
[10:21:58.197]                           if (!has_future) {
[10:21:58.197]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:58.197]                               info)
[10:21:58.197]                           }
[10:21:58.197]                           else {
[10:21:58.197]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:58.197]                               info, version)
[10:21:58.197]                           }
[10:21:58.197]                           base::stop(msg)
[10:21:58.197]                         }
[10:21:58.197]                       })
[10:21:58.197]                     }
[10:21:58.197]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:58.197]                     base::options(mc.cores = 1L)
[10:21:58.197]                   }
[10:21:58.197]                   ...future.strategy.old <- future::plan("list")
[10:21:58.197]                   options(future.plan = NULL)
[10:21:58.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:58.197]                 }
[10:21:58.197]                 ...future.workdir <- getwd()
[10:21:58.197]             }
[10:21:58.197]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:58.197]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:58.197]         }
[10:21:58.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:58.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:58.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:58.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:58.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:58.197]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:58.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:58.197]             base::names(...future.oldOptions))
[10:21:58.197]     }
[10:21:58.197]     if (FALSE) {
[10:21:58.197]     }
[10:21:58.197]     else {
[10:21:58.197]         if (TRUE) {
[10:21:58.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:58.197]                 open = "w")
[10:21:58.197]         }
[10:21:58.197]         else {
[10:21:58.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:58.197]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:58.197]         }
[10:21:58.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:58.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:58.197]             base::sink(type = "output", split = FALSE)
[10:21:58.197]             base::close(...future.stdout)
[10:21:58.197]         }, add = TRUE)
[10:21:58.197]     }
[10:21:58.197]     ...future.frame <- base::sys.nframe()
[10:21:58.197]     ...future.conditions <- base::list()
[10:21:58.197]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:58.197]     if (FALSE) {
[10:21:58.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:58.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:58.197]     }
[10:21:58.197]     ...future.result <- base::tryCatch({
[10:21:58.197]         base::withCallingHandlers({
[10:21:58.197]             ...future.value <- base::withVisible(base::local({
[10:21:58.197]                 ...future.makeSendCondition <- base::local({
[10:21:58.197]                   sendCondition <- NULL
[10:21:58.197]                   function(frame = 1L) {
[10:21:58.197]                     if (is.function(sendCondition)) 
[10:21:58.197]                       return(sendCondition)
[10:21:58.197]                     ns <- getNamespace("parallel")
[10:21:58.197]                     if (exists("sendData", mode = "function", 
[10:21:58.197]                       envir = ns)) {
[10:21:58.197]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:58.197]                         envir = ns)
[10:21:58.197]                       envir <- sys.frame(frame)
[10:21:58.197]                       master <- NULL
[10:21:58.197]                       while (!identical(envir, .GlobalEnv) && 
[10:21:58.197]                         !identical(envir, emptyenv())) {
[10:21:58.197]                         if (exists("master", mode = "list", envir = envir, 
[10:21:58.197]                           inherits = FALSE)) {
[10:21:58.197]                           master <- get("master", mode = "list", 
[10:21:58.197]                             envir = envir, inherits = FALSE)
[10:21:58.197]                           if (inherits(master, c("SOCKnode", 
[10:21:58.197]                             "SOCK0node"))) {
[10:21:58.197]                             sendCondition <<- function(cond) {
[10:21:58.197]                               data <- list(type = "VALUE", value = cond, 
[10:21:58.197]                                 success = TRUE)
[10:21:58.197]                               parallel_sendData(master, data)
[10:21:58.197]                             }
[10:21:58.197]                             return(sendCondition)
[10:21:58.197]                           }
[10:21:58.197]                         }
[10:21:58.197]                         frame <- frame + 1L
[10:21:58.197]                         envir <- sys.frame(frame)
[10:21:58.197]                       }
[10:21:58.197]                     }
[10:21:58.197]                     sendCondition <<- function(cond) NULL
[10:21:58.197]                   }
[10:21:58.197]                 })
[10:21:58.197]                 withCallingHandlers({
[10:21:58.197]                   {
[10:21:58.197]                     gc()
[10:21:58.197]                   }
[10:21:58.197]                 }, immediateCondition = function(cond) {
[10:21:58.197]                   sendCondition <- ...future.makeSendCondition()
[10:21:58.197]                   sendCondition(cond)
[10:21:58.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.197]                   {
[10:21:58.197]                     inherits <- base::inherits
[10:21:58.197]                     invokeRestart <- base::invokeRestart
[10:21:58.197]                     is.null <- base::is.null
[10:21:58.197]                     muffled <- FALSE
[10:21:58.197]                     if (inherits(cond, "message")) {
[10:21:58.197]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:58.197]                       if (muffled) 
[10:21:58.197]                         invokeRestart("muffleMessage")
[10:21:58.197]                     }
[10:21:58.197]                     else if (inherits(cond, "warning")) {
[10:21:58.197]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:58.197]                       if (muffled) 
[10:21:58.197]                         invokeRestart("muffleWarning")
[10:21:58.197]                     }
[10:21:58.197]                     else if (inherits(cond, "condition")) {
[10:21:58.197]                       if (!is.null(pattern)) {
[10:21:58.197]                         computeRestarts <- base::computeRestarts
[10:21:58.197]                         grepl <- base::grepl
[10:21:58.197]                         restarts <- computeRestarts(cond)
[10:21:58.197]                         for (restart in restarts) {
[10:21:58.197]                           name <- restart$name
[10:21:58.197]                           if (is.null(name)) 
[10:21:58.197]                             next
[10:21:58.197]                           if (!grepl(pattern, name)) 
[10:21:58.197]                             next
[10:21:58.197]                           invokeRestart(restart)
[10:21:58.197]                           muffled <- TRUE
[10:21:58.197]                           break
[10:21:58.197]                         }
[10:21:58.197]                       }
[10:21:58.197]                     }
[10:21:58.197]                     invisible(muffled)
[10:21:58.197]                   }
[10:21:58.197]                   muffleCondition(cond)
[10:21:58.197]                 })
[10:21:58.197]             }))
[10:21:58.197]             future::FutureResult(value = ...future.value$value, 
[10:21:58.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.197]                   ...future.rng), globalenv = if (FALSE) 
[10:21:58.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:58.197]                     ...future.globalenv.names))
[10:21:58.197]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:58.197]         }, condition = base::local({
[10:21:58.197]             c <- base::c
[10:21:58.197]             inherits <- base::inherits
[10:21:58.197]             invokeRestart <- base::invokeRestart
[10:21:58.197]             length <- base::length
[10:21:58.197]             list <- base::list
[10:21:58.197]             seq.int <- base::seq.int
[10:21:58.197]             signalCondition <- base::signalCondition
[10:21:58.197]             sys.calls <- base::sys.calls
[10:21:58.197]             `[[` <- base::`[[`
[10:21:58.197]             `+` <- base::`+`
[10:21:58.197]             `<<-` <- base::`<<-`
[10:21:58.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:58.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:58.197]                   3L)]
[10:21:58.197]             }
[10:21:58.197]             function(cond) {
[10:21:58.197]                 is_error <- inherits(cond, "error")
[10:21:58.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:58.197]                   NULL)
[10:21:58.197]                 if (is_error) {
[10:21:58.197]                   sessionInformation <- function() {
[10:21:58.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:58.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:58.197]                       search = base::search(), system = base::Sys.info())
[10:21:58.197]                   }
[10:21:58.197]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:58.197]                     cond$call), session = sessionInformation(), 
[10:21:58.197]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:58.197]                   signalCondition(cond)
[10:21:58.197]                 }
[10:21:58.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:58.197]                 "immediateCondition"))) {
[10:21:58.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:58.197]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:58.197]                   if (TRUE && !signal) {
[10:21:58.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.197]                     {
[10:21:58.197]                       inherits <- base::inherits
[10:21:58.197]                       invokeRestart <- base::invokeRestart
[10:21:58.197]                       is.null <- base::is.null
[10:21:58.197]                       muffled <- FALSE
[10:21:58.197]                       if (inherits(cond, "message")) {
[10:21:58.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.197]                         if (muffled) 
[10:21:58.197]                           invokeRestart("muffleMessage")
[10:21:58.197]                       }
[10:21:58.197]                       else if (inherits(cond, "warning")) {
[10:21:58.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.197]                         if (muffled) 
[10:21:58.197]                           invokeRestart("muffleWarning")
[10:21:58.197]                       }
[10:21:58.197]                       else if (inherits(cond, "condition")) {
[10:21:58.197]                         if (!is.null(pattern)) {
[10:21:58.197]                           computeRestarts <- base::computeRestarts
[10:21:58.197]                           grepl <- base::grepl
[10:21:58.197]                           restarts <- computeRestarts(cond)
[10:21:58.197]                           for (restart in restarts) {
[10:21:58.197]                             name <- restart$name
[10:21:58.197]                             if (is.null(name)) 
[10:21:58.197]                               next
[10:21:58.197]                             if (!grepl(pattern, name)) 
[10:21:58.197]                               next
[10:21:58.197]                             invokeRestart(restart)
[10:21:58.197]                             muffled <- TRUE
[10:21:58.197]                             break
[10:21:58.197]                           }
[10:21:58.197]                         }
[10:21:58.197]                       }
[10:21:58.197]                       invisible(muffled)
[10:21:58.197]                     }
[10:21:58.197]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.197]                   }
[10:21:58.197]                 }
[10:21:58.197]                 else {
[10:21:58.197]                   if (TRUE) {
[10:21:58.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.197]                     {
[10:21:58.197]                       inherits <- base::inherits
[10:21:58.197]                       invokeRestart <- base::invokeRestart
[10:21:58.197]                       is.null <- base::is.null
[10:21:58.197]                       muffled <- FALSE
[10:21:58.197]                       if (inherits(cond, "message")) {
[10:21:58.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.197]                         if (muffled) 
[10:21:58.197]                           invokeRestart("muffleMessage")
[10:21:58.197]                       }
[10:21:58.197]                       else if (inherits(cond, "warning")) {
[10:21:58.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.197]                         if (muffled) 
[10:21:58.197]                           invokeRestart("muffleWarning")
[10:21:58.197]                       }
[10:21:58.197]                       else if (inherits(cond, "condition")) {
[10:21:58.197]                         if (!is.null(pattern)) {
[10:21:58.197]                           computeRestarts <- base::computeRestarts
[10:21:58.197]                           grepl <- base::grepl
[10:21:58.197]                           restarts <- computeRestarts(cond)
[10:21:58.197]                           for (restart in restarts) {
[10:21:58.197]                             name <- restart$name
[10:21:58.197]                             if (is.null(name)) 
[10:21:58.197]                               next
[10:21:58.197]                             if (!grepl(pattern, name)) 
[10:21:58.197]                               next
[10:21:58.197]                             invokeRestart(restart)
[10:21:58.197]                             muffled <- TRUE
[10:21:58.197]                             break
[10:21:58.197]                           }
[10:21:58.197]                         }
[10:21:58.197]                       }
[10:21:58.197]                       invisible(muffled)
[10:21:58.197]                     }
[10:21:58.197]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.197]                   }
[10:21:58.197]                 }
[10:21:58.197]             }
[10:21:58.197]         }))
[10:21:58.197]     }, error = function(ex) {
[10:21:58.197]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:58.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.197]                 ...future.rng), started = ...future.startTime, 
[10:21:58.197]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:58.197]             version = "1.8"), class = "FutureResult")
[10:21:58.197]     }, finally = {
[10:21:58.197]         if (!identical(...future.workdir, getwd())) 
[10:21:58.197]             setwd(...future.workdir)
[10:21:58.197]         {
[10:21:58.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:58.197]                 ...future.oldOptions$nwarnings <- NULL
[10:21:58.197]             }
[10:21:58.197]             base::options(...future.oldOptions)
[10:21:58.197]             if (.Platform$OS.type == "windows") {
[10:21:58.197]                 old_names <- names(...future.oldEnvVars)
[10:21:58.197]                 envs <- base::Sys.getenv()
[10:21:58.197]                 names <- names(envs)
[10:21:58.197]                 common <- intersect(names, old_names)
[10:21:58.197]                 added <- setdiff(names, old_names)
[10:21:58.197]                 removed <- setdiff(old_names, names)
[10:21:58.197]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:58.197]                   envs[common]]
[10:21:58.197]                 NAMES <- toupper(changed)
[10:21:58.197]                 args <- list()
[10:21:58.197]                 for (kk in seq_along(NAMES)) {
[10:21:58.197]                   name <- changed[[kk]]
[10:21:58.197]                   NAME <- NAMES[[kk]]
[10:21:58.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.197]                     next
[10:21:58.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.197]                 }
[10:21:58.197]                 NAMES <- toupper(added)
[10:21:58.197]                 for (kk in seq_along(NAMES)) {
[10:21:58.197]                   name <- added[[kk]]
[10:21:58.197]                   NAME <- NAMES[[kk]]
[10:21:58.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.197]                     next
[10:21:58.197]                   args[[name]] <- ""
[10:21:58.197]                 }
[10:21:58.197]                 NAMES <- toupper(removed)
[10:21:58.197]                 for (kk in seq_along(NAMES)) {
[10:21:58.197]                   name <- removed[[kk]]
[10:21:58.197]                   NAME <- NAMES[[kk]]
[10:21:58.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.197]                     next
[10:21:58.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.197]                 }
[10:21:58.197]                 if (length(args) > 0) 
[10:21:58.197]                   base::do.call(base::Sys.setenv, args = args)
[10:21:58.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:58.197]             }
[10:21:58.197]             else {
[10:21:58.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:58.197]             }
[10:21:58.197]             {
[10:21:58.197]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:58.197]                   0L) {
[10:21:58.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:58.197]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:58.197]                   base::options(opts)
[10:21:58.197]                 }
[10:21:58.197]                 {
[10:21:58.197]                   {
[10:21:58.197]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:58.197]                     NULL
[10:21:58.197]                   }
[10:21:58.197]                   options(future.plan = NULL)
[10:21:58.197]                   if (is.na(NA_character_)) 
[10:21:58.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:58.197]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:58.197]                     .init = FALSE)
[10:21:58.197]                 }
[10:21:58.197]             }
[10:21:58.197]         }
[10:21:58.197]     })
[10:21:58.197]     if (TRUE) {
[10:21:58.197]         base::sink(type = "output", split = FALSE)
[10:21:58.197]         if (TRUE) {
[10:21:58.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:58.197]         }
[10:21:58.197]         else {
[10:21:58.197]             ...future.result["stdout"] <- base::list(NULL)
[10:21:58.197]         }
[10:21:58.197]         base::close(...future.stdout)
[10:21:58.197]         ...future.stdout <- NULL
[10:21:58.197]     }
[10:21:58.197]     ...future.result$conditions <- ...future.conditions
[10:21:58.197]     ...future.result$finished <- base::Sys.time()
[10:21:58.197]     ...future.result
[10:21:58.197] }
[10:21:58.200] MultisessionFuture started
[10:21:58.200] - Launch lazy future ... done
[10:21:58.200] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[10:21:58.200] result() for ClusterFuture ...
[10:21:58.200] receiveMessageFromWorker() for ClusterFuture ...
[10:21:58.200] - Validating connection of MultisessionFuture
[10:21:58.267] - received message: FutureResult
[10:21:58.267] - Received FutureResult
[10:21:58.267] - Erased future from FutureRegistry
[10:21:58.268] result() for ClusterFuture ...
[10:21:58.268] - result already collected: FutureResult
[10:21:58.268] result() for ClusterFuture ... done
[10:21:58.268] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:58.268] result() for ClusterFuture ... done
[10:21:58.268] result() for ClusterFuture ...
[10:21:58.268] - result already collected: FutureResult
[10:21:58.268] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 409538 21.9     692222   37   692222 37.0
Vcells 732386  5.6    8388608   64  1923645 14.7
> 
> f <- future({ integer(10e6) })
[10:21:58.268] getGlobalsAndPackages() ...
[10:21:58.269] Searching for globals...
[10:21:58.269] - globals found: [2] ‘{’, ‘integer’
[10:21:58.270] Searching for globals ... DONE
[10:21:58.270] Resolving globals: FALSE
[10:21:58.270] 
[10:21:58.270] 
[10:21:58.270] getGlobalsAndPackages() ... DONE
[10:21:58.270] run() for ‘Future’ ...
[10:21:58.271] - state: ‘created’
[10:21:58.271] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:58.283] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:58.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:58.284]   - Field: ‘node’
[10:21:58.284]   - Field: ‘label’
[10:21:58.284]   - Field: ‘local’
[10:21:58.284]   - Field: ‘owner’
[10:21:58.284]   - Field: ‘envir’
[10:21:58.284]   - Field: ‘workers’
[10:21:58.284]   - Field: ‘packages’
[10:21:58.284]   - Field: ‘gc’
[10:21:58.284]   - Field: ‘conditions’
[10:21:58.285]   - Field: ‘persistent’
[10:21:58.285]   - Field: ‘expr’
[10:21:58.285]   - Field: ‘uuid’
[10:21:58.285]   - Field: ‘seed’
[10:21:58.285]   - Field: ‘version’
[10:21:58.285]   - Field: ‘result’
[10:21:58.285]   - Field: ‘asynchronous’
[10:21:58.285]   - Field: ‘calls’
[10:21:58.285]   - Field: ‘globals’
[10:21:58.285]   - Field: ‘stdout’
[10:21:58.285]   - Field: ‘earlySignal’
[10:21:58.285]   - Field: ‘lazy’
[10:21:58.286]   - Field: ‘state’
[10:21:58.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:58.286] - Launch lazy future ...
[10:21:58.286] Packages needed by the future expression (n = 0): <none>
[10:21:58.286] Packages needed by future strategies (n = 0): <none>
[10:21:58.287] {
[10:21:58.287]     {
[10:21:58.287]         {
[10:21:58.287]             ...future.startTime <- base::Sys.time()
[10:21:58.287]             {
[10:21:58.287]                 {
[10:21:58.287]                   {
[10:21:58.287]                     {
[10:21:58.287]                       base::local({
[10:21:58.287]                         has_future <- base::requireNamespace("future", 
[10:21:58.287]                           quietly = TRUE)
[10:21:58.287]                         if (has_future) {
[10:21:58.287]                           ns <- base::getNamespace("future")
[10:21:58.287]                           version <- ns[[".package"]][["version"]]
[10:21:58.287]                           if (is.null(version)) 
[10:21:58.287]                             version <- utils::packageVersion("future")
[10:21:58.287]                         }
[10:21:58.287]                         else {
[10:21:58.287]                           version <- NULL
[10:21:58.287]                         }
[10:21:58.287]                         if (!has_future || version < "1.8.0") {
[10:21:58.287]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:58.287]                             "", base::R.version$version.string), 
[10:21:58.287]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:58.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:58.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:58.287]                               "release", "version")], collapse = " "), 
[10:21:58.287]                             hostname = base::Sys.info()[["nodename"]])
[10:21:58.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:58.287]                             info)
[10:21:58.287]                           info <- base::paste(info, collapse = "; ")
[10:21:58.287]                           if (!has_future) {
[10:21:58.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:58.287]                               info)
[10:21:58.287]                           }
[10:21:58.287]                           else {
[10:21:58.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:58.287]                               info, version)
[10:21:58.287]                           }
[10:21:58.287]                           base::stop(msg)
[10:21:58.287]                         }
[10:21:58.287]                       })
[10:21:58.287]                     }
[10:21:58.287]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:58.287]                     base::options(mc.cores = 1L)
[10:21:58.287]                   }
[10:21:58.287]                   ...future.strategy.old <- future::plan("list")
[10:21:58.287]                   options(future.plan = NULL)
[10:21:58.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:58.287]                 }
[10:21:58.287]                 ...future.workdir <- getwd()
[10:21:58.287]             }
[10:21:58.287]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:58.287]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:58.287]         }
[10:21:58.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:58.287]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:58.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:58.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:58.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:58.287]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:58.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:58.287]             base::names(...future.oldOptions))
[10:21:58.287]     }
[10:21:58.287]     if (FALSE) {
[10:21:58.287]     }
[10:21:58.287]     else {
[10:21:58.287]         if (TRUE) {
[10:21:58.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:58.287]                 open = "w")
[10:21:58.287]         }
[10:21:58.287]         else {
[10:21:58.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:58.287]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:58.287]         }
[10:21:58.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:58.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:58.287]             base::sink(type = "output", split = FALSE)
[10:21:58.287]             base::close(...future.stdout)
[10:21:58.287]         }, add = TRUE)
[10:21:58.287]     }
[10:21:58.287]     ...future.frame <- base::sys.nframe()
[10:21:58.287]     ...future.conditions <- base::list()
[10:21:58.287]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:58.287]     if (FALSE) {
[10:21:58.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:58.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:58.287]     }
[10:21:58.287]     ...future.result <- base::tryCatch({
[10:21:58.287]         base::withCallingHandlers({
[10:21:58.287]             ...future.value <- base::withVisible(base::local({
[10:21:58.287]                 ...future.makeSendCondition <- base::local({
[10:21:58.287]                   sendCondition <- NULL
[10:21:58.287]                   function(frame = 1L) {
[10:21:58.287]                     if (is.function(sendCondition)) 
[10:21:58.287]                       return(sendCondition)
[10:21:58.287]                     ns <- getNamespace("parallel")
[10:21:58.287]                     if (exists("sendData", mode = "function", 
[10:21:58.287]                       envir = ns)) {
[10:21:58.287]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:58.287]                         envir = ns)
[10:21:58.287]                       envir <- sys.frame(frame)
[10:21:58.287]                       master <- NULL
[10:21:58.287]                       while (!identical(envir, .GlobalEnv) && 
[10:21:58.287]                         !identical(envir, emptyenv())) {
[10:21:58.287]                         if (exists("master", mode = "list", envir = envir, 
[10:21:58.287]                           inherits = FALSE)) {
[10:21:58.287]                           master <- get("master", mode = "list", 
[10:21:58.287]                             envir = envir, inherits = FALSE)
[10:21:58.287]                           if (inherits(master, c("SOCKnode", 
[10:21:58.287]                             "SOCK0node"))) {
[10:21:58.287]                             sendCondition <<- function(cond) {
[10:21:58.287]                               data <- list(type = "VALUE", value = cond, 
[10:21:58.287]                                 success = TRUE)
[10:21:58.287]                               parallel_sendData(master, data)
[10:21:58.287]                             }
[10:21:58.287]                             return(sendCondition)
[10:21:58.287]                           }
[10:21:58.287]                         }
[10:21:58.287]                         frame <- frame + 1L
[10:21:58.287]                         envir <- sys.frame(frame)
[10:21:58.287]                       }
[10:21:58.287]                     }
[10:21:58.287]                     sendCondition <<- function(cond) NULL
[10:21:58.287]                   }
[10:21:58.287]                 })
[10:21:58.287]                 withCallingHandlers({
[10:21:58.287]                   {
[10:21:58.287]                     integer(1e+07)
[10:21:58.287]                   }
[10:21:58.287]                 }, immediateCondition = function(cond) {
[10:21:58.287]                   sendCondition <- ...future.makeSendCondition()
[10:21:58.287]                   sendCondition(cond)
[10:21:58.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.287]                   {
[10:21:58.287]                     inherits <- base::inherits
[10:21:58.287]                     invokeRestart <- base::invokeRestart
[10:21:58.287]                     is.null <- base::is.null
[10:21:58.287]                     muffled <- FALSE
[10:21:58.287]                     if (inherits(cond, "message")) {
[10:21:58.287]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:58.287]                       if (muffled) 
[10:21:58.287]                         invokeRestart("muffleMessage")
[10:21:58.287]                     }
[10:21:58.287]                     else if (inherits(cond, "warning")) {
[10:21:58.287]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:58.287]                       if (muffled) 
[10:21:58.287]                         invokeRestart("muffleWarning")
[10:21:58.287]                     }
[10:21:58.287]                     else if (inherits(cond, "condition")) {
[10:21:58.287]                       if (!is.null(pattern)) {
[10:21:58.287]                         computeRestarts <- base::computeRestarts
[10:21:58.287]                         grepl <- base::grepl
[10:21:58.287]                         restarts <- computeRestarts(cond)
[10:21:58.287]                         for (restart in restarts) {
[10:21:58.287]                           name <- restart$name
[10:21:58.287]                           if (is.null(name)) 
[10:21:58.287]                             next
[10:21:58.287]                           if (!grepl(pattern, name)) 
[10:21:58.287]                             next
[10:21:58.287]                           invokeRestart(restart)
[10:21:58.287]                           muffled <- TRUE
[10:21:58.287]                           break
[10:21:58.287]                         }
[10:21:58.287]                       }
[10:21:58.287]                     }
[10:21:58.287]                     invisible(muffled)
[10:21:58.287]                   }
[10:21:58.287]                   muffleCondition(cond)
[10:21:58.287]                 })
[10:21:58.287]             }))
[10:21:58.287]             future::FutureResult(value = ...future.value$value, 
[10:21:58.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.287]                   ...future.rng), globalenv = if (FALSE) 
[10:21:58.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:58.287]                     ...future.globalenv.names))
[10:21:58.287]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:58.287]         }, condition = base::local({
[10:21:58.287]             c <- base::c
[10:21:58.287]             inherits <- base::inherits
[10:21:58.287]             invokeRestart <- base::invokeRestart
[10:21:58.287]             length <- base::length
[10:21:58.287]             list <- base::list
[10:21:58.287]             seq.int <- base::seq.int
[10:21:58.287]             signalCondition <- base::signalCondition
[10:21:58.287]             sys.calls <- base::sys.calls
[10:21:58.287]             `[[` <- base::`[[`
[10:21:58.287]             `+` <- base::`+`
[10:21:58.287]             `<<-` <- base::`<<-`
[10:21:58.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:58.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:58.287]                   3L)]
[10:21:58.287]             }
[10:21:58.287]             function(cond) {
[10:21:58.287]                 is_error <- inherits(cond, "error")
[10:21:58.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:58.287]                   NULL)
[10:21:58.287]                 if (is_error) {
[10:21:58.287]                   sessionInformation <- function() {
[10:21:58.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:58.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:58.287]                       search = base::search(), system = base::Sys.info())
[10:21:58.287]                   }
[10:21:58.287]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:58.287]                     cond$call), session = sessionInformation(), 
[10:21:58.287]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:58.287]                   signalCondition(cond)
[10:21:58.287]                 }
[10:21:58.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:58.287]                 "immediateCondition"))) {
[10:21:58.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:58.287]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:58.287]                   if (TRUE && !signal) {
[10:21:58.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.287]                     {
[10:21:58.287]                       inherits <- base::inherits
[10:21:58.287]                       invokeRestart <- base::invokeRestart
[10:21:58.287]                       is.null <- base::is.null
[10:21:58.287]                       muffled <- FALSE
[10:21:58.287]                       if (inherits(cond, "message")) {
[10:21:58.287]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.287]                         if (muffled) 
[10:21:58.287]                           invokeRestart("muffleMessage")
[10:21:58.287]                       }
[10:21:58.287]                       else if (inherits(cond, "warning")) {
[10:21:58.287]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.287]                         if (muffled) 
[10:21:58.287]                           invokeRestart("muffleWarning")
[10:21:58.287]                       }
[10:21:58.287]                       else if (inherits(cond, "condition")) {
[10:21:58.287]                         if (!is.null(pattern)) {
[10:21:58.287]                           computeRestarts <- base::computeRestarts
[10:21:58.287]                           grepl <- base::grepl
[10:21:58.287]                           restarts <- computeRestarts(cond)
[10:21:58.287]                           for (restart in restarts) {
[10:21:58.287]                             name <- restart$name
[10:21:58.287]                             if (is.null(name)) 
[10:21:58.287]                               next
[10:21:58.287]                             if (!grepl(pattern, name)) 
[10:21:58.287]                               next
[10:21:58.287]                             invokeRestart(restart)
[10:21:58.287]                             muffled <- TRUE
[10:21:58.287]                             break
[10:21:58.287]                           }
[10:21:58.287]                         }
[10:21:58.287]                       }
[10:21:58.287]                       invisible(muffled)
[10:21:58.287]                     }
[10:21:58.287]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.287]                   }
[10:21:58.287]                 }
[10:21:58.287]                 else {
[10:21:58.287]                   if (TRUE) {
[10:21:58.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.287]                     {
[10:21:58.287]                       inherits <- base::inherits
[10:21:58.287]                       invokeRestart <- base::invokeRestart
[10:21:58.287]                       is.null <- base::is.null
[10:21:58.287]                       muffled <- FALSE
[10:21:58.287]                       if (inherits(cond, "message")) {
[10:21:58.287]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.287]                         if (muffled) 
[10:21:58.287]                           invokeRestart("muffleMessage")
[10:21:58.287]                       }
[10:21:58.287]                       else if (inherits(cond, "warning")) {
[10:21:58.287]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.287]                         if (muffled) 
[10:21:58.287]                           invokeRestart("muffleWarning")
[10:21:58.287]                       }
[10:21:58.287]                       else if (inherits(cond, "condition")) {
[10:21:58.287]                         if (!is.null(pattern)) {
[10:21:58.287]                           computeRestarts <- base::computeRestarts
[10:21:58.287]                           grepl <- base::grepl
[10:21:58.287]                           restarts <- computeRestarts(cond)
[10:21:58.287]                           for (restart in restarts) {
[10:21:58.287]                             name <- restart$name
[10:21:58.287]                             if (is.null(name)) 
[10:21:58.287]                               next
[10:21:58.287]                             if (!grepl(pattern, name)) 
[10:21:58.287]                               next
[10:21:58.287]                             invokeRestart(restart)
[10:21:58.287]                             muffled <- TRUE
[10:21:58.287]                             break
[10:21:58.287]                           }
[10:21:58.287]                         }
[10:21:58.287]                       }
[10:21:58.287]                       invisible(muffled)
[10:21:58.287]                     }
[10:21:58.287]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.287]                   }
[10:21:58.287]                 }
[10:21:58.287]             }
[10:21:58.287]         }))
[10:21:58.287]     }, error = function(ex) {
[10:21:58.287]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:58.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.287]                 ...future.rng), started = ...future.startTime, 
[10:21:58.287]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:58.287]             version = "1.8"), class = "FutureResult")
[10:21:58.287]     }, finally = {
[10:21:58.287]         if (!identical(...future.workdir, getwd())) 
[10:21:58.287]             setwd(...future.workdir)
[10:21:58.287]         {
[10:21:58.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:58.287]                 ...future.oldOptions$nwarnings <- NULL
[10:21:58.287]             }
[10:21:58.287]             base::options(...future.oldOptions)
[10:21:58.287]             if (.Platform$OS.type == "windows") {
[10:21:58.287]                 old_names <- names(...future.oldEnvVars)
[10:21:58.287]                 envs <- base::Sys.getenv()
[10:21:58.287]                 names <- names(envs)
[10:21:58.287]                 common <- intersect(names, old_names)
[10:21:58.287]                 added <- setdiff(names, old_names)
[10:21:58.287]                 removed <- setdiff(old_names, names)
[10:21:58.287]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:58.287]                   envs[common]]
[10:21:58.287]                 NAMES <- toupper(changed)
[10:21:58.287]                 args <- list()
[10:21:58.287]                 for (kk in seq_along(NAMES)) {
[10:21:58.287]                   name <- changed[[kk]]
[10:21:58.287]                   NAME <- NAMES[[kk]]
[10:21:58.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.287]                     next
[10:21:58.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.287]                 }
[10:21:58.287]                 NAMES <- toupper(added)
[10:21:58.287]                 for (kk in seq_along(NAMES)) {
[10:21:58.287]                   name <- added[[kk]]
[10:21:58.287]                   NAME <- NAMES[[kk]]
[10:21:58.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.287]                     next
[10:21:58.287]                   args[[name]] <- ""
[10:21:58.287]                 }
[10:21:58.287]                 NAMES <- toupper(removed)
[10:21:58.287]                 for (kk in seq_along(NAMES)) {
[10:21:58.287]                   name <- removed[[kk]]
[10:21:58.287]                   NAME <- NAMES[[kk]]
[10:21:58.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.287]                     next
[10:21:58.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.287]                 }
[10:21:58.287]                 if (length(args) > 0) 
[10:21:58.287]                   base::do.call(base::Sys.setenv, args = args)
[10:21:58.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:58.287]             }
[10:21:58.287]             else {
[10:21:58.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:58.287]             }
[10:21:58.287]             {
[10:21:58.287]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:58.287]                   0L) {
[10:21:58.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:58.287]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:58.287]                   base::options(opts)
[10:21:58.287]                 }
[10:21:58.287]                 {
[10:21:58.287]                   {
[10:21:58.287]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:58.287]                     NULL
[10:21:58.287]                   }
[10:21:58.287]                   options(future.plan = NULL)
[10:21:58.287]                   if (is.na(NA_character_)) 
[10:21:58.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:58.287]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:58.287]                     .init = FALSE)
[10:21:58.287]                 }
[10:21:58.287]             }
[10:21:58.287]         }
[10:21:58.287]     })
[10:21:58.287]     if (TRUE) {
[10:21:58.287]         base::sink(type = "output", split = FALSE)
[10:21:58.287]         if (TRUE) {
[10:21:58.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:58.287]         }
[10:21:58.287]         else {
[10:21:58.287]             ...future.result["stdout"] <- base::list(NULL)
[10:21:58.287]         }
[10:21:58.287]         base::close(...future.stdout)
[10:21:58.287]         ...future.stdout <- NULL
[10:21:58.287]     }
[10:21:58.287]     ...future.result$conditions <- ...future.conditions
[10:21:58.287]     ...future.result$finished <- base::Sys.time()
[10:21:58.287]     ...future.result
[10:21:58.287] }
[10:21:58.290] MultisessionFuture started
[10:21:58.290] - Launch lazy future ... done
[10:21:58.290] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[10:21:58.290] result() for ClusterFuture ...
[10:21:58.290] receiveMessageFromWorker() for ClusterFuture ...
[10:21:58.290] - Validating connection of MultisessionFuture
[10:21:58.384] - received message: FutureResult
[10:21:58.385] - Received FutureResult
[10:21:58.385] - Erased future from FutureRegistry
[10:21:58.385] result() for ClusterFuture ...
[10:21:58.385] - result already collected: FutureResult
[10:21:58.385] result() for ClusterFuture ... done
[10:21:58.385] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:58.385] result() for ClusterFuture ... done
[10:21:58.385] result() for ClusterFuture ...
[10:21:58.385] - result already collected: FutureResult
[10:21:58.385] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[10:21:58.386] getGlobalsAndPackages() ...
[10:21:58.386] Searching for globals...
[10:21:58.387] - globals found: [2] ‘{’, ‘gc’
[10:21:58.387] Searching for globals ... DONE
[10:21:58.387] Resolving globals: FALSE
[10:21:58.387] 
[10:21:58.388] 
[10:21:58.388] getGlobalsAndPackages() ... DONE
[10:21:58.388] run() for ‘Future’ ...
[10:21:58.388] - state: ‘created’
[10:21:58.388] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:58.401] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:58.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:58.401]   - Field: ‘node’
[10:21:58.401]   - Field: ‘label’
[10:21:58.401]   - Field: ‘local’
[10:21:58.401]   - Field: ‘owner’
[10:21:58.401]   - Field: ‘envir’
[10:21:58.401]   - Field: ‘workers’
[10:21:58.401]   - Field: ‘packages’
[10:21:58.402]   - Field: ‘gc’
[10:21:58.402]   - Field: ‘conditions’
[10:21:58.402]   - Field: ‘persistent’
[10:21:58.402]   - Field: ‘expr’
[10:21:58.402]   - Field: ‘uuid’
[10:21:58.402]   - Field: ‘seed’
[10:21:58.402]   - Field: ‘version’
[10:21:58.402]   - Field: ‘result’
[10:21:58.402]   - Field: ‘asynchronous’
[10:21:58.402]   - Field: ‘calls’
[10:21:58.402]   - Field: ‘globals’
[10:21:58.403]   - Field: ‘stdout’
[10:21:58.403]   - Field: ‘earlySignal’
[10:21:58.403]   - Field: ‘lazy’
[10:21:58.403]   - Field: ‘state’
[10:21:58.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:58.403] - Launch lazy future ...
[10:21:58.403] Packages needed by the future expression (n = 0): <none>
[10:21:58.403] Packages needed by future strategies (n = 0): <none>
[10:21:58.404] {
[10:21:58.404]     {
[10:21:58.404]         {
[10:21:58.404]             ...future.startTime <- base::Sys.time()
[10:21:58.404]             {
[10:21:58.404]                 {
[10:21:58.404]                   {
[10:21:58.404]                     {
[10:21:58.404]                       base::local({
[10:21:58.404]                         has_future <- base::requireNamespace("future", 
[10:21:58.404]                           quietly = TRUE)
[10:21:58.404]                         if (has_future) {
[10:21:58.404]                           ns <- base::getNamespace("future")
[10:21:58.404]                           version <- ns[[".package"]][["version"]]
[10:21:58.404]                           if (is.null(version)) 
[10:21:58.404]                             version <- utils::packageVersion("future")
[10:21:58.404]                         }
[10:21:58.404]                         else {
[10:21:58.404]                           version <- NULL
[10:21:58.404]                         }
[10:21:58.404]                         if (!has_future || version < "1.8.0") {
[10:21:58.404]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:58.404]                             "", base::R.version$version.string), 
[10:21:58.404]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:58.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:58.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:58.404]                               "release", "version")], collapse = " "), 
[10:21:58.404]                             hostname = base::Sys.info()[["nodename"]])
[10:21:58.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:58.404]                             info)
[10:21:58.404]                           info <- base::paste(info, collapse = "; ")
[10:21:58.404]                           if (!has_future) {
[10:21:58.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:58.404]                               info)
[10:21:58.404]                           }
[10:21:58.404]                           else {
[10:21:58.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:58.404]                               info, version)
[10:21:58.404]                           }
[10:21:58.404]                           base::stop(msg)
[10:21:58.404]                         }
[10:21:58.404]                       })
[10:21:58.404]                     }
[10:21:58.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:58.404]                     base::options(mc.cores = 1L)
[10:21:58.404]                   }
[10:21:58.404]                   ...future.strategy.old <- future::plan("list")
[10:21:58.404]                   options(future.plan = NULL)
[10:21:58.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:58.404]                 }
[10:21:58.404]                 ...future.workdir <- getwd()
[10:21:58.404]             }
[10:21:58.404]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:58.404]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:58.404]         }
[10:21:58.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:58.404]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:58.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:58.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:58.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:58.404]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:58.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:58.404]             base::names(...future.oldOptions))
[10:21:58.404]     }
[10:21:58.404]     if (FALSE) {
[10:21:58.404]     }
[10:21:58.404]     else {
[10:21:58.404]         if (TRUE) {
[10:21:58.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:58.404]                 open = "w")
[10:21:58.404]         }
[10:21:58.404]         else {
[10:21:58.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:58.404]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:58.404]         }
[10:21:58.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:58.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:58.404]             base::sink(type = "output", split = FALSE)
[10:21:58.404]             base::close(...future.stdout)
[10:21:58.404]         }, add = TRUE)
[10:21:58.404]     }
[10:21:58.404]     ...future.frame <- base::sys.nframe()
[10:21:58.404]     ...future.conditions <- base::list()
[10:21:58.404]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:58.404]     if (FALSE) {
[10:21:58.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:58.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:58.404]     }
[10:21:58.404]     ...future.result <- base::tryCatch({
[10:21:58.404]         base::withCallingHandlers({
[10:21:58.404]             ...future.value <- base::withVisible(base::local({
[10:21:58.404]                 ...future.makeSendCondition <- base::local({
[10:21:58.404]                   sendCondition <- NULL
[10:21:58.404]                   function(frame = 1L) {
[10:21:58.404]                     if (is.function(sendCondition)) 
[10:21:58.404]                       return(sendCondition)
[10:21:58.404]                     ns <- getNamespace("parallel")
[10:21:58.404]                     if (exists("sendData", mode = "function", 
[10:21:58.404]                       envir = ns)) {
[10:21:58.404]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:58.404]                         envir = ns)
[10:21:58.404]                       envir <- sys.frame(frame)
[10:21:58.404]                       master <- NULL
[10:21:58.404]                       while (!identical(envir, .GlobalEnv) && 
[10:21:58.404]                         !identical(envir, emptyenv())) {
[10:21:58.404]                         if (exists("master", mode = "list", envir = envir, 
[10:21:58.404]                           inherits = FALSE)) {
[10:21:58.404]                           master <- get("master", mode = "list", 
[10:21:58.404]                             envir = envir, inherits = FALSE)
[10:21:58.404]                           if (inherits(master, c("SOCKnode", 
[10:21:58.404]                             "SOCK0node"))) {
[10:21:58.404]                             sendCondition <<- function(cond) {
[10:21:58.404]                               data <- list(type = "VALUE", value = cond, 
[10:21:58.404]                                 success = TRUE)
[10:21:58.404]                               parallel_sendData(master, data)
[10:21:58.404]                             }
[10:21:58.404]                             return(sendCondition)
[10:21:58.404]                           }
[10:21:58.404]                         }
[10:21:58.404]                         frame <- frame + 1L
[10:21:58.404]                         envir <- sys.frame(frame)
[10:21:58.404]                       }
[10:21:58.404]                     }
[10:21:58.404]                     sendCondition <<- function(cond) NULL
[10:21:58.404]                   }
[10:21:58.404]                 })
[10:21:58.404]                 withCallingHandlers({
[10:21:58.404]                   {
[10:21:58.404]                     gc()
[10:21:58.404]                   }
[10:21:58.404]                 }, immediateCondition = function(cond) {
[10:21:58.404]                   sendCondition <- ...future.makeSendCondition()
[10:21:58.404]                   sendCondition(cond)
[10:21:58.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.404]                   {
[10:21:58.404]                     inherits <- base::inherits
[10:21:58.404]                     invokeRestart <- base::invokeRestart
[10:21:58.404]                     is.null <- base::is.null
[10:21:58.404]                     muffled <- FALSE
[10:21:58.404]                     if (inherits(cond, "message")) {
[10:21:58.404]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:58.404]                       if (muffled) 
[10:21:58.404]                         invokeRestart("muffleMessage")
[10:21:58.404]                     }
[10:21:58.404]                     else if (inherits(cond, "warning")) {
[10:21:58.404]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:58.404]                       if (muffled) 
[10:21:58.404]                         invokeRestart("muffleWarning")
[10:21:58.404]                     }
[10:21:58.404]                     else if (inherits(cond, "condition")) {
[10:21:58.404]                       if (!is.null(pattern)) {
[10:21:58.404]                         computeRestarts <- base::computeRestarts
[10:21:58.404]                         grepl <- base::grepl
[10:21:58.404]                         restarts <- computeRestarts(cond)
[10:21:58.404]                         for (restart in restarts) {
[10:21:58.404]                           name <- restart$name
[10:21:58.404]                           if (is.null(name)) 
[10:21:58.404]                             next
[10:21:58.404]                           if (!grepl(pattern, name)) 
[10:21:58.404]                             next
[10:21:58.404]                           invokeRestart(restart)
[10:21:58.404]                           muffled <- TRUE
[10:21:58.404]                           break
[10:21:58.404]                         }
[10:21:58.404]                       }
[10:21:58.404]                     }
[10:21:58.404]                     invisible(muffled)
[10:21:58.404]                   }
[10:21:58.404]                   muffleCondition(cond)
[10:21:58.404]                 })
[10:21:58.404]             }))
[10:21:58.404]             future::FutureResult(value = ...future.value$value, 
[10:21:58.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.404]                   ...future.rng), globalenv = if (FALSE) 
[10:21:58.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:58.404]                     ...future.globalenv.names))
[10:21:58.404]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:58.404]         }, condition = base::local({
[10:21:58.404]             c <- base::c
[10:21:58.404]             inherits <- base::inherits
[10:21:58.404]             invokeRestart <- base::invokeRestart
[10:21:58.404]             length <- base::length
[10:21:58.404]             list <- base::list
[10:21:58.404]             seq.int <- base::seq.int
[10:21:58.404]             signalCondition <- base::signalCondition
[10:21:58.404]             sys.calls <- base::sys.calls
[10:21:58.404]             `[[` <- base::`[[`
[10:21:58.404]             `+` <- base::`+`
[10:21:58.404]             `<<-` <- base::`<<-`
[10:21:58.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:58.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:58.404]                   3L)]
[10:21:58.404]             }
[10:21:58.404]             function(cond) {
[10:21:58.404]                 is_error <- inherits(cond, "error")
[10:21:58.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:58.404]                   NULL)
[10:21:58.404]                 if (is_error) {
[10:21:58.404]                   sessionInformation <- function() {
[10:21:58.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:58.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:58.404]                       search = base::search(), system = base::Sys.info())
[10:21:58.404]                   }
[10:21:58.404]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:58.404]                     cond$call), session = sessionInformation(), 
[10:21:58.404]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:58.404]                   signalCondition(cond)
[10:21:58.404]                 }
[10:21:58.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:58.404]                 "immediateCondition"))) {
[10:21:58.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:58.404]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:58.404]                   if (TRUE && !signal) {
[10:21:58.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.404]                     {
[10:21:58.404]                       inherits <- base::inherits
[10:21:58.404]                       invokeRestart <- base::invokeRestart
[10:21:58.404]                       is.null <- base::is.null
[10:21:58.404]                       muffled <- FALSE
[10:21:58.404]                       if (inherits(cond, "message")) {
[10:21:58.404]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.404]                         if (muffled) 
[10:21:58.404]                           invokeRestart("muffleMessage")
[10:21:58.404]                       }
[10:21:58.404]                       else if (inherits(cond, "warning")) {
[10:21:58.404]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.404]                         if (muffled) 
[10:21:58.404]                           invokeRestart("muffleWarning")
[10:21:58.404]                       }
[10:21:58.404]                       else if (inherits(cond, "condition")) {
[10:21:58.404]                         if (!is.null(pattern)) {
[10:21:58.404]                           computeRestarts <- base::computeRestarts
[10:21:58.404]                           grepl <- base::grepl
[10:21:58.404]                           restarts <- computeRestarts(cond)
[10:21:58.404]                           for (restart in restarts) {
[10:21:58.404]                             name <- restart$name
[10:21:58.404]                             if (is.null(name)) 
[10:21:58.404]                               next
[10:21:58.404]                             if (!grepl(pattern, name)) 
[10:21:58.404]                               next
[10:21:58.404]                             invokeRestart(restart)
[10:21:58.404]                             muffled <- TRUE
[10:21:58.404]                             break
[10:21:58.404]                           }
[10:21:58.404]                         }
[10:21:58.404]                       }
[10:21:58.404]                       invisible(muffled)
[10:21:58.404]                     }
[10:21:58.404]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.404]                   }
[10:21:58.404]                 }
[10:21:58.404]                 else {
[10:21:58.404]                   if (TRUE) {
[10:21:58.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.404]                     {
[10:21:58.404]                       inherits <- base::inherits
[10:21:58.404]                       invokeRestart <- base::invokeRestart
[10:21:58.404]                       is.null <- base::is.null
[10:21:58.404]                       muffled <- FALSE
[10:21:58.404]                       if (inherits(cond, "message")) {
[10:21:58.404]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.404]                         if (muffled) 
[10:21:58.404]                           invokeRestart("muffleMessage")
[10:21:58.404]                       }
[10:21:58.404]                       else if (inherits(cond, "warning")) {
[10:21:58.404]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.404]                         if (muffled) 
[10:21:58.404]                           invokeRestart("muffleWarning")
[10:21:58.404]                       }
[10:21:58.404]                       else if (inherits(cond, "condition")) {
[10:21:58.404]                         if (!is.null(pattern)) {
[10:21:58.404]                           computeRestarts <- base::computeRestarts
[10:21:58.404]                           grepl <- base::grepl
[10:21:58.404]                           restarts <- computeRestarts(cond)
[10:21:58.404]                           for (restart in restarts) {
[10:21:58.404]                             name <- restart$name
[10:21:58.404]                             if (is.null(name)) 
[10:21:58.404]                               next
[10:21:58.404]                             if (!grepl(pattern, name)) 
[10:21:58.404]                               next
[10:21:58.404]                             invokeRestart(restart)
[10:21:58.404]                             muffled <- TRUE
[10:21:58.404]                             break
[10:21:58.404]                           }
[10:21:58.404]                         }
[10:21:58.404]                       }
[10:21:58.404]                       invisible(muffled)
[10:21:58.404]                     }
[10:21:58.404]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.404]                   }
[10:21:58.404]                 }
[10:21:58.404]             }
[10:21:58.404]         }))
[10:21:58.404]     }, error = function(ex) {
[10:21:58.404]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:58.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.404]                 ...future.rng), started = ...future.startTime, 
[10:21:58.404]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:58.404]             version = "1.8"), class = "FutureResult")
[10:21:58.404]     }, finally = {
[10:21:58.404]         if (!identical(...future.workdir, getwd())) 
[10:21:58.404]             setwd(...future.workdir)
[10:21:58.404]         {
[10:21:58.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:58.404]                 ...future.oldOptions$nwarnings <- NULL
[10:21:58.404]             }
[10:21:58.404]             base::options(...future.oldOptions)
[10:21:58.404]             if (.Platform$OS.type == "windows") {
[10:21:58.404]                 old_names <- names(...future.oldEnvVars)
[10:21:58.404]                 envs <- base::Sys.getenv()
[10:21:58.404]                 names <- names(envs)
[10:21:58.404]                 common <- intersect(names, old_names)
[10:21:58.404]                 added <- setdiff(names, old_names)
[10:21:58.404]                 removed <- setdiff(old_names, names)
[10:21:58.404]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:58.404]                   envs[common]]
[10:21:58.404]                 NAMES <- toupper(changed)
[10:21:58.404]                 args <- list()
[10:21:58.404]                 for (kk in seq_along(NAMES)) {
[10:21:58.404]                   name <- changed[[kk]]
[10:21:58.404]                   NAME <- NAMES[[kk]]
[10:21:58.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.404]                     next
[10:21:58.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.404]                 }
[10:21:58.404]                 NAMES <- toupper(added)
[10:21:58.404]                 for (kk in seq_along(NAMES)) {
[10:21:58.404]                   name <- added[[kk]]
[10:21:58.404]                   NAME <- NAMES[[kk]]
[10:21:58.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.404]                     next
[10:21:58.404]                   args[[name]] <- ""
[10:21:58.404]                 }
[10:21:58.404]                 NAMES <- toupper(removed)
[10:21:58.404]                 for (kk in seq_along(NAMES)) {
[10:21:58.404]                   name <- removed[[kk]]
[10:21:58.404]                   NAME <- NAMES[[kk]]
[10:21:58.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.404]                     next
[10:21:58.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.404]                 }
[10:21:58.404]                 if (length(args) > 0) 
[10:21:58.404]                   base::do.call(base::Sys.setenv, args = args)
[10:21:58.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:58.404]             }
[10:21:58.404]             else {
[10:21:58.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:58.404]             }
[10:21:58.404]             {
[10:21:58.404]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:58.404]                   0L) {
[10:21:58.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:58.404]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:58.404]                   base::options(opts)
[10:21:58.404]                 }
[10:21:58.404]                 {
[10:21:58.404]                   {
[10:21:58.404]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:58.404]                     NULL
[10:21:58.404]                   }
[10:21:58.404]                   options(future.plan = NULL)
[10:21:58.404]                   if (is.na(NA_character_)) 
[10:21:58.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:58.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:58.404]                     .init = FALSE)
[10:21:58.404]                 }
[10:21:58.404]             }
[10:21:58.404]         }
[10:21:58.404]     })
[10:21:58.404]     if (TRUE) {
[10:21:58.404]         base::sink(type = "output", split = FALSE)
[10:21:58.404]         if (TRUE) {
[10:21:58.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:58.404]         }
[10:21:58.404]         else {
[10:21:58.404]             ...future.result["stdout"] <- base::list(NULL)
[10:21:58.404]         }
[10:21:58.404]         base::close(...future.stdout)
[10:21:58.404]         ...future.stdout <- NULL
[10:21:58.404]     }
[10:21:58.404]     ...future.result$conditions <- ...future.conditions
[10:21:58.404]     ...future.result$finished <- base::Sys.time()
[10:21:58.404]     ...future.result
[10:21:58.404] }
[10:21:58.407] MultisessionFuture started
[10:21:58.407] - Launch lazy future ... done
[10:21:58.407] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[10:21:58.407] result() for ClusterFuture ...
[10:21:58.407] receiveMessageFromWorker() for ClusterFuture ...
[10:21:58.407] - Validating connection of MultisessionFuture
[10:21:58.476] - received message: FutureResult
[10:21:58.476] - Received FutureResult
[10:21:58.476] - Erased future from FutureRegistry
[10:21:58.476] result() for ClusterFuture ...
[10:21:58.476] - result already collected: FutureResult
[10:21:58.476] result() for ClusterFuture ... done
[10:21:58.477] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:58.477] result() for ClusterFuture ... done
[10:21:58.477] result() for ClusterFuture ...
[10:21:58.477] - result already collected: FutureResult
[10:21:58.477] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 409533 21.9     692222   37   692222   37
Vcells 732376  5.6    8388608   64  5754333   44
> 
> f <- future({ integer(10e6) }, gc = TRUE)
[10:21:58.477] getGlobalsAndPackages() ...
[10:21:58.477] Searching for globals...
[10:21:58.478] - globals found: [2] ‘{’, ‘integer’
[10:21:58.478] Searching for globals ... DONE
[10:21:58.478] Resolving globals: FALSE
[10:21:58.479] 
[10:21:58.479] 
[10:21:58.479] getGlobalsAndPackages() ... DONE
[10:21:58.479] run() for ‘Future’ ...
[10:21:58.479] - state: ‘created’
[10:21:58.479] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:58.492] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:58.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:58.492]   - Field: ‘node’
[10:21:58.492]   - Field: ‘label’
[10:21:58.492]   - Field: ‘local’
[10:21:58.493]   - Field: ‘owner’
[10:21:58.493]   - Field: ‘envir’
[10:21:58.493]   - Field: ‘workers’
[10:21:58.493]   - Field: ‘packages’
[10:21:58.493]   - Field: ‘gc’
[10:21:58.493]   - Field: ‘conditions’
[10:21:58.493]   - Field: ‘persistent’
[10:21:58.493]   - Field: ‘expr’
[10:21:58.493]   - Field: ‘uuid’
[10:21:58.493]   - Field: ‘seed’
[10:21:58.493]   - Field: ‘version’
[10:21:58.493]   - Field: ‘result’
[10:21:58.494]   - Field: ‘asynchronous’
[10:21:58.494]   - Field: ‘calls’
[10:21:58.494]   - Field: ‘globals’
[10:21:58.494]   - Field: ‘stdout’
[10:21:58.494]   - Field: ‘earlySignal’
[10:21:58.494]   - Field: ‘lazy’
[10:21:58.494]   - Field: ‘state’
[10:21:58.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:58.494] - Launch lazy future ...
[10:21:58.495] Packages needed by the future expression (n = 0): <none>
[10:21:58.495] Packages needed by future strategies (n = 0): <none>
[10:21:58.497] {
[10:21:58.497]     {
[10:21:58.497]         {
[10:21:58.497]             ...future.startTime <- base::Sys.time()
[10:21:58.497]             {
[10:21:58.497]                 {
[10:21:58.497]                   {
[10:21:58.497]                     {
[10:21:58.497]                       base::local({
[10:21:58.497]                         has_future <- base::requireNamespace("future", 
[10:21:58.497]                           quietly = TRUE)
[10:21:58.497]                         if (has_future) {
[10:21:58.497]                           ns <- base::getNamespace("future")
[10:21:58.497]                           version <- ns[[".package"]][["version"]]
[10:21:58.497]                           if (is.null(version)) 
[10:21:58.497]                             version <- utils::packageVersion("future")
[10:21:58.497]                         }
[10:21:58.497]                         else {
[10:21:58.497]                           version <- NULL
[10:21:58.497]                         }
[10:21:58.497]                         if (!has_future || version < "1.8.0") {
[10:21:58.497]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:58.497]                             "", base::R.version$version.string), 
[10:21:58.497]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:58.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:58.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:58.497]                               "release", "version")], collapse = " "), 
[10:21:58.497]                             hostname = base::Sys.info()[["nodename"]])
[10:21:58.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:58.497]                             info)
[10:21:58.497]                           info <- base::paste(info, collapse = "; ")
[10:21:58.497]                           if (!has_future) {
[10:21:58.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:58.497]                               info)
[10:21:58.497]                           }
[10:21:58.497]                           else {
[10:21:58.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:58.497]                               info, version)
[10:21:58.497]                           }
[10:21:58.497]                           base::stop(msg)
[10:21:58.497]                         }
[10:21:58.497]                       })
[10:21:58.497]                     }
[10:21:58.497]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:58.497]                     base::options(mc.cores = 1L)
[10:21:58.497]                   }
[10:21:58.497]                   ...future.strategy.old <- future::plan("list")
[10:21:58.497]                   options(future.plan = NULL)
[10:21:58.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:58.497]                 }
[10:21:58.497]                 ...future.workdir <- getwd()
[10:21:58.497]             }
[10:21:58.497]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:58.497]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:58.497]         }
[10:21:58.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:58.497]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:58.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:58.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:58.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:58.497]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:58.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:58.497]             base::names(...future.oldOptions))
[10:21:58.497]     }
[10:21:58.497]     if (FALSE) {
[10:21:58.497]     }
[10:21:58.497]     else {
[10:21:58.497]         if (TRUE) {
[10:21:58.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:58.497]                 open = "w")
[10:21:58.497]         }
[10:21:58.497]         else {
[10:21:58.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:58.497]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:58.497]         }
[10:21:58.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:58.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:58.497]             base::sink(type = "output", split = FALSE)
[10:21:58.497]             base::close(...future.stdout)
[10:21:58.497]         }, add = TRUE)
[10:21:58.497]     }
[10:21:58.497]     ...future.frame <- base::sys.nframe()
[10:21:58.497]     ...future.conditions <- base::list()
[10:21:58.497]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:58.497]     if (FALSE) {
[10:21:58.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:58.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:58.497]     }
[10:21:58.497]     ...future.result <- base::tryCatch({
[10:21:58.497]         base::withCallingHandlers({
[10:21:58.497]             ...future.value <- base::withVisible(base::local({
[10:21:58.497]                 ...future.makeSendCondition <- base::local({
[10:21:58.497]                   sendCondition <- NULL
[10:21:58.497]                   function(frame = 1L) {
[10:21:58.497]                     if (is.function(sendCondition)) 
[10:21:58.497]                       return(sendCondition)
[10:21:58.497]                     ns <- getNamespace("parallel")
[10:21:58.497]                     if (exists("sendData", mode = "function", 
[10:21:58.497]                       envir = ns)) {
[10:21:58.497]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:58.497]                         envir = ns)
[10:21:58.497]                       envir <- sys.frame(frame)
[10:21:58.497]                       master <- NULL
[10:21:58.497]                       while (!identical(envir, .GlobalEnv) && 
[10:21:58.497]                         !identical(envir, emptyenv())) {
[10:21:58.497]                         if (exists("master", mode = "list", envir = envir, 
[10:21:58.497]                           inherits = FALSE)) {
[10:21:58.497]                           master <- get("master", mode = "list", 
[10:21:58.497]                             envir = envir, inherits = FALSE)
[10:21:58.497]                           if (inherits(master, c("SOCKnode", 
[10:21:58.497]                             "SOCK0node"))) {
[10:21:58.497]                             sendCondition <<- function(cond) {
[10:21:58.497]                               data <- list(type = "VALUE", value = cond, 
[10:21:58.497]                                 success = TRUE)
[10:21:58.497]                               parallel_sendData(master, data)
[10:21:58.497]                             }
[10:21:58.497]                             return(sendCondition)
[10:21:58.497]                           }
[10:21:58.497]                         }
[10:21:58.497]                         frame <- frame + 1L
[10:21:58.497]                         envir <- sys.frame(frame)
[10:21:58.497]                       }
[10:21:58.497]                     }
[10:21:58.497]                     sendCondition <<- function(cond) NULL
[10:21:58.497]                   }
[10:21:58.497]                 })
[10:21:58.497]                 withCallingHandlers({
[10:21:58.497]                   {
[10:21:58.497]                     integer(1e+07)
[10:21:58.497]                   }
[10:21:58.497]                 }, immediateCondition = function(cond) {
[10:21:58.497]                   sendCondition <- ...future.makeSendCondition()
[10:21:58.497]                   sendCondition(cond)
[10:21:58.497]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.497]                   {
[10:21:58.497]                     inherits <- base::inherits
[10:21:58.497]                     invokeRestart <- base::invokeRestart
[10:21:58.497]                     is.null <- base::is.null
[10:21:58.497]                     muffled <- FALSE
[10:21:58.497]                     if (inherits(cond, "message")) {
[10:21:58.497]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:58.497]                       if (muffled) 
[10:21:58.497]                         invokeRestart("muffleMessage")
[10:21:58.497]                     }
[10:21:58.497]                     else if (inherits(cond, "warning")) {
[10:21:58.497]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:58.497]                       if (muffled) 
[10:21:58.497]                         invokeRestart("muffleWarning")
[10:21:58.497]                     }
[10:21:58.497]                     else if (inherits(cond, "condition")) {
[10:21:58.497]                       if (!is.null(pattern)) {
[10:21:58.497]                         computeRestarts <- base::computeRestarts
[10:21:58.497]                         grepl <- base::grepl
[10:21:58.497]                         restarts <- computeRestarts(cond)
[10:21:58.497]                         for (restart in restarts) {
[10:21:58.497]                           name <- restart$name
[10:21:58.497]                           if (is.null(name)) 
[10:21:58.497]                             next
[10:21:58.497]                           if (!grepl(pattern, name)) 
[10:21:58.497]                             next
[10:21:58.497]                           invokeRestart(restart)
[10:21:58.497]                           muffled <- TRUE
[10:21:58.497]                           break
[10:21:58.497]                         }
[10:21:58.497]                       }
[10:21:58.497]                     }
[10:21:58.497]                     invisible(muffled)
[10:21:58.497]                   }
[10:21:58.497]                   muffleCondition(cond)
[10:21:58.497]                 })
[10:21:58.497]             }))
[10:21:58.497]             future::FutureResult(value = ...future.value$value, 
[10:21:58.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.497]                   ...future.rng), globalenv = if (FALSE) 
[10:21:58.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:58.497]                     ...future.globalenv.names))
[10:21:58.497]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:58.497]         }, condition = base::local({
[10:21:58.497]             c <- base::c
[10:21:58.497]             inherits <- base::inherits
[10:21:58.497]             invokeRestart <- base::invokeRestart
[10:21:58.497]             length <- base::length
[10:21:58.497]             list <- base::list
[10:21:58.497]             seq.int <- base::seq.int
[10:21:58.497]             signalCondition <- base::signalCondition
[10:21:58.497]             sys.calls <- base::sys.calls
[10:21:58.497]             `[[` <- base::`[[`
[10:21:58.497]             `+` <- base::`+`
[10:21:58.497]             `<<-` <- base::`<<-`
[10:21:58.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:58.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:58.497]                   3L)]
[10:21:58.497]             }
[10:21:58.497]             function(cond) {
[10:21:58.497]                 is_error <- inherits(cond, "error")
[10:21:58.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:58.497]                   NULL)
[10:21:58.497]                 if (is_error) {
[10:21:58.497]                   sessionInformation <- function() {
[10:21:58.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:58.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:58.497]                       search = base::search(), system = base::Sys.info())
[10:21:58.497]                   }
[10:21:58.497]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:58.497]                     cond$call), session = sessionInformation(), 
[10:21:58.497]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:58.497]                   signalCondition(cond)
[10:21:58.497]                 }
[10:21:58.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:58.497]                 "immediateCondition"))) {
[10:21:58.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:58.497]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:58.497]                   if (TRUE && !signal) {
[10:21:58.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.497]                     {
[10:21:58.497]                       inherits <- base::inherits
[10:21:58.497]                       invokeRestart <- base::invokeRestart
[10:21:58.497]                       is.null <- base::is.null
[10:21:58.497]                       muffled <- FALSE
[10:21:58.497]                       if (inherits(cond, "message")) {
[10:21:58.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.497]                         if (muffled) 
[10:21:58.497]                           invokeRestart("muffleMessage")
[10:21:58.497]                       }
[10:21:58.497]                       else if (inherits(cond, "warning")) {
[10:21:58.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.497]                         if (muffled) 
[10:21:58.497]                           invokeRestart("muffleWarning")
[10:21:58.497]                       }
[10:21:58.497]                       else if (inherits(cond, "condition")) {
[10:21:58.497]                         if (!is.null(pattern)) {
[10:21:58.497]                           computeRestarts <- base::computeRestarts
[10:21:58.497]                           grepl <- base::grepl
[10:21:58.497]                           restarts <- computeRestarts(cond)
[10:21:58.497]                           for (restart in restarts) {
[10:21:58.497]                             name <- restart$name
[10:21:58.497]                             if (is.null(name)) 
[10:21:58.497]                               next
[10:21:58.497]                             if (!grepl(pattern, name)) 
[10:21:58.497]                               next
[10:21:58.497]                             invokeRestart(restart)
[10:21:58.497]                             muffled <- TRUE
[10:21:58.497]                             break
[10:21:58.497]                           }
[10:21:58.497]                         }
[10:21:58.497]                       }
[10:21:58.497]                       invisible(muffled)
[10:21:58.497]                     }
[10:21:58.497]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.497]                   }
[10:21:58.497]                 }
[10:21:58.497]                 else {
[10:21:58.497]                   if (TRUE) {
[10:21:58.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.497]                     {
[10:21:58.497]                       inherits <- base::inherits
[10:21:58.497]                       invokeRestart <- base::invokeRestart
[10:21:58.497]                       is.null <- base::is.null
[10:21:58.497]                       muffled <- FALSE
[10:21:58.497]                       if (inherits(cond, "message")) {
[10:21:58.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.497]                         if (muffled) 
[10:21:58.497]                           invokeRestart("muffleMessage")
[10:21:58.497]                       }
[10:21:58.497]                       else if (inherits(cond, "warning")) {
[10:21:58.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.497]                         if (muffled) 
[10:21:58.497]                           invokeRestart("muffleWarning")
[10:21:58.497]                       }
[10:21:58.497]                       else if (inherits(cond, "condition")) {
[10:21:58.497]                         if (!is.null(pattern)) {
[10:21:58.497]                           computeRestarts <- base::computeRestarts
[10:21:58.497]                           grepl <- base::grepl
[10:21:58.497]                           restarts <- computeRestarts(cond)
[10:21:58.497]                           for (restart in restarts) {
[10:21:58.497]                             name <- restart$name
[10:21:58.497]                             if (is.null(name)) 
[10:21:58.497]                               next
[10:21:58.497]                             if (!grepl(pattern, name)) 
[10:21:58.497]                               next
[10:21:58.497]                             invokeRestart(restart)
[10:21:58.497]                             muffled <- TRUE
[10:21:58.497]                             break
[10:21:58.497]                           }
[10:21:58.497]                         }
[10:21:58.497]                       }
[10:21:58.497]                       invisible(muffled)
[10:21:58.497]                     }
[10:21:58.497]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.497]                   }
[10:21:58.497]                 }
[10:21:58.497]             }
[10:21:58.497]         }))
[10:21:58.497]     }, error = function(ex) {
[10:21:58.497]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:58.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.497]                 ...future.rng), started = ...future.startTime, 
[10:21:58.497]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:58.497]             version = "1.8"), class = "FutureResult")
[10:21:58.497]     }, finally = {
[10:21:58.497]         if (!identical(...future.workdir, getwd())) 
[10:21:58.497]             setwd(...future.workdir)
[10:21:58.497]         {
[10:21:58.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:58.497]                 ...future.oldOptions$nwarnings <- NULL
[10:21:58.497]             }
[10:21:58.497]             base::options(...future.oldOptions)
[10:21:58.497]             if (.Platform$OS.type == "windows") {
[10:21:58.497]                 old_names <- names(...future.oldEnvVars)
[10:21:58.497]                 envs <- base::Sys.getenv()
[10:21:58.497]                 names <- names(envs)
[10:21:58.497]                 common <- intersect(names, old_names)
[10:21:58.497]                 added <- setdiff(names, old_names)
[10:21:58.497]                 removed <- setdiff(old_names, names)
[10:21:58.497]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:58.497]                   envs[common]]
[10:21:58.497]                 NAMES <- toupper(changed)
[10:21:58.497]                 args <- list()
[10:21:58.497]                 for (kk in seq_along(NAMES)) {
[10:21:58.497]                   name <- changed[[kk]]
[10:21:58.497]                   NAME <- NAMES[[kk]]
[10:21:58.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.497]                     next
[10:21:58.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.497]                 }
[10:21:58.497]                 NAMES <- toupper(added)
[10:21:58.497]                 for (kk in seq_along(NAMES)) {
[10:21:58.497]                   name <- added[[kk]]
[10:21:58.497]                   NAME <- NAMES[[kk]]
[10:21:58.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.497]                     next
[10:21:58.497]                   args[[name]] <- ""
[10:21:58.497]                 }
[10:21:58.497]                 NAMES <- toupper(removed)
[10:21:58.497]                 for (kk in seq_along(NAMES)) {
[10:21:58.497]                   name <- removed[[kk]]
[10:21:58.497]                   NAME <- NAMES[[kk]]
[10:21:58.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.497]                     next
[10:21:58.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.497]                 }
[10:21:58.497]                 if (length(args) > 0) 
[10:21:58.497]                   base::do.call(base::Sys.setenv, args = args)
[10:21:58.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:58.497]             }
[10:21:58.497]             else {
[10:21:58.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:58.497]             }
[10:21:58.497]             {
[10:21:58.497]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:58.497]                   0L) {
[10:21:58.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:58.497]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:58.497]                   base::options(opts)
[10:21:58.497]                 }
[10:21:58.497]                 {
[10:21:58.497]                   {
[10:21:58.497]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:58.497]                     NULL
[10:21:58.497]                   }
[10:21:58.497]                   options(future.plan = NULL)
[10:21:58.497]                   if (is.na(NA_character_)) 
[10:21:58.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:58.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:58.497]                     .init = FALSE)
[10:21:58.497]                 }
[10:21:58.497]             }
[10:21:58.497]         }
[10:21:58.497]     })
[10:21:58.497]     if (TRUE) {
[10:21:58.497]         base::sink(type = "output", split = FALSE)
[10:21:58.497]         if (TRUE) {
[10:21:58.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:58.497]         }
[10:21:58.497]         else {
[10:21:58.497]             ...future.result["stdout"] <- base::list(NULL)
[10:21:58.497]         }
[10:21:58.497]         base::close(...future.stdout)
[10:21:58.497]         ...future.stdout <- NULL
[10:21:58.497]     }
[10:21:58.497]     ...future.result$conditions <- ...future.conditions
[10:21:58.497]     ...future.result$finished <- base::Sys.time()
[10:21:58.497]     ...future.result
[10:21:58.497] }
[10:21:58.500] MultisessionFuture started
[10:21:58.500] - Launch lazy future ... done
[10:21:58.501] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[10:21:58.501] result() for ClusterFuture ...
[10:21:58.501] receiveMessageFromWorker() for ClusterFuture ...
[10:21:58.501] - Validating connection of MultisessionFuture
[10:21:58.591] - received message: FutureResult
[10:21:58.591] - Received FutureResult
[10:21:58.591] - Erased future from FutureRegistry
[10:21:58.592] result() for ClusterFuture ...
[10:21:58.592] - result already collected: FutureResult
[10:21:58.592] result() for ClusterFuture ... done
[10:21:58.592] - Garbage collecting worker ...
[10:21:58.829] - Garbage collecting worker ... done
[10:21:58.830] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:58.830] result() for ClusterFuture ... done
[10:21:58.830] result() for ClusterFuture ...
[10:21:58.830] - result already collected: FutureResult
[10:21:58.830] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[10:21:58.831] getGlobalsAndPackages() ...
[10:21:58.831] Searching for globals...
[10:21:58.832] - globals found: [2] ‘{’, ‘gc’
[10:21:58.832] Searching for globals ... DONE
[10:21:58.832] Resolving globals: FALSE
[10:21:58.832] 
[10:21:58.832] 
[10:21:58.832] getGlobalsAndPackages() ... DONE
[10:21:58.833] run() for ‘Future’ ...
[10:21:58.833] - state: ‘created’
[10:21:58.833] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:58.845] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:58.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:58.846]   - Field: ‘node’
[10:21:58.846]   - Field: ‘label’
[10:21:58.846]   - Field: ‘local’
[10:21:58.846]   - Field: ‘owner’
[10:21:58.846]   - Field: ‘envir’
[10:21:58.846]   - Field: ‘workers’
[10:21:58.846]   - Field: ‘packages’
[10:21:58.846]   - Field: ‘gc’
[10:21:58.846]   - Field: ‘conditions’
[10:21:58.846]   - Field: ‘persistent’
[10:21:58.847]   - Field: ‘expr’
[10:21:58.847]   - Field: ‘uuid’
[10:21:58.847]   - Field: ‘seed’
[10:21:58.847]   - Field: ‘version’
[10:21:58.847]   - Field: ‘result’
[10:21:58.847]   - Field: ‘asynchronous’
[10:21:58.847]   - Field: ‘calls’
[10:21:58.847]   - Field: ‘globals’
[10:21:58.847]   - Field: ‘stdout’
[10:21:58.847]   - Field: ‘earlySignal’
[10:21:58.847]   - Field: ‘lazy’
[10:21:58.847]   - Field: ‘state’
[10:21:58.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:58.848] - Launch lazy future ...
[10:21:58.848] Packages needed by the future expression (n = 0): <none>
[10:21:58.848] Packages needed by future strategies (n = 0): <none>
[10:21:58.848] {
[10:21:58.848]     {
[10:21:58.848]         {
[10:21:58.848]             ...future.startTime <- base::Sys.time()
[10:21:58.848]             {
[10:21:58.848]                 {
[10:21:58.848]                   {
[10:21:58.848]                     {
[10:21:58.848]                       base::local({
[10:21:58.848]                         has_future <- base::requireNamespace("future", 
[10:21:58.848]                           quietly = TRUE)
[10:21:58.848]                         if (has_future) {
[10:21:58.848]                           ns <- base::getNamespace("future")
[10:21:58.848]                           version <- ns[[".package"]][["version"]]
[10:21:58.848]                           if (is.null(version)) 
[10:21:58.848]                             version <- utils::packageVersion("future")
[10:21:58.848]                         }
[10:21:58.848]                         else {
[10:21:58.848]                           version <- NULL
[10:21:58.848]                         }
[10:21:58.848]                         if (!has_future || version < "1.8.0") {
[10:21:58.848]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:58.848]                             "", base::R.version$version.string), 
[10:21:58.848]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:58.848]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:58.848]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:58.848]                               "release", "version")], collapse = " "), 
[10:21:58.848]                             hostname = base::Sys.info()[["nodename"]])
[10:21:58.848]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:58.848]                             info)
[10:21:58.848]                           info <- base::paste(info, collapse = "; ")
[10:21:58.848]                           if (!has_future) {
[10:21:58.848]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:58.848]                               info)
[10:21:58.848]                           }
[10:21:58.848]                           else {
[10:21:58.848]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:58.848]                               info, version)
[10:21:58.848]                           }
[10:21:58.848]                           base::stop(msg)
[10:21:58.848]                         }
[10:21:58.848]                       })
[10:21:58.848]                     }
[10:21:58.848]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:58.848]                     base::options(mc.cores = 1L)
[10:21:58.848]                   }
[10:21:58.848]                   ...future.strategy.old <- future::plan("list")
[10:21:58.848]                   options(future.plan = NULL)
[10:21:58.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:58.848]                 }
[10:21:58.848]                 ...future.workdir <- getwd()
[10:21:58.848]             }
[10:21:58.848]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:58.848]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:58.848]         }
[10:21:58.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:58.848]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:58.848]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:58.848]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:58.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:58.848]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:58.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:58.848]             base::names(...future.oldOptions))
[10:21:58.848]     }
[10:21:58.848]     if (FALSE) {
[10:21:58.848]     }
[10:21:58.848]     else {
[10:21:58.848]         if (TRUE) {
[10:21:58.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:58.848]                 open = "w")
[10:21:58.848]         }
[10:21:58.848]         else {
[10:21:58.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:58.848]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:58.848]         }
[10:21:58.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:58.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:58.848]             base::sink(type = "output", split = FALSE)
[10:21:58.848]             base::close(...future.stdout)
[10:21:58.848]         }, add = TRUE)
[10:21:58.848]     }
[10:21:58.848]     ...future.frame <- base::sys.nframe()
[10:21:58.848]     ...future.conditions <- base::list()
[10:21:58.848]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:58.848]     if (FALSE) {
[10:21:58.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:58.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:58.848]     }
[10:21:58.848]     ...future.result <- base::tryCatch({
[10:21:58.848]         base::withCallingHandlers({
[10:21:58.848]             ...future.value <- base::withVisible(base::local({
[10:21:58.848]                 ...future.makeSendCondition <- base::local({
[10:21:58.848]                   sendCondition <- NULL
[10:21:58.848]                   function(frame = 1L) {
[10:21:58.848]                     if (is.function(sendCondition)) 
[10:21:58.848]                       return(sendCondition)
[10:21:58.848]                     ns <- getNamespace("parallel")
[10:21:58.848]                     if (exists("sendData", mode = "function", 
[10:21:58.848]                       envir = ns)) {
[10:21:58.848]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:58.848]                         envir = ns)
[10:21:58.848]                       envir <- sys.frame(frame)
[10:21:58.848]                       master <- NULL
[10:21:58.848]                       while (!identical(envir, .GlobalEnv) && 
[10:21:58.848]                         !identical(envir, emptyenv())) {
[10:21:58.848]                         if (exists("master", mode = "list", envir = envir, 
[10:21:58.848]                           inherits = FALSE)) {
[10:21:58.848]                           master <- get("master", mode = "list", 
[10:21:58.848]                             envir = envir, inherits = FALSE)
[10:21:58.848]                           if (inherits(master, c("SOCKnode", 
[10:21:58.848]                             "SOCK0node"))) {
[10:21:58.848]                             sendCondition <<- function(cond) {
[10:21:58.848]                               data <- list(type = "VALUE", value = cond, 
[10:21:58.848]                                 success = TRUE)
[10:21:58.848]                               parallel_sendData(master, data)
[10:21:58.848]                             }
[10:21:58.848]                             return(sendCondition)
[10:21:58.848]                           }
[10:21:58.848]                         }
[10:21:58.848]                         frame <- frame + 1L
[10:21:58.848]                         envir <- sys.frame(frame)
[10:21:58.848]                       }
[10:21:58.848]                     }
[10:21:58.848]                     sendCondition <<- function(cond) NULL
[10:21:58.848]                   }
[10:21:58.848]                 })
[10:21:58.848]                 withCallingHandlers({
[10:21:58.848]                   {
[10:21:58.848]                     gc()
[10:21:58.848]                   }
[10:21:58.848]                 }, immediateCondition = function(cond) {
[10:21:58.848]                   sendCondition <- ...future.makeSendCondition()
[10:21:58.848]                   sendCondition(cond)
[10:21:58.848]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.848]                   {
[10:21:58.848]                     inherits <- base::inherits
[10:21:58.848]                     invokeRestart <- base::invokeRestart
[10:21:58.848]                     is.null <- base::is.null
[10:21:58.848]                     muffled <- FALSE
[10:21:58.848]                     if (inherits(cond, "message")) {
[10:21:58.848]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:58.848]                       if (muffled) 
[10:21:58.848]                         invokeRestart("muffleMessage")
[10:21:58.848]                     }
[10:21:58.848]                     else if (inherits(cond, "warning")) {
[10:21:58.848]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:58.848]                       if (muffled) 
[10:21:58.848]                         invokeRestart("muffleWarning")
[10:21:58.848]                     }
[10:21:58.848]                     else if (inherits(cond, "condition")) {
[10:21:58.848]                       if (!is.null(pattern)) {
[10:21:58.848]                         computeRestarts <- base::computeRestarts
[10:21:58.848]                         grepl <- base::grepl
[10:21:58.848]                         restarts <- computeRestarts(cond)
[10:21:58.848]                         for (restart in restarts) {
[10:21:58.848]                           name <- restart$name
[10:21:58.848]                           if (is.null(name)) 
[10:21:58.848]                             next
[10:21:58.848]                           if (!grepl(pattern, name)) 
[10:21:58.848]                             next
[10:21:58.848]                           invokeRestart(restart)
[10:21:58.848]                           muffled <- TRUE
[10:21:58.848]                           break
[10:21:58.848]                         }
[10:21:58.848]                       }
[10:21:58.848]                     }
[10:21:58.848]                     invisible(muffled)
[10:21:58.848]                   }
[10:21:58.848]                   muffleCondition(cond)
[10:21:58.848]                 })
[10:21:58.848]             }))
[10:21:58.848]             future::FutureResult(value = ...future.value$value, 
[10:21:58.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.848]                   ...future.rng), globalenv = if (FALSE) 
[10:21:58.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:58.848]                     ...future.globalenv.names))
[10:21:58.848]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:58.848]         }, condition = base::local({
[10:21:58.848]             c <- base::c
[10:21:58.848]             inherits <- base::inherits
[10:21:58.848]             invokeRestart <- base::invokeRestart
[10:21:58.848]             length <- base::length
[10:21:58.848]             list <- base::list
[10:21:58.848]             seq.int <- base::seq.int
[10:21:58.848]             signalCondition <- base::signalCondition
[10:21:58.848]             sys.calls <- base::sys.calls
[10:21:58.848]             `[[` <- base::`[[`
[10:21:58.848]             `+` <- base::`+`
[10:21:58.848]             `<<-` <- base::`<<-`
[10:21:58.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:58.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:58.848]                   3L)]
[10:21:58.848]             }
[10:21:58.848]             function(cond) {
[10:21:58.848]                 is_error <- inherits(cond, "error")
[10:21:58.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:58.848]                   NULL)
[10:21:58.848]                 if (is_error) {
[10:21:58.848]                   sessionInformation <- function() {
[10:21:58.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:58.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:58.848]                       search = base::search(), system = base::Sys.info())
[10:21:58.848]                   }
[10:21:58.848]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:58.848]                     cond$call), session = sessionInformation(), 
[10:21:58.848]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:58.848]                   signalCondition(cond)
[10:21:58.848]                 }
[10:21:58.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:58.848]                 "immediateCondition"))) {
[10:21:58.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:58.848]                   ...future.conditions[[length(...future.conditions) + 
[10:21:58.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:58.848]                   if (TRUE && !signal) {
[10:21:58.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.848]                     {
[10:21:58.848]                       inherits <- base::inherits
[10:21:58.848]                       invokeRestart <- base::invokeRestart
[10:21:58.848]                       is.null <- base::is.null
[10:21:58.848]                       muffled <- FALSE
[10:21:58.848]                       if (inherits(cond, "message")) {
[10:21:58.848]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.848]                         if (muffled) 
[10:21:58.848]                           invokeRestart("muffleMessage")
[10:21:58.848]                       }
[10:21:58.848]                       else if (inherits(cond, "warning")) {
[10:21:58.848]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.848]                         if (muffled) 
[10:21:58.848]                           invokeRestart("muffleWarning")
[10:21:58.848]                       }
[10:21:58.848]                       else if (inherits(cond, "condition")) {
[10:21:58.848]                         if (!is.null(pattern)) {
[10:21:58.848]                           computeRestarts <- base::computeRestarts
[10:21:58.848]                           grepl <- base::grepl
[10:21:58.848]                           restarts <- computeRestarts(cond)
[10:21:58.848]                           for (restart in restarts) {
[10:21:58.848]                             name <- restart$name
[10:21:58.848]                             if (is.null(name)) 
[10:21:58.848]                               next
[10:21:58.848]                             if (!grepl(pattern, name)) 
[10:21:58.848]                               next
[10:21:58.848]                             invokeRestart(restart)
[10:21:58.848]                             muffled <- TRUE
[10:21:58.848]                             break
[10:21:58.848]                           }
[10:21:58.848]                         }
[10:21:58.848]                       }
[10:21:58.848]                       invisible(muffled)
[10:21:58.848]                     }
[10:21:58.848]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.848]                   }
[10:21:58.848]                 }
[10:21:58.848]                 else {
[10:21:58.848]                   if (TRUE) {
[10:21:58.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:58.848]                     {
[10:21:58.848]                       inherits <- base::inherits
[10:21:58.848]                       invokeRestart <- base::invokeRestart
[10:21:58.848]                       is.null <- base::is.null
[10:21:58.848]                       muffled <- FALSE
[10:21:58.848]                       if (inherits(cond, "message")) {
[10:21:58.848]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:58.848]                         if (muffled) 
[10:21:58.848]                           invokeRestart("muffleMessage")
[10:21:58.848]                       }
[10:21:58.848]                       else if (inherits(cond, "warning")) {
[10:21:58.848]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:58.848]                         if (muffled) 
[10:21:58.848]                           invokeRestart("muffleWarning")
[10:21:58.848]                       }
[10:21:58.848]                       else if (inherits(cond, "condition")) {
[10:21:58.848]                         if (!is.null(pattern)) {
[10:21:58.848]                           computeRestarts <- base::computeRestarts
[10:21:58.848]                           grepl <- base::grepl
[10:21:58.848]                           restarts <- computeRestarts(cond)
[10:21:58.848]                           for (restart in restarts) {
[10:21:58.848]                             name <- restart$name
[10:21:58.848]                             if (is.null(name)) 
[10:21:58.848]                               next
[10:21:58.848]                             if (!grepl(pattern, name)) 
[10:21:58.848]                               next
[10:21:58.848]                             invokeRestart(restart)
[10:21:58.848]                             muffled <- TRUE
[10:21:58.848]                             break
[10:21:58.848]                           }
[10:21:58.848]                         }
[10:21:58.848]                       }
[10:21:58.848]                       invisible(muffled)
[10:21:58.848]                     }
[10:21:58.848]                     muffleCondition(cond, pattern = "^muffle")
[10:21:58.848]                   }
[10:21:58.848]                 }
[10:21:58.848]             }
[10:21:58.848]         }))
[10:21:58.848]     }, error = function(ex) {
[10:21:58.848]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:58.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:58.848]                 ...future.rng), started = ...future.startTime, 
[10:21:58.848]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:58.848]             version = "1.8"), class = "FutureResult")
[10:21:58.848]     }, finally = {
[10:21:58.848]         if (!identical(...future.workdir, getwd())) 
[10:21:58.848]             setwd(...future.workdir)
[10:21:58.848]         {
[10:21:58.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:58.848]                 ...future.oldOptions$nwarnings <- NULL
[10:21:58.848]             }
[10:21:58.848]             base::options(...future.oldOptions)
[10:21:58.848]             if (.Platform$OS.type == "windows") {
[10:21:58.848]                 old_names <- names(...future.oldEnvVars)
[10:21:58.848]                 envs <- base::Sys.getenv()
[10:21:58.848]                 names <- names(envs)
[10:21:58.848]                 common <- intersect(names, old_names)
[10:21:58.848]                 added <- setdiff(names, old_names)
[10:21:58.848]                 removed <- setdiff(old_names, names)
[10:21:58.848]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:58.848]                   envs[common]]
[10:21:58.848]                 NAMES <- toupper(changed)
[10:21:58.848]                 args <- list()
[10:21:58.848]                 for (kk in seq_along(NAMES)) {
[10:21:58.848]                   name <- changed[[kk]]
[10:21:58.848]                   NAME <- NAMES[[kk]]
[10:21:58.848]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.848]                     next
[10:21:58.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.848]                 }
[10:21:58.848]                 NAMES <- toupper(added)
[10:21:58.848]                 for (kk in seq_along(NAMES)) {
[10:21:58.848]                   name <- added[[kk]]
[10:21:58.848]                   NAME <- NAMES[[kk]]
[10:21:58.848]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.848]                     next
[10:21:58.848]                   args[[name]] <- ""
[10:21:58.848]                 }
[10:21:58.848]                 NAMES <- toupper(removed)
[10:21:58.848]                 for (kk in seq_along(NAMES)) {
[10:21:58.848]                   name <- removed[[kk]]
[10:21:58.848]                   NAME <- NAMES[[kk]]
[10:21:58.848]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:58.848]                     next
[10:21:58.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:58.848]                 }
[10:21:58.848]                 if (length(args) > 0) 
[10:21:58.848]                   base::do.call(base::Sys.setenv, args = args)
[10:21:58.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:58.848]             }
[10:21:58.848]             else {
[10:21:58.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:58.848]             }
[10:21:58.848]             {
[10:21:58.848]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:58.848]                   0L) {
[10:21:58.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:58.848]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:58.848]                   base::options(opts)
[10:21:58.848]                 }
[10:21:58.848]                 {
[10:21:58.848]                   {
[10:21:58.848]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:58.848]                     NULL
[10:21:58.848]                   }
[10:21:58.848]                   options(future.plan = NULL)
[10:21:58.848]                   if (is.na(NA_character_)) 
[10:21:58.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:58.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:58.848]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:58.848]                     .init = FALSE)
[10:21:58.848]                 }
[10:21:58.848]             }
[10:21:58.848]         }
[10:21:58.848]     })
[10:21:58.848]     if (TRUE) {
[10:21:58.848]         base::sink(type = "output", split = FALSE)
[10:21:58.848]         if (TRUE) {
[10:21:58.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:58.848]         }
[10:21:58.848]         else {
[10:21:58.848]             ...future.result["stdout"] <- base::list(NULL)
[10:21:58.848]         }
[10:21:58.848]         base::close(...future.stdout)
[10:21:58.848]         ...future.stdout <- NULL
[10:21:58.848]     }
[10:21:58.848]     ...future.result$conditions <- ...future.conditions
[10:21:58.848]     ...future.result$finished <- base::Sys.time()
[10:21:58.848]     ...future.result
[10:21:58.848] }
[10:21:58.851] MultisessionFuture started
[10:21:58.851] - Launch lazy future ... done
[10:21:58.851] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[10:21:58.852] result() for ClusterFuture ...
[10:21:58.852] receiveMessageFromWorker() for ClusterFuture ...
[10:21:58.852] - Validating connection of MultisessionFuture
[10:21:58.918] - received message: FutureResult
[10:21:58.918] - Received FutureResult
[10:21:58.919] - Erased future from FutureRegistry
[10:21:58.919] result() for ClusterFuture ...
[10:21:58.919] - result already collected: FutureResult
[10:21:58.919] result() for ClusterFuture ... done
[10:21:58.919] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:58.919] result() for ClusterFuture ... done
[10:21:58.919] result() for ClusterFuture ...
[10:21:58.919] - result already collected: FutureResult
[10:21:58.919] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger  (Mb) max used  (Mb)
Ncells 409681 21.9     912380  48.8   692222  37.0
Vcells 732466  5.6   13482749 102.9 15813665 120.7
> 
> message("*** multisession(..., gc = TRUE) ... TRUE")
*** multisession(..., gc = TRUE) ... TRUE
> 
> 
> message("*** multisession(...) - stopping with plan() change ...")
*** multisession(...) - stopping with plan() change ...
>   
> plan(multisession, workers = 2L)
[10:21:58.920] plan(): Setting new future strategy stack:
[10:21:58.920] List of future strategies:
[10:21:58.920] 1. multisession:
[10:21:58.920]    - args: function (..., workers = 2L, envir = parent.frame())
[10:21:58.920]    - tweaked: TRUE
[10:21:58.920]    - call: plan(multisession, workers = 2L)
[10:21:58.921] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:58.921] multisession:
[10:21:58.921] - args: function (..., workers = 2L, envir = parent.frame())
[10:21:58.921] - tweaked: TRUE
[10:21:58.921] - call: plan(multisession, workers = 2L)
[10:21:58.922] getGlobalsAndPackages() ...
[10:21:58.922] Not searching for globals
[10:21:58.922] - globals: [0] <none>
[10:21:58.922] getGlobalsAndPackages() ... DONE
[10:21:59.186] Packages needed by the future expression (n = 0): <none>
[10:21:59.186] Packages needed by future strategies (n = 0): <none>
[10:21:59.186] {
[10:21:59.186]     {
[10:21:59.186]         {
[10:21:59.186]             ...future.startTime <- base::Sys.time()
[10:21:59.186]             {
[10:21:59.186]                 {
[10:21:59.186]                   {
[10:21:59.186]                     {
[10:21:59.186]                       base::local({
[10:21:59.186]                         has_future <- base::requireNamespace("future", 
[10:21:59.186]                           quietly = TRUE)
[10:21:59.186]                         if (has_future) {
[10:21:59.186]                           ns <- base::getNamespace("future")
[10:21:59.186]                           version <- ns[[".package"]][["version"]]
[10:21:59.186]                           if (is.null(version)) 
[10:21:59.186]                             version <- utils::packageVersion("future")
[10:21:59.186]                         }
[10:21:59.186]                         else {
[10:21:59.186]                           version <- NULL
[10:21:59.186]                         }
[10:21:59.186]                         if (!has_future || version < "1.8.0") {
[10:21:59.186]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:59.186]                             "", base::R.version$version.string), 
[10:21:59.186]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:59.186]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:59.186]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:59.186]                               "release", "version")], collapse = " "), 
[10:21:59.186]                             hostname = base::Sys.info()[["nodename"]])
[10:21:59.186]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:59.186]                             info)
[10:21:59.186]                           info <- base::paste(info, collapse = "; ")
[10:21:59.186]                           if (!has_future) {
[10:21:59.186]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:59.186]                               info)
[10:21:59.186]                           }
[10:21:59.186]                           else {
[10:21:59.186]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:59.186]                               info, version)
[10:21:59.186]                           }
[10:21:59.186]                           base::stop(msg)
[10:21:59.186]                         }
[10:21:59.186]                       })
[10:21:59.186]                     }
[10:21:59.186]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:59.186]                     base::options(mc.cores = 1L)
[10:21:59.186]                   }
[10:21:59.186]                   ...future.strategy.old <- future::plan("list")
[10:21:59.186]                   options(future.plan = NULL)
[10:21:59.186]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:59.186]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:59.186]                 }
[10:21:59.186]                 ...future.workdir <- getwd()
[10:21:59.186]             }
[10:21:59.186]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:59.186]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:59.186]         }
[10:21:59.186]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:59.186]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:59.186]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:59.186]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:59.186]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:59.186]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:59.186]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:59.186]             base::names(...future.oldOptions))
[10:21:59.186]     }
[10:21:59.186]     if (FALSE) {
[10:21:59.186]     }
[10:21:59.186]     else {
[10:21:59.186]         if (TRUE) {
[10:21:59.186]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:59.186]                 open = "w")
[10:21:59.186]         }
[10:21:59.186]         else {
[10:21:59.186]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:59.186]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:59.186]         }
[10:21:59.186]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:59.186]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:59.186]             base::sink(type = "output", split = FALSE)
[10:21:59.186]             base::close(...future.stdout)
[10:21:59.186]         }, add = TRUE)
[10:21:59.186]     }
[10:21:59.186]     ...future.frame <- base::sys.nframe()
[10:21:59.186]     ...future.conditions <- base::list()
[10:21:59.186]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:59.186]     if (FALSE) {
[10:21:59.186]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:59.186]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:59.186]     }
[10:21:59.186]     ...future.result <- base::tryCatch({
[10:21:59.186]         base::withCallingHandlers({
[10:21:59.186]             ...future.value <- base::withVisible(base::local({
[10:21:59.186]                 ...future.makeSendCondition <- base::local({
[10:21:59.186]                   sendCondition <- NULL
[10:21:59.186]                   function(frame = 1L) {
[10:21:59.186]                     if (is.function(sendCondition)) 
[10:21:59.186]                       return(sendCondition)
[10:21:59.186]                     ns <- getNamespace("parallel")
[10:21:59.186]                     if (exists("sendData", mode = "function", 
[10:21:59.186]                       envir = ns)) {
[10:21:59.186]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:59.186]                         envir = ns)
[10:21:59.186]                       envir <- sys.frame(frame)
[10:21:59.186]                       master <- NULL
[10:21:59.186]                       while (!identical(envir, .GlobalEnv) && 
[10:21:59.186]                         !identical(envir, emptyenv())) {
[10:21:59.186]                         if (exists("master", mode = "list", envir = envir, 
[10:21:59.186]                           inherits = FALSE)) {
[10:21:59.186]                           master <- get("master", mode = "list", 
[10:21:59.186]                             envir = envir, inherits = FALSE)
[10:21:59.186]                           if (inherits(master, c("SOCKnode", 
[10:21:59.186]                             "SOCK0node"))) {
[10:21:59.186]                             sendCondition <<- function(cond) {
[10:21:59.186]                               data <- list(type = "VALUE", value = cond, 
[10:21:59.186]                                 success = TRUE)
[10:21:59.186]                               parallel_sendData(master, data)
[10:21:59.186]                             }
[10:21:59.186]                             return(sendCondition)
[10:21:59.186]                           }
[10:21:59.186]                         }
[10:21:59.186]                         frame <- frame + 1L
[10:21:59.186]                         envir <- sys.frame(frame)
[10:21:59.186]                       }
[10:21:59.186]                     }
[10:21:59.186]                     sendCondition <<- function(cond) NULL
[10:21:59.186]                   }
[10:21:59.186]                 })
[10:21:59.186]                 withCallingHandlers({
[10:21:59.186]                   NA
[10:21:59.186]                 }, immediateCondition = function(cond) {
[10:21:59.186]                   sendCondition <- ...future.makeSendCondition()
[10:21:59.186]                   sendCondition(cond)
[10:21:59.186]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:59.186]                   {
[10:21:59.186]                     inherits <- base::inherits
[10:21:59.186]                     invokeRestart <- base::invokeRestart
[10:21:59.186]                     is.null <- base::is.null
[10:21:59.186]                     muffled <- FALSE
[10:21:59.186]                     if (inherits(cond, "message")) {
[10:21:59.186]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:59.186]                       if (muffled) 
[10:21:59.186]                         invokeRestart("muffleMessage")
[10:21:59.186]                     }
[10:21:59.186]                     else if (inherits(cond, "warning")) {
[10:21:59.186]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:59.186]                       if (muffled) 
[10:21:59.186]                         invokeRestart("muffleWarning")
[10:21:59.186]                     }
[10:21:59.186]                     else if (inherits(cond, "condition")) {
[10:21:59.186]                       if (!is.null(pattern)) {
[10:21:59.186]                         computeRestarts <- base::computeRestarts
[10:21:59.186]                         grepl <- base::grepl
[10:21:59.186]                         restarts <- computeRestarts(cond)
[10:21:59.186]                         for (restart in restarts) {
[10:21:59.186]                           name <- restart$name
[10:21:59.186]                           if (is.null(name)) 
[10:21:59.186]                             next
[10:21:59.186]                           if (!grepl(pattern, name)) 
[10:21:59.186]                             next
[10:21:59.186]                           invokeRestart(restart)
[10:21:59.186]                           muffled <- TRUE
[10:21:59.186]                           break
[10:21:59.186]                         }
[10:21:59.186]                       }
[10:21:59.186]                     }
[10:21:59.186]                     invisible(muffled)
[10:21:59.186]                   }
[10:21:59.186]                   muffleCondition(cond)
[10:21:59.186]                 })
[10:21:59.186]             }))
[10:21:59.186]             future::FutureResult(value = ...future.value$value, 
[10:21:59.186]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:59.186]                   ...future.rng), globalenv = if (FALSE) 
[10:21:59.186]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:59.186]                     ...future.globalenv.names))
[10:21:59.186]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:59.186]         }, condition = base::local({
[10:21:59.186]             c <- base::c
[10:21:59.186]             inherits <- base::inherits
[10:21:59.186]             invokeRestart <- base::invokeRestart
[10:21:59.186]             length <- base::length
[10:21:59.186]             list <- base::list
[10:21:59.186]             seq.int <- base::seq.int
[10:21:59.186]             signalCondition <- base::signalCondition
[10:21:59.186]             sys.calls <- base::sys.calls
[10:21:59.186]             `[[` <- base::`[[`
[10:21:59.186]             `+` <- base::`+`
[10:21:59.186]             `<<-` <- base::`<<-`
[10:21:59.186]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:59.186]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:59.186]                   3L)]
[10:21:59.186]             }
[10:21:59.186]             function(cond) {
[10:21:59.186]                 is_error <- inherits(cond, "error")
[10:21:59.186]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:59.186]                   NULL)
[10:21:59.186]                 if (is_error) {
[10:21:59.186]                   sessionInformation <- function() {
[10:21:59.186]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:59.186]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:59.186]                       search = base::search(), system = base::Sys.info())
[10:21:59.186]                   }
[10:21:59.186]                   ...future.conditions[[length(...future.conditions) + 
[10:21:59.186]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:59.186]                     cond$call), session = sessionInformation(), 
[10:21:59.186]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:59.186]                   signalCondition(cond)
[10:21:59.186]                 }
[10:21:59.186]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:59.186]                 "immediateCondition"))) {
[10:21:59.186]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:59.186]                   ...future.conditions[[length(...future.conditions) + 
[10:21:59.186]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:59.186]                   if (TRUE && !signal) {
[10:21:59.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:59.186]                     {
[10:21:59.186]                       inherits <- base::inherits
[10:21:59.186]                       invokeRestart <- base::invokeRestart
[10:21:59.186]                       is.null <- base::is.null
[10:21:59.186]                       muffled <- FALSE
[10:21:59.186]                       if (inherits(cond, "message")) {
[10:21:59.186]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:59.186]                         if (muffled) 
[10:21:59.186]                           invokeRestart("muffleMessage")
[10:21:59.186]                       }
[10:21:59.186]                       else if (inherits(cond, "warning")) {
[10:21:59.186]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:59.186]                         if (muffled) 
[10:21:59.186]                           invokeRestart("muffleWarning")
[10:21:59.186]                       }
[10:21:59.186]                       else if (inherits(cond, "condition")) {
[10:21:59.186]                         if (!is.null(pattern)) {
[10:21:59.186]                           computeRestarts <- base::computeRestarts
[10:21:59.186]                           grepl <- base::grepl
[10:21:59.186]                           restarts <- computeRestarts(cond)
[10:21:59.186]                           for (restart in restarts) {
[10:21:59.186]                             name <- restart$name
[10:21:59.186]                             if (is.null(name)) 
[10:21:59.186]                               next
[10:21:59.186]                             if (!grepl(pattern, name)) 
[10:21:59.186]                               next
[10:21:59.186]                             invokeRestart(restart)
[10:21:59.186]                             muffled <- TRUE
[10:21:59.186]                             break
[10:21:59.186]                           }
[10:21:59.186]                         }
[10:21:59.186]                       }
[10:21:59.186]                       invisible(muffled)
[10:21:59.186]                     }
[10:21:59.186]                     muffleCondition(cond, pattern = "^muffle")
[10:21:59.186]                   }
[10:21:59.186]                 }
[10:21:59.186]                 else {
[10:21:59.186]                   if (TRUE) {
[10:21:59.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:59.186]                     {
[10:21:59.186]                       inherits <- base::inherits
[10:21:59.186]                       invokeRestart <- base::invokeRestart
[10:21:59.186]                       is.null <- base::is.null
[10:21:59.186]                       muffled <- FALSE
[10:21:59.186]                       if (inherits(cond, "message")) {
[10:21:59.186]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:59.186]                         if (muffled) 
[10:21:59.186]                           invokeRestart("muffleMessage")
[10:21:59.186]                       }
[10:21:59.186]                       else if (inherits(cond, "warning")) {
[10:21:59.186]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:59.186]                         if (muffled) 
[10:21:59.186]                           invokeRestart("muffleWarning")
[10:21:59.186]                       }
[10:21:59.186]                       else if (inherits(cond, "condition")) {
[10:21:59.186]                         if (!is.null(pattern)) {
[10:21:59.186]                           computeRestarts <- base::computeRestarts
[10:21:59.186]                           grepl <- base::grepl
[10:21:59.186]                           restarts <- computeRestarts(cond)
[10:21:59.186]                           for (restart in restarts) {
[10:21:59.186]                             name <- restart$name
[10:21:59.186]                             if (is.null(name)) 
[10:21:59.186]                               next
[10:21:59.186]                             if (!grepl(pattern, name)) 
[10:21:59.186]                               next
[10:21:59.186]                             invokeRestart(restart)
[10:21:59.186]                             muffled <- TRUE
[10:21:59.186]                             break
[10:21:59.186]                           }
[10:21:59.186]                         }
[10:21:59.186]                       }
[10:21:59.186]                       invisible(muffled)
[10:21:59.186]                     }
[10:21:59.186]                     muffleCondition(cond, pattern = "^muffle")
[10:21:59.186]                   }
[10:21:59.186]                 }
[10:21:59.186]             }
[10:21:59.186]         }))
[10:21:59.186]     }, error = function(ex) {
[10:21:59.186]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:59.186]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:59.186]                 ...future.rng), started = ...future.startTime, 
[10:21:59.186]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:59.186]             version = "1.8"), class = "FutureResult")
[10:21:59.186]     }, finally = {
[10:21:59.186]         if (!identical(...future.workdir, getwd())) 
[10:21:59.186]             setwd(...future.workdir)
[10:21:59.186]         {
[10:21:59.186]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:59.186]                 ...future.oldOptions$nwarnings <- NULL
[10:21:59.186]             }
[10:21:59.186]             base::options(...future.oldOptions)
[10:21:59.186]             if (.Platform$OS.type == "windows") {
[10:21:59.186]                 old_names <- names(...future.oldEnvVars)
[10:21:59.186]                 envs <- base::Sys.getenv()
[10:21:59.186]                 names <- names(envs)
[10:21:59.186]                 common <- intersect(names, old_names)
[10:21:59.186]                 added <- setdiff(names, old_names)
[10:21:59.186]                 removed <- setdiff(old_names, names)
[10:21:59.186]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:59.186]                   envs[common]]
[10:21:59.186]                 NAMES <- toupper(changed)
[10:21:59.186]                 args <- list()
[10:21:59.186]                 for (kk in seq_along(NAMES)) {
[10:21:59.186]                   name <- changed[[kk]]
[10:21:59.186]                   NAME <- NAMES[[kk]]
[10:21:59.186]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:59.186]                     next
[10:21:59.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:59.186]                 }
[10:21:59.186]                 NAMES <- toupper(added)
[10:21:59.186]                 for (kk in seq_along(NAMES)) {
[10:21:59.186]                   name <- added[[kk]]
[10:21:59.186]                   NAME <- NAMES[[kk]]
[10:21:59.186]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:59.186]                     next
[10:21:59.186]                   args[[name]] <- ""
[10:21:59.186]                 }
[10:21:59.186]                 NAMES <- toupper(removed)
[10:21:59.186]                 for (kk in seq_along(NAMES)) {
[10:21:59.186]                   name <- removed[[kk]]
[10:21:59.186]                   NAME <- NAMES[[kk]]
[10:21:59.186]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:59.186]                     next
[10:21:59.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:59.186]                 }
[10:21:59.186]                 if (length(args) > 0) 
[10:21:59.186]                   base::do.call(base::Sys.setenv, args = args)
[10:21:59.186]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:59.186]             }
[10:21:59.186]             else {
[10:21:59.186]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:59.186]             }
[10:21:59.186]             {
[10:21:59.186]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:59.186]                   0L) {
[10:21:59.186]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:59.186]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:59.186]                   base::options(opts)
[10:21:59.186]                 }
[10:21:59.186]                 {
[10:21:59.186]                   {
[10:21:59.186]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:59.186]                     NULL
[10:21:59.186]                   }
[10:21:59.186]                   options(future.plan = NULL)
[10:21:59.186]                   if (is.na(NA_character_)) 
[10:21:59.186]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:59.186]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:59.186]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:59.186]                     .init = FALSE)
[10:21:59.186]                 }
[10:21:59.186]             }
[10:21:59.186]         }
[10:21:59.186]     })
[10:21:59.186]     if (TRUE) {
[10:21:59.186]         base::sink(type = "output", split = FALSE)
[10:21:59.186]         if (TRUE) {
[10:21:59.186]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:59.186]         }
[10:21:59.186]         else {
[10:21:59.186]             ...future.result["stdout"] <- base::list(NULL)
[10:21:59.186]         }
[10:21:59.186]         base::close(...future.stdout)
[10:21:59.186]         ...future.stdout <- NULL
[10:21:59.186]     }
[10:21:59.186]     ...future.result$conditions <- ...future.conditions
[10:21:59.186]     ...future.result$finished <- base::Sys.time()
[10:21:59.186]     ...future.result
[10:21:59.186] }
[10:21:59.238] MultisessionFuture started
[10:21:59.238] result() for ClusterFuture ...
[10:21:59.239] receiveMessageFromWorker() for ClusterFuture ...
[10:21:59.239] - Validating connection of MultisessionFuture
[10:21:59.269] - received message: FutureResult
[10:21:59.269] - Received FutureResult
[10:21:59.270] - Erased future from FutureRegistry
[10:21:59.270] result() for ClusterFuture ...
[10:21:59.270] - result already collected: FutureResult
[10:21:59.270] result() for ClusterFuture ... done
[10:21:59.270] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:59.270] result() for ClusterFuture ... done
[10:21:59.270] result() for ClusterFuture ...
[10:21:59.270] - result already collected: FutureResult
[10:21:59.270] result() for ClusterFuture ... done
[10:21:59.270] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:59.271] plan(): nbrOfWorkers() = 2
> f <- future(1L)
[10:21:59.271] getGlobalsAndPackages() ...
[10:21:59.271] Searching for globals...
[10:21:59.271] 
[10:21:59.271] Searching for globals ... DONE
[10:21:59.271] - globals: [0] <none>
[10:21:59.272] getGlobalsAndPackages() ... DONE
[10:21:59.272] run() for ‘Future’ ...
[10:21:59.272] - state: ‘created’
[10:21:59.272] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:59.286] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:59.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:59.286]   - Field: ‘node’
[10:21:59.287]   - Field: ‘label’
[10:21:59.287]   - Field: ‘local’
[10:21:59.287]   - Field: ‘owner’
[10:21:59.287]   - Field: ‘envir’
[10:21:59.287]   - Field: ‘workers’
[10:21:59.287]   - Field: ‘packages’
[10:21:59.287]   - Field: ‘gc’
[10:21:59.287]   - Field: ‘conditions’
[10:21:59.287]   - Field: ‘persistent’
[10:21:59.287]   - Field: ‘expr’
[10:21:59.287]   - Field: ‘uuid’
[10:21:59.288]   - Field: ‘seed’
[10:21:59.288]   - Field: ‘version’
[10:21:59.288]   - Field: ‘result’
[10:21:59.288]   - Field: ‘asynchronous’
[10:21:59.288]   - Field: ‘calls’
[10:21:59.288]   - Field: ‘globals’
[10:21:59.288]   - Field: ‘stdout’
[10:21:59.288]   - Field: ‘earlySignal’
[10:21:59.288]   - Field: ‘lazy’
[10:21:59.288]   - Field: ‘state’
[10:21:59.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:59.289] - Launch lazy future ...
[10:21:59.289] Packages needed by the future expression (n = 0): <none>
[10:21:59.289] Packages needed by future strategies (n = 0): <none>
[10:21:59.289] {
[10:21:59.289]     {
[10:21:59.289]         {
[10:21:59.289]             ...future.startTime <- base::Sys.time()
[10:21:59.289]             {
[10:21:59.289]                 {
[10:21:59.289]                   {
[10:21:59.289]                     {
[10:21:59.289]                       base::local({
[10:21:59.289]                         has_future <- base::requireNamespace("future", 
[10:21:59.289]                           quietly = TRUE)
[10:21:59.289]                         if (has_future) {
[10:21:59.289]                           ns <- base::getNamespace("future")
[10:21:59.289]                           version <- ns[[".package"]][["version"]]
[10:21:59.289]                           if (is.null(version)) 
[10:21:59.289]                             version <- utils::packageVersion("future")
[10:21:59.289]                         }
[10:21:59.289]                         else {
[10:21:59.289]                           version <- NULL
[10:21:59.289]                         }
[10:21:59.289]                         if (!has_future || version < "1.8.0") {
[10:21:59.289]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:59.289]                             "", base::R.version$version.string), 
[10:21:59.289]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:59.289]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:59.289]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:59.289]                               "release", "version")], collapse = " "), 
[10:21:59.289]                             hostname = base::Sys.info()[["nodename"]])
[10:21:59.289]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:59.289]                             info)
[10:21:59.289]                           info <- base::paste(info, collapse = "; ")
[10:21:59.289]                           if (!has_future) {
[10:21:59.289]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:59.289]                               info)
[10:21:59.289]                           }
[10:21:59.289]                           else {
[10:21:59.289]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:59.289]                               info, version)
[10:21:59.289]                           }
[10:21:59.289]                           base::stop(msg)
[10:21:59.289]                         }
[10:21:59.289]                       })
[10:21:59.289]                     }
[10:21:59.289]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:59.289]                     base::options(mc.cores = 1L)
[10:21:59.289]                   }
[10:21:59.289]                   ...future.strategy.old <- future::plan("list")
[10:21:59.289]                   options(future.plan = NULL)
[10:21:59.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:59.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:59.289]                 }
[10:21:59.289]                 ...future.workdir <- getwd()
[10:21:59.289]             }
[10:21:59.289]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:59.289]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:59.289]         }
[10:21:59.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:59.289]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:59.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:59.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:59.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:59.289]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:59.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:59.289]             base::names(...future.oldOptions))
[10:21:59.289]     }
[10:21:59.289]     if (FALSE) {
[10:21:59.289]     }
[10:21:59.289]     else {
[10:21:59.289]         if (TRUE) {
[10:21:59.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:59.289]                 open = "w")
[10:21:59.289]         }
[10:21:59.289]         else {
[10:21:59.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:59.289]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:59.289]         }
[10:21:59.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:59.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:59.289]             base::sink(type = "output", split = FALSE)
[10:21:59.289]             base::close(...future.stdout)
[10:21:59.289]         }, add = TRUE)
[10:21:59.289]     }
[10:21:59.289]     ...future.frame <- base::sys.nframe()
[10:21:59.289]     ...future.conditions <- base::list()
[10:21:59.289]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:59.289]     if (FALSE) {
[10:21:59.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:59.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:59.289]     }
[10:21:59.289]     ...future.result <- base::tryCatch({
[10:21:59.289]         base::withCallingHandlers({
[10:21:59.289]             ...future.value <- base::withVisible(base::local({
[10:21:59.289]                 ...future.makeSendCondition <- base::local({
[10:21:59.289]                   sendCondition <- NULL
[10:21:59.289]                   function(frame = 1L) {
[10:21:59.289]                     if (is.function(sendCondition)) 
[10:21:59.289]                       return(sendCondition)
[10:21:59.289]                     ns <- getNamespace("parallel")
[10:21:59.289]                     if (exists("sendData", mode = "function", 
[10:21:59.289]                       envir = ns)) {
[10:21:59.289]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:59.289]                         envir = ns)
[10:21:59.289]                       envir <- sys.frame(frame)
[10:21:59.289]                       master <- NULL
[10:21:59.289]                       while (!identical(envir, .GlobalEnv) && 
[10:21:59.289]                         !identical(envir, emptyenv())) {
[10:21:59.289]                         if (exists("master", mode = "list", envir = envir, 
[10:21:59.289]                           inherits = FALSE)) {
[10:21:59.289]                           master <- get("master", mode = "list", 
[10:21:59.289]                             envir = envir, inherits = FALSE)
[10:21:59.289]                           if (inherits(master, c("SOCKnode", 
[10:21:59.289]                             "SOCK0node"))) {
[10:21:59.289]                             sendCondition <<- function(cond) {
[10:21:59.289]                               data <- list(type = "VALUE", value = cond, 
[10:21:59.289]                                 success = TRUE)
[10:21:59.289]                               parallel_sendData(master, data)
[10:21:59.289]                             }
[10:21:59.289]                             return(sendCondition)
[10:21:59.289]                           }
[10:21:59.289]                         }
[10:21:59.289]                         frame <- frame + 1L
[10:21:59.289]                         envir <- sys.frame(frame)
[10:21:59.289]                       }
[10:21:59.289]                     }
[10:21:59.289]                     sendCondition <<- function(cond) NULL
[10:21:59.289]                   }
[10:21:59.289]                 })
[10:21:59.289]                 withCallingHandlers({
[10:21:59.289]                   1L
[10:21:59.289]                 }, immediateCondition = function(cond) {
[10:21:59.289]                   sendCondition <- ...future.makeSendCondition()
[10:21:59.289]                   sendCondition(cond)
[10:21:59.289]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:59.289]                   {
[10:21:59.289]                     inherits <- base::inherits
[10:21:59.289]                     invokeRestart <- base::invokeRestart
[10:21:59.289]                     is.null <- base::is.null
[10:21:59.289]                     muffled <- FALSE
[10:21:59.289]                     if (inherits(cond, "message")) {
[10:21:59.289]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:59.289]                       if (muffled) 
[10:21:59.289]                         invokeRestart("muffleMessage")
[10:21:59.289]                     }
[10:21:59.289]                     else if (inherits(cond, "warning")) {
[10:21:59.289]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:59.289]                       if (muffled) 
[10:21:59.289]                         invokeRestart("muffleWarning")
[10:21:59.289]                     }
[10:21:59.289]                     else if (inherits(cond, "condition")) {
[10:21:59.289]                       if (!is.null(pattern)) {
[10:21:59.289]                         computeRestarts <- base::computeRestarts
[10:21:59.289]                         grepl <- base::grepl
[10:21:59.289]                         restarts <- computeRestarts(cond)
[10:21:59.289]                         for (restart in restarts) {
[10:21:59.289]                           name <- restart$name
[10:21:59.289]                           if (is.null(name)) 
[10:21:59.289]                             next
[10:21:59.289]                           if (!grepl(pattern, name)) 
[10:21:59.289]                             next
[10:21:59.289]                           invokeRestart(restart)
[10:21:59.289]                           muffled <- TRUE
[10:21:59.289]                           break
[10:21:59.289]                         }
[10:21:59.289]                       }
[10:21:59.289]                     }
[10:21:59.289]                     invisible(muffled)
[10:21:59.289]                   }
[10:21:59.289]                   muffleCondition(cond)
[10:21:59.289]                 })
[10:21:59.289]             }))
[10:21:59.289]             future::FutureResult(value = ...future.value$value, 
[10:21:59.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:59.289]                   ...future.rng), globalenv = if (FALSE) 
[10:21:59.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:59.289]                     ...future.globalenv.names))
[10:21:59.289]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:59.289]         }, condition = base::local({
[10:21:59.289]             c <- base::c
[10:21:59.289]             inherits <- base::inherits
[10:21:59.289]             invokeRestart <- base::invokeRestart
[10:21:59.289]             length <- base::length
[10:21:59.289]             list <- base::list
[10:21:59.289]             seq.int <- base::seq.int
[10:21:59.289]             signalCondition <- base::signalCondition
[10:21:59.289]             sys.calls <- base::sys.calls
[10:21:59.289]             `[[` <- base::`[[`
[10:21:59.289]             `+` <- base::`+`
[10:21:59.289]             `<<-` <- base::`<<-`
[10:21:59.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:59.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:59.289]                   3L)]
[10:21:59.289]             }
[10:21:59.289]             function(cond) {
[10:21:59.289]                 is_error <- inherits(cond, "error")
[10:21:59.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:59.289]                   NULL)
[10:21:59.289]                 if (is_error) {
[10:21:59.289]                   sessionInformation <- function() {
[10:21:59.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:59.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:59.289]                       search = base::search(), system = base::Sys.info())
[10:21:59.289]                   }
[10:21:59.289]                   ...future.conditions[[length(...future.conditions) + 
[10:21:59.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:59.289]                     cond$call), session = sessionInformation(), 
[10:21:59.289]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:59.289]                   signalCondition(cond)
[10:21:59.289]                 }
[10:21:59.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:59.289]                 "immediateCondition"))) {
[10:21:59.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:59.289]                   ...future.conditions[[length(...future.conditions) + 
[10:21:59.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:59.289]                   if (TRUE && !signal) {
[10:21:59.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:59.289]                     {
[10:21:59.289]                       inherits <- base::inherits
[10:21:59.289]                       invokeRestart <- base::invokeRestart
[10:21:59.289]                       is.null <- base::is.null
[10:21:59.289]                       muffled <- FALSE
[10:21:59.289]                       if (inherits(cond, "message")) {
[10:21:59.289]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:59.289]                         if (muffled) 
[10:21:59.289]                           invokeRestart("muffleMessage")
[10:21:59.289]                       }
[10:21:59.289]                       else if (inherits(cond, "warning")) {
[10:21:59.289]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:59.289]                         if (muffled) 
[10:21:59.289]                           invokeRestart("muffleWarning")
[10:21:59.289]                       }
[10:21:59.289]                       else if (inherits(cond, "condition")) {
[10:21:59.289]                         if (!is.null(pattern)) {
[10:21:59.289]                           computeRestarts <- base::computeRestarts
[10:21:59.289]                           grepl <- base::grepl
[10:21:59.289]                           restarts <- computeRestarts(cond)
[10:21:59.289]                           for (restart in restarts) {
[10:21:59.289]                             name <- restart$name
[10:21:59.289]                             if (is.null(name)) 
[10:21:59.289]                               next
[10:21:59.289]                             if (!grepl(pattern, name)) 
[10:21:59.289]                               next
[10:21:59.289]                             invokeRestart(restart)
[10:21:59.289]                             muffled <- TRUE
[10:21:59.289]                             break
[10:21:59.289]                           }
[10:21:59.289]                         }
[10:21:59.289]                       }
[10:21:59.289]                       invisible(muffled)
[10:21:59.289]                     }
[10:21:59.289]                     muffleCondition(cond, pattern = "^muffle")
[10:21:59.289]                   }
[10:21:59.289]                 }
[10:21:59.289]                 else {
[10:21:59.289]                   if (TRUE) {
[10:21:59.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:59.289]                     {
[10:21:59.289]                       inherits <- base::inherits
[10:21:59.289]                       invokeRestart <- base::invokeRestart
[10:21:59.289]                       is.null <- base::is.null
[10:21:59.289]                       muffled <- FALSE
[10:21:59.289]                       if (inherits(cond, "message")) {
[10:21:59.289]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:59.289]                         if (muffled) 
[10:21:59.289]                           invokeRestart("muffleMessage")
[10:21:59.289]                       }
[10:21:59.289]                       else if (inherits(cond, "warning")) {
[10:21:59.289]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:59.289]                         if (muffled) 
[10:21:59.289]                           invokeRestart("muffleWarning")
[10:21:59.289]                       }
[10:21:59.289]                       else if (inherits(cond, "condition")) {
[10:21:59.289]                         if (!is.null(pattern)) {
[10:21:59.289]                           computeRestarts <- base::computeRestarts
[10:21:59.289]                           grepl <- base::grepl
[10:21:59.289]                           restarts <- computeRestarts(cond)
[10:21:59.289]                           for (restart in restarts) {
[10:21:59.289]                             name <- restart$name
[10:21:59.289]                             if (is.null(name)) 
[10:21:59.289]                               next
[10:21:59.289]                             if (!grepl(pattern, name)) 
[10:21:59.289]                               next
[10:21:59.289]                             invokeRestart(restart)
[10:21:59.289]                             muffled <- TRUE
[10:21:59.289]                             break
[10:21:59.289]                           }
[10:21:59.289]                         }
[10:21:59.289]                       }
[10:21:59.289]                       invisible(muffled)
[10:21:59.289]                     }
[10:21:59.289]                     muffleCondition(cond, pattern = "^muffle")
[10:21:59.289]                   }
[10:21:59.289]                 }
[10:21:59.289]             }
[10:21:59.289]         }))
[10:21:59.289]     }, error = function(ex) {
[10:21:59.289]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:59.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:59.289]                 ...future.rng), started = ...future.startTime, 
[10:21:59.289]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:59.289]             version = "1.8"), class = "FutureResult")
[10:21:59.289]     }, finally = {
[10:21:59.289]         if (!identical(...future.workdir, getwd())) 
[10:21:59.289]             setwd(...future.workdir)
[10:21:59.289]         {
[10:21:59.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:59.289]                 ...future.oldOptions$nwarnings <- NULL
[10:21:59.289]             }
[10:21:59.289]             base::options(...future.oldOptions)
[10:21:59.289]             if (.Platform$OS.type == "windows") {
[10:21:59.289]                 old_names <- names(...future.oldEnvVars)
[10:21:59.289]                 envs <- base::Sys.getenv()
[10:21:59.289]                 names <- names(envs)
[10:21:59.289]                 common <- intersect(names, old_names)
[10:21:59.289]                 added <- setdiff(names, old_names)
[10:21:59.289]                 removed <- setdiff(old_names, names)
[10:21:59.289]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:59.289]                   envs[common]]
[10:21:59.289]                 NAMES <- toupper(changed)
[10:21:59.289]                 args <- list()
[10:21:59.289]                 for (kk in seq_along(NAMES)) {
[10:21:59.289]                   name <- changed[[kk]]
[10:21:59.289]                   NAME <- NAMES[[kk]]
[10:21:59.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:59.289]                     next
[10:21:59.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:59.289]                 }
[10:21:59.289]                 NAMES <- toupper(added)
[10:21:59.289]                 for (kk in seq_along(NAMES)) {
[10:21:59.289]                   name <- added[[kk]]
[10:21:59.289]                   NAME <- NAMES[[kk]]
[10:21:59.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:59.289]                     next
[10:21:59.289]                   args[[name]] <- ""
[10:21:59.289]                 }
[10:21:59.289]                 NAMES <- toupper(removed)
[10:21:59.289]                 for (kk in seq_along(NAMES)) {
[10:21:59.289]                   name <- removed[[kk]]
[10:21:59.289]                   NAME <- NAMES[[kk]]
[10:21:59.289]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:59.289]                     next
[10:21:59.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:59.289]                 }
[10:21:59.289]                 if (length(args) > 0) 
[10:21:59.289]                   base::do.call(base::Sys.setenv, args = args)
[10:21:59.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:59.289]             }
[10:21:59.289]             else {
[10:21:59.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:59.289]             }
[10:21:59.289]             {
[10:21:59.289]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:59.289]                   0L) {
[10:21:59.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:59.289]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:59.289]                   base::options(opts)
[10:21:59.289]                 }
[10:21:59.289]                 {
[10:21:59.289]                   {
[10:21:59.289]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:59.289]                     NULL
[10:21:59.289]                   }
[10:21:59.289]                   options(future.plan = NULL)
[10:21:59.289]                   if (is.na(NA_character_)) 
[10:21:59.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:59.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:59.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:59.289]                     .init = FALSE)
[10:21:59.289]                 }
[10:21:59.289]             }
[10:21:59.289]         }
[10:21:59.289]     })
[10:21:59.289]     if (TRUE) {
[10:21:59.289]         base::sink(type = "output", split = FALSE)
[10:21:59.289]         if (TRUE) {
[10:21:59.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:59.289]         }
[10:21:59.289]         else {
[10:21:59.289]             ...future.result["stdout"] <- base::list(NULL)
[10:21:59.289]         }
[10:21:59.289]         base::close(...future.stdout)
[10:21:59.289]         ...future.stdout <- NULL
[10:21:59.289]     }
[10:21:59.289]     ...future.result$conditions <- ...future.conditions
[10:21:59.289]     ...future.result$finished <- base::Sys.time()
[10:21:59.289]     ...future.result
[10:21:59.289] }
[10:21:59.292] MultisessionFuture started
[10:21:59.292] - Launch lazy future ... done
[10:21:59.293] run() for ‘MultisessionFuture’ ... done
> 
> ## Collect value, to speep up the stopping of the parallel workers,
> ## and to make sure we're not leaving any stray processes behind.
> v <- value(f)
[10:21:59.293] result() for ClusterFuture ...
[10:21:59.293] receiveMessageFromWorker() for ClusterFuture ...
[10:21:59.293] - Validating connection of MultisessionFuture
[10:21:59.334] - received message: FutureResult
[10:21:59.334] - Received FutureResult
[10:21:59.334] - Erased future from FutureRegistry
[10:21:59.334] result() for ClusterFuture ...
[10:21:59.334] - result already collected: FutureResult
[10:21:59.334] result() for ClusterFuture ... done
[10:21:59.334] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:59.335] result() for ClusterFuture ... done
[10:21:59.335] result() for ClusterFuture ...
[10:21:59.335] - result already collected: FutureResult
[10:21:59.335] result() for ClusterFuture ... done
> 
> cl <- ClusterRegistry("get")
> stopifnot(inherits(cl, "cluster"), length(cl) >= 1L)
> 
> plan(sequential)
[10:21:59.335] plan(): Setting new future strategy stack:
[10:21:59.335] List of future strategies:
[10:21:59.335] 1. sequential:
[10:21:59.335]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:59.335]    - tweaked: FALSE
[10:21:59.335]    - call: plan(sequential)
[10:21:59.336] plan(): nbrOfWorkers() = 1
> cl <- ClusterRegistry("get")
> stopifnot(is.null(cl), length(cl) == 0L)
>   
> message("*** multisession(...) - stopping with plan() change ... DONE")
*** multisession(...) - stopping with plan() change ... DONE
> 
> message("*** multisession() ... DONE")
*** multisession() ... DONE
> 
> source("incl/end.R")
[10:21:59.337] plan(): Setting new future strategy stack:
[10:21:59.337] List of future strategies:
[10:21:59.337] 1. FutureStrategy:
[10:21:59.337]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:59.337]    - tweaked: FALSE
[10:21:59.337]    - call: future::plan(oplan)
[10:21:59.338] plan(): nbrOfWorkers() = 1
> 
