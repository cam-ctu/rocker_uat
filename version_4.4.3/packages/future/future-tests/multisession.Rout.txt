
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:02:05.273] plan(): Setting new future strategy stack:
[11:02:05.273] List of future strategies:
[11:02:05.273] 1. sequential:
[11:02:05.273]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.273]    - tweaked: FALSE
[11:02:05.273]    - call: future::plan("sequential")
[11:02:05.287] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** multisession() ...")
*** multisession() ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   ## No global variables
+   f <- multisession({
+     42L
+   })
+   print(f)
+   stopifnot(inherits(f, "ClusterFuture") || (inherits(f, "SequentialFuture") && f$lazy))
+ 
+   print(resolved(f))
+   y <- value(f)
+   print(y)
+   stopifnot(y == 42L)
+ 
+ 
+   ## A global variable
+   a <- 0
+   f <- multisession({
+     b <- 3
+     c <- 2
+     a * b * c
+   }, globals = TRUE)
+   print(f)
+ 
+ 
+   ## A multisession future is evaluated in a separate
+   ## R session process.  Changing the value of a global
+   ## variable should not affect the result of the
+   ## future.
+   a <- 7  ## Make sure globals are frozen
+   v <- value(f)
+   print(v)
+   stopifnot(v == 0)
+ 
+ 
+   message("*** multisession() with globals and blocking")
+   x <- listenv()
+   for (ii in 2:1) {
+     message(sprintf(" - Creating multisession future #%d ...", ii))
+     x[[ii]] <- multisession({ ii }, globals = TRUE)
+   }
+   message(sprintf(" - Resolving %d multisession futures", length(x)))
+   v <- sapply(x, FUN = value)
+   stopifnot(all(v == 1:2))
+ 
+ 
+   message("*** multisession() - workers inherit .libPaths()")
+ 
+   libs <- value(future(.libPaths()))
+   str(list(
+     main = .libPaths(),
+     workers = libs
+   ))
+   stopifnot(identical(libs, .libPaths()))
+ 
+   message("*** multisession() and errors")
+   f <- multisession({
+     stop("Whoops!")
+     1
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "simpleError"))
+ 
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Error is repeated
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Custom error class
+   f <- multisession({
+     stop(structure(list(message = "boom"),
+                    class = c("MyError", "error", "condition")))
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+ 
+   ## Make sure error is signaled
+   res <- tryCatch(value(f), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   ## Issue #200: Custom condition class attributes are lost
+   ## https://github.com/HenrikBengtsson/Wishlist-for-R/issues/57
+   ## stopifnot(inherits(res, "MyError"))    
+ 
+   ## Make sure to stop these cluster processes to avoid triggering
+   ## checking for detritus in the temp directory ... NOTE
+   ClusterRegistry(action = "stop")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
[11:02:05.340] getGlobalsAndPackages() ...
[11:02:05.340] Searching for globals...
[11:02:05.343] - globals found: [1] ‘{’
[11:02:05.343] Searching for globals ... DONE
[11:02:05.343] Resolving globals: FALSE
[11:02:05.343] 
[11:02:05.343] 
[11:02:05.344] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d252f3dd-7a92-6ee4-db84-2a586bbc6302
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:05.345] Packages needed by the future expression (n = 0): <none>
[11:02:05.345] Packages needed by future strategies (n = 0): <none>
[11:02:05.346] {
[11:02:05.346]     {
[11:02:05.346]         {
[11:02:05.346]             ...future.startTime <- base::Sys.time()
[11:02:05.346]             {
[11:02:05.346]                 {
[11:02:05.346]                   {
[11:02:05.346]                     base::local({
[11:02:05.346]                       has_future <- base::requireNamespace("future", 
[11:02:05.346]                         quietly = TRUE)
[11:02:05.346]                       if (has_future) {
[11:02:05.346]                         ns <- base::getNamespace("future")
[11:02:05.346]                         version <- ns[[".package"]][["version"]]
[11:02:05.346]                         if (is.null(version)) 
[11:02:05.346]                           version <- utils::packageVersion("future")
[11:02:05.346]                       }
[11:02:05.346]                       else {
[11:02:05.346]                         version <- NULL
[11:02:05.346]                       }
[11:02:05.346]                       if (!has_future || version < "1.8.0") {
[11:02:05.346]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:05.346]                           "", base::R.version$version.string), 
[11:02:05.346]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:05.346]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:05.346]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:05.346]                             "release", "version")], collapse = " "), 
[11:02:05.346]                           hostname = base::Sys.info()[["nodename"]])
[11:02:05.346]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:05.346]                           info)
[11:02:05.346]                         info <- base::paste(info, collapse = "; ")
[11:02:05.346]                         if (!has_future) {
[11:02:05.346]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:05.346]                             info)
[11:02:05.346]                         }
[11:02:05.346]                         else {
[11:02:05.346]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:05.346]                             info, version)
[11:02:05.346]                         }
[11:02:05.346]                         base::stop(msg)
[11:02:05.346]                       }
[11:02:05.346]                     })
[11:02:05.346]                   }
[11:02:05.346]                   ...future.strategy.old <- future::plan("list")
[11:02:05.346]                   options(future.plan = NULL)
[11:02:05.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:05.346]                 }
[11:02:05.346]                 ...future.workdir <- getwd()
[11:02:05.346]             }
[11:02:05.346]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:05.346]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:05.346]         }
[11:02:05.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:05.346]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:05.346]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:05.346]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:05.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:05.346]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:05.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:05.346]             base::names(...future.oldOptions))
[11:02:05.346]     }
[11:02:05.346]     if (FALSE) {
[11:02:05.346]     }
[11:02:05.346]     else {
[11:02:05.346]         if (TRUE) {
[11:02:05.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:05.346]                 open = "w")
[11:02:05.346]         }
[11:02:05.346]         else {
[11:02:05.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:05.346]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:05.346]         }
[11:02:05.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:05.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:05.346]             base::sink(type = "output", split = FALSE)
[11:02:05.346]             base::close(...future.stdout)
[11:02:05.346]         }, add = TRUE)
[11:02:05.346]     }
[11:02:05.346]     ...future.frame <- base::sys.nframe()
[11:02:05.346]     ...future.conditions <- base::list()
[11:02:05.346]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:05.346]     if (FALSE) {
[11:02:05.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:05.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:05.346]     }
[11:02:05.346]     ...future.result <- base::tryCatch({
[11:02:05.346]         base::withCallingHandlers({
[11:02:05.346]             ...future.value <- base::withVisible(base::local({
[11:02:05.346]                 42L
[11:02:05.346]             }))
[11:02:05.346]             future::FutureResult(value = ...future.value$value, 
[11:02:05.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.346]                   ...future.rng), globalenv = if (FALSE) 
[11:02:05.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:05.346]                     ...future.globalenv.names))
[11:02:05.346]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:05.346]         }, condition = base::local({
[11:02:05.346]             c <- base::c
[11:02:05.346]             inherits <- base::inherits
[11:02:05.346]             invokeRestart <- base::invokeRestart
[11:02:05.346]             length <- base::length
[11:02:05.346]             list <- base::list
[11:02:05.346]             seq.int <- base::seq.int
[11:02:05.346]             signalCondition <- base::signalCondition
[11:02:05.346]             sys.calls <- base::sys.calls
[11:02:05.346]             `[[` <- base::`[[`
[11:02:05.346]             `+` <- base::`+`
[11:02:05.346]             `<<-` <- base::`<<-`
[11:02:05.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:05.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:05.346]                   3L)]
[11:02:05.346]             }
[11:02:05.346]             function(cond) {
[11:02:05.346]                 is_error <- inherits(cond, "error")
[11:02:05.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:05.346]                   NULL)
[11:02:05.346]                 if (is_error) {
[11:02:05.346]                   sessionInformation <- function() {
[11:02:05.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:05.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:05.346]                       search = base::search(), system = base::Sys.info())
[11:02:05.346]                   }
[11:02:05.346]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:05.346]                     cond$call), session = sessionInformation(), 
[11:02:05.346]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:05.346]                   signalCondition(cond)
[11:02:05.346]                 }
[11:02:05.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:05.346]                 "immediateCondition"))) {
[11:02:05.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:05.346]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:05.346]                   if (TRUE && !signal) {
[11:02:05.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.346]                     {
[11:02:05.346]                       inherits <- base::inherits
[11:02:05.346]                       invokeRestart <- base::invokeRestart
[11:02:05.346]                       is.null <- base::is.null
[11:02:05.346]                       muffled <- FALSE
[11:02:05.346]                       if (inherits(cond, "message")) {
[11:02:05.346]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.346]                         if (muffled) 
[11:02:05.346]                           invokeRestart("muffleMessage")
[11:02:05.346]                       }
[11:02:05.346]                       else if (inherits(cond, "warning")) {
[11:02:05.346]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.346]                         if (muffled) 
[11:02:05.346]                           invokeRestart("muffleWarning")
[11:02:05.346]                       }
[11:02:05.346]                       else if (inherits(cond, "condition")) {
[11:02:05.346]                         if (!is.null(pattern)) {
[11:02:05.346]                           computeRestarts <- base::computeRestarts
[11:02:05.346]                           grepl <- base::grepl
[11:02:05.346]                           restarts <- computeRestarts(cond)
[11:02:05.346]                           for (restart in restarts) {
[11:02:05.346]                             name <- restart$name
[11:02:05.346]                             if (is.null(name)) 
[11:02:05.346]                               next
[11:02:05.346]                             if (!grepl(pattern, name)) 
[11:02:05.346]                               next
[11:02:05.346]                             invokeRestart(restart)
[11:02:05.346]                             muffled <- TRUE
[11:02:05.346]                             break
[11:02:05.346]                           }
[11:02:05.346]                         }
[11:02:05.346]                       }
[11:02:05.346]                       invisible(muffled)
[11:02:05.346]                     }
[11:02:05.346]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.346]                   }
[11:02:05.346]                 }
[11:02:05.346]                 else {
[11:02:05.346]                   if (TRUE) {
[11:02:05.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.346]                     {
[11:02:05.346]                       inherits <- base::inherits
[11:02:05.346]                       invokeRestart <- base::invokeRestart
[11:02:05.346]                       is.null <- base::is.null
[11:02:05.346]                       muffled <- FALSE
[11:02:05.346]                       if (inherits(cond, "message")) {
[11:02:05.346]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.346]                         if (muffled) 
[11:02:05.346]                           invokeRestart("muffleMessage")
[11:02:05.346]                       }
[11:02:05.346]                       else if (inherits(cond, "warning")) {
[11:02:05.346]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.346]                         if (muffled) 
[11:02:05.346]                           invokeRestart("muffleWarning")
[11:02:05.346]                       }
[11:02:05.346]                       else if (inherits(cond, "condition")) {
[11:02:05.346]                         if (!is.null(pattern)) {
[11:02:05.346]                           computeRestarts <- base::computeRestarts
[11:02:05.346]                           grepl <- base::grepl
[11:02:05.346]                           restarts <- computeRestarts(cond)
[11:02:05.346]                           for (restart in restarts) {
[11:02:05.346]                             name <- restart$name
[11:02:05.346]                             if (is.null(name)) 
[11:02:05.346]                               next
[11:02:05.346]                             if (!grepl(pattern, name)) 
[11:02:05.346]                               next
[11:02:05.346]                             invokeRestart(restart)
[11:02:05.346]                             muffled <- TRUE
[11:02:05.346]                             break
[11:02:05.346]                           }
[11:02:05.346]                         }
[11:02:05.346]                       }
[11:02:05.346]                       invisible(muffled)
[11:02:05.346]                     }
[11:02:05.346]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.346]                   }
[11:02:05.346]                 }
[11:02:05.346]             }
[11:02:05.346]         }))
[11:02:05.346]     }, error = function(ex) {
[11:02:05.346]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:05.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.346]                 ...future.rng), started = ...future.startTime, 
[11:02:05.346]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:05.346]             version = "1.8"), class = "FutureResult")
[11:02:05.346]     }, finally = {
[11:02:05.346]         if (!identical(...future.workdir, getwd())) 
[11:02:05.346]             setwd(...future.workdir)
[11:02:05.346]         {
[11:02:05.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:05.346]                 ...future.oldOptions$nwarnings <- NULL
[11:02:05.346]             }
[11:02:05.346]             base::options(...future.oldOptions)
[11:02:05.346]             if (.Platform$OS.type == "windows") {
[11:02:05.346]                 old_names <- names(...future.oldEnvVars)
[11:02:05.346]                 envs <- base::Sys.getenv()
[11:02:05.346]                 names <- names(envs)
[11:02:05.346]                 common <- intersect(names, old_names)
[11:02:05.346]                 added <- setdiff(names, old_names)
[11:02:05.346]                 removed <- setdiff(old_names, names)
[11:02:05.346]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:05.346]                   envs[common]]
[11:02:05.346]                 NAMES <- toupper(changed)
[11:02:05.346]                 args <- list()
[11:02:05.346]                 for (kk in seq_along(NAMES)) {
[11:02:05.346]                   name <- changed[[kk]]
[11:02:05.346]                   NAME <- NAMES[[kk]]
[11:02:05.346]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.346]                     next
[11:02:05.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.346]                 }
[11:02:05.346]                 NAMES <- toupper(added)
[11:02:05.346]                 for (kk in seq_along(NAMES)) {
[11:02:05.346]                   name <- added[[kk]]
[11:02:05.346]                   NAME <- NAMES[[kk]]
[11:02:05.346]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.346]                     next
[11:02:05.346]                   args[[name]] <- ""
[11:02:05.346]                 }
[11:02:05.346]                 NAMES <- toupper(removed)
[11:02:05.346]                 for (kk in seq_along(NAMES)) {
[11:02:05.346]                   name <- removed[[kk]]
[11:02:05.346]                   NAME <- NAMES[[kk]]
[11:02:05.346]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.346]                     next
[11:02:05.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.346]                 }
[11:02:05.346]                 if (length(args) > 0) 
[11:02:05.346]                   base::do.call(base::Sys.setenv, args = args)
[11:02:05.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:05.346]             }
[11:02:05.346]             else {
[11:02:05.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:05.346]             }
[11:02:05.346]             {
[11:02:05.346]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:05.346]                   0L) {
[11:02:05.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:05.346]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:05.346]                   base::options(opts)
[11:02:05.346]                 }
[11:02:05.346]                 {
[11:02:05.346]                   {
[11:02:05.346]                     NULL
[11:02:05.346]                     RNGkind("Mersenne-Twister")
[11:02:05.346]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:05.346]                       inherits = FALSE)
[11:02:05.346]                   }
[11:02:05.346]                   options(future.plan = NULL)
[11:02:05.346]                   if (is.na(NA_character_)) 
[11:02:05.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:05.346]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:05.346]                     .init = FALSE)
[11:02:05.346]                 }
[11:02:05.346]             }
[11:02:05.346]         }
[11:02:05.346]     })
[11:02:05.346]     if (TRUE) {
[11:02:05.346]         base::sink(type = "output", split = FALSE)
[11:02:05.346]         if (TRUE) {
[11:02:05.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:05.346]         }
[11:02:05.346]         else {
[11:02:05.346]             ...future.result["stdout"] <- base::list(NULL)
[11:02:05.346]         }
[11:02:05.346]         base::close(...future.stdout)
[11:02:05.346]         ...future.stdout <- NULL
[11:02:05.346]     }
[11:02:05.346]     ...future.result$conditions <- ...future.conditions
[11:02:05.346]     ...future.result$finished <- base::Sys.time()
[11:02:05.346]     ...future.result
[11:02:05.346] }
[11:02:05.348] plan(): Setting new future strategy stack:
[11:02:05.348] List of future strategies:
[11:02:05.348] 1. sequential:
[11:02:05.348]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.348]    - tweaked: FALSE
[11:02:05.348]    - call: NULL
[11:02:05.348] plan(): nbrOfWorkers() = 1
[11:02:05.349] plan(): Setting new future strategy stack:
[11:02:05.349] List of future strategies:
[11:02:05.349] 1. sequential:
[11:02:05.349]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.349]    - tweaked: FALSE
[11:02:05.349]    - call: future::plan("sequential")
[11:02:05.350] plan(): nbrOfWorkers() = 1
[11:02:05.350] SequentialFuture started (and completed)
[11:02:05.350] resolved() for ‘SequentialFuture’ ...
[11:02:05.350] - state: ‘finished’
[11:02:05.351] - run: TRUE
[11:02:05.351] - result: ‘FutureResult’
[11:02:05.351] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
[11:02:05.352] getGlobalsAndPackages() ...
[11:02:05.352] Searching for globals...
[11:02:05.358] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[11:02:05.358] Searching for globals ... DONE
[11:02:05.358] Resolving globals: FALSE
[11:02:05.359] The total size of the 1 globals is 39 bytes (39 bytes)
[11:02:05.359] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:02:05.359] - globals: [1] ‘a’
[11:02:05.359] 
[11:02:05.359] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 39 bytes (numeric ‘a’ of 39 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d252f3dd-7a92-6ee4-db84-2a586bbc6302
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:05.360] Packages needed by the future expression (n = 0): <none>
[11:02:05.360] Packages needed by future strategies (n = 0): <none>
[11:02:05.361] {
[11:02:05.361]     {
[11:02:05.361]         {
[11:02:05.361]             ...future.startTime <- base::Sys.time()
[11:02:05.361]             {
[11:02:05.361]                 {
[11:02:05.361]                   {
[11:02:05.361]                     base::local({
[11:02:05.361]                       has_future <- base::requireNamespace("future", 
[11:02:05.361]                         quietly = TRUE)
[11:02:05.361]                       if (has_future) {
[11:02:05.361]                         ns <- base::getNamespace("future")
[11:02:05.361]                         version <- ns[[".package"]][["version"]]
[11:02:05.361]                         if (is.null(version)) 
[11:02:05.361]                           version <- utils::packageVersion("future")
[11:02:05.361]                       }
[11:02:05.361]                       else {
[11:02:05.361]                         version <- NULL
[11:02:05.361]                       }
[11:02:05.361]                       if (!has_future || version < "1.8.0") {
[11:02:05.361]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:05.361]                           "", base::R.version$version.string), 
[11:02:05.361]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:05.361]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:05.361]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:05.361]                             "release", "version")], collapse = " "), 
[11:02:05.361]                           hostname = base::Sys.info()[["nodename"]])
[11:02:05.361]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:05.361]                           info)
[11:02:05.361]                         info <- base::paste(info, collapse = "; ")
[11:02:05.361]                         if (!has_future) {
[11:02:05.361]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:05.361]                             info)
[11:02:05.361]                         }
[11:02:05.361]                         else {
[11:02:05.361]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:05.361]                             info, version)
[11:02:05.361]                         }
[11:02:05.361]                         base::stop(msg)
[11:02:05.361]                       }
[11:02:05.361]                     })
[11:02:05.361]                   }
[11:02:05.361]                   ...future.strategy.old <- future::plan("list")
[11:02:05.361]                   options(future.plan = NULL)
[11:02:05.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:05.361]                 }
[11:02:05.361]                 ...future.workdir <- getwd()
[11:02:05.361]             }
[11:02:05.361]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:05.361]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:05.361]         }
[11:02:05.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:05.361]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:05.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:05.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:05.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:05.361]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:05.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:05.361]             base::names(...future.oldOptions))
[11:02:05.361]     }
[11:02:05.361]     if (FALSE) {
[11:02:05.361]     }
[11:02:05.361]     else {
[11:02:05.361]         if (TRUE) {
[11:02:05.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:05.361]                 open = "w")
[11:02:05.361]         }
[11:02:05.361]         else {
[11:02:05.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:05.361]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:05.361]         }
[11:02:05.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:05.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:05.361]             base::sink(type = "output", split = FALSE)
[11:02:05.361]             base::close(...future.stdout)
[11:02:05.361]         }, add = TRUE)
[11:02:05.361]     }
[11:02:05.361]     ...future.frame <- base::sys.nframe()
[11:02:05.361]     ...future.conditions <- base::list()
[11:02:05.361]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:05.361]     if (FALSE) {
[11:02:05.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:05.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:05.361]     }
[11:02:05.361]     ...future.result <- base::tryCatch({
[11:02:05.361]         base::withCallingHandlers({
[11:02:05.361]             ...future.value <- base::withVisible(base::local({
[11:02:05.361]                 b <- 3
[11:02:05.361]                 c <- 2
[11:02:05.361]                 a * b * c
[11:02:05.361]             }))
[11:02:05.361]             future::FutureResult(value = ...future.value$value, 
[11:02:05.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.361]                   ...future.rng), globalenv = if (FALSE) 
[11:02:05.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:05.361]                     ...future.globalenv.names))
[11:02:05.361]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:05.361]         }, condition = base::local({
[11:02:05.361]             c <- base::c
[11:02:05.361]             inherits <- base::inherits
[11:02:05.361]             invokeRestart <- base::invokeRestart
[11:02:05.361]             length <- base::length
[11:02:05.361]             list <- base::list
[11:02:05.361]             seq.int <- base::seq.int
[11:02:05.361]             signalCondition <- base::signalCondition
[11:02:05.361]             sys.calls <- base::sys.calls
[11:02:05.361]             `[[` <- base::`[[`
[11:02:05.361]             `+` <- base::`+`
[11:02:05.361]             `<<-` <- base::`<<-`
[11:02:05.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:05.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:05.361]                   3L)]
[11:02:05.361]             }
[11:02:05.361]             function(cond) {
[11:02:05.361]                 is_error <- inherits(cond, "error")
[11:02:05.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:05.361]                   NULL)
[11:02:05.361]                 if (is_error) {
[11:02:05.361]                   sessionInformation <- function() {
[11:02:05.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:05.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:05.361]                       search = base::search(), system = base::Sys.info())
[11:02:05.361]                   }
[11:02:05.361]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:05.361]                     cond$call), session = sessionInformation(), 
[11:02:05.361]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:05.361]                   signalCondition(cond)
[11:02:05.361]                 }
[11:02:05.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:05.361]                 "immediateCondition"))) {
[11:02:05.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:05.361]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:05.361]                   if (TRUE && !signal) {
[11:02:05.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.361]                     {
[11:02:05.361]                       inherits <- base::inherits
[11:02:05.361]                       invokeRestart <- base::invokeRestart
[11:02:05.361]                       is.null <- base::is.null
[11:02:05.361]                       muffled <- FALSE
[11:02:05.361]                       if (inherits(cond, "message")) {
[11:02:05.361]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.361]                         if (muffled) 
[11:02:05.361]                           invokeRestart("muffleMessage")
[11:02:05.361]                       }
[11:02:05.361]                       else if (inherits(cond, "warning")) {
[11:02:05.361]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.361]                         if (muffled) 
[11:02:05.361]                           invokeRestart("muffleWarning")
[11:02:05.361]                       }
[11:02:05.361]                       else if (inherits(cond, "condition")) {
[11:02:05.361]                         if (!is.null(pattern)) {
[11:02:05.361]                           computeRestarts <- base::computeRestarts
[11:02:05.361]                           grepl <- base::grepl
[11:02:05.361]                           restarts <- computeRestarts(cond)
[11:02:05.361]                           for (restart in restarts) {
[11:02:05.361]                             name <- restart$name
[11:02:05.361]                             if (is.null(name)) 
[11:02:05.361]                               next
[11:02:05.361]                             if (!grepl(pattern, name)) 
[11:02:05.361]                               next
[11:02:05.361]                             invokeRestart(restart)
[11:02:05.361]                             muffled <- TRUE
[11:02:05.361]                             break
[11:02:05.361]                           }
[11:02:05.361]                         }
[11:02:05.361]                       }
[11:02:05.361]                       invisible(muffled)
[11:02:05.361]                     }
[11:02:05.361]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.361]                   }
[11:02:05.361]                 }
[11:02:05.361]                 else {
[11:02:05.361]                   if (TRUE) {
[11:02:05.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.361]                     {
[11:02:05.361]                       inherits <- base::inherits
[11:02:05.361]                       invokeRestart <- base::invokeRestart
[11:02:05.361]                       is.null <- base::is.null
[11:02:05.361]                       muffled <- FALSE
[11:02:05.361]                       if (inherits(cond, "message")) {
[11:02:05.361]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.361]                         if (muffled) 
[11:02:05.361]                           invokeRestart("muffleMessage")
[11:02:05.361]                       }
[11:02:05.361]                       else if (inherits(cond, "warning")) {
[11:02:05.361]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.361]                         if (muffled) 
[11:02:05.361]                           invokeRestart("muffleWarning")
[11:02:05.361]                       }
[11:02:05.361]                       else if (inherits(cond, "condition")) {
[11:02:05.361]                         if (!is.null(pattern)) {
[11:02:05.361]                           computeRestarts <- base::computeRestarts
[11:02:05.361]                           grepl <- base::grepl
[11:02:05.361]                           restarts <- computeRestarts(cond)
[11:02:05.361]                           for (restart in restarts) {
[11:02:05.361]                             name <- restart$name
[11:02:05.361]                             if (is.null(name)) 
[11:02:05.361]                               next
[11:02:05.361]                             if (!grepl(pattern, name)) 
[11:02:05.361]                               next
[11:02:05.361]                             invokeRestart(restart)
[11:02:05.361]                             muffled <- TRUE
[11:02:05.361]                             break
[11:02:05.361]                           }
[11:02:05.361]                         }
[11:02:05.361]                       }
[11:02:05.361]                       invisible(muffled)
[11:02:05.361]                     }
[11:02:05.361]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.361]                   }
[11:02:05.361]                 }
[11:02:05.361]             }
[11:02:05.361]         }))
[11:02:05.361]     }, error = function(ex) {
[11:02:05.361]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:05.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.361]                 ...future.rng), started = ...future.startTime, 
[11:02:05.361]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:05.361]             version = "1.8"), class = "FutureResult")
[11:02:05.361]     }, finally = {
[11:02:05.361]         if (!identical(...future.workdir, getwd())) 
[11:02:05.361]             setwd(...future.workdir)
[11:02:05.361]         {
[11:02:05.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:05.361]                 ...future.oldOptions$nwarnings <- NULL
[11:02:05.361]             }
[11:02:05.361]             base::options(...future.oldOptions)
[11:02:05.361]             if (.Platform$OS.type == "windows") {
[11:02:05.361]                 old_names <- names(...future.oldEnvVars)
[11:02:05.361]                 envs <- base::Sys.getenv()
[11:02:05.361]                 names <- names(envs)
[11:02:05.361]                 common <- intersect(names, old_names)
[11:02:05.361]                 added <- setdiff(names, old_names)
[11:02:05.361]                 removed <- setdiff(old_names, names)
[11:02:05.361]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:05.361]                   envs[common]]
[11:02:05.361]                 NAMES <- toupper(changed)
[11:02:05.361]                 args <- list()
[11:02:05.361]                 for (kk in seq_along(NAMES)) {
[11:02:05.361]                   name <- changed[[kk]]
[11:02:05.361]                   NAME <- NAMES[[kk]]
[11:02:05.361]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.361]                     next
[11:02:05.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.361]                 }
[11:02:05.361]                 NAMES <- toupper(added)
[11:02:05.361]                 for (kk in seq_along(NAMES)) {
[11:02:05.361]                   name <- added[[kk]]
[11:02:05.361]                   NAME <- NAMES[[kk]]
[11:02:05.361]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.361]                     next
[11:02:05.361]                   args[[name]] <- ""
[11:02:05.361]                 }
[11:02:05.361]                 NAMES <- toupper(removed)
[11:02:05.361]                 for (kk in seq_along(NAMES)) {
[11:02:05.361]                   name <- removed[[kk]]
[11:02:05.361]                   NAME <- NAMES[[kk]]
[11:02:05.361]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.361]                     next
[11:02:05.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.361]                 }
[11:02:05.361]                 if (length(args) > 0) 
[11:02:05.361]                   base::do.call(base::Sys.setenv, args = args)
[11:02:05.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:05.361]             }
[11:02:05.361]             else {
[11:02:05.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:05.361]             }
[11:02:05.361]             {
[11:02:05.361]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:05.361]                   0L) {
[11:02:05.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:05.361]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:05.361]                   base::options(opts)
[11:02:05.361]                 }
[11:02:05.361]                 {
[11:02:05.361]                   {
[11:02:05.361]                     NULL
[11:02:05.361]                     RNGkind("Mersenne-Twister")
[11:02:05.361]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:05.361]                       inherits = FALSE)
[11:02:05.361]                   }
[11:02:05.361]                   options(future.plan = NULL)
[11:02:05.361]                   if (is.na(NA_character_)) 
[11:02:05.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:05.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:05.361]                     .init = FALSE)
[11:02:05.361]                 }
[11:02:05.361]             }
[11:02:05.361]         }
[11:02:05.361]     })
[11:02:05.361]     if (TRUE) {
[11:02:05.361]         base::sink(type = "output", split = FALSE)
[11:02:05.361]         if (TRUE) {
[11:02:05.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:05.361]         }
[11:02:05.361]         else {
[11:02:05.361]             ...future.result["stdout"] <- base::list(NULL)
[11:02:05.361]         }
[11:02:05.361]         base::close(...future.stdout)
[11:02:05.361]         ...future.stdout <- NULL
[11:02:05.361]     }
[11:02:05.361]     ...future.result$conditions <- ...future.conditions
[11:02:05.361]     ...future.result$finished <- base::Sys.time()
[11:02:05.361]     ...future.result
[11:02:05.361] }
[11:02:05.362] assign_globals() ...
[11:02:05.362] List of 1
[11:02:05.362]  $ a: num 0
[11:02:05.362]  - attr(*, "where")=List of 1
[11:02:05.362]   ..$ a:<environment: R_EmptyEnv> 
[11:02:05.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:05.362]  - attr(*, "resolved")= logi FALSE
[11:02:05.362]  - attr(*, "total_size")= num 39
[11:02:05.366] - copied ‘a’ to environment
[11:02:05.366] assign_globals() ... done
[11:02:05.366] plan(): Setting new future strategy stack:
[11:02:05.367] List of future strategies:
[11:02:05.367] 1. sequential:
[11:02:05.367]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.367]    - tweaked: FALSE
[11:02:05.367]    - call: NULL
[11:02:05.367] plan(): nbrOfWorkers() = 1
[11:02:05.368] plan(): Setting new future strategy stack:
[11:02:05.368] List of future strategies:
[11:02:05.368] 1. sequential:
[11:02:05.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.368]    - tweaked: FALSE
[11:02:05.368]    - call: future::plan("sequential")
[11:02:05.368] plan(): nbrOfWorkers() = 1
[11:02:05.368] SequentialFuture started (and completed)
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[11:02:05.370] getGlobalsAndPackages() ...
[11:02:05.370] Searching for globals...
[11:02:05.370] - globals found: [2] ‘{’, ‘ii’
[11:02:05.370] Searching for globals ... DONE
[11:02:05.371] Resolving globals: FALSE
[11:02:05.371] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:05.371] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:02:05.371] - globals: [1] ‘ii’
[11:02:05.371] 
[11:02:05.371] getGlobalsAndPackages() ... DONE
 - Creating multisession future #1 ...
[11:02:05.373] getGlobalsAndPackages() ...
[11:02:05.373] Searching for globals...
[11:02:05.374] - globals found: [2] ‘{’, ‘ii’
[11:02:05.374] Searching for globals ... DONE
[11:02:05.374] Resolving globals: FALSE
[11:02:05.374] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:05.374] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:02:05.375] - globals: [1] ‘ii’
[11:02:05.375] 
[11:02:05.375] getGlobalsAndPackages() ... DONE
 - Resolving 2 multisession futures
[11:02:05.375] Packages needed by the future expression (n = 0): <none>
[11:02:05.375] Packages needed by future strategies (n = 0): <none>
[11:02:05.376] {
[11:02:05.376]     {
[11:02:05.376]         {
[11:02:05.376]             ...future.startTime <- base::Sys.time()
[11:02:05.376]             {
[11:02:05.376]                 {
[11:02:05.376]                   {
[11:02:05.376]                     base::local({
[11:02:05.376]                       has_future <- base::requireNamespace("future", 
[11:02:05.376]                         quietly = TRUE)
[11:02:05.376]                       if (has_future) {
[11:02:05.376]                         ns <- base::getNamespace("future")
[11:02:05.376]                         version <- ns[[".package"]][["version"]]
[11:02:05.376]                         if (is.null(version)) 
[11:02:05.376]                           version <- utils::packageVersion("future")
[11:02:05.376]                       }
[11:02:05.376]                       else {
[11:02:05.376]                         version <- NULL
[11:02:05.376]                       }
[11:02:05.376]                       if (!has_future || version < "1.8.0") {
[11:02:05.376]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:05.376]                           "", base::R.version$version.string), 
[11:02:05.376]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:05.376]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:05.376]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:05.376]                             "release", "version")], collapse = " "), 
[11:02:05.376]                           hostname = base::Sys.info()[["nodename"]])
[11:02:05.376]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:05.376]                           info)
[11:02:05.376]                         info <- base::paste(info, collapse = "; ")
[11:02:05.376]                         if (!has_future) {
[11:02:05.376]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:05.376]                             info)
[11:02:05.376]                         }
[11:02:05.376]                         else {
[11:02:05.376]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:05.376]                             info, version)
[11:02:05.376]                         }
[11:02:05.376]                         base::stop(msg)
[11:02:05.376]                       }
[11:02:05.376]                     })
[11:02:05.376]                   }
[11:02:05.376]                   ...future.strategy.old <- future::plan("list")
[11:02:05.376]                   options(future.plan = NULL)
[11:02:05.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:05.376]                 }
[11:02:05.376]                 ...future.workdir <- getwd()
[11:02:05.376]             }
[11:02:05.376]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:05.376]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:05.376]         }
[11:02:05.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:05.376]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:05.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:05.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:05.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:05.376]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:05.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:05.376]             base::names(...future.oldOptions))
[11:02:05.376]     }
[11:02:05.376]     if (FALSE) {
[11:02:05.376]     }
[11:02:05.376]     else {
[11:02:05.376]         if (TRUE) {
[11:02:05.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:05.376]                 open = "w")
[11:02:05.376]         }
[11:02:05.376]         else {
[11:02:05.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:05.376]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:05.376]         }
[11:02:05.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:05.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:05.376]             base::sink(type = "output", split = FALSE)
[11:02:05.376]             base::close(...future.stdout)
[11:02:05.376]         }, add = TRUE)
[11:02:05.376]     }
[11:02:05.376]     ...future.frame <- base::sys.nframe()
[11:02:05.376]     ...future.conditions <- base::list()
[11:02:05.376]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:05.376]     if (FALSE) {
[11:02:05.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:05.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:05.376]     }
[11:02:05.376]     ...future.result <- base::tryCatch({
[11:02:05.376]         base::withCallingHandlers({
[11:02:05.376]             ...future.value <- base::withVisible(base::local({
[11:02:05.376]                 ii
[11:02:05.376]             }))
[11:02:05.376]             future::FutureResult(value = ...future.value$value, 
[11:02:05.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.376]                   ...future.rng), globalenv = if (FALSE) 
[11:02:05.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:05.376]                     ...future.globalenv.names))
[11:02:05.376]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:05.376]         }, condition = base::local({
[11:02:05.376]             c <- base::c
[11:02:05.376]             inherits <- base::inherits
[11:02:05.376]             invokeRestart <- base::invokeRestart
[11:02:05.376]             length <- base::length
[11:02:05.376]             list <- base::list
[11:02:05.376]             seq.int <- base::seq.int
[11:02:05.376]             signalCondition <- base::signalCondition
[11:02:05.376]             sys.calls <- base::sys.calls
[11:02:05.376]             `[[` <- base::`[[`
[11:02:05.376]             `+` <- base::`+`
[11:02:05.376]             `<<-` <- base::`<<-`
[11:02:05.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:05.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:05.376]                   3L)]
[11:02:05.376]             }
[11:02:05.376]             function(cond) {
[11:02:05.376]                 is_error <- inherits(cond, "error")
[11:02:05.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:05.376]                   NULL)
[11:02:05.376]                 if (is_error) {
[11:02:05.376]                   sessionInformation <- function() {
[11:02:05.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:05.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:05.376]                       search = base::search(), system = base::Sys.info())
[11:02:05.376]                   }
[11:02:05.376]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:05.376]                     cond$call), session = sessionInformation(), 
[11:02:05.376]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:05.376]                   signalCondition(cond)
[11:02:05.376]                 }
[11:02:05.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:05.376]                 "immediateCondition"))) {
[11:02:05.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:05.376]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:05.376]                   if (TRUE && !signal) {
[11:02:05.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.376]                     {
[11:02:05.376]                       inherits <- base::inherits
[11:02:05.376]                       invokeRestart <- base::invokeRestart
[11:02:05.376]                       is.null <- base::is.null
[11:02:05.376]                       muffled <- FALSE
[11:02:05.376]                       if (inherits(cond, "message")) {
[11:02:05.376]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.376]                         if (muffled) 
[11:02:05.376]                           invokeRestart("muffleMessage")
[11:02:05.376]                       }
[11:02:05.376]                       else if (inherits(cond, "warning")) {
[11:02:05.376]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.376]                         if (muffled) 
[11:02:05.376]                           invokeRestart("muffleWarning")
[11:02:05.376]                       }
[11:02:05.376]                       else if (inherits(cond, "condition")) {
[11:02:05.376]                         if (!is.null(pattern)) {
[11:02:05.376]                           computeRestarts <- base::computeRestarts
[11:02:05.376]                           grepl <- base::grepl
[11:02:05.376]                           restarts <- computeRestarts(cond)
[11:02:05.376]                           for (restart in restarts) {
[11:02:05.376]                             name <- restart$name
[11:02:05.376]                             if (is.null(name)) 
[11:02:05.376]                               next
[11:02:05.376]                             if (!grepl(pattern, name)) 
[11:02:05.376]                               next
[11:02:05.376]                             invokeRestart(restart)
[11:02:05.376]                             muffled <- TRUE
[11:02:05.376]                             break
[11:02:05.376]                           }
[11:02:05.376]                         }
[11:02:05.376]                       }
[11:02:05.376]                       invisible(muffled)
[11:02:05.376]                     }
[11:02:05.376]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.376]                   }
[11:02:05.376]                 }
[11:02:05.376]                 else {
[11:02:05.376]                   if (TRUE) {
[11:02:05.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.376]                     {
[11:02:05.376]                       inherits <- base::inherits
[11:02:05.376]                       invokeRestart <- base::invokeRestart
[11:02:05.376]                       is.null <- base::is.null
[11:02:05.376]                       muffled <- FALSE
[11:02:05.376]                       if (inherits(cond, "message")) {
[11:02:05.376]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.376]                         if (muffled) 
[11:02:05.376]                           invokeRestart("muffleMessage")
[11:02:05.376]                       }
[11:02:05.376]                       else if (inherits(cond, "warning")) {
[11:02:05.376]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.376]                         if (muffled) 
[11:02:05.376]                           invokeRestart("muffleWarning")
[11:02:05.376]                       }
[11:02:05.376]                       else if (inherits(cond, "condition")) {
[11:02:05.376]                         if (!is.null(pattern)) {
[11:02:05.376]                           computeRestarts <- base::computeRestarts
[11:02:05.376]                           grepl <- base::grepl
[11:02:05.376]                           restarts <- computeRestarts(cond)
[11:02:05.376]                           for (restart in restarts) {
[11:02:05.376]                             name <- restart$name
[11:02:05.376]                             if (is.null(name)) 
[11:02:05.376]                               next
[11:02:05.376]                             if (!grepl(pattern, name)) 
[11:02:05.376]                               next
[11:02:05.376]                             invokeRestart(restart)
[11:02:05.376]                             muffled <- TRUE
[11:02:05.376]                             break
[11:02:05.376]                           }
[11:02:05.376]                         }
[11:02:05.376]                       }
[11:02:05.376]                       invisible(muffled)
[11:02:05.376]                     }
[11:02:05.376]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.376]                   }
[11:02:05.376]                 }
[11:02:05.376]             }
[11:02:05.376]         }))
[11:02:05.376]     }, error = function(ex) {
[11:02:05.376]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:05.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.376]                 ...future.rng), started = ...future.startTime, 
[11:02:05.376]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:05.376]             version = "1.8"), class = "FutureResult")
[11:02:05.376]     }, finally = {
[11:02:05.376]         if (!identical(...future.workdir, getwd())) 
[11:02:05.376]             setwd(...future.workdir)
[11:02:05.376]         {
[11:02:05.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:05.376]                 ...future.oldOptions$nwarnings <- NULL
[11:02:05.376]             }
[11:02:05.376]             base::options(...future.oldOptions)
[11:02:05.376]             if (.Platform$OS.type == "windows") {
[11:02:05.376]                 old_names <- names(...future.oldEnvVars)
[11:02:05.376]                 envs <- base::Sys.getenv()
[11:02:05.376]                 names <- names(envs)
[11:02:05.376]                 common <- intersect(names, old_names)
[11:02:05.376]                 added <- setdiff(names, old_names)
[11:02:05.376]                 removed <- setdiff(old_names, names)
[11:02:05.376]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:05.376]                   envs[common]]
[11:02:05.376]                 NAMES <- toupper(changed)
[11:02:05.376]                 args <- list()
[11:02:05.376]                 for (kk in seq_along(NAMES)) {
[11:02:05.376]                   name <- changed[[kk]]
[11:02:05.376]                   NAME <- NAMES[[kk]]
[11:02:05.376]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.376]                     next
[11:02:05.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.376]                 }
[11:02:05.376]                 NAMES <- toupper(added)
[11:02:05.376]                 for (kk in seq_along(NAMES)) {
[11:02:05.376]                   name <- added[[kk]]
[11:02:05.376]                   NAME <- NAMES[[kk]]
[11:02:05.376]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.376]                     next
[11:02:05.376]                   args[[name]] <- ""
[11:02:05.376]                 }
[11:02:05.376]                 NAMES <- toupper(removed)
[11:02:05.376]                 for (kk in seq_along(NAMES)) {
[11:02:05.376]                   name <- removed[[kk]]
[11:02:05.376]                   NAME <- NAMES[[kk]]
[11:02:05.376]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.376]                     next
[11:02:05.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.376]                 }
[11:02:05.376]                 if (length(args) > 0) 
[11:02:05.376]                   base::do.call(base::Sys.setenv, args = args)
[11:02:05.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:05.376]             }
[11:02:05.376]             else {
[11:02:05.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:05.376]             }
[11:02:05.376]             {
[11:02:05.376]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:05.376]                   0L) {
[11:02:05.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:05.376]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:05.376]                   base::options(opts)
[11:02:05.376]                 }
[11:02:05.376]                 {
[11:02:05.376]                   {
[11:02:05.376]                     NULL
[11:02:05.376]                     RNGkind("Mersenne-Twister")
[11:02:05.376]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:05.376]                       inherits = FALSE)
[11:02:05.376]                   }
[11:02:05.376]                   options(future.plan = NULL)
[11:02:05.376]                   if (is.na(NA_character_)) 
[11:02:05.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:05.376]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:05.376]                     .init = FALSE)
[11:02:05.376]                 }
[11:02:05.376]             }
[11:02:05.376]         }
[11:02:05.376]     })
[11:02:05.376]     if (TRUE) {
[11:02:05.376]         base::sink(type = "output", split = FALSE)
[11:02:05.376]         if (TRUE) {
[11:02:05.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:05.376]         }
[11:02:05.376]         else {
[11:02:05.376]             ...future.result["stdout"] <- base::list(NULL)
[11:02:05.376]         }
[11:02:05.376]         base::close(...future.stdout)
[11:02:05.376]         ...future.stdout <- NULL
[11:02:05.376]     }
[11:02:05.376]     ...future.result$conditions <- ...future.conditions
[11:02:05.376]     ...future.result$finished <- base::Sys.time()
[11:02:05.376]     ...future.result
[11:02:05.376] }
[11:02:05.377] assign_globals() ...
[11:02:05.377] List of 1
[11:02:05.377]  $ ii: int 1
[11:02:05.377]  - attr(*, "where")=List of 1
[11:02:05.377]   ..$ ii:<environment: R_EmptyEnv> 
[11:02:05.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:05.377]  - attr(*, "resolved")= logi FALSE
[11:02:05.377]  - attr(*, "total_size")= num 35
[11:02:05.379] - copied ‘ii’ to environment
[11:02:05.380] assign_globals() ... done
[11:02:05.380] plan(): Setting new future strategy stack:
[11:02:05.380] List of future strategies:
[11:02:05.380] 1. sequential:
[11:02:05.380]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.380]    - tweaked: FALSE
[11:02:05.380]    - call: NULL
[11:02:05.380] plan(): nbrOfWorkers() = 1
[11:02:05.381] plan(): Setting new future strategy stack:
[11:02:05.381] List of future strategies:
[11:02:05.381] 1. sequential:
[11:02:05.381]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.381]    - tweaked: FALSE
[11:02:05.381]    - call: future::plan("sequential")
[11:02:05.381] plan(): nbrOfWorkers() = 1
[11:02:05.382] SequentialFuture started (and completed)
[11:02:05.382] Packages needed by the future expression (n = 0): <none>
[11:02:05.382] Packages needed by future strategies (n = 0): <none>
[11:02:05.382] {
[11:02:05.382]     {
[11:02:05.382]         {
[11:02:05.382]             ...future.startTime <- base::Sys.time()
[11:02:05.382]             {
[11:02:05.382]                 {
[11:02:05.382]                   {
[11:02:05.382]                     base::local({
[11:02:05.382]                       has_future <- base::requireNamespace("future", 
[11:02:05.382]                         quietly = TRUE)
[11:02:05.382]                       if (has_future) {
[11:02:05.382]                         ns <- base::getNamespace("future")
[11:02:05.382]                         version <- ns[[".package"]][["version"]]
[11:02:05.382]                         if (is.null(version)) 
[11:02:05.382]                           version <- utils::packageVersion("future")
[11:02:05.382]                       }
[11:02:05.382]                       else {
[11:02:05.382]                         version <- NULL
[11:02:05.382]                       }
[11:02:05.382]                       if (!has_future || version < "1.8.0") {
[11:02:05.382]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:05.382]                           "", base::R.version$version.string), 
[11:02:05.382]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:05.382]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:05.382]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:05.382]                             "release", "version")], collapse = " "), 
[11:02:05.382]                           hostname = base::Sys.info()[["nodename"]])
[11:02:05.382]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:05.382]                           info)
[11:02:05.382]                         info <- base::paste(info, collapse = "; ")
[11:02:05.382]                         if (!has_future) {
[11:02:05.382]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:05.382]                             info)
[11:02:05.382]                         }
[11:02:05.382]                         else {
[11:02:05.382]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:05.382]                             info, version)
[11:02:05.382]                         }
[11:02:05.382]                         base::stop(msg)
[11:02:05.382]                       }
[11:02:05.382]                     })
[11:02:05.382]                   }
[11:02:05.382]                   ...future.strategy.old <- future::plan("list")
[11:02:05.382]                   options(future.plan = NULL)
[11:02:05.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:05.382]                 }
[11:02:05.382]                 ...future.workdir <- getwd()
[11:02:05.382]             }
[11:02:05.382]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:05.382]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:05.382]         }
[11:02:05.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:05.382]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:05.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:05.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:05.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:05.382]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:05.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:05.382]             base::names(...future.oldOptions))
[11:02:05.382]     }
[11:02:05.382]     if (FALSE) {
[11:02:05.382]     }
[11:02:05.382]     else {
[11:02:05.382]         if (TRUE) {
[11:02:05.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:05.382]                 open = "w")
[11:02:05.382]         }
[11:02:05.382]         else {
[11:02:05.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:05.382]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:05.382]         }
[11:02:05.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:05.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:05.382]             base::sink(type = "output", split = FALSE)
[11:02:05.382]             base::close(...future.stdout)
[11:02:05.382]         }, add = TRUE)
[11:02:05.382]     }
[11:02:05.382]     ...future.frame <- base::sys.nframe()
[11:02:05.382]     ...future.conditions <- base::list()
[11:02:05.382]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:05.382]     if (FALSE) {
[11:02:05.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:05.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:05.382]     }
[11:02:05.382]     ...future.result <- base::tryCatch({
[11:02:05.382]         base::withCallingHandlers({
[11:02:05.382]             ...future.value <- base::withVisible(base::local({
[11:02:05.382]                 ii
[11:02:05.382]             }))
[11:02:05.382]             future::FutureResult(value = ...future.value$value, 
[11:02:05.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.382]                   ...future.rng), globalenv = if (FALSE) 
[11:02:05.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:05.382]                     ...future.globalenv.names))
[11:02:05.382]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:05.382]         }, condition = base::local({
[11:02:05.382]             c <- base::c
[11:02:05.382]             inherits <- base::inherits
[11:02:05.382]             invokeRestart <- base::invokeRestart
[11:02:05.382]             length <- base::length
[11:02:05.382]             list <- base::list
[11:02:05.382]             seq.int <- base::seq.int
[11:02:05.382]             signalCondition <- base::signalCondition
[11:02:05.382]             sys.calls <- base::sys.calls
[11:02:05.382]             `[[` <- base::`[[`
[11:02:05.382]             `+` <- base::`+`
[11:02:05.382]             `<<-` <- base::`<<-`
[11:02:05.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:05.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:05.382]                   3L)]
[11:02:05.382]             }
[11:02:05.382]             function(cond) {
[11:02:05.382]                 is_error <- inherits(cond, "error")
[11:02:05.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:05.382]                   NULL)
[11:02:05.382]                 if (is_error) {
[11:02:05.382]                   sessionInformation <- function() {
[11:02:05.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:05.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:05.382]                       search = base::search(), system = base::Sys.info())
[11:02:05.382]                   }
[11:02:05.382]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:05.382]                     cond$call), session = sessionInformation(), 
[11:02:05.382]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:05.382]                   signalCondition(cond)
[11:02:05.382]                 }
[11:02:05.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:05.382]                 "immediateCondition"))) {
[11:02:05.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:05.382]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:05.382]                   if (TRUE && !signal) {
[11:02:05.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.382]                     {
[11:02:05.382]                       inherits <- base::inherits
[11:02:05.382]                       invokeRestart <- base::invokeRestart
[11:02:05.382]                       is.null <- base::is.null
[11:02:05.382]                       muffled <- FALSE
[11:02:05.382]                       if (inherits(cond, "message")) {
[11:02:05.382]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.382]                         if (muffled) 
[11:02:05.382]                           invokeRestart("muffleMessage")
[11:02:05.382]                       }
[11:02:05.382]                       else if (inherits(cond, "warning")) {
[11:02:05.382]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.382]                         if (muffled) 
[11:02:05.382]                           invokeRestart("muffleWarning")
[11:02:05.382]                       }
[11:02:05.382]                       else if (inherits(cond, "condition")) {
[11:02:05.382]                         if (!is.null(pattern)) {
[11:02:05.382]                           computeRestarts <- base::computeRestarts
[11:02:05.382]                           grepl <- base::grepl
[11:02:05.382]                           restarts <- computeRestarts(cond)
[11:02:05.382]                           for (restart in restarts) {
[11:02:05.382]                             name <- restart$name
[11:02:05.382]                             if (is.null(name)) 
[11:02:05.382]                               next
[11:02:05.382]                             if (!grepl(pattern, name)) 
[11:02:05.382]                               next
[11:02:05.382]                             invokeRestart(restart)
[11:02:05.382]                             muffled <- TRUE
[11:02:05.382]                             break
[11:02:05.382]                           }
[11:02:05.382]                         }
[11:02:05.382]                       }
[11:02:05.382]                       invisible(muffled)
[11:02:05.382]                     }
[11:02:05.382]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.382]                   }
[11:02:05.382]                 }
[11:02:05.382]                 else {
[11:02:05.382]                   if (TRUE) {
[11:02:05.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.382]                     {
[11:02:05.382]                       inherits <- base::inherits
[11:02:05.382]                       invokeRestart <- base::invokeRestart
[11:02:05.382]                       is.null <- base::is.null
[11:02:05.382]                       muffled <- FALSE
[11:02:05.382]                       if (inherits(cond, "message")) {
[11:02:05.382]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.382]                         if (muffled) 
[11:02:05.382]                           invokeRestart("muffleMessage")
[11:02:05.382]                       }
[11:02:05.382]                       else if (inherits(cond, "warning")) {
[11:02:05.382]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.382]                         if (muffled) 
[11:02:05.382]                           invokeRestart("muffleWarning")
[11:02:05.382]                       }
[11:02:05.382]                       else if (inherits(cond, "condition")) {
[11:02:05.382]                         if (!is.null(pattern)) {
[11:02:05.382]                           computeRestarts <- base::computeRestarts
[11:02:05.382]                           grepl <- base::grepl
[11:02:05.382]                           restarts <- computeRestarts(cond)
[11:02:05.382]                           for (restart in restarts) {
[11:02:05.382]                             name <- restart$name
[11:02:05.382]                             if (is.null(name)) 
[11:02:05.382]                               next
[11:02:05.382]                             if (!grepl(pattern, name)) 
[11:02:05.382]                               next
[11:02:05.382]                             invokeRestart(restart)
[11:02:05.382]                             muffled <- TRUE
[11:02:05.382]                             break
[11:02:05.382]                           }
[11:02:05.382]                         }
[11:02:05.382]                       }
[11:02:05.382]                       invisible(muffled)
[11:02:05.382]                     }
[11:02:05.382]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.382]                   }
[11:02:05.382]                 }
[11:02:05.382]             }
[11:02:05.382]         }))
[11:02:05.382]     }, error = function(ex) {
[11:02:05.382]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:05.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.382]                 ...future.rng), started = ...future.startTime, 
[11:02:05.382]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:05.382]             version = "1.8"), class = "FutureResult")
[11:02:05.382]     }, finally = {
[11:02:05.382]         if (!identical(...future.workdir, getwd())) 
[11:02:05.382]             setwd(...future.workdir)
[11:02:05.382]         {
[11:02:05.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:05.382]                 ...future.oldOptions$nwarnings <- NULL
[11:02:05.382]             }
[11:02:05.382]             base::options(...future.oldOptions)
[11:02:05.382]             if (.Platform$OS.type == "windows") {
[11:02:05.382]                 old_names <- names(...future.oldEnvVars)
[11:02:05.382]                 envs <- base::Sys.getenv()
[11:02:05.382]                 names <- names(envs)
[11:02:05.382]                 common <- intersect(names, old_names)
[11:02:05.382]                 added <- setdiff(names, old_names)
[11:02:05.382]                 removed <- setdiff(old_names, names)
[11:02:05.382]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:05.382]                   envs[common]]
[11:02:05.382]                 NAMES <- toupper(changed)
[11:02:05.382]                 args <- list()
[11:02:05.382]                 for (kk in seq_along(NAMES)) {
[11:02:05.382]                   name <- changed[[kk]]
[11:02:05.382]                   NAME <- NAMES[[kk]]
[11:02:05.382]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.382]                     next
[11:02:05.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.382]                 }
[11:02:05.382]                 NAMES <- toupper(added)
[11:02:05.382]                 for (kk in seq_along(NAMES)) {
[11:02:05.382]                   name <- added[[kk]]
[11:02:05.382]                   NAME <- NAMES[[kk]]
[11:02:05.382]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.382]                     next
[11:02:05.382]                   args[[name]] <- ""
[11:02:05.382]                 }
[11:02:05.382]                 NAMES <- toupper(removed)
[11:02:05.382]                 for (kk in seq_along(NAMES)) {
[11:02:05.382]                   name <- removed[[kk]]
[11:02:05.382]                   NAME <- NAMES[[kk]]
[11:02:05.382]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.382]                     next
[11:02:05.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.382]                 }
[11:02:05.382]                 if (length(args) > 0) 
[11:02:05.382]                   base::do.call(base::Sys.setenv, args = args)
[11:02:05.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:05.382]             }
[11:02:05.382]             else {
[11:02:05.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:05.382]             }
[11:02:05.382]             {
[11:02:05.382]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:05.382]                   0L) {
[11:02:05.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:05.382]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:05.382]                   base::options(opts)
[11:02:05.382]                 }
[11:02:05.382]                 {
[11:02:05.382]                   {
[11:02:05.382]                     NULL
[11:02:05.382]                     RNGkind("Mersenne-Twister")
[11:02:05.382]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:05.382]                       inherits = FALSE)
[11:02:05.382]                   }
[11:02:05.382]                   options(future.plan = NULL)
[11:02:05.382]                   if (is.na(NA_character_)) 
[11:02:05.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:05.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:05.382]                     .init = FALSE)
[11:02:05.382]                 }
[11:02:05.382]             }
[11:02:05.382]         }
[11:02:05.382]     })
[11:02:05.382]     if (TRUE) {
[11:02:05.382]         base::sink(type = "output", split = FALSE)
[11:02:05.382]         if (TRUE) {
[11:02:05.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:05.382]         }
[11:02:05.382]         else {
[11:02:05.382]             ...future.result["stdout"] <- base::list(NULL)
[11:02:05.382]         }
[11:02:05.382]         base::close(...future.stdout)
[11:02:05.382]         ...future.stdout <- NULL
[11:02:05.382]     }
[11:02:05.382]     ...future.result$conditions <- ...future.conditions
[11:02:05.382]     ...future.result$finished <- base::Sys.time()
[11:02:05.382]     ...future.result
[11:02:05.382] }
[11:02:05.384] assign_globals() ...
[11:02:05.384] List of 1
[11:02:05.384]  $ ii: int 2
[11:02:05.384]  - attr(*, "where")=List of 1
[11:02:05.384]   ..$ ii:<environment: R_EmptyEnv> 
[11:02:05.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:05.384]  - attr(*, "resolved")= logi FALSE
[11:02:05.384]  - attr(*, "total_size")= num 35
[11:02:05.386] - copied ‘ii’ to environment
[11:02:05.386] assign_globals() ... done
[11:02:05.386] plan(): Setting new future strategy stack:
[11:02:05.386] List of future strategies:
[11:02:05.386] 1. sequential:
[11:02:05.386]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.386]    - tweaked: FALSE
[11:02:05.386]    - call: NULL
[11:02:05.387] plan(): nbrOfWorkers() = 1
[11:02:05.387] plan(): Setting new future strategy stack:
[11:02:05.387] List of future strategies:
[11:02:05.387] 1. sequential:
[11:02:05.387]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.387]    - tweaked: FALSE
[11:02:05.387]    - call: future::plan("sequential")
[11:02:05.388] plan(): nbrOfWorkers() = 1
[11:02:05.388] SequentialFuture started (and completed)
*** multisession() - workers inherit .libPaths()
[11:02:05.388] getGlobalsAndPackages() ...
[11:02:05.388] Searching for globals...
[11:02:05.389] - globals found: [1] ‘.libPaths’
[11:02:05.389] Searching for globals ... DONE
[11:02:05.389] Resolving globals: FALSE
[11:02:05.390] 
[11:02:05.390] 
[11:02:05.390] getGlobalsAndPackages() ... DONE
[11:02:05.391] run() for ‘Future’ ...
[11:02:05.391] - state: ‘created’
[11:02:05.391] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:05.391] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:05.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:05.391]   - Field: ‘label’
[11:02:05.392]   - Field: ‘local’
[11:02:05.392]   - Field: ‘owner’
[11:02:05.392]   - Field: ‘envir’
[11:02:05.392]   - Field: ‘packages’
[11:02:05.392]   - Field: ‘gc’
[11:02:05.392]   - Field: ‘conditions’
[11:02:05.392]   - Field: ‘expr’
[11:02:05.392]   - Field: ‘uuid’
[11:02:05.392]   - Field: ‘seed’
[11:02:05.392]   - Field: ‘version’
[11:02:05.392]   - Field: ‘result’
[11:02:05.392]   - Field: ‘asynchronous’
[11:02:05.393]   - Field: ‘calls’
[11:02:05.393]   - Field: ‘globals’
[11:02:05.393]   - Field: ‘stdout’
[11:02:05.393]   - Field: ‘earlySignal’
[11:02:05.393]   - Field: ‘lazy’
[11:02:05.393]   - Field: ‘state’
[11:02:05.393] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:05.393] - Launch lazy future ...
[11:02:05.393] Packages needed by the future expression (n = 0): <none>
[11:02:05.393] Packages needed by future strategies (n = 0): <none>
[11:02:05.394] {
[11:02:05.394]     {
[11:02:05.394]         {
[11:02:05.394]             ...future.startTime <- base::Sys.time()
[11:02:05.394]             {
[11:02:05.394]                 {
[11:02:05.394]                   {
[11:02:05.394]                     base::local({
[11:02:05.394]                       has_future <- base::requireNamespace("future", 
[11:02:05.394]                         quietly = TRUE)
[11:02:05.394]                       if (has_future) {
[11:02:05.394]                         ns <- base::getNamespace("future")
[11:02:05.394]                         version <- ns[[".package"]][["version"]]
[11:02:05.394]                         if (is.null(version)) 
[11:02:05.394]                           version <- utils::packageVersion("future")
[11:02:05.394]                       }
[11:02:05.394]                       else {
[11:02:05.394]                         version <- NULL
[11:02:05.394]                       }
[11:02:05.394]                       if (!has_future || version < "1.8.0") {
[11:02:05.394]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:05.394]                           "", base::R.version$version.string), 
[11:02:05.394]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:05.394]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:05.394]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:05.394]                             "release", "version")], collapse = " "), 
[11:02:05.394]                           hostname = base::Sys.info()[["nodename"]])
[11:02:05.394]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:05.394]                           info)
[11:02:05.394]                         info <- base::paste(info, collapse = "; ")
[11:02:05.394]                         if (!has_future) {
[11:02:05.394]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:05.394]                             info)
[11:02:05.394]                         }
[11:02:05.394]                         else {
[11:02:05.394]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:05.394]                             info, version)
[11:02:05.394]                         }
[11:02:05.394]                         base::stop(msg)
[11:02:05.394]                       }
[11:02:05.394]                     })
[11:02:05.394]                   }
[11:02:05.394]                   ...future.strategy.old <- future::plan("list")
[11:02:05.394]                   options(future.plan = NULL)
[11:02:05.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:05.394]                 }
[11:02:05.394]                 ...future.workdir <- getwd()
[11:02:05.394]             }
[11:02:05.394]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:05.394]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:05.394]         }
[11:02:05.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:05.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:05.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:05.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:05.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:05.394]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:05.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:05.394]             base::names(...future.oldOptions))
[11:02:05.394]     }
[11:02:05.394]     if (FALSE) {
[11:02:05.394]     }
[11:02:05.394]     else {
[11:02:05.394]         if (TRUE) {
[11:02:05.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:05.394]                 open = "w")
[11:02:05.394]         }
[11:02:05.394]         else {
[11:02:05.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:05.394]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:05.394]         }
[11:02:05.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:05.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:05.394]             base::sink(type = "output", split = FALSE)
[11:02:05.394]             base::close(...future.stdout)
[11:02:05.394]         }, add = TRUE)
[11:02:05.394]     }
[11:02:05.394]     ...future.frame <- base::sys.nframe()
[11:02:05.394]     ...future.conditions <- base::list()
[11:02:05.394]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:05.394]     if (FALSE) {
[11:02:05.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:05.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:05.394]     }
[11:02:05.394]     ...future.result <- base::tryCatch({
[11:02:05.394]         base::withCallingHandlers({
[11:02:05.394]             ...future.value <- base::withVisible(base::local(.libPaths()))
[11:02:05.394]             future::FutureResult(value = ...future.value$value, 
[11:02:05.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.394]                   ...future.rng), globalenv = if (FALSE) 
[11:02:05.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:05.394]                     ...future.globalenv.names))
[11:02:05.394]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:05.394]         }, condition = base::local({
[11:02:05.394]             c <- base::c
[11:02:05.394]             inherits <- base::inherits
[11:02:05.394]             invokeRestart <- base::invokeRestart
[11:02:05.394]             length <- base::length
[11:02:05.394]             list <- base::list
[11:02:05.394]             seq.int <- base::seq.int
[11:02:05.394]             signalCondition <- base::signalCondition
[11:02:05.394]             sys.calls <- base::sys.calls
[11:02:05.394]             `[[` <- base::`[[`
[11:02:05.394]             `+` <- base::`+`
[11:02:05.394]             `<<-` <- base::`<<-`
[11:02:05.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:05.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:05.394]                   3L)]
[11:02:05.394]             }
[11:02:05.394]             function(cond) {
[11:02:05.394]                 is_error <- inherits(cond, "error")
[11:02:05.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:05.394]                   NULL)
[11:02:05.394]                 if (is_error) {
[11:02:05.394]                   sessionInformation <- function() {
[11:02:05.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:05.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:05.394]                       search = base::search(), system = base::Sys.info())
[11:02:05.394]                   }
[11:02:05.394]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:05.394]                     cond$call), session = sessionInformation(), 
[11:02:05.394]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:05.394]                   signalCondition(cond)
[11:02:05.394]                 }
[11:02:05.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:05.394]                 "immediateCondition"))) {
[11:02:05.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:05.394]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:05.394]                   if (TRUE && !signal) {
[11:02:05.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.394]                     {
[11:02:05.394]                       inherits <- base::inherits
[11:02:05.394]                       invokeRestart <- base::invokeRestart
[11:02:05.394]                       is.null <- base::is.null
[11:02:05.394]                       muffled <- FALSE
[11:02:05.394]                       if (inherits(cond, "message")) {
[11:02:05.394]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.394]                         if (muffled) 
[11:02:05.394]                           invokeRestart("muffleMessage")
[11:02:05.394]                       }
[11:02:05.394]                       else if (inherits(cond, "warning")) {
[11:02:05.394]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.394]                         if (muffled) 
[11:02:05.394]                           invokeRestart("muffleWarning")
[11:02:05.394]                       }
[11:02:05.394]                       else if (inherits(cond, "condition")) {
[11:02:05.394]                         if (!is.null(pattern)) {
[11:02:05.394]                           computeRestarts <- base::computeRestarts
[11:02:05.394]                           grepl <- base::grepl
[11:02:05.394]                           restarts <- computeRestarts(cond)
[11:02:05.394]                           for (restart in restarts) {
[11:02:05.394]                             name <- restart$name
[11:02:05.394]                             if (is.null(name)) 
[11:02:05.394]                               next
[11:02:05.394]                             if (!grepl(pattern, name)) 
[11:02:05.394]                               next
[11:02:05.394]                             invokeRestart(restart)
[11:02:05.394]                             muffled <- TRUE
[11:02:05.394]                             break
[11:02:05.394]                           }
[11:02:05.394]                         }
[11:02:05.394]                       }
[11:02:05.394]                       invisible(muffled)
[11:02:05.394]                     }
[11:02:05.394]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.394]                   }
[11:02:05.394]                 }
[11:02:05.394]                 else {
[11:02:05.394]                   if (TRUE) {
[11:02:05.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.394]                     {
[11:02:05.394]                       inherits <- base::inherits
[11:02:05.394]                       invokeRestart <- base::invokeRestart
[11:02:05.394]                       is.null <- base::is.null
[11:02:05.394]                       muffled <- FALSE
[11:02:05.394]                       if (inherits(cond, "message")) {
[11:02:05.394]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.394]                         if (muffled) 
[11:02:05.394]                           invokeRestart("muffleMessage")
[11:02:05.394]                       }
[11:02:05.394]                       else if (inherits(cond, "warning")) {
[11:02:05.394]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.394]                         if (muffled) 
[11:02:05.394]                           invokeRestart("muffleWarning")
[11:02:05.394]                       }
[11:02:05.394]                       else if (inherits(cond, "condition")) {
[11:02:05.394]                         if (!is.null(pattern)) {
[11:02:05.394]                           computeRestarts <- base::computeRestarts
[11:02:05.394]                           grepl <- base::grepl
[11:02:05.394]                           restarts <- computeRestarts(cond)
[11:02:05.394]                           for (restart in restarts) {
[11:02:05.394]                             name <- restart$name
[11:02:05.394]                             if (is.null(name)) 
[11:02:05.394]                               next
[11:02:05.394]                             if (!grepl(pattern, name)) 
[11:02:05.394]                               next
[11:02:05.394]                             invokeRestart(restart)
[11:02:05.394]                             muffled <- TRUE
[11:02:05.394]                             break
[11:02:05.394]                           }
[11:02:05.394]                         }
[11:02:05.394]                       }
[11:02:05.394]                       invisible(muffled)
[11:02:05.394]                     }
[11:02:05.394]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.394]                   }
[11:02:05.394]                 }
[11:02:05.394]             }
[11:02:05.394]         }))
[11:02:05.394]     }, error = function(ex) {
[11:02:05.394]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:05.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.394]                 ...future.rng), started = ...future.startTime, 
[11:02:05.394]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:05.394]             version = "1.8"), class = "FutureResult")
[11:02:05.394]     }, finally = {
[11:02:05.394]         if (!identical(...future.workdir, getwd())) 
[11:02:05.394]             setwd(...future.workdir)
[11:02:05.394]         {
[11:02:05.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:05.394]                 ...future.oldOptions$nwarnings <- NULL
[11:02:05.394]             }
[11:02:05.394]             base::options(...future.oldOptions)
[11:02:05.394]             if (.Platform$OS.type == "windows") {
[11:02:05.394]                 old_names <- names(...future.oldEnvVars)
[11:02:05.394]                 envs <- base::Sys.getenv()
[11:02:05.394]                 names <- names(envs)
[11:02:05.394]                 common <- intersect(names, old_names)
[11:02:05.394]                 added <- setdiff(names, old_names)
[11:02:05.394]                 removed <- setdiff(old_names, names)
[11:02:05.394]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:05.394]                   envs[common]]
[11:02:05.394]                 NAMES <- toupper(changed)
[11:02:05.394]                 args <- list()
[11:02:05.394]                 for (kk in seq_along(NAMES)) {
[11:02:05.394]                   name <- changed[[kk]]
[11:02:05.394]                   NAME <- NAMES[[kk]]
[11:02:05.394]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.394]                     next
[11:02:05.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.394]                 }
[11:02:05.394]                 NAMES <- toupper(added)
[11:02:05.394]                 for (kk in seq_along(NAMES)) {
[11:02:05.394]                   name <- added[[kk]]
[11:02:05.394]                   NAME <- NAMES[[kk]]
[11:02:05.394]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.394]                     next
[11:02:05.394]                   args[[name]] <- ""
[11:02:05.394]                 }
[11:02:05.394]                 NAMES <- toupper(removed)
[11:02:05.394]                 for (kk in seq_along(NAMES)) {
[11:02:05.394]                   name <- removed[[kk]]
[11:02:05.394]                   NAME <- NAMES[[kk]]
[11:02:05.394]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.394]                     next
[11:02:05.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.394]                 }
[11:02:05.394]                 if (length(args) > 0) 
[11:02:05.394]                   base::do.call(base::Sys.setenv, args = args)
[11:02:05.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:05.394]             }
[11:02:05.394]             else {
[11:02:05.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:05.394]             }
[11:02:05.394]             {
[11:02:05.394]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:05.394]                   0L) {
[11:02:05.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:05.394]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:05.394]                   base::options(opts)
[11:02:05.394]                 }
[11:02:05.394]                 {
[11:02:05.394]                   {
[11:02:05.394]                     NULL
[11:02:05.394]                     RNGkind("Mersenne-Twister")
[11:02:05.394]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:05.394]                       inherits = FALSE)
[11:02:05.394]                   }
[11:02:05.394]                   options(future.plan = NULL)
[11:02:05.394]                   if (is.na(NA_character_)) 
[11:02:05.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:05.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:05.394]                     .init = FALSE)
[11:02:05.394]                 }
[11:02:05.394]             }
[11:02:05.394]         }
[11:02:05.394]     })
[11:02:05.394]     if (TRUE) {
[11:02:05.394]         base::sink(type = "output", split = FALSE)
[11:02:05.394]         if (TRUE) {
[11:02:05.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:05.394]         }
[11:02:05.394]         else {
[11:02:05.394]             ...future.result["stdout"] <- base::list(NULL)
[11:02:05.394]         }
[11:02:05.394]         base::close(...future.stdout)
[11:02:05.394]         ...future.stdout <- NULL
[11:02:05.394]     }
[11:02:05.394]     ...future.result$conditions <- ...future.conditions
[11:02:05.394]     ...future.result$finished <- base::Sys.time()
[11:02:05.394]     ...future.result
[11:02:05.394] }
[11:02:05.395] plan(): Setting new future strategy stack:
[11:02:05.396] List of future strategies:
[11:02:05.396] 1. sequential:
[11:02:05.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.396]    - tweaked: FALSE
[11:02:05.396]    - call: NULL
[11:02:05.396] plan(): nbrOfWorkers() = 1
[11:02:05.397] plan(): Setting new future strategy stack:
[11:02:05.397] List of future strategies:
[11:02:05.397] 1. sequential:
[11:02:05.397]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.397]    - tweaked: FALSE
[11:02:05.397]    - call: future::plan("sequential")
[11:02:05.397] plan(): nbrOfWorkers() = 1
[11:02:05.397] SequentialFuture started (and completed)
[11:02:05.397] - Launch lazy future ... done
[11:02:05.397] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[11:02:05.399] getGlobalsAndPackages() ...
[11:02:05.400] Searching for globals...
[11:02:05.400] - globals found: [2] ‘{’, ‘stop’
[11:02:05.400] Searching for globals ... DONE
[11:02:05.401] Resolving globals: FALSE
[11:02:05.401] 
[11:02:05.401] 
[11:02:05.401] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d252f3dd-7a92-6ee4-db84-2a586bbc6302
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:05.402] Packages needed by the future expression (n = 0): <none>
[11:02:05.402] Packages needed by future strategies (n = 0): <none>
[11:02:05.402] {
[11:02:05.402]     {
[11:02:05.402]         {
[11:02:05.402]             ...future.startTime <- base::Sys.time()
[11:02:05.402]             {
[11:02:05.402]                 {
[11:02:05.402]                   {
[11:02:05.402]                     base::local({
[11:02:05.402]                       has_future <- base::requireNamespace("future", 
[11:02:05.402]                         quietly = TRUE)
[11:02:05.402]                       if (has_future) {
[11:02:05.402]                         ns <- base::getNamespace("future")
[11:02:05.402]                         version <- ns[[".package"]][["version"]]
[11:02:05.402]                         if (is.null(version)) 
[11:02:05.402]                           version <- utils::packageVersion("future")
[11:02:05.402]                       }
[11:02:05.402]                       else {
[11:02:05.402]                         version <- NULL
[11:02:05.402]                       }
[11:02:05.402]                       if (!has_future || version < "1.8.0") {
[11:02:05.402]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:05.402]                           "", base::R.version$version.string), 
[11:02:05.402]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:05.402]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:05.402]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:05.402]                             "release", "version")], collapse = " "), 
[11:02:05.402]                           hostname = base::Sys.info()[["nodename"]])
[11:02:05.402]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:05.402]                           info)
[11:02:05.402]                         info <- base::paste(info, collapse = "; ")
[11:02:05.402]                         if (!has_future) {
[11:02:05.402]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:05.402]                             info)
[11:02:05.402]                         }
[11:02:05.402]                         else {
[11:02:05.402]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:05.402]                             info, version)
[11:02:05.402]                         }
[11:02:05.402]                         base::stop(msg)
[11:02:05.402]                       }
[11:02:05.402]                     })
[11:02:05.402]                   }
[11:02:05.402]                   ...future.strategy.old <- future::plan("list")
[11:02:05.402]                   options(future.plan = NULL)
[11:02:05.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:05.402]                 }
[11:02:05.402]                 ...future.workdir <- getwd()
[11:02:05.402]             }
[11:02:05.402]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:05.402]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:05.402]         }
[11:02:05.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:05.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:05.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:05.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:05.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:05.402]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:05.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:05.402]             base::names(...future.oldOptions))
[11:02:05.402]     }
[11:02:05.402]     if (FALSE) {
[11:02:05.402]     }
[11:02:05.402]     else {
[11:02:05.402]         if (TRUE) {
[11:02:05.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:05.402]                 open = "w")
[11:02:05.402]         }
[11:02:05.402]         else {
[11:02:05.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:05.402]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:05.402]         }
[11:02:05.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:05.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:05.402]             base::sink(type = "output", split = FALSE)
[11:02:05.402]             base::close(...future.stdout)
[11:02:05.402]         }, add = TRUE)
[11:02:05.402]     }
[11:02:05.402]     ...future.frame <- base::sys.nframe()
[11:02:05.402]     ...future.conditions <- base::list()
[11:02:05.402]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:05.402]     if (FALSE) {
[11:02:05.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:05.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:05.402]     }
[11:02:05.402]     ...future.result <- base::tryCatch({
[11:02:05.402]         base::withCallingHandlers({
[11:02:05.402]             ...future.value <- base::withVisible(base::local({
[11:02:05.402]                 stop("Whoops!")
[11:02:05.402]                 1
[11:02:05.402]             }))
[11:02:05.402]             future::FutureResult(value = ...future.value$value, 
[11:02:05.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.402]                   ...future.rng), globalenv = if (FALSE) 
[11:02:05.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:05.402]                     ...future.globalenv.names))
[11:02:05.402]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:05.402]         }, condition = base::local({
[11:02:05.402]             c <- base::c
[11:02:05.402]             inherits <- base::inherits
[11:02:05.402]             invokeRestart <- base::invokeRestart
[11:02:05.402]             length <- base::length
[11:02:05.402]             list <- base::list
[11:02:05.402]             seq.int <- base::seq.int
[11:02:05.402]             signalCondition <- base::signalCondition
[11:02:05.402]             sys.calls <- base::sys.calls
[11:02:05.402]             `[[` <- base::`[[`
[11:02:05.402]             `+` <- base::`+`
[11:02:05.402]             `<<-` <- base::`<<-`
[11:02:05.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:05.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:05.402]                   3L)]
[11:02:05.402]             }
[11:02:05.402]             function(cond) {
[11:02:05.402]                 is_error <- inherits(cond, "error")
[11:02:05.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:05.402]                   NULL)
[11:02:05.402]                 if (is_error) {
[11:02:05.402]                   sessionInformation <- function() {
[11:02:05.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:05.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:05.402]                       search = base::search(), system = base::Sys.info())
[11:02:05.402]                   }
[11:02:05.402]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:05.402]                     cond$call), session = sessionInformation(), 
[11:02:05.402]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:05.402]                   signalCondition(cond)
[11:02:05.402]                 }
[11:02:05.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:05.402]                 "immediateCondition"))) {
[11:02:05.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:05.402]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:05.402]                   if (TRUE && !signal) {
[11:02:05.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.402]                     {
[11:02:05.402]                       inherits <- base::inherits
[11:02:05.402]                       invokeRestart <- base::invokeRestart
[11:02:05.402]                       is.null <- base::is.null
[11:02:05.402]                       muffled <- FALSE
[11:02:05.402]                       if (inherits(cond, "message")) {
[11:02:05.402]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.402]                         if (muffled) 
[11:02:05.402]                           invokeRestart("muffleMessage")
[11:02:05.402]                       }
[11:02:05.402]                       else if (inherits(cond, "warning")) {
[11:02:05.402]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.402]                         if (muffled) 
[11:02:05.402]                           invokeRestart("muffleWarning")
[11:02:05.402]                       }
[11:02:05.402]                       else if (inherits(cond, "condition")) {
[11:02:05.402]                         if (!is.null(pattern)) {
[11:02:05.402]                           computeRestarts <- base::computeRestarts
[11:02:05.402]                           grepl <- base::grepl
[11:02:05.402]                           restarts <- computeRestarts(cond)
[11:02:05.402]                           for (restart in restarts) {
[11:02:05.402]                             name <- restart$name
[11:02:05.402]                             if (is.null(name)) 
[11:02:05.402]                               next
[11:02:05.402]                             if (!grepl(pattern, name)) 
[11:02:05.402]                               next
[11:02:05.402]                             invokeRestart(restart)
[11:02:05.402]                             muffled <- TRUE
[11:02:05.402]                             break
[11:02:05.402]                           }
[11:02:05.402]                         }
[11:02:05.402]                       }
[11:02:05.402]                       invisible(muffled)
[11:02:05.402]                     }
[11:02:05.402]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.402]                   }
[11:02:05.402]                 }
[11:02:05.402]                 else {
[11:02:05.402]                   if (TRUE) {
[11:02:05.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.402]                     {
[11:02:05.402]                       inherits <- base::inherits
[11:02:05.402]                       invokeRestart <- base::invokeRestart
[11:02:05.402]                       is.null <- base::is.null
[11:02:05.402]                       muffled <- FALSE
[11:02:05.402]                       if (inherits(cond, "message")) {
[11:02:05.402]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.402]                         if (muffled) 
[11:02:05.402]                           invokeRestart("muffleMessage")
[11:02:05.402]                       }
[11:02:05.402]                       else if (inherits(cond, "warning")) {
[11:02:05.402]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.402]                         if (muffled) 
[11:02:05.402]                           invokeRestart("muffleWarning")
[11:02:05.402]                       }
[11:02:05.402]                       else if (inherits(cond, "condition")) {
[11:02:05.402]                         if (!is.null(pattern)) {
[11:02:05.402]                           computeRestarts <- base::computeRestarts
[11:02:05.402]                           grepl <- base::grepl
[11:02:05.402]                           restarts <- computeRestarts(cond)
[11:02:05.402]                           for (restart in restarts) {
[11:02:05.402]                             name <- restart$name
[11:02:05.402]                             if (is.null(name)) 
[11:02:05.402]                               next
[11:02:05.402]                             if (!grepl(pattern, name)) 
[11:02:05.402]                               next
[11:02:05.402]                             invokeRestart(restart)
[11:02:05.402]                             muffled <- TRUE
[11:02:05.402]                             break
[11:02:05.402]                           }
[11:02:05.402]                         }
[11:02:05.402]                       }
[11:02:05.402]                       invisible(muffled)
[11:02:05.402]                     }
[11:02:05.402]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.402]                   }
[11:02:05.402]                 }
[11:02:05.402]             }
[11:02:05.402]         }))
[11:02:05.402]     }, error = function(ex) {
[11:02:05.402]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:05.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.402]                 ...future.rng), started = ...future.startTime, 
[11:02:05.402]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:05.402]             version = "1.8"), class = "FutureResult")
[11:02:05.402]     }, finally = {
[11:02:05.402]         if (!identical(...future.workdir, getwd())) 
[11:02:05.402]             setwd(...future.workdir)
[11:02:05.402]         {
[11:02:05.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:05.402]                 ...future.oldOptions$nwarnings <- NULL
[11:02:05.402]             }
[11:02:05.402]             base::options(...future.oldOptions)
[11:02:05.402]             if (.Platform$OS.type == "windows") {
[11:02:05.402]                 old_names <- names(...future.oldEnvVars)
[11:02:05.402]                 envs <- base::Sys.getenv()
[11:02:05.402]                 names <- names(envs)
[11:02:05.402]                 common <- intersect(names, old_names)
[11:02:05.402]                 added <- setdiff(names, old_names)
[11:02:05.402]                 removed <- setdiff(old_names, names)
[11:02:05.402]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:05.402]                   envs[common]]
[11:02:05.402]                 NAMES <- toupper(changed)
[11:02:05.402]                 args <- list()
[11:02:05.402]                 for (kk in seq_along(NAMES)) {
[11:02:05.402]                   name <- changed[[kk]]
[11:02:05.402]                   NAME <- NAMES[[kk]]
[11:02:05.402]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.402]                     next
[11:02:05.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.402]                 }
[11:02:05.402]                 NAMES <- toupper(added)
[11:02:05.402]                 for (kk in seq_along(NAMES)) {
[11:02:05.402]                   name <- added[[kk]]
[11:02:05.402]                   NAME <- NAMES[[kk]]
[11:02:05.402]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.402]                     next
[11:02:05.402]                   args[[name]] <- ""
[11:02:05.402]                 }
[11:02:05.402]                 NAMES <- toupper(removed)
[11:02:05.402]                 for (kk in seq_along(NAMES)) {
[11:02:05.402]                   name <- removed[[kk]]
[11:02:05.402]                   NAME <- NAMES[[kk]]
[11:02:05.402]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.402]                     next
[11:02:05.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.402]                 }
[11:02:05.402]                 if (length(args) > 0) 
[11:02:05.402]                   base::do.call(base::Sys.setenv, args = args)
[11:02:05.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:05.402]             }
[11:02:05.402]             else {
[11:02:05.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:05.402]             }
[11:02:05.402]             {
[11:02:05.402]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:05.402]                   0L) {
[11:02:05.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:05.402]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:05.402]                   base::options(opts)
[11:02:05.402]                 }
[11:02:05.402]                 {
[11:02:05.402]                   {
[11:02:05.402]                     NULL
[11:02:05.402]                     RNGkind("Mersenne-Twister")
[11:02:05.402]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:05.402]                       inherits = FALSE)
[11:02:05.402]                   }
[11:02:05.402]                   options(future.plan = NULL)
[11:02:05.402]                   if (is.na(NA_character_)) 
[11:02:05.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:05.402]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:05.402]                     .init = FALSE)
[11:02:05.402]                 }
[11:02:05.402]             }
[11:02:05.402]         }
[11:02:05.402]     })
[11:02:05.402]     if (TRUE) {
[11:02:05.402]         base::sink(type = "output", split = FALSE)
[11:02:05.402]         if (TRUE) {
[11:02:05.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:05.402]         }
[11:02:05.402]         else {
[11:02:05.402]             ...future.result["stdout"] <- base::list(NULL)
[11:02:05.402]         }
[11:02:05.402]         base::close(...future.stdout)
[11:02:05.402]         ...future.stdout <- NULL
[11:02:05.402]     }
[11:02:05.402]     ...future.result$conditions <- ...future.conditions
[11:02:05.402]     ...future.result$finished <- base::Sys.time()
[11:02:05.402]     ...future.result
[11:02:05.402] }
[11:02:05.404] plan(): Setting new future strategy stack:
[11:02:05.404] List of future strategies:
[11:02:05.404] 1. sequential:
[11:02:05.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.404]    - tweaked: FALSE
[11:02:05.404]    - call: NULL
[11:02:05.404] plan(): nbrOfWorkers() = 1
[11:02:05.405] plan(): Setting new future strategy stack:
[11:02:05.405] List of future strategies:
[11:02:05.405] 1. sequential:
[11:02:05.405]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.405]    - tweaked: FALSE
[11:02:05.405]    - call: future::plan("sequential")
[11:02:05.406] plan(): nbrOfWorkers() = 1
[11:02:05.406] SequentialFuture started (and completed)
[11:02:05.406] signalConditions() ...
[11:02:05.406]  - include = ‘immediateCondition’
[11:02:05.406]  - exclude = 
[11:02:05.406]  - resignal = FALSE
[11:02:05.406]  - Number of conditions: 1
[11:02:05.406] signalConditions() ... done
[11:02:05.406] signalConditions() ...
[11:02:05.406]  - include = ‘immediateCondition’
[11:02:05.407]  - exclude = 
[11:02:05.407]  - resignal = FALSE
[11:02:05.407]  - Number of conditions: 1
[11:02:05.407] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[11:02:05.407] signalConditions() ...
[11:02:05.407]  - include = ‘immediateCondition’
[11:02:05.407]  - exclude = 
[11:02:05.407]  - resignal = FALSE
[11:02:05.407]  - Number of conditions: 1
[11:02:05.407] signalConditions() ... done
[11:02:05.408] Future state: ‘finished’
[11:02:05.408] signalConditions() ...
[11:02:05.408]  - include = ‘condition’
[11:02:05.408]  - exclude = ‘immediateCondition’
[11:02:05.408]  - resignal = TRUE
[11:02:05.408]  - Number of conditions: 1
[11:02:05.408]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:02:05.408] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[11:02:05.408] signalConditions() ...
[11:02:05.409]  - include = ‘immediateCondition’
[11:02:05.409]  - exclude = 
[11:02:05.409]  - resignal = FALSE
[11:02:05.409]  - Number of conditions: 1
[11:02:05.409] signalConditions() ... done
[11:02:05.409] Future state: ‘finished’
[11:02:05.409] signalConditions() ...
[11:02:05.409]  - include = ‘condition’
[11:02:05.409]  - exclude = ‘immediateCondition’
[11:02:05.409]  - resignal = TRUE
[11:02:05.409]  - Number of conditions: 1
[11:02:05.409]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:02:05.410] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[11:02:05.411] getGlobalsAndPackages() ...
[11:02:05.411] Searching for globals...
[11:02:05.412] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[11:02:05.412] Searching for globals ... DONE
[11:02:05.412] Resolving globals: FALSE
[11:02:05.413] 
[11:02:05.413] 
[11:02:05.413] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d252f3dd-7a92-6ee4-db84-2a586bbc6302
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:05.413] Packages needed by the future expression (n = 0): <none>
[11:02:05.413] Packages needed by future strategies (n = 0): <none>
[11:02:05.414] {
[11:02:05.414]     {
[11:02:05.414]         {
[11:02:05.414]             ...future.startTime <- base::Sys.time()
[11:02:05.414]             {
[11:02:05.414]                 {
[11:02:05.414]                   {
[11:02:05.414]                     base::local({
[11:02:05.414]                       has_future <- base::requireNamespace("future", 
[11:02:05.414]                         quietly = TRUE)
[11:02:05.414]                       if (has_future) {
[11:02:05.414]                         ns <- base::getNamespace("future")
[11:02:05.414]                         version <- ns[[".package"]][["version"]]
[11:02:05.414]                         if (is.null(version)) 
[11:02:05.414]                           version <- utils::packageVersion("future")
[11:02:05.414]                       }
[11:02:05.414]                       else {
[11:02:05.414]                         version <- NULL
[11:02:05.414]                       }
[11:02:05.414]                       if (!has_future || version < "1.8.0") {
[11:02:05.414]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:05.414]                           "", base::R.version$version.string), 
[11:02:05.414]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:05.414]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:05.414]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:05.414]                             "release", "version")], collapse = " "), 
[11:02:05.414]                           hostname = base::Sys.info()[["nodename"]])
[11:02:05.414]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:05.414]                           info)
[11:02:05.414]                         info <- base::paste(info, collapse = "; ")
[11:02:05.414]                         if (!has_future) {
[11:02:05.414]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:05.414]                             info)
[11:02:05.414]                         }
[11:02:05.414]                         else {
[11:02:05.414]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:05.414]                             info, version)
[11:02:05.414]                         }
[11:02:05.414]                         base::stop(msg)
[11:02:05.414]                       }
[11:02:05.414]                     })
[11:02:05.414]                   }
[11:02:05.414]                   ...future.strategy.old <- future::plan("list")
[11:02:05.414]                   options(future.plan = NULL)
[11:02:05.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:05.414]                 }
[11:02:05.414]                 ...future.workdir <- getwd()
[11:02:05.414]             }
[11:02:05.414]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:05.414]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:05.414]         }
[11:02:05.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:05.414]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:05.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:05.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:05.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:05.414]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:05.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:05.414]             base::names(...future.oldOptions))
[11:02:05.414]     }
[11:02:05.414]     if (FALSE) {
[11:02:05.414]     }
[11:02:05.414]     else {
[11:02:05.414]         if (TRUE) {
[11:02:05.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:05.414]                 open = "w")
[11:02:05.414]         }
[11:02:05.414]         else {
[11:02:05.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:05.414]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:05.414]         }
[11:02:05.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:05.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:05.414]             base::sink(type = "output", split = FALSE)
[11:02:05.414]             base::close(...future.stdout)
[11:02:05.414]         }, add = TRUE)
[11:02:05.414]     }
[11:02:05.414]     ...future.frame <- base::sys.nframe()
[11:02:05.414]     ...future.conditions <- base::list()
[11:02:05.414]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:05.414]     if (FALSE) {
[11:02:05.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:05.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:05.414]     }
[11:02:05.414]     ...future.result <- base::tryCatch({
[11:02:05.414]         base::withCallingHandlers({
[11:02:05.414]             ...future.value <- base::withVisible(base::local({
[11:02:05.414]                 stop(structure(list(message = "boom"), class = c("MyError", 
[11:02:05.414]                   "error", "condition")))
[11:02:05.414]             }))
[11:02:05.414]             future::FutureResult(value = ...future.value$value, 
[11:02:05.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.414]                   ...future.rng), globalenv = if (FALSE) 
[11:02:05.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:05.414]                     ...future.globalenv.names))
[11:02:05.414]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:05.414]         }, condition = base::local({
[11:02:05.414]             c <- base::c
[11:02:05.414]             inherits <- base::inherits
[11:02:05.414]             invokeRestart <- base::invokeRestart
[11:02:05.414]             length <- base::length
[11:02:05.414]             list <- base::list
[11:02:05.414]             seq.int <- base::seq.int
[11:02:05.414]             signalCondition <- base::signalCondition
[11:02:05.414]             sys.calls <- base::sys.calls
[11:02:05.414]             `[[` <- base::`[[`
[11:02:05.414]             `+` <- base::`+`
[11:02:05.414]             `<<-` <- base::`<<-`
[11:02:05.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:05.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:05.414]                   3L)]
[11:02:05.414]             }
[11:02:05.414]             function(cond) {
[11:02:05.414]                 is_error <- inherits(cond, "error")
[11:02:05.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:05.414]                   NULL)
[11:02:05.414]                 if (is_error) {
[11:02:05.414]                   sessionInformation <- function() {
[11:02:05.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:05.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:05.414]                       search = base::search(), system = base::Sys.info())
[11:02:05.414]                   }
[11:02:05.414]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:05.414]                     cond$call), session = sessionInformation(), 
[11:02:05.414]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:05.414]                   signalCondition(cond)
[11:02:05.414]                 }
[11:02:05.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:05.414]                 "immediateCondition"))) {
[11:02:05.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:05.414]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:05.414]                   if (TRUE && !signal) {
[11:02:05.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.414]                     {
[11:02:05.414]                       inherits <- base::inherits
[11:02:05.414]                       invokeRestart <- base::invokeRestart
[11:02:05.414]                       is.null <- base::is.null
[11:02:05.414]                       muffled <- FALSE
[11:02:05.414]                       if (inherits(cond, "message")) {
[11:02:05.414]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.414]                         if (muffled) 
[11:02:05.414]                           invokeRestart("muffleMessage")
[11:02:05.414]                       }
[11:02:05.414]                       else if (inherits(cond, "warning")) {
[11:02:05.414]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.414]                         if (muffled) 
[11:02:05.414]                           invokeRestart("muffleWarning")
[11:02:05.414]                       }
[11:02:05.414]                       else if (inherits(cond, "condition")) {
[11:02:05.414]                         if (!is.null(pattern)) {
[11:02:05.414]                           computeRestarts <- base::computeRestarts
[11:02:05.414]                           grepl <- base::grepl
[11:02:05.414]                           restarts <- computeRestarts(cond)
[11:02:05.414]                           for (restart in restarts) {
[11:02:05.414]                             name <- restart$name
[11:02:05.414]                             if (is.null(name)) 
[11:02:05.414]                               next
[11:02:05.414]                             if (!grepl(pattern, name)) 
[11:02:05.414]                               next
[11:02:05.414]                             invokeRestart(restart)
[11:02:05.414]                             muffled <- TRUE
[11:02:05.414]                             break
[11:02:05.414]                           }
[11:02:05.414]                         }
[11:02:05.414]                       }
[11:02:05.414]                       invisible(muffled)
[11:02:05.414]                     }
[11:02:05.414]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.414]                   }
[11:02:05.414]                 }
[11:02:05.414]                 else {
[11:02:05.414]                   if (TRUE) {
[11:02:05.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.414]                     {
[11:02:05.414]                       inherits <- base::inherits
[11:02:05.414]                       invokeRestart <- base::invokeRestart
[11:02:05.414]                       is.null <- base::is.null
[11:02:05.414]                       muffled <- FALSE
[11:02:05.414]                       if (inherits(cond, "message")) {
[11:02:05.414]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.414]                         if (muffled) 
[11:02:05.414]                           invokeRestart("muffleMessage")
[11:02:05.414]                       }
[11:02:05.414]                       else if (inherits(cond, "warning")) {
[11:02:05.414]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.414]                         if (muffled) 
[11:02:05.414]                           invokeRestart("muffleWarning")
[11:02:05.414]                       }
[11:02:05.414]                       else if (inherits(cond, "condition")) {
[11:02:05.414]                         if (!is.null(pattern)) {
[11:02:05.414]                           computeRestarts <- base::computeRestarts
[11:02:05.414]                           grepl <- base::grepl
[11:02:05.414]                           restarts <- computeRestarts(cond)
[11:02:05.414]                           for (restart in restarts) {
[11:02:05.414]                             name <- restart$name
[11:02:05.414]                             if (is.null(name)) 
[11:02:05.414]                               next
[11:02:05.414]                             if (!grepl(pattern, name)) 
[11:02:05.414]                               next
[11:02:05.414]                             invokeRestart(restart)
[11:02:05.414]                             muffled <- TRUE
[11:02:05.414]                             break
[11:02:05.414]                           }
[11:02:05.414]                         }
[11:02:05.414]                       }
[11:02:05.414]                       invisible(muffled)
[11:02:05.414]                     }
[11:02:05.414]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.414]                   }
[11:02:05.414]                 }
[11:02:05.414]             }
[11:02:05.414]         }))
[11:02:05.414]     }, error = function(ex) {
[11:02:05.414]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:05.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.414]                 ...future.rng), started = ...future.startTime, 
[11:02:05.414]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:05.414]             version = "1.8"), class = "FutureResult")
[11:02:05.414]     }, finally = {
[11:02:05.414]         if (!identical(...future.workdir, getwd())) 
[11:02:05.414]             setwd(...future.workdir)
[11:02:05.414]         {
[11:02:05.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:05.414]                 ...future.oldOptions$nwarnings <- NULL
[11:02:05.414]             }
[11:02:05.414]             base::options(...future.oldOptions)
[11:02:05.414]             if (.Platform$OS.type == "windows") {
[11:02:05.414]                 old_names <- names(...future.oldEnvVars)
[11:02:05.414]                 envs <- base::Sys.getenv()
[11:02:05.414]                 names <- names(envs)
[11:02:05.414]                 common <- intersect(names, old_names)
[11:02:05.414]                 added <- setdiff(names, old_names)
[11:02:05.414]                 removed <- setdiff(old_names, names)
[11:02:05.414]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:05.414]                   envs[common]]
[11:02:05.414]                 NAMES <- toupper(changed)
[11:02:05.414]                 args <- list()
[11:02:05.414]                 for (kk in seq_along(NAMES)) {
[11:02:05.414]                   name <- changed[[kk]]
[11:02:05.414]                   NAME <- NAMES[[kk]]
[11:02:05.414]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.414]                     next
[11:02:05.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.414]                 }
[11:02:05.414]                 NAMES <- toupper(added)
[11:02:05.414]                 for (kk in seq_along(NAMES)) {
[11:02:05.414]                   name <- added[[kk]]
[11:02:05.414]                   NAME <- NAMES[[kk]]
[11:02:05.414]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.414]                     next
[11:02:05.414]                   args[[name]] <- ""
[11:02:05.414]                 }
[11:02:05.414]                 NAMES <- toupper(removed)
[11:02:05.414]                 for (kk in seq_along(NAMES)) {
[11:02:05.414]                   name <- removed[[kk]]
[11:02:05.414]                   NAME <- NAMES[[kk]]
[11:02:05.414]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.414]                     next
[11:02:05.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.414]                 }
[11:02:05.414]                 if (length(args) > 0) 
[11:02:05.414]                   base::do.call(base::Sys.setenv, args = args)
[11:02:05.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:05.414]             }
[11:02:05.414]             else {
[11:02:05.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:05.414]             }
[11:02:05.414]             {
[11:02:05.414]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:05.414]                   0L) {
[11:02:05.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:05.414]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:05.414]                   base::options(opts)
[11:02:05.414]                 }
[11:02:05.414]                 {
[11:02:05.414]                   {
[11:02:05.414]                     NULL
[11:02:05.414]                     RNGkind("Mersenne-Twister")
[11:02:05.414]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:05.414]                       inherits = FALSE)
[11:02:05.414]                   }
[11:02:05.414]                   options(future.plan = NULL)
[11:02:05.414]                   if (is.na(NA_character_)) 
[11:02:05.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:05.414]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:05.414]                     .init = FALSE)
[11:02:05.414]                 }
[11:02:05.414]             }
[11:02:05.414]         }
[11:02:05.414]     })
[11:02:05.414]     if (TRUE) {
[11:02:05.414]         base::sink(type = "output", split = FALSE)
[11:02:05.414]         if (TRUE) {
[11:02:05.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:05.414]         }
[11:02:05.414]         else {
[11:02:05.414]             ...future.result["stdout"] <- base::list(NULL)
[11:02:05.414]         }
[11:02:05.414]         base::close(...future.stdout)
[11:02:05.414]         ...future.stdout <- NULL
[11:02:05.414]     }
[11:02:05.414]     ...future.result$conditions <- ...future.conditions
[11:02:05.414]     ...future.result$finished <- base::Sys.time()
[11:02:05.414]     ...future.result
[11:02:05.414] }
[11:02:05.416] plan(): Setting new future strategy stack:
[11:02:05.416] List of future strategies:
[11:02:05.416] 1. sequential:
[11:02:05.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.416]    - tweaked: FALSE
[11:02:05.416]    - call: NULL
[11:02:05.416] plan(): nbrOfWorkers() = 1
[11:02:05.417] plan(): Setting new future strategy stack:
[11:02:05.417] List of future strategies:
[11:02:05.417] 1. sequential:
[11:02:05.417]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:05.417]    - tweaked: FALSE
[11:02:05.417]    - call: future::plan("sequential")
[11:02:05.417] plan(): nbrOfWorkers() = 1
[11:02:05.418] SequentialFuture started (and completed)
[11:02:05.418] signalConditions() ...
[11:02:05.418]  - include = ‘immediateCondition’
[11:02:05.418]  - exclude = 
[11:02:05.418]  - resignal = FALSE
[11:02:05.418]  - Number of conditions: 1
[11:02:05.418] signalConditions() ... done
[11:02:05.418] signalConditions() ...
[11:02:05.418]  - include = ‘immediateCondition’
[11:02:05.418]  - exclude = 
[11:02:05.418]  - resignal = FALSE
[11:02:05.418]  - Number of conditions: 1
[11:02:05.419] signalConditions() ... done
<MyError: boom>
[11:02:05.419] signalConditions() ...
[11:02:05.419]  - include = ‘immediateCondition’
[11:02:05.419]  - exclude = 
[11:02:05.419]  - resignal = FALSE
[11:02:05.420]  - Number of conditions: 1
[11:02:05.420] signalConditions() ... done
[11:02:05.420] Future state: ‘finished’
[11:02:05.421] signalConditions() ...
[11:02:05.421]  - include = ‘condition’
[11:02:05.421]  - exclude = ‘immediateCondition’
[11:02:05.421]  - resignal = TRUE
[11:02:05.421]  - Number of conditions: 1
[11:02:05.421]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[11:02:05.421] signalConditions() ... done
Testing with 1 cores ... DONE
Testing with 2 cores ...
[11:02:05.424] getGlobalsAndPackages() ...
[11:02:05.424] 
[11:02:05.424] - globals: [0] <none>
[11:02:05.424] getGlobalsAndPackages() ... DONE
[11:02:05.892] Packages needed by the future expression (n = 0): <none>
[11:02:05.892] Packages needed by future strategies (n = 0): <none>
[11:02:05.892] {
[11:02:05.892]     {
[11:02:05.892]         {
[11:02:05.892]             ...future.startTime <- base::Sys.time()
[11:02:05.892]             {
[11:02:05.892]                 {
[11:02:05.892]                   {
[11:02:05.892]                     {
[11:02:05.892]                       base::local({
[11:02:05.892]                         has_future <- base::requireNamespace("future", 
[11:02:05.892]                           quietly = TRUE)
[11:02:05.892]                         if (has_future) {
[11:02:05.892]                           ns <- base::getNamespace("future")
[11:02:05.892]                           version <- ns[[".package"]][["version"]]
[11:02:05.892]                           if (is.null(version)) 
[11:02:05.892]                             version <- utils::packageVersion("future")
[11:02:05.892]                         }
[11:02:05.892]                         else {
[11:02:05.892]                           version <- NULL
[11:02:05.892]                         }
[11:02:05.892]                         if (!has_future || version < "1.8.0") {
[11:02:05.892]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:05.892]                             "", base::R.version$version.string), 
[11:02:05.892]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:05.892]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:05.892]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:05.892]                               "release", "version")], collapse = " "), 
[11:02:05.892]                             hostname = base::Sys.info()[["nodename"]])
[11:02:05.892]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:05.892]                             info)
[11:02:05.892]                           info <- base::paste(info, collapse = "; ")
[11:02:05.892]                           if (!has_future) {
[11:02:05.892]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:05.892]                               info)
[11:02:05.892]                           }
[11:02:05.892]                           else {
[11:02:05.892]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:05.892]                               info, version)
[11:02:05.892]                           }
[11:02:05.892]                           base::stop(msg)
[11:02:05.892]                         }
[11:02:05.892]                       })
[11:02:05.892]                     }
[11:02:05.892]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:05.892]                     base::options(mc.cores = 1L)
[11:02:05.892]                   }
[11:02:05.892]                   ...future.strategy.old <- future::plan("list")
[11:02:05.892]                   options(future.plan = NULL)
[11:02:05.892]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.892]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:05.892]                 }
[11:02:05.892]                 ...future.workdir <- getwd()
[11:02:05.892]             }
[11:02:05.892]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:05.892]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:05.892]         }
[11:02:05.892]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:05.892]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:05.892]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:05.892]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:05.892]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:05.892]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:05.892]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:05.892]             base::names(...future.oldOptions))
[11:02:05.892]     }
[11:02:05.892]     if (FALSE) {
[11:02:05.892]     }
[11:02:05.892]     else {
[11:02:05.892]         if (TRUE) {
[11:02:05.892]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:05.892]                 open = "w")
[11:02:05.892]         }
[11:02:05.892]         else {
[11:02:05.892]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:05.892]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:05.892]         }
[11:02:05.892]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:05.892]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:05.892]             base::sink(type = "output", split = FALSE)
[11:02:05.892]             base::close(...future.stdout)
[11:02:05.892]         }, add = TRUE)
[11:02:05.892]     }
[11:02:05.892]     ...future.frame <- base::sys.nframe()
[11:02:05.892]     ...future.conditions <- base::list()
[11:02:05.892]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:05.892]     if (FALSE) {
[11:02:05.892]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:05.892]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:05.892]     }
[11:02:05.892]     ...future.result <- base::tryCatch({
[11:02:05.892]         base::withCallingHandlers({
[11:02:05.892]             ...future.value <- base::withVisible(base::local({
[11:02:05.892]                 ...future.makeSendCondition <- base::local({
[11:02:05.892]                   sendCondition <- NULL
[11:02:05.892]                   function(frame = 1L) {
[11:02:05.892]                     if (is.function(sendCondition)) 
[11:02:05.892]                       return(sendCondition)
[11:02:05.892]                     ns <- getNamespace("parallel")
[11:02:05.892]                     if (exists("sendData", mode = "function", 
[11:02:05.892]                       envir = ns)) {
[11:02:05.892]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:05.892]                         envir = ns)
[11:02:05.892]                       envir <- sys.frame(frame)
[11:02:05.892]                       master <- NULL
[11:02:05.892]                       while (!identical(envir, .GlobalEnv) && 
[11:02:05.892]                         !identical(envir, emptyenv())) {
[11:02:05.892]                         if (exists("master", mode = "list", envir = envir, 
[11:02:05.892]                           inherits = FALSE)) {
[11:02:05.892]                           master <- get("master", mode = "list", 
[11:02:05.892]                             envir = envir, inherits = FALSE)
[11:02:05.892]                           if (inherits(master, c("SOCKnode", 
[11:02:05.892]                             "SOCK0node"))) {
[11:02:05.892]                             sendCondition <<- function(cond) {
[11:02:05.892]                               data <- list(type = "VALUE", value = cond, 
[11:02:05.892]                                 success = TRUE)
[11:02:05.892]                               parallel_sendData(master, data)
[11:02:05.892]                             }
[11:02:05.892]                             return(sendCondition)
[11:02:05.892]                           }
[11:02:05.892]                         }
[11:02:05.892]                         frame <- frame + 1L
[11:02:05.892]                         envir <- sys.frame(frame)
[11:02:05.892]                       }
[11:02:05.892]                     }
[11:02:05.892]                     sendCondition <<- function(cond) NULL
[11:02:05.892]                   }
[11:02:05.892]                 })
[11:02:05.892]                 withCallingHandlers({
[11:02:05.892]                   {
[11:02:05.892]                     42L
[11:02:05.892]                   }
[11:02:05.892]                 }, immediateCondition = function(cond) {
[11:02:05.892]                   sendCondition <- ...future.makeSendCondition()
[11:02:05.892]                   sendCondition(cond)
[11:02:05.892]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.892]                   {
[11:02:05.892]                     inherits <- base::inherits
[11:02:05.892]                     invokeRestart <- base::invokeRestart
[11:02:05.892]                     is.null <- base::is.null
[11:02:05.892]                     muffled <- FALSE
[11:02:05.892]                     if (inherits(cond, "message")) {
[11:02:05.892]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:05.892]                       if (muffled) 
[11:02:05.892]                         invokeRestart("muffleMessage")
[11:02:05.892]                     }
[11:02:05.892]                     else if (inherits(cond, "warning")) {
[11:02:05.892]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:05.892]                       if (muffled) 
[11:02:05.892]                         invokeRestart("muffleWarning")
[11:02:05.892]                     }
[11:02:05.892]                     else if (inherits(cond, "condition")) {
[11:02:05.892]                       if (!is.null(pattern)) {
[11:02:05.892]                         computeRestarts <- base::computeRestarts
[11:02:05.892]                         grepl <- base::grepl
[11:02:05.892]                         restarts <- computeRestarts(cond)
[11:02:05.892]                         for (restart in restarts) {
[11:02:05.892]                           name <- restart$name
[11:02:05.892]                           if (is.null(name)) 
[11:02:05.892]                             next
[11:02:05.892]                           if (!grepl(pattern, name)) 
[11:02:05.892]                             next
[11:02:05.892]                           invokeRestart(restart)
[11:02:05.892]                           muffled <- TRUE
[11:02:05.892]                           break
[11:02:05.892]                         }
[11:02:05.892]                       }
[11:02:05.892]                     }
[11:02:05.892]                     invisible(muffled)
[11:02:05.892]                   }
[11:02:05.892]                   muffleCondition(cond)
[11:02:05.892]                 })
[11:02:05.892]             }))
[11:02:05.892]             future::FutureResult(value = ...future.value$value, 
[11:02:05.892]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.892]                   ...future.rng), globalenv = if (FALSE) 
[11:02:05.892]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:05.892]                     ...future.globalenv.names))
[11:02:05.892]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:05.892]         }, condition = base::local({
[11:02:05.892]             c <- base::c
[11:02:05.892]             inherits <- base::inherits
[11:02:05.892]             invokeRestart <- base::invokeRestart
[11:02:05.892]             length <- base::length
[11:02:05.892]             list <- base::list
[11:02:05.892]             seq.int <- base::seq.int
[11:02:05.892]             signalCondition <- base::signalCondition
[11:02:05.892]             sys.calls <- base::sys.calls
[11:02:05.892]             `[[` <- base::`[[`
[11:02:05.892]             `+` <- base::`+`
[11:02:05.892]             `<<-` <- base::`<<-`
[11:02:05.892]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:05.892]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:05.892]                   3L)]
[11:02:05.892]             }
[11:02:05.892]             function(cond) {
[11:02:05.892]                 is_error <- inherits(cond, "error")
[11:02:05.892]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:05.892]                   NULL)
[11:02:05.892]                 if (is_error) {
[11:02:05.892]                   sessionInformation <- function() {
[11:02:05.892]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:05.892]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:05.892]                       search = base::search(), system = base::Sys.info())
[11:02:05.892]                   }
[11:02:05.892]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.892]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:05.892]                     cond$call), session = sessionInformation(), 
[11:02:05.892]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:05.892]                   signalCondition(cond)
[11:02:05.892]                 }
[11:02:05.892]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:05.892]                 "immediateCondition"))) {
[11:02:05.892]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:05.892]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.892]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:05.892]                   if (TRUE && !signal) {
[11:02:05.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.892]                     {
[11:02:05.892]                       inherits <- base::inherits
[11:02:05.892]                       invokeRestart <- base::invokeRestart
[11:02:05.892]                       is.null <- base::is.null
[11:02:05.892]                       muffled <- FALSE
[11:02:05.892]                       if (inherits(cond, "message")) {
[11:02:05.892]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.892]                         if (muffled) 
[11:02:05.892]                           invokeRestart("muffleMessage")
[11:02:05.892]                       }
[11:02:05.892]                       else if (inherits(cond, "warning")) {
[11:02:05.892]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.892]                         if (muffled) 
[11:02:05.892]                           invokeRestart("muffleWarning")
[11:02:05.892]                       }
[11:02:05.892]                       else if (inherits(cond, "condition")) {
[11:02:05.892]                         if (!is.null(pattern)) {
[11:02:05.892]                           computeRestarts <- base::computeRestarts
[11:02:05.892]                           grepl <- base::grepl
[11:02:05.892]                           restarts <- computeRestarts(cond)
[11:02:05.892]                           for (restart in restarts) {
[11:02:05.892]                             name <- restart$name
[11:02:05.892]                             if (is.null(name)) 
[11:02:05.892]                               next
[11:02:05.892]                             if (!grepl(pattern, name)) 
[11:02:05.892]                               next
[11:02:05.892]                             invokeRestart(restart)
[11:02:05.892]                             muffled <- TRUE
[11:02:05.892]                             break
[11:02:05.892]                           }
[11:02:05.892]                         }
[11:02:05.892]                       }
[11:02:05.892]                       invisible(muffled)
[11:02:05.892]                     }
[11:02:05.892]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.892]                   }
[11:02:05.892]                 }
[11:02:05.892]                 else {
[11:02:05.892]                   if (TRUE) {
[11:02:05.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.892]                     {
[11:02:05.892]                       inherits <- base::inherits
[11:02:05.892]                       invokeRestart <- base::invokeRestart
[11:02:05.892]                       is.null <- base::is.null
[11:02:05.892]                       muffled <- FALSE
[11:02:05.892]                       if (inherits(cond, "message")) {
[11:02:05.892]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.892]                         if (muffled) 
[11:02:05.892]                           invokeRestart("muffleMessage")
[11:02:05.892]                       }
[11:02:05.892]                       else if (inherits(cond, "warning")) {
[11:02:05.892]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.892]                         if (muffled) 
[11:02:05.892]                           invokeRestart("muffleWarning")
[11:02:05.892]                       }
[11:02:05.892]                       else if (inherits(cond, "condition")) {
[11:02:05.892]                         if (!is.null(pattern)) {
[11:02:05.892]                           computeRestarts <- base::computeRestarts
[11:02:05.892]                           grepl <- base::grepl
[11:02:05.892]                           restarts <- computeRestarts(cond)
[11:02:05.892]                           for (restart in restarts) {
[11:02:05.892]                             name <- restart$name
[11:02:05.892]                             if (is.null(name)) 
[11:02:05.892]                               next
[11:02:05.892]                             if (!grepl(pattern, name)) 
[11:02:05.892]                               next
[11:02:05.892]                             invokeRestart(restart)
[11:02:05.892]                             muffled <- TRUE
[11:02:05.892]                             break
[11:02:05.892]                           }
[11:02:05.892]                         }
[11:02:05.892]                       }
[11:02:05.892]                       invisible(muffled)
[11:02:05.892]                     }
[11:02:05.892]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.892]                   }
[11:02:05.892]                 }
[11:02:05.892]             }
[11:02:05.892]         }))
[11:02:05.892]     }, error = function(ex) {
[11:02:05.892]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:05.892]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.892]                 ...future.rng), started = ...future.startTime, 
[11:02:05.892]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:05.892]             version = "1.8"), class = "FutureResult")
[11:02:05.892]     }, finally = {
[11:02:05.892]         if (!identical(...future.workdir, getwd())) 
[11:02:05.892]             setwd(...future.workdir)
[11:02:05.892]         {
[11:02:05.892]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:05.892]                 ...future.oldOptions$nwarnings <- NULL
[11:02:05.892]             }
[11:02:05.892]             base::options(...future.oldOptions)
[11:02:05.892]             if (.Platform$OS.type == "windows") {
[11:02:05.892]                 old_names <- names(...future.oldEnvVars)
[11:02:05.892]                 envs <- base::Sys.getenv()
[11:02:05.892]                 names <- names(envs)
[11:02:05.892]                 common <- intersect(names, old_names)
[11:02:05.892]                 added <- setdiff(names, old_names)
[11:02:05.892]                 removed <- setdiff(old_names, names)
[11:02:05.892]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:05.892]                   envs[common]]
[11:02:05.892]                 NAMES <- toupper(changed)
[11:02:05.892]                 args <- list()
[11:02:05.892]                 for (kk in seq_along(NAMES)) {
[11:02:05.892]                   name <- changed[[kk]]
[11:02:05.892]                   NAME <- NAMES[[kk]]
[11:02:05.892]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.892]                     next
[11:02:05.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.892]                 }
[11:02:05.892]                 NAMES <- toupper(added)
[11:02:05.892]                 for (kk in seq_along(NAMES)) {
[11:02:05.892]                   name <- added[[kk]]
[11:02:05.892]                   NAME <- NAMES[[kk]]
[11:02:05.892]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.892]                     next
[11:02:05.892]                   args[[name]] <- ""
[11:02:05.892]                 }
[11:02:05.892]                 NAMES <- toupper(removed)
[11:02:05.892]                 for (kk in seq_along(NAMES)) {
[11:02:05.892]                   name <- removed[[kk]]
[11:02:05.892]                   NAME <- NAMES[[kk]]
[11:02:05.892]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.892]                     next
[11:02:05.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.892]                 }
[11:02:05.892]                 if (length(args) > 0) 
[11:02:05.892]                   base::do.call(base::Sys.setenv, args = args)
[11:02:05.892]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:05.892]             }
[11:02:05.892]             else {
[11:02:05.892]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:05.892]             }
[11:02:05.892]             {
[11:02:05.892]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:05.892]                   0L) {
[11:02:05.892]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:05.892]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:05.892]                   base::options(opts)
[11:02:05.892]                 }
[11:02:05.892]                 {
[11:02:05.892]                   {
[11:02:05.892]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:05.892]                     NULL
[11:02:05.892]                   }
[11:02:05.892]                   options(future.plan = NULL)
[11:02:05.892]                   if (is.na(NA_character_)) 
[11:02:05.892]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.892]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:05.892]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:05.892]                     .init = FALSE)
[11:02:05.892]                 }
[11:02:05.892]             }
[11:02:05.892]         }
[11:02:05.892]     })
[11:02:05.892]     if (TRUE) {
[11:02:05.892]         base::sink(type = "output", split = FALSE)
[11:02:05.892]         if (TRUE) {
[11:02:05.892]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:05.892]         }
[11:02:05.892]         else {
[11:02:05.892]             ...future.result["stdout"] <- base::list(NULL)
[11:02:05.892]         }
[11:02:05.892]         base::close(...future.stdout)
[11:02:05.892]         ...future.stdout <- NULL
[11:02:05.892]     }
[11:02:05.892]     ...future.result$conditions <- ...future.conditions
[11:02:05.892]     ...future.result$finished <- base::Sys.time()
[11:02:05.892]     ...future.result
[11:02:05.892] }
[11:02:05.943] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d252f3dd-7a92-6ee4-db84-2a586bbc6302
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] FALSE
[11:02:05.966] result() for ClusterFuture ...
[11:02:05.966] receiveMessageFromWorker() for ClusterFuture ...
[11:02:05.967] - Validating connection of MultisessionFuture
[11:02:05.975] - received message: FutureResult
[11:02:05.976] - Received FutureResult
[11:02:05.978] - Erased future from FutureRegistry
[11:02:05.978] result() for ClusterFuture ...
[11:02:05.978] - result already collected: FutureResult
[11:02:05.978] result() for ClusterFuture ... done
[11:02:05.978] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:05.978] result() for ClusterFuture ... done
[11:02:05.979] result() for ClusterFuture ...
[11:02:05.979] - result already collected: FutureResult
[11:02:05.979] result() for ClusterFuture ... done
[1] 42
[11:02:05.980] getGlobalsAndPackages() ...
[11:02:05.980] Searching for globals...
[11:02:05.982] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[11:02:05.982] Searching for globals ... DONE
[11:02:05.982] Resolving globals: FALSE
[11:02:05.983] The total size of the 1 globals is 39 bytes (39 bytes)
[11:02:05.983] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:02:05.983] - globals: [1] ‘a’
[11:02:05.983] 
[11:02:05.983] getGlobalsAndPackages() ... DONE
[11:02:05.996] Packages needed by the future expression (n = 0): <none>
[11:02:05.996] Packages needed by future strategies (n = 0): <none>
[11:02:05.996] {
[11:02:05.996]     {
[11:02:05.996]         {
[11:02:05.996]             ...future.startTime <- base::Sys.time()
[11:02:05.996]             {
[11:02:05.996]                 {
[11:02:05.996]                   {
[11:02:05.996]                     {
[11:02:05.996]                       base::local({
[11:02:05.996]                         has_future <- base::requireNamespace("future", 
[11:02:05.996]                           quietly = TRUE)
[11:02:05.996]                         if (has_future) {
[11:02:05.996]                           ns <- base::getNamespace("future")
[11:02:05.996]                           version <- ns[[".package"]][["version"]]
[11:02:05.996]                           if (is.null(version)) 
[11:02:05.996]                             version <- utils::packageVersion("future")
[11:02:05.996]                         }
[11:02:05.996]                         else {
[11:02:05.996]                           version <- NULL
[11:02:05.996]                         }
[11:02:05.996]                         if (!has_future || version < "1.8.0") {
[11:02:05.996]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:05.996]                             "", base::R.version$version.string), 
[11:02:05.996]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:05.996]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:05.996]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:05.996]                               "release", "version")], collapse = " "), 
[11:02:05.996]                             hostname = base::Sys.info()[["nodename"]])
[11:02:05.996]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:05.996]                             info)
[11:02:05.996]                           info <- base::paste(info, collapse = "; ")
[11:02:05.996]                           if (!has_future) {
[11:02:05.996]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:05.996]                               info)
[11:02:05.996]                           }
[11:02:05.996]                           else {
[11:02:05.996]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:05.996]                               info, version)
[11:02:05.996]                           }
[11:02:05.996]                           base::stop(msg)
[11:02:05.996]                         }
[11:02:05.996]                       })
[11:02:05.996]                     }
[11:02:05.996]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:05.996]                     base::options(mc.cores = 1L)
[11:02:05.996]                   }
[11:02:05.996]                   ...future.strategy.old <- future::plan("list")
[11:02:05.996]                   options(future.plan = NULL)
[11:02:05.996]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.996]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:05.996]                 }
[11:02:05.996]                 ...future.workdir <- getwd()
[11:02:05.996]             }
[11:02:05.996]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:05.996]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:05.996]         }
[11:02:05.996]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:05.996]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:05.996]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:05.996]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:05.996]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:05.996]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:05.996]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:05.996]             base::names(...future.oldOptions))
[11:02:05.996]     }
[11:02:05.996]     if (FALSE) {
[11:02:05.996]     }
[11:02:05.996]     else {
[11:02:05.996]         if (TRUE) {
[11:02:05.996]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:05.996]                 open = "w")
[11:02:05.996]         }
[11:02:05.996]         else {
[11:02:05.996]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:05.996]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:05.996]         }
[11:02:05.996]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:05.996]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:05.996]             base::sink(type = "output", split = FALSE)
[11:02:05.996]             base::close(...future.stdout)
[11:02:05.996]         }, add = TRUE)
[11:02:05.996]     }
[11:02:05.996]     ...future.frame <- base::sys.nframe()
[11:02:05.996]     ...future.conditions <- base::list()
[11:02:05.996]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:05.996]     if (FALSE) {
[11:02:05.996]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:05.996]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:05.996]     }
[11:02:05.996]     ...future.result <- base::tryCatch({
[11:02:05.996]         base::withCallingHandlers({
[11:02:05.996]             ...future.value <- base::withVisible(base::local({
[11:02:05.996]                 ...future.makeSendCondition <- base::local({
[11:02:05.996]                   sendCondition <- NULL
[11:02:05.996]                   function(frame = 1L) {
[11:02:05.996]                     if (is.function(sendCondition)) 
[11:02:05.996]                       return(sendCondition)
[11:02:05.996]                     ns <- getNamespace("parallel")
[11:02:05.996]                     if (exists("sendData", mode = "function", 
[11:02:05.996]                       envir = ns)) {
[11:02:05.996]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:05.996]                         envir = ns)
[11:02:05.996]                       envir <- sys.frame(frame)
[11:02:05.996]                       master <- NULL
[11:02:05.996]                       while (!identical(envir, .GlobalEnv) && 
[11:02:05.996]                         !identical(envir, emptyenv())) {
[11:02:05.996]                         if (exists("master", mode = "list", envir = envir, 
[11:02:05.996]                           inherits = FALSE)) {
[11:02:05.996]                           master <- get("master", mode = "list", 
[11:02:05.996]                             envir = envir, inherits = FALSE)
[11:02:05.996]                           if (inherits(master, c("SOCKnode", 
[11:02:05.996]                             "SOCK0node"))) {
[11:02:05.996]                             sendCondition <<- function(cond) {
[11:02:05.996]                               data <- list(type = "VALUE", value = cond, 
[11:02:05.996]                                 success = TRUE)
[11:02:05.996]                               parallel_sendData(master, data)
[11:02:05.996]                             }
[11:02:05.996]                             return(sendCondition)
[11:02:05.996]                           }
[11:02:05.996]                         }
[11:02:05.996]                         frame <- frame + 1L
[11:02:05.996]                         envir <- sys.frame(frame)
[11:02:05.996]                       }
[11:02:05.996]                     }
[11:02:05.996]                     sendCondition <<- function(cond) NULL
[11:02:05.996]                   }
[11:02:05.996]                 })
[11:02:05.996]                 withCallingHandlers({
[11:02:05.996]                   {
[11:02:05.996]                     b <- 3
[11:02:05.996]                     c <- 2
[11:02:05.996]                     a * b * c
[11:02:05.996]                   }
[11:02:05.996]                 }, immediateCondition = function(cond) {
[11:02:05.996]                   sendCondition <- ...future.makeSendCondition()
[11:02:05.996]                   sendCondition(cond)
[11:02:05.996]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.996]                   {
[11:02:05.996]                     inherits <- base::inherits
[11:02:05.996]                     invokeRestart <- base::invokeRestart
[11:02:05.996]                     is.null <- base::is.null
[11:02:05.996]                     muffled <- FALSE
[11:02:05.996]                     if (inherits(cond, "message")) {
[11:02:05.996]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:05.996]                       if (muffled) 
[11:02:05.996]                         invokeRestart("muffleMessage")
[11:02:05.996]                     }
[11:02:05.996]                     else if (inherits(cond, "warning")) {
[11:02:05.996]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:05.996]                       if (muffled) 
[11:02:05.996]                         invokeRestart("muffleWarning")
[11:02:05.996]                     }
[11:02:05.996]                     else if (inherits(cond, "condition")) {
[11:02:05.996]                       if (!is.null(pattern)) {
[11:02:05.996]                         computeRestarts <- base::computeRestarts
[11:02:05.996]                         grepl <- base::grepl
[11:02:05.996]                         restarts <- computeRestarts(cond)
[11:02:05.996]                         for (restart in restarts) {
[11:02:05.996]                           name <- restart$name
[11:02:05.996]                           if (is.null(name)) 
[11:02:05.996]                             next
[11:02:05.996]                           if (!grepl(pattern, name)) 
[11:02:05.996]                             next
[11:02:05.996]                           invokeRestart(restart)
[11:02:05.996]                           muffled <- TRUE
[11:02:05.996]                           break
[11:02:05.996]                         }
[11:02:05.996]                       }
[11:02:05.996]                     }
[11:02:05.996]                     invisible(muffled)
[11:02:05.996]                   }
[11:02:05.996]                   muffleCondition(cond)
[11:02:05.996]                 })
[11:02:05.996]             }))
[11:02:05.996]             future::FutureResult(value = ...future.value$value, 
[11:02:05.996]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.996]                   ...future.rng), globalenv = if (FALSE) 
[11:02:05.996]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:05.996]                     ...future.globalenv.names))
[11:02:05.996]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:05.996]         }, condition = base::local({
[11:02:05.996]             c <- base::c
[11:02:05.996]             inherits <- base::inherits
[11:02:05.996]             invokeRestart <- base::invokeRestart
[11:02:05.996]             length <- base::length
[11:02:05.996]             list <- base::list
[11:02:05.996]             seq.int <- base::seq.int
[11:02:05.996]             signalCondition <- base::signalCondition
[11:02:05.996]             sys.calls <- base::sys.calls
[11:02:05.996]             `[[` <- base::`[[`
[11:02:05.996]             `+` <- base::`+`
[11:02:05.996]             `<<-` <- base::`<<-`
[11:02:05.996]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:05.996]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:05.996]                   3L)]
[11:02:05.996]             }
[11:02:05.996]             function(cond) {
[11:02:05.996]                 is_error <- inherits(cond, "error")
[11:02:05.996]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:05.996]                   NULL)
[11:02:05.996]                 if (is_error) {
[11:02:05.996]                   sessionInformation <- function() {
[11:02:05.996]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:05.996]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:05.996]                       search = base::search(), system = base::Sys.info())
[11:02:05.996]                   }
[11:02:05.996]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.996]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:05.996]                     cond$call), session = sessionInformation(), 
[11:02:05.996]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:05.996]                   signalCondition(cond)
[11:02:05.996]                 }
[11:02:05.996]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:05.996]                 "immediateCondition"))) {
[11:02:05.996]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:05.996]                   ...future.conditions[[length(...future.conditions) + 
[11:02:05.996]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:05.996]                   if (TRUE && !signal) {
[11:02:05.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.996]                     {
[11:02:05.996]                       inherits <- base::inherits
[11:02:05.996]                       invokeRestart <- base::invokeRestart
[11:02:05.996]                       is.null <- base::is.null
[11:02:05.996]                       muffled <- FALSE
[11:02:05.996]                       if (inherits(cond, "message")) {
[11:02:05.996]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.996]                         if (muffled) 
[11:02:05.996]                           invokeRestart("muffleMessage")
[11:02:05.996]                       }
[11:02:05.996]                       else if (inherits(cond, "warning")) {
[11:02:05.996]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.996]                         if (muffled) 
[11:02:05.996]                           invokeRestart("muffleWarning")
[11:02:05.996]                       }
[11:02:05.996]                       else if (inherits(cond, "condition")) {
[11:02:05.996]                         if (!is.null(pattern)) {
[11:02:05.996]                           computeRestarts <- base::computeRestarts
[11:02:05.996]                           grepl <- base::grepl
[11:02:05.996]                           restarts <- computeRestarts(cond)
[11:02:05.996]                           for (restart in restarts) {
[11:02:05.996]                             name <- restart$name
[11:02:05.996]                             if (is.null(name)) 
[11:02:05.996]                               next
[11:02:05.996]                             if (!grepl(pattern, name)) 
[11:02:05.996]                               next
[11:02:05.996]                             invokeRestart(restart)
[11:02:05.996]                             muffled <- TRUE
[11:02:05.996]                             break
[11:02:05.996]                           }
[11:02:05.996]                         }
[11:02:05.996]                       }
[11:02:05.996]                       invisible(muffled)
[11:02:05.996]                     }
[11:02:05.996]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.996]                   }
[11:02:05.996]                 }
[11:02:05.996]                 else {
[11:02:05.996]                   if (TRUE) {
[11:02:05.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:05.996]                     {
[11:02:05.996]                       inherits <- base::inherits
[11:02:05.996]                       invokeRestart <- base::invokeRestart
[11:02:05.996]                       is.null <- base::is.null
[11:02:05.996]                       muffled <- FALSE
[11:02:05.996]                       if (inherits(cond, "message")) {
[11:02:05.996]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:05.996]                         if (muffled) 
[11:02:05.996]                           invokeRestart("muffleMessage")
[11:02:05.996]                       }
[11:02:05.996]                       else if (inherits(cond, "warning")) {
[11:02:05.996]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:05.996]                         if (muffled) 
[11:02:05.996]                           invokeRestart("muffleWarning")
[11:02:05.996]                       }
[11:02:05.996]                       else if (inherits(cond, "condition")) {
[11:02:05.996]                         if (!is.null(pattern)) {
[11:02:05.996]                           computeRestarts <- base::computeRestarts
[11:02:05.996]                           grepl <- base::grepl
[11:02:05.996]                           restarts <- computeRestarts(cond)
[11:02:05.996]                           for (restart in restarts) {
[11:02:05.996]                             name <- restart$name
[11:02:05.996]                             if (is.null(name)) 
[11:02:05.996]                               next
[11:02:05.996]                             if (!grepl(pattern, name)) 
[11:02:05.996]                               next
[11:02:05.996]                             invokeRestart(restart)
[11:02:05.996]                             muffled <- TRUE
[11:02:05.996]                             break
[11:02:05.996]                           }
[11:02:05.996]                         }
[11:02:05.996]                       }
[11:02:05.996]                       invisible(muffled)
[11:02:05.996]                     }
[11:02:05.996]                     muffleCondition(cond, pattern = "^muffle")
[11:02:05.996]                   }
[11:02:05.996]                 }
[11:02:05.996]             }
[11:02:05.996]         }))
[11:02:05.996]     }, error = function(ex) {
[11:02:05.996]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:05.996]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:05.996]                 ...future.rng), started = ...future.startTime, 
[11:02:05.996]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:05.996]             version = "1.8"), class = "FutureResult")
[11:02:05.996]     }, finally = {
[11:02:05.996]         if (!identical(...future.workdir, getwd())) 
[11:02:05.996]             setwd(...future.workdir)
[11:02:05.996]         {
[11:02:05.996]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:05.996]                 ...future.oldOptions$nwarnings <- NULL
[11:02:05.996]             }
[11:02:05.996]             base::options(...future.oldOptions)
[11:02:05.996]             if (.Platform$OS.type == "windows") {
[11:02:05.996]                 old_names <- names(...future.oldEnvVars)
[11:02:05.996]                 envs <- base::Sys.getenv()
[11:02:05.996]                 names <- names(envs)
[11:02:05.996]                 common <- intersect(names, old_names)
[11:02:05.996]                 added <- setdiff(names, old_names)
[11:02:05.996]                 removed <- setdiff(old_names, names)
[11:02:05.996]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:05.996]                   envs[common]]
[11:02:05.996]                 NAMES <- toupper(changed)
[11:02:05.996]                 args <- list()
[11:02:05.996]                 for (kk in seq_along(NAMES)) {
[11:02:05.996]                   name <- changed[[kk]]
[11:02:05.996]                   NAME <- NAMES[[kk]]
[11:02:05.996]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.996]                     next
[11:02:05.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.996]                 }
[11:02:05.996]                 NAMES <- toupper(added)
[11:02:05.996]                 for (kk in seq_along(NAMES)) {
[11:02:05.996]                   name <- added[[kk]]
[11:02:05.996]                   NAME <- NAMES[[kk]]
[11:02:05.996]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.996]                     next
[11:02:05.996]                   args[[name]] <- ""
[11:02:05.996]                 }
[11:02:05.996]                 NAMES <- toupper(removed)
[11:02:05.996]                 for (kk in seq_along(NAMES)) {
[11:02:05.996]                   name <- removed[[kk]]
[11:02:05.996]                   NAME <- NAMES[[kk]]
[11:02:05.996]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:05.996]                     next
[11:02:05.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:05.996]                 }
[11:02:05.996]                 if (length(args) > 0) 
[11:02:05.996]                   base::do.call(base::Sys.setenv, args = args)
[11:02:05.996]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:05.996]             }
[11:02:05.996]             else {
[11:02:05.996]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:05.996]             }
[11:02:05.996]             {
[11:02:05.996]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:05.996]                   0L) {
[11:02:05.996]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:05.996]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:05.996]                   base::options(opts)
[11:02:05.996]                 }
[11:02:05.996]                 {
[11:02:05.996]                   {
[11:02:05.996]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:05.996]                     NULL
[11:02:05.996]                   }
[11:02:05.996]                   options(future.plan = NULL)
[11:02:05.996]                   if (is.na(NA_character_)) 
[11:02:05.996]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:05.996]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:05.996]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:05.996]                     .init = FALSE)
[11:02:05.996]                 }
[11:02:05.996]             }
[11:02:05.996]         }
[11:02:05.996]     })
[11:02:05.996]     if (TRUE) {
[11:02:05.996]         base::sink(type = "output", split = FALSE)
[11:02:05.996]         if (TRUE) {
[11:02:05.996]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:05.996]         }
[11:02:05.996]         else {
[11:02:05.996]             ...future.result["stdout"] <- base::list(NULL)
[11:02:05.996]         }
[11:02:05.996]         base::close(...future.stdout)
[11:02:05.996]         ...future.stdout <- NULL
[11:02:05.996]     }
[11:02:05.996]     ...future.result$conditions <- ...future.conditions
[11:02:05.996]     ...future.result$finished <- base::Sys.time()
[11:02:05.996]     ...future.result
[11:02:05.996] }
[11:02:05.999] Exporting 1 global objects (306 bytes) to cluster node #1 ...
[11:02:05.999] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:02:05.999] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:02:06.000] Exporting 1 global objects (306 bytes) to cluster node #1 ... DONE
[11:02:06.000] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 39 bytes (numeric ‘a’ of 39 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d252f3dd-7a92-6ee4-db84-2a586bbc6302
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:06.011] result() for ClusterFuture ...
[11:02:06.011] receiveMessageFromWorker() for ClusterFuture ...
[11:02:06.012] - Validating connection of MultisessionFuture
[11:02:06.042] - received message: FutureResult
[11:02:06.042] - Received FutureResult
[11:02:06.042] - Erased future from FutureRegistry
[11:02:06.042] result() for ClusterFuture ...
[11:02:06.042] - result already collected: FutureResult
[11:02:06.043] result() for ClusterFuture ... done
[11:02:06.043] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:06.043] result() for ClusterFuture ... done
[11:02:06.043] result() for ClusterFuture ...
[11:02:06.043] - result already collected: FutureResult
[11:02:06.043] result() for ClusterFuture ... done
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[11:02:06.044] getGlobalsAndPackages() ...
[11:02:06.045] Searching for globals...
[11:02:06.045] - globals found: [2] ‘{’, ‘ii’
[11:02:06.045] Searching for globals ... DONE
[11:02:06.045] Resolving globals: FALSE
[11:02:06.046] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:06.046] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:02:06.046] - globals: [1] ‘ii’
[11:02:06.046] 
[11:02:06.046] getGlobalsAndPackages() ... DONE
[11:02:06.062] Packages needed by the future expression (n = 0): <none>
[11:02:06.062] Packages needed by future strategies (n = 0): <none>
[11:02:06.062] {
[11:02:06.062]     {
[11:02:06.062]         {
[11:02:06.062]             ...future.startTime <- base::Sys.time()
[11:02:06.062]             {
[11:02:06.062]                 {
[11:02:06.062]                   {
[11:02:06.062]                     {
[11:02:06.062]                       base::local({
[11:02:06.062]                         has_future <- base::requireNamespace("future", 
[11:02:06.062]                           quietly = TRUE)
[11:02:06.062]                         if (has_future) {
[11:02:06.062]                           ns <- base::getNamespace("future")
[11:02:06.062]                           version <- ns[[".package"]][["version"]]
[11:02:06.062]                           if (is.null(version)) 
[11:02:06.062]                             version <- utils::packageVersion("future")
[11:02:06.062]                         }
[11:02:06.062]                         else {
[11:02:06.062]                           version <- NULL
[11:02:06.062]                         }
[11:02:06.062]                         if (!has_future || version < "1.8.0") {
[11:02:06.062]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:06.062]                             "", base::R.version$version.string), 
[11:02:06.062]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:06.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:06.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:06.062]                               "release", "version")], collapse = " "), 
[11:02:06.062]                             hostname = base::Sys.info()[["nodename"]])
[11:02:06.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:06.062]                             info)
[11:02:06.062]                           info <- base::paste(info, collapse = "; ")
[11:02:06.062]                           if (!has_future) {
[11:02:06.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:06.062]                               info)
[11:02:06.062]                           }
[11:02:06.062]                           else {
[11:02:06.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:06.062]                               info, version)
[11:02:06.062]                           }
[11:02:06.062]                           base::stop(msg)
[11:02:06.062]                         }
[11:02:06.062]                       })
[11:02:06.062]                     }
[11:02:06.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:06.062]                     base::options(mc.cores = 1L)
[11:02:06.062]                   }
[11:02:06.062]                   ...future.strategy.old <- future::plan("list")
[11:02:06.062]                   options(future.plan = NULL)
[11:02:06.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:06.062]                 }
[11:02:06.062]                 ...future.workdir <- getwd()
[11:02:06.062]             }
[11:02:06.062]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:06.062]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:06.062]         }
[11:02:06.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:06.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:06.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:06.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:06.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:06.062]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:06.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:06.062]             base::names(...future.oldOptions))
[11:02:06.062]     }
[11:02:06.062]     if (FALSE) {
[11:02:06.062]     }
[11:02:06.062]     else {
[11:02:06.062]         if (TRUE) {
[11:02:06.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:06.062]                 open = "w")
[11:02:06.062]         }
[11:02:06.062]         else {
[11:02:06.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:06.062]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:06.062]         }
[11:02:06.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:06.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:06.062]             base::sink(type = "output", split = FALSE)
[11:02:06.062]             base::close(...future.stdout)
[11:02:06.062]         }, add = TRUE)
[11:02:06.062]     }
[11:02:06.062]     ...future.frame <- base::sys.nframe()
[11:02:06.062]     ...future.conditions <- base::list()
[11:02:06.062]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:06.062]     if (FALSE) {
[11:02:06.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:06.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:06.062]     }
[11:02:06.062]     ...future.result <- base::tryCatch({
[11:02:06.062]         base::withCallingHandlers({
[11:02:06.062]             ...future.value <- base::withVisible(base::local({
[11:02:06.062]                 ...future.makeSendCondition <- base::local({
[11:02:06.062]                   sendCondition <- NULL
[11:02:06.062]                   function(frame = 1L) {
[11:02:06.062]                     if (is.function(sendCondition)) 
[11:02:06.062]                       return(sendCondition)
[11:02:06.062]                     ns <- getNamespace("parallel")
[11:02:06.062]                     if (exists("sendData", mode = "function", 
[11:02:06.062]                       envir = ns)) {
[11:02:06.062]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:06.062]                         envir = ns)
[11:02:06.062]                       envir <- sys.frame(frame)
[11:02:06.062]                       master <- NULL
[11:02:06.062]                       while (!identical(envir, .GlobalEnv) && 
[11:02:06.062]                         !identical(envir, emptyenv())) {
[11:02:06.062]                         if (exists("master", mode = "list", envir = envir, 
[11:02:06.062]                           inherits = FALSE)) {
[11:02:06.062]                           master <- get("master", mode = "list", 
[11:02:06.062]                             envir = envir, inherits = FALSE)
[11:02:06.062]                           if (inherits(master, c("SOCKnode", 
[11:02:06.062]                             "SOCK0node"))) {
[11:02:06.062]                             sendCondition <<- function(cond) {
[11:02:06.062]                               data <- list(type = "VALUE", value = cond, 
[11:02:06.062]                                 success = TRUE)
[11:02:06.062]                               parallel_sendData(master, data)
[11:02:06.062]                             }
[11:02:06.062]                             return(sendCondition)
[11:02:06.062]                           }
[11:02:06.062]                         }
[11:02:06.062]                         frame <- frame + 1L
[11:02:06.062]                         envir <- sys.frame(frame)
[11:02:06.062]                       }
[11:02:06.062]                     }
[11:02:06.062]                     sendCondition <<- function(cond) NULL
[11:02:06.062]                   }
[11:02:06.062]                 })
[11:02:06.062]                 withCallingHandlers({
[11:02:06.062]                   {
[11:02:06.062]                     ii
[11:02:06.062]                   }
[11:02:06.062]                 }, immediateCondition = function(cond) {
[11:02:06.062]                   sendCondition <- ...future.makeSendCondition()
[11:02:06.062]                   sendCondition(cond)
[11:02:06.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.062]                   {
[11:02:06.062]                     inherits <- base::inherits
[11:02:06.062]                     invokeRestart <- base::invokeRestart
[11:02:06.062]                     is.null <- base::is.null
[11:02:06.062]                     muffled <- FALSE
[11:02:06.062]                     if (inherits(cond, "message")) {
[11:02:06.062]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:06.062]                       if (muffled) 
[11:02:06.062]                         invokeRestart("muffleMessage")
[11:02:06.062]                     }
[11:02:06.062]                     else if (inherits(cond, "warning")) {
[11:02:06.062]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:06.062]                       if (muffled) 
[11:02:06.062]                         invokeRestart("muffleWarning")
[11:02:06.062]                     }
[11:02:06.062]                     else if (inherits(cond, "condition")) {
[11:02:06.062]                       if (!is.null(pattern)) {
[11:02:06.062]                         computeRestarts <- base::computeRestarts
[11:02:06.062]                         grepl <- base::grepl
[11:02:06.062]                         restarts <- computeRestarts(cond)
[11:02:06.062]                         for (restart in restarts) {
[11:02:06.062]                           name <- restart$name
[11:02:06.062]                           if (is.null(name)) 
[11:02:06.062]                             next
[11:02:06.062]                           if (!grepl(pattern, name)) 
[11:02:06.062]                             next
[11:02:06.062]                           invokeRestart(restart)
[11:02:06.062]                           muffled <- TRUE
[11:02:06.062]                           break
[11:02:06.062]                         }
[11:02:06.062]                       }
[11:02:06.062]                     }
[11:02:06.062]                     invisible(muffled)
[11:02:06.062]                   }
[11:02:06.062]                   muffleCondition(cond)
[11:02:06.062]                 })
[11:02:06.062]             }))
[11:02:06.062]             future::FutureResult(value = ...future.value$value, 
[11:02:06.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.062]                   ...future.rng), globalenv = if (FALSE) 
[11:02:06.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:06.062]                     ...future.globalenv.names))
[11:02:06.062]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:06.062]         }, condition = base::local({
[11:02:06.062]             c <- base::c
[11:02:06.062]             inherits <- base::inherits
[11:02:06.062]             invokeRestart <- base::invokeRestart
[11:02:06.062]             length <- base::length
[11:02:06.062]             list <- base::list
[11:02:06.062]             seq.int <- base::seq.int
[11:02:06.062]             signalCondition <- base::signalCondition
[11:02:06.062]             sys.calls <- base::sys.calls
[11:02:06.062]             `[[` <- base::`[[`
[11:02:06.062]             `+` <- base::`+`
[11:02:06.062]             `<<-` <- base::`<<-`
[11:02:06.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:06.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:06.062]                   3L)]
[11:02:06.062]             }
[11:02:06.062]             function(cond) {
[11:02:06.062]                 is_error <- inherits(cond, "error")
[11:02:06.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:06.062]                   NULL)
[11:02:06.062]                 if (is_error) {
[11:02:06.062]                   sessionInformation <- function() {
[11:02:06.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:06.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:06.062]                       search = base::search(), system = base::Sys.info())
[11:02:06.062]                   }
[11:02:06.062]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:06.062]                     cond$call), session = sessionInformation(), 
[11:02:06.062]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:06.062]                   signalCondition(cond)
[11:02:06.062]                 }
[11:02:06.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:06.062]                 "immediateCondition"))) {
[11:02:06.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:06.062]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:06.062]                   if (TRUE && !signal) {
[11:02:06.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.062]                     {
[11:02:06.062]                       inherits <- base::inherits
[11:02:06.062]                       invokeRestart <- base::invokeRestart
[11:02:06.062]                       is.null <- base::is.null
[11:02:06.062]                       muffled <- FALSE
[11:02:06.062]                       if (inherits(cond, "message")) {
[11:02:06.062]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.062]                         if (muffled) 
[11:02:06.062]                           invokeRestart("muffleMessage")
[11:02:06.062]                       }
[11:02:06.062]                       else if (inherits(cond, "warning")) {
[11:02:06.062]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.062]                         if (muffled) 
[11:02:06.062]                           invokeRestart("muffleWarning")
[11:02:06.062]                       }
[11:02:06.062]                       else if (inherits(cond, "condition")) {
[11:02:06.062]                         if (!is.null(pattern)) {
[11:02:06.062]                           computeRestarts <- base::computeRestarts
[11:02:06.062]                           grepl <- base::grepl
[11:02:06.062]                           restarts <- computeRestarts(cond)
[11:02:06.062]                           for (restart in restarts) {
[11:02:06.062]                             name <- restart$name
[11:02:06.062]                             if (is.null(name)) 
[11:02:06.062]                               next
[11:02:06.062]                             if (!grepl(pattern, name)) 
[11:02:06.062]                               next
[11:02:06.062]                             invokeRestart(restart)
[11:02:06.062]                             muffled <- TRUE
[11:02:06.062]                             break
[11:02:06.062]                           }
[11:02:06.062]                         }
[11:02:06.062]                       }
[11:02:06.062]                       invisible(muffled)
[11:02:06.062]                     }
[11:02:06.062]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.062]                   }
[11:02:06.062]                 }
[11:02:06.062]                 else {
[11:02:06.062]                   if (TRUE) {
[11:02:06.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.062]                     {
[11:02:06.062]                       inherits <- base::inherits
[11:02:06.062]                       invokeRestart <- base::invokeRestart
[11:02:06.062]                       is.null <- base::is.null
[11:02:06.062]                       muffled <- FALSE
[11:02:06.062]                       if (inherits(cond, "message")) {
[11:02:06.062]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.062]                         if (muffled) 
[11:02:06.062]                           invokeRestart("muffleMessage")
[11:02:06.062]                       }
[11:02:06.062]                       else if (inherits(cond, "warning")) {
[11:02:06.062]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.062]                         if (muffled) 
[11:02:06.062]                           invokeRestart("muffleWarning")
[11:02:06.062]                       }
[11:02:06.062]                       else if (inherits(cond, "condition")) {
[11:02:06.062]                         if (!is.null(pattern)) {
[11:02:06.062]                           computeRestarts <- base::computeRestarts
[11:02:06.062]                           grepl <- base::grepl
[11:02:06.062]                           restarts <- computeRestarts(cond)
[11:02:06.062]                           for (restart in restarts) {
[11:02:06.062]                             name <- restart$name
[11:02:06.062]                             if (is.null(name)) 
[11:02:06.062]                               next
[11:02:06.062]                             if (!grepl(pattern, name)) 
[11:02:06.062]                               next
[11:02:06.062]                             invokeRestart(restart)
[11:02:06.062]                             muffled <- TRUE
[11:02:06.062]                             break
[11:02:06.062]                           }
[11:02:06.062]                         }
[11:02:06.062]                       }
[11:02:06.062]                       invisible(muffled)
[11:02:06.062]                     }
[11:02:06.062]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.062]                   }
[11:02:06.062]                 }
[11:02:06.062]             }
[11:02:06.062]         }))
[11:02:06.062]     }, error = function(ex) {
[11:02:06.062]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:06.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.062]                 ...future.rng), started = ...future.startTime, 
[11:02:06.062]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:06.062]             version = "1.8"), class = "FutureResult")
[11:02:06.062]     }, finally = {
[11:02:06.062]         if (!identical(...future.workdir, getwd())) 
[11:02:06.062]             setwd(...future.workdir)
[11:02:06.062]         {
[11:02:06.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:06.062]                 ...future.oldOptions$nwarnings <- NULL
[11:02:06.062]             }
[11:02:06.062]             base::options(...future.oldOptions)
[11:02:06.062]             if (.Platform$OS.type == "windows") {
[11:02:06.062]                 old_names <- names(...future.oldEnvVars)
[11:02:06.062]                 envs <- base::Sys.getenv()
[11:02:06.062]                 names <- names(envs)
[11:02:06.062]                 common <- intersect(names, old_names)
[11:02:06.062]                 added <- setdiff(names, old_names)
[11:02:06.062]                 removed <- setdiff(old_names, names)
[11:02:06.062]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:06.062]                   envs[common]]
[11:02:06.062]                 NAMES <- toupper(changed)
[11:02:06.062]                 args <- list()
[11:02:06.062]                 for (kk in seq_along(NAMES)) {
[11:02:06.062]                   name <- changed[[kk]]
[11:02:06.062]                   NAME <- NAMES[[kk]]
[11:02:06.062]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.062]                     next
[11:02:06.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.062]                 }
[11:02:06.062]                 NAMES <- toupper(added)
[11:02:06.062]                 for (kk in seq_along(NAMES)) {
[11:02:06.062]                   name <- added[[kk]]
[11:02:06.062]                   NAME <- NAMES[[kk]]
[11:02:06.062]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.062]                     next
[11:02:06.062]                   args[[name]] <- ""
[11:02:06.062]                 }
[11:02:06.062]                 NAMES <- toupper(removed)
[11:02:06.062]                 for (kk in seq_along(NAMES)) {
[11:02:06.062]                   name <- removed[[kk]]
[11:02:06.062]                   NAME <- NAMES[[kk]]
[11:02:06.062]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.062]                     next
[11:02:06.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.062]                 }
[11:02:06.062]                 if (length(args) > 0) 
[11:02:06.062]                   base::do.call(base::Sys.setenv, args = args)
[11:02:06.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:06.062]             }
[11:02:06.062]             else {
[11:02:06.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:06.062]             }
[11:02:06.062]             {
[11:02:06.062]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:06.062]                   0L) {
[11:02:06.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:06.062]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:06.062]                   base::options(opts)
[11:02:06.062]                 }
[11:02:06.062]                 {
[11:02:06.062]                   {
[11:02:06.062]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:06.062]                     NULL
[11:02:06.062]                   }
[11:02:06.062]                   options(future.plan = NULL)
[11:02:06.062]                   if (is.na(NA_character_)) 
[11:02:06.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:06.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:06.062]                     .init = FALSE)
[11:02:06.062]                 }
[11:02:06.062]             }
[11:02:06.062]         }
[11:02:06.062]     })
[11:02:06.062]     if (TRUE) {
[11:02:06.062]         base::sink(type = "output", split = FALSE)
[11:02:06.062]         if (TRUE) {
[11:02:06.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:06.062]         }
[11:02:06.062]         else {
[11:02:06.062]             ...future.result["stdout"] <- base::list(NULL)
[11:02:06.062]         }
[11:02:06.062]         base::close(...future.stdout)
[11:02:06.062]         ...future.stdout <- NULL
[11:02:06.062]     }
[11:02:06.062]     ...future.result$conditions <- ...future.conditions
[11:02:06.062]     ...future.result$finished <- base::Sys.time()
[11:02:06.062]     ...future.result
[11:02:06.062] }
[11:02:06.068] Exporting 1 global objects (304 bytes) to cluster node #1 ...
[11:02:06.068] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:02:06.068] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:02:06.069] Exporting 1 global objects (304 bytes) to cluster node #1 ... DONE
[11:02:06.069] MultisessionFuture started
 - Creating multisession future #1 ...
[11:02:06.071] getGlobalsAndPackages() ...
[11:02:06.071] Searching for globals...
[11:02:06.072] - globals found: [2] ‘{’, ‘ii’
[11:02:06.072] Searching for globals ... DONE
[11:02:06.072] Resolving globals: FALSE
[11:02:06.072] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:06.073] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:02:06.073] - globals: [1] ‘ii’
[11:02:06.073] 
[11:02:06.073] getGlobalsAndPackages() ... DONE
[11:02:06.086] Packages needed by the future expression (n = 0): <none>
[11:02:06.086] Packages needed by future strategies (n = 0): <none>
[11:02:06.087] {
[11:02:06.087]     {
[11:02:06.087]         {
[11:02:06.087]             ...future.startTime <- base::Sys.time()
[11:02:06.087]             {
[11:02:06.087]                 {
[11:02:06.087]                   {
[11:02:06.087]                     {
[11:02:06.087]                       base::local({
[11:02:06.087]                         has_future <- base::requireNamespace("future", 
[11:02:06.087]                           quietly = TRUE)
[11:02:06.087]                         if (has_future) {
[11:02:06.087]                           ns <- base::getNamespace("future")
[11:02:06.087]                           version <- ns[[".package"]][["version"]]
[11:02:06.087]                           if (is.null(version)) 
[11:02:06.087]                             version <- utils::packageVersion("future")
[11:02:06.087]                         }
[11:02:06.087]                         else {
[11:02:06.087]                           version <- NULL
[11:02:06.087]                         }
[11:02:06.087]                         if (!has_future || version < "1.8.0") {
[11:02:06.087]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:06.087]                             "", base::R.version$version.string), 
[11:02:06.087]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:06.087]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:06.087]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:06.087]                               "release", "version")], collapse = " "), 
[11:02:06.087]                             hostname = base::Sys.info()[["nodename"]])
[11:02:06.087]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:06.087]                             info)
[11:02:06.087]                           info <- base::paste(info, collapse = "; ")
[11:02:06.087]                           if (!has_future) {
[11:02:06.087]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:06.087]                               info)
[11:02:06.087]                           }
[11:02:06.087]                           else {
[11:02:06.087]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:06.087]                               info, version)
[11:02:06.087]                           }
[11:02:06.087]                           base::stop(msg)
[11:02:06.087]                         }
[11:02:06.087]                       })
[11:02:06.087]                     }
[11:02:06.087]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:06.087]                     base::options(mc.cores = 1L)
[11:02:06.087]                   }
[11:02:06.087]                   ...future.strategy.old <- future::plan("list")
[11:02:06.087]                   options(future.plan = NULL)
[11:02:06.087]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.087]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:06.087]                 }
[11:02:06.087]                 ...future.workdir <- getwd()
[11:02:06.087]             }
[11:02:06.087]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:06.087]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:06.087]         }
[11:02:06.087]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:06.087]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:06.087]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:06.087]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:06.087]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:06.087]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:06.087]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:06.087]             base::names(...future.oldOptions))
[11:02:06.087]     }
[11:02:06.087]     if (FALSE) {
[11:02:06.087]     }
[11:02:06.087]     else {
[11:02:06.087]         if (TRUE) {
[11:02:06.087]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:06.087]                 open = "w")
[11:02:06.087]         }
[11:02:06.087]         else {
[11:02:06.087]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:06.087]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:06.087]         }
[11:02:06.087]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:06.087]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:06.087]             base::sink(type = "output", split = FALSE)
[11:02:06.087]             base::close(...future.stdout)
[11:02:06.087]         }, add = TRUE)
[11:02:06.087]     }
[11:02:06.087]     ...future.frame <- base::sys.nframe()
[11:02:06.087]     ...future.conditions <- base::list()
[11:02:06.087]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:06.087]     if (FALSE) {
[11:02:06.087]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:06.087]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:06.087]     }
[11:02:06.087]     ...future.result <- base::tryCatch({
[11:02:06.087]         base::withCallingHandlers({
[11:02:06.087]             ...future.value <- base::withVisible(base::local({
[11:02:06.087]                 ...future.makeSendCondition <- base::local({
[11:02:06.087]                   sendCondition <- NULL
[11:02:06.087]                   function(frame = 1L) {
[11:02:06.087]                     if (is.function(sendCondition)) 
[11:02:06.087]                       return(sendCondition)
[11:02:06.087]                     ns <- getNamespace("parallel")
[11:02:06.087]                     if (exists("sendData", mode = "function", 
[11:02:06.087]                       envir = ns)) {
[11:02:06.087]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:06.087]                         envir = ns)
[11:02:06.087]                       envir <- sys.frame(frame)
[11:02:06.087]                       master <- NULL
[11:02:06.087]                       while (!identical(envir, .GlobalEnv) && 
[11:02:06.087]                         !identical(envir, emptyenv())) {
[11:02:06.087]                         if (exists("master", mode = "list", envir = envir, 
[11:02:06.087]                           inherits = FALSE)) {
[11:02:06.087]                           master <- get("master", mode = "list", 
[11:02:06.087]                             envir = envir, inherits = FALSE)
[11:02:06.087]                           if (inherits(master, c("SOCKnode", 
[11:02:06.087]                             "SOCK0node"))) {
[11:02:06.087]                             sendCondition <<- function(cond) {
[11:02:06.087]                               data <- list(type = "VALUE", value = cond, 
[11:02:06.087]                                 success = TRUE)
[11:02:06.087]                               parallel_sendData(master, data)
[11:02:06.087]                             }
[11:02:06.087]                             return(sendCondition)
[11:02:06.087]                           }
[11:02:06.087]                         }
[11:02:06.087]                         frame <- frame + 1L
[11:02:06.087]                         envir <- sys.frame(frame)
[11:02:06.087]                       }
[11:02:06.087]                     }
[11:02:06.087]                     sendCondition <<- function(cond) NULL
[11:02:06.087]                   }
[11:02:06.087]                 })
[11:02:06.087]                 withCallingHandlers({
[11:02:06.087]                   {
[11:02:06.087]                     ii
[11:02:06.087]                   }
[11:02:06.087]                 }, immediateCondition = function(cond) {
[11:02:06.087]                   sendCondition <- ...future.makeSendCondition()
[11:02:06.087]                   sendCondition(cond)
[11:02:06.087]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.087]                   {
[11:02:06.087]                     inherits <- base::inherits
[11:02:06.087]                     invokeRestart <- base::invokeRestart
[11:02:06.087]                     is.null <- base::is.null
[11:02:06.087]                     muffled <- FALSE
[11:02:06.087]                     if (inherits(cond, "message")) {
[11:02:06.087]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:06.087]                       if (muffled) 
[11:02:06.087]                         invokeRestart("muffleMessage")
[11:02:06.087]                     }
[11:02:06.087]                     else if (inherits(cond, "warning")) {
[11:02:06.087]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:06.087]                       if (muffled) 
[11:02:06.087]                         invokeRestart("muffleWarning")
[11:02:06.087]                     }
[11:02:06.087]                     else if (inherits(cond, "condition")) {
[11:02:06.087]                       if (!is.null(pattern)) {
[11:02:06.087]                         computeRestarts <- base::computeRestarts
[11:02:06.087]                         grepl <- base::grepl
[11:02:06.087]                         restarts <- computeRestarts(cond)
[11:02:06.087]                         for (restart in restarts) {
[11:02:06.087]                           name <- restart$name
[11:02:06.087]                           if (is.null(name)) 
[11:02:06.087]                             next
[11:02:06.087]                           if (!grepl(pattern, name)) 
[11:02:06.087]                             next
[11:02:06.087]                           invokeRestart(restart)
[11:02:06.087]                           muffled <- TRUE
[11:02:06.087]                           break
[11:02:06.087]                         }
[11:02:06.087]                       }
[11:02:06.087]                     }
[11:02:06.087]                     invisible(muffled)
[11:02:06.087]                   }
[11:02:06.087]                   muffleCondition(cond)
[11:02:06.087]                 })
[11:02:06.087]             }))
[11:02:06.087]             future::FutureResult(value = ...future.value$value, 
[11:02:06.087]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.087]                   ...future.rng), globalenv = if (FALSE) 
[11:02:06.087]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:06.087]                     ...future.globalenv.names))
[11:02:06.087]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:06.087]         }, condition = base::local({
[11:02:06.087]             c <- base::c
[11:02:06.087]             inherits <- base::inherits
[11:02:06.087]             invokeRestart <- base::invokeRestart
[11:02:06.087]             length <- base::length
[11:02:06.087]             list <- base::list
[11:02:06.087]             seq.int <- base::seq.int
[11:02:06.087]             signalCondition <- base::signalCondition
[11:02:06.087]             sys.calls <- base::sys.calls
[11:02:06.087]             `[[` <- base::`[[`
[11:02:06.087]             `+` <- base::`+`
[11:02:06.087]             `<<-` <- base::`<<-`
[11:02:06.087]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:06.087]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:06.087]                   3L)]
[11:02:06.087]             }
[11:02:06.087]             function(cond) {
[11:02:06.087]                 is_error <- inherits(cond, "error")
[11:02:06.087]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:06.087]                   NULL)
[11:02:06.087]                 if (is_error) {
[11:02:06.087]                   sessionInformation <- function() {
[11:02:06.087]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:06.087]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:06.087]                       search = base::search(), system = base::Sys.info())
[11:02:06.087]                   }
[11:02:06.087]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.087]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:06.087]                     cond$call), session = sessionInformation(), 
[11:02:06.087]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:06.087]                   signalCondition(cond)
[11:02:06.087]                 }
[11:02:06.087]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:06.087]                 "immediateCondition"))) {
[11:02:06.087]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:06.087]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.087]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:06.087]                   if (TRUE && !signal) {
[11:02:06.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.087]                     {
[11:02:06.087]                       inherits <- base::inherits
[11:02:06.087]                       invokeRestart <- base::invokeRestart
[11:02:06.087]                       is.null <- base::is.null
[11:02:06.087]                       muffled <- FALSE
[11:02:06.087]                       if (inherits(cond, "message")) {
[11:02:06.087]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.087]                         if (muffled) 
[11:02:06.087]                           invokeRestart("muffleMessage")
[11:02:06.087]                       }
[11:02:06.087]                       else if (inherits(cond, "warning")) {
[11:02:06.087]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.087]                         if (muffled) 
[11:02:06.087]                           invokeRestart("muffleWarning")
[11:02:06.087]                       }
[11:02:06.087]                       else if (inherits(cond, "condition")) {
[11:02:06.087]                         if (!is.null(pattern)) {
[11:02:06.087]                           computeRestarts <- base::computeRestarts
[11:02:06.087]                           grepl <- base::grepl
[11:02:06.087]                           restarts <- computeRestarts(cond)
[11:02:06.087]                           for (restart in restarts) {
[11:02:06.087]                             name <- restart$name
[11:02:06.087]                             if (is.null(name)) 
[11:02:06.087]                               next
[11:02:06.087]                             if (!grepl(pattern, name)) 
[11:02:06.087]                               next
[11:02:06.087]                             invokeRestart(restart)
[11:02:06.087]                             muffled <- TRUE
[11:02:06.087]                             break
[11:02:06.087]                           }
[11:02:06.087]                         }
[11:02:06.087]                       }
[11:02:06.087]                       invisible(muffled)
[11:02:06.087]                     }
[11:02:06.087]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.087]                   }
[11:02:06.087]                 }
[11:02:06.087]                 else {
[11:02:06.087]                   if (TRUE) {
[11:02:06.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.087]                     {
[11:02:06.087]                       inherits <- base::inherits
[11:02:06.087]                       invokeRestart <- base::invokeRestart
[11:02:06.087]                       is.null <- base::is.null
[11:02:06.087]                       muffled <- FALSE
[11:02:06.087]                       if (inherits(cond, "message")) {
[11:02:06.087]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.087]                         if (muffled) 
[11:02:06.087]                           invokeRestart("muffleMessage")
[11:02:06.087]                       }
[11:02:06.087]                       else if (inherits(cond, "warning")) {
[11:02:06.087]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.087]                         if (muffled) 
[11:02:06.087]                           invokeRestart("muffleWarning")
[11:02:06.087]                       }
[11:02:06.087]                       else if (inherits(cond, "condition")) {
[11:02:06.087]                         if (!is.null(pattern)) {
[11:02:06.087]                           computeRestarts <- base::computeRestarts
[11:02:06.087]                           grepl <- base::grepl
[11:02:06.087]                           restarts <- computeRestarts(cond)
[11:02:06.087]                           for (restart in restarts) {
[11:02:06.087]                             name <- restart$name
[11:02:06.087]                             if (is.null(name)) 
[11:02:06.087]                               next
[11:02:06.087]                             if (!grepl(pattern, name)) 
[11:02:06.087]                               next
[11:02:06.087]                             invokeRestart(restart)
[11:02:06.087]                             muffled <- TRUE
[11:02:06.087]                             break
[11:02:06.087]                           }
[11:02:06.087]                         }
[11:02:06.087]                       }
[11:02:06.087]                       invisible(muffled)
[11:02:06.087]                     }
[11:02:06.087]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.087]                   }
[11:02:06.087]                 }
[11:02:06.087]             }
[11:02:06.087]         }))
[11:02:06.087]     }, error = function(ex) {
[11:02:06.087]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:06.087]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.087]                 ...future.rng), started = ...future.startTime, 
[11:02:06.087]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:06.087]             version = "1.8"), class = "FutureResult")
[11:02:06.087]     }, finally = {
[11:02:06.087]         if (!identical(...future.workdir, getwd())) 
[11:02:06.087]             setwd(...future.workdir)
[11:02:06.087]         {
[11:02:06.087]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:06.087]                 ...future.oldOptions$nwarnings <- NULL
[11:02:06.087]             }
[11:02:06.087]             base::options(...future.oldOptions)
[11:02:06.087]             if (.Platform$OS.type == "windows") {
[11:02:06.087]                 old_names <- names(...future.oldEnvVars)
[11:02:06.087]                 envs <- base::Sys.getenv()
[11:02:06.087]                 names <- names(envs)
[11:02:06.087]                 common <- intersect(names, old_names)
[11:02:06.087]                 added <- setdiff(names, old_names)
[11:02:06.087]                 removed <- setdiff(old_names, names)
[11:02:06.087]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:06.087]                   envs[common]]
[11:02:06.087]                 NAMES <- toupper(changed)
[11:02:06.087]                 args <- list()
[11:02:06.087]                 for (kk in seq_along(NAMES)) {
[11:02:06.087]                   name <- changed[[kk]]
[11:02:06.087]                   NAME <- NAMES[[kk]]
[11:02:06.087]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.087]                     next
[11:02:06.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.087]                 }
[11:02:06.087]                 NAMES <- toupper(added)
[11:02:06.087]                 for (kk in seq_along(NAMES)) {
[11:02:06.087]                   name <- added[[kk]]
[11:02:06.087]                   NAME <- NAMES[[kk]]
[11:02:06.087]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.087]                     next
[11:02:06.087]                   args[[name]] <- ""
[11:02:06.087]                 }
[11:02:06.087]                 NAMES <- toupper(removed)
[11:02:06.087]                 for (kk in seq_along(NAMES)) {
[11:02:06.087]                   name <- removed[[kk]]
[11:02:06.087]                   NAME <- NAMES[[kk]]
[11:02:06.087]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.087]                     next
[11:02:06.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.087]                 }
[11:02:06.087]                 if (length(args) > 0) 
[11:02:06.087]                   base::do.call(base::Sys.setenv, args = args)
[11:02:06.087]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:06.087]             }
[11:02:06.087]             else {
[11:02:06.087]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:06.087]             }
[11:02:06.087]             {
[11:02:06.087]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:06.087]                   0L) {
[11:02:06.087]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:06.087]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:06.087]                   base::options(opts)
[11:02:06.087]                 }
[11:02:06.087]                 {
[11:02:06.087]                   {
[11:02:06.087]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:06.087]                     NULL
[11:02:06.087]                   }
[11:02:06.087]                   options(future.plan = NULL)
[11:02:06.087]                   if (is.na(NA_character_)) 
[11:02:06.087]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.087]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:06.087]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:06.087]                     .init = FALSE)
[11:02:06.087]                 }
[11:02:06.087]             }
[11:02:06.087]         }
[11:02:06.087]     })
[11:02:06.087]     if (TRUE) {
[11:02:06.087]         base::sink(type = "output", split = FALSE)
[11:02:06.087]         if (TRUE) {
[11:02:06.087]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:06.087]         }
[11:02:06.087]         else {
[11:02:06.087]             ...future.result["stdout"] <- base::list(NULL)
[11:02:06.087]         }
[11:02:06.087]         base::close(...future.stdout)
[11:02:06.087]         ...future.stdout <- NULL
[11:02:06.087]     }
[11:02:06.087]     ...future.result$conditions <- ...future.conditions
[11:02:06.087]     ...future.result$finished <- base::Sys.time()
[11:02:06.087]     ...future.result
[11:02:06.087] }
[11:02:06.138] Exporting 1 global objects (304 bytes) to cluster node #2 ...
[11:02:06.138] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[11:02:06.139] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[11:02:06.139] Exporting 1 global objects (304 bytes) to cluster node #2 ... DONE
[11:02:06.140] MultisessionFuture started
 - Resolving 2 multisession futures
[11:02:06.140] result() for ClusterFuture ...
[11:02:06.140] receiveMessageFromWorker() for ClusterFuture ...
[11:02:06.140] - Validating connection of MultisessionFuture
[11:02:06.211] - received message: FutureResult
[11:02:06.211] - Received FutureResult
[11:02:06.211] - Erased future from FutureRegistry
[11:02:06.211] result() for ClusterFuture ...
[11:02:06.211] - result already collected: FutureResult
[11:02:06.212] result() for ClusterFuture ... done
[11:02:06.212] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:06.212] result() for ClusterFuture ... done
[11:02:06.212] result() for ClusterFuture ...
[11:02:06.212] - result already collected: FutureResult
[11:02:06.212] result() for ClusterFuture ... done
[11:02:06.212] result() for ClusterFuture ...
[11:02:06.212] receiveMessageFromWorker() for ClusterFuture ...
[11:02:06.213] - Validating connection of MultisessionFuture
[11:02:06.213] - received message: FutureResult
[11:02:06.213] - Received FutureResult
[11:02:06.213] - Erased future from FutureRegistry
[11:02:06.213] result() for ClusterFuture ...
[11:02:06.213] - result already collected: FutureResult
[11:02:06.213] result() for ClusterFuture ... done
[11:02:06.213] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:06.213] result() for ClusterFuture ... done
[11:02:06.214] result() for ClusterFuture ...
[11:02:06.214] - result already collected: FutureResult
[11:02:06.214] result() for ClusterFuture ... done
*** multisession() - workers inherit .libPaths()
[11:02:06.214] getGlobalsAndPackages() ...
[11:02:06.214] Searching for globals...
[11:02:06.215] - globals found: [1] ‘.libPaths’
[11:02:06.215] Searching for globals ... DONE
[11:02:06.215] Resolving globals: FALSE
[11:02:06.215] 
[11:02:06.216] 
[11:02:06.216] getGlobalsAndPackages() ... DONE
[11:02:06.216] run() for ‘Future’ ...
[11:02:06.216] - state: ‘created’
[11:02:06.216] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:06.217] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:06.217] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:06.217]   - Field: ‘label’
[11:02:06.217]   - Field: ‘local’
[11:02:06.217]   - Field: ‘owner’
[11:02:06.217]   - Field: ‘envir’
[11:02:06.217]   - Field: ‘packages’
[11:02:06.217]   - Field: ‘gc’
[11:02:06.218]   - Field: ‘conditions’
[11:02:06.218]   - Field: ‘expr’
[11:02:06.218]   - Field: ‘uuid’
[11:02:06.218]   - Field: ‘seed’
[11:02:06.218]   - Field: ‘version’
[11:02:06.218]   - Field: ‘result’
[11:02:06.218]   - Field: ‘asynchronous’
[11:02:06.218]   - Field: ‘calls’
[11:02:06.218]   - Field: ‘globals’
[11:02:06.218]   - Field: ‘stdout’
[11:02:06.219]   - Field: ‘earlySignal’
[11:02:06.219]   - Field: ‘lazy’
[11:02:06.219]   - Field: ‘state’
[11:02:06.219] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:06.219] - Launch lazy future ...
[11:02:06.219] Packages needed by the future expression (n = 0): <none>
[11:02:06.219] Packages needed by future strategies (n = 0): <none>
[11:02:06.220] {
[11:02:06.220]     {
[11:02:06.220]         {
[11:02:06.220]             ...future.startTime <- base::Sys.time()
[11:02:06.220]             {
[11:02:06.220]                 {
[11:02:06.220]                   {
[11:02:06.220]                     base::local({
[11:02:06.220]                       has_future <- base::requireNamespace("future", 
[11:02:06.220]                         quietly = TRUE)
[11:02:06.220]                       if (has_future) {
[11:02:06.220]                         ns <- base::getNamespace("future")
[11:02:06.220]                         version <- ns[[".package"]][["version"]]
[11:02:06.220]                         if (is.null(version)) 
[11:02:06.220]                           version <- utils::packageVersion("future")
[11:02:06.220]                       }
[11:02:06.220]                       else {
[11:02:06.220]                         version <- NULL
[11:02:06.220]                       }
[11:02:06.220]                       if (!has_future || version < "1.8.0") {
[11:02:06.220]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:06.220]                           "", base::R.version$version.string), 
[11:02:06.220]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:06.220]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:06.220]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:06.220]                             "release", "version")], collapse = " "), 
[11:02:06.220]                           hostname = base::Sys.info()[["nodename"]])
[11:02:06.220]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:06.220]                           info)
[11:02:06.220]                         info <- base::paste(info, collapse = "; ")
[11:02:06.220]                         if (!has_future) {
[11:02:06.220]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:06.220]                             info)
[11:02:06.220]                         }
[11:02:06.220]                         else {
[11:02:06.220]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:06.220]                             info, version)
[11:02:06.220]                         }
[11:02:06.220]                         base::stop(msg)
[11:02:06.220]                       }
[11:02:06.220]                     })
[11:02:06.220]                   }
[11:02:06.220]                   ...future.strategy.old <- future::plan("list")
[11:02:06.220]                   options(future.plan = NULL)
[11:02:06.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:06.220]                 }
[11:02:06.220]                 ...future.workdir <- getwd()
[11:02:06.220]             }
[11:02:06.220]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:06.220]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:06.220]         }
[11:02:06.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:06.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:06.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:06.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:06.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:06.220]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:06.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:06.220]             base::names(...future.oldOptions))
[11:02:06.220]     }
[11:02:06.220]     if (FALSE) {
[11:02:06.220]     }
[11:02:06.220]     else {
[11:02:06.220]         if (TRUE) {
[11:02:06.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:06.220]                 open = "w")
[11:02:06.220]         }
[11:02:06.220]         else {
[11:02:06.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:06.220]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:06.220]         }
[11:02:06.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:06.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:06.220]             base::sink(type = "output", split = FALSE)
[11:02:06.220]             base::close(...future.stdout)
[11:02:06.220]         }, add = TRUE)
[11:02:06.220]     }
[11:02:06.220]     ...future.frame <- base::sys.nframe()
[11:02:06.220]     ...future.conditions <- base::list()
[11:02:06.220]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:06.220]     if (FALSE) {
[11:02:06.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:06.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:06.220]     }
[11:02:06.220]     ...future.result <- base::tryCatch({
[11:02:06.220]         base::withCallingHandlers({
[11:02:06.220]             ...future.value <- base::withVisible(base::local(.libPaths()))
[11:02:06.220]             future::FutureResult(value = ...future.value$value, 
[11:02:06.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.220]                   ...future.rng), globalenv = if (FALSE) 
[11:02:06.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:06.220]                     ...future.globalenv.names))
[11:02:06.220]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:06.220]         }, condition = base::local({
[11:02:06.220]             c <- base::c
[11:02:06.220]             inherits <- base::inherits
[11:02:06.220]             invokeRestart <- base::invokeRestart
[11:02:06.220]             length <- base::length
[11:02:06.220]             list <- base::list
[11:02:06.220]             seq.int <- base::seq.int
[11:02:06.220]             signalCondition <- base::signalCondition
[11:02:06.220]             sys.calls <- base::sys.calls
[11:02:06.220]             `[[` <- base::`[[`
[11:02:06.220]             `+` <- base::`+`
[11:02:06.220]             `<<-` <- base::`<<-`
[11:02:06.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:06.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:06.220]                   3L)]
[11:02:06.220]             }
[11:02:06.220]             function(cond) {
[11:02:06.220]                 is_error <- inherits(cond, "error")
[11:02:06.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:06.220]                   NULL)
[11:02:06.220]                 if (is_error) {
[11:02:06.220]                   sessionInformation <- function() {
[11:02:06.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:06.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:06.220]                       search = base::search(), system = base::Sys.info())
[11:02:06.220]                   }
[11:02:06.220]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:06.220]                     cond$call), session = sessionInformation(), 
[11:02:06.220]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:06.220]                   signalCondition(cond)
[11:02:06.220]                 }
[11:02:06.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:06.220]                 "immediateCondition"))) {
[11:02:06.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:06.220]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:06.220]                   if (TRUE && !signal) {
[11:02:06.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.220]                     {
[11:02:06.220]                       inherits <- base::inherits
[11:02:06.220]                       invokeRestart <- base::invokeRestart
[11:02:06.220]                       is.null <- base::is.null
[11:02:06.220]                       muffled <- FALSE
[11:02:06.220]                       if (inherits(cond, "message")) {
[11:02:06.220]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.220]                         if (muffled) 
[11:02:06.220]                           invokeRestart("muffleMessage")
[11:02:06.220]                       }
[11:02:06.220]                       else if (inherits(cond, "warning")) {
[11:02:06.220]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.220]                         if (muffled) 
[11:02:06.220]                           invokeRestart("muffleWarning")
[11:02:06.220]                       }
[11:02:06.220]                       else if (inherits(cond, "condition")) {
[11:02:06.220]                         if (!is.null(pattern)) {
[11:02:06.220]                           computeRestarts <- base::computeRestarts
[11:02:06.220]                           grepl <- base::grepl
[11:02:06.220]                           restarts <- computeRestarts(cond)
[11:02:06.220]                           for (restart in restarts) {
[11:02:06.220]                             name <- restart$name
[11:02:06.220]                             if (is.null(name)) 
[11:02:06.220]                               next
[11:02:06.220]                             if (!grepl(pattern, name)) 
[11:02:06.220]                               next
[11:02:06.220]                             invokeRestart(restart)
[11:02:06.220]                             muffled <- TRUE
[11:02:06.220]                             break
[11:02:06.220]                           }
[11:02:06.220]                         }
[11:02:06.220]                       }
[11:02:06.220]                       invisible(muffled)
[11:02:06.220]                     }
[11:02:06.220]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.220]                   }
[11:02:06.220]                 }
[11:02:06.220]                 else {
[11:02:06.220]                   if (TRUE) {
[11:02:06.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.220]                     {
[11:02:06.220]                       inherits <- base::inherits
[11:02:06.220]                       invokeRestart <- base::invokeRestart
[11:02:06.220]                       is.null <- base::is.null
[11:02:06.220]                       muffled <- FALSE
[11:02:06.220]                       if (inherits(cond, "message")) {
[11:02:06.220]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.220]                         if (muffled) 
[11:02:06.220]                           invokeRestart("muffleMessage")
[11:02:06.220]                       }
[11:02:06.220]                       else if (inherits(cond, "warning")) {
[11:02:06.220]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.220]                         if (muffled) 
[11:02:06.220]                           invokeRestart("muffleWarning")
[11:02:06.220]                       }
[11:02:06.220]                       else if (inherits(cond, "condition")) {
[11:02:06.220]                         if (!is.null(pattern)) {
[11:02:06.220]                           computeRestarts <- base::computeRestarts
[11:02:06.220]                           grepl <- base::grepl
[11:02:06.220]                           restarts <- computeRestarts(cond)
[11:02:06.220]                           for (restart in restarts) {
[11:02:06.220]                             name <- restart$name
[11:02:06.220]                             if (is.null(name)) 
[11:02:06.220]                               next
[11:02:06.220]                             if (!grepl(pattern, name)) 
[11:02:06.220]                               next
[11:02:06.220]                             invokeRestart(restart)
[11:02:06.220]                             muffled <- TRUE
[11:02:06.220]                             break
[11:02:06.220]                           }
[11:02:06.220]                         }
[11:02:06.220]                       }
[11:02:06.220]                       invisible(muffled)
[11:02:06.220]                     }
[11:02:06.220]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.220]                   }
[11:02:06.220]                 }
[11:02:06.220]             }
[11:02:06.220]         }))
[11:02:06.220]     }, error = function(ex) {
[11:02:06.220]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:06.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.220]                 ...future.rng), started = ...future.startTime, 
[11:02:06.220]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:06.220]             version = "1.8"), class = "FutureResult")
[11:02:06.220]     }, finally = {
[11:02:06.220]         if (!identical(...future.workdir, getwd())) 
[11:02:06.220]             setwd(...future.workdir)
[11:02:06.220]         {
[11:02:06.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:06.220]                 ...future.oldOptions$nwarnings <- NULL
[11:02:06.220]             }
[11:02:06.220]             base::options(...future.oldOptions)
[11:02:06.220]             if (.Platform$OS.type == "windows") {
[11:02:06.220]                 old_names <- names(...future.oldEnvVars)
[11:02:06.220]                 envs <- base::Sys.getenv()
[11:02:06.220]                 names <- names(envs)
[11:02:06.220]                 common <- intersect(names, old_names)
[11:02:06.220]                 added <- setdiff(names, old_names)
[11:02:06.220]                 removed <- setdiff(old_names, names)
[11:02:06.220]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:06.220]                   envs[common]]
[11:02:06.220]                 NAMES <- toupper(changed)
[11:02:06.220]                 args <- list()
[11:02:06.220]                 for (kk in seq_along(NAMES)) {
[11:02:06.220]                   name <- changed[[kk]]
[11:02:06.220]                   NAME <- NAMES[[kk]]
[11:02:06.220]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.220]                     next
[11:02:06.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.220]                 }
[11:02:06.220]                 NAMES <- toupper(added)
[11:02:06.220]                 for (kk in seq_along(NAMES)) {
[11:02:06.220]                   name <- added[[kk]]
[11:02:06.220]                   NAME <- NAMES[[kk]]
[11:02:06.220]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.220]                     next
[11:02:06.220]                   args[[name]] <- ""
[11:02:06.220]                 }
[11:02:06.220]                 NAMES <- toupper(removed)
[11:02:06.220]                 for (kk in seq_along(NAMES)) {
[11:02:06.220]                   name <- removed[[kk]]
[11:02:06.220]                   NAME <- NAMES[[kk]]
[11:02:06.220]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.220]                     next
[11:02:06.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.220]                 }
[11:02:06.220]                 if (length(args) > 0) 
[11:02:06.220]                   base::do.call(base::Sys.setenv, args = args)
[11:02:06.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:06.220]             }
[11:02:06.220]             else {
[11:02:06.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:06.220]             }
[11:02:06.220]             {
[11:02:06.220]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:06.220]                   0L) {
[11:02:06.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:06.220]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:06.220]                   base::options(opts)
[11:02:06.220]                 }
[11:02:06.220]                 {
[11:02:06.220]                   {
[11:02:06.220]                     NULL
[11:02:06.220]                     RNGkind("Mersenne-Twister")
[11:02:06.220]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:06.220]                       inherits = FALSE)
[11:02:06.220]                   }
[11:02:06.220]                   options(future.plan = NULL)
[11:02:06.220]                   if (is.na(NA_character_)) 
[11:02:06.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:06.220]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:06.220]                     .init = FALSE)
[11:02:06.220]                 }
[11:02:06.220]             }
[11:02:06.220]         }
[11:02:06.220]     })
[11:02:06.220]     if (TRUE) {
[11:02:06.220]         base::sink(type = "output", split = FALSE)
[11:02:06.220]         if (TRUE) {
[11:02:06.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:06.220]         }
[11:02:06.220]         else {
[11:02:06.220]             ...future.result["stdout"] <- base::list(NULL)
[11:02:06.220]         }
[11:02:06.220]         base::close(...future.stdout)
[11:02:06.220]         ...future.stdout <- NULL
[11:02:06.220]     }
[11:02:06.220]     ...future.result$conditions <- ...future.conditions
[11:02:06.220]     ...future.result$finished <- base::Sys.time()
[11:02:06.220]     ...future.result
[11:02:06.220] }
[11:02:06.222] plan(): Setting new future strategy stack:
[11:02:06.222] List of future strategies:
[11:02:06.222] 1. sequential:
[11:02:06.222]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:06.222]    - tweaked: FALSE
[11:02:06.222]    - call: NULL
[11:02:06.223] plan(): nbrOfWorkers() = 1
[11:02:06.224] plan(): Setting new future strategy stack:
[11:02:06.224] List of future strategies:
[11:02:06.224] 1. sequential:
[11:02:06.224]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:06.224]    - tweaked: FALSE
[11:02:06.224]    - call: future::plan("sequential")
[11:02:06.224] plan(): nbrOfWorkers() = 1
[11:02:06.224] SequentialFuture started (and completed)
[11:02:06.225] - Launch lazy future ... done
[11:02:06.225] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[11:02:06.227] getGlobalsAndPackages() ...
[11:02:06.228] 
[11:02:06.228] - globals: [0] <none>
[11:02:06.228] getGlobalsAndPackages() ... DONE
[11:02:06.241] Packages needed by the future expression (n = 0): <none>
[11:02:06.241] Packages needed by future strategies (n = 0): <none>
[11:02:06.242] {
[11:02:06.242]     {
[11:02:06.242]         {
[11:02:06.242]             ...future.startTime <- base::Sys.time()
[11:02:06.242]             {
[11:02:06.242]                 {
[11:02:06.242]                   {
[11:02:06.242]                     {
[11:02:06.242]                       base::local({
[11:02:06.242]                         has_future <- base::requireNamespace("future", 
[11:02:06.242]                           quietly = TRUE)
[11:02:06.242]                         if (has_future) {
[11:02:06.242]                           ns <- base::getNamespace("future")
[11:02:06.242]                           version <- ns[[".package"]][["version"]]
[11:02:06.242]                           if (is.null(version)) 
[11:02:06.242]                             version <- utils::packageVersion("future")
[11:02:06.242]                         }
[11:02:06.242]                         else {
[11:02:06.242]                           version <- NULL
[11:02:06.242]                         }
[11:02:06.242]                         if (!has_future || version < "1.8.0") {
[11:02:06.242]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:06.242]                             "", base::R.version$version.string), 
[11:02:06.242]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:06.242]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:06.242]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:06.242]                               "release", "version")], collapse = " "), 
[11:02:06.242]                             hostname = base::Sys.info()[["nodename"]])
[11:02:06.242]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:06.242]                             info)
[11:02:06.242]                           info <- base::paste(info, collapse = "; ")
[11:02:06.242]                           if (!has_future) {
[11:02:06.242]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:06.242]                               info)
[11:02:06.242]                           }
[11:02:06.242]                           else {
[11:02:06.242]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:06.242]                               info, version)
[11:02:06.242]                           }
[11:02:06.242]                           base::stop(msg)
[11:02:06.242]                         }
[11:02:06.242]                       })
[11:02:06.242]                     }
[11:02:06.242]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:06.242]                     base::options(mc.cores = 1L)
[11:02:06.242]                   }
[11:02:06.242]                   ...future.strategy.old <- future::plan("list")
[11:02:06.242]                   options(future.plan = NULL)
[11:02:06.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:06.242]                 }
[11:02:06.242]                 ...future.workdir <- getwd()
[11:02:06.242]             }
[11:02:06.242]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:06.242]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:06.242]         }
[11:02:06.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:06.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:06.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:06.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:06.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:06.242]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:06.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:06.242]             base::names(...future.oldOptions))
[11:02:06.242]     }
[11:02:06.242]     if (FALSE) {
[11:02:06.242]     }
[11:02:06.242]     else {
[11:02:06.242]         if (TRUE) {
[11:02:06.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:06.242]                 open = "w")
[11:02:06.242]         }
[11:02:06.242]         else {
[11:02:06.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:06.242]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:06.242]         }
[11:02:06.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:06.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:06.242]             base::sink(type = "output", split = FALSE)
[11:02:06.242]             base::close(...future.stdout)
[11:02:06.242]         }, add = TRUE)
[11:02:06.242]     }
[11:02:06.242]     ...future.frame <- base::sys.nframe()
[11:02:06.242]     ...future.conditions <- base::list()
[11:02:06.242]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:06.242]     if (FALSE) {
[11:02:06.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:06.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:06.242]     }
[11:02:06.242]     ...future.result <- base::tryCatch({
[11:02:06.242]         base::withCallingHandlers({
[11:02:06.242]             ...future.value <- base::withVisible(base::local({
[11:02:06.242]                 ...future.makeSendCondition <- base::local({
[11:02:06.242]                   sendCondition <- NULL
[11:02:06.242]                   function(frame = 1L) {
[11:02:06.242]                     if (is.function(sendCondition)) 
[11:02:06.242]                       return(sendCondition)
[11:02:06.242]                     ns <- getNamespace("parallel")
[11:02:06.242]                     if (exists("sendData", mode = "function", 
[11:02:06.242]                       envir = ns)) {
[11:02:06.242]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:06.242]                         envir = ns)
[11:02:06.242]                       envir <- sys.frame(frame)
[11:02:06.242]                       master <- NULL
[11:02:06.242]                       while (!identical(envir, .GlobalEnv) && 
[11:02:06.242]                         !identical(envir, emptyenv())) {
[11:02:06.242]                         if (exists("master", mode = "list", envir = envir, 
[11:02:06.242]                           inherits = FALSE)) {
[11:02:06.242]                           master <- get("master", mode = "list", 
[11:02:06.242]                             envir = envir, inherits = FALSE)
[11:02:06.242]                           if (inherits(master, c("SOCKnode", 
[11:02:06.242]                             "SOCK0node"))) {
[11:02:06.242]                             sendCondition <<- function(cond) {
[11:02:06.242]                               data <- list(type = "VALUE", value = cond, 
[11:02:06.242]                                 success = TRUE)
[11:02:06.242]                               parallel_sendData(master, data)
[11:02:06.242]                             }
[11:02:06.242]                             return(sendCondition)
[11:02:06.242]                           }
[11:02:06.242]                         }
[11:02:06.242]                         frame <- frame + 1L
[11:02:06.242]                         envir <- sys.frame(frame)
[11:02:06.242]                       }
[11:02:06.242]                     }
[11:02:06.242]                     sendCondition <<- function(cond) NULL
[11:02:06.242]                   }
[11:02:06.242]                 })
[11:02:06.242]                 withCallingHandlers({
[11:02:06.242]                   {
[11:02:06.242]                     stop("Whoops!")
[11:02:06.242]                     1
[11:02:06.242]                   }
[11:02:06.242]                 }, immediateCondition = function(cond) {
[11:02:06.242]                   sendCondition <- ...future.makeSendCondition()
[11:02:06.242]                   sendCondition(cond)
[11:02:06.242]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.242]                   {
[11:02:06.242]                     inherits <- base::inherits
[11:02:06.242]                     invokeRestart <- base::invokeRestart
[11:02:06.242]                     is.null <- base::is.null
[11:02:06.242]                     muffled <- FALSE
[11:02:06.242]                     if (inherits(cond, "message")) {
[11:02:06.242]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:06.242]                       if (muffled) 
[11:02:06.242]                         invokeRestart("muffleMessage")
[11:02:06.242]                     }
[11:02:06.242]                     else if (inherits(cond, "warning")) {
[11:02:06.242]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:06.242]                       if (muffled) 
[11:02:06.242]                         invokeRestart("muffleWarning")
[11:02:06.242]                     }
[11:02:06.242]                     else if (inherits(cond, "condition")) {
[11:02:06.242]                       if (!is.null(pattern)) {
[11:02:06.242]                         computeRestarts <- base::computeRestarts
[11:02:06.242]                         grepl <- base::grepl
[11:02:06.242]                         restarts <- computeRestarts(cond)
[11:02:06.242]                         for (restart in restarts) {
[11:02:06.242]                           name <- restart$name
[11:02:06.242]                           if (is.null(name)) 
[11:02:06.242]                             next
[11:02:06.242]                           if (!grepl(pattern, name)) 
[11:02:06.242]                             next
[11:02:06.242]                           invokeRestart(restart)
[11:02:06.242]                           muffled <- TRUE
[11:02:06.242]                           break
[11:02:06.242]                         }
[11:02:06.242]                       }
[11:02:06.242]                     }
[11:02:06.242]                     invisible(muffled)
[11:02:06.242]                   }
[11:02:06.242]                   muffleCondition(cond)
[11:02:06.242]                 })
[11:02:06.242]             }))
[11:02:06.242]             future::FutureResult(value = ...future.value$value, 
[11:02:06.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.242]                   ...future.rng), globalenv = if (FALSE) 
[11:02:06.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:06.242]                     ...future.globalenv.names))
[11:02:06.242]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:06.242]         }, condition = base::local({
[11:02:06.242]             c <- base::c
[11:02:06.242]             inherits <- base::inherits
[11:02:06.242]             invokeRestart <- base::invokeRestart
[11:02:06.242]             length <- base::length
[11:02:06.242]             list <- base::list
[11:02:06.242]             seq.int <- base::seq.int
[11:02:06.242]             signalCondition <- base::signalCondition
[11:02:06.242]             sys.calls <- base::sys.calls
[11:02:06.242]             `[[` <- base::`[[`
[11:02:06.242]             `+` <- base::`+`
[11:02:06.242]             `<<-` <- base::`<<-`
[11:02:06.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:06.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:06.242]                   3L)]
[11:02:06.242]             }
[11:02:06.242]             function(cond) {
[11:02:06.242]                 is_error <- inherits(cond, "error")
[11:02:06.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:06.242]                   NULL)
[11:02:06.242]                 if (is_error) {
[11:02:06.242]                   sessionInformation <- function() {
[11:02:06.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:06.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:06.242]                       search = base::search(), system = base::Sys.info())
[11:02:06.242]                   }
[11:02:06.242]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:06.242]                     cond$call), session = sessionInformation(), 
[11:02:06.242]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:06.242]                   signalCondition(cond)
[11:02:06.242]                 }
[11:02:06.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:06.242]                 "immediateCondition"))) {
[11:02:06.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:06.242]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:06.242]                   if (TRUE && !signal) {
[11:02:06.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.242]                     {
[11:02:06.242]                       inherits <- base::inherits
[11:02:06.242]                       invokeRestart <- base::invokeRestart
[11:02:06.242]                       is.null <- base::is.null
[11:02:06.242]                       muffled <- FALSE
[11:02:06.242]                       if (inherits(cond, "message")) {
[11:02:06.242]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.242]                         if (muffled) 
[11:02:06.242]                           invokeRestart("muffleMessage")
[11:02:06.242]                       }
[11:02:06.242]                       else if (inherits(cond, "warning")) {
[11:02:06.242]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.242]                         if (muffled) 
[11:02:06.242]                           invokeRestart("muffleWarning")
[11:02:06.242]                       }
[11:02:06.242]                       else if (inherits(cond, "condition")) {
[11:02:06.242]                         if (!is.null(pattern)) {
[11:02:06.242]                           computeRestarts <- base::computeRestarts
[11:02:06.242]                           grepl <- base::grepl
[11:02:06.242]                           restarts <- computeRestarts(cond)
[11:02:06.242]                           for (restart in restarts) {
[11:02:06.242]                             name <- restart$name
[11:02:06.242]                             if (is.null(name)) 
[11:02:06.242]                               next
[11:02:06.242]                             if (!grepl(pattern, name)) 
[11:02:06.242]                               next
[11:02:06.242]                             invokeRestart(restart)
[11:02:06.242]                             muffled <- TRUE
[11:02:06.242]                             break
[11:02:06.242]                           }
[11:02:06.242]                         }
[11:02:06.242]                       }
[11:02:06.242]                       invisible(muffled)
[11:02:06.242]                     }
[11:02:06.242]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.242]                   }
[11:02:06.242]                 }
[11:02:06.242]                 else {
[11:02:06.242]                   if (TRUE) {
[11:02:06.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.242]                     {
[11:02:06.242]                       inherits <- base::inherits
[11:02:06.242]                       invokeRestart <- base::invokeRestart
[11:02:06.242]                       is.null <- base::is.null
[11:02:06.242]                       muffled <- FALSE
[11:02:06.242]                       if (inherits(cond, "message")) {
[11:02:06.242]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.242]                         if (muffled) 
[11:02:06.242]                           invokeRestart("muffleMessage")
[11:02:06.242]                       }
[11:02:06.242]                       else if (inherits(cond, "warning")) {
[11:02:06.242]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.242]                         if (muffled) 
[11:02:06.242]                           invokeRestart("muffleWarning")
[11:02:06.242]                       }
[11:02:06.242]                       else if (inherits(cond, "condition")) {
[11:02:06.242]                         if (!is.null(pattern)) {
[11:02:06.242]                           computeRestarts <- base::computeRestarts
[11:02:06.242]                           grepl <- base::grepl
[11:02:06.242]                           restarts <- computeRestarts(cond)
[11:02:06.242]                           for (restart in restarts) {
[11:02:06.242]                             name <- restart$name
[11:02:06.242]                             if (is.null(name)) 
[11:02:06.242]                               next
[11:02:06.242]                             if (!grepl(pattern, name)) 
[11:02:06.242]                               next
[11:02:06.242]                             invokeRestart(restart)
[11:02:06.242]                             muffled <- TRUE
[11:02:06.242]                             break
[11:02:06.242]                           }
[11:02:06.242]                         }
[11:02:06.242]                       }
[11:02:06.242]                       invisible(muffled)
[11:02:06.242]                     }
[11:02:06.242]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.242]                   }
[11:02:06.242]                 }
[11:02:06.242]             }
[11:02:06.242]         }))
[11:02:06.242]     }, error = function(ex) {
[11:02:06.242]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:06.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.242]                 ...future.rng), started = ...future.startTime, 
[11:02:06.242]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:06.242]             version = "1.8"), class = "FutureResult")
[11:02:06.242]     }, finally = {
[11:02:06.242]         if (!identical(...future.workdir, getwd())) 
[11:02:06.242]             setwd(...future.workdir)
[11:02:06.242]         {
[11:02:06.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:06.242]                 ...future.oldOptions$nwarnings <- NULL
[11:02:06.242]             }
[11:02:06.242]             base::options(...future.oldOptions)
[11:02:06.242]             if (.Platform$OS.type == "windows") {
[11:02:06.242]                 old_names <- names(...future.oldEnvVars)
[11:02:06.242]                 envs <- base::Sys.getenv()
[11:02:06.242]                 names <- names(envs)
[11:02:06.242]                 common <- intersect(names, old_names)
[11:02:06.242]                 added <- setdiff(names, old_names)
[11:02:06.242]                 removed <- setdiff(old_names, names)
[11:02:06.242]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:06.242]                   envs[common]]
[11:02:06.242]                 NAMES <- toupper(changed)
[11:02:06.242]                 args <- list()
[11:02:06.242]                 for (kk in seq_along(NAMES)) {
[11:02:06.242]                   name <- changed[[kk]]
[11:02:06.242]                   NAME <- NAMES[[kk]]
[11:02:06.242]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.242]                     next
[11:02:06.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.242]                 }
[11:02:06.242]                 NAMES <- toupper(added)
[11:02:06.242]                 for (kk in seq_along(NAMES)) {
[11:02:06.242]                   name <- added[[kk]]
[11:02:06.242]                   NAME <- NAMES[[kk]]
[11:02:06.242]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.242]                     next
[11:02:06.242]                   args[[name]] <- ""
[11:02:06.242]                 }
[11:02:06.242]                 NAMES <- toupper(removed)
[11:02:06.242]                 for (kk in seq_along(NAMES)) {
[11:02:06.242]                   name <- removed[[kk]]
[11:02:06.242]                   NAME <- NAMES[[kk]]
[11:02:06.242]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.242]                     next
[11:02:06.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.242]                 }
[11:02:06.242]                 if (length(args) > 0) 
[11:02:06.242]                   base::do.call(base::Sys.setenv, args = args)
[11:02:06.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:06.242]             }
[11:02:06.242]             else {
[11:02:06.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:06.242]             }
[11:02:06.242]             {
[11:02:06.242]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:06.242]                   0L) {
[11:02:06.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:06.242]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:06.242]                   base::options(opts)
[11:02:06.242]                 }
[11:02:06.242]                 {
[11:02:06.242]                   {
[11:02:06.242]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:06.242]                     NULL
[11:02:06.242]                   }
[11:02:06.242]                   options(future.plan = NULL)
[11:02:06.242]                   if (is.na(NA_character_)) 
[11:02:06.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:06.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:06.242]                     .init = FALSE)
[11:02:06.242]                 }
[11:02:06.242]             }
[11:02:06.242]         }
[11:02:06.242]     })
[11:02:06.242]     if (TRUE) {
[11:02:06.242]         base::sink(type = "output", split = FALSE)
[11:02:06.242]         if (TRUE) {
[11:02:06.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:06.242]         }
[11:02:06.242]         else {
[11:02:06.242]             ...future.result["stdout"] <- base::list(NULL)
[11:02:06.242]         }
[11:02:06.242]         base::close(...future.stdout)
[11:02:06.242]         ...future.stdout <- NULL
[11:02:06.242]     }
[11:02:06.242]     ...future.result$conditions <- ...future.conditions
[11:02:06.242]     ...future.result$finished <- base::Sys.time()
[11:02:06.242]     ...future.result
[11:02:06.242] }
[11:02:06.245] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d252f3dd-7a92-6ee4-db84-2a586bbc6302
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:06.256] result() for ClusterFuture ...
[11:02:06.256] receiveMessageFromWorker() for ClusterFuture ...
[11:02:06.257] - Validating connection of MultisessionFuture
[11:02:06.288] - received message: FutureResult
[11:02:06.288] - Received FutureResult
[11:02:06.288] - Erased future from FutureRegistry
[11:02:06.288] result() for ClusterFuture ...
[11:02:06.289] - result already collected: FutureResult
[11:02:06.289] result() for ClusterFuture ... done
[11:02:06.289] signalConditions() ...
[11:02:06.289]  - include = ‘immediateCondition’
[11:02:06.289]  - exclude = 
[11:02:06.289]  - resignal = FALSE
[11:02:06.289]  - Number of conditions: 1
[11:02:06.289] signalConditions() ... done
[11:02:06.289] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:06.290] result() for ClusterFuture ... done
[11:02:06.290] result() for ClusterFuture ...
[11:02:06.290] - result already collected: FutureResult
[11:02:06.290] result() for ClusterFuture ... done
[11:02:06.290] signalConditions() ...
[11:02:06.290]  - include = ‘immediateCondition’
[11:02:06.290]  - exclude = 
[11:02:06.290]  - resignal = FALSE
[11:02:06.290]  - Number of conditions: 1
[11:02:06.290] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[11:02:06.291] result() for ClusterFuture ...
[11:02:06.291] - result already collected: FutureResult
[11:02:06.291] result() for ClusterFuture ... done
[11:02:06.291] result() for ClusterFuture ...
[11:02:06.291] - result already collected: FutureResult
[11:02:06.291] result() for ClusterFuture ... done
[11:02:06.291] signalConditions() ...
[11:02:06.292]  - include = ‘immediateCondition’
[11:02:06.292]  - exclude = 
[11:02:06.292]  - resignal = FALSE
[11:02:06.292]  - Number of conditions: 1
[11:02:06.292] signalConditions() ... done
[11:02:06.292] Future state: ‘finished’
[11:02:06.292] result() for ClusterFuture ...
[11:02:06.292] - result already collected: FutureResult
[11:02:06.292] result() for ClusterFuture ... done
[11:02:06.292] signalConditions() ...
[11:02:06.293]  - include = ‘condition’
[11:02:06.293]  - exclude = ‘immediateCondition’
[11:02:06.293]  - resignal = TRUE
[11:02:06.293]  - Number of conditions: 1
[11:02:06.293]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:02:06.293] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[11:02:06.294] result() for ClusterFuture ...
[11:02:06.294] - result already collected: FutureResult
[11:02:06.294] result() for ClusterFuture ... done
[11:02:06.294] result() for ClusterFuture ...
[11:02:06.294] - result already collected: FutureResult
[11:02:06.294] result() for ClusterFuture ... done
[11:02:06.294] signalConditions() ...
[11:02:06.294]  - include = ‘immediateCondition’
[11:02:06.294]  - exclude = 
[11:02:06.295]  - resignal = FALSE
[11:02:06.295]  - Number of conditions: 1
[11:02:06.295] signalConditions() ... done
[11:02:06.295] Future state: ‘finished’
[11:02:06.295] result() for ClusterFuture ...
[11:02:06.295] - result already collected: FutureResult
[11:02:06.295] result() for ClusterFuture ... done
[11:02:06.295] signalConditions() ...
[11:02:06.295]  - include = ‘condition’
[11:02:06.296]  - exclude = ‘immediateCondition’
[11:02:06.296]  - resignal = TRUE
[11:02:06.296]  - Number of conditions: 1
[11:02:06.296]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:02:06.296] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[11:02:06.298] getGlobalsAndPackages() ...
[11:02:06.298] 
[11:02:06.298] - globals: [0] <none>
[11:02:06.298] getGlobalsAndPackages() ... DONE
[11:02:06.311] Packages needed by the future expression (n = 0): <none>
[11:02:06.312] Packages needed by future strategies (n = 0): <none>
[11:02:06.312] {
[11:02:06.312]     {
[11:02:06.312]         {
[11:02:06.312]             ...future.startTime <- base::Sys.time()
[11:02:06.312]             {
[11:02:06.312]                 {
[11:02:06.312]                   {
[11:02:06.312]                     {
[11:02:06.312]                       base::local({
[11:02:06.312]                         has_future <- base::requireNamespace("future", 
[11:02:06.312]                           quietly = TRUE)
[11:02:06.312]                         if (has_future) {
[11:02:06.312]                           ns <- base::getNamespace("future")
[11:02:06.312]                           version <- ns[[".package"]][["version"]]
[11:02:06.312]                           if (is.null(version)) 
[11:02:06.312]                             version <- utils::packageVersion("future")
[11:02:06.312]                         }
[11:02:06.312]                         else {
[11:02:06.312]                           version <- NULL
[11:02:06.312]                         }
[11:02:06.312]                         if (!has_future || version < "1.8.0") {
[11:02:06.312]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:06.312]                             "", base::R.version$version.string), 
[11:02:06.312]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:06.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:06.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:06.312]                               "release", "version")], collapse = " "), 
[11:02:06.312]                             hostname = base::Sys.info()[["nodename"]])
[11:02:06.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:06.312]                             info)
[11:02:06.312]                           info <- base::paste(info, collapse = "; ")
[11:02:06.312]                           if (!has_future) {
[11:02:06.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:06.312]                               info)
[11:02:06.312]                           }
[11:02:06.312]                           else {
[11:02:06.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:06.312]                               info, version)
[11:02:06.312]                           }
[11:02:06.312]                           base::stop(msg)
[11:02:06.312]                         }
[11:02:06.312]                       })
[11:02:06.312]                     }
[11:02:06.312]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:06.312]                     base::options(mc.cores = 1L)
[11:02:06.312]                   }
[11:02:06.312]                   ...future.strategy.old <- future::plan("list")
[11:02:06.312]                   options(future.plan = NULL)
[11:02:06.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:06.312]                 }
[11:02:06.312]                 ...future.workdir <- getwd()
[11:02:06.312]             }
[11:02:06.312]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:06.312]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:06.312]         }
[11:02:06.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:06.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:06.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:06.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:06.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:06.312]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:06.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:06.312]             base::names(...future.oldOptions))
[11:02:06.312]     }
[11:02:06.312]     if (FALSE) {
[11:02:06.312]     }
[11:02:06.312]     else {
[11:02:06.312]         if (TRUE) {
[11:02:06.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:06.312]                 open = "w")
[11:02:06.312]         }
[11:02:06.312]         else {
[11:02:06.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:06.312]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:06.312]         }
[11:02:06.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:06.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:06.312]             base::sink(type = "output", split = FALSE)
[11:02:06.312]             base::close(...future.stdout)
[11:02:06.312]         }, add = TRUE)
[11:02:06.312]     }
[11:02:06.312]     ...future.frame <- base::sys.nframe()
[11:02:06.312]     ...future.conditions <- base::list()
[11:02:06.312]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:06.312]     if (FALSE) {
[11:02:06.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:06.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:06.312]     }
[11:02:06.312]     ...future.result <- base::tryCatch({
[11:02:06.312]         base::withCallingHandlers({
[11:02:06.312]             ...future.value <- base::withVisible(base::local({
[11:02:06.312]                 ...future.makeSendCondition <- base::local({
[11:02:06.312]                   sendCondition <- NULL
[11:02:06.312]                   function(frame = 1L) {
[11:02:06.312]                     if (is.function(sendCondition)) 
[11:02:06.312]                       return(sendCondition)
[11:02:06.312]                     ns <- getNamespace("parallel")
[11:02:06.312]                     if (exists("sendData", mode = "function", 
[11:02:06.312]                       envir = ns)) {
[11:02:06.312]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:06.312]                         envir = ns)
[11:02:06.312]                       envir <- sys.frame(frame)
[11:02:06.312]                       master <- NULL
[11:02:06.312]                       while (!identical(envir, .GlobalEnv) && 
[11:02:06.312]                         !identical(envir, emptyenv())) {
[11:02:06.312]                         if (exists("master", mode = "list", envir = envir, 
[11:02:06.312]                           inherits = FALSE)) {
[11:02:06.312]                           master <- get("master", mode = "list", 
[11:02:06.312]                             envir = envir, inherits = FALSE)
[11:02:06.312]                           if (inherits(master, c("SOCKnode", 
[11:02:06.312]                             "SOCK0node"))) {
[11:02:06.312]                             sendCondition <<- function(cond) {
[11:02:06.312]                               data <- list(type = "VALUE", value = cond, 
[11:02:06.312]                                 success = TRUE)
[11:02:06.312]                               parallel_sendData(master, data)
[11:02:06.312]                             }
[11:02:06.312]                             return(sendCondition)
[11:02:06.312]                           }
[11:02:06.312]                         }
[11:02:06.312]                         frame <- frame + 1L
[11:02:06.312]                         envir <- sys.frame(frame)
[11:02:06.312]                       }
[11:02:06.312]                     }
[11:02:06.312]                     sendCondition <<- function(cond) NULL
[11:02:06.312]                   }
[11:02:06.312]                 })
[11:02:06.312]                 withCallingHandlers({
[11:02:06.312]                   {
[11:02:06.312]                     stop(structure(list(message = "boom"), class = c("MyError", 
[11:02:06.312]                       "error", "condition")))
[11:02:06.312]                   }
[11:02:06.312]                 }, immediateCondition = function(cond) {
[11:02:06.312]                   sendCondition <- ...future.makeSendCondition()
[11:02:06.312]                   sendCondition(cond)
[11:02:06.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.312]                   {
[11:02:06.312]                     inherits <- base::inherits
[11:02:06.312]                     invokeRestart <- base::invokeRestart
[11:02:06.312]                     is.null <- base::is.null
[11:02:06.312]                     muffled <- FALSE
[11:02:06.312]                     if (inherits(cond, "message")) {
[11:02:06.312]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:06.312]                       if (muffled) 
[11:02:06.312]                         invokeRestart("muffleMessage")
[11:02:06.312]                     }
[11:02:06.312]                     else if (inherits(cond, "warning")) {
[11:02:06.312]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:06.312]                       if (muffled) 
[11:02:06.312]                         invokeRestart("muffleWarning")
[11:02:06.312]                     }
[11:02:06.312]                     else if (inherits(cond, "condition")) {
[11:02:06.312]                       if (!is.null(pattern)) {
[11:02:06.312]                         computeRestarts <- base::computeRestarts
[11:02:06.312]                         grepl <- base::grepl
[11:02:06.312]                         restarts <- computeRestarts(cond)
[11:02:06.312]                         for (restart in restarts) {
[11:02:06.312]                           name <- restart$name
[11:02:06.312]                           if (is.null(name)) 
[11:02:06.312]                             next
[11:02:06.312]                           if (!grepl(pattern, name)) 
[11:02:06.312]                             next
[11:02:06.312]                           invokeRestart(restart)
[11:02:06.312]                           muffled <- TRUE
[11:02:06.312]                           break
[11:02:06.312]                         }
[11:02:06.312]                       }
[11:02:06.312]                     }
[11:02:06.312]                     invisible(muffled)
[11:02:06.312]                   }
[11:02:06.312]                   muffleCondition(cond)
[11:02:06.312]                 })
[11:02:06.312]             }))
[11:02:06.312]             future::FutureResult(value = ...future.value$value, 
[11:02:06.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.312]                   ...future.rng), globalenv = if (FALSE) 
[11:02:06.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:06.312]                     ...future.globalenv.names))
[11:02:06.312]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:06.312]         }, condition = base::local({
[11:02:06.312]             c <- base::c
[11:02:06.312]             inherits <- base::inherits
[11:02:06.312]             invokeRestart <- base::invokeRestart
[11:02:06.312]             length <- base::length
[11:02:06.312]             list <- base::list
[11:02:06.312]             seq.int <- base::seq.int
[11:02:06.312]             signalCondition <- base::signalCondition
[11:02:06.312]             sys.calls <- base::sys.calls
[11:02:06.312]             `[[` <- base::`[[`
[11:02:06.312]             `+` <- base::`+`
[11:02:06.312]             `<<-` <- base::`<<-`
[11:02:06.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:06.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:06.312]                   3L)]
[11:02:06.312]             }
[11:02:06.312]             function(cond) {
[11:02:06.312]                 is_error <- inherits(cond, "error")
[11:02:06.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:06.312]                   NULL)
[11:02:06.312]                 if (is_error) {
[11:02:06.312]                   sessionInformation <- function() {
[11:02:06.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:06.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:06.312]                       search = base::search(), system = base::Sys.info())
[11:02:06.312]                   }
[11:02:06.312]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:06.312]                     cond$call), session = sessionInformation(), 
[11:02:06.312]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:06.312]                   signalCondition(cond)
[11:02:06.312]                 }
[11:02:06.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:06.312]                 "immediateCondition"))) {
[11:02:06.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:06.312]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:06.312]                   if (TRUE && !signal) {
[11:02:06.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.312]                     {
[11:02:06.312]                       inherits <- base::inherits
[11:02:06.312]                       invokeRestart <- base::invokeRestart
[11:02:06.312]                       is.null <- base::is.null
[11:02:06.312]                       muffled <- FALSE
[11:02:06.312]                       if (inherits(cond, "message")) {
[11:02:06.312]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.312]                         if (muffled) 
[11:02:06.312]                           invokeRestart("muffleMessage")
[11:02:06.312]                       }
[11:02:06.312]                       else if (inherits(cond, "warning")) {
[11:02:06.312]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.312]                         if (muffled) 
[11:02:06.312]                           invokeRestart("muffleWarning")
[11:02:06.312]                       }
[11:02:06.312]                       else if (inherits(cond, "condition")) {
[11:02:06.312]                         if (!is.null(pattern)) {
[11:02:06.312]                           computeRestarts <- base::computeRestarts
[11:02:06.312]                           grepl <- base::grepl
[11:02:06.312]                           restarts <- computeRestarts(cond)
[11:02:06.312]                           for (restart in restarts) {
[11:02:06.312]                             name <- restart$name
[11:02:06.312]                             if (is.null(name)) 
[11:02:06.312]                               next
[11:02:06.312]                             if (!grepl(pattern, name)) 
[11:02:06.312]                               next
[11:02:06.312]                             invokeRestart(restart)
[11:02:06.312]                             muffled <- TRUE
[11:02:06.312]                             break
[11:02:06.312]                           }
[11:02:06.312]                         }
[11:02:06.312]                       }
[11:02:06.312]                       invisible(muffled)
[11:02:06.312]                     }
[11:02:06.312]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.312]                   }
[11:02:06.312]                 }
[11:02:06.312]                 else {
[11:02:06.312]                   if (TRUE) {
[11:02:06.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.312]                     {
[11:02:06.312]                       inherits <- base::inherits
[11:02:06.312]                       invokeRestart <- base::invokeRestart
[11:02:06.312]                       is.null <- base::is.null
[11:02:06.312]                       muffled <- FALSE
[11:02:06.312]                       if (inherits(cond, "message")) {
[11:02:06.312]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.312]                         if (muffled) 
[11:02:06.312]                           invokeRestart("muffleMessage")
[11:02:06.312]                       }
[11:02:06.312]                       else if (inherits(cond, "warning")) {
[11:02:06.312]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.312]                         if (muffled) 
[11:02:06.312]                           invokeRestart("muffleWarning")
[11:02:06.312]                       }
[11:02:06.312]                       else if (inherits(cond, "condition")) {
[11:02:06.312]                         if (!is.null(pattern)) {
[11:02:06.312]                           computeRestarts <- base::computeRestarts
[11:02:06.312]                           grepl <- base::grepl
[11:02:06.312]                           restarts <- computeRestarts(cond)
[11:02:06.312]                           for (restart in restarts) {
[11:02:06.312]                             name <- restart$name
[11:02:06.312]                             if (is.null(name)) 
[11:02:06.312]                               next
[11:02:06.312]                             if (!grepl(pattern, name)) 
[11:02:06.312]                               next
[11:02:06.312]                             invokeRestart(restart)
[11:02:06.312]                             muffled <- TRUE
[11:02:06.312]                             break
[11:02:06.312]                           }
[11:02:06.312]                         }
[11:02:06.312]                       }
[11:02:06.312]                       invisible(muffled)
[11:02:06.312]                     }
[11:02:06.312]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.312]                   }
[11:02:06.312]                 }
[11:02:06.312]             }
[11:02:06.312]         }))
[11:02:06.312]     }, error = function(ex) {
[11:02:06.312]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:06.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.312]                 ...future.rng), started = ...future.startTime, 
[11:02:06.312]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:06.312]             version = "1.8"), class = "FutureResult")
[11:02:06.312]     }, finally = {
[11:02:06.312]         if (!identical(...future.workdir, getwd())) 
[11:02:06.312]             setwd(...future.workdir)
[11:02:06.312]         {
[11:02:06.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:06.312]                 ...future.oldOptions$nwarnings <- NULL
[11:02:06.312]             }
[11:02:06.312]             base::options(...future.oldOptions)
[11:02:06.312]             if (.Platform$OS.type == "windows") {
[11:02:06.312]                 old_names <- names(...future.oldEnvVars)
[11:02:06.312]                 envs <- base::Sys.getenv()
[11:02:06.312]                 names <- names(envs)
[11:02:06.312]                 common <- intersect(names, old_names)
[11:02:06.312]                 added <- setdiff(names, old_names)
[11:02:06.312]                 removed <- setdiff(old_names, names)
[11:02:06.312]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:06.312]                   envs[common]]
[11:02:06.312]                 NAMES <- toupper(changed)
[11:02:06.312]                 args <- list()
[11:02:06.312]                 for (kk in seq_along(NAMES)) {
[11:02:06.312]                   name <- changed[[kk]]
[11:02:06.312]                   NAME <- NAMES[[kk]]
[11:02:06.312]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.312]                     next
[11:02:06.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.312]                 }
[11:02:06.312]                 NAMES <- toupper(added)
[11:02:06.312]                 for (kk in seq_along(NAMES)) {
[11:02:06.312]                   name <- added[[kk]]
[11:02:06.312]                   NAME <- NAMES[[kk]]
[11:02:06.312]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.312]                     next
[11:02:06.312]                   args[[name]] <- ""
[11:02:06.312]                 }
[11:02:06.312]                 NAMES <- toupper(removed)
[11:02:06.312]                 for (kk in seq_along(NAMES)) {
[11:02:06.312]                   name <- removed[[kk]]
[11:02:06.312]                   NAME <- NAMES[[kk]]
[11:02:06.312]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.312]                     next
[11:02:06.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.312]                 }
[11:02:06.312]                 if (length(args) > 0) 
[11:02:06.312]                   base::do.call(base::Sys.setenv, args = args)
[11:02:06.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:06.312]             }
[11:02:06.312]             else {
[11:02:06.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:06.312]             }
[11:02:06.312]             {
[11:02:06.312]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:06.312]                   0L) {
[11:02:06.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:06.312]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:06.312]                   base::options(opts)
[11:02:06.312]                 }
[11:02:06.312]                 {
[11:02:06.312]                   {
[11:02:06.312]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:06.312]                     NULL
[11:02:06.312]                   }
[11:02:06.312]                   options(future.plan = NULL)
[11:02:06.312]                   if (is.na(NA_character_)) 
[11:02:06.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:06.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:06.312]                     .init = FALSE)
[11:02:06.312]                 }
[11:02:06.312]             }
[11:02:06.312]         }
[11:02:06.312]     })
[11:02:06.312]     if (TRUE) {
[11:02:06.312]         base::sink(type = "output", split = FALSE)
[11:02:06.312]         if (TRUE) {
[11:02:06.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:06.312]         }
[11:02:06.312]         else {
[11:02:06.312]             ...future.result["stdout"] <- base::list(NULL)
[11:02:06.312]         }
[11:02:06.312]         base::close(...future.stdout)
[11:02:06.312]         ...future.stdout <- NULL
[11:02:06.312]     }
[11:02:06.312]     ...future.result$conditions <- ...future.conditions
[11:02:06.312]     ...future.result$finished <- base::Sys.time()
[11:02:06.312]     ...future.result
[11:02:06.312] }
[11:02:06.315] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d252f3dd-7a92-6ee4-db84-2a586bbc6302
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:06.326] result() for ClusterFuture ...
[11:02:06.326] receiveMessageFromWorker() for ClusterFuture ...
[11:02:06.327] - Validating connection of MultisessionFuture
[11:02:06.357] - received message: FutureResult
[11:02:06.357] - Received FutureResult
[11:02:06.358] - Erased future from FutureRegistry
[11:02:06.358] result() for ClusterFuture ...
[11:02:06.358] - result already collected: FutureResult
[11:02:06.358] result() for ClusterFuture ... done
[11:02:06.358] signalConditions() ...
[11:02:06.358]  - include = ‘immediateCondition’
[11:02:06.358]  - exclude = 
[11:02:06.358]  - resignal = FALSE
[11:02:06.358]  - Number of conditions: 1
[11:02:06.359] signalConditions() ... done
[11:02:06.359] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:06.359] result() for ClusterFuture ... done
[11:02:06.359] result() for ClusterFuture ...
[11:02:06.359] - result already collected: FutureResult
[11:02:06.359] result() for ClusterFuture ... done
[11:02:06.359] signalConditions() ...
[11:02:06.359]  - include = ‘immediateCondition’
[11:02:06.359]  - exclude = 
[11:02:06.359]  - resignal = FALSE
[11:02:06.360]  - Number of conditions: 1
[11:02:06.360] signalConditions() ... done
<MyError: boom>
[11:02:06.360] result() for ClusterFuture ...
[11:02:06.360] - result already collected: FutureResult
[11:02:06.360] result() for ClusterFuture ... done
[11:02:06.360] result() for ClusterFuture ...
[11:02:06.360] - result already collected: FutureResult
[11:02:06.360] result() for ClusterFuture ... done
[11:02:06.361] signalConditions() ...
[11:02:06.361]  - include = ‘immediateCondition’
[11:02:06.361]  - exclude = 
[11:02:06.361]  - resignal = FALSE
[11:02:06.361]  - Number of conditions: 1
[11:02:06.361] signalConditions() ... done
[11:02:06.361] Future state: ‘finished’
[11:02:06.361] result() for ClusterFuture ...
[11:02:06.361] - result already collected: FutureResult
[11:02:06.361] result() for ClusterFuture ... done
[11:02:06.362] signalConditions() ...
[11:02:06.362]  - include = ‘condition’
[11:02:06.362]  - exclude = ‘immediateCondition’
[11:02:06.362]  - resignal = TRUE
[11:02:06.362]  - Number of conditions: 1
[11:02:06.362]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[11:02:06.362] signalConditions() ... done
Testing with 2 cores ... DONE
> 
> 
> message("*** multisession() - too large globals ... DONE")
*** multisession() - too large globals ... DONE
> 
> message("*** multisession(..., workers = 1L) ...")
*** multisession(..., workers = 1L) ...
> 
> a <- 2
> b <- 3
> yTruth <- a * b
> 
> f <- multisession({ a * b }, globals = TRUE, workers = 1L)
[11:02:06.363] getGlobalsAndPackages() ...
[11:02:06.366] Searching for globals...
[11:02:06.368] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[11:02:06.368] Searching for globals ... DONE
[11:02:06.368] Resolving globals: FALSE
[11:02:06.368] The total size of the 2 globals is 78 bytes (78 bytes)
[11:02:06.369] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 78 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘b’ (39 bytes of class ‘numeric’)
[11:02:06.369] - globals: [2] ‘a’, ‘b’
[11:02:06.369] 
[11:02:06.369] getGlobalsAndPackages() ... DONE
> rm(list = c("a", "b"))
> 
> v <- value(f)
[11:02:06.370] Packages needed by the future expression (n = 0): <none>
[11:02:06.370] Packages needed by future strategies (n = 0): <none>
[11:02:06.370] {
[11:02:06.370]     {
[11:02:06.370]         {
[11:02:06.370]             ...future.startTime <- base::Sys.time()
[11:02:06.370]             {
[11:02:06.370]                 {
[11:02:06.370]                   {
[11:02:06.370]                     base::local({
[11:02:06.370]                       has_future <- base::requireNamespace("future", 
[11:02:06.370]                         quietly = TRUE)
[11:02:06.370]                       if (has_future) {
[11:02:06.370]                         ns <- base::getNamespace("future")
[11:02:06.370]                         version <- ns[[".package"]][["version"]]
[11:02:06.370]                         if (is.null(version)) 
[11:02:06.370]                           version <- utils::packageVersion("future")
[11:02:06.370]                       }
[11:02:06.370]                       else {
[11:02:06.370]                         version <- NULL
[11:02:06.370]                       }
[11:02:06.370]                       if (!has_future || version < "1.8.0") {
[11:02:06.370]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:06.370]                           "", base::R.version$version.string), 
[11:02:06.370]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:06.370]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:06.370]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:06.370]                             "release", "version")], collapse = " "), 
[11:02:06.370]                           hostname = base::Sys.info()[["nodename"]])
[11:02:06.370]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:06.370]                           info)
[11:02:06.370]                         info <- base::paste(info, collapse = "; ")
[11:02:06.370]                         if (!has_future) {
[11:02:06.370]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:06.370]                             info)
[11:02:06.370]                         }
[11:02:06.370]                         else {
[11:02:06.370]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:06.370]                             info, version)
[11:02:06.370]                         }
[11:02:06.370]                         base::stop(msg)
[11:02:06.370]                       }
[11:02:06.370]                     })
[11:02:06.370]                   }
[11:02:06.370]                   ...future.strategy.old <- future::plan("list")
[11:02:06.370]                   options(future.plan = NULL)
[11:02:06.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:06.370]                 }
[11:02:06.370]                 ...future.workdir <- getwd()
[11:02:06.370]             }
[11:02:06.370]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:06.370]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:06.370]         }
[11:02:06.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:06.370]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:06.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:06.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:06.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:06.370]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:06.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:06.370]             base::names(...future.oldOptions))
[11:02:06.370]     }
[11:02:06.370]     if (FALSE) {
[11:02:06.370]     }
[11:02:06.370]     else {
[11:02:06.370]         if (TRUE) {
[11:02:06.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:06.370]                 open = "w")
[11:02:06.370]         }
[11:02:06.370]         else {
[11:02:06.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:06.370]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:06.370]         }
[11:02:06.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:06.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:06.370]             base::sink(type = "output", split = FALSE)
[11:02:06.370]             base::close(...future.stdout)
[11:02:06.370]         }, add = TRUE)
[11:02:06.370]     }
[11:02:06.370]     ...future.frame <- base::sys.nframe()
[11:02:06.370]     ...future.conditions <- base::list()
[11:02:06.370]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:06.370]     if (FALSE) {
[11:02:06.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:06.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:06.370]     }
[11:02:06.370]     ...future.result <- base::tryCatch({
[11:02:06.370]         base::withCallingHandlers({
[11:02:06.370]             ...future.value <- base::withVisible(base::local({
[11:02:06.370]                 a * b
[11:02:06.370]             }))
[11:02:06.370]             future::FutureResult(value = ...future.value$value, 
[11:02:06.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.370]                   ...future.rng), globalenv = if (FALSE) 
[11:02:06.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:06.370]                     ...future.globalenv.names))
[11:02:06.370]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:06.370]         }, condition = base::local({
[11:02:06.370]             c <- base::c
[11:02:06.370]             inherits <- base::inherits
[11:02:06.370]             invokeRestart <- base::invokeRestart
[11:02:06.370]             length <- base::length
[11:02:06.370]             list <- base::list
[11:02:06.370]             seq.int <- base::seq.int
[11:02:06.370]             signalCondition <- base::signalCondition
[11:02:06.370]             sys.calls <- base::sys.calls
[11:02:06.370]             `[[` <- base::`[[`
[11:02:06.370]             `+` <- base::`+`
[11:02:06.370]             `<<-` <- base::`<<-`
[11:02:06.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:06.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:06.370]                   3L)]
[11:02:06.370]             }
[11:02:06.370]             function(cond) {
[11:02:06.370]                 is_error <- inherits(cond, "error")
[11:02:06.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:06.370]                   NULL)
[11:02:06.370]                 if (is_error) {
[11:02:06.370]                   sessionInformation <- function() {
[11:02:06.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:06.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:06.370]                       search = base::search(), system = base::Sys.info())
[11:02:06.370]                   }
[11:02:06.370]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:06.370]                     cond$call), session = sessionInformation(), 
[11:02:06.370]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:06.370]                   signalCondition(cond)
[11:02:06.370]                 }
[11:02:06.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:06.370]                 "immediateCondition"))) {
[11:02:06.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:06.370]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:06.370]                   if (TRUE && !signal) {
[11:02:06.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.370]                     {
[11:02:06.370]                       inherits <- base::inherits
[11:02:06.370]                       invokeRestart <- base::invokeRestart
[11:02:06.370]                       is.null <- base::is.null
[11:02:06.370]                       muffled <- FALSE
[11:02:06.370]                       if (inherits(cond, "message")) {
[11:02:06.370]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.370]                         if (muffled) 
[11:02:06.370]                           invokeRestart("muffleMessage")
[11:02:06.370]                       }
[11:02:06.370]                       else if (inherits(cond, "warning")) {
[11:02:06.370]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.370]                         if (muffled) 
[11:02:06.370]                           invokeRestart("muffleWarning")
[11:02:06.370]                       }
[11:02:06.370]                       else if (inherits(cond, "condition")) {
[11:02:06.370]                         if (!is.null(pattern)) {
[11:02:06.370]                           computeRestarts <- base::computeRestarts
[11:02:06.370]                           grepl <- base::grepl
[11:02:06.370]                           restarts <- computeRestarts(cond)
[11:02:06.370]                           for (restart in restarts) {
[11:02:06.370]                             name <- restart$name
[11:02:06.370]                             if (is.null(name)) 
[11:02:06.370]                               next
[11:02:06.370]                             if (!grepl(pattern, name)) 
[11:02:06.370]                               next
[11:02:06.370]                             invokeRestart(restart)
[11:02:06.370]                             muffled <- TRUE
[11:02:06.370]                             break
[11:02:06.370]                           }
[11:02:06.370]                         }
[11:02:06.370]                       }
[11:02:06.370]                       invisible(muffled)
[11:02:06.370]                     }
[11:02:06.370]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.370]                   }
[11:02:06.370]                 }
[11:02:06.370]                 else {
[11:02:06.370]                   if (TRUE) {
[11:02:06.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.370]                     {
[11:02:06.370]                       inherits <- base::inherits
[11:02:06.370]                       invokeRestart <- base::invokeRestart
[11:02:06.370]                       is.null <- base::is.null
[11:02:06.370]                       muffled <- FALSE
[11:02:06.370]                       if (inherits(cond, "message")) {
[11:02:06.370]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.370]                         if (muffled) 
[11:02:06.370]                           invokeRestart("muffleMessage")
[11:02:06.370]                       }
[11:02:06.370]                       else if (inherits(cond, "warning")) {
[11:02:06.370]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.370]                         if (muffled) 
[11:02:06.370]                           invokeRestart("muffleWarning")
[11:02:06.370]                       }
[11:02:06.370]                       else if (inherits(cond, "condition")) {
[11:02:06.370]                         if (!is.null(pattern)) {
[11:02:06.370]                           computeRestarts <- base::computeRestarts
[11:02:06.370]                           grepl <- base::grepl
[11:02:06.370]                           restarts <- computeRestarts(cond)
[11:02:06.370]                           for (restart in restarts) {
[11:02:06.370]                             name <- restart$name
[11:02:06.370]                             if (is.null(name)) 
[11:02:06.370]                               next
[11:02:06.370]                             if (!grepl(pattern, name)) 
[11:02:06.370]                               next
[11:02:06.370]                             invokeRestart(restart)
[11:02:06.370]                             muffled <- TRUE
[11:02:06.370]                             break
[11:02:06.370]                           }
[11:02:06.370]                         }
[11:02:06.370]                       }
[11:02:06.370]                       invisible(muffled)
[11:02:06.370]                     }
[11:02:06.370]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.370]                   }
[11:02:06.370]                 }
[11:02:06.370]             }
[11:02:06.370]         }))
[11:02:06.370]     }, error = function(ex) {
[11:02:06.370]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:06.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.370]                 ...future.rng), started = ...future.startTime, 
[11:02:06.370]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:06.370]             version = "1.8"), class = "FutureResult")
[11:02:06.370]     }, finally = {
[11:02:06.370]         if (!identical(...future.workdir, getwd())) 
[11:02:06.370]             setwd(...future.workdir)
[11:02:06.370]         {
[11:02:06.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:06.370]                 ...future.oldOptions$nwarnings <- NULL
[11:02:06.370]             }
[11:02:06.370]             base::options(...future.oldOptions)
[11:02:06.370]             if (.Platform$OS.type == "windows") {
[11:02:06.370]                 old_names <- names(...future.oldEnvVars)
[11:02:06.370]                 envs <- base::Sys.getenv()
[11:02:06.370]                 names <- names(envs)
[11:02:06.370]                 common <- intersect(names, old_names)
[11:02:06.370]                 added <- setdiff(names, old_names)
[11:02:06.370]                 removed <- setdiff(old_names, names)
[11:02:06.370]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:06.370]                   envs[common]]
[11:02:06.370]                 NAMES <- toupper(changed)
[11:02:06.370]                 args <- list()
[11:02:06.370]                 for (kk in seq_along(NAMES)) {
[11:02:06.370]                   name <- changed[[kk]]
[11:02:06.370]                   NAME <- NAMES[[kk]]
[11:02:06.370]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.370]                     next
[11:02:06.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.370]                 }
[11:02:06.370]                 NAMES <- toupper(added)
[11:02:06.370]                 for (kk in seq_along(NAMES)) {
[11:02:06.370]                   name <- added[[kk]]
[11:02:06.370]                   NAME <- NAMES[[kk]]
[11:02:06.370]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.370]                     next
[11:02:06.370]                   args[[name]] <- ""
[11:02:06.370]                 }
[11:02:06.370]                 NAMES <- toupper(removed)
[11:02:06.370]                 for (kk in seq_along(NAMES)) {
[11:02:06.370]                   name <- removed[[kk]]
[11:02:06.370]                   NAME <- NAMES[[kk]]
[11:02:06.370]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.370]                     next
[11:02:06.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.370]                 }
[11:02:06.370]                 if (length(args) > 0) 
[11:02:06.370]                   base::do.call(base::Sys.setenv, args = args)
[11:02:06.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:06.370]             }
[11:02:06.370]             else {
[11:02:06.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:06.370]             }
[11:02:06.370]             {
[11:02:06.370]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:06.370]                   0L) {
[11:02:06.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:06.370]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:06.370]                   base::options(opts)
[11:02:06.370]                 }
[11:02:06.370]                 {
[11:02:06.370]                   {
[11:02:06.370]                     NULL
[11:02:06.370]                     RNGkind("Mersenne-Twister")
[11:02:06.370]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:06.370]                       inherits = FALSE)
[11:02:06.370]                   }
[11:02:06.370]                   options(future.plan = NULL)
[11:02:06.370]                   if (is.na(NA_character_)) 
[11:02:06.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:06.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:06.370]                     .init = FALSE)
[11:02:06.370]                 }
[11:02:06.370]             }
[11:02:06.370]         }
[11:02:06.370]     })
[11:02:06.370]     if (TRUE) {
[11:02:06.370]         base::sink(type = "output", split = FALSE)
[11:02:06.370]         if (TRUE) {
[11:02:06.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:06.370]         }
[11:02:06.370]         else {
[11:02:06.370]             ...future.result["stdout"] <- base::list(NULL)
[11:02:06.370]         }
[11:02:06.370]         base::close(...future.stdout)
[11:02:06.370]         ...future.stdout <- NULL
[11:02:06.370]     }
[11:02:06.370]     ...future.result$conditions <- ...future.conditions
[11:02:06.370]     ...future.result$finished <- base::Sys.time()
[11:02:06.370]     ...future.result
[11:02:06.370] }
[11:02:06.373] assign_globals() ...
[11:02:06.373] List of 2
[11:02:06.373]  $ a: num 2
[11:02:06.373]  $ b: num 3
[11:02:06.373]  - attr(*, "where")=List of 2
[11:02:06.373]   ..$ a:<environment: R_EmptyEnv> 
[11:02:06.373]   ..$ b:<environment: R_EmptyEnv> 
[11:02:06.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:06.373]  - attr(*, "resolved")= logi FALSE
[11:02:06.373]  - attr(*, "total_size")= num 78
[11:02:06.376] - copied ‘a’ to environment
[11:02:06.376] - copied ‘b’ to environment
[11:02:06.376] assign_globals() ... done
[11:02:06.376] plan(): Setting new future strategy stack:
[11:02:06.376] List of future strategies:
[11:02:06.376] 1. sequential:
[11:02:06.376]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:06.376]    - tweaked: FALSE
[11:02:06.376]    - call: NULL
[11:02:06.377] plan(): nbrOfWorkers() = 1
[11:02:06.377] plan(): Setting new future strategy stack:
[11:02:06.378] List of future strategies:
[11:02:06.378] 1. sequential:
[11:02:06.378]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:06.378]    - tweaked: FALSE
[11:02:06.378]    - call: future::plan("sequential")
[11:02:06.378] plan(): nbrOfWorkers() = 1
[11:02:06.378] SequentialFuture started (and completed)
> print(v)
[1] 6
> stopifnot(v == yTruth)
> 
> message("*** multisession(..., workers = 1L) ... DONE")
*** multisession(..., workers = 1L) ... DONE
> 
> 
> message("*** multisession(..., gc = TRUE) ...")
*** multisession(..., gc = TRUE) ...
> plan(multisession, workers = 2L)
[11:02:06.379] plan(): Setting new future strategy stack:
[11:02:06.379] List of future strategies:
[11:02:06.379] 1. multisession:
[11:02:06.379]    - args: function (..., workers = 2L, envir = parent.frame())
[11:02:06.379]    - tweaked: TRUE
[11:02:06.379]    - call: plan(multisession, workers = 2L)
[11:02:06.390] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:02:06.390] multisession:
[11:02:06.390] - args: function (..., workers = 2L, envir = parent.frame())
[11:02:06.390] - tweaked: TRUE
[11:02:06.390] - call: plan(multisession, workers = 2L)
[11:02:06.390] getGlobalsAndPackages() ...
[11:02:06.391] Not searching for globals
[11:02:06.391] - globals: [0] <none>
[11:02:06.391] getGlobalsAndPackages() ... DONE
[11:02:06.647] Packages needed by the future expression (n = 0): <none>
[11:02:06.648] Packages needed by future strategies (n = 0): <none>
[11:02:06.648] {
[11:02:06.648]     {
[11:02:06.648]         {
[11:02:06.648]             ...future.startTime <- base::Sys.time()
[11:02:06.648]             {
[11:02:06.648]                 {
[11:02:06.648]                   {
[11:02:06.648]                     {
[11:02:06.648]                       base::local({
[11:02:06.648]                         has_future <- base::requireNamespace("future", 
[11:02:06.648]                           quietly = TRUE)
[11:02:06.648]                         if (has_future) {
[11:02:06.648]                           ns <- base::getNamespace("future")
[11:02:06.648]                           version <- ns[[".package"]][["version"]]
[11:02:06.648]                           if (is.null(version)) 
[11:02:06.648]                             version <- utils::packageVersion("future")
[11:02:06.648]                         }
[11:02:06.648]                         else {
[11:02:06.648]                           version <- NULL
[11:02:06.648]                         }
[11:02:06.648]                         if (!has_future || version < "1.8.0") {
[11:02:06.648]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:06.648]                             "", base::R.version$version.string), 
[11:02:06.648]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:06.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:06.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:06.648]                               "release", "version")], collapse = " "), 
[11:02:06.648]                             hostname = base::Sys.info()[["nodename"]])
[11:02:06.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:06.648]                             info)
[11:02:06.648]                           info <- base::paste(info, collapse = "; ")
[11:02:06.648]                           if (!has_future) {
[11:02:06.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:06.648]                               info)
[11:02:06.648]                           }
[11:02:06.648]                           else {
[11:02:06.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:06.648]                               info, version)
[11:02:06.648]                           }
[11:02:06.648]                           base::stop(msg)
[11:02:06.648]                         }
[11:02:06.648]                       })
[11:02:06.648]                     }
[11:02:06.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:06.648]                     base::options(mc.cores = 1L)
[11:02:06.648]                   }
[11:02:06.648]                   ...future.strategy.old <- future::plan("list")
[11:02:06.648]                   options(future.plan = NULL)
[11:02:06.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:06.648]                 }
[11:02:06.648]                 ...future.workdir <- getwd()
[11:02:06.648]             }
[11:02:06.648]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:06.648]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:06.648]         }
[11:02:06.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:06.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:06.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:06.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:06.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:06.648]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:06.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:06.648]             base::names(...future.oldOptions))
[11:02:06.648]     }
[11:02:06.648]     if (FALSE) {
[11:02:06.648]     }
[11:02:06.648]     else {
[11:02:06.648]         if (TRUE) {
[11:02:06.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:06.648]                 open = "w")
[11:02:06.648]         }
[11:02:06.648]         else {
[11:02:06.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:06.648]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:06.648]         }
[11:02:06.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:06.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:06.648]             base::sink(type = "output", split = FALSE)
[11:02:06.648]             base::close(...future.stdout)
[11:02:06.648]         }, add = TRUE)
[11:02:06.648]     }
[11:02:06.648]     ...future.frame <- base::sys.nframe()
[11:02:06.648]     ...future.conditions <- base::list()
[11:02:06.648]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:06.648]     if (FALSE) {
[11:02:06.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:06.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:06.648]     }
[11:02:06.648]     ...future.result <- base::tryCatch({
[11:02:06.648]         base::withCallingHandlers({
[11:02:06.648]             ...future.value <- base::withVisible(base::local({
[11:02:06.648]                 ...future.makeSendCondition <- base::local({
[11:02:06.648]                   sendCondition <- NULL
[11:02:06.648]                   function(frame = 1L) {
[11:02:06.648]                     if (is.function(sendCondition)) 
[11:02:06.648]                       return(sendCondition)
[11:02:06.648]                     ns <- getNamespace("parallel")
[11:02:06.648]                     if (exists("sendData", mode = "function", 
[11:02:06.648]                       envir = ns)) {
[11:02:06.648]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:06.648]                         envir = ns)
[11:02:06.648]                       envir <- sys.frame(frame)
[11:02:06.648]                       master <- NULL
[11:02:06.648]                       while (!identical(envir, .GlobalEnv) && 
[11:02:06.648]                         !identical(envir, emptyenv())) {
[11:02:06.648]                         if (exists("master", mode = "list", envir = envir, 
[11:02:06.648]                           inherits = FALSE)) {
[11:02:06.648]                           master <- get("master", mode = "list", 
[11:02:06.648]                             envir = envir, inherits = FALSE)
[11:02:06.648]                           if (inherits(master, c("SOCKnode", 
[11:02:06.648]                             "SOCK0node"))) {
[11:02:06.648]                             sendCondition <<- function(cond) {
[11:02:06.648]                               data <- list(type = "VALUE", value = cond, 
[11:02:06.648]                                 success = TRUE)
[11:02:06.648]                               parallel_sendData(master, data)
[11:02:06.648]                             }
[11:02:06.648]                             return(sendCondition)
[11:02:06.648]                           }
[11:02:06.648]                         }
[11:02:06.648]                         frame <- frame + 1L
[11:02:06.648]                         envir <- sys.frame(frame)
[11:02:06.648]                       }
[11:02:06.648]                     }
[11:02:06.648]                     sendCondition <<- function(cond) NULL
[11:02:06.648]                   }
[11:02:06.648]                 })
[11:02:06.648]                 withCallingHandlers({
[11:02:06.648]                   NA
[11:02:06.648]                 }, immediateCondition = function(cond) {
[11:02:06.648]                   sendCondition <- ...future.makeSendCondition()
[11:02:06.648]                   sendCondition(cond)
[11:02:06.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.648]                   {
[11:02:06.648]                     inherits <- base::inherits
[11:02:06.648]                     invokeRestart <- base::invokeRestart
[11:02:06.648]                     is.null <- base::is.null
[11:02:06.648]                     muffled <- FALSE
[11:02:06.648]                     if (inherits(cond, "message")) {
[11:02:06.648]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:06.648]                       if (muffled) 
[11:02:06.648]                         invokeRestart("muffleMessage")
[11:02:06.648]                     }
[11:02:06.648]                     else if (inherits(cond, "warning")) {
[11:02:06.648]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:06.648]                       if (muffled) 
[11:02:06.648]                         invokeRestart("muffleWarning")
[11:02:06.648]                     }
[11:02:06.648]                     else if (inherits(cond, "condition")) {
[11:02:06.648]                       if (!is.null(pattern)) {
[11:02:06.648]                         computeRestarts <- base::computeRestarts
[11:02:06.648]                         grepl <- base::grepl
[11:02:06.648]                         restarts <- computeRestarts(cond)
[11:02:06.648]                         for (restart in restarts) {
[11:02:06.648]                           name <- restart$name
[11:02:06.648]                           if (is.null(name)) 
[11:02:06.648]                             next
[11:02:06.648]                           if (!grepl(pattern, name)) 
[11:02:06.648]                             next
[11:02:06.648]                           invokeRestart(restart)
[11:02:06.648]                           muffled <- TRUE
[11:02:06.648]                           break
[11:02:06.648]                         }
[11:02:06.648]                       }
[11:02:06.648]                     }
[11:02:06.648]                     invisible(muffled)
[11:02:06.648]                   }
[11:02:06.648]                   muffleCondition(cond)
[11:02:06.648]                 })
[11:02:06.648]             }))
[11:02:06.648]             future::FutureResult(value = ...future.value$value, 
[11:02:06.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.648]                   ...future.rng), globalenv = if (FALSE) 
[11:02:06.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:06.648]                     ...future.globalenv.names))
[11:02:06.648]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:06.648]         }, condition = base::local({
[11:02:06.648]             c <- base::c
[11:02:06.648]             inherits <- base::inherits
[11:02:06.648]             invokeRestart <- base::invokeRestart
[11:02:06.648]             length <- base::length
[11:02:06.648]             list <- base::list
[11:02:06.648]             seq.int <- base::seq.int
[11:02:06.648]             signalCondition <- base::signalCondition
[11:02:06.648]             sys.calls <- base::sys.calls
[11:02:06.648]             `[[` <- base::`[[`
[11:02:06.648]             `+` <- base::`+`
[11:02:06.648]             `<<-` <- base::`<<-`
[11:02:06.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:06.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:06.648]                   3L)]
[11:02:06.648]             }
[11:02:06.648]             function(cond) {
[11:02:06.648]                 is_error <- inherits(cond, "error")
[11:02:06.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:06.648]                   NULL)
[11:02:06.648]                 if (is_error) {
[11:02:06.648]                   sessionInformation <- function() {
[11:02:06.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:06.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:06.648]                       search = base::search(), system = base::Sys.info())
[11:02:06.648]                   }
[11:02:06.648]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:06.648]                     cond$call), session = sessionInformation(), 
[11:02:06.648]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:06.648]                   signalCondition(cond)
[11:02:06.648]                 }
[11:02:06.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:06.648]                 "immediateCondition"))) {
[11:02:06.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:06.648]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:06.648]                   if (TRUE && !signal) {
[11:02:06.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.648]                     {
[11:02:06.648]                       inherits <- base::inherits
[11:02:06.648]                       invokeRestart <- base::invokeRestart
[11:02:06.648]                       is.null <- base::is.null
[11:02:06.648]                       muffled <- FALSE
[11:02:06.648]                       if (inherits(cond, "message")) {
[11:02:06.648]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.648]                         if (muffled) 
[11:02:06.648]                           invokeRestart("muffleMessage")
[11:02:06.648]                       }
[11:02:06.648]                       else if (inherits(cond, "warning")) {
[11:02:06.648]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.648]                         if (muffled) 
[11:02:06.648]                           invokeRestart("muffleWarning")
[11:02:06.648]                       }
[11:02:06.648]                       else if (inherits(cond, "condition")) {
[11:02:06.648]                         if (!is.null(pattern)) {
[11:02:06.648]                           computeRestarts <- base::computeRestarts
[11:02:06.648]                           grepl <- base::grepl
[11:02:06.648]                           restarts <- computeRestarts(cond)
[11:02:06.648]                           for (restart in restarts) {
[11:02:06.648]                             name <- restart$name
[11:02:06.648]                             if (is.null(name)) 
[11:02:06.648]                               next
[11:02:06.648]                             if (!grepl(pattern, name)) 
[11:02:06.648]                               next
[11:02:06.648]                             invokeRestart(restart)
[11:02:06.648]                             muffled <- TRUE
[11:02:06.648]                             break
[11:02:06.648]                           }
[11:02:06.648]                         }
[11:02:06.648]                       }
[11:02:06.648]                       invisible(muffled)
[11:02:06.648]                     }
[11:02:06.648]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.648]                   }
[11:02:06.648]                 }
[11:02:06.648]                 else {
[11:02:06.648]                   if (TRUE) {
[11:02:06.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.648]                     {
[11:02:06.648]                       inherits <- base::inherits
[11:02:06.648]                       invokeRestart <- base::invokeRestart
[11:02:06.648]                       is.null <- base::is.null
[11:02:06.648]                       muffled <- FALSE
[11:02:06.648]                       if (inherits(cond, "message")) {
[11:02:06.648]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.648]                         if (muffled) 
[11:02:06.648]                           invokeRestart("muffleMessage")
[11:02:06.648]                       }
[11:02:06.648]                       else if (inherits(cond, "warning")) {
[11:02:06.648]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.648]                         if (muffled) 
[11:02:06.648]                           invokeRestart("muffleWarning")
[11:02:06.648]                       }
[11:02:06.648]                       else if (inherits(cond, "condition")) {
[11:02:06.648]                         if (!is.null(pattern)) {
[11:02:06.648]                           computeRestarts <- base::computeRestarts
[11:02:06.648]                           grepl <- base::grepl
[11:02:06.648]                           restarts <- computeRestarts(cond)
[11:02:06.648]                           for (restart in restarts) {
[11:02:06.648]                             name <- restart$name
[11:02:06.648]                             if (is.null(name)) 
[11:02:06.648]                               next
[11:02:06.648]                             if (!grepl(pattern, name)) 
[11:02:06.648]                               next
[11:02:06.648]                             invokeRestart(restart)
[11:02:06.648]                             muffled <- TRUE
[11:02:06.648]                             break
[11:02:06.648]                           }
[11:02:06.648]                         }
[11:02:06.648]                       }
[11:02:06.648]                       invisible(muffled)
[11:02:06.648]                     }
[11:02:06.648]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.648]                   }
[11:02:06.648]                 }
[11:02:06.648]             }
[11:02:06.648]         }))
[11:02:06.648]     }, error = function(ex) {
[11:02:06.648]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:06.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.648]                 ...future.rng), started = ...future.startTime, 
[11:02:06.648]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:06.648]             version = "1.8"), class = "FutureResult")
[11:02:06.648]     }, finally = {
[11:02:06.648]         if (!identical(...future.workdir, getwd())) 
[11:02:06.648]             setwd(...future.workdir)
[11:02:06.648]         {
[11:02:06.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:06.648]                 ...future.oldOptions$nwarnings <- NULL
[11:02:06.648]             }
[11:02:06.648]             base::options(...future.oldOptions)
[11:02:06.648]             if (.Platform$OS.type == "windows") {
[11:02:06.648]                 old_names <- names(...future.oldEnvVars)
[11:02:06.648]                 envs <- base::Sys.getenv()
[11:02:06.648]                 names <- names(envs)
[11:02:06.648]                 common <- intersect(names, old_names)
[11:02:06.648]                 added <- setdiff(names, old_names)
[11:02:06.648]                 removed <- setdiff(old_names, names)
[11:02:06.648]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:06.648]                   envs[common]]
[11:02:06.648]                 NAMES <- toupper(changed)
[11:02:06.648]                 args <- list()
[11:02:06.648]                 for (kk in seq_along(NAMES)) {
[11:02:06.648]                   name <- changed[[kk]]
[11:02:06.648]                   NAME <- NAMES[[kk]]
[11:02:06.648]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.648]                     next
[11:02:06.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.648]                 }
[11:02:06.648]                 NAMES <- toupper(added)
[11:02:06.648]                 for (kk in seq_along(NAMES)) {
[11:02:06.648]                   name <- added[[kk]]
[11:02:06.648]                   NAME <- NAMES[[kk]]
[11:02:06.648]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.648]                     next
[11:02:06.648]                   args[[name]] <- ""
[11:02:06.648]                 }
[11:02:06.648]                 NAMES <- toupper(removed)
[11:02:06.648]                 for (kk in seq_along(NAMES)) {
[11:02:06.648]                   name <- removed[[kk]]
[11:02:06.648]                   NAME <- NAMES[[kk]]
[11:02:06.648]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.648]                     next
[11:02:06.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.648]                 }
[11:02:06.648]                 if (length(args) > 0) 
[11:02:06.648]                   base::do.call(base::Sys.setenv, args = args)
[11:02:06.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:06.648]             }
[11:02:06.648]             else {
[11:02:06.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:06.648]             }
[11:02:06.648]             {
[11:02:06.648]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:06.648]                   0L) {
[11:02:06.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:06.648]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:06.648]                   base::options(opts)
[11:02:06.648]                 }
[11:02:06.648]                 {
[11:02:06.648]                   {
[11:02:06.648]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:06.648]                     NULL
[11:02:06.648]                   }
[11:02:06.648]                   options(future.plan = NULL)
[11:02:06.648]                   if (is.na(NA_character_)) 
[11:02:06.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:06.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:06.648]                     .init = FALSE)
[11:02:06.648]                 }
[11:02:06.648]             }
[11:02:06.648]         }
[11:02:06.648]     })
[11:02:06.648]     if (TRUE) {
[11:02:06.648]         base::sink(type = "output", split = FALSE)
[11:02:06.648]         if (TRUE) {
[11:02:06.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:06.648]         }
[11:02:06.648]         else {
[11:02:06.648]             ...future.result["stdout"] <- base::list(NULL)
[11:02:06.648]         }
[11:02:06.648]         base::close(...future.stdout)
[11:02:06.648]         ...future.stdout <- NULL
[11:02:06.648]     }
[11:02:06.648]     ...future.result$conditions <- ...future.conditions
[11:02:06.648]     ...future.result$finished <- base::Sys.time()
[11:02:06.648]     ...future.result
[11:02:06.648] }
[11:02:06.700] MultisessionFuture started
[11:02:06.700] result() for ClusterFuture ...
[11:02:06.700] receiveMessageFromWorker() for ClusterFuture ...
[11:02:06.700] - Validating connection of MultisessionFuture
[11:02:06.731] - received message: FutureResult
[11:02:06.731] - Received FutureResult
[11:02:06.731] - Erased future from FutureRegistry
[11:02:06.731] result() for ClusterFuture ...
[11:02:06.731] - result already collected: FutureResult
[11:02:06.731] result() for ClusterFuture ... done
[11:02:06.731] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:06.732] result() for ClusterFuture ... done
[11:02:06.732] result() for ClusterFuture ...
[11:02:06.732] - result already collected: FutureResult
[11:02:06.732] result() for ClusterFuture ... done
[11:02:06.732] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:02:06.732] plan(): nbrOfWorkers() = 2
> 
> f <- future({ gc() })
[11:02:06.732] getGlobalsAndPackages() ...
[11:02:06.732] Searching for globals...
[11:02:06.733] - globals found: [2] ‘{’, ‘gc’
[11:02:06.733] Searching for globals ... DONE
[11:02:06.734] Resolving globals: FALSE
[11:02:06.734] 
[11:02:06.734] 
[11:02:06.734] getGlobalsAndPackages() ... DONE
[11:02:06.734] run() for ‘Future’ ...
[11:02:06.734] - state: ‘created’
[11:02:06.735] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:06.747] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:06.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:06.747]   - Field: ‘node’
[11:02:06.747]   - Field: ‘label’
[11:02:06.747]   - Field: ‘local’
[11:02:06.748]   - Field: ‘owner’
[11:02:06.748]   - Field: ‘envir’
[11:02:06.748]   - Field: ‘workers’
[11:02:06.748]   - Field: ‘packages’
[11:02:06.748]   - Field: ‘gc’
[11:02:06.748]   - Field: ‘conditions’
[11:02:06.748]   - Field: ‘persistent’
[11:02:06.748]   - Field: ‘expr’
[11:02:06.748]   - Field: ‘uuid’
[11:02:06.748]   - Field: ‘seed’
[11:02:06.748]   - Field: ‘version’
[11:02:06.749]   - Field: ‘result’
[11:02:06.749]   - Field: ‘asynchronous’
[11:02:06.749]   - Field: ‘calls’
[11:02:06.749]   - Field: ‘globals’
[11:02:06.749]   - Field: ‘stdout’
[11:02:06.749]   - Field: ‘earlySignal’
[11:02:06.749]   - Field: ‘lazy’
[11:02:06.749]   - Field: ‘state’
[11:02:06.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:06.749] - Launch lazy future ...
[11:02:06.750] Packages needed by the future expression (n = 0): <none>
[11:02:06.750] Packages needed by future strategies (n = 0): <none>
[11:02:06.750] {
[11:02:06.750]     {
[11:02:06.750]         {
[11:02:06.750]             ...future.startTime <- base::Sys.time()
[11:02:06.750]             {
[11:02:06.750]                 {
[11:02:06.750]                   {
[11:02:06.750]                     {
[11:02:06.750]                       base::local({
[11:02:06.750]                         has_future <- base::requireNamespace("future", 
[11:02:06.750]                           quietly = TRUE)
[11:02:06.750]                         if (has_future) {
[11:02:06.750]                           ns <- base::getNamespace("future")
[11:02:06.750]                           version <- ns[[".package"]][["version"]]
[11:02:06.750]                           if (is.null(version)) 
[11:02:06.750]                             version <- utils::packageVersion("future")
[11:02:06.750]                         }
[11:02:06.750]                         else {
[11:02:06.750]                           version <- NULL
[11:02:06.750]                         }
[11:02:06.750]                         if (!has_future || version < "1.8.0") {
[11:02:06.750]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:06.750]                             "", base::R.version$version.string), 
[11:02:06.750]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:06.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:06.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:06.750]                               "release", "version")], collapse = " "), 
[11:02:06.750]                             hostname = base::Sys.info()[["nodename"]])
[11:02:06.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:06.750]                             info)
[11:02:06.750]                           info <- base::paste(info, collapse = "; ")
[11:02:06.750]                           if (!has_future) {
[11:02:06.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:06.750]                               info)
[11:02:06.750]                           }
[11:02:06.750]                           else {
[11:02:06.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:06.750]                               info, version)
[11:02:06.750]                           }
[11:02:06.750]                           base::stop(msg)
[11:02:06.750]                         }
[11:02:06.750]                       })
[11:02:06.750]                     }
[11:02:06.750]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:06.750]                     base::options(mc.cores = 1L)
[11:02:06.750]                   }
[11:02:06.750]                   ...future.strategy.old <- future::plan("list")
[11:02:06.750]                   options(future.plan = NULL)
[11:02:06.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:06.750]                 }
[11:02:06.750]                 ...future.workdir <- getwd()
[11:02:06.750]             }
[11:02:06.750]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:06.750]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:06.750]         }
[11:02:06.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:06.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:06.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:06.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:06.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:06.750]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:06.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:06.750]             base::names(...future.oldOptions))
[11:02:06.750]     }
[11:02:06.750]     if (FALSE) {
[11:02:06.750]     }
[11:02:06.750]     else {
[11:02:06.750]         if (TRUE) {
[11:02:06.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:06.750]                 open = "w")
[11:02:06.750]         }
[11:02:06.750]         else {
[11:02:06.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:06.750]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:06.750]         }
[11:02:06.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:06.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:06.750]             base::sink(type = "output", split = FALSE)
[11:02:06.750]             base::close(...future.stdout)
[11:02:06.750]         }, add = TRUE)
[11:02:06.750]     }
[11:02:06.750]     ...future.frame <- base::sys.nframe()
[11:02:06.750]     ...future.conditions <- base::list()
[11:02:06.750]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:06.750]     if (FALSE) {
[11:02:06.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:06.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:06.750]     }
[11:02:06.750]     ...future.result <- base::tryCatch({
[11:02:06.750]         base::withCallingHandlers({
[11:02:06.750]             ...future.value <- base::withVisible(base::local({
[11:02:06.750]                 ...future.makeSendCondition <- base::local({
[11:02:06.750]                   sendCondition <- NULL
[11:02:06.750]                   function(frame = 1L) {
[11:02:06.750]                     if (is.function(sendCondition)) 
[11:02:06.750]                       return(sendCondition)
[11:02:06.750]                     ns <- getNamespace("parallel")
[11:02:06.750]                     if (exists("sendData", mode = "function", 
[11:02:06.750]                       envir = ns)) {
[11:02:06.750]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:06.750]                         envir = ns)
[11:02:06.750]                       envir <- sys.frame(frame)
[11:02:06.750]                       master <- NULL
[11:02:06.750]                       while (!identical(envir, .GlobalEnv) && 
[11:02:06.750]                         !identical(envir, emptyenv())) {
[11:02:06.750]                         if (exists("master", mode = "list", envir = envir, 
[11:02:06.750]                           inherits = FALSE)) {
[11:02:06.750]                           master <- get("master", mode = "list", 
[11:02:06.750]                             envir = envir, inherits = FALSE)
[11:02:06.750]                           if (inherits(master, c("SOCKnode", 
[11:02:06.750]                             "SOCK0node"))) {
[11:02:06.750]                             sendCondition <<- function(cond) {
[11:02:06.750]                               data <- list(type = "VALUE", value = cond, 
[11:02:06.750]                                 success = TRUE)
[11:02:06.750]                               parallel_sendData(master, data)
[11:02:06.750]                             }
[11:02:06.750]                             return(sendCondition)
[11:02:06.750]                           }
[11:02:06.750]                         }
[11:02:06.750]                         frame <- frame + 1L
[11:02:06.750]                         envir <- sys.frame(frame)
[11:02:06.750]                       }
[11:02:06.750]                     }
[11:02:06.750]                     sendCondition <<- function(cond) NULL
[11:02:06.750]                   }
[11:02:06.750]                 })
[11:02:06.750]                 withCallingHandlers({
[11:02:06.750]                   {
[11:02:06.750]                     gc()
[11:02:06.750]                   }
[11:02:06.750]                 }, immediateCondition = function(cond) {
[11:02:06.750]                   sendCondition <- ...future.makeSendCondition()
[11:02:06.750]                   sendCondition(cond)
[11:02:06.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.750]                   {
[11:02:06.750]                     inherits <- base::inherits
[11:02:06.750]                     invokeRestart <- base::invokeRestart
[11:02:06.750]                     is.null <- base::is.null
[11:02:06.750]                     muffled <- FALSE
[11:02:06.750]                     if (inherits(cond, "message")) {
[11:02:06.750]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:06.750]                       if (muffled) 
[11:02:06.750]                         invokeRestart("muffleMessage")
[11:02:06.750]                     }
[11:02:06.750]                     else if (inherits(cond, "warning")) {
[11:02:06.750]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:06.750]                       if (muffled) 
[11:02:06.750]                         invokeRestart("muffleWarning")
[11:02:06.750]                     }
[11:02:06.750]                     else if (inherits(cond, "condition")) {
[11:02:06.750]                       if (!is.null(pattern)) {
[11:02:06.750]                         computeRestarts <- base::computeRestarts
[11:02:06.750]                         grepl <- base::grepl
[11:02:06.750]                         restarts <- computeRestarts(cond)
[11:02:06.750]                         for (restart in restarts) {
[11:02:06.750]                           name <- restart$name
[11:02:06.750]                           if (is.null(name)) 
[11:02:06.750]                             next
[11:02:06.750]                           if (!grepl(pattern, name)) 
[11:02:06.750]                             next
[11:02:06.750]                           invokeRestart(restart)
[11:02:06.750]                           muffled <- TRUE
[11:02:06.750]                           break
[11:02:06.750]                         }
[11:02:06.750]                       }
[11:02:06.750]                     }
[11:02:06.750]                     invisible(muffled)
[11:02:06.750]                   }
[11:02:06.750]                   muffleCondition(cond)
[11:02:06.750]                 })
[11:02:06.750]             }))
[11:02:06.750]             future::FutureResult(value = ...future.value$value, 
[11:02:06.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.750]                   ...future.rng), globalenv = if (FALSE) 
[11:02:06.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:06.750]                     ...future.globalenv.names))
[11:02:06.750]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:06.750]         }, condition = base::local({
[11:02:06.750]             c <- base::c
[11:02:06.750]             inherits <- base::inherits
[11:02:06.750]             invokeRestart <- base::invokeRestart
[11:02:06.750]             length <- base::length
[11:02:06.750]             list <- base::list
[11:02:06.750]             seq.int <- base::seq.int
[11:02:06.750]             signalCondition <- base::signalCondition
[11:02:06.750]             sys.calls <- base::sys.calls
[11:02:06.750]             `[[` <- base::`[[`
[11:02:06.750]             `+` <- base::`+`
[11:02:06.750]             `<<-` <- base::`<<-`
[11:02:06.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:06.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:06.750]                   3L)]
[11:02:06.750]             }
[11:02:06.750]             function(cond) {
[11:02:06.750]                 is_error <- inherits(cond, "error")
[11:02:06.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:06.750]                   NULL)
[11:02:06.750]                 if (is_error) {
[11:02:06.750]                   sessionInformation <- function() {
[11:02:06.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:06.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:06.750]                       search = base::search(), system = base::Sys.info())
[11:02:06.750]                   }
[11:02:06.750]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:06.750]                     cond$call), session = sessionInformation(), 
[11:02:06.750]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:06.750]                   signalCondition(cond)
[11:02:06.750]                 }
[11:02:06.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:06.750]                 "immediateCondition"))) {
[11:02:06.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:06.750]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:06.750]                   if (TRUE && !signal) {
[11:02:06.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.750]                     {
[11:02:06.750]                       inherits <- base::inherits
[11:02:06.750]                       invokeRestart <- base::invokeRestart
[11:02:06.750]                       is.null <- base::is.null
[11:02:06.750]                       muffled <- FALSE
[11:02:06.750]                       if (inherits(cond, "message")) {
[11:02:06.750]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.750]                         if (muffled) 
[11:02:06.750]                           invokeRestart("muffleMessage")
[11:02:06.750]                       }
[11:02:06.750]                       else if (inherits(cond, "warning")) {
[11:02:06.750]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.750]                         if (muffled) 
[11:02:06.750]                           invokeRestart("muffleWarning")
[11:02:06.750]                       }
[11:02:06.750]                       else if (inherits(cond, "condition")) {
[11:02:06.750]                         if (!is.null(pattern)) {
[11:02:06.750]                           computeRestarts <- base::computeRestarts
[11:02:06.750]                           grepl <- base::grepl
[11:02:06.750]                           restarts <- computeRestarts(cond)
[11:02:06.750]                           for (restart in restarts) {
[11:02:06.750]                             name <- restart$name
[11:02:06.750]                             if (is.null(name)) 
[11:02:06.750]                               next
[11:02:06.750]                             if (!grepl(pattern, name)) 
[11:02:06.750]                               next
[11:02:06.750]                             invokeRestart(restart)
[11:02:06.750]                             muffled <- TRUE
[11:02:06.750]                             break
[11:02:06.750]                           }
[11:02:06.750]                         }
[11:02:06.750]                       }
[11:02:06.750]                       invisible(muffled)
[11:02:06.750]                     }
[11:02:06.750]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.750]                   }
[11:02:06.750]                 }
[11:02:06.750]                 else {
[11:02:06.750]                   if (TRUE) {
[11:02:06.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.750]                     {
[11:02:06.750]                       inherits <- base::inherits
[11:02:06.750]                       invokeRestart <- base::invokeRestart
[11:02:06.750]                       is.null <- base::is.null
[11:02:06.750]                       muffled <- FALSE
[11:02:06.750]                       if (inherits(cond, "message")) {
[11:02:06.750]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.750]                         if (muffled) 
[11:02:06.750]                           invokeRestart("muffleMessage")
[11:02:06.750]                       }
[11:02:06.750]                       else if (inherits(cond, "warning")) {
[11:02:06.750]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.750]                         if (muffled) 
[11:02:06.750]                           invokeRestart("muffleWarning")
[11:02:06.750]                       }
[11:02:06.750]                       else if (inherits(cond, "condition")) {
[11:02:06.750]                         if (!is.null(pattern)) {
[11:02:06.750]                           computeRestarts <- base::computeRestarts
[11:02:06.750]                           grepl <- base::grepl
[11:02:06.750]                           restarts <- computeRestarts(cond)
[11:02:06.750]                           for (restart in restarts) {
[11:02:06.750]                             name <- restart$name
[11:02:06.750]                             if (is.null(name)) 
[11:02:06.750]                               next
[11:02:06.750]                             if (!grepl(pattern, name)) 
[11:02:06.750]                               next
[11:02:06.750]                             invokeRestart(restart)
[11:02:06.750]                             muffled <- TRUE
[11:02:06.750]                             break
[11:02:06.750]                           }
[11:02:06.750]                         }
[11:02:06.750]                       }
[11:02:06.750]                       invisible(muffled)
[11:02:06.750]                     }
[11:02:06.750]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.750]                   }
[11:02:06.750]                 }
[11:02:06.750]             }
[11:02:06.750]         }))
[11:02:06.750]     }, error = function(ex) {
[11:02:06.750]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:06.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.750]                 ...future.rng), started = ...future.startTime, 
[11:02:06.750]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:06.750]             version = "1.8"), class = "FutureResult")
[11:02:06.750]     }, finally = {
[11:02:06.750]         if (!identical(...future.workdir, getwd())) 
[11:02:06.750]             setwd(...future.workdir)
[11:02:06.750]         {
[11:02:06.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:06.750]                 ...future.oldOptions$nwarnings <- NULL
[11:02:06.750]             }
[11:02:06.750]             base::options(...future.oldOptions)
[11:02:06.750]             if (.Platform$OS.type == "windows") {
[11:02:06.750]                 old_names <- names(...future.oldEnvVars)
[11:02:06.750]                 envs <- base::Sys.getenv()
[11:02:06.750]                 names <- names(envs)
[11:02:06.750]                 common <- intersect(names, old_names)
[11:02:06.750]                 added <- setdiff(names, old_names)
[11:02:06.750]                 removed <- setdiff(old_names, names)
[11:02:06.750]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:06.750]                   envs[common]]
[11:02:06.750]                 NAMES <- toupper(changed)
[11:02:06.750]                 args <- list()
[11:02:06.750]                 for (kk in seq_along(NAMES)) {
[11:02:06.750]                   name <- changed[[kk]]
[11:02:06.750]                   NAME <- NAMES[[kk]]
[11:02:06.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.750]                     next
[11:02:06.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.750]                 }
[11:02:06.750]                 NAMES <- toupper(added)
[11:02:06.750]                 for (kk in seq_along(NAMES)) {
[11:02:06.750]                   name <- added[[kk]]
[11:02:06.750]                   NAME <- NAMES[[kk]]
[11:02:06.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.750]                     next
[11:02:06.750]                   args[[name]] <- ""
[11:02:06.750]                 }
[11:02:06.750]                 NAMES <- toupper(removed)
[11:02:06.750]                 for (kk in seq_along(NAMES)) {
[11:02:06.750]                   name <- removed[[kk]]
[11:02:06.750]                   NAME <- NAMES[[kk]]
[11:02:06.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.750]                     next
[11:02:06.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.750]                 }
[11:02:06.750]                 if (length(args) > 0) 
[11:02:06.750]                   base::do.call(base::Sys.setenv, args = args)
[11:02:06.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:06.750]             }
[11:02:06.750]             else {
[11:02:06.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:06.750]             }
[11:02:06.750]             {
[11:02:06.750]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:06.750]                   0L) {
[11:02:06.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:06.750]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:06.750]                   base::options(opts)
[11:02:06.750]                 }
[11:02:06.750]                 {
[11:02:06.750]                   {
[11:02:06.750]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:06.750]                     NULL
[11:02:06.750]                   }
[11:02:06.750]                   options(future.plan = NULL)
[11:02:06.750]                   if (is.na(NA_character_)) 
[11:02:06.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:06.750]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:06.750]                     .init = FALSE)
[11:02:06.750]                 }
[11:02:06.750]             }
[11:02:06.750]         }
[11:02:06.750]     })
[11:02:06.750]     if (TRUE) {
[11:02:06.750]         base::sink(type = "output", split = FALSE)
[11:02:06.750]         if (TRUE) {
[11:02:06.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:06.750]         }
[11:02:06.750]         else {
[11:02:06.750]             ...future.result["stdout"] <- base::list(NULL)
[11:02:06.750]         }
[11:02:06.750]         base::close(...future.stdout)
[11:02:06.750]         ...future.stdout <- NULL
[11:02:06.750]     }
[11:02:06.750]     ...future.result$conditions <- ...future.conditions
[11:02:06.750]     ...future.result$finished <- base::Sys.time()
[11:02:06.750]     ...future.result
[11:02:06.750] }
[11:02:06.753] MultisessionFuture started
[11:02:06.753] - Launch lazy future ... done
[11:02:06.753] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[11:02:06.753] result() for ClusterFuture ...
[11:02:06.753] receiveMessageFromWorker() for ClusterFuture ...
[11:02:06.754] - Validating connection of MultisessionFuture
[11:02:06.817] - received message: FutureResult
[11:02:06.817] - Received FutureResult
[11:02:06.817] - Erased future from FutureRegistry
[11:02:06.817] result() for ClusterFuture ...
[11:02:06.818] - result already collected: FutureResult
[11:02:06.818] result() for ClusterFuture ... done
[11:02:06.818] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:06.818] result() for ClusterFuture ... done
[11:02:06.818] result() for ClusterFuture ...
[11:02:06.818] - result already collected: FutureResult
[11:02:06.818] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 409539 21.9     692220   37   692220 37.0
Vcells 732387  5.6    8388608   64  1923650 14.7
> 
> f <- future({ integer(10e6) })
[11:02:06.818] getGlobalsAndPackages() ...
[11:02:06.818] Searching for globals...
[11:02:06.819] - globals found: [2] ‘{’, ‘integer’
[11:02:06.819] Searching for globals ... DONE
[11:02:06.819] Resolving globals: FALSE
[11:02:06.820] 
[11:02:06.820] 
[11:02:06.820] getGlobalsAndPackages() ... DONE
[11:02:06.820] run() for ‘Future’ ...
[11:02:06.820] - state: ‘created’
[11:02:06.820] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:06.833] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:06.833] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:06.833]   - Field: ‘node’
[11:02:06.833]   - Field: ‘label’
[11:02:06.833]   - Field: ‘local’
[11:02:06.834]   - Field: ‘owner’
[11:02:06.834]   - Field: ‘envir’
[11:02:06.834]   - Field: ‘workers’
[11:02:06.834]   - Field: ‘packages’
[11:02:06.834]   - Field: ‘gc’
[11:02:06.834]   - Field: ‘conditions’
[11:02:06.834]   - Field: ‘persistent’
[11:02:06.834]   - Field: ‘expr’
[11:02:06.834]   - Field: ‘uuid’
[11:02:06.834]   - Field: ‘seed’
[11:02:06.834]   - Field: ‘version’
[11:02:06.835]   - Field: ‘result’
[11:02:06.835]   - Field: ‘asynchronous’
[11:02:06.835]   - Field: ‘calls’
[11:02:06.835]   - Field: ‘globals’
[11:02:06.835]   - Field: ‘stdout’
[11:02:06.835]   - Field: ‘earlySignal’
[11:02:06.835]   - Field: ‘lazy’
[11:02:06.835]   - Field: ‘state’
[11:02:06.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:06.835] - Launch lazy future ...
[11:02:06.836] Packages needed by the future expression (n = 0): <none>
[11:02:06.836] Packages needed by future strategies (n = 0): <none>
[11:02:06.836] {
[11:02:06.836]     {
[11:02:06.836]         {
[11:02:06.836]             ...future.startTime <- base::Sys.time()
[11:02:06.836]             {
[11:02:06.836]                 {
[11:02:06.836]                   {
[11:02:06.836]                     {
[11:02:06.836]                       base::local({
[11:02:06.836]                         has_future <- base::requireNamespace("future", 
[11:02:06.836]                           quietly = TRUE)
[11:02:06.836]                         if (has_future) {
[11:02:06.836]                           ns <- base::getNamespace("future")
[11:02:06.836]                           version <- ns[[".package"]][["version"]]
[11:02:06.836]                           if (is.null(version)) 
[11:02:06.836]                             version <- utils::packageVersion("future")
[11:02:06.836]                         }
[11:02:06.836]                         else {
[11:02:06.836]                           version <- NULL
[11:02:06.836]                         }
[11:02:06.836]                         if (!has_future || version < "1.8.0") {
[11:02:06.836]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:06.836]                             "", base::R.version$version.string), 
[11:02:06.836]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:06.836]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:06.836]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:06.836]                               "release", "version")], collapse = " "), 
[11:02:06.836]                             hostname = base::Sys.info()[["nodename"]])
[11:02:06.836]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:06.836]                             info)
[11:02:06.836]                           info <- base::paste(info, collapse = "; ")
[11:02:06.836]                           if (!has_future) {
[11:02:06.836]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:06.836]                               info)
[11:02:06.836]                           }
[11:02:06.836]                           else {
[11:02:06.836]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:06.836]                               info, version)
[11:02:06.836]                           }
[11:02:06.836]                           base::stop(msg)
[11:02:06.836]                         }
[11:02:06.836]                       })
[11:02:06.836]                     }
[11:02:06.836]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:06.836]                     base::options(mc.cores = 1L)
[11:02:06.836]                   }
[11:02:06.836]                   ...future.strategy.old <- future::plan("list")
[11:02:06.836]                   options(future.plan = NULL)
[11:02:06.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:06.836]                 }
[11:02:06.836]                 ...future.workdir <- getwd()
[11:02:06.836]             }
[11:02:06.836]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:06.836]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:06.836]         }
[11:02:06.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:06.836]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:06.836]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:06.836]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:06.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:06.836]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:06.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:06.836]             base::names(...future.oldOptions))
[11:02:06.836]     }
[11:02:06.836]     if (FALSE) {
[11:02:06.836]     }
[11:02:06.836]     else {
[11:02:06.836]         if (TRUE) {
[11:02:06.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:06.836]                 open = "w")
[11:02:06.836]         }
[11:02:06.836]         else {
[11:02:06.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:06.836]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:06.836]         }
[11:02:06.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:06.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:06.836]             base::sink(type = "output", split = FALSE)
[11:02:06.836]             base::close(...future.stdout)
[11:02:06.836]         }, add = TRUE)
[11:02:06.836]     }
[11:02:06.836]     ...future.frame <- base::sys.nframe()
[11:02:06.836]     ...future.conditions <- base::list()
[11:02:06.836]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:06.836]     if (FALSE) {
[11:02:06.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:06.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:06.836]     }
[11:02:06.836]     ...future.result <- base::tryCatch({
[11:02:06.836]         base::withCallingHandlers({
[11:02:06.836]             ...future.value <- base::withVisible(base::local({
[11:02:06.836]                 ...future.makeSendCondition <- base::local({
[11:02:06.836]                   sendCondition <- NULL
[11:02:06.836]                   function(frame = 1L) {
[11:02:06.836]                     if (is.function(sendCondition)) 
[11:02:06.836]                       return(sendCondition)
[11:02:06.836]                     ns <- getNamespace("parallel")
[11:02:06.836]                     if (exists("sendData", mode = "function", 
[11:02:06.836]                       envir = ns)) {
[11:02:06.836]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:06.836]                         envir = ns)
[11:02:06.836]                       envir <- sys.frame(frame)
[11:02:06.836]                       master <- NULL
[11:02:06.836]                       while (!identical(envir, .GlobalEnv) && 
[11:02:06.836]                         !identical(envir, emptyenv())) {
[11:02:06.836]                         if (exists("master", mode = "list", envir = envir, 
[11:02:06.836]                           inherits = FALSE)) {
[11:02:06.836]                           master <- get("master", mode = "list", 
[11:02:06.836]                             envir = envir, inherits = FALSE)
[11:02:06.836]                           if (inherits(master, c("SOCKnode", 
[11:02:06.836]                             "SOCK0node"))) {
[11:02:06.836]                             sendCondition <<- function(cond) {
[11:02:06.836]                               data <- list(type = "VALUE", value = cond, 
[11:02:06.836]                                 success = TRUE)
[11:02:06.836]                               parallel_sendData(master, data)
[11:02:06.836]                             }
[11:02:06.836]                             return(sendCondition)
[11:02:06.836]                           }
[11:02:06.836]                         }
[11:02:06.836]                         frame <- frame + 1L
[11:02:06.836]                         envir <- sys.frame(frame)
[11:02:06.836]                       }
[11:02:06.836]                     }
[11:02:06.836]                     sendCondition <<- function(cond) NULL
[11:02:06.836]                   }
[11:02:06.836]                 })
[11:02:06.836]                 withCallingHandlers({
[11:02:06.836]                   {
[11:02:06.836]                     integer(1e+07)
[11:02:06.836]                   }
[11:02:06.836]                 }, immediateCondition = function(cond) {
[11:02:06.836]                   sendCondition <- ...future.makeSendCondition()
[11:02:06.836]                   sendCondition(cond)
[11:02:06.836]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.836]                   {
[11:02:06.836]                     inherits <- base::inherits
[11:02:06.836]                     invokeRestart <- base::invokeRestart
[11:02:06.836]                     is.null <- base::is.null
[11:02:06.836]                     muffled <- FALSE
[11:02:06.836]                     if (inherits(cond, "message")) {
[11:02:06.836]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:06.836]                       if (muffled) 
[11:02:06.836]                         invokeRestart("muffleMessage")
[11:02:06.836]                     }
[11:02:06.836]                     else if (inherits(cond, "warning")) {
[11:02:06.836]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:06.836]                       if (muffled) 
[11:02:06.836]                         invokeRestart("muffleWarning")
[11:02:06.836]                     }
[11:02:06.836]                     else if (inherits(cond, "condition")) {
[11:02:06.836]                       if (!is.null(pattern)) {
[11:02:06.836]                         computeRestarts <- base::computeRestarts
[11:02:06.836]                         grepl <- base::grepl
[11:02:06.836]                         restarts <- computeRestarts(cond)
[11:02:06.836]                         for (restart in restarts) {
[11:02:06.836]                           name <- restart$name
[11:02:06.836]                           if (is.null(name)) 
[11:02:06.836]                             next
[11:02:06.836]                           if (!grepl(pattern, name)) 
[11:02:06.836]                             next
[11:02:06.836]                           invokeRestart(restart)
[11:02:06.836]                           muffled <- TRUE
[11:02:06.836]                           break
[11:02:06.836]                         }
[11:02:06.836]                       }
[11:02:06.836]                     }
[11:02:06.836]                     invisible(muffled)
[11:02:06.836]                   }
[11:02:06.836]                   muffleCondition(cond)
[11:02:06.836]                 })
[11:02:06.836]             }))
[11:02:06.836]             future::FutureResult(value = ...future.value$value, 
[11:02:06.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.836]                   ...future.rng), globalenv = if (FALSE) 
[11:02:06.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:06.836]                     ...future.globalenv.names))
[11:02:06.836]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:06.836]         }, condition = base::local({
[11:02:06.836]             c <- base::c
[11:02:06.836]             inherits <- base::inherits
[11:02:06.836]             invokeRestart <- base::invokeRestart
[11:02:06.836]             length <- base::length
[11:02:06.836]             list <- base::list
[11:02:06.836]             seq.int <- base::seq.int
[11:02:06.836]             signalCondition <- base::signalCondition
[11:02:06.836]             sys.calls <- base::sys.calls
[11:02:06.836]             `[[` <- base::`[[`
[11:02:06.836]             `+` <- base::`+`
[11:02:06.836]             `<<-` <- base::`<<-`
[11:02:06.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:06.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:06.836]                   3L)]
[11:02:06.836]             }
[11:02:06.836]             function(cond) {
[11:02:06.836]                 is_error <- inherits(cond, "error")
[11:02:06.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:06.836]                   NULL)
[11:02:06.836]                 if (is_error) {
[11:02:06.836]                   sessionInformation <- function() {
[11:02:06.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:06.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:06.836]                       search = base::search(), system = base::Sys.info())
[11:02:06.836]                   }
[11:02:06.836]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:06.836]                     cond$call), session = sessionInformation(), 
[11:02:06.836]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:06.836]                   signalCondition(cond)
[11:02:06.836]                 }
[11:02:06.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:06.836]                 "immediateCondition"))) {
[11:02:06.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:06.836]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:06.836]                   if (TRUE && !signal) {
[11:02:06.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.836]                     {
[11:02:06.836]                       inherits <- base::inherits
[11:02:06.836]                       invokeRestart <- base::invokeRestart
[11:02:06.836]                       is.null <- base::is.null
[11:02:06.836]                       muffled <- FALSE
[11:02:06.836]                       if (inherits(cond, "message")) {
[11:02:06.836]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.836]                         if (muffled) 
[11:02:06.836]                           invokeRestart("muffleMessage")
[11:02:06.836]                       }
[11:02:06.836]                       else if (inherits(cond, "warning")) {
[11:02:06.836]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.836]                         if (muffled) 
[11:02:06.836]                           invokeRestart("muffleWarning")
[11:02:06.836]                       }
[11:02:06.836]                       else if (inherits(cond, "condition")) {
[11:02:06.836]                         if (!is.null(pattern)) {
[11:02:06.836]                           computeRestarts <- base::computeRestarts
[11:02:06.836]                           grepl <- base::grepl
[11:02:06.836]                           restarts <- computeRestarts(cond)
[11:02:06.836]                           for (restart in restarts) {
[11:02:06.836]                             name <- restart$name
[11:02:06.836]                             if (is.null(name)) 
[11:02:06.836]                               next
[11:02:06.836]                             if (!grepl(pattern, name)) 
[11:02:06.836]                               next
[11:02:06.836]                             invokeRestart(restart)
[11:02:06.836]                             muffled <- TRUE
[11:02:06.836]                             break
[11:02:06.836]                           }
[11:02:06.836]                         }
[11:02:06.836]                       }
[11:02:06.836]                       invisible(muffled)
[11:02:06.836]                     }
[11:02:06.836]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.836]                   }
[11:02:06.836]                 }
[11:02:06.836]                 else {
[11:02:06.836]                   if (TRUE) {
[11:02:06.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.836]                     {
[11:02:06.836]                       inherits <- base::inherits
[11:02:06.836]                       invokeRestart <- base::invokeRestart
[11:02:06.836]                       is.null <- base::is.null
[11:02:06.836]                       muffled <- FALSE
[11:02:06.836]                       if (inherits(cond, "message")) {
[11:02:06.836]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.836]                         if (muffled) 
[11:02:06.836]                           invokeRestart("muffleMessage")
[11:02:06.836]                       }
[11:02:06.836]                       else if (inherits(cond, "warning")) {
[11:02:06.836]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.836]                         if (muffled) 
[11:02:06.836]                           invokeRestart("muffleWarning")
[11:02:06.836]                       }
[11:02:06.836]                       else if (inherits(cond, "condition")) {
[11:02:06.836]                         if (!is.null(pattern)) {
[11:02:06.836]                           computeRestarts <- base::computeRestarts
[11:02:06.836]                           grepl <- base::grepl
[11:02:06.836]                           restarts <- computeRestarts(cond)
[11:02:06.836]                           for (restart in restarts) {
[11:02:06.836]                             name <- restart$name
[11:02:06.836]                             if (is.null(name)) 
[11:02:06.836]                               next
[11:02:06.836]                             if (!grepl(pattern, name)) 
[11:02:06.836]                               next
[11:02:06.836]                             invokeRestart(restart)
[11:02:06.836]                             muffled <- TRUE
[11:02:06.836]                             break
[11:02:06.836]                           }
[11:02:06.836]                         }
[11:02:06.836]                       }
[11:02:06.836]                       invisible(muffled)
[11:02:06.836]                     }
[11:02:06.836]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.836]                   }
[11:02:06.836]                 }
[11:02:06.836]             }
[11:02:06.836]         }))
[11:02:06.836]     }, error = function(ex) {
[11:02:06.836]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:06.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.836]                 ...future.rng), started = ...future.startTime, 
[11:02:06.836]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:06.836]             version = "1.8"), class = "FutureResult")
[11:02:06.836]     }, finally = {
[11:02:06.836]         if (!identical(...future.workdir, getwd())) 
[11:02:06.836]             setwd(...future.workdir)
[11:02:06.836]         {
[11:02:06.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:06.836]                 ...future.oldOptions$nwarnings <- NULL
[11:02:06.836]             }
[11:02:06.836]             base::options(...future.oldOptions)
[11:02:06.836]             if (.Platform$OS.type == "windows") {
[11:02:06.836]                 old_names <- names(...future.oldEnvVars)
[11:02:06.836]                 envs <- base::Sys.getenv()
[11:02:06.836]                 names <- names(envs)
[11:02:06.836]                 common <- intersect(names, old_names)
[11:02:06.836]                 added <- setdiff(names, old_names)
[11:02:06.836]                 removed <- setdiff(old_names, names)
[11:02:06.836]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:06.836]                   envs[common]]
[11:02:06.836]                 NAMES <- toupper(changed)
[11:02:06.836]                 args <- list()
[11:02:06.836]                 for (kk in seq_along(NAMES)) {
[11:02:06.836]                   name <- changed[[kk]]
[11:02:06.836]                   NAME <- NAMES[[kk]]
[11:02:06.836]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.836]                     next
[11:02:06.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.836]                 }
[11:02:06.836]                 NAMES <- toupper(added)
[11:02:06.836]                 for (kk in seq_along(NAMES)) {
[11:02:06.836]                   name <- added[[kk]]
[11:02:06.836]                   NAME <- NAMES[[kk]]
[11:02:06.836]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.836]                     next
[11:02:06.836]                   args[[name]] <- ""
[11:02:06.836]                 }
[11:02:06.836]                 NAMES <- toupper(removed)
[11:02:06.836]                 for (kk in seq_along(NAMES)) {
[11:02:06.836]                   name <- removed[[kk]]
[11:02:06.836]                   NAME <- NAMES[[kk]]
[11:02:06.836]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.836]                     next
[11:02:06.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.836]                 }
[11:02:06.836]                 if (length(args) > 0) 
[11:02:06.836]                   base::do.call(base::Sys.setenv, args = args)
[11:02:06.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:06.836]             }
[11:02:06.836]             else {
[11:02:06.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:06.836]             }
[11:02:06.836]             {
[11:02:06.836]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:06.836]                   0L) {
[11:02:06.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:06.836]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:06.836]                   base::options(opts)
[11:02:06.836]                 }
[11:02:06.836]                 {
[11:02:06.836]                   {
[11:02:06.836]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:06.836]                     NULL
[11:02:06.836]                   }
[11:02:06.836]                   options(future.plan = NULL)
[11:02:06.836]                   if (is.na(NA_character_)) 
[11:02:06.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:06.836]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:06.836]                     .init = FALSE)
[11:02:06.836]                 }
[11:02:06.836]             }
[11:02:06.836]         }
[11:02:06.836]     })
[11:02:06.836]     if (TRUE) {
[11:02:06.836]         base::sink(type = "output", split = FALSE)
[11:02:06.836]         if (TRUE) {
[11:02:06.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:06.836]         }
[11:02:06.836]         else {
[11:02:06.836]             ...future.result["stdout"] <- base::list(NULL)
[11:02:06.836]         }
[11:02:06.836]         base::close(...future.stdout)
[11:02:06.836]         ...future.stdout <- NULL
[11:02:06.836]     }
[11:02:06.836]     ...future.result$conditions <- ...future.conditions
[11:02:06.836]     ...future.result$finished <- base::Sys.time()
[11:02:06.836]     ...future.result
[11:02:06.836] }
[11:02:06.839] MultisessionFuture started
[11:02:06.839] - Launch lazy future ... done
[11:02:06.839] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[11:02:06.839] result() for ClusterFuture ...
[11:02:06.840] receiveMessageFromWorker() for ClusterFuture ...
[11:02:06.840] - Validating connection of MultisessionFuture
[11:02:06.934] - received message: FutureResult
[11:02:06.935] - Received FutureResult
[11:02:06.935] - Erased future from FutureRegistry
[11:02:06.935] result() for ClusterFuture ...
[11:02:06.935] - result already collected: FutureResult
[11:02:06.935] result() for ClusterFuture ... done
[11:02:06.935] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:06.935] result() for ClusterFuture ... done
[11:02:06.935] result() for ClusterFuture ...
[11:02:06.935] - result already collected: FutureResult
[11:02:06.936] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[11:02:06.936] getGlobalsAndPackages() ...
[11:02:06.936] Searching for globals...
[11:02:06.937] - globals found: [2] ‘{’, ‘gc’
[11:02:06.937] Searching for globals ... DONE
[11:02:06.937] Resolving globals: FALSE
[11:02:06.937] 
[11:02:06.938] 
[11:02:06.938] getGlobalsAndPackages() ... DONE
[11:02:06.938] run() for ‘Future’ ...
[11:02:06.938] - state: ‘created’
[11:02:06.938] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:06.951] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:06.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:06.951]   - Field: ‘node’
[11:02:06.951]   - Field: ‘label’
[11:02:06.951]   - Field: ‘local’
[11:02:06.951]   - Field: ‘owner’
[11:02:06.951]   - Field: ‘envir’
[11:02:06.951]   - Field: ‘workers’
[11:02:06.951]   - Field: ‘packages’
[11:02:06.951]   - Field: ‘gc’
[11:02:06.952]   - Field: ‘conditions’
[11:02:06.952]   - Field: ‘persistent’
[11:02:06.952]   - Field: ‘expr’
[11:02:06.952]   - Field: ‘uuid’
[11:02:06.952]   - Field: ‘seed’
[11:02:06.952]   - Field: ‘version’
[11:02:06.952]   - Field: ‘result’
[11:02:06.952]   - Field: ‘asynchronous’
[11:02:06.952]   - Field: ‘calls’
[11:02:06.952]   - Field: ‘globals’
[11:02:06.952]   - Field: ‘stdout’
[11:02:06.952]   - Field: ‘earlySignal’
[11:02:06.953]   - Field: ‘lazy’
[11:02:06.953]   - Field: ‘state’
[11:02:06.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:06.953] - Launch lazy future ...
[11:02:06.953] Packages needed by the future expression (n = 0): <none>
[11:02:06.953] Packages needed by future strategies (n = 0): <none>
[11:02:06.954] {
[11:02:06.954]     {
[11:02:06.954]         {
[11:02:06.954]             ...future.startTime <- base::Sys.time()
[11:02:06.954]             {
[11:02:06.954]                 {
[11:02:06.954]                   {
[11:02:06.954]                     {
[11:02:06.954]                       base::local({
[11:02:06.954]                         has_future <- base::requireNamespace("future", 
[11:02:06.954]                           quietly = TRUE)
[11:02:06.954]                         if (has_future) {
[11:02:06.954]                           ns <- base::getNamespace("future")
[11:02:06.954]                           version <- ns[[".package"]][["version"]]
[11:02:06.954]                           if (is.null(version)) 
[11:02:06.954]                             version <- utils::packageVersion("future")
[11:02:06.954]                         }
[11:02:06.954]                         else {
[11:02:06.954]                           version <- NULL
[11:02:06.954]                         }
[11:02:06.954]                         if (!has_future || version < "1.8.0") {
[11:02:06.954]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:06.954]                             "", base::R.version$version.string), 
[11:02:06.954]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:06.954]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:06.954]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:06.954]                               "release", "version")], collapse = " "), 
[11:02:06.954]                             hostname = base::Sys.info()[["nodename"]])
[11:02:06.954]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:06.954]                             info)
[11:02:06.954]                           info <- base::paste(info, collapse = "; ")
[11:02:06.954]                           if (!has_future) {
[11:02:06.954]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:06.954]                               info)
[11:02:06.954]                           }
[11:02:06.954]                           else {
[11:02:06.954]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:06.954]                               info, version)
[11:02:06.954]                           }
[11:02:06.954]                           base::stop(msg)
[11:02:06.954]                         }
[11:02:06.954]                       })
[11:02:06.954]                     }
[11:02:06.954]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:06.954]                     base::options(mc.cores = 1L)
[11:02:06.954]                   }
[11:02:06.954]                   ...future.strategy.old <- future::plan("list")
[11:02:06.954]                   options(future.plan = NULL)
[11:02:06.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:06.954]                 }
[11:02:06.954]                 ...future.workdir <- getwd()
[11:02:06.954]             }
[11:02:06.954]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:06.954]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:06.954]         }
[11:02:06.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:06.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:06.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:06.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:06.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:06.954]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:06.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:06.954]             base::names(...future.oldOptions))
[11:02:06.954]     }
[11:02:06.954]     if (FALSE) {
[11:02:06.954]     }
[11:02:06.954]     else {
[11:02:06.954]         if (TRUE) {
[11:02:06.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:06.954]                 open = "w")
[11:02:06.954]         }
[11:02:06.954]         else {
[11:02:06.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:06.954]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:06.954]         }
[11:02:06.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:06.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:06.954]             base::sink(type = "output", split = FALSE)
[11:02:06.954]             base::close(...future.stdout)
[11:02:06.954]         }, add = TRUE)
[11:02:06.954]     }
[11:02:06.954]     ...future.frame <- base::sys.nframe()
[11:02:06.954]     ...future.conditions <- base::list()
[11:02:06.954]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:06.954]     if (FALSE) {
[11:02:06.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:06.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:06.954]     }
[11:02:06.954]     ...future.result <- base::tryCatch({
[11:02:06.954]         base::withCallingHandlers({
[11:02:06.954]             ...future.value <- base::withVisible(base::local({
[11:02:06.954]                 ...future.makeSendCondition <- base::local({
[11:02:06.954]                   sendCondition <- NULL
[11:02:06.954]                   function(frame = 1L) {
[11:02:06.954]                     if (is.function(sendCondition)) 
[11:02:06.954]                       return(sendCondition)
[11:02:06.954]                     ns <- getNamespace("parallel")
[11:02:06.954]                     if (exists("sendData", mode = "function", 
[11:02:06.954]                       envir = ns)) {
[11:02:06.954]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:06.954]                         envir = ns)
[11:02:06.954]                       envir <- sys.frame(frame)
[11:02:06.954]                       master <- NULL
[11:02:06.954]                       while (!identical(envir, .GlobalEnv) && 
[11:02:06.954]                         !identical(envir, emptyenv())) {
[11:02:06.954]                         if (exists("master", mode = "list", envir = envir, 
[11:02:06.954]                           inherits = FALSE)) {
[11:02:06.954]                           master <- get("master", mode = "list", 
[11:02:06.954]                             envir = envir, inherits = FALSE)
[11:02:06.954]                           if (inherits(master, c("SOCKnode", 
[11:02:06.954]                             "SOCK0node"))) {
[11:02:06.954]                             sendCondition <<- function(cond) {
[11:02:06.954]                               data <- list(type = "VALUE", value = cond, 
[11:02:06.954]                                 success = TRUE)
[11:02:06.954]                               parallel_sendData(master, data)
[11:02:06.954]                             }
[11:02:06.954]                             return(sendCondition)
[11:02:06.954]                           }
[11:02:06.954]                         }
[11:02:06.954]                         frame <- frame + 1L
[11:02:06.954]                         envir <- sys.frame(frame)
[11:02:06.954]                       }
[11:02:06.954]                     }
[11:02:06.954]                     sendCondition <<- function(cond) NULL
[11:02:06.954]                   }
[11:02:06.954]                 })
[11:02:06.954]                 withCallingHandlers({
[11:02:06.954]                   {
[11:02:06.954]                     gc()
[11:02:06.954]                   }
[11:02:06.954]                 }, immediateCondition = function(cond) {
[11:02:06.954]                   sendCondition <- ...future.makeSendCondition()
[11:02:06.954]                   sendCondition(cond)
[11:02:06.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.954]                   {
[11:02:06.954]                     inherits <- base::inherits
[11:02:06.954]                     invokeRestart <- base::invokeRestart
[11:02:06.954]                     is.null <- base::is.null
[11:02:06.954]                     muffled <- FALSE
[11:02:06.954]                     if (inherits(cond, "message")) {
[11:02:06.954]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:06.954]                       if (muffled) 
[11:02:06.954]                         invokeRestart("muffleMessage")
[11:02:06.954]                     }
[11:02:06.954]                     else if (inherits(cond, "warning")) {
[11:02:06.954]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:06.954]                       if (muffled) 
[11:02:06.954]                         invokeRestart("muffleWarning")
[11:02:06.954]                     }
[11:02:06.954]                     else if (inherits(cond, "condition")) {
[11:02:06.954]                       if (!is.null(pattern)) {
[11:02:06.954]                         computeRestarts <- base::computeRestarts
[11:02:06.954]                         grepl <- base::grepl
[11:02:06.954]                         restarts <- computeRestarts(cond)
[11:02:06.954]                         for (restart in restarts) {
[11:02:06.954]                           name <- restart$name
[11:02:06.954]                           if (is.null(name)) 
[11:02:06.954]                             next
[11:02:06.954]                           if (!grepl(pattern, name)) 
[11:02:06.954]                             next
[11:02:06.954]                           invokeRestart(restart)
[11:02:06.954]                           muffled <- TRUE
[11:02:06.954]                           break
[11:02:06.954]                         }
[11:02:06.954]                       }
[11:02:06.954]                     }
[11:02:06.954]                     invisible(muffled)
[11:02:06.954]                   }
[11:02:06.954]                   muffleCondition(cond)
[11:02:06.954]                 })
[11:02:06.954]             }))
[11:02:06.954]             future::FutureResult(value = ...future.value$value, 
[11:02:06.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.954]                   ...future.rng), globalenv = if (FALSE) 
[11:02:06.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:06.954]                     ...future.globalenv.names))
[11:02:06.954]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:06.954]         }, condition = base::local({
[11:02:06.954]             c <- base::c
[11:02:06.954]             inherits <- base::inherits
[11:02:06.954]             invokeRestart <- base::invokeRestart
[11:02:06.954]             length <- base::length
[11:02:06.954]             list <- base::list
[11:02:06.954]             seq.int <- base::seq.int
[11:02:06.954]             signalCondition <- base::signalCondition
[11:02:06.954]             sys.calls <- base::sys.calls
[11:02:06.954]             `[[` <- base::`[[`
[11:02:06.954]             `+` <- base::`+`
[11:02:06.954]             `<<-` <- base::`<<-`
[11:02:06.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:06.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:06.954]                   3L)]
[11:02:06.954]             }
[11:02:06.954]             function(cond) {
[11:02:06.954]                 is_error <- inherits(cond, "error")
[11:02:06.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:06.954]                   NULL)
[11:02:06.954]                 if (is_error) {
[11:02:06.954]                   sessionInformation <- function() {
[11:02:06.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:06.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:06.954]                       search = base::search(), system = base::Sys.info())
[11:02:06.954]                   }
[11:02:06.954]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:06.954]                     cond$call), session = sessionInformation(), 
[11:02:06.954]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:06.954]                   signalCondition(cond)
[11:02:06.954]                 }
[11:02:06.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:06.954]                 "immediateCondition"))) {
[11:02:06.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:06.954]                   ...future.conditions[[length(...future.conditions) + 
[11:02:06.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:06.954]                   if (TRUE && !signal) {
[11:02:06.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.954]                     {
[11:02:06.954]                       inherits <- base::inherits
[11:02:06.954]                       invokeRestart <- base::invokeRestart
[11:02:06.954]                       is.null <- base::is.null
[11:02:06.954]                       muffled <- FALSE
[11:02:06.954]                       if (inherits(cond, "message")) {
[11:02:06.954]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.954]                         if (muffled) 
[11:02:06.954]                           invokeRestart("muffleMessage")
[11:02:06.954]                       }
[11:02:06.954]                       else if (inherits(cond, "warning")) {
[11:02:06.954]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.954]                         if (muffled) 
[11:02:06.954]                           invokeRestart("muffleWarning")
[11:02:06.954]                       }
[11:02:06.954]                       else if (inherits(cond, "condition")) {
[11:02:06.954]                         if (!is.null(pattern)) {
[11:02:06.954]                           computeRestarts <- base::computeRestarts
[11:02:06.954]                           grepl <- base::grepl
[11:02:06.954]                           restarts <- computeRestarts(cond)
[11:02:06.954]                           for (restart in restarts) {
[11:02:06.954]                             name <- restart$name
[11:02:06.954]                             if (is.null(name)) 
[11:02:06.954]                               next
[11:02:06.954]                             if (!grepl(pattern, name)) 
[11:02:06.954]                               next
[11:02:06.954]                             invokeRestart(restart)
[11:02:06.954]                             muffled <- TRUE
[11:02:06.954]                             break
[11:02:06.954]                           }
[11:02:06.954]                         }
[11:02:06.954]                       }
[11:02:06.954]                       invisible(muffled)
[11:02:06.954]                     }
[11:02:06.954]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.954]                   }
[11:02:06.954]                 }
[11:02:06.954]                 else {
[11:02:06.954]                   if (TRUE) {
[11:02:06.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:06.954]                     {
[11:02:06.954]                       inherits <- base::inherits
[11:02:06.954]                       invokeRestart <- base::invokeRestart
[11:02:06.954]                       is.null <- base::is.null
[11:02:06.954]                       muffled <- FALSE
[11:02:06.954]                       if (inherits(cond, "message")) {
[11:02:06.954]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:06.954]                         if (muffled) 
[11:02:06.954]                           invokeRestart("muffleMessage")
[11:02:06.954]                       }
[11:02:06.954]                       else if (inherits(cond, "warning")) {
[11:02:06.954]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:06.954]                         if (muffled) 
[11:02:06.954]                           invokeRestart("muffleWarning")
[11:02:06.954]                       }
[11:02:06.954]                       else if (inherits(cond, "condition")) {
[11:02:06.954]                         if (!is.null(pattern)) {
[11:02:06.954]                           computeRestarts <- base::computeRestarts
[11:02:06.954]                           grepl <- base::grepl
[11:02:06.954]                           restarts <- computeRestarts(cond)
[11:02:06.954]                           for (restart in restarts) {
[11:02:06.954]                             name <- restart$name
[11:02:06.954]                             if (is.null(name)) 
[11:02:06.954]                               next
[11:02:06.954]                             if (!grepl(pattern, name)) 
[11:02:06.954]                               next
[11:02:06.954]                             invokeRestart(restart)
[11:02:06.954]                             muffled <- TRUE
[11:02:06.954]                             break
[11:02:06.954]                           }
[11:02:06.954]                         }
[11:02:06.954]                       }
[11:02:06.954]                       invisible(muffled)
[11:02:06.954]                     }
[11:02:06.954]                     muffleCondition(cond, pattern = "^muffle")
[11:02:06.954]                   }
[11:02:06.954]                 }
[11:02:06.954]             }
[11:02:06.954]         }))
[11:02:06.954]     }, error = function(ex) {
[11:02:06.954]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:06.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:06.954]                 ...future.rng), started = ...future.startTime, 
[11:02:06.954]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:06.954]             version = "1.8"), class = "FutureResult")
[11:02:06.954]     }, finally = {
[11:02:06.954]         if (!identical(...future.workdir, getwd())) 
[11:02:06.954]             setwd(...future.workdir)
[11:02:06.954]         {
[11:02:06.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:06.954]                 ...future.oldOptions$nwarnings <- NULL
[11:02:06.954]             }
[11:02:06.954]             base::options(...future.oldOptions)
[11:02:06.954]             if (.Platform$OS.type == "windows") {
[11:02:06.954]                 old_names <- names(...future.oldEnvVars)
[11:02:06.954]                 envs <- base::Sys.getenv()
[11:02:06.954]                 names <- names(envs)
[11:02:06.954]                 common <- intersect(names, old_names)
[11:02:06.954]                 added <- setdiff(names, old_names)
[11:02:06.954]                 removed <- setdiff(old_names, names)
[11:02:06.954]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:06.954]                   envs[common]]
[11:02:06.954]                 NAMES <- toupper(changed)
[11:02:06.954]                 args <- list()
[11:02:06.954]                 for (kk in seq_along(NAMES)) {
[11:02:06.954]                   name <- changed[[kk]]
[11:02:06.954]                   NAME <- NAMES[[kk]]
[11:02:06.954]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.954]                     next
[11:02:06.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.954]                 }
[11:02:06.954]                 NAMES <- toupper(added)
[11:02:06.954]                 for (kk in seq_along(NAMES)) {
[11:02:06.954]                   name <- added[[kk]]
[11:02:06.954]                   NAME <- NAMES[[kk]]
[11:02:06.954]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.954]                     next
[11:02:06.954]                   args[[name]] <- ""
[11:02:06.954]                 }
[11:02:06.954]                 NAMES <- toupper(removed)
[11:02:06.954]                 for (kk in seq_along(NAMES)) {
[11:02:06.954]                   name <- removed[[kk]]
[11:02:06.954]                   NAME <- NAMES[[kk]]
[11:02:06.954]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:06.954]                     next
[11:02:06.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:06.954]                 }
[11:02:06.954]                 if (length(args) > 0) 
[11:02:06.954]                   base::do.call(base::Sys.setenv, args = args)
[11:02:06.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:06.954]             }
[11:02:06.954]             else {
[11:02:06.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:06.954]             }
[11:02:06.954]             {
[11:02:06.954]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:06.954]                   0L) {
[11:02:06.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:06.954]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:06.954]                   base::options(opts)
[11:02:06.954]                 }
[11:02:06.954]                 {
[11:02:06.954]                   {
[11:02:06.954]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:06.954]                     NULL
[11:02:06.954]                   }
[11:02:06.954]                   options(future.plan = NULL)
[11:02:06.954]                   if (is.na(NA_character_)) 
[11:02:06.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:06.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:06.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:06.954]                     .init = FALSE)
[11:02:06.954]                 }
[11:02:06.954]             }
[11:02:06.954]         }
[11:02:06.954]     })
[11:02:06.954]     if (TRUE) {
[11:02:06.954]         base::sink(type = "output", split = FALSE)
[11:02:06.954]         if (TRUE) {
[11:02:06.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:06.954]         }
[11:02:06.954]         else {
[11:02:06.954]             ...future.result["stdout"] <- base::list(NULL)
[11:02:06.954]         }
[11:02:06.954]         base::close(...future.stdout)
[11:02:06.954]         ...future.stdout <- NULL
[11:02:06.954]     }
[11:02:06.954]     ...future.result$conditions <- ...future.conditions
[11:02:06.954]     ...future.result$finished <- base::Sys.time()
[11:02:06.954]     ...future.result
[11:02:06.954] }
[11:02:06.957] MultisessionFuture started
[11:02:06.957] - Launch lazy future ... done
[11:02:06.957] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[11:02:06.957] result() for ClusterFuture ...
[11:02:06.957] receiveMessageFromWorker() for ClusterFuture ...
[11:02:06.957] - Validating connection of MultisessionFuture
[11:02:07.022] - received message: FutureResult
[11:02:07.023] - Received FutureResult
[11:02:07.023] - Erased future from FutureRegistry
[11:02:07.023] result() for ClusterFuture ...
[11:02:07.023] - result already collected: FutureResult
[11:02:07.023] result() for ClusterFuture ... done
[11:02:07.023] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:07.023] result() for ClusterFuture ... done
[11:02:07.023] result() for ClusterFuture ...
[11:02:07.024] - result already collected: FutureResult
[11:02:07.024] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 409534 21.9     692220   37   692220   37
Vcells 732377  5.6    8388608   64  5754334   44
> 
> f <- future({ integer(10e6) }, gc = TRUE)
[11:02:07.024] getGlobalsAndPackages() ...
[11:02:07.024] Searching for globals...
[11:02:07.025] - globals found: [2] ‘{’, ‘integer’
[11:02:07.025] Searching for globals ... DONE
[11:02:07.025] Resolving globals: FALSE
[11:02:07.025] 
[11:02:07.025] 
[11:02:07.025] getGlobalsAndPackages() ... DONE
[11:02:07.026] run() for ‘Future’ ...
[11:02:07.026] - state: ‘created’
[11:02:07.026] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:07.038] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:07.038] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:07.039]   - Field: ‘node’
[11:02:07.039]   - Field: ‘label’
[11:02:07.039]   - Field: ‘local’
[11:02:07.039]   - Field: ‘owner’
[11:02:07.039]   - Field: ‘envir’
[11:02:07.039]   - Field: ‘workers’
[11:02:07.039]   - Field: ‘packages’
[11:02:07.039]   - Field: ‘gc’
[11:02:07.039]   - Field: ‘conditions’
[11:02:07.039]   - Field: ‘persistent’
[11:02:07.040]   - Field: ‘expr’
[11:02:07.040]   - Field: ‘uuid’
[11:02:07.040]   - Field: ‘seed’
[11:02:07.040]   - Field: ‘version’
[11:02:07.040]   - Field: ‘result’
[11:02:07.040]   - Field: ‘asynchronous’
[11:02:07.040]   - Field: ‘calls’
[11:02:07.040]   - Field: ‘globals’
[11:02:07.040]   - Field: ‘stdout’
[11:02:07.040]   - Field: ‘earlySignal’
[11:02:07.040]   - Field: ‘lazy’
[11:02:07.040]   - Field: ‘state’
[11:02:07.041] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:07.041] - Launch lazy future ...
[11:02:07.041] Packages needed by the future expression (n = 0): <none>
[11:02:07.041] Packages needed by future strategies (n = 0): <none>
[11:02:07.044] {
[11:02:07.044]     {
[11:02:07.044]         {
[11:02:07.044]             ...future.startTime <- base::Sys.time()
[11:02:07.044]             {
[11:02:07.044]                 {
[11:02:07.044]                   {
[11:02:07.044]                     {
[11:02:07.044]                       base::local({
[11:02:07.044]                         has_future <- base::requireNamespace("future", 
[11:02:07.044]                           quietly = TRUE)
[11:02:07.044]                         if (has_future) {
[11:02:07.044]                           ns <- base::getNamespace("future")
[11:02:07.044]                           version <- ns[[".package"]][["version"]]
[11:02:07.044]                           if (is.null(version)) 
[11:02:07.044]                             version <- utils::packageVersion("future")
[11:02:07.044]                         }
[11:02:07.044]                         else {
[11:02:07.044]                           version <- NULL
[11:02:07.044]                         }
[11:02:07.044]                         if (!has_future || version < "1.8.0") {
[11:02:07.044]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:07.044]                             "", base::R.version$version.string), 
[11:02:07.044]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:07.044]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:07.044]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:07.044]                               "release", "version")], collapse = " "), 
[11:02:07.044]                             hostname = base::Sys.info()[["nodename"]])
[11:02:07.044]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:07.044]                             info)
[11:02:07.044]                           info <- base::paste(info, collapse = "; ")
[11:02:07.044]                           if (!has_future) {
[11:02:07.044]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:07.044]                               info)
[11:02:07.044]                           }
[11:02:07.044]                           else {
[11:02:07.044]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:07.044]                               info, version)
[11:02:07.044]                           }
[11:02:07.044]                           base::stop(msg)
[11:02:07.044]                         }
[11:02:07.044]                       })
[11:02:07.044]                     }
[11:02:07.044]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:07.044]                     base::options(mc.cores = 1L)
[11:02:07.044]                   }
[11:02:07.044]                   ...future.strategy.old <- future::plan("list")
[11:02:07.044]                   options(future.plan = NULL)
[11:02:07.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:07.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:07.044]                 }
[11:02:07.044]                 ...future.workdir <- getwd()
[11:02:07.044]             }
[11:02:07.044]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:07.044]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:07.044]         }
[11:02:07.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:07.044]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:07.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:07.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:07.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:07.044]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:07.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:07.044]             base::names(...future.oldOptions))
[11:02:07.044]     }
[11:02:07.044]     if (FALSE) {
[11:02:07.044]     }
[11:02:07.044]     else {
[11:02:07.044]         if (TRUE) {
[11:02:07.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:07.044]                 open = "w")
[11:02:07.044]         }
[11:02:07.044]         else {
[11:02:07.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:07.044]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:07.044]         }
[11:02:07.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:07.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:07.044]             base::sink(type = "output", split = FALSE)
[11:02:07.044]             base::close(...future.stdout)
[11:02:07.044]         }, add = TRUE)
[11:02:07.044]     }
[11:02:07.044]     ...future.frame <- base::sys.nframe()
[11:02:07.044]     ...future.conditions <- base::list()
[11:02:07.044]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:07.044]     if (FALSE) {
[11:02:07.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:07.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:07.044]     }
[11:02:07.044]     ...future.result <- base::tryCatch({
[11:02:07.044]         base::withCallingHandlers({
[11:02:07.044]             ...future.value <- base::withVisible(base::local({
[11:02:07.044]                 ...future.makeSendCondition <- base::local({
[11:02:07.044]                   sendCondition <- NULL
[11:02:07.044]                   function(frame = 1L) {
[11:02:07.044]                     if (is.function(sendCondition)) 
[11:02:07.044]                       return(sendCondition)
[11:02:07.044]                     ns <- getNamespace("parallel")
[11:02:07.044]                     if (exists("sendData", mode = "function", 
[11:02:07.044]                       envir = ns)) {
[11:02:07.044]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:07.044]                         envir = ns)
[11:02:07.044]                       envir <- sys.frame(frame)
[11:02:07.044]                       master <- NULL
[11:02:07.044]                       while (!identical(envir, .GlobalEnv) && 
[11:02:07.044]                         !identical(envir, emptyenv())) {
[11:02:07.044]                         if (exists("master", mode = "list", envir = envir, 
[11:02:07.044]                           inherits = FALSE)) {
[11:02:07.044]                           master <- get("master", mode = "list", 
[11:02:07.044]                             envir = envir, inherits = FALSE)
[11:02:07.044]                           if (inherits(master, c("SOCKnode", 
[11:02:07.044]                             "SOCK0node"))) {
[11:02:07.044]                             sendCondition <<- function(cond) {
[11:02:07.044]                               data <- list(type = "VALUE", value = cond, 
[11:02:07.044]                                 success = TRUE)
[11:02:07.044]                               parallel_sendData(master, data)
[11:02:07.044]                             }
[11:02:07.044]                             return(sendCondition)
[11:02:07.044]                           }
[11:02:07.044]                         }
[11:02:07.044]                         frame <- frame + 1L
[11:02:07.044]                         envir <- sys.frame(frame)
[11:02:07.044]                       }
[11:02:07.044]                     }
[11:02:07.044]                     sendCondition <<- function(cond) NULL
[11:02:07.044]                   }
[11:02:07.044]                 })
[11:02:07.044]                 withCallingHandlers({
[11:02:07.044]                   {
[11:02:07.044]                     integer(1e+07)
[11:02:07.044]                   }
[11:02:07.044]                 }, immediateCondition = function(cond) {
[11:02:07.044]                   sendCondition <- ...future.makeSendCondition()
[11:02:07.044]                   sendCondition(cond)
[11:02:07.044]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.044]                   {
[11:02:07.044]                     inherits <- base::inherits
[11:02:07.044]                     invokeRestart <- base::invokeRestart
[11:02:07.044]                     is.null <- base::is.null
[11:02:07.044]                     muffled <- FALSE
[11:02:07.044]                     if (inherits(cond, "message")) {
[11:02:07.044]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:07.044]                       if (muffled) 
[11:02:07.044]                         invokeRestart("muffleMessage")
[11:02:07.044]                     }
[11:02:07.044]                     else if (inherits(cond, "warning")) {
[11:02:07.044]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:07.044]                       if (muffled) 
[11:02:07.044]                         invokeRestart("muffleWarning")
[11:02:07.044]                     }
[11:02:07.044]                     else if (inherits(cond, "condition")) {
[11:02:07.044]                       if (!is.null(pattern)) {
[11:02:07.044]                         computeRestarts <- base::computeRestarts
[11:02:07.044]                         grepl <- base::grepl
[11:02:07.044]                         restarts <- computeRestarts(cond)
[11:02:07.044]                         for (restart in restarts) {
[11:02:07.044]                           name <- restart$name
[11:02:07.044]                           if (is.null(name)) 
[11:02:07.044]                             next
[11:02:07.044]                           if (!grepl(pattern, name)) 
[11:02:07.044]                             next
[11:02:07.044]                           invokeRestart(restart)
[11:02:07.044]                           muffled <- TRUE
[11:02:07.044]                           break
[11:02:07.044]                         }
[11:02:07.044]                       }
[11:02:07.044]                     }
[11:02:07.044]                     invisible(muffled)
[11:02:07.044]                   }
[11:02:07.044]                   muffleCondition(cond)
[11:02:07.044]                 })
[11:02:07.044]             }))
[11:02:07.044]             future::FutureResult(value = ...future.value$value, 
[11:02:07.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:07.044]                   ...future.rng), globalenv = if (FALSE) 
[11:02:07.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:07.044]                     ...future.globalenv.names))
[11:02:07.044]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:07.044]         }, condition = base::local({
[11:02:07.044]             c <- base::c
[11:02:07.044]             inherits <- base::inherits
[11:02:07.044]             invokeRestart <- base::invokeRestart
[11:02:07.044]             length <- base::length
[11:02:07.044]             list <- base::list
[11:02:07.044]             seq.int <- base::seq.int
[11:02:07.044]             signalCondition <- base::signalCondition
[11:02:07.044]             sys.calls <- base::sys.calls
[11:02:07.044]             `[[` <- base::`[[`
[11:02:07.044]             `+` <- base::`+`
[11:02:07.044]             `<<-` <- base::`<<-`
[11:02:07.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:07.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:07.044]                   3L)]
[11:02:07.044]             }
[11:02:07.044]             function(cond) {
[11:02:07.044]                 is_error <- inherits(cond, "error")
[11:02:07.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:07.044]                   NULL)
[11:02:07.044]                 if (is_error) {
[11:02:07.044]                   sessionInformation <- function() {
[11:02:07.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:07.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:07.044]                       search = base::search(), system = base::Sys.info())
[11:02:07.044]                   }
[11:02:07.044]                   ...future.conditions[[length(...future.conditions) + 
[11:02:07.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:07.044]                     cond$call), session = sessionInformation(), 
[11:02:07.044]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:07.044]                   signalCondition(cond)
[11:02:07.044]                 }
[11:02:07.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:07.044]                 "immediateCondition"))) {
[11:02:07.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:07.044]                   ...future.conditions[[length(...future.conditions) + 
[11:02:07.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:07.044]                   if (TRUE && !signal) {
[11:02:07.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.044]                     {
[11:02:07.044]                       inherits <- base::inherits
[11:02:07.044]                       invokeRestart <- base::invokeRestart
[11:02:07.044]                       is.null <- base::is.null
[11:02:07.044]                       muffled <- FALSE
[11:02:07.044]                       if (inherits(cond, "message")) {
[11:02:07.044]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:07.044]                         if (muffled) 
[11:02:07.044]                           invokeRestart("muffleMessage")
[11:02:07.044]                       }
[11:02:07.044]                       else if (inherits(cond, "warning")) {
[11:02:07.044]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:07.044]                         if (muffled) 
[11:02:07.044]                           invokeRestart("muffleWarning")
[11:02:07.044]                       }
[11:02:07.044]                       else if (inherits(cond, "condition")) {
[11:02:07.044]                         if (!is.null(pattern)) {
[11:02:07.044]                           computeRestarts <- base::computeRestarts
[11:02:07.044]                           grepl <- base::grepl
[11:02:07.044]                           restarts <- computeRestarts(cond)
[11:02:07.044]                           for (restart in restarts) {
[11:02:07.044]                             name <- restart$name
[11:02:07.044]                             if (is.null(name)) 
[11:02:07.044]                               next
[11:02:07.044]                             if (!grepl(pattern, name)) 
[11:02:07.044]                               next
[11:02:07.044]                             invokeRestart(restart)
[11:02:07.044]                             muffled <- TRUE
[11:02:07.044]                             break
[11:02:07.044]                           }
[11:02:07.044]                         }
[11:02:07.044]                       }
[11:02:07.044]                       invisible(muffled)
[11:02:07.044]                     }
[11:02:07.044]                     muffleCondition(cond, pattern = "^muffle")
[11:02:07.044]                   }
[11:02:07.044]                 }
[11:02:07.044]                 else {
[11:02:07.044]                   if (TRUE) {
[11:02:07.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.044]                     {
[11:02:07.044]                       inherits <- base::inherits
[11:02:07.044]                       invokeRestart <- base::invokeRestart
[11:02:07.044]                       is.null <- base::is.null
[11:02:07.044]                       muffled <- FALSE
[11:02:07.044]                       if (inherits(cond, "message")) {
[11:02:07.044]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:07.044]                         if (muffled) 
[11:02:07.044]                           invokeRestart("muffleMessage")
[11:02:07.044]                       }
[11:02:07.044]                       else if (inherits(cond, "warning")) {
[11:02:07.044]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:07.044]                         if (muffled) 
[11:02:07.044]                           invokeRestart("muffleWarning")
[11:02:07.044]                       }
[11:02:07.044]                       else if (inherits(cond, "condition")) {
[11:02:07.044]                         if (!is.null(pattern)) {
[11:02:07.044]                           computeRestarts <- base::computeRestarts
[11:02:07.044]                           grepl <- base::grepl
[11:02:07.044]                           restarts <- computeRestarts(cond)
[11:02:07.044]                           for (restart in restarts) {
[11:02:07.044]                             name <- restart$name
[11:02:07.044]                             if (is.null(name)) 
[11:02:07.044]                               next
[11:02:07.044]                             if (!grepl(pattern, name)) 
[11:02:07.044]                               next
[11:02:07.044]                             invokeRestart(restart)
[11:02:07.044]                             muffled <- TRUE
[11:02:07.044]                             break
[11:02:07.044]                           }
[11:02:07.044]                         }
[11:02:07.044]                       }
[11:02:07.044]                       invisible(muffled)
[11:02:07.044]                     }
[11:02:07.044]                     muffleCondition(cond, pattern = "^muffle")
[11:02:07.044]                   }
[11:02:07.044]                 }
[11:02:07.044]             }
[11:02:07.044]         }))
[11:02:07.044]     }, error = function(ex) {
[11:02:07.044]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:07.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:07.044]                 ...future.rng), started = ...future.startTime, 
[11:02:07.044]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:07.044]             version = "1.8"), class = "FutureResult")
[11:02:07.044]     }, finally = {
[11:02:07.044]         if (!identical(...future.workdir, getwd())) 
[11:02:07.044]             setwd(...future.workdir)
[11:02:07.044]         {
[11:02:07.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:07.044]                 ...future.oldOptions$nwarnings <- NULL
[11:02:07.044]             }
[11:02:07.044]             base::options(...future.oldOptions)
[11:02:07.044]             if (.Platform$OS.type == "windows") {
[11:02:07.044]                 old_names <- names(...future.oldEnvVars)
[11:02:07.044]                 envs <- base::Sys.getenv()
[11:02:07.044]                 names <- names(envs)
[11:02:07.044]                 common <- intersect(names, old_names)
[11:02:07.044]                 added <- setdiff(names, old_names)
[11:02:07.044]                 removed <- setdiff(old_names, names)
[11:02:07.044]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:07.044]                   envs[common]]
[11:02:07.044]                 NAMES <- toupper(changed)
[11:02:07.044]                 args <- list()
[11:02:07.044]                 for (kk in seq_along(NAMES)) {
[11:02:07.044]                   name <- changed[[kk]]
[11:02:07.044]                   NAME <- NAMES[[kk]]
[11:02:07.044]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.044]                     next
[11:02:07.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:07.044]                 }
[11:02:07.044]                 NAMES <- toupper(added)
[11:02:07.044]                 for (kk in seq_along(NAMES)) {
[11:02:07.044]                   name <- added[[kk]]
[11:02:07.044]                   NAME <- NAMES[[kk]]
[11:02:07.044]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.044]                     next
[11:02:07.044]                   args[[name]] <- ""
[11:02:07.044]                 }
[11:02:07.044]                 NAMES <- toupper(removed)
[11:02:07.044]                 for (kk in seq_along(NAMES)) {
[11:02:07.044]                   name <- removed[[kk]]
[11:02:07.044]                   NAME <- NAMES[[kk]]
[11:02:07.044]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.044]                     next
[11:02:07.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:07.044]                 }
[11:02:07.044]                 if (length(args) > 0) 
[11:02:07.044]                   base::do.call(base::Sys.setenv, args = args)
[11:02:07.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:07.044]             }
[11:02:07.044]             else {
[11:02:07.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:07.044]             }
[11:02:07.044]             {
[11:02:07.044]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:07.044]                   0L) {
[11:02:07.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:07.044]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:07.044]                   base::options(opts)
[11:02:07.044]                 }
[11:02:07.044]                 {
[11:02:07.044]                   {
[11:02:07.044]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:07.044]                     NULL
[11:02:07.044]                   }
[11:02:07.044]                   options(future.plan = NULL)
[11:02:07.044]                   if (is.na(NA_character_)) 
[11:02:07.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:07.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:07.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:07.044]                     .init = FALSE)
[11:02:07.044]                 }
[11:02:07.044]             }
[11:02:07.044]         }
[11:02:07.044]     })
[11:02:07.044]     if (TRUE) {
[11:02:07.044]         base::sink(type = "output", split = FALSE)
[11:02:07.044]         if (TRUE) {
[11:02:07.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:07.044]         }
[11:02:07.044]         else {
[11:02:07.044]             ...future.result["stdout"] <- base::list(NULL)
[11:02:07.044]         }
[11:02:07.044]         base::close(...future.stdout)
[11:02:07.044]         ...future.stdout <- NULL
[11:02:07.044]     }
[11:02:07.044]     ...future.result$conditions <- ...future.conditions
[11:02:07.044]     ...future.result$finished <- base::Sys.time()
[11:02:07.044]     ...future.result
[11:02:07.044] }
[11:02:07.047] MultisessionFuture started
[11:02:07.047] - Launch lazy future ... done
[11:02:07.047] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[11:02:07.047] result() for ClusterFuture ...
[11:02:07.047] receiveMessageFromWorker() for ClusterFuture ...
[11:02:07.047] - Validating connection of MultisessionFuture
[11:02:07.136] - received message: FutureResult
[11:02:07.136] - Received FutureResult
[11:02:07.136] - Erased future from FutureRegistry
[11:02:07.136] result() for ClusterFuture ...
[11:02:07.136] - result already collected: FutureResult
[11:02:07.137] result() for ClusterFuture ... done
[11:02:07.137] - Garbage collecting worker ...
[11:02:07.370] - Garbage collecting worker ... done
[11:02:07.370] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:07.370] result() for ClusterFuture ... done
[11:02:07.371] result() for ClusterFuture ...
[11:02:07.371] - result already collected: FutureResult
[11:02:07.371] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[11:02:07.371] getGlobalsAndPackages() ...
[11:02:07.371] Searching for globals...
[11:02:07.372] - globals found: [2] ‘{’, ‘gc’
[11:02:07.372] Searching for globals ... DONE
[11:02:07.372] Resolving globals: FALSE
[11:02:07.373] 
[11:02:07.373] 
[11:02:07.373] getGlobalsAndPackages() ... DONE
[11:02:07.373] run() for ‘Future’ ...
[11:02:07.373] - state: ‘created’
[11:02:07.373] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:07.386] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:07.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:07.386]   - Field: ‘node’
[11:02:07.386]   - Field: ‘label’
[11:02:07.386]   - Field: ‘local’
[11:02:07.386]   - Field: ‘owner’
[11:02:07.386]   - Field: ‘envir’
[11:02:07.387]   - Field: ‘workers’
[11:02:07.387]   - Field: ‘packages’
[11:02:07.387]   - Field: ‘gc’
[11:02:07.387]   - Field: ‘conditions’
[11:02:07.387]   - Field: ‘persistent’
[11:02:07.387]   - Field: ‘expr’
[11:02:07.387]   - Field: ‘uuid’
[11:02:07.387]   - Field: ‘seed’
[11:02:07.387]   - Field: ‘version’
[11:02:07.387]   - Field: ‘result’
[11:02:07.387]   - Field: ‘asynchronous’
[11:02:07.387]   - Field: ‘calls’
[11:02:07.388]   - Field: ‘globals’
[11:02:07.388]   - Field: ‘stdout’
[11:02:07.388]   - Field: ‘earlySignal’
[11:02:07.388]   - Field: ‘lazy’
[11:02:07.388]   - Field: ‘state’
[11:02:07.388] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:07.388] - Launch lazy future ...
[11:02:07.388] Packages needed by the future expression (n = 0): <none>
[11:02:07.388] Packages needed by future strategies (n = 0): <none>
[11:02:07.389] {
[11:02:07.389]     {
[11:02:07.389]         {
[11:02:07.389]             ...future.startTime <- base::Sys.time()
[11:02:07.389]             {
[11:02:07.389]                 {
[11:02:07.389]                   {
[11:02:07.389]                     {
[11:02:07.389]                       base::local({
[11:02:07.389]                         has_future <- base::requireNamespace("future", 
[11:02:07.389]                           quietly = TRUE)
[11:02:07.389]                         if (has_future) {
[11:02:07.389]                           ns <- base::getNamespace("future")
[11:02:07.389]                           version <- ns[[".package"]][["version"]]
[11:02:07.389]                           if (is.null(version)) 
[11:02:07.389]                             version <- utils::packageVersion("future")
[11:02:07.389]                         }
[11:02:07.389]                         else {
[11:02:07.389]                           version <- NULL
[11:02:07.389]                         }
[11:02:07.389]                         if (!has_future || version < "1.8.0") {
[11:02:07.389]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:07.389]                             "", base::R.version$version.string), 
[11:02:07.389]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:07.389]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:07.389]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:07.389]                               "release", "version")], collapse = " "), 
[11:02:07.389]                             hostname = base::Sys.info()[["nodename"]])
[11:02:07.389]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:07.389]                             info)
[11:02:07.389]                           info <- base::paste(info, collapse = "; ")
[11:02:07.389]                           if (!has_future) {
[11:02:07.389]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:07.389]                               info)
[11:02:07.389]                           }
[11:02:07.389]                           else {
[11:02:07.389]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:07.389]                               info, version)
[11:02:07.389]                           }
[11:02:07.389]                           base::stop(msg)
[11:02:07.389]                         }
[11:02:07.389]                       })
[11:02:07.389]                     }
[11:02:07.389]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:07.389]                     base::options(mc.cores = 1L)
[11:02:07.389]                   }
[11:02:07.389]                   ...future.strategy.old <- future::plan("list")
[11:02:07.389]                   options(future.plan = NULL)
[11:02:07.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:07.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:07.389]                 }
[11:02:07.389]                 ...future.workdir <- getwd()
[11:02:07.389]             }
[11:02:07.389]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:07.389]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:07.389]         }
[11:02:07.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:07.389]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:07.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:07.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:07.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:07.389]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:07.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:07.389]             base::names(...future.oldOptions))
[11:02:07.389]     }
[11:02:07.389]     if (FALSE) {
[11:02:07.389]     }
[11:02:07.389]     else {
[11:02:07.389]         if (TRUE) {
[11:02:07.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:07.389]                 open = "w")
[11:02:07.389]         }
[11:02:07.389]         else {
[11:02:07.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:07.389]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:07.389]         }
[11:02:07.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:07.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:07.389]             base::sink(type = "output", split = FALSE)
[11:02:07.389]             base::close(...future.stdout)
[11:02:07.389]         }, add = TRUE)
[11:02:07.389]     }
[11:02:07.389]     ...future.frame <- base::sys.nframe()
[11:02:07.389]     ...future.conditions <- base::list()
[11:02:07.389]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:07.389]     if (FALSE) {
[11:02:07.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:07.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:07.389]     }
[11:02:07.389]     ...future.result <- base::tryCatch({
[11:02:07.389]         base::withCallingHandlers({
[11:02:07.389]             ...future.value <- base::withVisible(base::local({
[11:02:07.389]                 ...future.makeSendCondition <- base::local({
[11:02:07.389]                   sendCondition <- NULL
[11:02:07.389]                   function(frame = 1L) {
[11:02:07.389]                     if (is.function(sendCondition)) 
[11:02:07.389]                       return(sendCondition)
[11:02:07.389]                     ns <- getNamespace("parallel")
[11:02:07.389]                     if (exists("sendData", mode = "function", 
[11:02:07.389]                       envir = ns)) {
[11:02:07.389]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:07.389]                         envir = ns)
[11:02:07.389]                       envir <- sys.frame(frame)
[11:02:07.389]                       master <- NULL
[11:02:07.389]                       while (!identical(envir, .GlobalEnv) && 
[11:02:07.389]                         !identical(envir, emptyenv())) {
[11:02:07.389]                         if (exists("master", mode = "list", envir = envir, 
[11:02:07.389]                           inherits = FALSE)) {
[11:02:07.389]                           master <- get("master", mode = "list", 
[11:02:07.389]                             envir = envir, inherits = FALSE)
[11:02:07.389]                           if (inherits(master, c("SOCKnode", 
[11:02:07.389]                             "SOCK0node"))) {
[11:02:07.389]                             sendCondition <<- function(cond) {
[11:02:07.389]                               data <- list(type = "VALUE", value = cond, 
[11:02:07.389]                                 success = TRUE)
[11:02:07.389]                               parallel_sendData(master, data)
[11:02:07.389]                             }
[11:02:07.389]                             return(sendCondition)
[11:02:07.389]                           }
[11:02:07.389]                         }
[11:02:07.389]                         frame <- frame + 1L
[11:02:07.389]                         envir <- sys.frame(frame)
[11:02:07.389]                       }
[11:02:07.389]                     }
[11:02:07.389]                     sendCondition <<- function(cond) NULL
[11:02:07.389]                   }
[11:02:07.389]                 })
[11:02:07.389]                 withCallingHandlers({
[11:02:07.389]                   {
[11:02:07.389]                     gc()
[11:02:07.389]                   }
[11:02:07.389]                 }, immediateCondition = function(cond) {
[11:02:07.389]                   sendCondition <- ...future.makeSendCondition()
[11:02:07.389]                   sendCondition(cond)
[11:02:07.389]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.389]                   {
[11:02:07.389]                     inherits <- base::inherits
[11:02:07.389]                     invokeRestart <- base::invokeRestart
[11:02:07.389]                     is.null <- base::is.null
[11:02:07.389]                     muffled <- FALSE
[11:02:07.389]                     if (inherits(cond, "message")) {
[11:02:07.389]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:07.389]                       if (muffled) 
[11:02:07.389]                         invokeRestart("muffleMessage")
[11:02:07.389]                     }
[11:02:07.389]                     else if (inherits(cond, "warning")) {
[11:02:07.389]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:07.389]                       if (muffled) 
[11:02:07.389]                         invokeRestart("muffleWarning")
[11:02:07.389]                     }
[11:02:07.389]                     else if (inherits(cond, "condition")) {
[11:02:07.389]                       if (!is.null(pattern)) {
[11:02:07.389]                         computeRestarts <- base::computeRestarts
[11:02:07.389]                         grepl <- base::grepl
[11:02:07.389]                         restarts <- computeRestarts(cond)
[11:02:07.389]                         for (restart in restarts) {
[11:02:07.389]                           name <- restart$name
[11:02:07.389]                           if (is.null(name)) 
[11:02:07.389]                             next
[11:02:07.389]                           if (!grepl(pattern, name)) 
[11:02:07.389]                             next
[11:02:07.389]                           invokeRestart(restart)
[11:02:07.389]                           muffled <- TRUE
[11:02:07.389]                           break
[11:02:07.389]                         }
[11:02:07.389]                       }
[11:02:07.389]                     }
[11:02:07.389]                     invisible(muffled)
[11:02:07.389]                   }
[11:02:07.389]                   muffleCondition(cond)
[11:02:07.389]                 })
[11:02:07.389]             }))
[11:02:07.389]             future::FutureResult(value = ...future.value$value, 
[11:02:07.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:07.389]                   ...future.rng), globalenv = if (FALSE) 
[11:02:07.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:07.389]                     ...future.globalenv.names))
[11:02:07.389]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:07.389]         }, condition = base::local({
[11:02:07.389]             c <- base::c
[11:02:07.389]             inherits <- base::inherits
[11:02:07.389]             invokeRestart <- base::invokeRestart
[11:02:07.389]             length <- base::length
[11:02:07.389]             list <- base::list
[11:02:07.389]             seq.int <- base::seq.int
[11:02:07.389]             signalCondition <- base::signalCondition
[11:02:07.389]             sys.calls <- base::sys.calls
[11:02:07.389]             `[[` <- base::`[[`
[11:02:07.389]             `+` <- base::`+`
[11:02:07.389]             `<<-` <- base::`<<-`
[11:02:07.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:07.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:07.389]                   3L)]
[11:02:07.389]             }
[11:02:07.389]             function(cond) {
[11:02:07.389]                 is_error <- inherits(cond, "error")
[11:02:07.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:07.389]                   NULL)
[11:02:07.389]                 if (is_error) {
[11:02:07.389]                   sessionInformation <- function() {
[11:02:07.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:07.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:07.389]                       search = base::search(), system = base::Sys.info())
[11:02:07.389]                   }
[11:02:07.389]                   ...future.conditions[[length(...future.conditions) + 
[11:02:07.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:07.389]                     cond$call), session = sessionInformation(), 
[11:02:07.389]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:07.389]                   signalCondition(cond)
[11:02:07.389]                 }
[11:02:07.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:07.389]                 "immediateCondition"))) {
[11:02:07.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:07.389]                   ...future.conditions[[length(...future.conditions) + 
[11:02:07.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:07.389]                   if (TRUE && !signal) {
[11:02:07.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.389]                     {
[11:02:07.389]                       inherits <- base::inherits
[11:02:07.389]                       invokeRestart <- base::invokeRestart
[11:02:07.389]                       is.null <- base::is.null
[11:02:07.389]                       muffled <- FALSE
[11:02:07.389]                       if (inherits(cond, "message")) {
[11:02:07.389]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:07.389]                         if (muffled) 
[11:02:07.389]                           invokeRestart("muffleMessage")
[11:02:07.389]                       }
[11:02:07.389]                       else if (inherits(cond, "warning")) {
[11:02:07.389]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:07.389]                         if (muffled) 
[11:02:07.389]                           invokeRestart("muffleWarning")
[11:02:07.389]                       }
[11:02:07.389]                       else if (inherits(cond, "condition")) {
[11:02:07.389]                         if (!is.null(pattern)) {
[11:02:07.389]                           computeRestarts <- base::computeRestarts
[11:02:07.389]                           grepl <- base::grepl
[11:02:07.389]                           restarts <- computeRestarts(cond)
[11:02:07.389]                           for (restart in restarts) {
[11:02:07.389]                             name <- restart$name
[11:02:07.389]                             if (is.null(name)) 
[11:02:07.389]                               next
[11:02:07.389]                             if (!grepl(pattern, name)) 
[11:02:07.389]                               next
[11:02:07.389]                             invokeRestart(restart)
[11:02:07.389]                             muffled <- TRUE
[11:02:07.389]                             break
[11:02:07.389]                           }
[11:02:07.389]                         }
[11:02:07.389]                       }
[11:02:07.389]                       invisible(muffled)
[11:02:07.389]                     }
[11:02:07.389]                     muffleCondition(cond, pattern = "^muffle")
[11:02:07.389]                   }
[11:02:07.389]                 }
[11:02:07.389]                 else {
[11:02:07.389]                   if (TRUE) {
[11:02:07.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.389]                     {
[11:02:07.389]                       inherits <- base::inherits
[11:02:07.389]                       invokeRestart <- base::invokeRestart
[11:02:07.389]                       is.null <- base::is.null
[11:02:07.389]                       muffled <- FALSE
[11:02:07.389]                       if (inherits(cond, "message")) {
[11:02:07.389]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:07.389]                         if (muffled) 
[11:02:07.389]                           invokeRestart("muffleMessage")
[11:02:07.389]                       }
[11:02:07.389]                       else if (inherits(cond, "warning")) {
[11:02:07.389]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:07.389]                         if (muffled) 
[11:02:07.389]                           invokeRestart("muffleWarning")
[11:02:07.389]                       }
[11:02:07.389]                       else if (inherits(cond, "condition")) {
[11:02:07.389]                         if (!is.null(pattern)) {
[11:02:07.389]                           computeRestarts <- base::computeRestarts
[11:02:07.389]                           grepl <- base::grepl
[11:02:07.389]                           restarts <- computeRestarts(cond)
[11:02:07.389]                           for (restart in restarts) {
[11:02:07.389]                             name <- restart$name
[11:02:07.389]                             if (is.null(name)) 
[11:02:07.389]                               next
[11:02:07.389]                             if (!grepl(pattern, name)) 
[11:02:07.389]                               next
[11:02:07.389]                             invokeRestart(restart)
[11:02:07.389]                             muffled <- TRUE
[11:02:07.389]                             break
[11:02:07.389]                           }
[11:02:07.389]                         }
[11:02:07.389]                       }
[11:02:07.389]                       invisible(muffled)
[11:02:07.389]                     }
[11:02:07.389]                     muffleCondition(cond, pattern = "^muffle")
[11:02:07.389]                   }
[11:02:07.389]                 }
[11:02:07.389]             }
[11:02:07.389]         }))
[11:02:07.389]     }, error = function(ex) {
[11:02:07.389]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:07.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:07.389]                 ...future.rng), started = ...future.startTime, 
[11:02:07.389]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:07.389]             version = "1.8"), class = "FutureResult")
[11:02:07.389]     }, finally = {
[11:02:07.389]         if (!identical(...future.workdir, getwd())) 
[11:02:07.389]             setwd(...future.workdir)
[11:02:07.389]         {
[11:02:07.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:07.389]                 ...future.oldOptions$nwarnings <- NULL
[11:02:07.389]             }
[11:02:07.389]             base::options(...future.oldOptions)
[11:02:07.389]             if (.Platform$OS.type == "windows") {
[11:02:07.389]                 old_names <- names(...future.oldEnvVars)
[11:02:07.389]                 envs <- base::Sys.getenv()
[11:02:07.389]                 names <- names(envs)
[11:02:07.389]                 common <- intersect(names, old_names)
[11:02:07.389]                 added <- setdiff(names, old_names)
[11:02:07.389]                 removed <- setdiff(old_names, names)
[11:02:07.389]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:07.389]                   envs[common]]
[11:02:07.389]                 NAMES <- toupper(changed)
[11:02:07.389]                 args <- list()
[11:02:07.389]                 for (kk in seq_along(NAMES)) {
[11:02:07.389]                   name <- changed[[kk]]
[11:02:07.389]                   NAME <- NAMES[[kk]]
[11:02:07.389]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.389]                     next
[11:02:07.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:07.389]                 }
[11:02:07.389]                 NAMES <- toupper(added)
[11:02:07.389]                 for (kk in seq_along(NAMES)) {
[11:02:07.389]                   name <- added[[kk]]
[11:02:07.389]                   NAME <- NAMES[[kk]]
[11:02:07.389]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.389]                     next
[11:02:07.389]                   args[[name]] <- ""
[11:02:07.389]                 }
[11:02:07.389]                 NAMES <- toupper(removed)
[11:02:07.389]                 for (kk in seq_along(NAMES)) {
[11:02:07.389]                   name <- removed[[kk]]
[11:02:07.389]                   NAME <- NAMES[[kk]]
[11:02:07.389]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.389]                     next
[11:02:07.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:07.389]                 }
[11:02:07.389]                 if (length(args) > 0) 
[11:02:07.389]                   base::do.call(base::Sys.setenv, args = args)
[11:02:07.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:07.389]             }
[11:02:07.389]             else {
[11:02:07.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:07.389]             }
[11:02:07.389]             {
[11:02:07.389]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:07.389]                   0L) {
[11:02:07.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:07.389]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:07.389]                   base::options(opts)
[11:02:07.389]                 }
[11:02:07.389]                 {
[11:02:07.389]                   {
[11:02:07.389]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:07.389]                     NULL
[11:02:07.389]                   }
[11:02:07.389]                   options(future.plan = NULL)
[11:02:07.389]                   if (is.na(NA_character_)) 
[11:02:07.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:07.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:07.389]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:07.389]                     .init = FALSE)
[11:02:07.389]                 }
[11:02:07.389]             }
[11:02:07.389]         }
[11:02:07.389]     })
[11:02:07.389]     if (TRUE) {
[11:02:07.389]         base::sink(type = "output", split = FALSE)
[11:02:07.389]         if (TRUE) {
[11:02:07.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:07.389]         }
[11:02:07.389]         else {
[11:02:07.389]             ...future.result["stdout"] <- base::list(NULL)
[11:02:07.389]         }
[11:02:07.389]         base::close(...future.stdout)
[11:02:07.389]         ...future.stdout <- NULL
[11:02:07.389]     }
[11:02:07.389]     ...future.result$conditions <- ...future.conditions
[11:02:07.389]     ...future.result$finished <- base::Sys.time()
[11:02:07.389]     ...future.result
[11:02:07.389] }
[11:02:07.392] MultisessionFuture started
[11:02:07.392] - Launch lazy future ... done
[11:02:07.392] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[11:02:07.392] result() for ClusterFuture ...
[11:02:07.392] receiveMessageFromWorker() for ClusterFuture ...
[11:02:07.392] - Validating connection of MultisessionFuture
[11:02:07.452] - received message: FutureResult
[11:02:07.452] - Received FutureResult
[11:02:07.452] - Erased future from FutureRegistry
[11:02:07.452] result() for ClusterFuture ...
[11:02:07.453] - result already collected: FutureResult
[11:02:07.453] result() for ClusterFuture ... done
[11:02:07.453] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:07.453] result() for ClusterFuture ... done
[11:02:07.453] result() for ClusterFuture ...
[11:02:07.453] - result already collected: FutureResult
[11:02:07.453] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger  (Mb) max used  (Mb)
Ncells 409682 21.9     912381  48.8   692220  37.0
Vcells 732467  5.6   13482749 102.9 15813665 120.7
> 
> message("*** multisession(..., gc = TRUE) ... TRUE")
*** multisession(..., gc = TRUE) ... TRUE
> 
> 
> message("*** multisession(...) - stopping with plan() change ...")
*** multisession(...) - stopping with plan() change ...
>   
> plan(multisession, workers = 2L)
[11:02:07.454] plan(): Setting new future strategy stack:
[11:02:07.454] List of future strategies:
[11:02:07.454] 1. multisession:
[11:02:07.454]    - args: function (..., workers = 2L, envir = parent.frame())
[11:02:07.454]    - tweaked: TRUE
[11:02:07.454]    - call: plan(multisession, workers = 2L)
[11:02:07.454] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:02:07.455] multisession:
[11:02:07.455] - args: function (..., workers = 2L, envir = parent.frame())
[11:02:07.455] - tweaked: TRUE
[11:02:07.455] - call: plan(multisession, workers = 2L)
[11:02:07.455] getGlobalsAndPackages() ...
[11:02:07.455] Not searching for globals
[11:02:07.456] - globals: [0] <none>
[11:02:07.456] getGlobalsAndPackages() ... DONE
[11:02:07.727] Packages needed by the future expression (n = 0): <none>
[11:02:07.727] Packages needed by future strategies (n = 0): <none>
[11:02:07.728] {
[11:02:07.728]     {
[11:02:07.728]         {
[11:02:07.728]             ...future.startTime <- base::Sys.time()
[11:02:07.728]             {
[11:02:07.728]                 {
[11:02:07.728]                   {
[11:02:07.728]                     {
[11:02:07.728]                       base::local({
[11:02:07.728]                         has_future <- base::requireNamespace("future", 
[11:02:07.728]                           quietly = TRUE)
[11:02:07.728]                         if (has_future) {
[11:02:07.728]                           ns <- base::getNamespace("future")
[11:02:07.728]                           version <- ns[[".package"]][["version"]]
[11:02:07.728]                           if (is.null(version)) 
[11:02:07.728]                             version <- utils::packageVersion("future")
[11:02:07.728]                         }
[11:02:07.728]                         else {
[11:02:07.728]                           version <- NULL
[11:02:07.728]                         }
[11:02:07.728]                         if (!has_future || version < "1.8.0") {
[11:02:07.728]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:07.728]                             "", base::R.version$version.string), 
[11:02:07.728]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:07.728]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:07.728]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:07.728]                               "release", "version")], collapse = " "), 
[11:02:07.728]                             hostname = base::Sys.info()[["nodename"]])
[11:02:07.728]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:07.728]                             info)
[11:02:07.728]                           info <- base::paste(info, collapse = "; ")
[11:02:07.728]                           if (!has_future) {
[11:02:07.728]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:07.728]                               info)
[11:02:07.728]                           }
[11:02:07.728]                           else {
[11:02:07.728]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:07.728]                               info, version)
[11:02:07.728]                           }
[11:02:07.728]                           base::stop(msg)
[11:02:07.728]                         }
[11:02:07.728]                       })
[11:02:07.728]                     }
[11:02:07.728]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:07.728]                     base::options(mc.cores = 1L)
[11:02:07.728]                   }
[11:02:07.728]                   ...future.strategy.old <- future::plan("list")
[11:02:07.728]                   options(future.plan = NULL)
[11:02:07.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:07.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:07.728]                 }
[11:02:07.728]                 ...future.workdir <- getwd()
[11:02:07.728]             }
[11:02:07.728]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:07.728]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:07.728]         }
[11:02:07.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:07.728]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:07.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:07.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:07.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:07.728]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:07.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:07.728]             base::names(...future.oldOptions))
[11:02:07.728]     }
[11:02:07.728]     if (FALSE) {
[11:02:07.728]     }
[11:02:07.728]     else {
[11:02:07.728]         if (TRUE) {
[11:02:07.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:07.728]                 open = "w")
[11:02:07.728]         }
[11:02:07.728]         else {
[11:02:07.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:07.728]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:07.728]         }
[11:02:07.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:07.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:07.728]             base::sink(type = "output", split = FALSE)
[11:02:07.728]             base::close(...future.stdout)
[11:02:07.728]         }, add = TRUE)
[11:02:07.728]     }
[11:02:07.728]     ...future.frame <- base::sys.nframe()
[11:02:07.728]     ...future.conditions <- base::list()
[11:02:07.728]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:07.728]     if (FALSE) {
[11:02:07.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:07.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:07.728]     }
[11:02:07.728]     ...future.result <- base::tryCatch({
[11:02:07.728]         base::withCallingHandlers({
[11:02:07.728]             ...future.value <- base::withVisible(base::local({
[11:02:07.728]                 ...future.makeSendCondition <- base::local({
[11:02:07.728]                   sendCondition <- NULL
[11:02:07.728]                   function(frame = 1L) {
[11:02:07.728]                     if (is.function(sendCondition)) 
[11:02:07.728]                       return(sendCondition)
[11:02:07.728]                     ns <- getNamespace("parallel")
[11:02:07.728]                     if (exists("sendData", mode = "function", 
[11:02:07.728]                       envir = ns)) {
[11:02:07.728]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:07.728]                         envir = ns)
[11:02:07.728]                       envir <- sys.frame(frame)
[11:02:07.728]                       master <- NULL
[11:02:07.728]                       while (!identical(envir, .GlobalEnv) && 
[11:02:07.728]                         !identical(envir, emptyenv())) {
[11:02:07.728]                         if (exists("master", mode = "list", envir = envir, 
[11:02:07.728]                           inherits = FALSE)) {
[11:02:07.728]                           master <- get("master", mode = "list", 
[11:02:07.728]                             envir = envir, inherits = FALSE)
[11:02:07.728]                           if (inherits(master, c("SOCKnode", 
[11:02:07.728]                             "SOCK0node"))) {
[11:02:07.728]                             sendCondition <<- function(cond) {
[11:02:07.728]                               data <- list(type = "VALUE", value = cond, 
[11:02:07.728]                                 success = TRUE)
[11:02:07.728]                               parallel_sendData(master, data)
[11:02:07.728]                             }
[11:02:07.728]                             return(sendCondition)
[11:02:07.728]                           }
[11:02:07.728]                         }
[11:02:07.728]                         frame <- frame + 1L
[11:02:07.728]                         envir <- sys.frame(frame)
[11:02:07.728]                       }
[11:02:07.728]                     }
[11:02:07.728]                     sendCondition <<- function(cond) NULL
[11:02:07.728]                   }
[11:02:07.728]                 })
[11:02:07.728]                 withCallingHandlers({
[11:02:07.728]                   NA
[11:02:07.728]                 }, immediateCondition = function(cond) {
[11:02:07.728]                   sendCondition <- ...future.makeSendCondition()
[11:02:07.728]                   sendCondition(cond)
[11:02:07.728]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.728]                   {
[11:02:07.728]                     inherits <- base::inherits
[11:02:07.728]                     invokeRestart <- base::invokeRestart
[11:02:07.728]                     is.null <- base::is.null
[11:02:07.728]                     muffled <- FALSE
[11:02:07.728]                     if (inherits(cond, "message")) {
[11:02:07.728]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:07.728]                       if (muffled) 
[11:02:07.728]                         invokeRestart("muffleMessage")
[11:02:07.728]                     }
[11:02:07.728]                     else if (inherits(cond, "warning")) {
[11:02:07.728]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:07.728]                       if (muffled) 
[11:02:07.728]                         invokeRestart("muffleWarning")
[11:02:07.728]                     }
[11:02:07.728]                     else if (inherits(cond, "condition")) {
[11:02:07.728]                       if (!is.null(pattern)) {
[11:02:07.728]                         computeRestarts <- base::computeRestarts
[11:02:07.728]                         grepl <- base::grepl
[11:02:07.728]                         restarts <- computeRestarts(cond)
[11:02:07.728]                         for (restart in restarts) {
[11:02:07.728]                           name <- restart$name
[11:02:07.728]                           if (is.null(name)) 
[11:02:07.728]                             next
[11:02:07.728]                           if (!grepl(pattern, name)) 
[11:02:07.728]                             next
[11:02:07.728]                           invokeRestart(restart)
[11:02:07.728]                           muffled <- TRUE
[11:02:07.728]                           break
[11:02:07.728]                         }
[11:02:07.728]                       }
[11:02:07.728]                     }
[11:02:07.728]                     invisible(muffled)
[11:02:07.728]                   }
[11:02:07.728]                   muffleCondition(cond)
[11:02:07.728]                 })
[11:02:07.728]             }))
[11:02:07.728]             future::FutureResult(value = ...future.value$value, 
[11:02:07.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:07.728]                   ...future.rng), globalenv = if (FALSE) 
[11:02:07.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:07.728]                     ...future.globalenv.names))
[11:02:07.728]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:07.728]         }, condition = base::local({
[11:02:07.728]             c <- base::c
[11:02:07.728]             inherits <- base::inherits
[11:02:07.728]             invokeRestart <- base::invokeRestart
[11:02:07.728]             length <- base::length
[11:02:07.728]             list <- base::list
[11:02:07.728]             seq.int <- base::seq.int
[11:02:07.728]             signalCondition <- base::signalCondition
[11:02:07.728]             sys.calls <- base::sys.calls
[11:02:07.728]             `[[` <- base::`[[`
[11:02:07.728]             `+` <- base::`+`
[11:02:07.728]             `<<-` <- base::`<<-`
[11:02:07.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:07.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:07.728]                   3L)]
[11:02:07.728]             }
[11:02:07.728]             function(cond) {
[11:02:07.728]                 is_error <- inherits(cond, "error")
[11:02:07.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:07.728]                   NULL)
[11:02:07.728]                 if (is_error) {
[11:02:07.728]                   sessionInformation <- function() {
[11:02:07.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:07.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:07.728]                       search = base::search(), system = base::Sys.info())
[11:02:07.728]                   }
[11:02:07.728]                   ...future.conditions[[length(...future.conditions) + 
[11:02:07.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:07.728]                     cond$call), session = sessionInformation(), 
[11:02:07.728]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:07.728]                   signalCondition(cond)
[11:02:07.728]                 }
[11:02:07.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:07.728]                 "immediateCondition"))) {
[11:02:07.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:07.728]                   ...future.conditions[[length(...future.conditions) + 
[11:02:07.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:07.728]                   if (TRUE && !signal) {
[11:02:07.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.728]                     {
[11:02:07.728]                       inherits <- base::inherits
[11:02:07.728]                       invokeRestart <- base::invokeRestart
[11:02:07.728]                       is.null <- base::is.null
[11:02:07.728]                       muffled <- FALSE
[11:02:07.728]                       if (inherits(cond, "message")) {
[11:02:07.728]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:07.728]                         if (muffled) 
[11:02:07.728]                           invokeRestart("muffleMessage")
[11:02:07.728]                       }
[11:02:07.728]                       else if (inherits(cond, "warning")) {
[11:02:07.728]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:07.728]                         if (muffled) 
[11:02:07.728]                           invokeRestart("muffleWarning")
[11:02:07.728]                       }
[11:02:07.728]                       else if (inherits(cond, "condition")) {
[11:02:07.728]                         if (!is.null(pattern)) {
[11:02:07.728]                           computeRestarts <- base::computeRestarts
[11:02:07.728]                           grepl <- base::grepl
[11:02:07.728]                           restarts <- computeRestarts(cond)
[11:02:07.728]                           for (restart in restarts) {
[11:02:07.728]                             name <- restart$name
[11:02:07.728]                             if (is.null(name)) 
[11:02:07.728]                               next
[11:02:07.728]                             if (!grepl(pattern, name)) 
[11:02:07.728]                               next
[11:02:07.728]                             invokeRestart(restart)
[11:02:07.728]                             muffled <- TRUE
[11:02:07.728]                             break
[11:02:07.728]                           }
[11:02:07.728]                         }
[11:02:07.728]                       }
[11:02:07.728]                       invisible(muffled)
[11:02:07.728]                     }
[11:02:07.728]                     muffleCondition(cond, pattern = "^muffle")
[11:02:07.728]                   }
[11:02:07.728]                 }
[11:02:07.728]                 else {
[11:02:07.728]                   if (TRUE) {
[11:02:07.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.728]                     {
[11:02:07.728]                       inherits <- base::inherits
[11:02:07.728]                       invokeRestart <- base::invokeRestart
[11:02:07.728]                       is.null <- base::is.null
[11:02:07.728]                       muffled <- FALSE
[11:02:07.728]                       if (inherits(cond, "message")) {
[11:02:07.728]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:07.728]                         if (muffled) 
[11:02:07.728]                           invokeRestart("muffleMessage")
[11:02:07.728]                       }
[11:02:07.728]                       else if (inherits(cond, "warning")) {
[11:02:07.728]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:07.728]                         if (muffled) 
[11:02:07.728]                           invokeRestart("muffleWarning")
[11:02:07.728]                       }
[11:02:07.728]                       else if (inherits(cond, "condition")) {
[11:02:07.728]                         if (!is.null(pattern)) {
[11:02:07.728]                           computeRestarts <- base::computeRestarts
[11:02:07.728]                           grepl <- base::grepl
[11:02:07.728]                           restarts <- computeRestarts(cond)
[11:02:07.728]                           for (restart in restarts) {
[11:02:07.728]                             name <- restart$name
[11:02:07.728]                             if (is.null(name)) 
[11:02:07.728]                               next
[11:02:07.728]                             if (!grepl(pattern, name)) 
[11:02:07.728]                               next
[11:02:07.728]                             invokeRestart(restart)
[11:02:07.728]                             muffled <- TRUE
[11:02:07.728]                             break
[11:02:07.728]                           }
[11:02:07.728]                         }
[11:02:07.728]                       }
[11:02:07.728]                       invisible(muffled)
[11:02:07.728]                     }
[11:02:07.728]                     muffleCondition(cond, pattern = "^muffle")
[11:02:07.728]                   }
[11:02:07.728]                 }
[11:02:07.728]             }
[11:02:07.728]         }))
[11:02:07.728]     }, error = function(ex) {
[11:02:07.728]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:07.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:07.728]                 ...future.rng), started = ...future.startTime, 
[11:02:07.728]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:07.728]             version = "1.8"), class = "FutureResult")
[11:02:07.728]     }, finally = {
[11:02:07.728]         if (!identical(...future.workdir, getwd())) 
[11:02:07.728]             setwd(...future.workdir)
[11:02:07.728]         {
[11:02:07.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:07.728]                 ...future.oldOptions$nwarnings <- NULL
[11:02:07.728]             }
[11:02:07.728]             base::options(...future.oldOptions)
[11:02:07.728]             if (.Platform$OS.type == "windows") {
[11:02:07.728]                 old_names <- names(...future.oldEnvVars)
[11:02:07.728]                 envs <- base::Sys.getenv()
[11:02:07.728]                 names <- names(envs)
[11:02:07.728]                 common <- intersect(names, old_names)
[11:02:07.728]                 added <- setdiff(names, old_names)
[11:02:07.728]                 removed <- setdiff(old_names, names)
[11:02:07.728]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:07.728]                   envs[common]]
[11:02:07.728]                 NAMES <- toupper(changed)
[11:02:07.728]                 args <- list()
[11:02:07.728]                 for (kk in seq_along(NAMES)) {
[11:02:07.728]                   name <- changed[[kk]]
[11:02:07.728]                   NAME <- NAMES[[kk]]
[11:02:07.728]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.728]                     next
[11:02:07.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:07.728]                 }
[11:02:07.728]                 NAMES <- toupper(added)
[11:02:07.728]                 for (kk in seq_along(NAMES)) {
[11:02:07.728]                   name <- added[[kk]]
[11:02:07.728]                   NAME <- NAMES[[kk]]
[11:02:07.728]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.728]                     next
[11:02:07.728]                   args[[name]] <- ""
[11:02:07.728]                 }
[11:02:07.728]                 NAMES <- toupper(removed)
[11:02:07.728]                 for (kk in seq_along(NAMES)) {
[11:02:07.728]                   name <- removed[[kk]]
[11:02:07.728]                   NAME <- NAMES[[kk]]
[11:02:07.728]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.728]                     next
[11:02:07.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:07.728]                 }
[11:02:07.728]                 if (length(args) > 0) 
[11:02:07.728]                   base::do.call(base::Sys.setenv, args = args)
[11:02:07.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:07.728]             }
[11:02:07.728]             else {
[11:02:07.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:07.728]             }
[11:02:07.728]             {
[11:02:07.728]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:07.728]                   0L) {
[11:02:07.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:07.728]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:07.728]                   base::options(opts)
[11:02:07.728]                 }
[11:02:07.728]                 {
[11:02:07.728]                   {
[11:02:07.728]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:07.728]                     NULL
[11:02:07.728]                   }
[11:02:07.728]                   options(future.plan = NULL)
[11:02:07.728]                   if (is.na(NA_character_)) 
[11:02:07.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:07.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:07.728]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:07.728]                     .init = FALSE)
[11:02:07.728]                 }
[11:02:07.728]             }
[11:02:07.728]         }
[11:02:07.728]     })
[11:02:07.728]     if (TRUE) {
[11:02:07.728]         base::sink(type = "output", split = FALSE)
[11:02:07.728]         if (TRUE) {
[11:02:07.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:07.728]         }
[11:02:07.728]         else {
[11:02:07.728]             ...future.result["stdout"] <- base::list(NULL)
[11:02:07.728]         }
[11:02:07.728]         base::close(...future.stdout)
[11:02:07.728]         ...future.stdout <- NULL
[11:02:07.728]     }
[11:02:07.728]     ...future.result$conditions <- ...future.conditions
[11:02:07.728]     ...future.result$finished <- base::Sys.time()
[11:02:07.728]     ...future.result
[11:02:07.728] }
[11:02:07.778] MultisessionFuture started
[11:02:07.779] result() for ClusterFuture ...
[11:02:07.779] receiveMessageFromWorker() for ClusterFuture ...
[11:02:07.779] - Validating connection of MultisessionFuture
[11:02:07.809] - received message: FutureResult
[11:02:07.809] - Received FutureResult
[11:02:07.809] - Erased future from FutureRegistry
[11:02:07.810] result() for ClusterFuture ...
[11:02:07.810] - result already collected: FutureResult
[11:02:07.810] result() for ClusterFuture ... done
[11:02:07.810] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:07.810] result() for ClusterFuture ... done
[11:02:07.810] result() for ClusterFuture ...
[11:02:07.810] - result already collected: FutureResult
[11:02:07.810] result() for ClusterFuture ... done
[11:02:07.810] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:02:07.810] plan(): nbrOfWorkers() = 2
> f <- future(1L)
[11:02:07.811] getGlobalsAndPackages() ...
[11:02:07.811] Searching for globals...
[11:02:07.811] 
[11:02:07.811] Searching for globals ... DONE
[11:02:07.811] - globals: [0] <none>
[11:02:07.811] getGlobalsAndPackages() ... DONE
[11:02:07.812] run() for ‘Future’ ...
[11:02:07.812] - state: ‘created’
[11:02:07.812] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:07.826] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:07.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:07.826]   - Field: ‘node’
[11:02:07.827]   - Field: ‘label’
[11:02:07.827]   - Field: ‘local’
[11:02:07.827]   - Field: ‘owner’
[11:02:07.827]   - Field: ‘envir’
[11:02:07.827]   - Field: ‘workers’
[11:02:07.827]   - Field: ‘packages’
[11:02:07.827]   - Field: ‘gc’
[11:02:07.827]   - Field: ‘conditions’
[11:02:07.827]   - Field: ‘persistent’
[11:02:07.827]   - Field: ‘expr’
[11:02:07.827]   - Field: ‘uuid’
[11:02:07.828]   - Field: ‘seed’
[11:02:07.828]   - Field: ‘version’
[11:02:07.828]   - Field: ‘result’
[11:02:07.828]   - Field: ‘asynchronous’
[11:02:07.828]   - Field: ‘calls’
[11:02:07.828]   - Field: ‘globals’
[11:02:07.828]   - Field: ‘stdout’
[11:02:07.828]   - Field: ‘earlySignal’
[11:02:07.828]   - Field: ‘lazy’
[11:02:07.828]   - Field: ‘state’
[11:02:07.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:07.828] - Launch lazy future ...
[11:02:07.829] Packages needed by the future expression (n = 0): <none>
[11:02:07.829] Packages needed by future strategies (n = 0): <none>
[11:02:07.829] {
[11:02:07.829]     {
[11:02:07.829]         {
[11:02:07.829]             ...future.startTime <- base::Sys.time()
[11:02:07.829]             {
[11:02:07.829]                 {
[11:02:07.829]                   {
[11:02:07.829]                     {
[11:02:07.829]                       base::local({
[11:02:07.829]                         has_future <- base::requireNamespace("future", 
[11:02:07.829]                           quietly = TRUE)
[11:02:07.829]                         if (has_future) {
[11:02:07.829]                           ns <- base::getNamespace("future")
[11:02:07.829]                           version <- ns[[".package"]][["version"]]
[11:02:07.829]                           if (is.null(version)) 
[11:02:07.829]                             version <- utils::packageVersion("future")
[11:02:07.829]                         }
[11:02:07.829]                         else {
[11:02:07.829]                           version <- NULL
[11:02:07.829]                         }
[11:02:07.829]                         if (!has_future || version < "1.8.0") {
[11:02:07.829]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:07.829]                             "", base::R.version$version.string), 
[11:02:07.829]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:07.829]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:07.829]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:07.829]                               "release", "version")], collapse = " "), 
[11:02:07.829]                             hostname = base::Sys.info()[["nodename"]])
[11:02:07.829]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:07.829]                             info)
[11:02:07.829]                           info <- base::paste(info, collapse = "; ")
[11:02:07.829]                           if (!has_future) {
[11:02:07.829]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:07.829]                               info)
[11:02:07.829]                           }
[11:02:07.829]                           else {
[11:02:07.829]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:07.829]                               info, version)
[11:02:07.829]                           }
[11:02:07.829]                           base::stop(msg)
[11:02:07.829]                         }
[11:02:07.829]                       })
[11:02:07.829]                     }
[11:02:07.829]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:07.829]                     base::options(mc.cores = 1L)
[11:02:07.829]                   }
[11:02:07.829]                   ...future.strategy.old <- future::plan("list")
[11:02:07.829]                   options(future.plan = NULL)
[11:02:07.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:07.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:07.829]                 }
[11:02:07.829]                 ...future.workdir <- getwd()
[11:02:07.829]             }
[11:02:07.829]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:07.829]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:07.829]         }
[11:02:07.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:07.829]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:07.829]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:07.829]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:07.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:07.829]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:07.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:07.829]             base::names(...future.oldOptions))
[11:02:07.829]     }
[11:02:07.829]     if (FALSE) {
[11:02:07.829]     }
[11:02:07.829]     else {
[11:02:07.829]         if (TRUE) {
[11:02:07.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:07.829]                 open = "w")
[11:02:07.829]         }
[11:02:07.829]         else {
[11:02:07.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:07.829]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:07.829]         }
[11:02:07.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:07.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:07.829]             base::sink(type = "output", split = FALSE)
[11:02:07.829]             base::close(...future.stdout)
[11:02:07.829]         }, add = TRUE)
[11:02:07.829]     }
[11:02:07.829]     ...future.frame <- base::sys.nframe()
[11:02:07.829]     ...future.conditions <- base::list()
[11:02:07.829]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:07.829]     if (FALSE) {
[11:02:07.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:07.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:07.829]     }
[11:02:07.829]     ...future.result <- base::tryCatch({
[11:02:07.829]         base::withCallingHandlers({
[11:02:07.829]             ...future.value <- base::withVisible(base::local({
[11:02:07.829]                 ...future.makeSendCondition <- base::local({
[11:02:07.829]                   sendCondition <- NULL
[11:02:07.829]                   function(frame = 1L) {
[11:02:07.829]                     if (is.function(sendCondition)) 
[11:02:07.829]                       return(sendCondition)
[11:02:07.829]                     ns <- getNamespace("parallel")
[11:02:07.829]                     if (exists("sendData", mode = "function", 
[11:02:07.829]                       envir = ns)) {
[11:02:07.829]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:07.829]                         envir = ns)
[11:02:07.829]                       envir <- sys.frame(frame)
[11:02:07.829]                       master <- NULL
[11:02:07.829]                       while (!identical(envir, .GlobalEnv) && 
[11:02:07.829]                         !identical(envir, emptyenv())) {
[11:02:07.829]                         if (exists("master", mode = "list", envir = envir, 
[11:02:07.829]                           inherits = FALSE)) {
[11:02:07.829]                           master <- get("master", mode = "list", 
[11:02:07.829]                             envir = envir, inherits = FALSE)
[11:02:07.829]                           if (inherits(master, c("SOCKnode", 
[11:02:07.829]                             "SOCK0node"))) {
[11:02:07.829]                             sendCondition <<- function(cond) {
[11:02:07.829]                               data <- list(type = "VALUE", value = cond, 
[11:02:07.829]                                 success = TRUE)
[11:02:07.829]                               parallel_sendData(master, data)
[11:02:07.829]                             }
[11:02:07.829]                             return(sendCondition)
[11:02:07.829]                           }
[11:02:07.829]                         }
[11:02:07.829]                         frame <- frame + 1L
[11:02:07.829]                         envir <- sys.frame(frame)
[11:02:07.829]                       }
[11:02:07.829]                     }
[11:02:07.829]                     sendCondition <<- function(cond) NULL
[11:02:07.829]                   }
[11:02:07.829]                 })
[11:02:07.829]                 withCallingHandlers({
[11:02:07.829]                   1L
[11:02:07.829]                 }, immediateCondition = function(cond) {
[11:02:07.829]                   sendCondition <- ...future.makeSendCondition()
[11:02:07.829]                   sendCondition(cond)
[11:02:07.829]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.829]                   {
[11:02:07.829]                     inherits <- base::inherits
[11:02:07.829]                     invokeRestart <- base::invokeRestart
[11:02:07.829]                     is.null <- base::is.null
[11:02:07.829]                     muffled <- FALSE
[11:02:07.829]                     if (inherits(cond, "message")) {
[11:02:07.829]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:07.829]                       if (muffled) 
[11:02:07.829]                         invokeRestart("muffleMessage")
[11:02:07.829]                     }
[11:02:07.829]                     else if (inherits(cond, "warning")) {
[11:02:07.829]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:07.829]                       if (muffled) 
[11:02:07.829]                         invokeRestart("muffleWarning")
[11:02:07.829]                     }
[11:02:07.829]                     else if (inherits(cond, "condition")) {
[11:02:07.829]                       if (!is.null(pattern)) {
[11:02:07.829]                         computeRestarts <- base::computeRestarts
[11:02:07.829]                         grepl <- base::grepl
[11:02:07.829]                         restarts <- computeRestarts(cond)
[11:02:07.829]                         for (restart in restarts) {
[11:02:07.829]                           name <- restart$name
[11:02:07.829]                           if (is.null(name)) 
[11:02:07.829]                             next
[11:02:07.829]                           if (!grepl(pattern, name)) 
[11:02:07.829]                             next
[11:02:07.829]                           invokeRestart(restart)
[11:02:07.829]                           muffled <- TRUE
[11:02:07.829]                           break
[11:02:07.829]                         }
[11:02:07.829]                       }
[11:02:07.829]                     }
[11:02:07.829]                     invisible(muffled)
[11:02:07.829]                   }
[11:02:07.829]                   muffleCondition(cond)
[11:02:07.829]                 })
[11:02:07.829]             }))
[11:02:07.829]             future::FutureResult(value = ...future.value$value, 
[11:02:07.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:07.829]                   ...future.rng), globalenv = if (FALSE) 
[11:02:07.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:07.829]                     ...future.globalenv.names))
[11:02:07.829]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:07.829]         }, condition = base::local({
[11:02:07.829]             c <- base::c
[11:02:07.829]             inherits <- base::inherits
[11:02:07.829]             invokeRestart <- base::invokeRestart
[11:02:07.829]             length <- base::length
[11:02:07.829]             list <- base::list
[11:02:07.829]             seq.int <- base::seq.int
[11:02:07.829]             signalCondition <- base::signalCondition
[11:02:07.829]             sys.calls <- base::sys.calls
[11:02:07.829]             `[[` <- base::`[[`
[11:02:07.829]             `+` <- base::`+`
[11:02:07.829]             `<<-` <- base::`<<-`
[11:02:07.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:07.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:07.829]                   3L)]
[11:02:07.829]             }
[11:02:07.829]             function(cond) {
[11:02:07.829]                 is_error <- inherits(cond, "error")
[11:02:07.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:07.829]                   NULL)
[11:02:07.829]                 if (is_error) {
[11:02:07.829]                   sessionInformation <- function() {
[11:02:07.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:07.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:07.829]                       search = base::search(), system = base::Sys.info())
[11:02:07.829]                   }
[11:02:07.829]                   ...future.conditions[[length(...future.conditions) + 
[11:02:07.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:07.829]                     cond$call), session = sessionInformation(), 
[11:02:07.829]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:07.829]                   signalCondition(cond)
[11:02:07.829]                 }
[11:02:07.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:07.829]                 "immediateCondition"))) {
[11:02:07.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:07.829]                   ...future.conditions[[length(...future.conditions) + 
[11:02:07.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:07.829]                   if (TRUE && !signal) {
[11:02:07.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.829]                     {
[11:02:07.829]                       inherits <- base::inherits
[11:02:07.829]                       invokeRestart <- base::invokeRestart
[11:02:07.829]                       is.null <- base::is.null
[11:02:07.829]                       muffled <- FALSE
[11:02:07.829]                       if (inherits(cond, "message")) {
[11:02:07.829]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:07.829]                         if (muffled) 
[11:02:07.829]                           invokeRestart("muffleMessage")
[11:02:07.829]                       }
[11:02:07.829]                       else if (inherits(cond, "warning")) {
[11:02:07.829]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:07.829]                         if (muffled) 
[11:02:07.829]                           invokeRestart("muffleWarning")
[11:02:07.829]                       }
[11:02:07.829]                       else if (inherits(cond, "condition")) {
[11:02:07.829]                         if (!is.null(pattern)) {
[11:02:07.829]                           computeRestarts <- base::computeRestarts
[11:02:07.829]                           grepl <- base::grepl
[11:02:07.829]                           restarts <- computeRestarts(cond)
[11:02:07.829]                           for (restart in restarts) {
[11:02:07.829]                             name <- restart$name
[11:02:07.829]                             if (is.null(name)) 
[11:02:07.829]                               next
[11:02:07.829]                             if (!grepl(pattern, name)) 
[11:02:07.829]                               next
[11:02:07.829]                             invokeRestart(restart)
[11:02:07.829]                             muffled <- TRUE
[11:02:07.829]                             break
[11:02:07.829]                           }
[11:02:07.829]                         }
[11:02:07.829]                       }
[11:02:07.829]                       invisible(muffled)
[11:02:07.829]                     }
[11:02:07.829]                     muffleCondition(cond, pattern = "^muffle")
[11:02:07.829]                   }
[11:02:07.829]                 }
[11:02:07.829]                 else {
[11:02:07.829]                   if (TRUE) {
[11:02:07.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:07.829]                     {
[11:02:07.829]                       inherits <- base::inherits
[11:02:07.829]                       invokeRestart <- base::invokeRestart
[11:02:07.829]                       is.null <- base::is.null
[11:02:07.829]                       muffled <- FALSE
[11:02:07.829]                       if (inherits(cond, "message")) {
[11:02:07.829]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:07.829]                         if (muffled) 
[11:02:07.829]                           invokeRestart("muffleMessage")
[11:02:07.829]                       }
[11:02:07.829]                       else if (inherits(cond, "warning")) {
[11:02:07.829]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:07.829]                         if (muffled) 
[11:02:07.829]                           invokeRestart("muffleWarning")
[11:02:07.829]                       }
[11:02:07.829]                       else if (inherits(cond, "condition")) {
[11:02:07.829]                         if (!is.null(pattern)) {
[11:02:07.829]                           computeRestarts <- base::computeRestarts
[11:02:07.829]                           grepl <- base::grepl
[11:02:07.829]                           restarts <- computeRestarts(cond)
[11:02:07.829]                           for (restart in restarts) {
[11:02:07.829]                             name <- restart$name
[11:02:07.829]                             if (is.null(name)) 
[11:02:07.829]                               next
[11:02:07.829]                             if (!grepl(pattern, name)) 
[11:02:07.829]                               next
[11:02:07.829]                             invokeRestart(restart)
[11:02:07.829]                             muffled <- TRUE
[11:02:07.829]                             break
[11:02:07.829]                           }
[11:02:07.829]                         }
[11:02:07.829]                       }
[11:02:07.829]                       invisible(muffled)
[11:02:07.829]                     }
[11:02:07.829]                     muffleCondition(cond, pattern = "^muffle")
[11:02:07.829]                   }
[11:02:07.829]                 }
[11:02:07.829]             }
[11:02:07.829]         }))
[11:02:07.829]     }, error = function(ex) {
[11:02:07.829]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:07.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:07.829]                 ...future.rng), started = ...future.startTime, 
[11:02:07.829]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:07.829]             version = "1.8"), class = "FutureResult")
[11:02:07.829]     }, finally = {
[11:02:07.829]         if (!identical(...future.workdir, getwd())) 
[11:02:07.829]             setwd(...future.workdir)
[11:02:07.829]         {
[11:02:07.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:07.829]                 ...future.oldOptions$nwarnings <- NULL
[11:02:07.829]             }
[11:02:07.829]             base::options(...future.oldOptions)
[11:02:07.829]             if (.Platform$OS.type == "windows") {
[11:02:07.829]                 old_names <- names(...future.oldEnvVars)
[11:02:07.829]                 envs <- base::Sys.getenv()
[11:02:07.829]                 names <- names(envs)
[11:02:07.829]                 common <- intersect(names, old_names)
[11:02:07.829]                 added <- setdiff(names, old_names)
[11:02:07.829]                 removed <- setdiff(old_names, names)
[11:02:07.829]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:07.829]                   envs[common]]
[11:02:07.829]                 NAMES <- toupper(changed)
[11:02:07.829]                 args <- list()
[11:02:07.829]                 for (kk in seq_along(NAMES)) {
[11:02:07.829]                   name <- changed[[kk]]
[11:02:07.829]                   NAME <- NAMES[[kk]]
[11:02:07.829]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.829]                     next
[11:02:07.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:07.829]                 }
[11:02:07.829]                 NAMES <- toupper(added)
[11:02:07.829]                 for (kk in seq_along(NAMES)) {
[11:02:07.829]                   name <- added[[kk]]
[11:02:07.829]                   NAME <- NAMES[[kk]]
[11:02:07.829]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.829]                     next
[11:02:07.829]                   args[[name]] <- ""
[11:02:07.829]                 }
[11:02:07.829]                 NAMES <- toupper(removed)
[11:02:07.829]                 for (kk in seq_along(NAMES)) {
[11:02:07.829]                   name <- removed[[kk]]
[11:02:07.829]                   NAME <- NAMES[[kk]]
[11:02:07.829]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:07.829]                     next
[11:02:07.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:07.829]                 }
[11:02:07.829]                 if (length(args) > 0) 
[11:02:07.829]                   base::do.call(base::Sys.setenv, args = args)
[11:02:07.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:07.829]             }
[11:02:07.829]             else {
[11:02:07.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:07.829]             }
[11:02:07.829]             {
[11:02:07.829]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:07.829]                   0L) {
[11:02:07.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:07.829]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:07.829]                   base::options(opts)
[11:02:07.829]                 }
[11:02:07.829]                 {
[11:02:07.829]                   {
[11:02:07.829]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:07.829]                     NULL
[11:02:07.829]                   }
[11:02:07.829]                   options(future.plan = NULL)
[11:02:07.829]                   if (is.na(NA_character_)) 
[11:02:07.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:07.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:07.829]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:07.829]                     .init = FALSE)
[11:02:07.829]                 }
[11:02:07.829]             }
[11:02:07.829]         }
[11:02:07.829]     })
[11:02:07.829]     if (TRUE) {
[11:02:07.829]         base::sink(type = "output", split = FALSE)
[11:02:07.829]         if (TRUE) {
[11:02:07.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:07.829]         }
[11:02:07.829]         else {
[11:02:07.829]             ...future.result["stdout"] <- base::list(NULL)
[11:02:07.829]         }
[11:02:07.829]         base::close(...future.stdout)
[11:02:07.829]         ...future.stdout <- NULL
[11:02:07.829]     }
[11:02:07.829]     ...future.result$conditions <- ...future.conditions
[11:02:07.829]     ...future.result$finished <- base::Sys.time()
[11:02:07.829]     ...future.result
[11:02:07.829] }
[11:02:07.832] MultisessionFuture started
[11:02:07.832] - Launch lazy future ... done
[11:02:07.832] run() for ‘MultisessionFuture’ ... done
> 
> ## Collect value, to speep up the stopping of the parallel workers,
> ## and to make sure we're not leaving any stray processes behind.
> v <- value(f)
[11:02:07.832] result() for ClusterFuture ...
[11:02:07.833] receiveMessageFromWorker() for ClusterFuture ...
[11:02:07.833] - Validating connection of MultisessionFuture
[11:02:07.874] - received message: FutureResult
[11:02:07.874] - Received FutureResult
[11:02:07.874] - Erased future from FutureRegistry
[11:02:07.874] result() for ClusterFuture ...
[11:02:07.874] - result already collected: FutureResult
[11:02:07.875] result() for ClusterFuture ... done
[11:02:07.875] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:07.875] result() for ClusterFuture ... done
[11:02:07.875] result() for ClusterFuture ...
[11:02:07.875] - result already collected: FutureResult
[11:02:07.875] result() for ClusterFuture ... done
> 
> cl <- ClusterRegistry("get")
> stopifnot(inherits(cl, "cluster"), length(cl) >= 1L)
> 
> plan(sequential)
[11:02:07.875] plan(): Setting new future strategy stack:
[11:02:07.875] List of future strategies:
[11:02:07.875] 1. sequential:
[11:02:07.875]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:07.875]    - tweaked: FALSE
[11:02:07.875]    - call: plan(sequential)
[11:02:07.876] plan(): nbrOfWorkers() = 1
> cl <- ClusterRegistry("get")
> stopifnot(is.null(cl), length(cl) == 0L)
>   
> message("*** multisession(...) - stopping with plan() change ... DONE")
*** multisession(...) - stopping with plan() change ... DONE
> 
> message("*** multisession() ... DONE")
*** multisession() ... DONE
> 
> source("incl/end.R")
[11:02:07.877] plan(): Setting new future strategy stack:
[11:02:07.877] List of future strategies:
[11:02:07.877] 1. FutureStrategy:
[11:02:07.877]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:07.877]    - tweaked: FALSE
[11:02:07.877]    - call: future::plan(oplan)
[11:02:07.878] plan(): nbrOfWorkers() = 1
> 
