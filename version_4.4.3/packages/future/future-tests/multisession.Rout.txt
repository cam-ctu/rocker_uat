
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:28:27.933] plan(): Setting new future strategy stack:
[08:28:27.934] List of future strategies:
[08:28:27.934] 1. sequential:
[08:28:27.934]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.934]    - tweaked: FALSE
[08:28:27.934]    - call: future::plan("sequential")
[08:28:27.948] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** multisession() ...")
*** multisession() ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   ## No global variables
+   f <- multisession({
+     42L
+   })
+   print(f)
+   stopifnot(inherits(f, "ClusterFuture") || (inherits(f, "SequentialFuture") && f$lazy))
+ 
+   print(resolved(f))
+   y <- value(f)
+   print(y)
+   stopifnot(y == 42L)
+ 
+ 
+   ## A global variable
+   a <- 0
+   f <- multisession({
+     b <- 3
+     c <- 2
+     a * b * c
+   }, globals = TRUE)
+   print(f)
+ 
+ 
+   ## A multisession future is evaluated in a separate
+   ## R session process.  Changing the value of a global
+   ## variable should not affect the result of the
+   ## future.
+   a <- 7  ## Make sure globals are frozen
+   v <- value(f)
+   print(v)
+   stopifnot(v == 0)
+ 
+ 
+   message("*** multisession() with globals and blocking")
+   x <- listenv()
+   for (ii in 2:1) {
+     message(sprintf(" - Creating multisession future #%d ...", ii))
+     x[[ii]] <- multisession({ ii }, globals = TRUE)
+   }
+   message(sprintf(" - Resolving %d multisession futures", length(x)))
+   v <- sapply(x, FUN = value)
+   stopifnot(all(v == 1:2))
+ 
+ 
+   message("*** multisession() - workers inherit .libPaths()")
+ 
+   libs <- value(future(.libPaths()))
+   str(list(
+     main = .libPaths(),
+     workers = libs
+   ))
+   stopifnot(identical(libs, .libPaths()))
+ 
+   message("*** multisession() and errors")
+   f <- multisession({
+     stop("Whoops!")
+     1
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "simpleError"))
+ 
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Error is repeated
+   res <- try(value(f), silent = TRUE)
+   print(res)
+   stopifnot(inherits(res, "try-error"))
+ 
+   ## Custom error class
+   f <- multisession({
+     stop(structure(list(message = "boom"),
+                    class = c("MyError", "error", "condition")))
+   })
+   print(f)
+   v <- value(f, signal = FALSE)
+   print(v)
+   stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+ 
+   ## Make sure error is signaled
+   res <- tryCatch(value(f), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   ## Issue #200: Custom condition class attributes are lost
+   ## https://github.com/HenrikBengtsson/Wishlist-for-R/issues/57
+   ## stopifnot(inherits(res, "MyError"))    
+ 
+   ## Make sure to stop these cluster processes to avoid triggering
+   ## checking for detritus in the temp directory ... NOTE
+   ClusterRegistry(action = "stop")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
[08:28:28.004] getGlobalsAndPackages() ...
[08:28:28.004] Searching for globals...
[08:28:28.007] - globals found: [1] ‘{’
[08:28:28.007] Searching for globals ... DONE
[08:28:28.007] Resolving globals: FALSE
[08:28:28.008] 
[08:28:28.008] 
[08:28:28.008] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 2d485820-dce0-a5ac-1757-5b458766347d
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:28.009] Packages needed by the future expression (n = 0): <none>
[08:28:28.009] Packages needed by future strategies (n = 0): <none>
[08:28:28.010] {
[08:28:28.010]     {
[08:28:28.010]         {
[08:28:28.010]             ...future.startTime <- base::Sys.time()
[08:28:28.010]             {
[08:28:28.010]                 {
[08:28:28.010]                   {
[08:28:28.010]                     base::local({
[08:28:28.010]                       has_future <- base::requireNamespace("future", 
[08:28:28.010]                         quietly = TRUE)
[08:28:28.010]                       if (has_future) {
[08:28:28.010]                         ns <- base::getNamespace("future")
[08:28:28.010]                         version <- ns[[".package"]][["version"]]
[08:28:28.010]                         if (is.null(version)) 
[08:28:28.010]                           version <- utils::packageVersion("future")
[08:28:28.010]                       }
[08:28:28.010]                       else {
[08:28:28.010]                         version <- NULL
[08:28:28.010]                       }
[08:28:28.010]                       if (!has_future || version < "1.8.0") {
[08:28:28.010]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.010]                           "", base::R.version$version.string), 
[08:28:28.010]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:28.010]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.010]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.010]                             "release", "version")], collapse = " "), 
[08:28:28.010]                           hostname = base::Sys.info()[["nodename"]])
[08:28:28.010]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.010]                           info)
[08:28:28.010]                         info <- base::paste(info, collapse = "; ")
[08:28:28.010]                         if (!has_future) {
[08:28:28.010]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.010]                             info)
[08:28:28.010]                         }
[08:28:28.010]                         else {
[08:28:28.010]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.010]                             info, version)
[08:28:28.010]                         }
[08:28:28.010]                         base::stop(msg)
[08:28:28.010]                       }
[08:28:28.010]                     })
[08:28:28.010]                   }
[08:28:28.010]                   ...future.strategy.old <- future::plan("list")
[08:28:28.010]                   options(future.plan = NULL)
[08:28:28.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.010]                 }
[08:28:28.010]                 ...future.workdir <- getwd()
[08:28:28.010]             }
[08:28:28.010]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.010]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.010]         }
[08:28:28.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.010]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.010]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.010]             base::names(...future.oldOptions))
[08:28:28.010]     }
[08:28:28.010]     if (FALSE) {
[08:28:28.010]     }
[08:28:28.010]     else {
[08:28:28.010]         if (TRUE) {
[08:28:28.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.010]                 open = "w")
[08:28:28.010]         }
[08:28:28.010]         else {
[08:28:28.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.010]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.010]         }
[08:28:28.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.010]             base::sink(type = "output", split = FALSE)
[08:28:28.010]             base::close(...future.stdout)
[08:28:28.010]         }, add = TRUE)
[08:28:28.010]     }
[08:28:28.010]     ...future.frame <- base::sys.nframe()
[08:28:28.010]     ...future.conditions <- base::list()
[08:28:28.010]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.010]     if (FALSE) {
[08:28:28.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.010]     }
[08:28:28.010]     ...future.result <- base::tryCatch({
[08:28:28.010]         base::withCallingHandlers({
[08:28:28.010]             ...future.value <- base::withVisible(base::local({
[08:28:28.010]                 42L
[08:28:28.010]             }))
[08:28:28.010]             future::FutureResult(value = ...future.value$value, 
[08:28:28.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.010]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.010]                     ...future.globalenv.names))
[08:28:28.010]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.010]         }, condition = base::local({
[08:28:28.010]             c <- base::c
[08:28:28.010]             inherits <- base::inherits
[08:28:28.010]             invokeRestart <- base::invokeRestart
[08:28:28.010]             length <- base::length
[08:28:28.010]             list <- base::list
[08:28:28.010]             seq.int <- base::seq.int
[08:28:28.010]             signalCondition <- base::signalCondition
[08:28:28.010]             sys.calls <- base::sys.calls
[08:28:28.010]             `[[` <- base::`[[`
[08:28:28.010]             `+` <- base::`+`
[08:28:28.010]             `<<-` <- base::`<<-`
[08:28:28.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.010]                   3L)]
[08:28:28.010]             }
[08:28:28.010]             function(cond) {
[08:28:28.010]                 is_error <- inherits(cond, "error")
[08:28:28.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.010]                   NULL)
[08:28:28.010]                 if (is_error) {
[08:28:28.010]                   sessionInformation <- function() {
[08:28:28.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.010]                       search = base::search(), system = base::Sys.info())
[08:28:28.010]                   }
[08:28:28.010]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.010]                     cond$call), session = sessionInformation(), 
[08:28:28.010]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.010]                   signalCondition(cond)
[08:28:28.010]                 }
[08:28:28.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.010]                 "immediateCondition"))) {
[08:28:28.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.010]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.010]                   if (TRUE && !signal) {
[08:28:28.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.010]                     {
[08:28:28.010]                       inherits <- base::inherits
[08:28:28.010]                       invokeRestart <- base::invokeRestart
[08:28:28.010]                       is.null <- base::is.null
[08:28:28.010]                       muffled <- FALSE
[08:28:28.010]                       if (inherits(cond, "message")) {
[08:28:28.010]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.010]                         if (muffled) 
[08:28:28.010]                           invokeRestart("muffleMessage")
[08:28:28.010]                       }
[08:28:28.010]                       else if (inherits(cond, "warning")) {
[08:28:28.010]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.010]                         if (muffled) 
[08:28:28.010]                           invokeRestart("muffleWarning")
[08:28:28.010]                       }
[08:28:28.010]                       else if (inherits(cond, "condition")) {
[08:28:28.010]                         if (!is.null(pattern)) {
[08:28:28.010]                           computeRestarts <- base::computeRestarts
[08:28:28.010]                           grepl <- base::grepl
[08:28:28.010]                           restarts <- computeRestarts(cond)
[08:28:28.010]                           for (restart in restarts) {
[08:28:28.010]                             name <- restart$name
[08:28:28.010]                             if (is.null(name)) 
[08:28:28.010]                               next
[08:28:28.010]                             if (!grepl(pattern, name)) 
[08:28:28.010]                               next
[08:28:28.010]                             invokeRestart(restart)
[08:28:28.010]                             muffled <- TRUE
[08:28:28.010]                             break
[08:28:28.010]                           }
[08:28:28.010]                         }
[08:28:28.010]                       }
[08:28:28.010]                       invisible(muffled)
[08:28:28.010]                     }
[08:28:28.010]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.010]                   }
[08:28:28.010]                 }
[08:28:28.010]                 else {
[08:28:28.010]                   if (TRUE) {
[08:28:28.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.010]                     {
[08:28:28.010]                       inherits <- base::inherits
[08:28:28.010]                       invokeRestart <- base::invokeRestart
[08:28:28.010]                       is.null <- base::is.null
[08:28:28.010]                       muffled <- FALSE
[08:28:28.010]                       if (inherits(cond, "message")) {
[08:28:28.010]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.010]                         if (muffled) 
[08:28:28.010]                           invokeRestart("muffleMessage")
[08:28:28.010]                       }
[08:28:28.010]                       else if (inherits(cond, "warning")) {
[08:28:28.010]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.010]                         if (muffled) 
[08:28:28.010]                           invokeRestart("muffleWarning")
[08:28:28.010]                       }
[08:28:28.010]                       else if (inherits(cond, "condition")) {
[08:28:28.010]                         if (!is.null(pattern)) {
[08:28:28.010]                           computeRestarts <- base::computeRestarts
[08:28:28.010]                           grepl <- base::grepl
[08:28:28.010]                           restarts <- computeRestarts(cond)
[08:28:28.010]                           for (restart in restarts) {
[08:28:28.010]                             name <- restart$name
[08:28:28.010]                             if (is.null(name)) 
[08:28:28.010]                               next
[08:28:28.010]                             if (!grepl(pattern, name)) 
[08:28:28.010]                               next
[08:28:28.010]                             invokeRestart(restart)
[08:28:28.010]                             muffled <- TRUE
[08:28:28.010]                             break
[08:28:28.010]                           }
[08:28:28.010]                         }
[08:28:28.010]                       }
[08:28:28.010]                       invisible(muffled)
[08:28:28.010]                     }
[08:28:28.010]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.010]                   }
[08:28:28.010]                 }
[08:28:28.010]             }
[08:28:28.010]         }))
[08:28:28.010]     }, error = function(ex) {
[08:28:28.010]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.010]                 ...future.rng), started = ...future.startTime, 
[08:28:28.010]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.010]             version = "1.8"), class = "FutureResult")
[08:28:28.010]     }, finally = {
[08:28:28.010]         if (!identical(...future.workdir, getwd())) 
[08:28:28.010]             setwd(...future.workdir)
[08:28:28.010]         {
[08:28:28.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.010]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.010]             }
[08:28:28.010]             base::options(...future.oldOptions)
[08:28:28.010]             if (.Platform$OS.type == "windows") {
[08:28:28.010]                 old_names <- names(...future.oldEnvVars)
[08:28:28.010]                 envs <- base::Sys.getenv()
[08:28:28.010]                 names <- names(envs)
[08:28:28.010]                 common <- intersect(names, old_names)
[08:28:28.010]                 added <- setdiff(names, old_names)
[08:28:28.010]                 removed <- setdiff(old_names, names)
[08:28:28.010]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.010]                   envs[common]]
[08:28:28.010]                 NAMES <- toupper(changed)
[08:28:28.010]                 args <- list()
[08:28:28.010]                 for (kk in seq_along(NAMES)) {
[08:28:28.010]                   name <- changed[[kk]]
[08:28:28.010]                   NAME <- NAMES[[kk]]
[08:28:28.010]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.010]                     next
[08:28:28.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.010]                 }
[08:28:28.010]                 NAMES <- toupper(added)
[08:28:28.010]                 for (kk in seq_along(NAMES)) {
[08:28:28.010]                   name <- added[[kk]]
[08:28:28.010]                   NAME <- NAMES[[kk]]
[08:28:28.010]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.010]                     next
[08:28:28.010]                   args[[name]] <- ""
[08:28:28.010]                 }
[08:28:28.010]                 NAMES <- toupper(removed)
[08:28:28.010]                 for (kk in seq_along(NAMES)) {
[08:28:28.010]                   name <- removed[[kk]]
[08:28:28.010]                   NAME <- NAMES[[kk]]
[08:28:28.010]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.010]                     next
[08:28:28.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.010]                 }
[08:28:28.010]                 if (length(args) > 0) 
[08:28:28.010]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.010]             }
[08:28:28.010]             else {
[08:28:28.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.010]             }
[08:28:28.010]             {
[08:28:28.010]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.010]                   0L) {
[08:28:28.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.010]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.010]                   base::options(opts)
[08:28:28.010]                 }
[08:28:28.010]                 {
[08:28:28.010]                   {
[08:28:28.010]                     NULL
[08:28:28.010]                     RNGkind("Mersenne-Twister")
[08:28:28.010]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:28.010]                       inherits = FALSE)
[08:28:28.010]                   }
[08:28:28.010]                   options(future.plan = NULL)
[08:28:28.010]                   if (is.na(NA_character_)) 
[08:28:28.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.010]                     .init = FALSE)
[08:28:28.010]                 }
[08:28:28.010]             }
[08:28:28.010]         }
[08:28:28.010]     })
[08:28:28.010]     if (TRUE) {
[08:28:28.010]         base::sink(type = "output", split = FALSE)
[08:28:28.010]         if (TRUE) {
[08:28:28.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.010]         }
[08:28:28.010]         else {
[08:28:28.010]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.010]         }
[08:28:28.010]         base::close(...future.stdout)
[08:28:28.010]         ...future.stdout <- NULL
[08:28:28.010]     }
[08:28:28.010]     ...future.result$conditions <- ...future.conditions
[08:28:28.010]     ...future.result$finished <- base::Sys.time()
[08:28:28.010]     ...future.result
[08:28:28.010] }
[08:28:28.012] plan(): Setting new future strategy stack:
[08:28:28.012] List of future strategies:
[08:28:28.012] 1. sequential:
[08:28:28.012]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.012]    - tweaked: FALSE
[08:28:28.012]    - call: NULL
[08:28:28.013] plan(): nbrOfWorkers() = 1
[08:28:28.014] plan(): Setting new future strategy stack:
[08:28:28.014] List of future strategies:
[08:28:28.014] 1. sequential:
[08:28:28.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.014]    - tweaked: FALSE
[08:28:28.014]    - call: future::plan("sequential")
[08:28:28.014] plan(): nbrOfWorkers() = 1
[08:28:28.015] SequentialFuture started (and completed)
[08:28:28.015] resolved() for ‘SequentialFuture’ ...
[08:28:28.015] - state: ‘finished’
[08:28:28.015] - run: TRUE
[08:28:28.015] - result: ‘FutureResult’
[08:28:28.015] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
[08:28:28.017] getGlobalsAndPackages() ...
[08:28:28.017] Searching for globals...
[08:28:28.024] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[08:28:28.024] Searching for globals ... DONE
[08:28:28.024] Resolving globals: FALSE
[08:28:28.025] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:28.025] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:28:28.025] - globals: [1] ‘a’
[08:28:28.025] 
[08:28:28.025] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 39 bytes (numeric ‘a’ of 39 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 2d485820-dce0-a5ac-1757-5b458766347d
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:28.026] Packages needed by the future expression (n = 0): <none>
[08:28:28.026] Packages needed by future strategies (n = 0): <none>
[08:28:28.027] {
[08:28:28.027]     {
[08:28:28.027]         {
[08:28:28.027]             ...future.startTime <- base::Sys.time()
[08:28:28.027]             {
[08:28:28.027]                 {
[08:28:28.027]                   {
[08:28:28.027]                     base::local({
[08:28:28.027]                       has_future <- base::requireNamespace("future", 
[08:28:28.027]                         quietly = TRUE)
[08:28:28.027]                       if (has_future) {
[08:28:28.027]                         ns <- base::getNamespace("future")
[08:28:28.027]                         version <- ns[[".package"]][["version"]]
[08:28:28.027]                         if (is.null(version)) 
[08:28:28.027]                           version <- utils::packageVersion("future")
[08:28:28.027]                       }
[08:28:28.027]                       else {
[08:28:28.027]                         version <- NULL
[08:28:28.027]                       }
[08:28:28.027]                       if (!has_future || version < "1.8.0") {
[08:28:28.027]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.027]                           "", base::R.version$version.string), 
[08:28:28.027]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:28.027]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.027]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.027]                             "release", "version")], collapse = " "), 
[08:28:28.027]                           hostname = base::Sys.info()[["nodename"]])
[08:28:28.027]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.027]                           info)
[08:28:28.027]                         info <- base::paste(info, collapse = "; ")
[08:28:28.027]                         if (!has_future) {
[08:28:28.027]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.027]                             info)
[08:28:28.027]                         }
[08:28:28.027]                         else {
[08:28:28.027]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.027]                             info, version)
[08:28:28.027]                         }
[08:28:28.027]                         base::stop(msg)
[08:28:28.027]                       }
[08:28:28.027]                     })
[08:28:28.027]                   }
[08:28:28.027]                   ...future.strategy.old <- future::plan("list")
[08:28:28.027]                   options(future.plan = NULL)
[08:28:28.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.027]                 }
[08:28:28.027]                 ...future.workdir <- getwd()
[08:28:28.027]             }
[08:28:28.027]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.027]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.027]         }
[08:28:28.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.027]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.027]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.027]             base::names(...future.oldOptions))
[08:28:28.027]     }
[08:28:28.027]     if (FALSE) {
[08:28:28.027]     }
[08:28:28.027]     else {
[08:28:28.027]         if (TRUE) {
[08:28:28.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.027]                 open = "w")
[08:28:28.027]         }
[08:28:28.027]         else {
[08:28:28.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.027]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.027]         }
[08:28:28.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.027]             base::sink(type = "output", split = FALSE)
[08:28:28.027]             base::close(...future.stdout)
[08:28:28.027]         }, add = TRUE)
[08:28:28.027]     }
[08:28:28.027]     ...future.frame <- base::sys.nframe()
[08:28:28.027]     ...future.conditions <- base::list()
[08:28:28.027]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.027]     if (FALSE) {
[08:28:28.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.027]     }
[08:28:28.027]     ...future.result <- base::tryCatch({
[08:28:28.027]         base::withCallingHandlers({
[08:28:28.027]             ...future.value <- base::withVisible(base::local({
[08:28:28.027]                 b <- 3
[08:28:28.027]                 c <- 2
[08:28:28.027]                 a * b * c
[08:28:28.027]             }))
[08:28:28.027]             future::FutureResult(value = ...future.value$value, 
[08:28:28.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.027]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.027]                     ...future.globalenv.names))
[08:28:28.027]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.027]         }, condition = base::local({
[08:28:28.027]             c <- base::c
[08:28:28.027]             inherits <- base::inherits
[08:28:28.027]             invokeRestart <- base::invokeRestart
[08:28:28.027]             length <- base::length
[08:28:28.027]             list <- base::list
[08:28:28.027]             seq.int <- base::seq.int
[08:28:28.027]             signalCondition <- base::signalCondition
[08:28:28.027]             sys.calls <- base::sys.calls
[08:28:28.027]             `[[` <- base::`[[`
[08:28:28.027]             `+` <- base::`+`
[08:28:28.027]             `<<-` <- base::`<<-`
[08:28:28.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.027]                   3L)]
[08:28:28.027]             }
[08:28:28.027]             function(cond) {
[08:28:28.027]                 is_error <- inherits(cond, "error")
[08:28:28.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.027]                   NULL)
[08:28:28.027]                 if (is_error) {
[08:28:28.027]                   sessionInformation <- function() {
[08:28:28.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.027]                       search = base::search(), system = base::Sys.info())
[08:28:28.027]                   }
[08:28:28.027]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.027]                     cond$call), session = sessionInformation(), 
[08:28:28.027]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.027]                   signalCondition(cond)
[08:28:28.027]                 }
[08:28:28.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.027]                 "immediateCondition"))) {
[08:28:28.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.027]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.027]                   if (TRUE && !signal) {
[08:28:28.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.027]                     {
[08:28:28.027]                       inherits <- base::inherits
[08:28:28.027]                       invokeRestart <- base::invokeRestart
[08:28:28.027]                       is.null <- base::is.null
[08:28:28.027]                       muffled <- FALSE
[08:28:28.027]                       if (inherits(cond, "message")) {
[08:28:28.027]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.027]                         if (muffled) 
[08:28:28.027]                           invokeRestart("muffleMessage")
[08:28:28.027]                       }
[08:28:28.027]                       else if (inherits(cond, "warning")) {
[08:28:28.027]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.027]                         if (muffled) 
[08:28:28.027]                           invokeRestart("muffleWarning")
[08:28:28.027]                       }
[08:28:28.027]                       else if (inherits(cond, "condition")) {
[08:28:28.027]                         if (!is.null(pattern)) {
[08:28:28.027]                           computeRestarts <- base::computeRestarts
[08:28:28.027]                           grepl <- base::grepl
[08:28:28.027]                           restarts <- computeRestarts(cond)
[08:28:28.027]                           for (restart in restarts) {
[08:28:28.027]                             name <- restart$name
[08:28:28.027]                             if (is.null(name)) 
[08:28:28.027]                               next
[08:28:28.027]                             if (!grepl(pattern, name)) 
[08:28:28.027]                               next
[08:28:28.027]                             invokeRestart(restart)
[08:28:28.027]                             muffled <- TRUE
[08:28:28.027]                             break
[08:28:28.027]                           }
[08:28:28.027]                         }
[08:28:28.027]                       }
[08:28:28.027]                       invisible(muffled)
[08:28:28.027]                     }
[08:28:28.027]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.027]                   }
[08:28:28.027]                 }
[08:28:28.027]                 else {
[08:28:28.027]                   if (TRUE) {
[08:28:28.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.027]                     {
[08:28:28.027]                       inherits <- base::inherits
[08:28:28.027]                       invokeRestart <- base::invokeRestart
[08:28:28.027]                       is.null <- base::is.null
[08:28:28.027]                       muffled <- FALSE
[08:28:28.027]                       if (inherits(cond, "message")) {
[08:28:28.027]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.027]                         if (muffled) 
[08:28:28.027]                           invokeRestart("muffleMessage")
[08:28:28.027]                       }
[08:28:28.027]                       else if (inherits(cond, "warning")) {
[08:28:28.027]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.027]                         if (muffled) 
[08:28:28.027]                           invokeRestart("muffleWarning")
[08:28:28.027]                       }
[08:28:28.027]                       else if (inherits(cond, "condition")) {
[08:28:28.027]                         if (!is.null(pattern)) {
[08:28:28.027]                           computeRestarts <- base::computeRestarts
[08:28:28.027]                           grepl <- base::grepl
[08:28:28.027]                           restarts <- computeRestarts(cond)
[08:28:28.027]                           for (restart in restarts) {
[08:28:28.027]                             name <- restart$name
[08:28:28.027]                             if (is.null(name)) 
[08:28:28.027]                               next
[08:28:28.027]                             if (!grepl(pattern, name)) 
[08:28:28.027]                               next
[08:28:28.027]                             invokeRestart(restart)
[08:28:28.027]                             muffled <- TRUE
[08:28:28.027]                             break
[08:28:28.027]                           }
[08:28:28.027]                         }
[08:28:28.027]                       }
[08:28:28.027]                       invisible(muffled)
[08:28:28.027]                     }
[08:28:28.027]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.027]                   }
[08:28:28.027]                 }
[08:28:28.027]             }
[08:28:28.027]         }))
[08:28:28.027]     }, error = function(ex) {
[08:28:28.027]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.027]                 ...future.rng), started = ...future.startTime, 
[08:28:28.027]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.027]             version = "1.8"), class = "FutureResult")
[08:28:28.027]     }, finally = {
[08:28:28.027]         if (!identical(...future.workdir, getwd())) 
[08:28:28.027]             setwd(...future.workdir)
[08:28:28.027]         {
[08:28:28.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.027]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.027]             }
[08:28:28.027]             base::options(...future.oldOptions)
[08:28:28.027]             if (.Platform$OS.type == "windows") {
[08:28:28.027]                 old_names <- names(...future.oldEnvVars)
[08:28:28.027]                 envs <- base::Sys.getenv()
[08:28:28.027]                 names <- names(envs)
[08:28:28.027]                 common <- intersect(names, old_names)
[08:28:28.027]                 added <- setdiff(names, old_names)
[08:28:28.027]                 removed <- setdiff(old_names, names)
[08:28:28.027]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.027]                   envs[common]]
[08:28:28.027]                 NAMES <- toupper(changed)
[08:28:28.027]                 args <- list()
[08:28:28.027]                 for (kk in seq_along(NAMES)) {
[08:28:28.027]                   name <- changed[[kk]]
[08:28:28.027]                   NAME <- NAMES[[kk]]
[08:28:28.027]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.027]                     next
[08:28:28.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.027]                 }
[08:28:28.027]                 NAMES <- toupper(added)
[08:28:28.027]                 for (kk in seq_along(NAMES)) {
[08:28:28.027]                   name <- added[[kk]]
[08:28:28.027]                   NAME <- NAMES[[kk]]
[08:28:28.027]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.027]                     next
[08:28:28.027]                   args[[name]] <- ""
[08:28:28.027]                 }
[08:28:28.027]                 NAMES <- toupper(removed)
[08:28:28.027]                 for (kk in seq_along(NAMES)) {
[08:28:28.027]                   name <- removed[[kk]]
[08:28:28.027]                   NAME <- NAMES[[kk]]
[08:28:28.027]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.027]                     next
[08:28:28.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.027]                 }
[08:28:28.027]                 if (length(args) > 0) 
[08:28:28.027]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.027]             }
[08:28:28.027]             else {
[08:28:28.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.027]             }
[08:28:28.027]             {
[08:28:28.027]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.027]                   0L) {
[08:28:28.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.027]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.027]                   base::options(opts)
[08:28:28.027]                 }
[08:28:28.027]                 {
[08:28:28.027]                   {
[08:28:28.027]                     NULL
[08:28:28.027]                     RNGkind("Mersenne-Twister")
[08:28:28.027]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:28.027]                       inherits = FALSE)
[08:28:28.027]                   }
[08:28:28.027]                   options(future.plan = NULL)
[08:28:28.027]                   if (is.na(NA_character_)) 
[08:28:28.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.027]                     .init = FALSE)
[08:28:28.027]                 }
[08:28:28.027]             }
[08:28:28.027]         }
[08:28:28.027]     })
[08:28:28.027]     if (TRUE) {
[08:28:28.027]         base::sink(type = "output", split = FALSE)
[08:28:28.027]         if (TRUE) {
[08:28:28.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.027]         }
[08:28:28.027]         else {
[08:28:28.027]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.027]         }
[08:28:28.027]         base::close(...future.stdout)
[08:28:28.027]         ...future.stdout <- NULL
[08:28:28.027]     }
[08:28:28.027]     ...future.result$conditions <- ...future.conditions
[08:28:28.027]     ...future.result$finished <- base::Sys.time()
[08:28:28.027]     ...future.result
[08:28:28.027] }
[08:28:28.029] assign_globals() ...
[08:28:28.029] List of 1
[08:28:28.029]  $ a: num 0
[08:28:28.029]  - attr(*, "where")=List of 1
[08:28:28.029]   ..$ a:<environment: R_EmptyEnv> 
[08:28:28.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:28.029]  - attr(*, "resolved")= logi FALSE
[08:28:28.029]  - attr(*, "total_size")= num 39
[08:28:28.033] - copied ‘a’ to environment
[08:28:28.033] assign_globals() ... done
[08:28:28.033] plan(): Setting new future strategy stack:
[08:28:28.033] List of future strategies:
[08:28:28.033] 1. sequential:
[08:28:28.033]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.033]    - tweaked: FALSE
[08:28:28.033]    - call: NULL
[08:28:28.033] plan(): nbrOfWorkers() = 1
[08:28:28.034] plan(): Setting new future strategy stack:
[08:28:28.034] List of future strategies:
[08:28:28.034] 1. sequential:
[08:28:28.034]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.034]    - tweaked: FALSE
[08:28:28.034]    - call: future::plan("sequential")
[08:28:28.035] plan(): nbrOfWorkers() = 1
[08:28:28.035] SequentialFuture started (and completed)
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[08:28:28.036] getGlobalsAndPackages() ...
[08:28:28.037] Searching for globals...
[08:28:28.037] - globals found: [2] ‘{’, ‘ii’
[08:28:28.037] Searching for globals ... DONE
[08:28:28.037] Resolving globals: FALSE
[08:28:28.038] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:28.038] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:28.038] - globals: [1] ‘ii’
[08:28:28.038] 
[08:28:28.038] getGlobalsAndPackages() ... DONE
 - Creating multisession future #1 ...
[08:28:28.040] getGlobalsAndPackages() ...
[08:28:28.040] Searching for globals...
[08:28:28.041] - globals found: [2] ‘{’, ‘ii’
[08:28:28.041] Searching for globals ... DONE
[08:28:28.041] Resolving globals: FALSE
[08:28:28.041] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:28.042] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:28.042] - globals: [1] ‘ii’
[08:28:28.042] 
[08:28:28.042] getGlobalsAndPackages() ... DONE
 - Resolving 2 multisession futures
[08:28:28.042] Packages needed by the future expression (n = 0): <none>
[08:28:28.043] Packages needed by future strategies (n = 0): <none>
[08:28:28.043] {
[08:28:28.043]     {
[08:28:28.043]         {
[08:28:28.043]             ...future.startTime <- base::Sys.time()
[08:28:28.043]             {
[08:28:28.043]                 {
[08:28:28.043]                   {
[08:28:28.043]                     base::local({
[08:28:28.043]                       has_future <- base::requireNamespace("future", 
[08:28:28.043]                         quietly = TRUE)
[08:28:28.043]                       if (has_future) {
[08:28:28.043]                         ns <- base::getNamespace("future")
[08:28:28.043]                         version <- ns[[".package"]][["version"]]
[08:28:28.043]                         if (is.null(version)) 
[08:28:28.043]                           version <- utils::packageVersion("future")
[08:28:28.043]                       }
[08:28:28.043]                       else {
[08:28:28.043]                         version <- NULL
[08:28:28.043]                       }
[08:28:28.043]                       if (!has_future || version < "1.8.0") {
[08:28:28.043]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.043]                           "", base::R.version$version.string), 
[08:28:28.043]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:28.043]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.043]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.043]                             "release", "version")], collapse = " "), 
[08:28:28.043]                           hostname = base::Sys.info()[["nodename"]])
[08:28:28.043]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.043]                           info)
[08:28:28.043]                         info <- base::paste(info, collapse = "; ")
[08:28:28.043]                         if (!has_future) {
[08:28:28.043]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.043]                             info)
[08:28:28.043]                         }
[08:28:28.043]                         else {
[08:28:28.043]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.043]                             info, version)
[08:28:28.043]                         }
[08:28:28.043]                         base::stop(msg)
[08:28:28.043]                       }
[08:28:28.043]                     })
[08:28:28.043]                   }
[08:28:28.043]                   ...future.strategy.old <- future::plan("list")
[08:28:28.043]                   options(future.plan = NULL)
[08:28:28.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.043]                 }
[08:28:28.043]                 ...future.workdir <- getwd()
[08:28:28.043]             }
[08:28:28.043]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.043]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.043]         }
[08:28:28.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.043]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.043]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.043]             base::names(...future.oldOptions))
[08:28:28.043]     }
[08:28:28.043]     if (FALSE) {
[08:28:28.043]     }
[08:28:28.043]     else {
[08:28:28.043]         if (TRUE) {
[08:28:28.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.043]                 open = "w")
[08:28:28.043]         }
[08:28:28.043]         else {
[08:28:28.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.043]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.043]         }
[08:28:28.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.043]             base::sink(type = "output", split = FALSE)
[08:28:28.043]             base::close(...future.stdout)
[08:28:28.043]         }, add = TRUE)
[08:28:28.043]     }
[08:28:28.043]     ...future.frame <- base::sys.nframe()
[08:28:28.043]     ...future.conditions <- base::list()
[08:28:28.043]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.043]     if (FALSE) {
[08:28:28.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.043]     }
[08:28:28.043]     ...future.result <- base::tryCatch({
[08:28:28.043]         base::withCallingHandlers({
[08:28:28.043]             ...future.value <- base::withVisible(base::local({
[08:28:28.043]                 ii
[08:28:28.043]             }))
[08:28:28.043]             future::FutureResult(value = ...future.value$value, 
[08:28:28.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.043]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.043]                     ...future.globalenv.names))
[08:28:28.043]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.043]         }, condition = base::local({
[08:28:28.043]             c <- base::c
[08:28:28.043]             inherits <- base::inherits
[08:28:28.043]             invokeRestart <- base::invokeRestart
[08:28:28.043]             length <- base::length
[08:28:28.043]             list <- base::list
[08:28:28.043]             seq.int <- base::seq.int
[08:28:28.043]             signalCondition <- base::signalCondition
[08:28:28.043]             sys.calls <- base::sys.calls
[08:28:28.043]             `[[` <- base::`[[`
[08:28:28.043]             `+` <- base::`+`
[08:28:28.043]             `<<-` <- base::`<<-`
[08:28:28.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.043]                   3L)]
[08:28:28.043]             }
[08:28:28.043]             function(cond) {
[08:28:28.043]                 is_error <- inherits(cond, "error")
[08:28:28.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.043]                   NULL)
[08:28:28.043]                 if (is_error) {
[08:28:28.043]                   sessionInformation <- function() {
[08:28:28.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.043]                       search = base::search(), system = base::Sys.info())
[08:28:28.043]                   }
[08:28:28.043]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.043]                     cond$call), session = sessionInformation(), 
[08:28:28.043]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.043]                   signalCondition(cond)
[08:28:28.043]                 }
[08:28:28.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.043]                 "immediateCondition"))) {
[08:28:28.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.043]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.043]                   if (TRUE && !signal) {
[08:28:28.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.043]                     {
[08:28:28.043]                       inherits <- base::inherits
[08:28:28.043]                       invokeRestart <- base::invokeRestart
[08:28:28.043]                       is.null <- base::is.null
[08:28:28.043]                       muffled <- FALSE
[08:28:28.043]                       if (inherits(cond, "message")) {
[08:28:28.043]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.043]                         if (muffled) 
[08:28:28.043]                           invokeRestart("muffleMessage")
[08:28:28.043]                       }
[08:28:28.043]                       else if (inherits(cond, "warning")) {
[08:28:28.043]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.043]                         if (muffled) 
[08:28:28.043]                           invokeRestart("muffleWarning")
[08:28:28.043]                       }
[08:28:28.043]                       else if (inherits(cond, "condition")) {
[08:28:28.043]                         if (!is.null(pattern)) {
[08:28:28.043]                           computeRestarts <- base::computeRestarts
[08:28:28.043]                           grepl <- base::grepl
[08:28:28.043]                           restarts <- computeRestarts(cond)
[08:28:28.043]                           for (restart in restarts) {
[08:28:28.043]                             name <- restart$name
[08:28:28.043]                             if (is.null(name)) 
[08:28:28.043]                               next
[08:28:28.043]                             if (!grepl(pattern, name)) 
[08:28:28.043]                               next
[08:28:28.043]                             invokeRestart(restart)
[08:28:28.043]                             muffled <- TRUE
[08:28:28.043]                             break
[08:28:28.043]                           }
[08:28:28.043]                         }
[08:28:28.043]                       }
[08:28:28.043]                       invisible(muffled)
[08:28:28.043]                     }
[08:28:28.043]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.043]                   }
[08:28:28.043]                 }
[08:28:28.043]                 else {
[08:28:28.043]                   if (TRUE) {
[08:28:28.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.043]                     {
[08:28:28.043]                       inherits <- base::inherits
[08:28:28.043]                       invokeRestart <- base::invokeRestart
[08:28:28.043]                       is.null <- base::is.null
[08:28:28.043]                       muffled <- FALSE
[08:28:28.043]                       if (inherits(cond, "message")) {
[08:28:28.043]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.043]                         if (muffled) 
[08:28:28.043]                           invokeRestart("muffleMessage")
[08:28:28.043]                       }
[08:28:28.043]                       else if (inherits(cond, "warning")) {
[08:28:28.043]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.043]                         if (muffled) 
[08:28:28.043]                           invokeRestart("muffleWarning")
[08:28:28.043]                       }
[08:28:28.043]                       else if (inherits(cond, "condition")) {
[08:28:28.043]                         if (!is.null(pattern)) {
[08:28:28.043]                           computeRestarts <- base::computeRestarts
[08:28:28.043]                           grepl <- base::grepl
[08:28:28.043]                           restarts <- computeRestarts(cond)
[08:28:28.043]                           for (restart in restarts) {
[08:28:28.043]                             name <- restart$name
[08:28:28.043]                             if (is.null(name)) 
[08:28:28.043]                               next
[08:28:28.043]                             if (!grepl(pattern, name)) 
[08:28:28.043]                               next
[08:28:28.043]                             invokeRestart(restart)
[08:28:28.043]                             muffled <- TRUE
[08:28:28.043]                             break
[08:28:28.043]                           }
[08:28:28.043]                         }
[08:28:28.043]                       }
[08:28:28.043]                       invisible(muffled)
[08:28:28.043]                     }
[08:28:28.043]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.043]                   }
[08:28:28.043]                 }
[08:28:28.043]             }
[08:28:28.043]         }))
[08:28:28.043]     }, error = function(ex) {
[08:28:28.043]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.043]                 ...future.rng), started = ...future.startTime, 
[08:28:28.043]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.043]             version = "1.8"), class = "FutureResult")
[08:28:28.043]     }, finally = {
[08:28:28.043]         if (!identical(...future.workdir, getwd())) 
[08:28:28.043]             setwd(...future.workdir)
[08:28:28.043]         {
[08:28:28.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.043]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.043]             }
[08:28:28.043]             base::options(...future.oldOptions)
[08:28:28.043]             if (.Platform$OS.type == "windows") {
[08:28:28.043]                 old_names <- names(...future.oldEnvVars)
[08:28:28.043]                 envs <- base::Sys.getenv()
[08:28:28.043]                 names <- names(envs)
[08:28:28.043]                 common <- intersect(names, old_names)
[08:28:28.043]                 added <- setdiff(names, old_names)
[08:28:28.043]                 removed <- setdiff(old_names, names)
[08:28:28.043]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.043]                   envs[common]]
[08:28:28.043]                 NAMES <- toupper(changed)
[08:28:28.043]                 args <- list()
[08:28:28.043]                 for (kk in seq_along(NAMES)) {
[08:28:28.043]                   name <- changed[[kk]]
[08:28:28.043]                   NAME <- NAMES[[kk]]
[08:28:28.043]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.043]                     next
[08:28:28.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.043]                 }
[08:28:28.043]                 NAMES <- toupper(added)
[08:28:28.043]                 for (kk in seq_along(NAMES)) {
[08:28:28.043]                   name <- added[[kk]]
[08:28:28.043]                   NAME <- NAMES[[kk]]
[08:28:28.043]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.043]                     next
[08:28:28.043]                   args[[name]] <- ""
[08:28:28.043]                 }
[08:28:28.043]                 NAMES <- toupper(removed)
[08:28:28.043]                 for (kk in seq_along(NAMES)) {
[08:28:28.043]                   name <- removed[[kk]]
[08:28:28.043]                   NAME <- NAMES[[kk]]
[08:28:28.043]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.043]                     next
[08:28:28.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.043]                 }
[08:28:28.043]                 if (length(args) > 0) 
[08:28:28.043]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.043]             }
[08:28:28.043]             else {
[08:28:28.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.043]             }
[08:28:28.043]             {
[08:28:28.043]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.043]                   0L) {
[08:28:28.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.043]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.043]                   base::options(opts)
[08:28:28.043]                 }
[08:28:28.043]                 {
[08:28:28.043]                   {
[08:28:28.043]                     NULL
[08:28:28.043]                     RNGkind("Mersenne-Twister")
[08:28:28.043]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:28.043]                       inherits = FALSE)
[08:28:28.043]                   }
[08:28:28.043]                   options(future.plan = NULL)
[08:28:28.043]                   if (is.na(NA_character_)) 
[08:28:28.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.043]                     .init = FALSE)
[08:28:28.043]                 }
[08:28:28.043]             }
[08:28:28.043]         }
[08:28:28.043]     })
[08:28:28.043]     if (TRUE) {
[08:28:28.043]         base::sink(type = "output", split = FALSE)
[08:28:28.043]         if (TRUE) {
[08:28:28.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.043]         }
[08:28:28.043]         else {
[08:28:28.043]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.043]         }
[08:28:28.043]         base::close(...future.stdout)
[08:28:28.043]         ...future.stdout <- NULL
[08:28:28.043]     }
[08:28:28.043]     ...future.result$conditions <- ...future.conditions
[08:28:28.043]     ...future.result$finished <- base::Sys.time()
[08:28:28.043]     ...future.result
[08:28:28.043] }
[08:28:28.045] assign_globals() ...
[08:28:28.045] List of 1
[08:28:28.045]  $ ii: int 1
[08:28:28.045]  - attr(*, "where")=List of 1
[08:28:28.045]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:28.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:28.045]  - attr(*, "resolved")= logi FALSE
[08:28:28.045]  - attr(*, "total_size")= num 35
[08:28:28.047] - copied ‘ii’ to environment
[08:28:28.047] assign_globals() ... done
[08:28:28.047] plan(): Setting new future strategy stack:
[08:28:28.047] List of future strategies:
[08:28:28.047] 1. sequential:
[08:28:28.047]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.047]    - tweaked: FALSE
[08:28:28.047]    - call: NULL
[08:28:28.048] plan(): nbrOfWorkers() = 1
[08:28:28.048] plan(): Setting new future strategy stack:
[08:28:28.048] List of future strategies:
[08:28:28.048] 1. sequential:
[08:28:28.048]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.048]    - tweaked: FALSE
[08:28:28.048]    - call: future::plan("sequential")
[08:28:28.049] plan(): nbrOfWorkers() = 1
[08:28:28.049] SequentialFuture started (and completed)
[08:28:28.049] Packages needed by the future expression (n = 0): <none>
[08:28:28.049] Packages needed by future strategies (n = 0): <none>
[08:28:28.050] {
[08:28:28.050]     {
[08:28:28.050]         {
[08:28:28.050]             ...future.startTime <- base::Sys.time()
[08:28:28.050]             {
[08:28:28.050]                 {
[08:28:28.050]                   {
[08:28:28.050]                     base::local({
[08:28:28.050]                       has_future <- base::requireNamespace("future", 
[08:28:28.050]                         quietly = TRUE)
[08:28:28.050]                       if (has_future) {
[08:28:28.050]                         ns <- base::getNamespace("future")
[08:28:28.050]                         version <- ns[[".package"]][["version"]]
[08:28:28.050]                         if (is.null(version)) 
[08:28:28.050]                           version <- utils::packageVersion("future")
[08:28:28.050]                       }
[08:28:28.050]                       else {
[08:28:28.050]                         version <- NULL
[08:28:28.050]                       }
[08:28:28.050]                       if (!has_future || version < "1.8.0") {
[08:28:28.050]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.050]                           "", base::R.version$version.string), 
[08:28:28.050]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:28.050]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.050]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.050]                             "release", "version")], collapse = " "), 
[08:28:28.050]                           hostname = base::Sys.info()[["nodename"]])
[08:28:28.050]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.050]                           info)
[08:28:28.050]                         info <- base::paste(info, collapse = "; ")
[08:28:28.050]                         if (!has_future) {
[08:28:28.050]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.050]                             info)
[08:28:28.050]                         }
[08:28:28.050]                         else {
[08:28:28.050]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.050]                             info, version)
[08:28:28.050]                         }
[08:28:28.050]                         base::stop(msg)
[08:28:28.050]                       }
[08:28:28.050]                     })
[08:28:28.050]                   }
[08:28:28.050]                   ...future.strategy.old <- future::plan("list")
[08:28:28.050]                   options(future.plan = NULL)
[08:28:28.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.050]                 }
[08:28:28.050]                 ...future.workdir <- getwd()
[08:28:28.050]             }
[08:28:28.050]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.050]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.050]         }
[08:28:28.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.050]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.050]             base::names(...future.oldOptions))
[08:28:28.050]     }
[08:28:28.050]     if (FALSE) {
[08:28:28.050]     }
[08:28:28.050]     else {
[08:28:28.050]         if (TRUE) {
[08:28:28.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.050]                 open = "w")
[08:28:28.050]         }
[08:28:28.050]         else {
[08:28:28.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.050]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.050]         }
[08:28:28.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.050]             base::sink(type = "output", split = FALSE)
[08:28:28.050]             base::close(...future.stdout)
[08:28:28.050]         }, add = TRUE)
[08:28:28.050]     }
[08:28:28.050]     ...future.frame <- base::sys.nframe()
[08:28:28.050]     ...future.conditions <- base::list()
[08:28:28.050]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.050]     if (FALSE) {
[08:28:28.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.050]     }
[08:28:28.050]     ...future.result <- base::tryCatch({
[08:28:28.050]         base::withCallingHandlers({
[08:28:28.050]             ...future.value <- base::withVisible(base::local({
[08:28:28.050]                 ii
[08:28:28.050]             }))
[08:28:28.050]             future::FutureResult(value = ...future.value$value, 
[08:28:28.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.050]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.050]                     ...future.globalenv.names))
[08:28:28.050]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.050]         }, condition = base::local({
[08:28:28.050]             c <- base::c
[08:28:28.050]             inherits <- base::inherits
[08:28:28.050]             invokeRestart <- base::invokeRestart
[08:28:28.050]             length <- base::length
[08:28:28.050]             list <- base::list
[08:28:28.050]             seq.int <- base::seq.int
[08:28:28.050]             signalCondition <- base::signalCondition
[08:28:28.050]             sys.calls <- base::sys.calls
[08:28:28.050]             `[[` <- base::`[[`
[08:28:28.050]             `+` <- base::`+`
[08:28:28.050]             `<<-` <- base::`<<-`
[08:28:28.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.050]                   3L)]
[08:28:28.050]             }
[08:28:28.050]             function(cond) {
[08:28:28.050]                 is_error <- inherits(cond, "error")
[08:28:28.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.050]                   NULL)
[08:28:28.050]                 if (is_error) {
[08:28:28.050]                   sessionInformation <- function() {
[08:28:28.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.050]                       search = base::search(), system = base::Sys.info())
[08:28:28.050]                   }
[08:28:28.050]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.050]                     cond$call), session = sessionInformation(), 
[08:28:28.050]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.050]                   signalCondition(cond)
[08:28:28.050]                 }
[08:28:28.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.050]                 "immediateCondition"))) {
[08:28:28.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.050]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.050]                   if (TRUE && !signal) {
[08:28:28.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.050]                     {
[08:28:28.050]                       inherits <- base::inherits
[08:28:28.050]                       invokeRestart <- base::invokeRestart
[08:28:28.050]                       is.null <- base::is.null
[08:28:28.050]                       muffled <- FALSE
[08:28:28.050]                       if (inherits(cond, "message")) {
[08:28:28.050]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.050]                         if (muffled) 
[08:28:28.050]                           invokeRestart("muffleMessage")
[08:28:28.050]                       }
[08:28:28.050]                       else if (inherits(cond, "warning")) {
[08:28:28.050]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.050]                         if (muffled) 
[08:28:28.050]                           invokeRestart("muffleWarning")
[08:28:28.050]                       }
[08:28:28.050]                       else if (inherits(cond, "condition")) {
[08:28:28.050]                         if (!is.null(pattern)) {
[08:28:28.050]                           computeRestarts <- base::computeRestarts
[08:28:28.050]                           grepl <- base::grepl
[08:28:28.050]                           restarts <- computeRestarts(cond)
[08:28:28.050]                           for (restart in restarts) {
[08:28:28.050]                             name <- restart$name
[08:28:28.050]                             if (is.null(name)) 
[08:28:28.050]                               next
[08:28:28.050]                             if (!grepl(pattern, name)) 
[08:28:28.050]                               next
[08:28:28.050]                             invokeRestart(restart)
[08:28:28.050]                             muffled <- TRUE
[08:28:28.050]                             break
[08:28:28.050]                           }
[08:28:28.050]                         }
[08:28:28.050]                       }
[08:28:28.050]                       invisible(muffled)
[08:28:28.050]                     }
[08:28:28.050]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.050]                   }
[08:28:28.050]                 }
[08:28:28.050]                 else {
[08:28:28.050]                   if (TRUE) {
[08:28:28.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.050]                     {
[08:28:28.050]                       inherits <- base::inherits
[08:28:28.050]                       invokeRestart <- base::invokeRestart
[08:28:28.050]                       is.null <- base::is.null
[08:28:28.050]                       muffled <- FALSE
[08:28:28.050]                       if (inherits(cond, "message")) {
[08:28:28.050]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.050]                         if (muffled) 
[08:28:28.050]                           invokeRestart("muffleMessage")
[08:28:28.050]                       }
[08:28:28.050]                       else if (inherits(cond, "warning")) {
[08:28:28.050]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.050]                         if (muffled) 
[08:28:28.050]                           invokeRestart("muffleWarning")
[08:28:28.050]                       }
[08:28:28.050]                       else if (inherits(cond, "condition")) {
[08:28:28.050]                         if (!is.null(pattern)) {
[08:28:28.050]                           computeRestarts <- base::computeRestarts
[08:28:28.050]                           grepl <- base::grepl
[08:28:28.050]                           restarts <- computeRestarts(cond)
[08:28:28.050]                           for (restart in restarts) {
[08:28:28.050]                             name <- restart$name
[08:28:28.050]                             if (is.null(name)) 
[08:28:28.050]                               next
[08:28:28.050]                             if (!grepl(pattern, name)) 
[08:28:28.050]                               next
[08:28:28.050]                             invokeRestart(restart)
[08:28:28.050]                             muffled <- TRUE
[08:28:28.050]                             break
[08:28:28.050]                           }
[08:28:28.050]                         }
[08:28:28.050]                       }
[08:28:28.050]                       invisible(muffled)
[08:28:28.050]                     }
[08:28:28.050]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.050]                   }
[08:28:28.050]                 }
[08:28:28.050]             }
[08:28:28.050]         }))
[08:28:28.050]     }, error = function(ex) {
[08:28:28.050]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.050]                 ...future.rng), started = ...future.startTime, 
[08:28:28.050]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.050]             version = "1.8"), class = "FutureResult")
[08:28:28.050]     }, finally = {
[08:28:28.050]         if (!identical(...future.workdir, getwd())) 
[08:28:28.050]             setwd(...future.workdir)
[08:28:28.050]         {
[08:28:28.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.050]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.050]             }
[08:28:28.050]             base::options(...future.oldOptions)
[08:28:28.050]             if (.Platform$OS.type == "windows") {
[08:28:28.050]                 old_names <- names(...future.oldEnvVars)
[08:28:28.050]                 envs <- base::Sys.getenv()
[08:28:28.050]                 names <- names(envs)
[08:28:28.050]                 common <- intersect(names, old_names)
[08:28:28.050]                 added <- setdiff(names, old_names)
[08:28:28.050]                 removed <- setdiff(old_names, names)
[08:28:28.050]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.050]                   envs[common]]
[08:28:28.050]                 NAMES <- toupper(changed)
[08:28:28.050]                 args <- list()
[08:28:28.050]                 for (kk in seq_along(NAMES)) {
[08:28:28.050]                   name <- changed[[kk]]
[08:28:28.050]                   NAME <- NAMES[[kk]]
[08:28:28.050]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.050]                     next
[08:28:28.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.050]                 }
[08:28:28.050]                 NAMES <- toupper(added)
[08:28:28.050]                 for (kk in seq_along(NAMES)) {
[08:28:28.050]                   name <- added[[kk]]
[08:28:28.050]                   NAME <- NAMES[[kk]]
[08:28:28.050]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.050]                     next
[08:28:28.050]                   args[[name]] <- ""
[08:28:28.050]                 }
[08:28:28.050]                 NAMES <- toupper(removed)
[08:28:28.050]                 for (kk in seq_along(NAMES)) {
[08:28:28.050]                   name <- removed[[kk]]
[08:28:28.050]                   NAME <- NAMES[[kk]]
[08:28:28.050]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.050]                     next
[08:28:28.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.050]                 }
[08:28:28.050]                 if (length(args) > 0) 
[08:28:28.050]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.050]             }
[08:28:28.050]             else {
[08:28:28.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.050]             }
[08:28:28.050]             {
[08:28:28.050]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.050]                   0L) {
[08:28:28.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.050]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.050]                   base::options(opts)
[08:28:28.050]                 }
[08:28:28.050]                 {
[08:28:28.050]                   {
[08:28:28.050]                     NULL
[08:28:28.050]                     RNGkind("Mersenne-Twister")
[08:28:28.050]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:28.050]                       inherits = FALSE)
[08:28:28.050]                   }
[08:28:28.050]                   options(future.plan = NULL)
[08:28:28.050]                   if (is.na(NA_character_)) 
[08:28:28.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.050]                     .init = FALSE)
[08:28:28.050]                 }
[08:28:28.050]             }
[08:28:28.050]         }
[08:28:28.050]     })
[08:28:28.050]     if (TRUE) {
[08:28:28.050]         base::sink(type = "output", split = FALSE)
[08:28:28.050]         if (TRUE) {
[08:28:28.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.050]         }
[08:28:28.050]         else {
[08:28:28.050]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.050]         }
[08:28:28.050]         base::close(...future.stdout)
[08:28:28.050]         ...future.stdout <- NULL
[08:28:28.050]     }
[08:28:28.050]     ...future.result$conditions <- ...future.conditions
[08:28:28.050]     ...future.result$finished <- base::Sys.time()
[08:28:28.050]     ...future.result
[08:28:28.050] }
[08:28:28.051] assign_globals() ...
[08:28:28.051] List of 1
[08:28:28.051]  $ ii: int 2
[08:28:28.051]  - attr(*, "where")=List of 1
[08:28:28.051]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:28.051]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:28.051]  - attr(*, "resolved")= logi FALSE
[08:28:28.051]  - attr(*, "total_size")= num 35
[08:28:28.054] - copied ‘ii’ to environment
[08:28:28.054] assign_globals() ... done
[08:28:28.054] plan(): Setting new future strategy stack:
[08:28:28.054] List of future strategies:
[08:28:28.054] 1. sequential:
[08:28:28.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.054]    - tweaked: FALSE
[08:28:28.054]    - call: NULL
[08:28:28.054] plan(): nbrOfWorkers() = 1
[08:28:28.055] plan(): Setting new future strategy stack:
[08:28:28.055] List of future strategies:
[08:28:28.055] 1. sequential:
[08:28:28.055]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.055]    - tweaked: FALSE
[08:28:28.055]    - call: future::plan("sequential")
[08:28:28.056] plan(): nbrOfWorkers() = 1
[08:28:28.056] SequentialFuture started (and completed)
*** multisession() - workers inherit .libPaths()
[08:28:28.056] getGlobalsAndPackages() ...
[08:28:28.056] Searching for globals...
[08:28:28.057] - globals found: [1] ‘.libPaths’
[08:28:28.057] Searching for globals ... DONE
[08:28:28.057] Resolving globals: FALSE
[08:28:28.059] 
[08:28:28.059] 
[08:28:28.059] getGlobalsAndPackages() ... DONE
[08:28:28.060] run() for ‘Future’ ...
[08:28:28.060] - state: ‘created’
[08:28:28.060] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:28.060] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:28.060] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:28.060]   - Field: ‘label’
[08:28:28.061]   - Field: ‘local’
[08:28:28.061]   - Field: ‘owner’
[08:28:28.061]   - Field: ‘envir’
[08:28:28.061]   - Field: ‘packages’
[08:28:28.061]   - Field: ‘gc’
[08:28:28.061]   - Field: ‘conditions’
[08:28:28.061]   - Field: ‘expr’
[08:28:28.061]   - Field: ‘uuid’
[08:28:28.061]   - Field: ‘seed’
[08:28:28.061]   - Field: ‘version’
[08:28:28.061]   - Field: ‘result’
[08:28:28.061]   - Field: ‘asynchronous’
[08:28:28.062]   - Field: ‘calls’
[08:28:28.062]   - Field: ‘globals’
[08:28:28.062]   - Field: ‘stdout’
[08:28:28.062]   - Field: ‘earlySignal’
[08:28:28.062]   - Field: ‘lazy’
[08:28:28.062]   - Field: ‘state’
[08:28:28.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:28.062] - Launch lazy future ...
[08:28:28.062] Packages needed by the future expression (n = 0): <none>
[08:28:28.062] Packages needed by future strategies (n = 0): <none>
[08:28:28.063] {
[08:28:28.063]     {
[08:28:28.063]         {
[08:28:28.063]             ...future.startTime <- base::Sys.time()
[08:28:28.063]             {
[08:28:28.063]                 {
[08:28:28.063]                   {
[08:28:28.063]                     base::local({
[08:28:28.063]                       has_future <- base::requireNamespace("future", 
[08:28:28.063]                         quietly = TRUE)
[08:28:28.063]                       if (has_future) {
[08:28:28.063]                         ns <- base::getNamespace("future")
[08:28:28.063]                         version <- ns[[".package"]][["version"]]
[08:28:28.063]                         if (is.null(version)) 
[08:28:28.063]                           version <- utils::packageVersion("future")
[08:28:28.063]                       }
[08:28:28.063]                       else {
[08:28:28.063]                         version <- NULL
[08:28:28.063]                       }
[08:28:28.063]                       if (!has_future || version < "1.8.0") {
[08:28:28.063]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.063]                           "", base::R.version$version.string), 
[08:28:28.063]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:28.063]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.063]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.063]                             "release", "version")], collapse = " "), 
[08:28:28.063]                           hostname = base::Sys.info()[["nodename"]])
[08:28:28.063]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.063]                           info)
[08:28:28.063]                         info <- base::paste(info, collapse = "; ")
[08:28:28.063]                         if (!has_future) {
[08:28:28.063]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.063]                             info)
[08:28:28.063]                         }
[08:28:28.063]                         else {
[08:28:28.063]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.063]                             info, version)
[08:28:28.063]                         }
[08:28:28.063]                         base::stop(msg)
[08:28:28.063]                       }
[08:28:28.063]                     })
[08:28:28.063]                   }
[08:28:28.063]                   ...future.strategy.old <- future::plan("list")
[08:28:28.063]                   options(future.plan = NULL)
[08:28:28.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.063]                 }
[08:28:28.063]                 ...future.workdir <- getwd()
[08:28:28.063]             }
[08:28:28.063]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.063]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.063]         }
[08:28:28.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.063]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.063]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.063]             base::names(...future.oldOptions))
[08:28:28.063]     }
[08:28:28.063]     if (FALSE) {
[08:28:28.063]     }
[08:28:28.063]     else {
[08:28:28.063]         if (TRUE) {
[08:28:28.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.063]                 open = "w")
[08:28:28.063]         }
[08:28:28.063]         else {
[08:28:28.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.063]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.063]         }
[08:28:28.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.063]             base::sink(type = "output", split = FALSE)
[08:28:28.063]             base::close(...future.stdout)
[08:28:28.063]         }, add = TRUE)
[08:28:28.063]     }
[08:28:28.063]     ...future.frame <- base::sys.nframe()
[08:28:28.063]     ...future.conditions <- base::list()
[08:28:28.063]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.063]     if (FALSE) {
[08:28:28.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.063]     }
[08:28:28.063]     ...future.result <- base::tryCatch({
[08:28:28.063]         base::withCallingHandlers({
[08:28:28.063]             ...future.value <- base::withVisible(base::local(.libPaths()))
[08:28:28.063]             future::FutureResult(value = ...future.value$value, 
[08:28:28.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.063]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.063]                     ...future.globalenv.names))
[08:28:28.063]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.063]         }, condition = base::local({
[08:28:28.063]             c <- base::c
[08:28:28.063]             inherits <- base::inherits
[08:28:28.063]             invokeRestart <- base::invokeRestart
[08:28:28.063]             length <- base::length
[08:28:28.063]             list <- base::list
[08:28:28.063]             seq.int <- base::seq.int
[08:28:28.063]             signalCondition <- base::signalCondition
[08:28:28.063]             sys.calls <- base::sys.calls
[08:28:28.063]             `[[` <- base::`[[`
[08:28:28.063]             `+` <- base::`+`
[08:28:28.063]             `<<-` <- base::`<<-`
[08:28:28.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.063]                   3L)]
[08:28:28.063]             }
[08:28:28.063]             function(cond) {
[08:28:28.063]                 is_error <- inherits(cond, "error")
[08:28:28.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.063]                   NULL)
[08:28:28.063]                 if (is_error) {
[08:28:28.063]                   sessionInformation <- function() {
[08:28:28.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.063]                       search = base::search(), system = base::Sys.info())
[08:28:28.063]                   }
[08:28:28.063]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.063]                     cond$call), session = sessionInformation(), 
[08:28:28.063]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.063]                   signalCondition(cond)
[08:28:28.063]                 }
[08:28:28.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.063]                 "immediateCondition"))) {
[08:28:28.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.063]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.063]                   if (TRUE && !signal) {
[08:28:28.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.063]                     {
[08:28:28.063]                       inherits <- base::inherits
[08:28:28.063]                       invokeRestart <- base::invokeRestart
[08:28:28.063]                       is.null <- base::is.null
[08:28:28.063]                       muffled <- FALSE
[08:28:28.063]                       if (inherits(cond, "message")) {
[08:28:28.063]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.063]                         if (muffled) 
[08:28:28.063]                           invokeRestart("muffleMessage")
[08:28:28.063]                       }
[08:28:28.063]                       else if (inherits(cond, "warning")) {
[08:28:28.063]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.063]                         if (muffled) 
[08:28:28.063]                           invokeRestart("muffleWarning")
[08:28:28.063]                       }
[08:28:28.063]                       else if (inherits(cond, "condition")) {
[08:28:28.063]                         if (!is.null(pattern)) {
[08:28:28.063]                           computeRestarts <- base::computeRestarts
[08:28:28.063]                           grepl <- base::grepl
[08:28:28.063]                           restarts <- computeRestarts(cond)
[08:28:28.063]                           for (restart in restarts) {
[08:28:28.063]                             name <- restart$name
[08:28:28.063]                             if (is.null(name)) 
[08:28:28.063]                               next
[08:28:28.063]                             if (!grepl(pattern, name)) 
[08:28:28.063]                               next
[08:28:28.063]                             invokeRestart(restart)
[08:28:28.063]                             muffled <- TRUE
[08:28:28.063]                             break
[08:28:28.063]                           }
[08:28:28.063]                         }
[08:28:28.063]                       }
[08:28:28.063]                       invisible(muffled)
[08:28:28.063]                     }
[08:28:28.063]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.063]                   }
[08:28:28.063]                 }
[08:28:28.063]                 else {
[08:28:28.063]                   if (TRUE) {
[08:28:28.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.063]                     {
[08:28:28.063]                       inherits <- base::inherits
[08:28:28.063]                       invokeRestart <- base::invokeRestart
[08:28:28.063]                       is.null <- base::is.null
[08:28:28.063]                       muffled <- FALSE
[08:28:28.063]                       if (inherits(cond, "message")) {
[08:28:28.063]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.063]                         if (muffled) 
[08:28:28.063]                           invokeRestart("muffleMessage")
[08:28:28.063]                       }
[08:28:28.063]                       else if (inherits(cond, "warning")) {
[08:28:28.063]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.063]                         if (muffled) 
[08:28:28.063]                           invokeRestart("muffleWarning")
[08:28:28.063]                       }
[08:28:28.063]                       else if (inherits(cond, "condition")) {
[08:28:28.063]                         if (!is.null(pattern)) {
[08:28:28.063]                           computeRestarts <- base::computeRestarts
[08:28:28.063]                           grepl <- base::grepl
[08:28:28.063]                           restarts <- computeRestarts(cond)
[08:28:28.063]                           for (restart in restarts) {
[08:28:28.063]                             name <- restart$name
[08:28:28.063]                             if (is.null(name)) 
[08:28:28.063]                               next
[08:28:28.063]                             if (!grepl(pattern, name)) 
[08:28:28.063]                               next
[08:28:28.063]                             invokeRestart(restart)
[08:28:28.063]                             muffled <- TRUE
[08:28:28.063]                             break
[08:28:28.063]                           }
[08:28:28.063]                         }
[08:28:28.063]                       }
[08:28:28.063]                       invisible(muffled)
[08:28:28.063]                     }
[08:28:28.063]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.063]                   }
[08:28:28.063]                 }
[08:28:28.063]             }
[08:28:28.063]         }))
[08:28:28.063]     }, error = function(ex) {
[08:28:28.063]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.063]                 ...future.rng), started = ...future.startTime, 
[08:28:28.063]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.063]             version = "1.8"), class = "FutureResult")
[08:28:28.063]     }, finally = {
[08:28:28.063]         if (!identical(...future.workdir, getwd())) 
[08:28:28.063]             setwd(...future.workdir)
[08:28:28.063]         {
[08:28:28.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.063]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.063]             }
[08:28:28.063]             base::options(...future.oldOptions)
[08:28:28.063]             if (.Platform$OS.type == "windows") {
[08:28:28.063]                 old_names <- names(...future.oldEnvVars)
[08:28:28.063]                 envs <- base::Sys.getenv()
[08:28:28.063]                 names <- names(envs)
[08:28:28.063]                 common <- intersect(names, old_names)
[08:28:28.063]                 added <- setdiff(names, old_names)
[08:28:28.063]                 removed <- setdiff(old_names, names)
[08:28:28.063]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.063]                   envs[common]]
[08:28:28.063]                 NAMES <- toupper(changed)
[08:28:28.063]                 args <- list()
[08:28:28.063]                 for (kk in seq_along(NAMES)) {
[08:28:28.063]                   name <- changed[[kk]]
[08:28:28.063]                   NAME <- NAMES[[kk]]
[08:28:28.063]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.063]                     next
[08:28:28.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.063]                 }
[08:28:28.063]                 NAMES <- toupper(added)
[08:28:28.063]                 for (kk in seq_along(NAMES)) {
[08:28:28.063]                   name <- added[[kk]]
[08:28:28.063]                   NAME <- NAMES[[kk]]
[08:28:28.063]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.063]                     next
[08:28:28.063]                   args[[name]] <- ""
[08:28:28.063]                 }
[08:28:28.063]                 NAMES <- toupper(removed)
[08:28:28.063]                 for (kk in seq_along(NAMES)) {
[08:28:28.063]                   name <- removed[[kk]]
[08:28:28.063]                   NAME <- NAMES[[kk]]
[08:28:28.063]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.063]                     next
[08:28:28.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.063]                 }
[08:28:28.063]                 if (length(args) > 0) 
[08:28:28.063]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.063]             }
[08:28:28.063]             else {
[08:28:28.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.063]             }
[08:28:28.063]             {
[08:28:28.063]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.063]                   0L) {
[08:28:28.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.063]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.063]                   base::options(opts)
[08:28:28.063]                 }
[08:28:28.063]                 {
[08:28:28.063]                   {
[08:28:28.063]                     NULL
[08:28:28.063]                     RNGkind("Mersenne-Twister")
[08:28:28.063]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:28.063]                       inherits = FALSE)
[08:28:28.063]                   }
[08:28:28.063]                   options(future.plan = NULL)
[08:28:28.063]                   if (is.na(NA_character_)) 
[08:28:28.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.063]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.063]                     .init = FALSE)
[08:28:28.063]                 }
[08:28:28.063]             }
[08:28:28.063]         }
[08:28:28.063]     })
[08:28:28.063]     if (TRUE) {
[08:28:28.063]         base::sink(type = "output", split = FALSE)
[08:28:28.063]         if (TRUE) {
[08:28:28.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.063]         }
[08:28:28.063]         else {
[08:28:28.063]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.063]         }
[08:28:28.063]         base::close(...future.stdout)
[08:28:28.063]         ...future.stdout <- NULL
[08:28:28.063]     }
[08:28:28.063]     ...future.result$conditions <- ...future.conditions
[08:28:28.063]     ...future.result$finished <- base::Sys.time()
[08:28:28.063]     ...future.result
[08:28:28.063] }
[08:28:28.065] plan(): Setting new future strategy stack:
[08:28:28.065] List of future strategies:
[08:28:28.065] 1. sequential:
[08:28:28.065]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.065]    - tweaked: FALSE
[08:28:28.065]    - call: NULL
[08:28:28.065] plan(): nbrOfWorkers() = 1
[08:28:28.066] plan(): Setting new future strategy stack:
[08:28:28.066] List of future strategies:
[08:28:28.066] 1. sequential:
[08:28:28.066]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.066]    - tweaked: FALSE
[08:28:28.066]    - call: future::plan("sequential")
[08:28:28.067] plan(): nbrOfWorkers() = 1
[08:28:28.067] SequentialFuture started (and completed)
[08:28:28.067] - Launch lazy future ... done
[08:28:28.067] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[08:28:28.069] getGlobalsAndPackages() ...
[08:28:28.069] Searching for globals...
[08:28:28.070] - globals found: [2] ‘{’, ‘stop’
[08:28:28.070] Searching for globals ... DONE
[08:28:28.070] Resolving globals: FALSE
[08:28:28.071] 
[08:28:28.071] 
[08:28:28.071] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 2d485820-dce0-a5ac-1757-5b458766347d
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:28.071] Packages needed by the future expression (n = 0): <none>
[08:28:28.072] Packages needed by future strategies (n = 0): <none>
[08:28:28.072] {
[08:28:28.072]     {
[08:28:28.072]         {
[08:28:28.072]             ...future.startTime <- base::Sys.time()
[08:28:28.072]             {
[08:28:28.072]                 {
[08:28:28.072]                   {
[08:28:28.072]                     base::local({
[08:28:28.072]                       has_future <- base::requireNamespace("future", 
[08:28:28.072]                         quietly = TRUE)
[08:28:28.072]                       if (has_future) {
[08:28:28.072]                         ns <- base::getNamespace("future")
[08:28:28.072]                         version <- ns[[".package"]][["version"]]
[08:28:28.072]                         if (is.null(version)) 
[08:28:28.072]                           version <- utils::packageVersion("future")
[08:28:28.072]                       }
[08:28:28.072]                       else {
[08:28:28.072]                         version <- NULL
[08:28:28.072]                       }
[08:28:28.072]                       if (!has_future || version < "1.8.0") {
[08:28:28.072]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.072]                           "", base::R.version$version.string), 
[08:28:28.072]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:28.072]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.072]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.072]                             "release", "version")], collapse = " "), 
[08:28:28.072]                           hostname = base::Sys.info()[["nodename"]])
[08:28:28.072]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.072]                           info)
[08:28:28.072]                         info <- base::paste(info, collapse = "; ")
[08:28:28.072]                         if (!has_future) {
[08:28:28.072]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.072]                             info)
[08:28:28.072]                         }
[08:28:28.072]                         else {
[08:28:28.072]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.072]                             info, version)
[08:28:28.072]                         }
[08:28:28.072]                         base::stop(msg)
[08:28:28.072]                       }
[08:28:28.072]                     })
[08:28:28.072]                   }
[08:28:28.072]                   ...future.strategy.old <- future::plan("list")
[08:28:28.072]                   options(future.plan = NULL)
[08:28:28.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.072]                 }
[08:28:28.072]                 ...future.workdir <- getwd()
[08:28:28.072]             }
[08:28:28.072]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.072]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.072]         }
[08:28:28.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.072]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.072]             base::names(...future.oldOptions))
[08:28:28.072]     }
[08:28:28.072]     if (FALSE) {
[08:28:28.072]     }
[08:28:28.072]     else {
[08:28:28.072]         if (TRUE) {
[08:28:28.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.072]                 open = "w")
[08:28:28.072]         }
[08:28:28.072]         else {
[08:28:28.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.072]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.072]         }
[08:28:28.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.072]             base::sink(type = "output", split = FALSE)
[08:28:28.072]             base::close(...future.stdout)
[08:28:28.072]         }, add = TRUE)
[08:28:28.072]     }
[08:28:28.072]     ...future.frame <- base::sys.nframe()
[08:28:28.072]     ...future.conditions <- base::list()
[08:28:28.072]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.072]     if (FALSE) {
[08:28:28.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.072]     }
[08:28:28.072]     ...future.result <- base::tryCatch({
[08:28:28.072]         base::withCallingHandlers({
[08:28:28.072]             ...future.value <- base::withVisible(base::local({
[08:28:28.072]                 stop("Whoops!")
[08:28:28.072]                 1
[08:28:28.072]             }))
[08:28:28.072]             future::FutureResult(value = ...future.value$value, 
[08:28:28.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.072]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.072]                     ...future.globalenv.names))
[08:28:28.072]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.072]         }, condition = base::local({
[08:28:28.072]             c <- base::c
[08:28:28.072]             inherits <- base::inherits
[08:28:28.072]             invokeRestart <- base::invokeRestart
[08:28:28.072]             length <- base::length
[08:28:28.072]             list <- base::list
[08:28:28.072]             seq.int <- base::seq.int
[08:28:28.072]             signalCondition <- base::signalCondition
[08:28:28.072]             sys.calls <- base::sys.calls
[08:28:28.072]             `[[` <- base::`[[`
[08:28:28.072]             `+` <- base::`+`
[08:28:28.072]             `<<-` <- base::`<<-`
[08:28:28.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.072]                   3L)]
[08:28:28.072]             }
[08:28:28.072]             function(cond) {
[08:28:28.072]                 is_error <- inherits(cond, "error")
[08:28:28.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.072]                   NULL)
[08:28:28.072]                 if (is_error) {
[08:28:28.072]                   sessionInformation <- function() {
[08:28:28.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.072]                       search = base::search(), system = base::Sys.info())
[08:28:28.072]                   }
[08:28:28.072]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.072]                     cond$call), session = sessionInformation(), 
[08:28:28.072]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.072]                   signalCondition(cond)
[08:28:28.072]                 }
[08:28:28.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.072]                 "immediateCondition"))) {
[08:28:28.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.072]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.072]                   if (TRUE && !signal) {
[08:28:28.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.072]                     {
[08:28:28.072]                       inherits <- base::inherits
[08:28:28.072]                       invokeRestart <- base::invokeRestart
[08:28:28.072]                       is.null <- base::is.null
[08:28:28.072]                       muffled <- FALSE
[08:28:28.072]                       if (inherits(cond, "message")) {
[08:28:28.072]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.072]                         if (muffled) 
[08:28:28.072]                           invokeRestart("muffleMessage")
[08:28:28.072]                       }
[08:28:28.072]                       else if (inherits(cond, "warning")) {
[08:28:28.072]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.072]                         if (muffled) 
[08:28:28.072]                           invokeRestart("muffleWarning")
[08:28:28.072]                       }
[08:28:28.072]                       else if (inherits(cond, "condition")) {
[08:28:28.072]                         if (!is.null(pattern)) {
[08:28:28.072]                           computeRestarts <- base::computeRestarts
[08:28:28.072]                           grepl <- base::grepl
[08:28:28.072]                           restarts <- computeRestarts(cond)
[08:28:28.072]                           for (restart in restarts) {
[08:28:28.072]                             name <- restart$name
[08:28:28.072]                             if (is.null(name)) 
[08:28:28.072]                               next
[08:28:28.072]                             if (!grepl(pattern, name)) 
[08:28:28.072]                               next
[08:28:28.072]                             invokeRestart(restart)
[08:28:28.072]                             muffled <- TRUE
[08:28:28.072]                             break
[08:28:28.072]                           }
[08:28:28.072]                         }
[08:28:28.072]                       }
[08:28:28.072]                       invisible(muffled)
[08:28:28.072]                     }
[08:28:28.072]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.072]                   }
[08:28:28.072]                 }
[08:28:28.072]                 else {
[08:28:28.072]                   if (TRUE) {
[08:28:28.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.072]                     {
[08:28:28.072]                       inherits <- base::inherits
[08:28:28.072]                       invokeRestart <- base::invokeRestart
[08:28:28.072]                       is.null <- base::is.null
[08:28:28.072]                       muffled <- FALSE
[08:28:28.072]                       if (inherits(cond, "message")) {
[08:28:28.072]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.072]                         if (muffled) 
[08:28:28.072]                           invokeRestart("muffleMessage")
[08:28:28.072]                       }
[08:28:28.072]                       else if (inherits(cond, "warning")) {
[08:28:28.072]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.072]                         if (muffled) 
[08:28:28.072]                           invokeRestart("muffleWarning")
[08:28:28.072]                       }
[08:28:28.072]                       else if (inherits(cond, "condition")) {
[08:28:28.072]                         if (!is.null(pattern)) {
[08:28:28.072]                           computeRestarts <- base::computeRestarts
[08:28:28.072]                           grepl <- base::grepl
[08:28:28.072]                           restarts <- computeRestarts(cond)
[08:28:28.072]                           for (restart in restarts) {
[08:28:28.072]                             name <- restart$name
[08:28:28.072]                             if (is.null(name)) 
[08:28:28.072]                               next
[08:28:28.072]                             if (!grepl(pattern, name)) 
[08:28:28.072]                               next
[08:28:28.072]                             invokeRestart(restart)
[08:28:28.072]                             muffled <- TRUE
[08:28:28.072]                             break
[08:28:28.072]                           }
[08:28:28.072]                         }
[08:28:28.072]                       }
[08:28:28.072]                       invisible(muffled)
[08:28:28.072]                     }
[08:28:28.072]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.072]                   }
[08:28:28.072]                 }
[08:28:28.072]             }
[08:28:28.072]         }))
[08:28:28.072]     }, error = function(ex) {
[08:28:28.072]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.072]                 ...future.rng), started = ...future.startTime, 
[08:28:28.072]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.072]             version = "1.8"), class = "FutureResult")
[08:28:28.072]     }, finally = {
[08:28:28.072]         if (!identical(...future.workdir, getwd())) 
[08:28:28.072]             setwd(...future.workdir)
[08:28:28.072]         {
[08:28:28.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.072]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.072]             }
[08:28:28.072]             base::options(...future.oldOptions)
[08:28:28.072]             if (.Platform$OS.type == "windows") {
[08:28:28.072]                 old_names <- names(...future.oldEnvVars)
[08:28:28.072]                 envs <- base::Sys.getenv()
[08:28:28.072]                 names <- names(envs)
[08:28:28.072]                 common <- intersect(names, old_names)
[08:28:28.072]                 added <- setdiff(names, old_names)
[08:28:28.072]                 removed <- setdiff(old_names, names)
[08:28:28.072]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.072]                   envs[common]]
[08:28:28.072]                 NAMES <- toupper(changed)
[08:28:28.072]                 args <- list()
[08:28:28.072]                 for (kk in seq_along(NAMES)) {
[08:28:28.072]                   name <- changed[[kk]]
[08:28:28.072]                   NAME <- NAMES[[kk]]
[08:28:28.072]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.072]                     next
[08:28:28.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.072]                 }
[08:28:28.072]                 NAMES <- toupper(added)
[08:28:28.072]                 for (kk in seq_along(NAMES)) {
[08:28:28.072]                   name <- added[[kk]]
[08:28:28.072]                   NAME <- NAMES[[kk]]
[08:28:28.072]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.072]                     next
[08:28:28.072]                   args[[name]] <- ""
[08:28:28.072]                 }
[08:28:28.072]                 NAMES <- toupper(removed)
[08:28:28.072]                 for (kk in seq_along(NAMES)) {
[08:28:28.072]                   name <- removed[[kk]]
[08:28:28.072]                   NAME <- NAMES[[kk]]
[08:28:28.072]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.072]                     next
[08:28:28.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.072]                 }
[08:28:28.072]                 if (length(args) > 0) 
[08:28:28.072]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.072]             }
[08:28:28.072]             else {
[08:28:28.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.072]             }
[08:28:28.072]             {
[08:28:28.072]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.072]                   0L) {
[08:28:28.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.072]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.072]                   base::options(opts)
[08:28:28.072]                 }
[08:28:28.072]                 {
[08:28:28.072]                   {
[08:28:28.072]                     NULL
[08:28:28.072]                     RNGkind("Mersenne-Twister")
[08:28:28.072]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:28.072]                       inherits = FALSE)
[08:28:28.072]                   }
[08:28:28.072]                   options(future.plan = NULL)
[08:28:28.072]                   if (is.na(NA_character_)) 
[08:28:28.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.072]                     .init = FALSE)
[08:28:28.072]                 }
[08:28:28.072]             }
[08:28:28.072]         }
[08:28:28.072]     })
[08:28:28.072]     if (TRUE) {
[08:28:28.072]         base::sink(type = "output", split = FALSE)
[08:28:28.072]         if (TRUE) {
[08:28:28.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.072]         }
[08:28:28.072]         else {
[08:28:28.072]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.072]         }
[08:28:28.072]         base::close(...future.stdout)
[08:28:28.072]         ...future.stdout <- NULL
[08:28:28.072]     }
[08:28:28.072]     ...future.result$conditions <- ...future.conditions
[08:28:28.072]     ...future.result$finished <- base::Sys.time()
[08:28:28.072]     ...future.result
[08:28:28.072] }
[08:28:28.074] plan(): Setting new future strategy stack:
[08:28:28.074] List of future strategies:
[08:28:28.074] 1. sequential:
[08:28:28.074]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.074]    - tweaked: FALSE
[08:28:28.074]    - call: NULL
[08:28:28.074] plan(): nbrOfWorkers() = 1
[08:28:28.075] plan(): Setting new future strategy stack:
[08:28:28.075] List of future strategies:
[08:28:28.075] 1. sequential:
[08:28:28.075]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.075]    - tweaked: FALSE
[08:28:28.075]    - call: future::plan("sequential")
[08:28:28.076] plan(): nbrOfWorkers() = 1
[08:28:28.076] SequentialFuture started (and completed)
[08:28:28.076] signalConditions() ...
[08:28:28.076]  - include = ‘immediateCondition’
[08:28:28.076]  - exclude = 
[08:28:28.076]  - resignal = FALSE
[08:28:28.076]  - Number of conditions: 1
[08:28:28.076] signalConditions() ... done
[08:28:28.077] signalConditions() ...
[08:28:28.077]  - include = ‘immediateCondition’
[08:28:28.077]  - exclude = 
[08:28:28.077]  - resignal = FALSE
[08:28:28.077]  - Number of conditions: 1
[08:28:28.077] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[08:28:28.077] signalConditions() ...
[08:28:28.077]  - include = ‘immediateCondition’
[08:28:28.077]  - exclude = 
[08:28:28.077]  - resignal = FALSE
[08:28:28.078]  - Number of conditions: 1
[08:28:28.078] signalConditions() ... done
[08:28:28.078] Future state: ‘finished’
[08:28:28.078] signalConditions() ...
[08:28:28.078]  - include = ‘condition’
[08:28:28.078]  - exclude = ‘immediateCondition’
[08:28:28.078]  - resignal = TRUE
[08:28:28.078]  - Number of conditions: 1
[08:28:28.078]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:28.078] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[08:28:28.079] signalConditions() ...
[08:28:28.079]  - include = ‘immediateCondition’
[08:28:28.079]  - exclude = 
[08:28:28.079]  - resignal = FALSE
[08:28:28.079]  - Number of conditions: 1
[08:28:28.079] signalConditions() ... done
[08:28:28.079] Future state: ‘finished’
[08:28:28.079] signalConditions() ...
[08:28:28.079]  - include = ‘condition’
[08:28:28.080]  - exclude = ‘immediateCondition’
[08:28:28.080]  - resignal = TRUE
[08:28:28.080]  - Number of conditions: 1
[08:28:28.080]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:28.080] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[08:28:28.081] getGlobalsAndPackages() ...
[08:28:28.081] Searching for globals...
[08:28:28.083] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[08:28:28.083] Searching for globals ... DONE
[08:28:28.083] Resolving globals: FALSE
[08:28:28.083] 
[08:28:28.083] 
[08:28:28.083] getGlobalsAndPackages() ... DONE
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: TRUE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 2d485820-dce0-a5ac-1757-5b458766347d
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:28.084] Packages needed by the future expression (n = 0): <none>
[08:28:28.084] Packages needed by future strategies (n = 0): <none>
[08:28:28.084] {
[08:28:28.084]     {
[08:28:28.084]         {
[08:28:28.084]             ...future.startTime <- base::Sys.time()
[08:28:28.084]             {
[08:28:28.084]                 {
[08:28:28.084]                   {
[08:28:28.084]                     base::local({
[08:28:28.084]                       has_future <- base::requireNamespace("future", 
[08:28:28.084]                         quietly = TRUE)
[08:28:28.084]                       if (has_future) {
[08:28:28.084]                         ns <- base::getNamespace("future")
[08:28:28.084]                         version <- ns[[".package"]][["version"]]
[08:28:28.084]                         if (is.null(version)) 
[08:28:28.084]                           version <- utils::packageVersion("future")
[08:28:28.084]                       }
[08:28:28.084]                       else {
[08:28:28.084]                         version <- NULL
[08:28:28.084]                       }
[08:28:28.084]                       if (!has_future || version < "1.8.0") {
[08:28:28.084]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.084]                           "", base::R.version$version.string), 
[08:28:28.084]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:28.084]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.084]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.084]                             "release", "version")], collapse = " "), 
[08:28:28.084]                           hostname = base::Sys.info()[["nodename"]])
[08:28:28.084]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.084]                           info)
[08:28:28.084]                         info <- base::paste(info, collapse = "; ")
[08:28:28.084]                         if (!has_future) {
[08:28:28.084]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.084]                             info)
[08:28:28.084]                         }
[08:28:28.084]                         else {
[08:28:28.084]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.084]                             info, version)
[08:28:28.084]                         }
[08:28:28.084]                         base::stop(msg)
[08:28:28.084]                       }
[08:28:28.084]                     })
[08:28:28.084]                   }
[08:28:28.084]                   ...future.strategy.old <- future::plan("list")
[08:28:28.084]                   options(future.plan = NULL)
[08:28:28.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.084]                 }
[08:28:28.084]                 ...future.workdir <- getwd()
[08:28:28.084]             }
[08:28:28.084]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.084]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.084]         }
[08:28:28.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.084]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.084]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.084]             base::names(...future.oldOptions))
[08:28:28.084]     }
[08:28:28.084]     if (FALSE) {
[08:28:28.084]     }
[08:28:28.084]     else {
[08:28:28.084]         if (TRUE) {
[08:28:28.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.084]                 open = "w")
[08:28:28.084]         }
[08:28:28.084]         else {
[08:28:28.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.084]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.084]         }
[08:28:28.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.084]             base::sink(type = "output", split = FALSE)
[08:28:28.084]             base::close(...future.stdout)
[08:28:28.084]         }, add = TRUE)
[08:28:28.084]     }
[08:28:28.084]     ...future.frame <- base::sys.nframe()
[08:28:28.084]     ...future.conditions <- base::list()
[08:28:28.084]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.084]     if (FALSE) {
[08:28:28.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.084]     }
[08:28:28.084]     ...future.result <- base::tryCatch({
[08:28:28.084]         base::withCallingHandlers({
[08:28:28.084]             ...future.value <- base::withVisible(base::local({
[08:28:28.084]                 stop(structure(list(message = "boom"), class = c("MyError", 
[08:28:28.084]                   "error", "condition")))
[08:28:28.084]             }))
[08:28:28.084]             future::FutureResult(value = ...future.value$value, 
[08:28:28.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.084]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.084]                     ...future.globalenv.names))
[08:28:28.084]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.084]         }, condition = base::local({
[08:28:28.084]             c <- base::c
[08:28:28.084]             inherits <- base::inherits
[08:28:28.084]             invokeRestart <- base::invokeRestart
[08:28:28.084]             length <- base::length
[08:28:28.084]             list <- base::list
[08:28:28.084]             seq.int <- base::seq.int
[08:28:28.084]             signalCondition <- base::signalCondition
[08:28:28.084]             sys.calls <- base::sys.calls
[08:28:28.084]             `[[` <- base::`[[`
[08:28:28.084]             `+` <- base::`+`
[08:28:28.084]             `<<-` <- base::`<<-`
[08:28:28.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.084]                   3L)]
[08:28:28.084]             }
[08:28:28.084]             function(cond) {
[08:28:28.084]                 is_error <- inherits(cond, "error")
[08:28:28.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.084]                   NULL)
[08:28:28.084]                 if (is_error) {
[08:28:28.084]                   sessionInformation <- function() {
[08:28:28.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.084]                       search = base::search(), system = base::Sys.info())
[08:28:28.084]                   }
[08:28:28.084]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.084]                     cond$call), session = sessionInformation(), 
[08:28:28.084]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.084]                   signalCondition(cond)
[08:28:28.084]                 }
[08:28:28.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.084]                 "immediateCondition"))) {
[08:28:28.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.084]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.084]                   if (TRUE && !signal) {
[08:28:28.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.084]                     {
[08:28:28.084]                       inherits <- base::inherits
[08:28:28.084]                       invokeRestart <- base::invokeRestart
[08:28:28.084]                       is.null <- base::is.null
[08:28:28.084]                       muffled <- FALSE
[08:28:28.084]                       if (inherits(cond, "message")) {
[08:28:28.084]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.084]                         if (muffled) 
[08:28:28.084]                           invokeRestart("muffleMessage")
[08:28:28.084]                       }
[08:28:28.084]                       else if (inherits(cond, "warning")) {
[08:28:28.084]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.084]                         if (muffled) 
[08:28:28.084]                           invokeRestart("muffleWarning")
[08:28:28.084]                       }
[08:28:28.084]                       else if (inherits(cond, "condition")) {
[08:28:28.084]                         if (!is.null(pattern)) {
[08:28:28.084]                           computeRestarts <- base::computeRestarts
[08:28:28.084]                           grepl <- base::grepl
[08:28:28.084]                           restarts <- computeRestarts(cond)
[08:28:28.084]                           for (restart in restarts) {
[08:28:28.084]                             name <- restart$name
[08:28:28.084]                             if (is.null(name)) 
[08:28:28.084]                               next
[08:28:28.084]                             if (!grepl(pattern, name)) 
[08:28:28.084]                               next
[08:28:28.084]                             invokeRestart(restart)
[08:28:28.084]                             muffled <- TRUE
[08:28:28.084]                             break
[08:28:28.084]                           }
[08:28:28.084]                         }
[08:28:28.084]                       }
[08:28:28.084]                       invisible(muffled)
[08:28:28.084]                     }
[08:28:28.084]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.084]                   }
[08:28:28.084]                 }
[08:28:28.084]                 else {
[08:28:28.084]                   if (TRUE) {
[08:28:28.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.084]                     {
[08:28:28.084]                       inherits <- base::inherits
[08:28:28.084]                       invokeRestart <- base::invokeRestart
[08:28:28.084]                       is.null <- base::is.null
[08:28:28.084]                       muffled <- FALSE
[08:28:28.084]                       if (inherits(cond, "message")) {
[08:28:28.084]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.084]                         if (muffled) 
[08:28:28.084]                           invokeRestart("muffleMessage")
[08:28:28.084]                       }
[08:28:28.084]                       else if (inherits(cond, "warning")) {
[08:28:28.084]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.084]                         if (muffled) 
[08:28:28.084]                           invokeRestart("muffleWarning")
[08:28:28.084]                       }
[08:28:28.084]                       else if (inherits(cond, "condition")) {
[08:28:28.084]                         if (!is.null(pattern)) {
[08:28:28.084]                           computeRestarts <- base::computeRestarts
[08:28:28.084]                           grepl <- base::grepl
[08:28:28.084]                           restarts <- computeRestarts(cond)
[08:28:28.084]                           for (restart in restarts) {
[08:28:28.084]                             name <- restart$name
[08:28:28.084]                             if (is.null(name)) 
[08:28:28.084]                               next
[08:28:28.084]                             if (!grepl(pattern, name)) 
[08:28:28.084]                               next
[08:28:28.084]                             invokeRestart(restart)
[08:28:28.084]                             muffled <- TRUE
[08:28:28.084]                             break
[08:28:28.084]                           }
[08:28:28.084]                         }
[08:28:28.084]                       }
[08:28:28.084]                       invisible(muffled)
[08:28:28.084]                     }
[08:28:28.084]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.084]                   }
[08:28:28.084]                 }
[08:28:28.084]             }
[08:28:28.084]         }))
[08:28:28.084]     }, error = function(ex) {
[08:28:28.084]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.084]                 ...future.rng), started = ...future.startTime, 
[08:28:28.084]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.084]             version = "1.8"), class = "FutureResult")
[08:28:28.084]     }, finally = {
[08:28:28.084]         if (!identical(...future.workdir, getwd())) 
[08:28:28.084]             setwd(...future.workdir)
[08:28:28.084]         {
[08:28:28.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.084]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.084]             }
[08:28:28.084]             base::options(...future.oldOptions)
[08:28:28.084]             if (.Platform$OS.type == "windows") {
[08:28:28.084]                 old_names <- names(...future.oldEnvVars)
[08:28:28.084]                 envs <- base::Sys.getenv()
[08:28:28.084]                 names <- names(envs)
[08:28:28.084]                 common <- intersect(names, old_names)
[08:28:28.084]                 added <- setdiff(names, old_names)
[08:28:28.084]                 removed <- setdiff(old_names, names)
[08:28:28.084]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.084]                   envs[common]]
[08:28:28.084]                 NAMES <- toupper(changed)
[08:28:28.084]                 args <- list()
[08:28:28.084]                 for (kk in seq_along(NAMES)) {
[08:28:28.084]                   name <- changed[[kk]]
[08:28:28.084]                   NAME <- NAMES[[kk]]
[08:28:28.084]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.084]                     next
[08:28:28.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.084]                 }
[08:28:28.084]                 NAMES <- toupper(added)
[08:28:28.084]                 for (kk in seq_along(NAMES)) {
[08:28:28.084]                   name <- added[[kk]]
[08:28:28.084]                   NAME <- NAMES[[kk]]
[08:28:28.084]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.084]                     next
[08:28:28.084]                   args[[name]] <- ""
[08:28:28.084]                 }
[08:28:28.084]                 NAMES <- toupper(removed)
[08:28:28.084]                 for (kk in seq_along(NAMES)) {
[08:28:28.084]                   name <- removed[[kk]]
[08:28:28.084]                   NAME <- NAMES[[kk]]
[08:28:28.084]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.084]                     next
[08:28:28.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.084]                 }
[08:28:28.084]                 if (length(args) > 0) 
[08:28:28.084]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.084]             }
[08:28:28.084]             else {
[08:28:28.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.084]             }
[08:28:28.084]             {
[08:28:28.084]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.084]                   0L) {
[08:28:28.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.084]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.084]                   base::options(opts)
[08:28:28.084]                 }
[08:28:28.084]                 {
[08:28:28.084]                   {
[08:28:28.084]                     NULL
[08:28:28.084]                     RNGkind("Mersenne-Twister")
[08:28:28.084]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:28.084]                       inherits = FALSE)
[08:28:28.084]                   }
[08:28:28.084]                   options(future.plan = NULL)
[08:28:28.084]                   if (is.na(NA_character_)) 
[08:28:28.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.084]                     .init = FALSE)
[08:28:28.084]                 }
[08:28:28.084]             }
[08:28:28.084]         }
[08:28:28.084]     })
[08:28:28.084]     if (TRUE) {
[08:28:28.084]         base::sink(type = "output", split = FALSE)
[08:28:28.084]         if (TRUE) {
[08:28:28.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.084]         }
[08:28:28.084]         else {
[08:28:28.084]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.084]         }
[08:28:28.084]         base::close(...future.stdout)
[08:28:28.084]         ...future.stdout <- NULL
[08:28:28.084]     }
[08:28:28.084]     ...future.result$conditions <- ...future.conditions
[08:28:28.084]     ...future.result$finished <- base::Sys.time()
[08:28:28.084]     ...future.result
[08:28:28.084] }
[08:28:28.086] plan(): Setting new future strategy stack:
[08:28:28.086] List of future strategies:
[08:28:28.086] 1. sequential:
[08:28:28.086]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.086]    - tweaked: FALSE
[08:28:28.086]    - call: NULL
[08:28:28.087] plan(): nbrOfWorkers() = 1
[08:28:28.088] plan(): Setting new future strategy stack:
[08:28:28.088] List of future strategies:
[08:28:28.088] 1. sequential:
[08:28:28.088]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.088]    - tweaked: FALSE
[08:28:28.088]    - call: future::plan("sequential")
[08:28:28.088] plan(): nbrOfWorkers() = 1
[08:28:28.088] SequentialFuture started (and completed)
[08:28:28.088] signalConditions() ...
[08:28:28.089]  - include = ‘immediateCondition’
[08:28:28.089]  - exclude = 
[08:28:28.089]  - resignal = FALSE
[08:28:28.089]  - Number of conditions: 1
[08:28:28.089] signalConditions() ... done
[08:28:28.089] signalConditions() ...
[08:28:28.089]  - include = ‘immediateCondition’
[08:28:28.089]  - exclude = 
[08:28:28.089]  - resignal = FALSE
[08:28:28.089]  - Number of conditions: 1
[08:28:28.089] signalConditions() ... done
<MyError: boom>
[08:28:28.090] signalConditions() ...
[08:28:28.090]  - include = ‘immediateCondition’
[08:28:28.090]  - exclude = 
[08:28:28.090]  - resignal = FALSE
[08:28:28.092]  - Number of conditions: 1
[08:28:28.092] signalConditions() ... done
[08:28:28.092] Future state: ‘finished’
[08:28:28.092] signalConditions() ...
[08:28:28.092]  - include = ‘condition’
[08:28:28.092]  - exclude = ‘immediateCondition’
[08:28:28.092]  - resignal = TRUE
[08:28:28.092]  - Number of conditions: 1
[08:28:28.092]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[08:28:28.092] signalConditions() ... done
Testing with 1 cores ... DONE
Testing with 2 cores ...
[08:28:28.096] getGlobalsAndPackages() ...
[08:28:28.096] 
[08:28:28.096] - globals: [0] <none>
[08:28:28.096] getGlobalsAndPackages() ... DONE
[08:28:28.576] Packages needed by the future expression (n = 0): <none>
[08:28:28.576] Packages needed by future strategies (n = 0): <none>
[08:28:28.577] {
[08:28:28.577]     {
[08:28:28.577]         {
[08:28:28.577]             ...future.startTime <- base::Sys.time()
[08:28:28.577]             {
[08:28:28.577]                 {
[08:28:28.577]                   {
[08:28:28.577]                     {
[08:28:28.577]                       base::local({
[08:28:28.577]                         has_future <- base::requireNamespace("future", 
[08:28:28.577]                           quietly = TRUE)
[08:28:28.577]                         if (has_future) {
[08:28:28.577]                           ns <- base::getNamespace("future")
[08:28:28.577]                           version <- ns[[".package"]][["version"]]
[08:28:28.577]                           if (is.null(version)) 
[08:28:28.577]                             version <- utils::packageVersion("future")
[08:28:28.577]                         }
[08:28:28.577]                         else {
[08:28:28.577]                           version <- NULL
[08:28:28.577]                         }
[08:28:28.577]                         if (!has_future || version < "1.8.0") {
[08:28:28.577]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.577]                             "", base::R.version$version.string), 
[08:28:28.577]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:28.577]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.577]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.577]                               "release", "version")], collapse = " "), 
[08:28:28.577]                             hostname = base::Sys.info()[["nodename"]])
[08:28:28.577]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.577]                             info)
[08:28:28.577]                           info <- base::paste(info, collapse = "; ")
[08:28:28.577]                           if (!has_future) {
[08:28:28.577]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.577]                               info)
[08:28:28.577]                           }
[08:28:28.577]                           else {
[08:28:28.577]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.577]                               info, version)
[08:28:28.577]                           }
[08:28:28.577]                           base::stop(msg)
[08:28:28.577]                         }
[08:28:28.577]                       })
[08:28:28.577]                     }
[08:28:28.577]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:28.577]                     base::options(mc.cores = 1L)
[08:28:28.577]                   }
[08:28:28.577]                   ...future.strategy.old <- future::plan("list")
[08:28:28.577]                   options(future.plan = NULL)
[08:28:28.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.577]                 }
[08:28:28.577]                 ...future.workdir <- getwd()
[08:28:28.577]             }
[08:28:28.577]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.577]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.577]         }
[08:28:28.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.577]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.577]             base::names(...future.oldOptions))
[08:28:28.577]     }
[08:28:28.577]     if (FALSE) {
[08:28:28.577]     }
[08:28:28.577]     else {
[08:28:28.577]         if (TRUE) {
[08:28:28.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.577]                 open = "w")
[08:28:28.577]         }
[08:28:28.577]         else {
[08:28:28.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.577]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.577]         }
[08:28:28.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.577]             base::sink(type = "output", split = FALSE)
[08:28:28.577]             base::close(...future.stdout)
[08:28:28.577]         }, add = TRUE)
[08:28:28.577]     }
[08:28:28.577]     ...future.frame <- base::sys.nframe()
[08:28:28.577]     ...future.conditions <- base::list()
[08:28:28.577]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.577]     if (FALSE) {
[08:28:28.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.577]     }
[08:28:28.577]     ...future.result <- base::tryCatch({
[08:28:28.577]         base::withCallingHandlers({
[08:28:28.577]             ...future.value <- base::withVisible(base::local({
[08:28:28.577]                 ...future.makeSendCondition <- base::local({
[08:28:28.577]                   sendCondition <- NULL
[08:28:28.577]                   function(frame = 1L) {
[08:28:28.577]                     if (is.function(sendCondition)) 
[08:28:28.577]                       return(sendCondition)
[08:28:28.577]                     ns <- getNamespace("parallel")
[08:28:28.577]                     if (exists("sendData", mode = "function", 
[08:28:28.577]                       envir = ns)) {
[08:28:28.577]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:28.577]                         envir = ns)
[08:28:28.577]                       envir <- sys.frame(frame)
[08:28:28.577]                       master <- NULL
[08:28:28.577]                       while (!identical(envir, .GlobalEnv) && 
[08:28:28.577]                         !identical(envir, emptyenv())) {
[08:28:28.577]                         if (exists("master", mode = "list", envir = envir, 
[08:28:28.577]                           inherits = FALSE)) {
[08:28:28.577]                           master <- get("master", mode = "list", 
[08:28:28.577]                             envir = envir, inherits = FALSE)
[08:28:28.577]                           if (inherits(master, c("SOCKnode", 
[08:28:28.577]                             "SOCK0node"))) {
[08:28:28.577]                             sendCondition <<- function(cond) {
[08:28:28.577]                               data <- list(type = "VALUE", value = cond, 
[08:28:28.577]                                 success = TRUE)
[08:28:28.577]                               parallel_sendData(master, data)
[08:28:28.577]                             }
[08:28:28.577]                             return(sendCondition)
[08:28:28.577]                           }
[08:28:28.577]                         }
[08:28:28.577]                         frame <- frame + 1L
[08:28:28.577]                         envir <- sys.frame(frame)
[08:28:28.577]                       }
[08:28:28.577]                     }
[08:28:28.577]                     sendCondition <<- function(cond) NULL
[08:28:28.577]                   }
[08:28:28.577]                 })
[08:28:28.577]                 withCallingHandlers({
[08:28:28.577]                   {
[08:28:28.577]                     42L
[08:28:28.577]                   }
[08:28:28.577]                 }, immediateCondition = function(cond) {
[08:28:28.577]                   sendCondition <- ...future.makeSendCondition()
[08:28:28.577]                   sendCondition(cond)
[08:28:28.577]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.577]                   {
[08:28:28.577]                     inherits <- base::inherits
[08:28:28.577]                     invokeRestart <- base::invokeRestart
[08:28:28.577]                     is.null <- base::is.null
[08:28:28.577]                     muffled <- FALSE
[08:28:28.577]                     if (inherits(cond, "message")) {
[08:28:28.577]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:28.577]                       if (muffled) 
[08:28:28.577]                         invokeRestart("muffleMessage")
[08:28:28.577]                     }
[08:28:28.577]                     else if (inherits(cond, "warning")) {
[08:28:28.577]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:28.577]                       if (muffled) 
[08:28:28.577]                         invokeRestart("muffleWarning")
[08:28:28.577]                     }
[08:28:28.577]                     else if (inherits(cond, "condition")) {
[08:28:28.577]                       if (!is.null(pattern)) {
[08:28:28.577]                         computeRestarts <- base::computeRestarts
[08:28:28.577]                         grepl <- base::grepl
[08:28:28.577]                         restarts <- computeRestarts(cond)
[08:28:28.577]                         for (restart in restarts) {
[08:28:28.577]                           name <- restart$name
[08:28:28.577]                           if (is.null(name)) 
[08:28:28.577]                             next
[08:28:28.577]                           if (!grepl(pattern, name)) 
[08:28:28.577]                             next
[08:28:28.577]                           invokeRestart(restart)
[08:28:28.577]                           muffled <- TRUE
[08:28:28.577]                           break
[08:28:28.577]                         }
[08:28:28.577]                       }
[08:28:28.577]                     }
[08:28:28.577]                     invisible(muffled)
[08:28:28.577]                   }
[08:28:28.577]                   muffleCondition(cond)
[08:28:28.577]                 })
[08:28:28.577]             }))
[08:28:28.577]             future::FutureResult(value = ...future.value$value, 
[08:28:28.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.577]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.577]                     ...future.globalenv.names))
[08:28:28.577]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.577]         }, condition = base::local({
[08:28:28.577]             c <- base::c
[08:28:28.577]             inherits <- base::inherits
[08:28:28.577]             invokeRestart <- base::invokeRestart
[08:28:28.577]             length <- base::length
[08:28:28.577]             list <- base::list
[08:28:28.577]             seq.int <- base::seq.int
[08:28:28.577]             signalCondition <- base::signalCondition
[08:28:28.577]             sys.calls <- base::sys.calls
[08:28:28.577]             `[[` <- base::`[[`
[08:28:28.577]             `+` <- base::`+`
[08:28:28.577]             `<<-` <- base::`<<-`
[08:28:28.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.577]                   3L)]
[08:28:28.577]             }
[08:28:28.577]             function(cond) {
[08:28:28.577]                 is_error <- inherits(cond, "error")
[08:28:28.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.577]                   NULL)
[08:28:28.577]                 if (is_error) {
[08:28:28.577]                   sessionInformation <- function() {
[08:28:28.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.577]                       search = base::search(), system = base::Sys.info())
[08:28:28.577]                   }
[08:28:28.577]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.577]                     cond$call), session = sessionInformation(), 
[08:28:28.577]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.577]                   signalCondition(cond)
[08:28:28.577]                 }
[08:28:28.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.577]                 "immediateCondition"))) {
[08:28:28.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.577]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.577]                   if (TRUE && !signal) {
[08:28:28.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.577]                     {
[08:28:28.577]                       inherits <- base::inherits
[08:28:28.577]                       invokeRestart <- base::invokeRestart
[08:28:28.577]                       is.null <- base::is.null
[08:28:28.577]                       muffled <- FALSE
[08:28:28.577]                       if (inherits(cond, "message")) {
[08:28:28.577]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.577]                         if (muffled) 
[08:28:28.577]                           invokeRestart("muffleMessage")
[08:28:28.577]                       }
[08:28:28.577]                       else if (inherits(cond, "warning")) {
[08:28:28.577]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.577]                         if (muffled) 
[08:28:28.577]                           invokeRestart("muffleWarning")
[08:28:28.577]                       }
[08:28:28.577]                       else if (inherits(cond, "condition")) {
[08:28:28.577]                         if (!is.null(pattern)) {
[08:28:28.577]                           computeRestarts <- base::computeRestarts
[08:28:28.577]                           grepl <- base::grepl
[08:28:28.577]                           restarts <- computeRestarts(cond)
[08:28:28.577]                           for (restart in restarts) {
[08:28:28.577]                             name <- restart$name
[08:28:28.577]                             if (is.null(name)) 
[08:28:28.577]                               next
[08:28:28.577]                             if (!grepl(pattern, name)) 
[08:28:28.577]                               next
[08:28:28.577]                             invokeRestart(restart)
[08:28:28.577]                             muffled <- TRUE
[08:28:28.577]                             break
[08:28:28.577]                           }
[08:28:28.577]                         }
[08:28:28.577]                       }
[08:28:28.577]                       invisible(muffled)
[08:28:28.577]                     }
[08:28:28.577]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.577]                   }
[08:28:28.577]                 }
[08:28:28.577]                 else {
[08:28:28.577]                   if (TRUE) {
[08:28:28.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.577]                     {
[08:28:28.577]                       inherits <- base::inherits
[08:28:28.577]                       invokeRestart <- base::invokeRestart
[08:28:28.577]                       is.null <- base::is.null
[08:28:28.577]                       muffled <- FALSE
[08:28:28.577]                       if (inherits(cond, "message")) {
[08:28:28.577]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.577]                         if (muffled) 
[08:28:28.577]                           invokeRestart("muffleMessage")
[08:28:28.577]                       }
[08:28:28.577]                       else if (inherits(cond, "warning")) {
[08:28:28.577]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.577]                         if (muffled) 
[08:28:28.577]                           invokeRestart("muffleWarning")
[08:28:28.577]                       }
[08:28:28.577]                       else if (inherits(cond, "condition")) {
[08:28:28.577]                         if (!is.null(pattern)) {
[08:28:28.577]                           computeRestarts <- base::computeRestarts
[08:28:28.577]                           grepl <- base::grepl
[08:28:28.577]                           restarts <- computeRestarts(cond)
[08:28:28.577]                           for (restart in restarts) {
[08:28:28.577]                             name <- restart$name
[08:28:28.577]                             if (is.null(name)) 
[08:28:28.577]                               next
[08:28:28.577]                             if (!grepl(pattern, name)) 
[08:28:28.577]                               next
[08:28:28.577]                             invokeRestart(restart)
[08:28:28.577]                             muffled <- TRUE
[08:28:28.577]                             break
[08:28:28.577]                           }
[08:28:28.577]                         }
[08:28:28.577]                       }
[08:28:28.577]                       invisible(muffled)
[08:28:28.577]                     }
[08:28:28.577]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.577]                   }
[08:28:28.577]                 }
[08:28:28.577]             }
[08:28:28.577]         }))
[08:28:28.577]     }, error = function(ex) {
[08:28:28.577]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.577]                 ...future.rng), started = ...future.startTime, 
[08:28:28.577]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.577]             version = "1.8"), class = "FutureResult")
[08:28:28.577]     }, finally = {
[08:28:28.577]         if (!identical(...future.workdir, getwd())) 
[08:28:28.577]             setwd(...future.workdir)
[08:28:28.577]         {
[08:28:28.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.577]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.577]             }
[08:28:28.577]             base::options(...future.oldOptions)
[08:28:28.577]             if (.Platform$OS.type == "windows") {
[08:28:28.577]                 old_names <- names(...future.oldEnvVars)
[08:28:28.577]                 envs <- base::Sys.getenv()
[08:28:28.577]                 names <- names(envs)
[08:28:28.577]                 common <- intersect(names, old_names)
[08:28:28.577]                 added <- setdiff(names, old_names)
[08:28:28.577]                 removed <- setdiff(old_names, names)
[08:28:28.577]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.577]                   envs[common]]
[08:28:28.577]                 NAMES <- toupper(changed)
[08:28:28.577]                 args <- list()
[08:28:28.577]                 for (kk in seq_along(NAMES)) {
[08:28:28.577]                   name <- changed[[kk]]
[08:28:28.577]                   NAME <- NAMES[[kk]]
[08:28:28.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.577]                     next
[08:28:28.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.577]                 }
[08:28:28.577]                 NAMES <- toupper(added)
[08:28:28.577]                 for (kk in seq_along(NAMES)) {
[08:28:28.577]                   name <- added[[kk]]
[08:28:28.577]                   NAME <- NAMES[[kk]]
[08:28:28.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.577]                     next
[08:28:28.577]                   args[[name]] <- ""
[08:28:28.577]                 }
[08:28:28.577]                 NAMES <- toupper(removed)
[08:28:28.577]                 for (kk in seq_along(NAMES)) {
[08:28:28.577]                   name <- removed[[kk]]
[08:28:28.577]                   NAME <- NAMES[[kk]]
[08:28:28.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.577]                     next
[08:28:28.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.577]                 }
[08:28:28.577]                 if (length(args) > 0) 
[08:28:28.577]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.577]             }
[08:28:28.577]             else {
[08:28:28.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.577]             }
[08:28:28.577]             {
[08:28:28.577]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.577]                   0L) {
[08:28:28.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.577]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.577]                   base::options(opts)
[08:28:28.577]                 }
[08:28:28.577]                 {
[08:28:28.577]                   {
[08:28:28.577]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:28.577]                     NULL
[08:28:28.577]                   }
[08:28:28.577]                   options(future.plan = NULL)
[08:28:28.577]                   if (is.na(NA_character_)) 
[08:28:28.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.577]                     .init = FALSE)
[08:28:28.577]                 }
[08:28:28.577]             }
[08:28:28.577]         }
[08:28:28.577]     })
[08:28:28.577]     if (TRUE) {
[08:28:28.577]         base::sink(type = "output", split = FALSE)
[08:28:28.577]         if (TRUE) {
[08:28:28.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.577]         }
[08:28:28.577]         else {
[08:28:28.577]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.577]         }
[08:28:28.577]         base::close(...future.stdout)
[08:28:28.577]         ...future.stdout <- NULL
[08:28:28.577]     }
[08:28:28.577]     ...future.result$conditions <- ...future.conditions
[08:28:28.577]     ...future.result$finished <- base::Sys.time()
[08:28:28.577]     ...future.result
[08:28:28.577] }
[08:28:28.630] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    42L
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 2d485820-dce0-a5ac-1757-5b458766347d
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[1] FALSE
[08:28:28.653] result() for ClusterFuture ...
[08:28:28.654] receiveMessageFromWorker() for ClusterFuture ...
[08:28:28.654] - Validating connection of MultisessionFuture
[08:28:28.663] - received message: FutureResult
[08:28:28.664] - Received FutureResult
[08:28:28.666] - Erased future from FutureRegistry
[08:28:28.666] result() for ClusterFuture ...
[08:28:28.666] - result already collected: FutureResult
[08:28:28.666] result() for ClusterFuture ... done
[08:28:28.666] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:28.667] result() for ClusterFuture ... done
[08:28:28.667] result() for ClusterFuture ...
[08:28:28.667] - result already collected: FutureResult
[08:28:28.667] result() for ClusterFuture ... done
[1] 42
[08:28:28.668] getGlobalsAndPackages() ...
[08:28:28.668] Searching for globals...
[08:28:28.670] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[08:28:28.670] Searching for globals ... DONE
[08:28:28.670] Resolving globals: FALSE
[08:28:28.671] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:28.671] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:28:28.671] - globals: [1] ‘a’
[08:28:28.671] 
[08:28:28.671] getGlobalsAndPackages() ... DONE
[08:28:28.684] Packages needed by the future expression (n = 0): <none>
[08:28:28.684] Packages needed by future strategies (n = 0): <none>
[08:28:28.685] {
[08:28:28.685]     {
[08:28:28.685]         {
[08:28:28.685]             ...future.startTime <- base::Sys.time()
[08:28:28.685]             {
[08:28:28.685]                 {
[08:28:28.685]                   {
[08:28:28.685]                     {
[08:28:28.685]                       base::local({
[08:28:28.685]                         has_future <- base::requireNamespace("future", 
[08:28:28.685]                           quietly = TRUE)
[08:28:28.685]                         if (has_future) {
[08:28:28.685]                           ns <- base::getNamespace("future")
[08:28:28.685]                           version <- ns[[".package"]][["version"]]
[08:28:28.685]                           if (is.null(version)) 
[08:28:28.685]                             version <- utils::packageVersion("future")
[08:28:28.685]                         }
[08:28:28.685]                         else {
[08:28:28.685]                           version <- NULL
[08:28:28.685]                         }
[08:28:28.685]                         if (!has_future || version < "1.8.0") {
[08:28:28.685]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.685]                             "", base::R.version$version.string), 
[08:28:28.685]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:28.685]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.685]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.685]                               "release", "version")], collapse = " "), 
[08:28:28.685]                             hostname = base::Sys.info()[["nodename"]])
[08:28:28.685]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.685]                             info)
[08:28:28.685]                           info <- base::paste(info, collapse = "; ")
[08:28:28.685]                           if (!has_future) {
[08:28:28.685]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.685]                               info)
[08:28:28.685]                           }
[08:28:28.685]                           else {
[08:28:28.685]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.685]                               info, version)
[08:28:28.685]                           }
[08:28:28.685]                           base::stop(msg)
[08:28:28.685]                         }
[08:28:28.685]                       })
[08:28:28.685]                     }
[08:28:28.685]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:28.685]                     base::options(mc.cores = 1L)
[08:28:28.685]                   }
[08:28:28.685]                   ...future.strategy.old <- future::plan("list")
[08:28:28.685]                   options(future.plan = NULL)
[08:28:28.685]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.685]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.685]                 }
[08:28:28.685]                 ...future.workdir <- getwd()
[08:28:28.685]             }
[08:28:28.685]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.685]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.685]         }
[08:28:28.685]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.685]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.685]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.685]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.685]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.685]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.685]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.685]             base::names(...future.oldOptions))
[08:28:28.685]     }
[08:28:28.685]     if (FALSE) {
[08:28:28.685]     }
[08:28:28.685]     else {
[08:28:28.685]         if (TRUE) {
[08:28:28.685]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.685]                 open = "w")
[08:28:28.685]         }
[08:28:28.685]         else {
[08:28:28.685]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.685]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.685]         }
[08:28:28.685]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.685]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.685]             base::sink(type = "output", split = FALSE)
[08:28:28.685]             base::close(...future.stdout)
[08:28:28.685]         }, add = TRUE)
[08:28:28.685]     }
[08:28:28.685]     ...future.frame <- base::sys.nframe()
[08:28:28.685]     ...future.conditions <- base::list()
[08:28:28.685]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.685]     if (FALSE) {
[08:28:28.685]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.685]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.685]     }
[08:28:28.685]     ...future.result <- base::tryCatch({
[08:28:28.685]         base::withCallingHandlers({
[08:28:28.685]             ...future.value <- base::withVisible(base::local({
[08:28:28.685]                 ...future.makeSendCondition <- base::local({
[08:28:28.685]                   sendCondition <- NULL
[08:28:28.685]                   function(frame = 1L) {
[08:28:28.685]                     if (is.function(sendCondition)) 
[08:28:28.685]                       return(sendCondition)
[08:28:28.685]                     ns <- getNamespace("parallel")
[08:28:28.685]                     if (exists("sendData", mode = "function", 
[08:28:28.685]                       envir = ns)) {
[08:28:28.685]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:28.685]                         envir = ns)
[08:28:28.685]                       envir <- sys.frame(frame)
[08:28:28.685]                       master <- NULL
[08:28:28.685]                       while (!identical(envir, .GlobalEnv) && 
[08:28:28.685]                         !identical(envir, emptyenv())) {
[08:28:28.685]                         if (exists("master", mode = "list", envir = envir, 
[08:28:28.685]                           inherits = FALSE)) {
[08:28:28.685]                           master <- get("master", mode = "list", 
[08:28:28.685]                             envir = envir, inherits = FALSE)
[08:28:28.685]                           if (inherits(master, c("SOCKnode", 
[08:28:28.685]                             "SOCK0node"))) {
[08:28:28.685]                             sendCondition <<- function(cond) {
[08:28:28.685]                               data <- list(type = "VALUE", value = cond, 
[08:28:28.685]                                 success = TRUE)
[08:28:28.685]                               parallel_sendData(master, data)
[08:28:28.685]                             }
[08:28:28.685]                             return(sendCondition)
[08:28:28.685]                           }
[08:28:28.685]                         }
[08:28:28.685]                         frame <- frame + 1L
[08:28:28.685]                         envir <- sys.frame(frame)
[08:28:28.685]                       }
[08:28:28.685]                     }
[08:28:28.685]                     sendCondition <<- function(cond) NULL
[08:28:28.685]                   }
[08:28:28.685]                 })
[08:28:28.685]                 withCallingHandlers({
[08:28:28.685]                   {
[08:28:28.685]                     b <- 3
[08:28:28.685]                     c <- 2
[08:28:28.685]                     a * b * c
[08:28:28.685]                   }
[08:28:28.685]                 }, immediateCondition = function(cond) {
[08:28:28.685]                   sendCondition <- ...future.makeSendCondition()
[08:28:28.685]                   sendCondition(cond)
[08:28:28.685]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.685]                   {
[08:28:28.685]                     inherits <- base::inherits
[08:28:28.685]                     invokeRestart <- base::invokeRestart
[08:28:28.685]                     is.null <- base::is.null
[08:28:28.685]                     muffled <- FALSE
[08:28:28.685]                     if (inherits(cond, "message")) {
[08:28:28.685]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:28.685]                       if (muffled) 
[08:28:28.685]                         invokeRestart("muffleMessage")
[08:28:28.685]                     }
[08:28:28.685]                     else if (inherits(cond, "warning")) {
[08:28:28.685]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:28.685]                       if (muffled) 
[08:28:28.685]                         invokeRestart("muffleWarning")
[08:28:28.685]                     }
[08:28:28.685]                     else if (inherits(cond, "condition")) {
[08:28:28.685]                       if (!is.null(pattern)) {
[08:28:28.685]                         computeRestarts <- base::computeRestarts
[08:28:28.685]                         grepl <- base::grepl
[08:28:28.685]                         restarts <- computeRestarts(cond)
[08:28:28.685]                         for (restart in restarts) {
[08:28:28.685]                           name <- restart$name
[08:28:28.685]                           if (is.null(name)) 
[08:28:28.685]                             next
[08:28:28.685]                           if (!grepl(pattern, name)) 
[08:28:28.685]                             next
[08:28:28.685]                           invokeRestart(restart)
[08:28:28.685]                           muffled <- TRUE
[08:28:28.685]                           break
[08:28:28.685]                         }
[08:28:28.685]                       }
[08:28:28.685]                     }
[08:28:28.685]                     invisible(muffled)
[08:28:28.685]                   }
[08:28:28.685]                   muffleCondition(cond)
[08:28:28.685]                 })
[08:28:28.685]             }))
[08:28:28.685]             future::FutureResult(value = ...future.value$value, 
[08:28:28.685]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.685]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.685]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.685]                     ...future.globalenv.names))
[08:28:28.685]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.685]         }, condition = base::local({
[08:28:28.685]             c <- base::c
[08:28:28.685]             inherits <- base::inherits
[08:28:28.685]             invokeRestart <- base::invokeRestart
[08:28:28.685]             length <- base::length
[08:28:28.685]             list <- base::list
[08:28:28.685]             seq.int <- base::seq.int
[08:28:28.685]             signalCondition <- base::signalCondition
[08:28:28.685]             sys.calls <- base::sys.calls
[08:28:28.685]             `[[` <- base::`[[`
[08:28:28.685]             `+` <- base::`+`
[08:28:28.685]             `<<-` <- base::`<<-`
[08:28:28.685]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.685]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.685]                   3L)]
[08:28:28.685]             }
[08:28:28.685]             function(cond) {
[08:28:28.685]                 is_error <- inherits(cond, "error")
[08:28:28.685]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.685]                   NULL)
[08:28:28.685]                 if (is_error) {
[08:28:28.685]                   sessionInformation <- function() {
[08:28:28.685]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.685]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.685]                       search = base::search(), system = base::Sys.info())
[08:28:28.685]                   }
[08:28:28.685]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.685]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.685]                     cond$call), session = sessionInformation(), 
[08:28:28.685]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.685]                   signalCondition(cond)
[08:28:28.685]                 }
[08:28:28.685]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.685]                 "immediateCondition"))) {
[08:28:28.685]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.685]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.685]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.685]                   if (TRUE && !signal) {
[08:28:28.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.685]                     {
[08:28:28.685]                       inherits <- base::inherits
[08:28:28.685]                       invokeRestart <- base::invokeRestart
[08:28:28.685]                       is.null <- base::is.null
[08:28:28.685]                       muffled <- FALSE
[08:28:28.685]                       if (inherits(cond, "message")) {
[08:28:28.685]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.685]                         if (muffled) 
[08:28:28.685]                           invokeRestart("muffleMessage")
[08:28:28.685]                       }
[08:28:28.685]                       else if (inherits(cond, "warning")) {
[08:28:28.685]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.685]                         if (muffled) 
[08:28:28.685]                           invokeRestart("muffleWarning")
[08:28:28.685]                       }
[08:28:28.685]                       else if (inherits(cond, "condition")) {
[08:28:28.685]                         if (!is.null(pattern)) {
[08:28:28.685]                           computeRestarts <- base::computeRestarts
[08:28:28.685]                           grepl <- base::grepl
[08:28:28.685]                           restarts <- computeRestarts(cond)
[08:28:28.685]                           for (restart in restarts) {
[08:28:28.685]                             name <- restart$name
[08:28:28.685]                             if (is.null(name)) 
[08:28:28.685]                               next
[08:28:28.685]                             if (!grepl(pattern, name)) 
[08:28:28.685]                               next
[08:28:28.685]                             invokeRestart(restart)
[08:28:28.685]                             muffled <- TRUE
[08:28:28.685]                             break
[08:28:28.685]                           }
[08:28:28.685]                         }
[08:28:28.685]                       }
[08:28:28.685]                       invisible(muffled)
[08:28:28.685]                     }
[08:28:28.685]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.685]                   }
[08:28:28.685]                 }
[08:28:28.685]                 else {
[08:28:28.685]                   if (TRUE) {
[08:28:28.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.685]                     {
[08:28:28.685]                       inherits <- base::inherits
[08:28:28.685]                       invokeRestart <- base::invokeRestart
[08:28:28.685]                       is.null <- base::is.null
[08:28:28.685]                       muffled <- FALSE
[08:28:28.685]                       if (inherits(cond, "message")) {
[08:28:28.685]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.685]                         if (muffled) 
[08:28:28.685]                           invokeRestart("muffleMessage")
[08:28:28.685]                       }
[08:28:28.685]                       else if (inherits(cond, "warning")) {
[08:28:28.685]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.685]                         if (muffled) 
[08:28:28.685]                           invokeRestart("muffleWarning")
[08:28:28.685]                       }
[08:28:28.685]                       else if (inherits(cond, "condition")) {
[08:28:28.685]                         if (!is.null(pattern)) {
[08:28:28.685]                           computeRestarts <- base::computeRestarts
[08:28:28.685]                           grepl <- base::grepl
[08:28:28.685]                           restarts <- computeRestarts(cond)
[08:28:28.685]                           for (restart in restarts) {
[08:28:28.685]                             name <- restart$name
[08:28:28.685]                             if (is.null(name)) 
[08:28:28.685]                               next
[08:28:28.685]                             if (!grepl(pattern, name)) 
[08:28:28.685]                               next
[08:28:28.685]                             invokeRestart(restart)
[08:28:28.685]                             muffled <- TRUE
[08:28:28.685]                             break
[08:28:28.685]                           }
[08:28:28.685]                         }
[08:28:28.685]                       }
[08:28:28.685]                       invisible(muffled)
[08:28:28.685]                     }
[08:28:28.685]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.685]                   }
[08:28:28.685]                 }
[08:28:28.685]             }
[08:28:28.685]         }))
[08:28:28.685]     }, error = function(ex) {
[08:28:28.685]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.685]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.685]                 ...future.rng), started = ...future.startTime, 
[08:28:28.685]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.685]             version = "1.8"), class = "FutureResult")
[08:28:28.685]     }, finally = {
[08:28:28.685]         if (!identical(...future.workdir, getwd())) 
[08:28:28.685]             setwd(...future.workdir)
[08:28:28.685]         {
[08:28:28.685]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.685]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.685]             }
[08:28:28.685]             base::options(...future.oldOptions)
[08:28:28.685]             if (.Platform$OS.type == "windows") {
[08:28:28.685]                 old_names <- names(...future.oldEnvVars)
[08:28:28.685]                 envs <- base::Sys.getenv()
[08:28:28.685]                 names <- names(envs)
[08:28:28.685]                 common <- intersect(names, old_names)
[08:28:28.685]                 added <- setdiff(names, old_names)
[08:28:28.685]                 removed <- setdiff(old_names, names)
[08:28:28.685]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.685]                   envs[common]]
[08:28:28.685]                 NAMES <- toupper(changed)
[08:28:28.685]                 args <- list()
[08:28:28.685]                 for (kk in seq_along(NAMES)) {
[08:28:28.685]                   name <- changed[[kk]]
[08:28:28.685]                   NAME <- NAMES[[kk]]
[08:28:28.685]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.685]                     next
[08:28:28.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.685]                 }
[08:28:28.685]                 NAMES <- toupper(added)
[08:28:28.685]                 for (kk in seq_along(NAMES)) {
[08:28:28.685]                   name <- added[[kk]]
[08:28:28.685]                   NAME <- NAMES[[kk]]
[08:28:28.685]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.685]                     next
[08:28:28.685]                   args[[name]] <- ""
[08:28:28.685]                 }
[08:28:28.685]                 NAMES <- toupper(removed)
[08:28:28.685]                 for (kk in seq_along(NAMES)) {
[08:28:28.685]                   name <- removed[[kk]]
[08:28:28.685]                   NAME <- NAMES[[kk]]
[08:28:28.685]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.685]                     next
[08:28:28.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.685]                 }
[08:28:28.685]                 if (length(args) > 0) 
[08:28:28.685]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.685]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.685]             }
[08:28:28.685]             else {
[08:28:28.685]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.685]             }
[08:28:28.685]             {
[08:28:28.685]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.685]                   0L) {
[08:28:28.685]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.685]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.685]                   base::options(opts)
[08:28:28.685]                 }
[08:28:28.685]                 {
[08:28:28.685]                   {
[08:28:28.685]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:28.685]                     NULL
[08:28:28.685]                   }
[08:28:28.685]                   options(future.plan = NULL)
[08:28:28.685]                   if (is.na(NA_character_)) 
[08:28:28.685]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.685]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.685]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.685]                     .init = FALSE)
[08:28:28.685]                 }
[08:28:28.685]             }
[08:28:28.685]         }
[08:28:28.685]     })
[08:28:28.685]     if (TRUE) {
[08:28:28.685]         base::sink(type = "output", split = FALSE)
[08:28:28.685]         if (TRUE) {
[08:28:28.685]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.685]         }
[08:28:28.685]         else {
[08:28:28.685]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.685]         }
[08:28:28.685]         base::close(...future.stdout)
[08:28:28.685]         ...future.stdout <- NULL
[08:28:28.685]     }
[08:28:28.685]     ...future.result$conditions <- ...future.conditions
[08:28:28.685]     ...future.result$finished <- base::Sys.time()
[08:28:28.685]     ...future.result
[08:28:28.685] }
[08:28:28.687] Exporting 1 global objects (306 bytes) to cluster node #1 ...
[08:28:28.687] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[08:28:28.688] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[08:28:28.688] Exporting 1 global objects (306 bytes) to cluster node #1 ... DONE
[08:28:28.688] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 39 bytes (numeric ‘a’ of 39 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 2d485820-dce0-a5ac-1757-5b458766347d
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:28.700] result() for ClusterFuture ...
[08:28:28.700] receiveMessageFromWorker() for ClusterFuture ...
[08:28:28.700] - Validating connection of MultisessionFuture
[08:28:28.731] - received message: FutureResult
[08:28:28.731] - Received FutureResult
[08:28:28.731] - Erased future from FutureRegistry
[08:28:28.732] result() for ClusterFuture ...
[08:28:28.732] - result already collected: FutureResult
[08:28:28.732] result() for ClusterFuture ... done
[08:28:28.732] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:28.732] result() for ClusterFuture ... done
[08:28:28.732] result() for ClusterFuture ...
[08:28:28.732] - result already collected: FutureResult
[08:28:28.732] result() for ClusterFuture ... done
[1] 0
*** multisession() with globals and blocking
 - Creating multisession future #2 ...
[08:28:28.734] getGlobalsAndPackages() ...
[08:28:28.734] Searching for globals...
[08:28:28.735] - globals found: [2] ‘{’, ‘ii’
[08:28:28.735] Searching for globals ... DONE
[08:28:28.735] Resolving globals: FALSE
[08:28:28.735] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:28.736] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:28.736] - globals: [1] ‘ii’
[08:28:28.736] 
[08:28:28.736] getGlobalsAndPackages() ... DONE
[08:28:28.751] Packages needed by the future expression (n = 0): <none>
[08:28:28.751] Packages needed by future strategies (n = 0): <none>
[08:28:28.752] {
[08:28:28.752]     {
[08:28:28.752]         {
[08:28:28.752]             ...future.startTime <- base::Sys.time()
[08:28:28.752]             {
[08:28:28.752]                 {
[08:28:28.752]                   {
[08:28:28.752]                     {
[08:28:28.752]                       base::local({
[08:28:28.752]                         has_future <- base::requireNamespace("future", 
[08:28:28.752]                           quietly = TRUE)
[08:28:28.752]                         if (has_future) {
[08:28:28.752]                           ns <- base::getNamespace("future")
[08:28:28.752]                           version <- ns[[".package"]][["version"]]
[08:28:28.752]                           if (is.null(version)) 
[08:28:28.752]                             version <- utils::packageVersion("future")
[08:28:28.752]                         }
[08:28:28.752]                         else {
[08:28:28.752]                           version <- NULL
[08:28:28.752]                         }
[08:28:28.752]                         if (!has_future || version < "1.8.0") {
[08:28:28.752]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.752]                             "", base::R.version$version.string), 
[08:28:28.752]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:28.752]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.752]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.752]                               "release", "version")], collapse = " "), 
[08:28:28.752]                             hostname = base::Sys.info()[["nodename"]])
[08:28:28.752]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.752]                             info)
[08:28:28.752]                           info <- base::paste(info, collapse = "; ")
[08:28:28.752]                           if (!has_future) {
[08:28:28.752]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.752]                               info)
[08:28:28.752]                           }
[08:28:28.752]                           else {
[08:28:28.752]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.752]                               info, version)
[08:28:28.752]                           }
[08:28:28.752]                           base::stop(msg)
[08:28:28.752]                         }
[08:28:28.752]                       })
[08:28:28.752]                     }
[08:28:28.752]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:28.752]                     base::options(mc.cores = 1L)
[08:28:28.752]                   }
[08:28:28.752]                   ...future.strategy.old <- future::plan("list")
[08:28:28.752]                   options(future.plan = NULL)
[08:28:28.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.752]                 }
[08:28:28.752]                 ...future.workdir <- getwd()
[08:28:28.752]             }
[08:28:28.752]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.752]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.752]         }
[08:28:28.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.752]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.752]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.752]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.752]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.752]             base::names(...future.oldOptions))
[08:28:28.752]     }
[08:28:28.752]     if (FALSE) {
[08:28:28.752]     }
[08:28:28.752]     else {
[08:28:28.752]         if (TRUE) {
[08:28:28.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.752]                 open = "w")
[08:28:28.752]         }
[08:28:28.752]         else {
[08:28:28.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.752]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.752]         }
[08:28:28.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.752]             base::sink(type = "output", split = FALSE)
[08:28:28.752]             base::close(...future.stdout)
[08:28:28.752]         }, add = TRUE)
[08:28:28.752]     }
[08:28:28.752]     ...future.frame <- base::sys.nframe()
[08:28:28.752]     ...future.conditions <- base::list()
[08:28:28.752]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.752]     if (FALSE) {
[08:28:28.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.752]     }
[08:28:28.752]     ...future.result <- base::tryCatch({
[08:28:28.752]         base::withCallingHandlers({
[08:28:28.752]             ...future.value <- base::withVisible(base::local({
[08:28:28.752]                 ...future.makeSendCondition <- base::local({
[08:28:28.752]                   sendCondition <- NULL
[08:28:28.752]                   function(frame = 1L) {
[08:28:28.752]                     if (is.function(sendCondition)) 
[08:28:28.752]                       return(sendCondition)
[08:28:28.752]                     ns <- getNamespace("parallel")
[08:28:28.752]                     if (exists("sendData", mode = "function", 
[08:28:28.752]                       envir = ns)) {
[08:28:28.752]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:28.752]                         envir = ns)
[08:28:28.752]                       envir <- sys.frame(frame)
[08:28:28.752]                       master <- NULL
[08:28:28.752]                       while (!identical(envir, .GlobalEnv) && 
[08:28:28.752]                         !identical(envir, emptyenv())) {
[08:28:28.752]                         if (exists("master", mode = "list", envir = envir, 
[08:28:28.752]                           inherits = FALSE)) {
[08:28:28.752]                           master <- get("master", mode = "list", 
[08:28:28.752]                             envir = envir, inherits = FALSE)
[08:28:28.752]                           if (inherits(master, c("SOCKnode", 
[08:28:28.752]                             "SOCK0node"))) {
[08:28:28.752]                             sendCondition <<- function(cond) {
[08:28:28.752]                               data <- list(type = "VALUE", value = cond, 
[08:28:28.752]                                 success = TRUE)
[08:28:28.752]                               parallel_sendData(master, data)
[08:28:28.752]                             }
[08:28:28.752]                             return(sendCondition)
[08:28:28.752]                           }
[08:28:28.752]                         }
[08:28:28.752]                         frame <- frame + 1L
[08:28:28.752]                         envir <- sys.frame(frame)
[08:28:28.752]                       }
[08:28:28.752]                     }
[08:28:28.752]                     sendCondition <<- function(cond) NULL
[08:28:28.752]                   }
[08:28:28.752]                 })
[08:28:28.752]                 withCallingHandlers({
[08:28:28.752]                   {
[08:28:28.752]                     ii
[08:28:28.752]                   }
[08:28:28.752]                 }, immediateCondition = function(cond) {
[08:28:28.752]                   sendCondition <- ...future.makeSendCondition()
[08:28:28.752]                   sendCondition(cond)
[08:28:28.752]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.752]                   {
[08:28:28.752]                     inherits <- base::inherits
[08:28:28.752]                     invokeRestart <- base::invokeRestart
[08:28:28.752]                     is.null <- base::is.null
[08:28:28.752]                     muffled <- FALSE
[08:28:28.752]                     if (inherits(cond, "message")) {
[08:28:28.752]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:28.752]                       if (muffled) 
[08:28:28.752]                         invokeRestart("muffleMessage")
[08:28:28.752]                     }
[08:28:28.752]                     else if (inherits(cond, "warning")) {
[08:28:28.752]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:28.752]                       if (muffled) 
[08:28:28.752]                         invokeRestart("muffleWarning")
[08:28:28.752]                     }
[08:28:28.752]                     else if (inherits(cond, "condition")) {
[08:28:28.752]                       if (!is.null(pattern)) {
[08:28:28.752]                         computeRestarts <- base::computeRestarts
[08:28:28.752]                         grepl <- base::grepl
[08:28:28.752]                         restarts <- computeRestarts(cond)
[08:28:28.752]                         for (restart in restarts) {
[08:28:28.752]                           name <- restart$name
[08:28:28.752]                           if (is.null(name)) 
[08:28:28.752]                             next
[08:28:28.752]                           if (!grepl(pattern, name)) 
[08:28:28.752]                             next
[08:28:28.752]                           invokeRestart(restart)
[08:28:28.752]                           muffled <- TRUE
[08:28:28.752]                           break
[08:28:28.752]                         }
[08:28:28.752]                       }
[08:28:28.752]                     }
[08:28:28.752]                     invisible(muffled)
[08:28:28.752]                   }
[08:28:28.752]                   muffleCondition(cond)
[08:28:28.752]                 })
[08:28:28.752]             }))
[08:28:28.752]             future::FutureResult(value = ...future.value$value, 
[08:28:28.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.752]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.752]                     ...future.globalenv.names))
[08:28:28.752]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.752]         }, condition = base::local({
[08:28:28.752]             c <- base::c
[08:28:28.752]             inherits <- base::inherits
[08:28:28.752]             invokeRestart <- base::invokeRestart
[08:28:28.752]             length <- base::length
[08:28:28.752]             list <- base::list
[08:28:28.752]             seq.int <- base::seq.int
[08:28:28.752]             signalCondition <- base::signalCondition
[08:28:28.752]             sys.calls <- base::sys.calls
[08:28:28.752]             `[[` <- base::`[[`
[08:28:28.752]             `+` <- base::`+`
[08:28:28.752]             `<<-` <- base::`<<-`
[08:28:28.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.752]                   3L)]
[08:28:28.752]             }
[08:28:28.752]             function(cond) {
[08:28:28.752]                 is_error <- inherits(cond, "error")
[08:28:28.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.752]                   NULL)
[08:28:28.752]                 if (is_error) {
[08:28:28.752]                   sessionInformation <- function() {
[08:28:28.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.752]                       search = base::search(), system = base::Sys.info())
[08:28:28.752]                   }
[08:28:28.752]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.752]                     cond$call), session = sessionInformation(), 
[08:28:28.752]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.752]                   signalCondition(cond)
[08:28:28.752]                 }
[08:28:28.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.752]                 "immediateCondition"))) {
[08:28:28.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.752]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.752]                   if (TRUE && !signal) {
[08:28:28.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.752]                     {
[08:28:28.752]                       inherits <- base::inherits
[08:28:28.752]                       invokeRestart <- base::invokeRestart
[08:28:28.752]                       is.null <- base::is.null
[08:28:28.752]                       muffled <- FALSE
[08:28:28.752]                       if (inherits(cond, "message")) {
[08:28:28.752]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.752]                         if (muffled) 
[08:28:28.752]                           invokeRestart("muffleMessage")
[08:28:28.752]                       }
[08:28:28.752]                       else if (inherits(cond, "warning")) {
[08:28:28.752]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.752]                         if (muffled) 
[08:28:28.752]                           invokeRestart("muffleWarning")
[08:28:28.752]                       }
[08:28:28.752]                       else if (inherits(cond, "condition")) {
[08:28:28.752]                         if (!is.null(pattern)) {
[08:28:28.752]                           computeRestarts <- base::computeRestarts
[08:28:28.752]                           grepl <- base::grepl
[08:28:28.752]                           restarts <- computeRestarts(cond)
[08:28:28.752]                           for (restart in restarts) {
[08:28:28.752]                             name <- restart$name
[08:28:28.752]                             if (is.null(name)) 
[08:28:28.752]                               next
[08:28:28.752]                             if (!grepl(pattern, name)) 
[08:28:28.752]                               next
[08:28:28.752]                             invokeRestart(restart)
[08:28:28.752]                             muffled <- TRUE
[08:28:28.752]                             break
[08:28:28.752]                           }
[08:28:28.752]                         }
[08:28:28.752]                       }
[08:28:28.752]                       invisible(muffled)
[08:28:28.752]                     }
[08:28:28.752]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.752]                   }
[08:28:28.752]                 }
[08:28:28.752]                 else {
[08:28:28.752]                   if (TRUE) {
[08:28:28.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.752]                     {
[08:28:28.752]                       inherits <- base::inherits
[08:28:28.752]                       invokeRestart <- base::invokeRestart
[08:28:28.752]                       is.null <- base::is.null
[08:28:28.752]                       muffled <- FALSE
[08:28:28.752]                       if (inherits(cond, "message")) {
[08:28:28.752]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.752]                         if (muffled) 
[08:28:28.752]                           invokeRestart("muffleMessage")
[08:28:28.752]                       }
[08:28:28.752]                       else if (inherits(cond, "warning")) {
[08:28:28.752]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.752]                         if (muffled) 
[08:28:28.752]                           invokeRestart("muffleWarning")
[08:28:28.752]                       }
[08:28:28.752]                       else if (inherits(cond, "condition")) {
[08:28:28.752]                         if (!is.null(pattern)) {
[08:28:28.752]                           computeRestarts <- base::computeRestarts
[08:28:28.752]                           grepl <- base::grepl
[08:28:28.752]                           restarts <- computeRestarts(cond)
[08:28:28.752]                           for (restart in restarts) {
[08:28:28.752]                             name <- restart$name
[08:28:28.752]                             if (is.null(name)) 
[08:28:28.752]                               next
[08:28:28.752]                             if (!grepl(pattern, name)) 
[08:28:28.752]                               next
[08:28:28.752]                             invokeRestart(restart)
[08:28:28.752]                             muffled <- TRUE
[08:28:28.752]                             break
[08:28:28.752]                           }
[08:28:28.752]                         }
[08:28:28.752]                       }
[08:28:28.752]                       invisible(muffled)
[08:28:28.752]                     }
[08:28:28.752]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.752]                   }
[08:28:28.752]                 }
[08:28:28.752]             }
[08:28:28.752]         }))
[08:28:28.752]     }, error = function(ex) {
[08:28:28.752]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.752]                 ...future.rng), started = ...future.startTime, 
[08:28:28.752]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.752]             version = "1.8"), class = "FutureResult")
[08:28:28.752]     }, finally = {
[08:28:28.752]         if (!identical(...future.workdir, getwd())) 
[08:28:28.752]             setwd(...future.workdir)
[08:28:28.752]         {
[08:28:28.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.752]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.752]             }
[08:28:28.752]             base::options(...future.oldOptions)
[08:28:28.752]             if (.Platform$OS.type == "windows") {
[08:28:28.752]                 old_names <- names(...future.oldEnvVars)
[08:28:28.752]                 envs <- base::Sys.getenv()
[08:28:28.752]                 names <- names(envs)
[08:28:28.752]                 common <- intersect(names, old_names)
[08:28:28.752]                 added <- setdiff(names, old_names)
[08:28:28.752]                 removed <- setdiff(old_names, names)
[08:28:28.752]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.752]                   envs[common]]
[08:28:28.752]                 NAMES <- toupper(changed)
[08:28:28.752]                 args <- list()
[08:28:28.752]                 for (kk in seq_along(NAMES)) {
[08:28:28.752]                   name <- changed[[kk]]
[08:28:28.752]                   NAME <- NAMES[[kk]]
[08:28:28.752]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.752]                     next
[08:28:28.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.752]                 }
[08:28:28.752]                 NAMES <- toupper(added)
[08:28:28.752]                 for (kk in seq_along(NAMES)) {
[08:28:28.752]                   name <- added[[kk]]
[08:28:28.752]                   NAME <- NAMES[[kk]]
[08:28:28.752]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.752]                     next
[08:28:28.752]                   args[[name]] <- ""
[08:28:28.752]                 }
[08:28:28.752]                 NAMES <- toupper(removed)
[08:28:28.752]                 for (kk in seq_along(NAMES)) {
[08:28:28.752]                   name <- removed[[kk]]
[08:28:28.752]                   NAME <- NAMES[[kk]]
[08:28:28.752]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.752]                     next
[08:28:28.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.752]                 }
[08:28:28.752]                 if (length(args) > 0) 
[08:28:28.752]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.752]             }
[08:28:28.752]             else {
[08:28:28.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.752]             }
[08:28:28.752]             {
[08:28:28.752]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.752]                   0L) {
[08:28:28.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.752]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.752]                   base::options(opts)
[08:28:28.752]                 }
[08:28:28.752]                 {
[08:28:28.752]                   {
[08:28:28.752]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:28.752]                     NULL
[08:28:28.752]                   }
[08:28:28.752]                   options(future.plan = NULL)
[08:28:28.752]                   if (is.na(NA_character_)) 
[08:28:28.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.752]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.752]                     .init = FALSE)
[08:28:28.752]                 }
[08:28:28.752]             }
[08:28:28.752]         }
[08:28:28.752]     })
[08:28:28.752]     if (TRUE) {
[08:28:28.752]         base::sink(type = "output", split = FALSE)
[08:28:28.752]         if (TRUE) {
[08:28:28.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.752]         }
[08:28:28.752]         else {
[08:28:28.752]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.752]         }
[08:28:28.752]         base::close(...future.stdout)
[08:28:28.752]         ...future.stdout <- NULL
[08:28:28.752]     }
[08:28:28.752]     ...future.result$conditions <- ...future.conditions
[08:28:28.752]     ...future.result$finished <- base::Sys.time()
[08:28:28.752]     ...future.result
[08:28:28.752] }
[08:28:28.758] Exporting 1 global objects (304 bytes) to cluster node #1 ...
[08:28:28.758] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:28:28.759] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:28:28.759] Exporting 1 global objects (304 bytes) to cluster node #1 ... DONE
[08:28:28.759] MultisessionFuture started
 - Creating multisession future #1 ...
[08:28:28.761] getGlobalsAndPackages() ...
[08:28:28.761] Searching for globals...
[08:28:28.762] - globals found: [2] ‘{’, ‘ii’
[08:28:28.762] Searching for globals ... DONE
[08:28:28.762] Resolving globals: FALSE
[08:28:28.763] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:28.763] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:28.763] - globals: [1] ‘ii’
[08:28:28.763] 
[08:28:28.764] getGlobalsAndPackages() ... DONE
[08:28:28.777] Packages needed by the future expression (n = 0): <none>
[08:28:28.777] Packages needed by future strategies (n = 0): <none>
[08:28:28.777] {
[08:28:28.777]     {
[08:28:28.777]         {
[08:28:28.777]             ...future.startTime <- base::Sys.time()
[08:28:28.777]             {
[08:28:28.777]                 {
[08:28:28.777]                   {
[08:28:28.777]                     {
[08:28:28.777]                       base::local({
[08:28:28.777]                         has_future <- base::requireNamespace("future", 
[08:28:28.777]                           quietly = TRUE)
[08:28:28.777]                         if (has_future) {
[08:28:28.777]                           ns <- base::getNamespace("future")
[08:28:28.777]                           version <- ns[[".package"]][["version"]]
[08:28:28.777]                           if (is.null(version)) 
[08:28:28.777]                             version <- utils::packageVersion("future")
[08:28:28.777]                         }
[08:28:28.777]                         else {
[08:28:28.777]                           version <- NULL
[08:28:28.777]                         }
[08:28:28.777]                         if (!has_future || version < "1.8.0") {
[08:28:28.777]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.777]                             "", base::R.version$version.string), 
[08:28:28.777]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:28.777]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.777]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.777]                               "release", "version")], collapse = " "), 
[08:28:28.777]                             hostname = base::Sys.info()[["nodename"]])
[08:28:28.777]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.777]                             info)
[08:28:28.777]                           info <- base::paste(info, collapse = "; ")
[08:28:28.777]                           if (!has_future) {
[08:28:28.777]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.777]                               info)
[08:28:28.777]                           }
[08:28:28.777]                           else {
[08:28:28.777]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.777]                               info, version)
[08:28:28.777]                           }
[08:28:28.777]                           base::stop(msg)
[08:28:28.777]                         }
[08:28:28.777]                       })
[08:28:28.777]                     }
[08:28:28.777]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:28.777]                     base::options(mc.cores = 1L)
[08:28:28.777]                   }
[08:28:28.777]                   ...future.strategy.old <- future::plan("list")
[08:28:28.777]                   options(future.plan = NULL)
[08:28:28.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.777]                 }
[08:28:28.777]                 ...future.workdir <- getwd()
[08:28:28.777]             }
[08:28:28.777]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.777]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.777]         }
[08:28:28.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.777]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.777]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.777]             base::names(...future.oldOptions))
[08:28:28.777]     }
[08:28:28.777]     if (FALSE) {
[08:28:28.777]     }
[08:28:28.777]     else {
[08:28:28.777]         if (TRUE) {
[08:28:28.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.777]                 open = "w")
[08:28:28.777]         }
[08:28:28.777]         else {
[08:28:28.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.777]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.777]         }
[08:28:28.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.777]             base::sink(type = "output", split = FALSE)
[08:28:28.777]             base::close(...future.stdout)
[08:28:28.777]         }, add = TRUE)
[08:28:28.777]     }
[08:28:28.777]     ...future.frame <- base::sys.nframe()
[08:28:28.777]     ...future.conditions <- base::list()
[08:28:28.777]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.777]     if (FALSE) {
[08:28:28.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.777]     }
[08:28:28.777]     ...future.result <- base::tryCatch({
[08:28:28.777]         base::withCallingHandlers({
[08:28:28.777]             ...future.value <- base::withVisible(base::local({
[08:28:28.777]                 ...future.makeSendCondition <- base::local({
[08:28:28.777]                   sendCondition <- NULL
[08:28:28.777]                   function(frame = 1L) {
[08:28:28.777]                     if (is.function(sendCondition)) 
[08:28:28.777]                       return(sendCondition)
[08:28:28.777]                     ns <- getNamespace("parallel")
[08:28:28.777]                     if (exists("sendData", mode = "function", 
[08:28:28.777]                       envir = ns)) {
[08:28:28.777]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:28.777]                         envir = ns)
[08:28:28.777]                       envir <- sys.frame(frame)
[08:28:28.777]                       master <- NULL
[08:28:28.777]                       while (!identical(envir, .GlobalEnv) && 
[08:28:28.777]                         !identical(envir, emptyenv())) {
[08:28:28.777]                         if (exists("master", mode = "list", envir = envir, 
[08:28:28.777]                           inherits = FALSE)) {
[08:28:28.777]                           master <- get("master", mode = "list", 
[08:28:28.777]                             envir = envir, inherits = FALSE)
[08:28:28.777]                           if (inherits(master, c("SOCKnode", 
[08:28:28.777]                             "SOCK0node"))) {
[08:28:28.777]                             sendCondition <<- function(cond) {
[08:28:28.777]                               data <- list(type = "VALUE", value = cond, 
[08:28:28.777]                                 success = TRUE)
[08:28:28.777]                               parallel_sendData(master, data)
[08:28:28.777]                             }
[08:28:28.777]                             return(sendCondition)
[08:28:28.777]                           }
[08:28:28.777]                         }
[08:28:28.777]                         frame <- frame + 1L
[08:28:28.777]                         envir <- sys.frame(frame)
[08:28:28.777]                       }
[08:28:28.777]                     }
[08:28:28.777]                     sendCondition <<- function(cond) NULL
[08:28:28.777]                   }
[08:28:28.777]                 })
[08:28:28.777]                 withCallingHandlers({
[08:28:28.777]                   {
[08:28:28.777]                     ii
[08:28:28.777]                   }
[08:28:28.777]                 }, immediateCondition = function(cond) {
[08:28:28.777]                   sendCondition <- ...future.makeSendCondition()
[08:28:28.777]                   sendCondition(cond)
[08:28:28.777]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.777]                   {
[08:28:28.777]                     inherits <- base::inherits
[08:28:28.777]                     invokeRestart <- base::invokeRestart
[08:28:28.777]                     is.null <- base::is.null
[08:28:28.777]                     muffled <- FALSE
[08:28:28.777]                     if (inherits(cond, "message")) {
[08:28:28.777]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:28.777]                       if (muffled) 
[08:28:28.777]                         invokeRestart("muffleMessage")
[08:28:28.777]                     }
[08:28:28.777]                     else if (inherits(cond, "warning")) {
[08:28:28.777]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:28.777]                       if (muffled) 
[08:28:28.777]                         invokeRestart("muffleWarning")
[08:28:28.777]                     }
[08:28:28.777]                     else if (inherits(cond, "condition")) {
[08:28:28.777]                       if (!is.null(pattern)) {
[08:28:28.777]                         computeRestarts <- base::computeRestarts
[08:28:28.777]                         grepl <- base::grepl
[08:28:28.777]                         restarts <- computeRestarts(cond)
[08:28:28.777]                         for (restart in restarts) {
[08:28:28.777]                           name <- restart$name
[08:28:28.777]                           if (is.null(name)) 
[08:28:28.777]                             next
[08:28:28.777]                           if (!grepl(pattern, name)) 
[08:28:28.777]                             next
[08:28:28.777]                           invokeRestart(restart)
[08:28:28.777]                           muffled <- TRUE
[08:28:28.777]                           break
[08:28:28.777]                         }
[08:28:28.777]                       }
[08:28:28.777]                     }
[08:28:28.777]                     invisible(muffled)
[08:28:28.777]                   }
[08:28:28.777]                   muffleCondition(cond)
[08:28:28.777]                 })
[08:28:28.777]             }))
[08:28:28.777]             future::FutureResult(value = ...future.value$value, 
[08:28:28.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.777]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.777]                     ...future.globalenv.names))
[08:28:28.777]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.777]         }, condition = base::local({
[08:28:28.777]             c <- base::c
[08:28:28.777]             inherits <- base::inherits
[08:28:28.777]             invokeRestart <- base::invokeRestart
[08:28:28.777]             length <- base::length
[08:28:28.777]             list <- base::list
[08:28:28.777]             seq.int <- base::seq.int
[08:28:28.777]             signalCondition <- base::signalCondition
[08:28:28.777]             sys.calls <- base::sys.calls
[08:28:28.777]             `[[` <- base::`[[`
[08:28:28.777]             `+` <- base::`+`
[08:28:28.777]             `<<-` <- base::`<<-`
[08:28:28.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.777]                   3L)]
[08:28:28.777]             }
[08:28:28.777]             function(cond) {
[08:28:28.777]                 is_error <- inherits(cond, "error")
[08:28:28.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.777]                   NULL)
[08:28:28.777]                 if (is_error) {
[08:28:28.777]                   sessionInformation <- function() {
[08:28:28.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.777]                       search = base::search(), system = base::Sys.info())
[08:28:28.777]                   }
[08:28:28.777]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.777]                     cond$call), session = sessionInformation(), 
[08:28:28.777]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.777]                   signalCondition(cond)
[08:28:28.777]                 }
[08:28:28.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.777]                 "immediateCondition"))) {
[08:28:28.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.777]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.777]                   if (TRUE && !signal) {
[08:28:28.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.777]                     {
[08:28:28.777]                       inherits <- base::inherits
[08:28:28.777]                       invokeRestart <- base::invokeRestart
[08:28:28.777]                       is.null <- base::is.null
[08:28:28.777]                       muffled <- FALSE
[08:28:28.777]                       if (inherits(cond, "message")) {
[08:28:28.777]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.777]                         if (muffled) 
[08:28:28.777]                           invokeRestart("muffleMessage")
[08:28:28.777]                       }
[08:28:28.777]                       else if (inherits(cond, "warning")) {
[08:28:28.777]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.777]                         if (muffled) 
[08:28:28.777]                           invokeRestart("muffleWarning")
[08:28:28.777]                       }
[08:28:28.777]                       else if (inherits(cond, "condition")) {
[08:28:28.777]                         if (!is.null(pattern)) {
[08:28:28.777]                           computeRestarts <- base::computeRestarts
[08:28:28.777]                           grepl <- base::grepl
[08:28:28.777]                           restarts <- computeRestarts(cond)
[08:28:28.777]                           for (restart in restarts) {
[08:28:28.777]                             name <- restart$name
[08:28:28.777]                             if (is.null(name)) 
[08:28:28.777]                               next
[08:28:28.777]                             if (!grepl(pattern, name)) 
[08:28:28.777]                               next
[08:28:28.777]                             invokeRestart(restart)
[08:28:28.777]                             muffled <- TRUE
[08:28:28.777]                             break
[08:28:28.777]                           }
[08:28:28.777]                         }
[08:28:28.777]                       }
[08:28:28.777]                       invisible(muffled)
[08:28:28.777]                     }
[08:28:28.777]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.777]                   }
[08:28:28.777]                 }
[08:28:28.777]                 else {
[08:28:28.777]                   if (TRUE) {
[08:28:28.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.777]                     {
[08:28:28.777]                       inherits <- base::inherits
[08:28:28.777]                       invokeRestart <- base::invokeRestart
[08:28:28.777]                       is.null <- base::is.null
[08:28:28.777]                       muffled <- FALSE
[08:28:28.777]                       if (inherits(cond, "message")) {
[08:28:28.777]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.777]                         if (muffled) 
[08:28:28.777]                           invokeRestart("muffleMessage")
[08:28:28.777]                       }
[08:28:28.777]                       else if (inherits(cond, "warning")) {
[08:28:28.777]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.777]                         if (muffled) 
[08:28:28.777]                           invokeRestart("muffleWarning")
[08:28:28.777]                       }
[08:28:28.777]                       else if (inherits(cond, "condition")) {
[08:28:28.777]                         if (!is.null(pattern)) {
[08:28:28.777]                           computeRestarts <- base::computeRestarts
[08:28:28.777]                           grepl <- base::grepl
[08:28:28.777]                           restarts <- computeRestarts(cond)
[08:28:28.777]                           for (restart in restarts) {
[08:28:28.777]                             name <- restart$name
[08:28:28.777]                             if (is.null(name)) 
[08:28:28.777]                               next
[08:28:28.777]                             if (!grepl(pattern, name)) 
[08:28:28.777]                               next
[08:28:28.777]                             invokeRestart(restart)
[08:28:28.777]                             muffled <- TRUE
[08:28:28.777]                             break
[08:28:28.777]                           }
[08:28:28.777]                         }
[08:28:28.777]                       }
[08:28:28.777]                       invisible(muffled)
[08:28:28.777]                     }
[08:28:28.777]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.777]                   }
[08:28:28.777]                 }
[08:28:28.777]             }
[08:28:28.777]         }))
[08:28:28.777]     }, error = function(ex) {
[08:28:28.777]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.777]                 ...future.rng), started = ...future.startTime, 
[08:28:28.777]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.777]             version = "1.8"), class = "FutureResult")
[08:28:28.777]     }, finally = {
[08:28:28.777]         if (!identical(...future.workdir, getwd())) 
[08:28:28.777]             setwd(...future.workdir)
[08:28:28.777]         {
[08:28:28.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.777]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.777]             }
[08:28:28.777]             base::options(...future.oldOptions)
[08:28:28.777]             if (.Platform$OS.type == "windows") {
[08:28:28.777]                 old_names <- names(...future.oldEnvVars)
[08:28:28.777]                 envs <- base::Sys.getenv()
[08:28:28.777]                 names <- names(envs)
[08:28:28.777]                 common <- intersect(names, old_names)
[08:28:28.777]                 added <- setdiff(names, old_names)
[08:28:28.777]                 removed <- setdiff(old_names, names)
[08:28:28.777]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.777]                   envs[common]]
[08:28:28.777]                 NAMES <- toupper(changed)
[08:28:28.777]                 args <- list()
[08:28:28.777]                 for (kk in seq_along(NAMES)) {
[08:28:28.777]                   name <- changed[[kk]]
[08:28:28.777]                   NAME <- NAMES[[kk]]
[08:28:28.777]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.777]                     next
[08:28:28.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.777]                 }
[08:28:28.777]                 NAMES <- toupper(added)
[08:28:28.777]                 for (kk in seq_along(NAMES)) {
[08:28:28.777]                   name <- added[[kk]]
[08:28:28.777]                   NAME <- NAMES[[kk]]
[08:28:28.777]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.777]                     next
[08:28:28.777]                   args[[name]] <- ""
[08:28:28.777]                 }
[08:28:28.777]                 NAMES <- toupper(removed)
[08:28:28.777]                 for (kk in seq_along(NAMES)) {
[08:28:28.777]                   name <- removed[[kk]]
[08:28:28.777]                   NAME <- NAMES[[kk]]
[08:28:28.777]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.777]                     next
[08:28:28.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.777]                 }
[08:28:28.777]                 if (length(args) > 0) 
[08:28:28.777]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.777]             }
[08:28:28.777]             else {
[08:28:28.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.777]             }
[08:28:28.777]             {
[08:28:28.777]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.777]                   0L) {
[08:28:28.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.777]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.777]                   base::options(opts)
[08:28:28.777]                 }
[08:28:28.777]                 {
[08:28:28.777]                   {
[08:28:28.777]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:28.777]                     NULL
[08:28:28.777]                   }
[08:28:28.777]                   options(future.plan = NULL)
[08:28:28.777]                   if (is.na(NA_character_)) 
[08:28:28.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.777]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.777]                     .init = FALSE)
[08:28:28.777]                 }
[08:28:28.777]             }
[08:28:28.777]         }
[08:28:28.777]     })
[08:28:28.777]     if (TRUE) {
[08:28:28.777]         base::sink(type = "output", split = FALSE)
[08:28:28.777]         if (TRUE) {
[08:28:28.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.777]         }
[08:28:28.777]         else {
[08:28:28.777]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.777]         }
[08:28:28.777]         base::close(...future.stdout)
[08:28:28.777]         ...future.stdout <- NULL
[08:28:28.777]     }
[08:28:28.777]     ...future.result$conditions <- ...future.conditions
[08:28:28.777]     ...future.result$finished <- base::Sys.time()
[08:28:28.777]     ...future.result
[08:28:28.777] }
[08:28:28.832] Exporting 1 global objects (304 bytes) to cluster node #2 ...
[08:28:28.832] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[08:28:28.832] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[08:28:28.833] Exporting 1 global objects (304 bytes) to cluster node #2 ... DONE
[08:28:28.833] MultisessionFuture started
 - Resolving 2 multisession futures
[08:28:28.834] result() for ClusterFuture ...
[08:28:28.834] receiveMessageFromWorker() for ClusterFuture ...
[08:28:28.834] - Validating connection of MultisessionFuture
[08:28:28.906] - received message: FutureResult
[08:28:28.906] - Received FutureResult
[08:28:28.907] - Erased future from FutureRegistry
[08:28:28.907] result() for ClusterFuture ...
[08:28:28.907] - result already collected: FutureResult
[08:28:28.907] result() for ClusterFuture ... done
[08:28:28.907] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:28.907] result() for ClusterFuture ... done
[08:28:28.907] result() for ClusterFuture ...
[08:28:28.907] - result already collected: FutureResult
[08:28:28.908] result() for ClusterFuture ... done
[08:28:28.908] result() for ClusterFuture ...
[08:28:28.908] receiveMessageFromWorker() for ClusterFuture ...
[08:28:28.908] - Validating connection of MultisessionFuture
[08:28:28.908] - received message: FutureResult
[08:28:28.908] - Received FutureResult
[08:28:28.908] - Erased future from FutureRegistry
[08:28:28.909] result() for ClusterFuture ...
[08:28:28.909] - result already collected: FutureResult
[08:28:28.909] result() for ClusterFuture ... done
[08:28:28.909] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:28.909] result() for ClusterFuture ... done
[08:28:28.909] result() for ClusterFuture ...
[08:28:28.909] - result already collected: FutureResult
[08:28:28.909] result() for ClusterFuture ... done
*** multisession() - workers inherit .libPaths()
[08:28:28.910] getGlobalsAndPackages() ...
[08:28:28.910] Searching for globals...
[08:28:28.910] - globals found: [1] ‘.libPaths’
[08:28:28.910] Searching for globals ... DONE
[08:28:28.911] Resolving globals: FALSE
[08:28:28.911] 
[08:28:28.911] 
[08:28:28.911] getGlobalsAndPackages() ... DONE
[08:28:28.911] run() for ‘Future’ ...
[08:28:28.912] - state: ‘created’
[08:28:28.912] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:28.912] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:28.912] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:28.912]   - Field: ‘label’
[08:28:28.912]   - Field: ‘local’
[08:28:28.913]   - Field: ‘owner’
[08:28:28.913]   - Field: ‘envir’
[08:28:28.913]   - Field: ‘packages’
[08:28:28.913]   - Field: ‘gc’
[08:28:28.913]   - Field: ‘conditions’
[08:28:28.913]   - Field: ‘expr’
[08:28:28.913]   - Field: ‘uuid’
[08:28:28.913]   - Field: ‘seed’
[08:28:28.913]   - Field: ‘version’
[08:28:28.914]   - Field: ‘result’
[08:28:28.914]   - Field: ‘asynchronous’
[08:28:28.914]   - Field: ‘calls’
[08:28:28.914]   - Field: ‘globals’
[08:28:28.914]   - Field: ‘stdout’
[08:28:28.914]   - Field: ‘earlySignal’
[08:28:28.914]   - Field: ‘lazy’
[08:28:28.914]   - Field: ‘state’
[08:28:28.914] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:28.915] - Launch lazy future ...
[08:28:28.915] Packages needed by the future expression (n = 0): <none>
[08:28:28.915] Packages needed by future strategies (n = 0): <none>
[08:28:28.915] {
[08:28:28.915]     {
[08:28:28.915]         {
[08:28:28.915]             ...future.startTime <- base::Sys.time()
[08:28:28.915]             {
[08:28:28.915]                 {
[08:28:28.915]                   {
[08:28:28.915]                     base::local({
[08:28:28.915]                       has_future <- base::requireNamespace("future", 
[08:28:28.915]                         quietly = TRUE)
[08:28:28.915]                       if (has_future) {
[08:28:28.915]                         ns <- base::getNamespace("future")
[08:28:28.915]                         version <- ns[[".package"]][["version"]]
[08:28:28.915]                         if (is.null(version)) 
[08:28:28.915]                           version <- utils::packageVersion("future")
[08:28:28.915]                       }
[08:28:28.915]                       else {
[08:28:28.915]                         version <- NULL
[08:28:28.915]                       }
[08:28:28.915]                       if (!has_future || version < "1.8.0") {
[08:28:28.915]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.915]                           "", base::R.version$version.string), 
[08:28:28.915]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:28.915]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.915]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.915]                             "release", "version")], collapse = " "), 
[08:28:28.915]                           hostname = base::Sys.info()[["nodename"]])
[08:28:28.915]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.915]                           info)
[08:28:28.915]                         info <- base::paste(info, collapse = "; ")
[08:28:28.915]                         if (!has_future) {
[08:28:28.915]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.915]                             info)
[08:28:28.915]                         }
[08:28:28.915]                         else {
[08:28:28.915]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.915]                             info, version)
[08:28:28.915]                         }
[08:28:28.915]                         base::stop(msg)
[08:28:28.915]                       }
[08:28:28.915]                     })
[08:28:28.915]                   }
[08:28:28.915]                   ...future.strategy.old <- future::plan("list")
[08:28:28.915]                   options(future.plan = NULL)
[08:28:28.915]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.915]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.915]                 }
[08:28:28.915]                 ...future.workdir <- getwd()
[08:28:28.915]             }
[08:28:28.915]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.915]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.915]         }
[08:28:28.915]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.915]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.915]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.915]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.915]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.915]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.915]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.915]             base::names(...future.oldOptions))
[08:28:28.915]     }
[08:28:28.915]     if (FALSE) {
[08:28:28.915]     }
[08:28:28.915]     else {
[08:28:28.915]         if (TRUE) {
[08:28:28.915]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.915]                 open = "w")
[08:28:28.915]         }
[08:28:28.915]         else {
[08:28:28.915]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.915]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.915]         }
[08:28:28.915]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.915]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.915]             base::sink(type = "output", split = FALSE)
[08:28:28.915]             base::close(...future.stdout)
[08:28:28.915]         }, add = TRUE)
[08:28:28.915]     }
[08:28:28.915]     ...future.frame <- base::sys.nframe()
[08:28:28.915]     ...future.conditions <- base::list()
[08:28:28.915]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.915]     if (FALSE) {
[08:28:28.915]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.915]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.915]     }
[08:28:28.915]     ...future.result <- base::tryCatch({
[08:28:28.915]         base::withCallingHandlers({
[08:28:28.915]             ...future.value <- base::withVisible(base::local(.libPaths()))
[08:28:28.915]             future::FutureResult(value = ...future.value$value, 
[08:28:28.915]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.915]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.915]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.915]                     ...future.globalenv.names))
[08:28:28.915]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.915]         }, condition = base::local({
[08:28:28.915]             c <- base::c
[08:28:28.915]             inherits <- base::inherits
[08:28:28.915]             invokeRestart <- base::invokeRestart
[08:28:28.915]             length <- base::length
[08:28:28.915]             list <- base::list
[08:28:28.915]             seq.int <- base::seq.int
[08:28:28.915]             signalCondition <- base::signalCondition
[08:28:28.915]             sys.calls <- base::sys.calls
[08:28:28.915]             `[[` <- base::`[[`
[08:28:28.915]             `+` <- base::`+`
[08:28:28.915]             `<<-` <- base::`<<-`
[08:28:28.915]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.915]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.915]                   3L)]
[08:28:28.915]             }
[08:28:28.915]             function(cond) {
[08:28:28.915]                 is_error <- inherits(cond, "error")
[08:28:28.915]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.915]                   NULL)
[08:28:28.915]                 if (is_error) {
[08:28:28.915]                   sessionInformation <- function() {
[08:28:28.915]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.915]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.915]                       search = base::search(), system = base::Sys.info())
[08:28:28.915]                   }
[08:28:28.915]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.915]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.915]                     cond$call), session = sessionInformation(), 
[08:28:28.915]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.915]                   signalCondition(cond)
[08:28:28.915]                 }
[08:28:28.915]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.915]                 "immediateCondition"))) {
[08:28:28.915]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.915]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.915]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.915]                   if (TRUE && !signal) {
[08:28:28.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.915]                     {
[08:28:28.915]                       inherits <- base::inherits
[08:28:28.915]                       invokeRestart <- base::invokeRestart
[08:28:28.915]                       is.null <- base::is.null
[08:28:28.915]                       muffled <- FALSE
[08:28:28.915]                       if (inherits(cond, "message")) {
[08:28:28.915]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.915]                         if (muffled) 
[08:28:28.915]                           invokeRestart("muffleMessage")
[08:28:28.915]                       }
[08:28:28.915]                       else if (inherits(cond, "warning")) {
[08:28:28.915]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.915]                         if (muffled) 
[08:28:28.915]                           invokeRestart("muffleWarning")
[08:28:28.915]                       }
[08:28:28.915]                       else if (inherits(cond, "condition")) {
[08:28:28.915]                         if (!is.null(pattern)) {
[08:28:28.915]                           computeRestarts <- base::computeRestarts
[08:28:28.915]                           grepl <- base::grepl
[08:28:28.915]                           restarts <- computeRestarts(cond)
[08:28:28.915]                           for (restart in restarts) {
[08:28:28.915]                             name <- restart$name
[08:28:28.915]                             if (is.null(name)) 
[08:28:28.915]                               next
[08:28:28.915]                             if (!grepl(pattern, name)) 
[08:28:28.915]                               next
[08:28:28.915]                             invokeRestart(restart)
[08:28:28.915]                             muffled <- TRUE
[08:28:28.915]                             break
[08:28:28.915]                           }
[08:28:28.915]                         }
[08:28:28.915]                       }
[08:28:28.915]                       invisible(muffled)
[08:28:28.915]                     }
[08:28:28.915]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.915]                   }
[08:28:28.915]                 }
[08:28:28.915]                 else {
[08:28:28.915]                   if (TRUE) {
[08:28:28.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.915]                     {
[08:28:28.915]                       inherits <- base::inherits
[08:28:28.915]                       invokeRestart <- base::invokeRestart
[08:28:28.915]                       is.null <- base::is.null
[08:28:28.915]                       muffled <- FALSE
[08:28:28.915]                       if (inherits(cond, "message")) {
[08:28:28.915]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.915]                         if (muffled) 
[08:28:28.915]                           invokeRestart("muffleMessage")
[08:28:28.915]                       }
[08:28:28.915]                       else if (inherits(cond, "warning")) {
[08:28:28.915]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.915]                         if (muffled) 
[08:28:28.915]                           invokeRestart("muffleWarning")
[08:28:28.915]                       }
[08:28:28.915]                       else if (inherits(cond, "condition")) {
[08:28:28.915]                         if (!is.null(pattern)) {
[08:28:28.915]                           computeRestarts <- base::computeRestarts
[08:28:28.915]                           grepl <- base::grepl
[08:28:28.915]                           restarts <- computeRestarts(cond)
[08:28:28.915]                           for (restart in restarts) {
[08:28:28.915]                             name <- restart$name
[08:28:28.915]                             if (is.null(name)) 
[08:28:28.915]                               next
[08:28:28.915]                             if (!grepl(pattern, name)) 
[08:28:28.915]                               next
[08:28:28.915]                             invokeRestart(restart)
[08:28:28.915]                             muffled <- TRUE
[08:28:28.915]                             break
[08:28:28.915]                           }
[08:28:28.915]                         }
[08:28:28.915]                       }
[08:28:28.915]                       invisible(muffled)
[08:28:28.915]                     }
[08:28:28.915]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.915]                   }
[08:28:28.915]                 }
[08:28:28.915]             }
[08:28:28.915]         }))
[08:28:28.915]     }, error = function(ex) {
[08:28:28.915]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.915]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.915]                 ...future.rng), started = ...future.startTime, 
[08:28:28.915]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.915]             version = "1.8"), class = "FutureResult")
[08:28:28.915]     }, finally = {
[08:28:28.915]         if (!identical(...future.workdir, getwd())) 
[08:28:28.915]             setwd(...future.workdir)
[08:28:28.915]         {
[08:28:28.915]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.915]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.915]             }
[08:28:28.915]             base::options(...future.oldOptions)
[08:28:28.915]             if (.Platform$OS.type == "windows") {
[08:28:28.915]                 old_names <- names(...future.oldEnvVars)
[08:28:28.915]                 envs <- base::Sys.getenv()
[08:28:28.915]                 names <- names(envs)
[08:28:28.915]                 common <- intersect(names, old_names)
[08:28:28.915]                 added <- setdiff(names, old_names)
[08:28:28.915]                 removed <- setdiff(old_names, names)
[08:28:28.915]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.915]                   envs[common]]
[08:28:28.915]                 NAMES <- toupper(changed)
[08:28:28.915]                 args <- list()
[08:28:28.915]                 for (kk in seq_along(NAMES)) {
[08:28:28.915]                   name <- changed[[kk]]
[08:28:28.915]                   NAME <- NAMES[[kk]]
[08:28:28.915]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.915]                     next
[08:28:28.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.915]                 }
[08:28:28.915]                 NAMES <- toupper(added)
[08:28:28.915]                 for (kk in seq_along(NAMES)) {
[08:28:28.915]                   name <- added[[kk]]
[08:28:28.915]                   NAME <- NAMES[[kk]]
[08:28:28.915]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.915]                     next
[08:28:28.915]                   args[[name]] <- ""
[08:28:28.915]                 }
[08:28:28.915]                 NAMES <- toupper(removed)
[08:28:28.915]                 for (kk in seq_along(NAMES)) {
[08:28:28.915]                   name <- removed[[kk]]
[08:28:28.915]                   NAME <- NAMES[[kk]]
[08:28:28.915]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.915]                     next
[08:28:28.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.915]                 }
[08:28:28.915]                 if (length(args) > 0) 
[08:28:28.915]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.915]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.915]             }
[08:28:28.915]             else {
[08:28:28.915]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.915]             }
[08:28:28.915]             {
[08:28:28.915]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.915]                   0L) {
[08:28:28.915]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.915]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.915]                   base::options(opts)
[08:28:28.915]                 }
[08:28:28.915]                 {
[08:28:28.915]                   {
[08:28:28.915]                     NULL
[08:28:28.915]                     RNGkind("Mersenne-Twister")
[08:28:28.915]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:28.915]                       inherits = FALSE)
[08:28:28.915]                   }
[08:28:28.915]                   options(future.plan = NULL)
[08:28:28.915]                   if (is.na(NA_character_)) 
[08:28:28.915]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.915]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.915]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.915]                     .init = FALSE)
[08:28:28.915]                 }
[08:28:28.915]             }
[08:28:28.915]         }
[08:28:28.915]     })
[08:28:28.915]     if (TRUE) {
[08:28:28.915]         base::sink(type = "output", split = FALSE)
[08:28:28.915]         if (TRUE) {
[08:28:28.915]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.915]         }
[08:28:28.915]         else {
[08:28:28.915]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.915]         }
[08:28:28.915]         base::close(...future.stdout)
[08:28:28.915]         ...future.stdout <- NULL
[08:28:28.915]     }
[08:28:28.915]     ...future.result$conditions <- ...future.conditions
[08:28:28.915]     ...future.result$finished <- base::Sys.time()
[08:28:28.915]     ...future.result
[08:28:28.915] }
[08:28:28.918] plan(): Setting new future strategy stack:
[08:28:28.918] List of future strategies:
[08:28:28.918] 1. sequential:
[08:28:28.918]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.918]    - tweaked: FALSE
[08:28:28.918]    - call: NULL
[08:28:28.918] plan(): nbrOfWorkers() = 1
[08:28:28.919] plan(): Setting new future strategy stack:
[08:28:28.919] List of future strategies:
[08:28:28.919] 1. sequential:
[08:28:28.919]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:28.919]    - tweaked: FALSE
[08:28:28.919]    - call: future::plan("sequential")
[08:28:28.920] plan(): nbrOfWorkers() = 1
[08:28:28.920] SequentialFuture started (and completed)
[08:28:28.920] - Launch lazy future ... done
[08:28:28.920] run() for ‘SequentialFuture’ ... done
List of 2
 $ main   : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
 $ workers: chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
*** multisession() and errors
[08:28:28.923] getGlobalsAndPackages() ...
[08:28:28.923] 
[08:28:28.923] - globals: [0] <none>
[08:28:28.924] getGlobalsAndPackages() ... DONE
[08:28:28.938] Packages needed by the future expression (n = 0): <none>
[08:28:28.938] Packages needed by future strategies (n = 0): <none>
[08:28:28.939] {
[08:28:28.939]     {
[08:28:28.939]         {
[08:28:28.939]             ...future.startTime <- base::Sys.time()
[08:28:28.939]             {
[08:28:28.939]                 {
[08:28:28.939]                   {
[08:28:28.939]                     {
[08:28:28.939]                       base::local({
[08:28:28.939]                         has_future <- base::requireNamespace("future", 
[08:28:28.939]                           quietly = TRUE)
[08:28:28.939]                         if (has_future) {
[08:28:28.939]                           ns <- base::getNamespace("future")
[08:28:28.939]                           version <- ns[[".package"]][["version"]]
[08:28:28.939]                           if (is.null(version)) 
[08:28:28.939]                             version <- utils::packageVersion("future")
[08:28:28.939]                         }
[08:28:28.939]                         else {
[08:28:28.939]                           version <- NULL
[08:28:28.939]                         }
[08:28:28.939]                         if (!has_future || version < "1.8.0") {
[08:28:28.939]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:28.939]                             "", base::R.version$version.string), 
[08:28:28.939]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:28.939]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:28.939]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:28.939]                               "release", "version")], collapse = " "), 
[08:28:28.939]                             hostname = base::Sys.info()[["nodename"]])
[08:28:28.939]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:28.939]                             info)
[08:28:28.939]                           info <- base::paste(info, collapse = "; ")
[08:28:28.939]                           if (!has_future) {
[08:28:28.939]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:28.939]                               info)
[08:28:28.939]                           }
[08:28:28.939]                           else {
[08:28:28.939]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:28.939]                               info, version)
[08:28:28.939]                           }
[08:28:28.939]                           base::stop(msg)
[08:28:28.939]                         }
[08:28:28.939]                       })
[08:28:28.939]                     }
[08:28:28.939]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:28.939]                     base::options(mc.cores = 1L)
[08:28:28.939]                   }
[08:28:28.939]                   ...future.strategy.old <- future::plan("list")
[08:28:28.939]                   options(future.plan = NULL)
[08:28:28.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:28.939]                 }
[08:28:28.939]                 ...future.workdir <- getwd()
[08:28:28.939]             }
[08:28:28.939]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:28.939]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:28.939]         }
[08:28:28.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:28.939]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:28.939]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:28.939]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:28.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:28.939]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:28.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:28.939]             base::names(...future.oldOptions))
[08:28:28.939]     }
[08:28:28.939]     if (FALSE) {
[08:28:28.939]     }
[08:28:28.939]     else {
[08:28:28.939]         if (TRUE) {
[08:28:28.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:28.939]                 open = "w")
[08:28:28.939]         }
[08:28:28.939]         else {
[08:28:28.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:28.939]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:28.939]         }
[08:28:28.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:28.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:28.939]             base::sink(type = "output", split = FALSE)
[08:28:28.939]             base::close(...future.stdout)
[08:28:28.939]         }, add = TRUE)
[08:28:28.939]     }
[08:28:28.939]     ...future.frame <- base::sys.nframe()
[08:28:28.939]     ...future.conditions <- base::list()
[08:28:28.939]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:28.939]     if (FALSE) {
[08:28:28.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:28.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:28.939]     }
[08:28:28.939]     ...future.result <- base::tryCatch({
[08:28:28.939]         base::withCallingHandlers({
[08:28:28.939]             ...future.value <- base::withVisible(base::local({
[08:28:28.939]                 ...future.makeSendCondition <- base::local({
[08:28:28.939]                   sendCondition <- NULL
[08:28:28.939]                   function(frame = 1L) {
[08:28:28.939]                     if (is.function(sendCondition)) 
[08:28:28.939]                       return(sendCondition)
[08:28:28.939]                     ns <- getNamespace("parallel")
[08:28:28.939]                     if (exists("sendData", mode = "function", 
[08:28:28.939]                       envir = ns)) {
[08:28:28.939]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:28.939]                         envir = ns)
[08:28:28.939]                       envir <- sys.frame(frame)
[08:28:28.939]                       master <- NULL
[08:28:28.939]                       while (!identical(envir, .GlobalEnv) && 
[08:28:28.939]                         !identical(envir, emptyenv())) {
[08:28:28.939]                         if (exists("master", mode = "list", envir = envir, 
[08:28:28.939]                           inherits = FALSE)) {
[08:28:28.939]                           master <- get("master", mode = "list", 
[08:28:28.939]                             envir = envir, inherits = FALSE)
[08:28:28.939]                           if (inherits(master, c("SOCKnode", 
[08:28:28.939]                             "SOCK0node"))) {
[08:28:28.939]                             sendCondition <<- function(cond) {
[08:28:28.939]                               data <- list(type = "VALUE", value = cond, 
[08:28:28.939]                                 success = TRUE)
[08:28:28.939]                               parallel_sendData(master, data)
[08:28:28.939]                             }
[08:28:28.939]                             return(sendCondition)
[08:28:28.939]                           }
[08:28:28.939]                         }
[08:28:28.939]                         frame <- frame + 1L
[08:28:28.939]                         envir <- sys.frame(frame)
[08:28:28.939]                       }
[08:28:28.939]                     }
[08:28:28.939]                     sendCondition <<- function(cond) NULL
[08:28:28.939]                   }
[08:28:28.939]                 })
[08:28:28.939]                 withCallingHandlers({
[08:28:28.939]                   {
[08:28:28.939]                     stop("Whoops!")
[08:28:28.939]                     1
[08:28:28.939]                   }
[08:28:28.939]                 }, immediateCondition = function(cond) {
[08:28:28.939]                   sendCondition <- ...future.makeSendCondition()
[08:28:28.939]                   sendCondition(cond)
[08:28:28.939]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.939]                   {
[08:28:28.939]                     inherits <- base::inherits
[08:28:28.939]                     invokeRestart <- base::invokeRestart
[08:28:28.939]                     is.null <- base::is.null
[08:28:28.939]                     muffled <- FALSE
[08:28:28.939]                     if (inherits(cond, "message")) {
[08:28:28.939]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:28.939]                       if (muffled) 
[08:28:28.939]                         invokeRestart("muffleMessage")
[08:28:28.939]                     }
[08:28:28.939]                     else if (inherits(cond, "warning")) {
[08:28:28.939]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:28.939]                       if (muffled) 
[08:28:28.939]                         invokeRestart("muffleWarning")
[08:28:28.939]                     }
[08:28:28.939]                     else if (inherits(cond, "condition")) {
[08:28:28.939]                       if (!is.null(pattern)) {
[08:28:28.939]                         computeRestarts <- base::computeRestarts
[08:28:28.939]                         grepl <- base::grepl
[08:28:28.939]                         restarts <- computeRestarts(cond)
[08:28:28.939]                         for (restart in restarts) {
[08:28:28.939]                           name <- restart$name
[08:28:28.939]                           if (is.null(name)) 
[08:28:28.939]                             next
[08:28:28.939]                           if (!grepl(pattern, name)) 
[08:28:28.939]                             next
[08:28:28.939]                           invokeRestart(restart)
[08:28:28.939]                           muffled <- TRUE
[08:28:28.939]                           break
[08:28:28.939]                         }
[08:28:28.939]                       }
[08:28:28.939]                     }
[08:28:28.939]                     invisible(muffled)
[08:28:28.939]                   }
[08:28:28.939]                   muffleCondition(cond)
[08:28:28.939]                 })
[08:28:28.939]             }))
[08:28:28.939]             future::FutureResult(value = ...future.value$value, 
[08:28:28.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.939]                   ...future.rng), globalenv = if (FALSE) 
[08:28:28.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:28.939]                     ...future.globalenv.names))
[08:28:28.939]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:28.939]         }, condition = base::local({
[08:28:28.939]             c <- base::c
[08:28:28.939]             inherits <- base::inherits
[08:28:28.939]             invokeRestart <- base::invokeRestart
[08:28:28.939]             length <- base::length
[08:28:28.939]             list <- base::list
[08:28:28.939]             seq.int <- base::seq.int
[08:28:28.939]             signalCondition <- base::signalCondition
[08:28:28.939]             sys.calls <- base::sys.calls
[08:28:28.939]             `[[` <- base::`[[`
[08:28:28.939]             `+` <- base::`+`
[08:28:28.939]             `<<-` <- base::`<<-`
[08:28:28.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:28.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:28.939]                   3L)]
[08:28:28.939]             }
[08:28:28.939]             function(cond) {
[08:28:28.939]                 is_error <- inherits(cond, "error")
[08:28:28.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:28.939]                   NULL)
[08:28:28.939]                 if (is_error) {
[08:28:28.939]                   sessionInformation <- function() {
[08:28:28.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:28.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:28.939]                       search = base::search(), system = base::Sys.info())
[08:28:28.939]                   }
[08:28:28.939]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:28.939]                     cond$call), session = sessionInformation(), 
[08:28:28.939]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:28.939]                   signalCondition(cond)
[08:28:28.939]                 }
[08:28:28.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:28.939]                 "immediateCondition"))) {
[08:28:28.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:28.939]                   ...future.conditions[[length(...future.conditions) + 
[08:28:28.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:28.939]                   if (TRUE && !signal) {
[08:28:28.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.939]                     {
[08:28:28.939]                       inherits <- base::inherits
[08:28:28.939]                       invokeRestart <- base::invokeRestart
[08:28:28.939]                       is.null <- base::is.null
[08:28:28.939]                       muffled <- FALSE
[08:28:28.939]                       if (inherits(cond, "message")) {
[08:28:28.939]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.939]                         if (muffled) 
[08:28:28.939]                           invokeRestart("muffleMessage")
[08:28:28.939]                       }
[08:28:28.939]                       else if (inherits(cond, "warning")) {
[08:28:28.939]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.939]                         if (muffled) 
[08:28:28.939]                           invokeRestart("muffleWarning")
[08:28:28.939]                       }
[08:28:28.939]                       else if (inherits(cond, "condition")) {
[08:28:28.939]                         if (!is.null(pattern)) {
[08:28:28.939]                           computeRestarts <- base::computeRestarts
[08:28:28.939]                           grepl <- base::grepl
[08:28:28.939]                           restarts <- computeRestarts(cond)
[08:28:28.939]                           for (restart in restarts) {
[08:28:28.939]                             name <- restart$name
[08:28:28.939]                             if (is.null(name)) 
[08:28:28.939]                               next
[08:28:28.939]                             if (!grepl(pattern, name)) 
[08:28:28.939]                               next
[08:28:28.939]                             invokeRestart(restart)
[08:28:28.939]                             muffled <- TRUE
[08:28:28.939]                             break
[08:28:28.939]                           }
[08:28:28.939]                         }
[08:28:28.939]                       }
[08:28:28.939]                       invisible(muffled)
[08:28:28.939]                     }
[08:28:28.939]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.939]                   }
[08:28:28.939]                 }
[08:28:28.939]                 else {
[08:28:28.939]                   if (TRUE) {
[08:28:28.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:28.939]                     {
[08:28:28.939]                       inherits <- base::inherits
[08:28:28.939]                       invokeRestart <- base::invokeRestart
[08:28:28.939]                       is.null <- base::is.null
[08:28:28.939]                       muffled <- FALSE
[08:28:28.939]                       if (inherits(cond, "message")) {
[08:28:28.939]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:28.939]                         if (muffled) 
[08:28:28.939]                           invokeRestart("muffleMessage")
[08:28:28.939]                       }
[08:28:28.939]                       else if (inherits(cond, "warning")) {
[08:28:28.939]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:28.939]                         if (muffled) 
[08:28:28.939]                           invokeRestart("muffleWarning")
[08:28:28.939]                       }
[08:28:28.939]                       else if (inherits(cond, "condition")) {
[08:28:28.939]                         if (!is.null(pattern)) {
[08:28:28.939]                           computeRestarts <- base::computeRestarts
[08:28:28.939]                           grepl <- base::grepl
[08:28:28.939]                           restarts <- computeRestarts(cond)
[08:28:28.939]                           for (restart in restarts) {
[08:28:28.939]                             name <- restart$name
[08:28:28.939]                             if (is.null(name)) 
[08:28:28.939]                               next
[08:28:28.939]                             if (!grepl(pattern, name)) 
[08:28:28.939]                               next
[08:28:28.939]                             invokeRestart(restart)
[08:28:28.939]                             muffled <- TRUE
[08:28:28.939]                             break
[08:28:28.939]                           }
[08:28:28.939]                         }
[08:28:28.939]                       }
[08:28:28.939]                       invisible(muffled)
[08:28:28.939]                     }
[08:28:28.939]                     muffleCondition(cond, pattern = "^muffle")
[08:28:28.939]                   }
[08:28:28.939]                 }
[08:28:28.939]             }
[08:28:28.939]         }))
[08:28:28.939]     }, error = function(ex) {
[08:28:28.939]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:28.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:28.939]                 ...future.rng), started = ...future.startTime, 
[08:28:28.939]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:28.939]             version = "1.8"), class = "FutureResult")
[08:28:28.939]     }, finally = {
[08:28:28.939]         if (!identical(...future.workdir, getwd())) 
[08:28:28.939]             setwd(...future.workdir)
[08:28:28.939]         {
[08:28:28.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:28.939]                 ...future.oldOptions$nwarnings <- NULL
[08:28:28.939]             }
[08:28:28.939]             base::options(...future.oldOptions)
[08:28:28.939]             if (.Platform$OS.type == "windows") {
[08:28:28.939]                 old_names <- names(...future.oldEnvVars)
[08:28:28.939]                 envs <- base::Sys.getenv()
[08:28:28.939]                 names <- names(envs)
[08:28:28.939]                 common <- intersect(names, old_names)
[08:28:28.939]                 added <- setdiff(names, old_names)
[08:28:28.939]                 removed <- setdiff(old_names, names)
[08:28:28.939]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:28.939]                   envs[common]]
[08:28:28.939]                 NAMES <- toupper(changed)
[08:28:28.939]                 args <- list()
[08:28:28.939]                 for (kk in seq_along(NAMES)) {
[08:28:28.939]                   name <- changed[[kk]]
[08:28:28.939]                   NAME <- NAMES[[kk]]
[08:28:28.939]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.939]                     next
[08:28:28.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.939]                 }
[08:28:28.939]                 NAMES <- toupper(added)
[08:28:28.939]                 for (kk in seq_along(NAMES)) {
[08:28:28.939]                   name <- added[[kk]]
[08:28:28.939]                   NAME <- NAMES[[kk]]
[08:28:28.939]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.939]                     next
[08:28:28.939]                   args[[name]] <- ""
[08:28:28.939]                 }
[08:28:28.939]                 NAMES <- toupper(removed)
[08:28:28.939]                 for (kk in seq_along(NAMES)) {
[08:28:28.939]                   name <- removed[[kk]]
[08:28:28.939]                   NAME <- NAMES[[kk]]
[08:28:28.939]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:28.939]                     next
[08:28:28.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:28.939]                 }
[08:28:28.939]                 if (length(args) > 0) 
[08:28:28.939]                   base::do.call(base::Sys.setenv, args = args)
[08:28:28.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:28.939]             }
[08:28:28.939]             else {
[08:28:28.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:28.939]             }
[08:28:28.939]             {
[08:28:28.939]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:28.939]                   0L) {
[08:28:28.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:28.939]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:28.939]                   base::options(opts)
[08:28:28.939]                 }
[08:28:28.939]                 {
[08:28:28.939]                   {
[08:28:28.939]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:28.939]                     NULL
[08:28:28.939]                   }
[08:28:28.939]                   options(future.plan = NULL)
[08:28:28.939]                   if (is.na(NA_character_)) 
[08:28:28.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:28.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:28.939]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:28.939]                     .init = FALSE)
[08:28:28.939]                 }
[08:28:28.939]             }
[08:28:28.939]         }
[08:28:28.939]     })
[08:28:28.939]     if (TRUE) {
[08:28:28.939]         base::sink(type = "output", split = FALSE)
[08:28:28.939]         if (TRUE) {
[08:28:28.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:28.939]         }
[08:28:28.939]         else {
[08:28:28.939]             ...future.result["stdout"] <- base::list(NULL)
[08:28:28.939]         }
[08:28:28.939]         base::close(...future.stdout)
[08:28:28.939]         ...future.stdout <- NULL
[08:28:28.939]     }
[08:28:28.939]     ...future.result$conditions <- ...future.conditions
[08:28:28.939]     ...future.result$finished <- base::Sys.time()
[08:28:28.939]     ...future.result
[08:28:28.939] }
[08:28:28.942] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 2d485820-dce0-a5ac-1757-5b458766347d
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:28.953] result() for ClusterFuture ...
[08:28:28.953] receiveMessageFromWorker() for ClusterFuture ...
[08:28:28.954] - Validating connection of MultisessionFuture
[08:28:28.985] - received message: FutureResult
[08:28:28.985] - Received FutureResult
[08:28:28.986] - Erased future from FutureRegistry
[08:28:28.986] result() for ClusterFuture ...
[08:28:28.986] - result already collected: FutureResult
[08:28:28.986] result() for ClusterFuture ... done
[08:28:28.986] signalConditions() ...
[08:28:28.986]  - include = ‘immediateCondition’
[08:28:28.986]  - exclude = 
[08:28:28.986]  - resignal = FALSE
[08:28:28.986]  - Number of conditions: 1
[08:28:28.987] signalConditions() ... done
[08:28:28.987] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:28.987] result() for ClusterFuture ... done
[08:28:28.987] result() for ClusterFuture ...
[08:28:28.987] - result already collected: FutureResult
[08:28:28.987] result() for ClusterFuture ... done
[08:28:28.987] signalConditions() ...
[08:28:28.987]  - include = ‘immediateCondition’
[08:28:28.987]  - exclude = 
[08:28:28.988]  - resignal = FALSE
[08:28:28.988]  - Number of conditions: 1
[08:28:28.988] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[08:28:28.988] result() for ClusterFuture ...
[08:28:28.988] - result already collected: FutureResult
[08:28:28.988] result() for ClusterFuture ... done
[08:28:28.988] result() for ClusterFuture ...
[08:28:28.989] - result already collected: FutureResult
[08:28:28.989] result() for ClusterFuture ... done
[08:28:28.989] signalConditions() ...
[08:28:28.989]  - include = ‘immediateCondition’
[08:28:28.989]  - exclude = 
[08:28:28.989]  - resignal = FALSE
[08:28:28.989]  - Number of conditions: 1
[08:28:28.989] signalConditions() ... done
[08:28:28.989] Future state: ‘finished’
[08:28:28.990] result() for ClusterFuture ...
[08:28:28.990] - result already collected: FutureResult
[08:28:28.990] result() for ClusterFuture ... done
[08:28:28.990] signalConditions() ...
[08:28:28.990]  - include = ‘condition’
[08:28:28.990]  - exclude = ‘immediateCondition’
[08:28:28.990]  - resignal = TRUE
[08:28:28.990]  - Number of conditions: 1
[08:28:28.990]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:28.991] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[08:28:28.991] result() for ClusterFuture ...
[08:28:28.991] - result already collected: FutureResult
[08:28:28.991] result() for ClusterFuture ... done
[08:28:28.991] result() for ClusterFuture ...
[08:28:28.992] - result already collected: FutureResult
[08:28:28.992] result() for ClusterFuture ... done
[08:28:28.992] signalConditions() ...
[08:28:28.992]  - include = ‘immediateCondition’
[08:28:28.992]  - exclude = 
[08:28:28.992]  - resignal = FALSE
[08:28:28.992]  - Number of conditions: 1
[08:28:28.992] signalConditions() ... done
[08:28:28.992] Future state: ‘finished’
[08:28:28.993] result() for ClusterFuture ...
[08:28:28.993] - result already collected: FutureResult
[08:28:28.993] result() for ClusterFuture ... done
[08:28:28.993] signalConditions() ...
[08:28:28.993]  - include = ‘condition’
[08:28:28.993]  - exclude = ‘immediateCondition’
[08:28:28.993]  - resignal = TRUE
[08:28:28.993]  - Number of conditions: 1
[08:28:28.993]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:28.994] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[08:28:28.996] getGlobalsAndPackages() ...
[08:28:28.996] 
[08:28:28.996] - globals: [0] <none>
[08:28:28.996] getGlobalsAndPackages() ... DONE
[08:28:29.010] Packages needed by the future expression (n = 0): <none>
[08:28:29.010] Packages needed by future strategies (n = 0): <none>
[08:28:29.010] {
[08:28:29.010]     {
[08:28:29.010]         {
[08:28:29.010]             ...future.startTime <- base::Sys.time()
[08:28:29.010]             {
[08:28:29.010]                 {
[08:28:29.010]                   {
[08:28:29.010]                     {
[08:28:29.010]                       base::local({
[08:28:29.010]                         has_future <- base::requireNamespace("future", 
[08:28:29.010]                           quietly = TRUE)
[08:28:29.010]                         if (has_future) {
[08:28:29.010]                           ns <- base::getNamespace("future")
[08:28:29.010]                           version <- ns[[".package"]][["version"]]
[08:28:29.010]                           if (is.null(version)) 
[08:28:29.010]                             version <- utils::packageVersion("future")
[08:28:29.010]                         }
[08:28:29.010]                         else {
[08:28:29.010]                           version <- NULL
[08:28:29.010]                         }
[08:28:29.010]                         if (!has_future || version < "1.8.0") {
[08:28:29.010]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:29.010]                             "", base::R.version$version.string), 
[08:28:29.010]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:29.010]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:29.010]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:29.010]                               "release", "version")], collapse = " "), 
[08:28:29.010]                             hostname = base::Sys.info()[["nodename"]])
[08:28:29.010]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:29.010]                             info)
[08:28:29.010]                           info <- base::paste(info, collapse = "; ")
[08:28:29.010]                           if (!has_future) {
[08:28:29.010]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:29.010]                               info)
[08:28:29.010]                           }
[08:28:29.010]                           else {
[08:28:29.010]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:29.010]                               info, version)
[08:28:29.010]                           }
[08:28:29.010]                           base::stop(msg)
[08:28:29.010]                         }
[08:28:29.010]                       })
[08:28:29.010]                     }
[08:28:29.010]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:29.010]                     base::options(mc.cores = 1L)
[08:28:29.010]                   }
[08:28:29.010]                   ...future.strategy.old <- future::plan("list")
[08:28:29.010]                   options(future.plan = NULL)
[08:28:29.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:29.010]                 }
[08:28:29.010]                 ...future.workdir <- getwd()
[08:28:29.010]             }
[08:28:29.010]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:29.010]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:29.010]         }
[08:28:29.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:29.010]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:29.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:29.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:29.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:29.010]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:29.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:29.010]             base::names(...future.oldOptions))
[08:28:29.010]     }
[08:28:29.010]     if (FALSE) {
[08:28:29.010]     }
[08:28:29.010]     else {
[08:28:29.010]         if (TRUE) {
[08:28:29.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:29.010]                 open = "w")
[08:28:29.010]         }
[08:28:29.010]         else {
[08:28:29.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:29.010]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:29.010]         }
[08:28:29.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:29.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:29.010]             base::sink(type = "output", split = FALSE)
[08:28:29.010]             base::close(...future.stdout)
[08:28:29.010]         }, add = TRUE)
[08:28:29.010]     }
[08:28:29.010]     ...future.frame <- base::sys.nframe()
[08:28:29.010]     ...future.conditions <- base::list()
[08:28:29.010]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:29.010]     if (FALSE) {
[08:28:29.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:29.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:29.010]     }
[08:28:29.010]     ...future.result <- base::tryCatch({
[08:28:29.010]         base::withCallingHandlers({
[08:28:29.010]             ...future.value <- base::withVisible(base::local({
[08:28:29.010]                 ...future.makeSendCondition <- base::local({
[08:28:29.010]                   sendCondition <- NULL
[08:28:29.010]                   function(frame = 1L) {
[08:28:29.010]                     if (is.function(sendCondition)) 
[08:28:29.010]                       return(sendCondition)
[08:28:29.010]                     ns <- getNamespace("parallel")
[08:28:29.010]                     if (exists("sendData", mode = "function", 
[08:28:29.010]                       envir = ns)) {
[08:28:29.010]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:29.010]                         envir = ns)
[08:28:29.010]                       envir <- sys.frame(frame)
[08:28:29.010]                       master <- NULL
[08:28:29.010]                       while (!identical(envir, .GlobalEnv) && 
[08:28:29.010]                         !identical(envir, emptyenv())) {
[08:28:29.010]                         if (exists("master", mode = "list", envir = envir, 
[08:28:29.010]                           inherits = FALSE)) {
[08:28:29.010]                           master <- get("master", mode = "list", 
[08:28:29.010]                             envir = envir, inherits = FALSE)
[08:28:29.010]                           if (inherits(master, c("SOCKnode", 
[08:28:29.010]                             "SOCK0node"))) {
[08:28:29.010]                             sendCondition <<- function(cond) {
[08:28:29.010]                               data <- list(type = "VALUE", value = cond, 
[08:28:29.010]                                 success = TRUE)
[08:28:29.010]                               parallel_sendData(master, data)
[08:28:29.010]                             }
[08:28:29.010]                             return(sendCondition)
[08:28:29.010]                           }
[08:28:29.010]                         }
[08:28:29.010]                         frame <- frame + 1L
[08:28:29.010]                         envir <- sys.frame(frame)
[08:28:29.010]                       }
[08:28:29.010]                     }
[08:28:29.010]                     sendCondition <<- function(cond) NULL
[08:28:29.010]                   }
[08:28:29.010]                 })
[08:28:29.010]                 withCallingHandlers({
[08:28:29.010]                   {
[08:28:29.010]                     stop(structure(list(message = "boom"), class = c("MyError", 
[08:28:29.010]                       "error", "condition")))
[08:28:29.010]                   }
[08:28:29.010]                 }, immediateCondition = function(cond) {
[08:28:29.010]                   sendCondition <- ...future.makeSendCondition()
[08:28:29.010]                   sendCondition(cond)
[08:28:29.010]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.010]                   {
[08:28:29.010]                     inherits <- base::inherits
[08:28:29.010]                     invokeRestart <- base::invokeRestart
[08:28:29.010]                     is.null <- base::is.null
[08:28:29.010]                     muffled <- FALSE
[08:28:29.010]                     if (inherits(cond, "message")) {
[08:28:29.010]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:29.010]                       if (muffled) 
[08:28:29.010]                         invokeRestart("muffleMessage")
[08:28:29.010]                     }
[08:28:29.010]                     else if (inherits(cond, "warning")) {
[08:28:29.010]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:29.010]                       if (muffled) 
[08:28:29.010]                         invokeRestart("muffleWarning")
[08:28:29.010]                     }
[08:28:29.010]                     else if (inherits(cond, "condition")) {
[08:28:29.010]                       if (!is.null(pattern)) {
[08:28:29.010]                         computeRestarts <- base::computeRestarts
[08:28:29.010]                         grepl <- base::grepl
[08:28:29.010]                         restarts <- computeRestarts(cond)
[08:28:29.010]                         for (restart in restarts) {
[08:28:29.010]                           name <- restart$name
[08:28:29.010]                           if (is.null(name)) 
[08:28:29.010]                             next
[08:28:29.010]                           if (!grepl(pattern, name)) 
[08:28:29.010]                             next
[08:28:29.010]                           invokeRestart(restart)
[08:28:29.010]                           muffled <- TRUE
[08:28:29.010]                           break
[08:28:29.010]                         }
[08:28:29.010]                       }
[08:28:29.010]                     }
[08:28:29.010]                     invisible(muffled)
[08:28:29.010]                   }
[08:28:29.010]                   muffleCondition(cond)
[08:28:29.010]                 })
[08:28:29.010]             }))
[08:28:29.010]             future::FutureResult(value = ...future.value$value, 
[08:28:29.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.010]                   ...future.rng), globalenv = if (FALSE) 
[08:28:29.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:29.010]                     ...future.globalenv.names))
[08:28:29.010]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:29.010]         }, condition = base::local({
[08:28:29.010]             c <- base::c
[08:28:29.010]             inherits <- base::inherits
[08:28:29.010]             invokeRestart <- base::invokeRestart
[08:28:29.010]             length <- base::length
[08:28:29.010]             list <- base::list
[08:28:29.010]             seq.int <- base::seq.int
[08:28:29.010]             signalCondition <- base::signalCondition
[08:28:29.010]             sys.calls <- base::sys.calls
[08:28:29.010]             `[[` <- base::`[[`
[08:28:29.010]             `+` <- base::`+`
[08:28:29.010]             `<<-` <- base::`<<-`
[08:28:29.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:29.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:29.010]                   3L)]
[08:28:29.010]             }
[08:28:29.010]             function(cond) {
[08:28:29.010]                 is_error <- inherits(cond, "error")
[08:28:29.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:29.010]                   NULL)
[08:28:29.010]                 if (is_error) {
[08:28:29.010]                   sessionInformation <- function() {
[08:28:29.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:29.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:29.010]                       search = base::search(), system = base::Sys.info())
[08:28:29.010]                   }
[08:28:29.010]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:29.010]                     cond$call), session = sessionInformation(), 
[08:28:29.010]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:29.010]                   signalCondition(cond)
[08:28:29.010]                 }
[08:28:29.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:29.010]                 "immediateCondition"))) {
[08:28:29.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:29.010]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:29.010]                   if (TRUE && !signal) {
[08:28:29.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.010]                     {
[08:28:29.010]                       inherits <- base::inherits
[08:28:29.010]                       invokeRestart <- base::invokeRestart
[08:28:29.010]                       is.null <- base::is.null
[08:28:29.010]                       muffled <- FALSE
[08:28:29.010]                       if (inherits(cond, "message")) {
[08:28:29.010]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.010]                         if (muffled) 
[08:28:29.010]                           invokeRestart("muffleMessage")
[08:28:29.010]                       }
[08:28:29.010]                       else if (inherits(cond, "warning")) {
[08:28:29.010]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.010]                         if (muffled) 
[08:28:29.010]                           invokeRestart("muffleWarning")
[08:28:29.010]                       }
[08:28:29.010]                       else if (inherits(cond, "condition")) {
[08:28:29.010]                         if (!is.null(pattern)) {
[08:28:29.010]                           computeRestarts <- base::computeRestarts
[08:28:29.010]                           grepl <- base::grepl
[08:28:29.010]                           restarts <- computeRestarts(cond)
[08:28:29.010]                           for (restart in restarts) {
[08:28:29.010]                             name <- restart$name
[08:28:29.010]                             if (is.null(name)) 
[08:28:29.010]                               next
[08:28:29.010]                             if (!grepl(pattern, name)) 
[08:28:29.010]                               next
[08:28:29.010]                             invokeRestart(restart)
[08:28:29.010]                             muffled <- TRUE
[08:28:29.010]                             break
[08:28:29.010]                           }
[08:28:29.010]                         }
[08:28:29.010]                       }
[08:28:29.010]                       invisible(muffled)
[08:28:29.010]                     }
[08:28:29.010]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.010]                   }
[08:28:29.010]                 }
[08:28:29.010]                 else {
[08:28:29.010]                   if (TRUE) {
[08:28:29.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.010]                     {
[08:28:29.010]                       inherits <- base::inherits
[08:28:29.010]                       invokeRestart <- base::invokeRestart
[08:28:29.010]                       is.null <- base::is.null
[08:28:29.010]                       muffled <- FALSE
[08:28:29.010]                       if (inherits(cond, "message")) {
[08:28:29.010]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.010]                         if (muffled) 
[08:28:29.010]                           invokeRestart("muffleMessage")
[08:28:29.010]                       }
[08:28:29.010]                       else if (inherits(cond, "warning")) {
[08:28:29.010]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.010]                         if (muffled) 
[08:28:29.010]                           invokeRestart("muffleWarning")
[08:28:29.010]                       }
[08:28:29.010]                       else if (inherits(cond, "condition")) {
[08:28:29.010]                         if (!is.null(pattern)) {
[08:28:29.010]                           computeRestarts <- base::computeRestarts
[08:28:29.010]                           grepl <- base::grepl
[08:28:29.010]                           restarts <- computeRestarts(cond)
[08:28:29.010]                           for (restart in restarts) {
[08:28:29.010]                             name <- restart$name
[08:28:29.010]                             if (is.null(name)) 
[08:28:29.010]                               next
[08:28:29.010]                             if (!grepl(pattern, name)) 
[08:28:29.010]                               next
[08:28:29.010]                             invokeRestart(restart)
[08:28:29.010]                             muffled <- TRUE
[08:28:29.010]                             break
[08:28:29.010]                           }
[08:28:29.010]                         }
[08:28:29.010]                       }
[08:28:29.010]                       invisible(muffled)
[08:28:29.010]                     }
[08:28:29.010]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.010]                   }
[08:28:29.010]                 }
[08:28:29.010]             }
[08:28:29.010]         }))
[08:28:29.010]     }, error = function(ex) {
[08:28:29.010]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:29.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.010]                 ...future.rng), started = ...future.startTime, 
[08:28:29.010]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:29.010]             version = "1.8"), class = "FutureResult")
[08:28:29.010]     }, finally = {
[08:28:29.010]         if (!identical(...future.workdir, getwd())) 
[08:28:29.010]             setwd(...future.workdir)
[08:28:29.010]         {
[08:28:29.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:29.010]                 ...future.oldOptions$nwarnings <- NULL
[08:28:29.010]             }
[08:28:29.010]             base::options(...future.oldOptions)
[08:28:29.010]             if (.Platform$OS.type == "windows") {
[08:28:29.010]                 old_names <- names(...future.oldEnvVars)
[08:28:29.010]                 envs <- base::Sys.getenv()
[08:28:29.010]                 names <- names(envs)
[08:28:29.010]                 common <- intersect(names, old_names)
[08:28:29.010]                 added <- setdiff(names, old_names)
[08:28:29.010]                 removed <- setdiff(old_names, names)
[08:28:29.010]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:29.010]                   envs[common]]
[08:28:29.010]                 NAMES <- toupper(changed)
[08:28:29.010]                 args <- list()
[08:28:29.010]                 for (kk in seq_along(NAMES)) {
[08:28:29.010]                   name <- changed[[kk]]
[08:28:29.010]                   NAME <- NAMES[[kk]]
[08:28:29.010]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.010]                     next
[08:28:29.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.010]                 }
[08:28:29.010]                 NAMES <- toupper(added)
[08:28:29.010]                 for (kk in seq_along(NAMES)) {
[08:28:29.010]                   name <- added[[kk]]
[08:28:29.010]                   NAME <- NAMES[[kk]]
[08:28:29.010]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.010]                     next
[08:28:29.010]                   args[[name]] <- ""
[08:28:29.010]                 }
[08:28:29.010]                 NAMES <- toupper(removed)
[08:28:29.010]                 for (kk in seq_along(NAMES)) {
[08:28:29.010]                   name <- removed[[kk]]
[08:28:29.010]                   NAME <- NAMES[[kk]]
[08:28:29.010]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.010]                     next
[08:28:29.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.010]                 }
[08:28:29.010]                 if (length(args) > 0) 
[08:28:29.010]                   base::do.call(base::Sys.setenv, args = args)
[08:28:29.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:29.010]             }
[08:28:29.010]             else {
[08:28:29.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:29.010]             }
[08:28:29.010]             {
[08:28:29.010]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:29.010]                   0L) {
[08:28:29.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:29.010]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:29.010]                   base::options(opts)
[08:28:29.010]                 }
[08:28:29.010]                 {
[08:28:29.010]                   {
[08:28:29.010]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:29.010]                     NULL
[08:28:29.010]                   }
[08:28:29.010]                   options(future.plan = NULL)
[08:28:29.010]                   if (is.na(NA_character_)) 
[08:28:29.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:29.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:29.010]                     .init = FALSE)
[08:28:29.010]                 }
[08:28:29.010]             }
[08:28:29.010]         }
[08:28:29.010]     })
[08:28:29.010]     if (TRUE) {
[08:28:29.010]         base::sink(type = "output", split = FALSE)
[08:28:29.010]         if (TRUE) {
[08:28:29.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:29.010]         }
[08:28:29.010]         else {
[08:28:29.010]             ...future.result["stdout"] <- base::list(NULL)
[08:28:29.010]         }
[08:28:29.010]         base::close(...future.stdout)
[08:28:29.010]         ...future.stdout <- NULL
[08:28:29.010]     }
[08:28:29.010]     ...future.result$conditions <- ...future.conditions
[08:28:29.010]     ...future.result$finished <- base::Sys.time()
[08:28:29.010]     ...future.result
[08:28:29.010] }
[08:28:29.014] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 2d485820-dce0-a5ac-1757-5b458766347d
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:29.025] result() for ClusterFuture ...
[08:28:29.025] receiveMessageFromWorker() for ClusterFuture ...
[08:28:29.025] - Validating connection of MultisessionFuture
[08:28:29.057] - received message: FutureResult
[08:28:29.057] - Received FutureResult
[08:28:29.057] - Erased future from FutureRegistry
[08:28:29.057] result() for ClusterFuture ...
[08:28:29.057] - result already collected: FutureResult
[08:28:29.058] result() for ClusterFuture ... done
[08:28:29.058] signalConditions() ...
[08:28:29.058]  - include = ‘immediateCondition’
[08:28:29.058]  - exclude = 
[08:28:29.058]  - resignal = FALSE
[08:28:29.058]  - Number of conditions: 1
[08:28:29.058] signalConditions() ... done
[08:28:29.058] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:29.058] result() for ClusterFuture ... done
[08:28:29.059] result() for ClusterFuture ...
[08:28:29.059] - result already collected: FutureResult
[08:28:29.059] result() for ClusterFuture ... done
[08:28:29.059] signalConditions() ...
[08:28:29.059]  - include = ‘immediateCondition’
[08:28:29.059]  - exclude = 
[08:28:29.059]  - resignal = FALSE
[08:28:29.059]  - Number of conditions: 1
[08:28:29.059] signalConditions() ... done
<MyError: boom>
[08:28:29.060] result() for ClusterFuture ...
[08:28:29.060] - result already collected: FutureResult
[08:28:29.060] result() for ClusterFuture ... done
[08:28:29.060] result() for ClusterFuture ...
[08:28:29.060] - result already collected: FutureResult
[08:28:29.060] result() for ClusterFuture ... done
[08:28:29.060] signalConditions() ...
[08:28:29.060]  - include = ‘immediateCondition’
[08:28:29.061]  - exclude = 
[08:28:29.061]  - resignal = FALSE
[08:28:29.061]  - Number of conditions: 1
[08:28:29.061] signalConditions() ... done
[08:28:29.061] Future state: ‘finished’
[08:28:29.061] result() for ClusterFuture ...
[08:28:29.061] - result already collected: FutureResult
[08:28:29.061] result() for ClusterFuture ... done
[08:28:29.061] signalConditions() ...
[08:28:29.062]  - include = ‘condition’
[08:28:29.062]  - exclude = ‘immediateCondition’
[08:28:29.062]  - resignal = TRUE
[08:28:29.062]  - Number of conditions: 1
[08:28:29.062]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[08:28:29.062] signalConditions() ... done
Testing with 2 cores ... DONE
> 
> 
> message("*** multisession() - too large globals ... DONE")
*** multisession() - too large globals ... DONE
> 
> message("*** multisession(..., workers = 1L) ...")
*** multisession(..., workers = 1L) ...
> 
> a <- 2
> b <- 3
> yTruth <- a * b
> 
> f <- multisession({ a * b }, globals = TRUE, workers = 1L)
[08:28:29.063] getGlobalsAndPackages() ...
[08:28:29.067] Searching for globals...
[08:28:29.069] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[08:28:29.069] Searching for globals ... DONE
[08:28:29.069] Resolving globals: FALSE
[08:28:29.069] The total size of the 2 globals is 78 bytes (78 bytes)
[08:28:29.070] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 78 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘b’ (39 bytes of class ‘numeric’)
[08:28:29.070] - globals: [2] ‘a’, ‘b’
[08:28:29.070] 
[08:28:29.070] getGlobalsAndPackages() ... DONE
> rm(list = c("a", "b"))
> 
> v <- value(f)
[08:28:29.071] Packages needed by the future expression (n = 0): <none>
[08:28:29.071] Packages needed by future strategies (n = 0): <none>
[08:28:29.072] {
[08:28:29.072]     {
[08:28:29.072]         {
[08:28:29.072]             ...future.startTime <- base::Sys.time()
[08:28:29.072]             {
[08:28:29.072]                 {
[08:28:29.072]                   {
[08:28:29.072]                     base::local({
[08:28:29.072]                       has_future <- base::requireNamespace("future", 
[08:28:29.072]                         quietly = TRUE)
[08:28:29.072]                       if (has_future) {
[08:28:29.072]                         ns <- base::getNamespace("future")
[08:28:29.072]                         version <- ns[[".package"]][["version"]]
[08:28:29.072]                         if (is.null(version)) 
[08:28:29.072]                           version <- utils::packageVersion("future")
[08:28:29.072]                       }
[08:28:29.072]                       else {
[08:28:29.072]                         version <- NULL
[08:28:29.072]                       }
[08:28:29.072]                       if (!has_future || version < "1.8.0") {
[08:28:29.072]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:29.072]                           "", base::R.version$version.string), 
[08:28:29.072]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:29.072]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:29.072]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:29.072]                             "release", "version")], collapse = " "), 
[08:28:29.072]                           hostname = base::Sys.info()[["nodename"]])
[08:28:29.072]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:29.072]                           info)
[08:28:29.072]                         info <- base::paste(info, collapse = "; ")
[08:28:29.072]                         if (!has_future) {
[08:28:29.072]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:29.072]                             info)
[08:28:29.072]                         }
[08:28:29.072]                         else {
[08:28:29.072]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:29.072]                             info, version)
[08:28:29.072]                         }
[08:28:29.072]                         base::stop(msg)
[08:28:29.072]                       }
[08:28:29.072]                     })
[08:28:29.072]                   }
[08:28:29.072]                   ...future.strategy.old <- future::plan("list")
[08:28:29.072]                   options(future.plan = NULL)
[08:28:29.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:29.072]                 }
[08:28:29.072]                 ...future.workdir <- getwd()
[08:28:29.072]             }
[08:28:29.072]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:29.072]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:29.072]         }
[08:28:29.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:29.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:29.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:29.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:29.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:29.072]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:29.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:29.072]             base::names(...future.oldOptions))
[08:28:29.072]     }
[08:28:29.072]     if (FALSE) {
[08:28:29.072]     }
[08:28:29.072]     else {
[08:28:29.072]         if (TRUE) {
[08:28:29.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:29.072]                 open = "w")
[08:28:29.072]         }
[08:28:29.072]         else {
[08:28:29.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:29.072]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:29.072]         }
[08:28:29.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:29.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:29.072]             base::sink(type = "output", split = FALSE)
[08:28:29.072]             base::close(...future.stdout)
[08:28:29.072]         }, add = TRUE)
[08:28:29.072]     }
[08:28:29.072]     ...future.frame <- base::sys.nframe()
[08:28:29.072]     ...future.conditions <- base::list()
[08:28:29.072]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:29.072]     if (FALSE) {
[08:28:29.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:29.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:29.072]     }
[08:28:29.072]     ...future.result <- base::tryCatch({
[08:28:29.072]         base::withCallingHandlers({
[08:28:29.072]             ...future.value <- base::withVisible(base::local({
[08:28:29.072]                 a * b
[08:28:29.072]             }))
[08:28:29.072]             future::FutureResult(value = ...future.value$value, 
[08:28:29.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.072]                   ...future.rng), globalenv = if (FALSE) 
[08:28:29.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:29.072]                     ...future.globalenv.names))
[08:28:29.072]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:29.072]         }, condition = base::local({
[08:28:29.072]             c <- base::c
[08:28:29.072]             inherits <- base::inherits
[08:28:29.072]             invokeRestart <- base::invokeRestart
[08:28:29.072]             length <- base::length
[08:28:29.072]             list <- base::list
[08:28:29.072]             seq.int <- base::seq.int
[08:28:29.072]             signalCondition <- base::signalCondition
[08:28:29.072]             sys.calls <- base::sys.calls
[08:28:29.072]             `[[` <- base::`[[`
[08:28:29.072]             `+` <- base::`+`
[08:28:29.072]             `<<-` <- base::`<<-`
[08:28:29.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:29.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:29.072]                   3L)]
[08:28:29.072]             }
[08:28:29.072]             function(cond) {
[08:28:29.072]                 is_error <- inherits(cond, "error")
[08:28:29.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:29.072]                   NULL)
[08:28:29.072]                 if (is_error) {
[08:28:29.072]                   sessionInformation <- function() {
[08:28:29.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:29.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:29.072]                       search = base::search(), system = base::Sys.info())
[08:28:29.072]                   }
[08:28:29.072]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:29.072]                     cond$call), session = sessionInformation(), 
[08:28:29.072]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:29.072]                   signalCondition(cond)
[08:28:29.072]                 }
[08:28:29.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:29.072]                 "immediateCondition"))) {
[08:28:29.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:29.072]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:29.072]                   if (TRUE && !signal) {
[08:28:29.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.072]                     {
[08:28:29.072]                       inherits <- base::inherits
[08:28:29.072]                       invokeRestart <- base::invokeRestart
[08:28:29.072]                       is.null <- base::is.null
[08:28:29.072]                       muffled <- FALSE
[08:28:29.072]                       if (inherits(cond, "message")) {
[08:28:29.072]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.072]                         if (muffled) 
[08:28:29.072]                           invokeRestart("muffleMessage")
[08:28:29.072]                       }
[08:28:29.072]                       else if (inherits(cond, "warning")) {
[08:28:29.072]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.072]                         if (muffled) 
[08:28:29.072]                           invokeRestart("muffleWarning")
[08:28:29.072]                       }
[08:28:29.072]                       else if (inherits(cond, "condition")) {
[08:28:29.072]                         if (!is.null(pattern)) {
[08:28:29.072]                           computeRestarts <- base::computeRestarts
[08:28:29.072]                           grepl <- base::grepl
[08:28:29.072]                           restarts <- computeRestarts(cond)
[08:28:29.072]                           for (restart in restarts) {
[08:28:29.072]                             name <- restart$name
[08:28:29.072]                             if (is.null(name)) 
[08:28:29.072]                               next
[08:28:29.072]                             if (!grepl(pattern, name)) 
[08:28:29.072]                               next
[08:28:29.072]                             invokeRestart(restart)
[08:28:29.072]                             muffled <- TRUE
[08:28:29.072]                             break
[08:28:29.072]                           }
[08:28:29.072]                         }
[08:28:29.072]                       }
[08:28:29.072]                       invisible(muffled)
[08:28:29.072]                     }
[08:28:29.072]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.072]                   }
[08:28:29.072]                 }
[08:28:29.072]                 else {
[08:28:29.072]                   if (TRUE) {
[08:28:29.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.072]                     {
[08:28:29.072]                       inherits <- base::inherits
[08:28:29.072]                       invokeRestart <- base::invokeRestart
[08:28:29.072]                       is.null <- base::is.null
[08:28:29.072]                       muffled <- FALSE
[08:28:29.072]                       if (inherits(cond, "message")) {
[08:28:29.072]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.072]                         if (muffled) 
[08:28:29.072]                           invokeRestart("muffleMessage")
[08:28:29.072]                       }
[08:28:29.072]                       else if (inherits(cond, "warning")) {
[08:28:29.072]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.072]                         if (muffled) 
[08:28:29.072]                           invokeRestart("muffleWarning")
[08:28:29.072]                       }
[08:28:29.072]                       else if (inherits(cond, "condition")) {
[08:28:29.072]                         if (!is.null(pattern)) {
[08:28:29.072]                           computeRestarts <- base::computeRestarts
[08:28:29.072]                           grepl <- base::grepl
[08:28:29.072]                           restarts <- computeRestarts(cond)
[08:28:29.072]                           for (restart in restarts) {
[08:28:29.072]                             name <- restart$name
[08:28:29.072]                             if (is.null(name)) 
[08:28:29.072]                               next
[08:28:29.072]                             if (!grepl(pattern, name)) 
[08:28:29.072]                               next
[08:28:29.072]                             invokeRestart(restart)
[08:28:29.072]                             muffled <- TRUE
[08:28:29.072]                             break
[08:28:29.072]                           }
[08:28:29.072]                         }
[08:28:29.072]                       }
[08:28:29.072]                       invisible(muffled)
[08:28:29.072]                     }
[08:28:29.072]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.072]                   }
[08:28:29.072]                 }
[08:28:29.072]             }
[08:28:29.072]         }))
[08:28:29.072]     }, error = function(ex) {
[08:28:29.072]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:29.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.072]                 ...future.rng), started = ...future.startTime, 
[08:28:29.072]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:29.072]             version = "1.8"), class = "FutureResult")
[08:28:29.072]     }, finally = {
[08:28:29.072]         if (!identical(...future.workdir, getwd())) 
[08:28:29.072]             setwd(...future.workdir)
[08:28:29.072]         {
[08:28:29.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:29.072]                 ...future.oldOptions$nwarnings <- NULL
[08:28:29.072]             }
[08:28:29.072]             base::options(...future.oldOptions)
[08:28:29.072]             if (.Platform$OS.type == "windows") {
[08:28:29.072]                 old_names <- names(...future.oldEnvVars)
[08:28:29.072]                 envs <- base::Sys.getenv()
[08:28:29.072]                 names <- names(envs)
[08:28:29.072]                 common <- intersect(names, old_names)
[08:28:29.072]                 added <- setdiff(names, old_names)
[08:28:29.072]                 removed <- setdiff(old_names, names)
[08:28:29.072]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:29.072]                   envs[common]]
[08:28:29.072]                 NAMES <- toupper(changed)
[08:28:29.072]                 args <- list()
[08:28:29.072]                 for (kk in seq_along(NAMES)) {
[08:28:29.072]                   name <- changed[[kk]]
[08:28:29.072]                   NAME <- NAMES[[kk]]
[08:28:29.072]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.072]                     next
[08:28:29.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.072]                 }
[08:28:29.072]                 NAMES <- toupper(added)
[08:28:29.072]                 for (kk in seq_along(NAMES)) {
[08:28:29.072]                   name <- added[[kk]]
[08:28:29.072]                   NAME <- NAMES[[kk]]
[08:28:29.072]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.072]                     next
[08:28:29.072]                   args[[name]] <- ""
[08:28:29.072]                 }
[08:28:29.072]                 NAMES <- toupper(removed)
[08:28:29.072]                 for (kk in seq_along(NAMES)) {
[08:28:29.072]                   name <- removed[[kk]]
[08:28:29.072]                   NAME <- NAMES[[kk]]
[08:28:29.072]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.072]                     next
[08:28:29.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.072]                 }
[08:28:29.072]                 if (length(args) > 0) 
[08:28:29.072]                   base::do.call(base::Sys.setenv, args = args)
[08:28:29.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:29.072]             }
[08:28:29.072]             else {
[08:28:29.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:29.072]             }
[08:28:29.072]             {
[08:28:29.072]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:29.072]                   0L) {
[08:28:29.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:29.072]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:29.072]                   base::options(opts)
[08:28:29.072]                 }
[08:28:29.072]                 {
[08:28:29.072]                   {
[08:28:29.072]                     NULL
[08:28:29.072]                     RNGkind("Mersenne-Twister")
[08:28:29.072]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:29.072]                       inherits = FALSE)
[08:28:29.072]                   }
[08:28:29.072]                   options(future.plan = NULL)
[08:28:29.072]                   if (is.na(NA_character_)) 
[08:28:29.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:29.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:29.072]                     .init = FALSE)
[08:28:29.072]                 }
[08:28:29.072]             }
[08:28:29.072]         }
[08:28:29.072]     })
[08:28:29.072]     if (TRUE) {
[08:28:29.072]         base::sink(type = "output", split = FALSE)
[08:28:29.072]         if (TRUE) {
[08:28:29.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:29.072]         }
[08:28:29.072]         else {
[08:28:29.072]             ...future.result["stdout"] <- base::list(NULL)
[08:28:29.072]         }
[08:28:29.072]         base::close(...future.stdout)
[08:28:29.072]         ...future.stdout <- NULL
[08:28:29.072]     }
[08:28:29.072]     ...future.result$conditions <- ...future.conditions
[08:28:29.072]     ...future.result$finished <- base::Sys.time()
[08:28:29.072]     ...future.result
[08:28:29.072] }
[08:28:29.074] assign_globals() ...
[08:28:29.074] List of 2
[08:28:29.074]  $ a: num 2
[08:28:29.074]  $ b: num 3
[08:28:29.074]  - attr(*, "where")=List of 2
[08:28:29.074]   ..$ a:<environment: R_EmptyEnv> 
[08:28:29.074]   ..$ b:<environment: R_EmptyEnv> 
[08:28:29.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:29.074]  - attr(*, "resolved")= logi FALSE
[08:28:29.074]  - attr(*, "total_size")= num 78
[08:28:29.077] - copied ‘a’ to environment
[08:28:29.077] - copied ‘b’ to environment
[08:28:29.077] assign_globals() ... done
[08:28:29.077] plan(): Setting new future strategy stack:
[08:28:29.077] List of future strategies:
[08:28:29.077] 1. sequential:
[08:28:29.077]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:29.077]    - tweaked: FALSE
[08:28:29.077]    - call: NULL
[08:28:29.078] plan(): nbrOfWorkers() = 1
[08:28:29.078] plan(): Setting new future strategy stack:
[08:28:29.079] List of future strategies:
[08:28:29.079] 1. sequential:
[08:28:29.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:29.079]    - tweaked: FALSE
[08:28:29.079]    - call: future::plan("sequential")
[08:28:29.079] plan(): nbrOfWorkers() = 1
[08:28:29.079] SequentialFuture started (and completed)
> print(v)
[1] 6
> stopifnot(v == yTruth)
> 
> message("*** multisession(..., workers = 1L) ... DONE")
*** multisession(..., workers = 1L) ... DONE
> 
> 
> message("*** multisession(..., gc = TRUE) ...")
*** multisession(..., gc = TRUE) ...
> plan(multisession, workers = 2L)
[08:28:29.080] plan(): Setting new future strategy stack:
[08:28:29.080] List of future strategies:
[08:28:29.080] 1. multisession:
[08:28:29.080]    - args: function (..., workers = 2L, envir = parent.frame())
[08:28:29.080]    - tweaked: TRUE
[08:28:29.080]    - call: plan(multisession, workers = 2L)
[08:28:29.091] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:28:29.091] multisession:
[08:28:29.091] - args: function (..., workers = 2L, envir = parent.frame())
[08:28:29.091] - tweaked: TRUE
[08:28:29.091] - call: plan(multisession, workers = 2L)
[08:28:29.092] getGlobalsAndPackages() ...
[08:28:29.092] Not searching for globals
[08:28:29.092] - globals: [0] <none>
[08:28:29.092] getGlobalsAndPackages() ... DONE
[08:28:29.364] Packages needed by the future expression (n = 0): <none>
[08:28:29.364] Packages needed by future strategies (n = 0): <none>
[08:28:29.365] {
[08:28:29.365]     {
[08:28:29.365]         {
[08:28:29.365]             ...future.startTime <- base::Sys.time()
[08:28:29.365]             {
[08:28:29.365]                 {
[08:28:29.365]                   {
[08:28:29.365]                     {
[08:28:29.365]                       base::local({
[08:28:29.365]                         has_future <- base::requireNamespace("future", 
[08:28:29.365]                           quietly = TRUE)
[08:28:29.365]                         if (has_future) {
[08:28:29.365]                           ns <- base::getNamespace("future")
[08:28:29.365]                           version <- ns[[".package"]][["version"]]
[08:28:29.365]                           if (is.null(version)) 
[08:28:29.365]                             version <- utils::packageVersion("future")
[08:28:29.365]                         }
[08:28:29.365]                         else {
[08:28:29.365]                           version <- NULL
[08:28:29.365]                         }
[08:28:29.365]                         if (!has_future || version < "1.8.0") {
[08:28:29.365]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:29.365]                             "", base::R.version$version.string), 
[08:28:29.365]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:29.365]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:29.365]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:29.365]                               "release", "version")], collapse = " "), 
[08:28:29.365]                             hostname = base::Sys.info()[["nodename"]])
[08:28:29.365]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:29.365]                             info)
[08:28:29.365]                           info <- base::paste(info, collapse = "; ")
[08:28:29.365]                           if (!has_future) {
[08:28:29.365]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:29.365]                               info)
[08:28:29.365]                           }
[08:28:29.365]                           else {
[08:28:29.365]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:29.365]                               info, version)
[08:28:29.365]                           }
[08:28:29.365]                           base::stop(msg)
[08:28:29.365]                         }
[08:28:29.365]                       })
[08:28:29.365]                     }
[08:28:29.365]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:29.365]                     base::options(mc.cores = 1L)
[08:28:29.365]                   }
[08:28:29.365]                   ...future.strategy.old <- future::plan("list")
[08:28:29.365]                   options(future.plan = NULL)
[08:28:29.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:29.365]                 }
[08:28:29.365]                 ...future.workdir <- getwd()
[08:28:29.365]             }
[08:28:29.365]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:29.365]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:29.365]         }
[08:28:29.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:29.365]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:29.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:29.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:29.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:29.365]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:29.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:29.365]             base::names(...future.oldOptions))
[08:28:29.365]     }
[08:28:29.365]     if (FALSE) {
[08:28:29.365]     }
[08:28:29.365]     else {
[08:28:29.365]         if (TRUE) {
[08:28:29.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:29.365]                 open = "w")
[08:28:29.365]         }
[08:28:29.365]         else {
[08:28:29.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:29.365]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:29.365]         }
[08:28:29.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:29.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:29.365]             base::sink(type = "output", split = FALSE)
[08:28:29.365]             base::close(...future.stdout)
[08:28:29.365]         }, add = TRUE)
[08:28:29.365]     }
[08:28:29.365]     ...future.frame <- base::sys.nframe()
[08:28:29.365]     ...future.conditions <- base::list()
[08:28:29.365]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:29.365]     if (FALSE) {
[08:28:29.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:29.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:29.365]     }
[08:28:29.365]     ...future.result <- base::tryCatch({
[08:28:29.365]         base::withCallingHandlers({
[08:28:29.365]             ...future.value <- base::withVisible(base::local({
[08:28:29.365]                 ...future.makeSendCondition <- base::local({
[08:28:29.365]                   sendCondition <- NULL
[08:28:29.365]                   function(frame = 1L) {
[08:28:29.365]                     if (is.function(sendCondition)) 
[08:28:29.365]                       return(sendCondition)
[08:28:29.365]                     ns <- getNamespace("parallel")
[08:28:29.365]                     if (exists("sendData", mode = "function", 
[08:28:29.365]                       envir = ns)) {
[08:28:29.365]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:29.365]                         envir = ns)
[08:28:29.365]                       envir <- sys.frame(frame)
[08:28:29.365]                       master <- NULL
[08:28:29.365]                       while (!identical(envir, .GlobalEnv) && 
[08:28:29.365]                         !identical(envir, emptyenv())) {
[08:28:29.365]                         if (exists("master", mode = "list", envir = envir, 
[08:28:29.365]                           inherits = FALSE)) {
[08:28:29.365]                           master <- get("master", mode = "list", 
[08:28:29.365]                             envir = envir, inherits = FALSE)
[08:28:29.365]                           if (inherits(master, c("SOCKnode", 
[08:28:29.365]                             "SOCK0node"))) {
[08:28:29.365]                             sendCondition <<- function(cond) {
[08:28:29.365]                               data <- list(type = "VALUE", value = cond, 
[08:28:29.365]                                 success = TRUE)
[08:28:29.365]                               parallel_sendData(master, data)
[08:28:29.365]                             }
[08:28:29.365]                             return(sendCondition)
[08:28:29.365]                           }
[08:28:29.365]                         }
[08:28:29.365]                         frame <- frame + 1L
[08:28:29.365]                         envir <- sys.frame(frame)
[08:28:29.365]                       }
[08:28:29.365]                     }
[08:28:29.365]                     sendCondition <<- function(cond) NULL
[08:28:29.365]                   }
[08:28:29.365]                 })
[08:28:29.365]                 withCallingHandlers({
[08:28:29.365]                   NA
[08:28:29.365]                 }, immediateCondition = function(cond) {
[08:28:29.365]                   sendCondition <- ...future.makeSendCondition()
[08:28:29.365]                   sendCondition(cond)
[08:28:29.365]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.365]                   {
[08:28:29.365]                     inherits <- base::inherits
[08:28:29.365]                     invokeRestart <- base::invokeRestart
[08:28:29.365]                     is.null <- base::is.null
[08:28:29.365]                     muffled <- FALSE
[08:28:29.365]                     if (inherits(cond, "message")) {
[08:28:29.365]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:29.365]                       if (muffled) 
[08:28:29.365]                         invokeRestart("muffleMessage")
[08:28:29.365]                     }
[08:28:29.365]                     else if (inherits(cond, "warning")) {
[08:28:29.365]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:29.365]                       if (muffled) 
[08:28:29.365]                         invokeRestart("muffleWarning")
[08:28:29.365]                     }
[08:28:29.365]                     else if (inherits(cond, "condition")) {
[08:28:29.365]                       if (!is.null(pattern)) {
[08:28:29.365]                         computeRestarts <- base::computeRestarts
[08:28:29.365]                         grepl <- base::grepl
[08:28:29.365]                         restarts <- computeRestarts(cond)
[08:28:29.365]                         for (restart in restarts) {
[08:28:29.365]                           name <- restart$name
[08:28:29.365]                           if (is.null(name)) 
[08:28:29.365]                             next
[08:28:29.365]                           if (!grepl(pattern, name)) 
[08:28:29.365]                             next
[08:28:29.365]                           invokeRestart(restart)
[08:28:29.365]                           muffled <- TRUE
[08:28:29.365]                           break
[08:28:29.365]                         }
[08:28:29.365]                       }
[08:28:29.365]                     }
[08:28:29.365]                     invisible(muffled)
[08:28:29.365]                   }
[08:28:29.365]                   muffleCondition(cond)
[08:28:29.365]                 })
[08:28:29.365]             }))
[08:28:29.365]             future::FutureResult(value = ...future.value$value, 
[08:28:29.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.365]                   ...future.rng), globalenv = if (FALSE) 
[08:28:29.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:29.365]                     ...future.globalenv.names))
[08:28:29.365]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:29.365]         }, condition = base::local({
[08:28:29.365]             c <- base::c
[08:28:29.365]             inherits <- base::inherits
[08:28:29.365]             invokeRestart <- base::invokeRestart
[08:28:29.365]             length <- base::length
[08:28:29.365]             list <- base::list
[08:28:29.365]             seq.int <- base::seq.int
[08:28:29.365]             signalCondition <- base::signalCondition
[08:28:29.365]             sys.calls <- base::sys.calls
[08:28:29.365]             `[[` <- base::`[[`
[08:28:29.365]             `+` <- base::`+`
[08:28:29.365]             `<<-` <- base::`<<-`
[08:28:29.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:29.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:29.365]                   3L)]
[08:28:29.365]             }
[08:28:29.365]             function(cond) {
[08:28:29.365]                 is_error <- inherits(cond, "error")
[08:28:29.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:29.365]                   NULL)
[08:28:29.365]                 if (is_error) {
[08:28:29.365]                   sessionInformation <- function() {
[08:28:29.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:29.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:29.365]                       search = base::search(), system = base::Sys.info())
[08:28:29.365]                   }
[08:28:29.365]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:29.365]                     cond$call), session = sessionInformation(), 
[08:28:29.365]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:29.365]                   signalCondition(cond)
[08:28:29.365]                 }
[08:28:29.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:29.365]                 "immediateCondition"))) {
[08:28:29.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:29.365]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:29.365]                   if (TRUE && !signal) {
[08:28:29.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.365]                     {
[08:28:29.365]                       inherits <- base::inherits
[08:28:29.365]                       invokeRestart <- base::invokeRestart
[08:28:29.365]                       is.null <- base::is.null
[08:28:29.365]                       muffled <- FALSE
[08:28:29.365]                       if (inherits(cond, "message")) {
[08:28:29.365]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.365]                         if (muffled) 
[08:28:29.365]                           invokeRestart("muffleMessage")
[08:28:29.365]                       }
[08:28:29.365]                       else if (inherits(cond, "warning")) {
[08:28:29.365]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.365]                         if (muffled) 
[08:28:29.365]                           invokeRestart("muffleWarning")
[08:28:29.365]                       }
[08:28:29.365]                       else if (inherits(cond, "condition")) {
[08:28:29.365]                         if (!is.null(pattern)) {
[08:28:29.365]                           computeRestarts <- base::computeRestarts
[08:28:29.365]                           grepl <- base::grepl
[08:28:29.365]                           restarts <- computeRestarts(cond)
[08:28:29.365]                           for (restart in restarts) {
[08:28:29.365]                             name <- restart$name
[08:28:29.365]                             if (is.null(name)) 
[08:28:29.365]                               next
[08:28:29.365]                             if (!grepl(pattern, name)) 
[08:28:29.365]                               next
[08:28:29.365]                             invokeRestart(restart)
[08:28:29.365]                             muffled <- TRUE
[08:28:29.365]                             break
[08:28:29.365]                           }
[08:28:29.365]                         }
[08:28:29.365]                       }
[08:28:29.365]                       invisible(muffled)
[08:28:29.365]                     }
[08:28:29.365]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.365]                   }
[08:28:29.365]                 }
[08:28:29.365]                 else {
[08:28:29.365]                   if (TRUE) {
[08:28:29.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.365]                     {
[08:28:29.365]                       inherits <- base::inherits
[08:28:29.365]                       invokeRestart <- base::invokeRestart
[08:28:29.365]                       is.null <- base::is.null
[08:28:29.365]                       muffled <- FALSE
[08:28:29.365]                       if (inherits(cond, "message")) {
[08:28:29.365]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.365]                         if (muffled) 
[08:28:29.365]                           invokeRestart("muffleMessage")
[08:28:29.365]                       }
[08:28:29.365]                       else if (inherits(cond, "warning")) {
[08:28:29.365]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.365]                         if (muffled) 
[08:28:29.365]                           invokeRestart("muffleWarning")
[08:28:29.365]                       }
[08:28:29.365]                       else if (inherits(cond, "condition")) {
[08:28:29.365]                         if (!is.null(pattern)) {
[08:28:29.365]                           computeRestarts <- base::computeRestarts
[08:28:29.365]                           grepl <- base::grepl
[08:28:29.365]                           restarts <- computeRestarts(cond)
[08:28:29.365]                           for (restart in restarts) {
[08:28:29.365]                             name <- restart$name
[08:28:29.365]                             if (is.null(name)) 
[08:28:29.365]                               next
[08:28:29.365]                             if (!grepl(pattern, name)) 
[08:28:29.365]                               next
[08:28:29.365]                             invokeRestart(restart)
[08:28:29.365]                             muffled <- TRUE
[08:28:29.365]                             break
[08:28:29.365]                           }
[08:28:29.365]                         }
[08:28:29.365]                       }
[08:28:29.365]                       invisible(muffled)
[08:28:29.365]                     }
[08:28:29.365]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.365]                   }
[08:28:29.365]                 }
[08:28:29.365]             }
[08:28:29.365]         }))
[08:28:29.365]     }, error = function(ex) {
[08:28:29.365]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:29.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.365]                 ...future.rng), started = ...future.startTime, 
[08:28:29.365]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:29.365]             version = "1.8"), class = "FutureResult")
[08:28:29.365]     }, finally = {
[08:28:29.365]         if (!identical(...future.workdir, getwd())) 
[08:28:29.365]             setwd(...future.workdir)
[08:28:29.365]         {
[08:28:29.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:29.365]                 ...future.oldOptions$nwarnings <- NULL
[08:28:29.365]             }
[08:28:29.365]             base::options(...future.oldOptions)
[08:28:29.365]             if (.Platform$OS.type == "windows") {
[08:28:29.365]                 old_names <- names(...future.oldEnvVars)
[08:28:29.365]                 envs <- base::Sys.getenv()
[08:28:29.365]                 names <- names(envs)
[08:28:29.365]                 common <- intersect(names, old_names)
[08:28:29.365]                 added <- setdiff(names, old_names)
[08:28:29.365]                 removed <- setdiff(old_names, names)
[08:28:29.365]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:29.365]                   envs[common]]
[08:28:29.365]                 NAMES <- toupper(changed)
[08:28:29.365]                 args <- list()
[08:28:29.365]                 for (kk in seq_along(NAMES)) {
[08:28:29.365]                   name <- changed[[kk]]
[08:28:29.365]                   NAME <- NAMES[[kk]]
[08:28:29.365]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.365]                     next
[08:28:29.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.365]                 }
[08:28:29.365]                 NAMES <- toupper(added)
[08:28:29.365]                 for (kk in seq_along(NAMES)) {
[08:28:29.365]                   name <- added[[kk]]
[08:28:29.365]                   NAME <- NAMES[[kk]]
[08:28:29.365]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.365]                     next
[08:28:29.365]                   args[[name]] <- ""
[08:28:29.365]                 }
[08:28:29.365]                 NAMES <- toupper(removed)
[08:28:29.365]                 for (kk in seq_along(NAMES)) {
[08:28:29.365]                   name <- removed[[kk]]
[08:28:29.365]                   NAME <- NAMES[[kk]]
[08:28:29.365]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.365]                     next
[08:28:29.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.365]                 }
[08:28:29.365]                 if (length(args) > 0) 
[08:28:29.365]                   base::do.call(base::Sys.setenv, args = args)
[08:28:29.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:29.365]             }
[08:28:29.365]             else {
[08:28:29.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:29.365]             }
[08:28:29.365]             {
[08:28:29.365]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:29.365]                   0L) {
[08:28:29.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:29.365]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:29.365]                   base::options(opts)
[08:28:29.365]                 }
[08:28:29.365]                 {
[08:28:29.365]                   {
[08:28:29.365]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:29.365]                     NULL
[08:28:29.365]                   }
[08:28:29.365]                   options(future.plan = NULL)
[08:28:29.365]                   if (is.na(NA_character_)) 
[08:28:29.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:29.365]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:29.365]                     .init = FALSE)
[08:28:29.365]                 }
[08:28:29.365]             }
[08:28:29.365]         }
[08:28:29.365]     })
[08:28:29.365]     if (TRUE) {
[08:28:29.365]         base::sink(type = "output", split = FALSE)
[08:28:29.365]         if (TRUE) {
[08:28:29.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:29.365]         }
[08:28:29.365]         else {
[08:28:29.365]             ...future.result["stdout"] <- base::list(NULL)
[08:28:29.365]         }
[08:28:29.365]         base::close(...future.stdout)
[08:28:29.365]         ...future.stdout <- NULL
[08:28:29.365]     }
[08:28:29.365]     ...future.result$conditions <- ...future.conditions
[08:28:29.365]     ...future.result$finished <- base::Sys.time()
[08:28:29.365]     ...future.result
[08:28:29.365] }
[08:28:29.418] MultisessionFuture started
[08:28:29.418] result() for ClusterFuture ...
[08:28:29.419] receiveMessageFromWorker() for ClusterFuture ...
[08:28:29.419] - Validating connection of MultisessionFuture
[08:28:29.450] - received message: FutureResult
[08:28:29.450] - Received FutureResult
[08:28:29.451] - Erased future from FutureRegistry
[08:28:29.451] result() for ClusterFuture ...
[08:28:29.451] - result already collected: FutureResult
[08:28:29.451] result() for ClusterFuture ... done
[08:28:29.451] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:29.451] result() for ClusterFuture ... done
[08:28:29.451] result() for ClusterFuture ...
[08:28:29.451] - result already collected: FutureResult
[08:28:29.451] result() for ClusterFuture ... done
[08:28:29.451] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:28:29.452] plan(): nbrOfWorkers() = 2
> 
> f <- future({ gc() })
[08:28:29.452] getGlobalsAndPackages() ...
[08:28:29.452] Searching for globals...
[08:28:29.453] - globals found: [2] ‘{’, ‘gc’
[08:28:29.453] Searching for globals ... DONE
[08:28:29.453] Resolving globals: FALSE
[08:28:29.453] 
[08:28:29.454] 
[08:28:29.454] getGlobalsAndPackages() ... DONE
[08:28:29.454] run() for ‘Future’ ...
[08:28:29.454] - state: ‘created’
[08:28:29.454] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:29.467] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:29.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:29.467]   - Field: ‘node’
[08:28:29.467]   - Field: ‘label’
[08:28:29.467]   - Field: ‘local’
[08:28:29.467]   - Field: ‘owner’
[08:28:29.467]   - Field: ‘envir’
[08:28:29.468]   - Field: ‘workers’
[08:28:29.468]   - Field: ‘packages’
[08:28:29.468]   - Field: ‘gc’
[08:28:29.468]   - Field: ‘conditions’
[08:28:29.468]   - Field: ‘persistent’
[08:28:29.468]   - Field: ‘expr’
[08:28:29.468]   - Field: ‘uuid’
[08:28:29.468]   - Field: ‘seed’
[08:28:29.468]   - Field: ‘version’
[08:28:29.468]   - Field: ‘result’
[08:28:29.468]   - Field: ‘asynchronous’
[08:28:29.469]   - Field: ‘calls’
[08:28:29.469]   - Field: ‘globals’
[08:28:29.469]   - Field: ‘stdout’
[08:28:29.469]   - Field: ‘earlySignal’
[08:28:29.469]   - Field: ‘lazy’
[08:28:29.469]   - Field: ‘state’
[08:28:29.469] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:29.469] - Launch lazy future ...
[08:28:29.469] Packages needed by the future expression (n = 0): <none>
[08:28:29.470] Packages needed by future strategies (n = 0): <none>
[08:28:29.470] {
[08:28:29.470]     {
[08:28:29.470]         {
[08:28:29.470]             ...future.startTime <- base::Sys.time()
[08:28:29.470]             {
[08:28:29.470]                 {
[08:28:29.470]                   {
[08:28:29.470]                     {
[08:28:29.470]                       base::local({
[08:28:29.470]                         has_future <- base::requireNamespace("future", 
[08:28:29.470]                           quietly = TRUE)
[08:28:29.470]                         if (has_future) {
[08:28:29.470]                           ns <- base::getNamespace("future")
[08:28:29.470]                           version <- ns[[".package"]][["version"]]
[08:28:29.470]                           if (is.null(version)) 
[08:28:29.470]                             version <- utils::packageVersion("future")
[08:28:29.470]                         }
[08:28:29.470]                         else {
[08:28:29.470]                           version <- NULL
[08:28:29.470]                         }
[08:28:29.470]                         if (!has_future || version < "1.8.0") {
[08:28:29.470]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:29.470]                             "", base::R.version$version.string), 
[08:28:29.470]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:29.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:29.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:29.470]                               "release", "version")], collapse = " "), 
[08:28:29.470]                             hostname = base::Sys.info()[["nodename"]])
[08:28:29.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:29.470]                             info)
[08:28:29.470]                           info <- base::paste(info, collapse = "; ")
[08:28:29.470]                           if (!has_future) {
[08:28:29.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:29.470]                               info)
[08:28:29.470]                           }
[08:28:29.470]                           else {
[08:28:29.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:29.470]                               info, version)
[08:28:29.470]                           }
[08:28:29.470]                           base::stop(msg)
[08:28:29.470]                         }
[08:28:29.470]                       })
[08:28:29.470]                     }
[08:28:29.470]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:29.470]                     base::options(mc.cores = 1L)
[08:28:29.470]                   }
[08:28:29.470]                   ...future.strategy.old <- future::plan("list")
[08:28:29.470]                   options(future.plan = NULL)
[08:28:29.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:29.470]                 }
[08:28:29.470]                 ...future.workdir <- getwd()
[08:28:29.470]             }
[08:28:29.470]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:29.470]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:29.470]         }
[08:28:29.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:29.470]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:29.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:29.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:29.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:29.470]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:29.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:29.470]             base::names(...future.oldOptions))
[08:28:29.470]     }
[08:28:29.470]     if (FALSE) {
[08:28:29.470]     }
[08:28:29.470]     else {
[08:28:29.470]         if (TRUE) {
[08:28:29.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:29.470]                 open = "w")
[08:28:29.470]         }
[08:28:29.470]         else {
[08:28:29.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:29.470]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:29.470]         }
[08:28:29.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:29.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:29.470]             base::sink(type = "output", split = FALSE)
[08:28:29.470]             base::close(...future.stdout)
[08:28:29.470]         }, add = TRUE)
[08:28:29.470]     }
[08:28:29.470]     ...future.frame <- base::sys.nframe()
[08:28:29.470]     ...future.conditions <- base::list()
[08:28:29.470]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:29.470]     if (FALSE) {
[08:28:29.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:29.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:29.470]     }
[08:28:29.470]     ...future.result <- base::tryCatch({
[08:28:29.470]         base::withCallingHandlers({
[08:28:29.470]             ...future.value <- base::withVisible(base::local({
[08:28:29.470]                 ...future.makeSendCondition <- base::local({
[08:28:29.470]                   sendCondition <- NULL
[08:28:29.470]                   function(frame = 1L) {
[08:28:29.470]                     if (is.function(sendCondition)) 
[08:28:29.470]                       return(sendCondition)
[08:28:29.470]                     ns <- getNamespace("parallel")
[08:28:29.470]                     if (exists("sendData", mode = "function", 
[08:28:29.470]                       envir = ns)) {
[08:28:29.470]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:29.470]                         envir = ns)
[08:28:29.470]                       envir <- sys.frame(frame)
[08:28:29.470]                       master <- NULL
[08:28:29.470]                       while (!identical(envir, .GlobalEnv) && 
[08:28:29.470]                         !identical(envir, emptyenv())) {
[08:28:29.470]                         if (exists("master", mode = "list", envir = envir, 
[08:28:29.470]                           inherits = FALSE)) {
[08:28:29.470]                           master <- get("master", mode = "list", 
[08:28:29.470]                             envir = envir, inherits = FALSE)
[08:28:29.470]                           if (inherits(master, c("SOCKnode", 
[08:28:29.470]                             "SOCK0node"))) {
[08:28:29.470]                             sendCondition <<- function(cond) {
[08:28:29.470]                               data <- list(type = "VALUE", value = cond, 
[08:28:29.470]                                 success = TRUE)
[08:28:29.470]                               parallel_sendData(master, data)
[08:28:29.470]                             }
[08:28:29.470]                             return(sendCondition)
[08:28:29.470]                           }
[08:28:29.470]                         }
[08:28:29.470]                         frame <- frame + 1L
[08:28:29.470]                         envir <- sys.frame(frame)
[08:28:29.470]                       }
[08:28:29.470]                     }
[08:28:29.470]                     sendCondition <<- function(cond) NULL
[08:28:29.470]                   }
[08:28:29.470]                 })
[08:28:29.470]                 withCallingHandlers({
[08:28:29.470]                   {
[08:28:29.470]                     gc()
[08:28:29.470]                   }
[08:28:29.470]                 }, immediateCondition = function(cond) {
[08:28:29.470]                   sendCondition <- ...future.makeSendCondition()
[08:28:29.470]                   sendCondition(cond)
[08:28:29.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.470]                   {
[08:28:29.470]                     inherits <- base::inherits
[08:28:29.470]                     invokeRestart <- base::invokeRestart
[08:28:29.470]                     is.null <- base::is.null
[08:28:29.470]                     muffled <- FALSE
[08:28:29.470]                     if (inherits(cond, "message")) {
[08:28:29.470]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:29.470]                       if (muffled) 
[08:28:29.470]                         invokeRestart("muffleMessage")
[08:28:29.470]                     }
[08:28:29.470]                     else if (inherits(cond, "warning")) {
[08:28:29.470]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:29.470]                       if (muffled) 
[08:28:29.470]                         invokeRestart("muffleWarning")
[08:28:29.470]                     }
[08:28:29.470]                     else if (inherits(cond, "condition")) {
[08:28:29.470]                       if (!is.null(pattern)) {
[08:28:29.470]                         computeRestarts <- base::computeRestarts
[08:28:29.470]                         grepl <- base::grepl
[08:28:29.470]                         restarts <- computeRestarts(cond)
[08:28:29.470]                         for (restart in restarts) {
[08:28:29.470]                           name <- restart$name
[08:28:29.470]                           if (is.null(name)) 
[08:28:29.470]                             next
[08:28:29.470]                           if (!grepl(pattern, name)) 
[08:28:29.470]                             next
[08:28:29.470]                           invokeRestart(restart)
[08:28:29.470]                           muffled <- TRUE
[08:28:29.470]                           break
[08:28:29.470]                         }
[08:28:29.470]                       }
[08:28:29.470]                     }
[08:28:29.470]                     invisible(muffled)
[08:28:29.470]                   }
[08:28:29.470]                   muffleCondition(cond)
[08:28:29.470]                 })
[08:28:29.470]             }))
[08:28:29.470]             future::FutureResult(value = ...future.value$value, 
[08:28:29.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.470]                   ...future.rng), globalenv = if (FALSE) 
[08:28:29.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:29.470]                     ...future.globalenv.names))
[08:28:29.470]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:29.470]         }, condition = base::local({
[08:28:29.470]             c <- base::c
[08:28:29.470]             inherits <- base::inherits
[08:28:29.470]             invokeRestart <- base::invokeRestart
[08:28:29.470]             length <- base::length
[08:28:29.470]             list <- base::list
[08:28:29.470]             seq.int <- base::seq.int
[08:28:29.470]             signalCondition <- base::signalCondition
[08:28:29.470]             sys.calls <- base::sys.calls
[08:28:29.470]             `[[` <- base::`[[`
[08:28:29.470]             `+` <- base::`+`
[08:28:29.470]             `<<-` <- base::`<<-`
[08:28:29.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:29.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:29.470]                   3L)]
[08:28:29.470]             }
[08:28:29.470]             function(cond) {
[08:28:29.470]                 is_error <- inherits(cond, "error")
[08:28:29.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:29.470]                   NULL)
[08:28:29.470]                 if (is_error) {
[08:28:29.470]                   sessionInformation <- function() {
[08:28:29.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:29.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:29.470]                       search = base::search(), system = base::Sys.info())
[08:28:29.470]                   }
[08:28:29.470]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:29.470]                     cond$call), session = sessionInformation(), 
[08:28:29.470]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:29.470]                   signalCondition(cond)
[08:28:29.470]                 }
[08:28:29.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:29.470]                 "immediateCondition"))) {
[08:28:29.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:29.470]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:29.470]                   if (TRUE && !signal) {
[08:28:29.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.470]                     {
[08:28:29.470]                       inherits <- base::inherits
[08:28:29.470]                       invokeRestart <- base::invokeRestart
[08:28:29.470]                       is.null <- base::is.null
[08:28:29.470]                       muffled <- FALSE
[08:28:29.470]                       if (inherits(cond, "message")) {
[08:28:29.470]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.470]                         if (muffled) 
[08:28:29.470]                           invokeRestart("muffleMessage")
[08:28:29.470]                       }
[08:28:29.470]                       else if (inherits(cond, "warning")) {
[08:28:29.470]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.470]                         if (muffled) 
[08:28:29.470]                           invokeRestart("muffleWarning")
[08:28:29.470]                       }
[08:28:29.470]                       else if (inherits(cond, "condition")) {
[08:28:29.470]                         if (!is.null(pattern)) {
[08:28:29.470]                           computeRestarts <- base::computeRestarts
[08:28:29.470]                           grepl <- base::grepl
[08:28:29.470]                           restarts <- computeRestarts(cond)
[08:28:29.470]                           for (restart in restarts) {
[08:28:29.470]                             name <- restart$name
[08:28:29.470]                             if (is.null(name)) 
[08:28:29.470]                               next
[08:28:29.470]                             if (!grepl(pattern, name)) 
[08:28:29.470]                               next
[08:28:29.470]                             invokeRestart(restart)
[08:28:29.470]                             muffled <- TRUE
[08:28:29.470]                             break
[08:28:29.470]                           }
[08:28:29.470]                         }
[08:28:29.470]                       }
[08:28:29.470]                       invisible(muffled)
[08:28:29.470]                     }
[08:28:29.470]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.470]                   }
[08:28:29.470]                 }
[08:28:29.470]                 else {
[08:28:29.470]                   if (TRUE) {
[08:28:29.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.470]                     {
[08:28:29.470]                       inherits <- base::inherits
[08:28:29.470]                       invokeRestart <- base::invokeRestart
[08:28:29.470]                       is.null <- base::is.null
[08:28:29.470]                       muffled <- FALSE
[08:28:29.470]                       if (inherits(cond, "message")) {
[08:28:29.470]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.470]                         if (muffled) 
[08:28:29.470]                           invokeRestart("muffleMessage")
[08:28:29.470]                       }
[08:28:29.470]                       else if (inherits(cond, "warning")) {
[08:28:29.470]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.470]                         if (muffled) 
[08:28:29.470]                           invokeRestart("muffleWarning")
[08:28:29.470]                       }
[08:28:29.470]                       else if (inherits(cond, "condition")) {
[08:28:29.470]                         if (!is.null(pattern)) {
[08:28:29.470]                           computeRestarts <- base::computeRestarts
[08:28:29.470]                           grepl <- base::grepl
[08:28:29.470]                           restarts <- computeRestarts(cond)
[08:28:29.470]                           for (restart in restarts) {
[08:28:29.470]                             name <- restart$name
[08:28:29.470]                             if (is.null(name)) 
[08:28:29.470]                               next
[08:28:29.470]                             if (!grepl(pattern, name)) 
[08:28:29.470]                               next
[08:28:29.470]                             invokeRestart(restart)
[08:28:29.470]                             muffled <- TRUE
[08:28:29.470]                             break
[08:28:29.470]                           }
[08:28:29.470]                         }
[08:28:29.470]                       }
[08:28:29.470]                       invisible(muffled)
[08:28:29.470]                     }
[08:28:29.470]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.470]                   }
[08:28:29.470]                 }
[08:28:29.470]             }
[08:28:29.470]         }))
[08:28:29.470]     }, error = function(ex) {
[08:28:29.470]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:29.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.470]                 ...future.rng), started = ...future.startTime, 
[08:28:29.470]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:29.470]             version = "1.8"), class = "FutureResult")
[08:28:29.470]     }, finally = {
[08:28:29.470]         if (!identical(...future.workdir, getwd())) 
[08:28:29.470]             setwd(...future.workdir)
[08:28:29.470]         {
[08:28:29.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:29.470]                 ...future.oldOptions$nwarnings <- NULL
[08:28:29.470]             }
[08:28:29.470]             base::options(...future.oldOptions)
[08:28:29.470]             if (.Platform$OS.type == "windows") {
[08:28:29.470]                 old_names <- names(...future.oldEnvVars)
[08:28:29.470]                 envs <- base::Sys.getenv()
[08:28:29.470]                 names <- names(envs)
[08:28:29.470]                 common <- intersect(names, old_names)
[08:28:29.470]                 added <- setdiff(names, old_names)
[08:28:29.470]                 removed <- setdiff(old_names, names)
[08:28:29.470]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:29.470]                   envs[common]]
[08:28:29.470]                 NAMES <- toupper(changed)
[08:28:29.470]                 args <- list()
[08:28:29.470]                 for (kk in seq_along(NAMES)) {
[08:28:29.470]                   name <- changed[[kk]]
[08:28:29.470]                   NAME <- NAMES[[kk]]
[08:28:29.470]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.470]                     next
[08:28:29.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.470]                 }
[08:28:29.470]                 NAMES <- toupper(added)
[08:28:29.470]                 for (kk in seq_along(NAMES)) {
[08:28:29.470]                   name <- added[[kk]]
[08:28:29.470]                   NAME <- NAMES[[kk]]
[08:28:29.470]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.470]                     next
[08:28:29.470]                   args[[name]] <- ""
[08:28:29.470]                 }
[08:28:29.470]                 NAMES <- toupper(removed)
[08:28:29.470]                 for (kk in seq_along(NAMES)) {
[08:28:29.470]                   name <- removed[[kk]]
[08:28:29.470]                   NAME <- NAMES[[kk]]
[08:28:29.470]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.470]                     next
[08:28:29.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.470]                 }
[08:28:29.470]                 if (length(args) > 0) 
[08:28:29.470]                   base::do.call(base::Sys.setenv, args = args)
[08:28:29.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:29.470]             }
[08:28:29.470]             else {
[08:28:29.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:29.470]             }
[08:28:29.470]             {
[08:28:29.470]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:29.470]                   0L) {
[08:28:29.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:29.470]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:29.470]                   base::options(opts)
[08:28:29.470]                 }
[08:28:29.470]                 {
[08:28:29.470]                   {
[08:28:29.470]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:29.470]                     NULL
[08:28:29.470]                   }
[08:28:29.470]                   options(future.plan = NULL)
[08:28:29.470]                   if (is.na(NA_character_)) 
[08:28:29.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:29.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:29.470]                     .init = FALSE)
[08:28:29.470]                 }
[08:28:29.470]             }
[08:28:29.470]         }
[08:28:29.470]     })
[08:28:29.470]     if (TRUE) {
[08:28:29.470]         base::sink(type = "output", split = FALSE)
[08:28:29.470]         if (TRUE) {
[08:28:29.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:29.470]         }
[08:28:29.470]         else {
[08:28:29.470]             ...future.result["stdout"] <- base::list(NULL)
[08:28:29.470]         }
[08:28:29.470]         base::close(...future.stdout)
[08:28:29.470]         ...future.stdout <- NULL
[08:28:29.470]     }
[08:28:29.470]     ...future.result$conditions <- ...future.conditions
[08:28:29.470]     ...future.result$finished <- base::Sys.time()
[08:28:29.470]     ...future.result
[08:28:29.470] }
[08:28:29.473] MultisessionFuture started
[08:28:29.473] - Launch lazy future ... done
[08:28:29.473] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[08:28:29.473] result() for ClusterFuture ...
[08:28:29.474] receiveMessageFromWorker() for ClusterFuture ...
[08:28:29.474] - Validating connection of MultisessionFuture
[08:28:29.548] - received message: FutureResult
[08:28:29.548] - Received FutureResult
[08:28:29.549] - Erased future from FutureRegistry
[08:28:29.549] result() for ClusterFuture ...
[08:28:29.549] - result already collected: FutureResult
[08:28:29.549] result() for ClusterFuture ... done
[08:28:29.549] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:29.549] result() for ClusterFuture ... done
[08:28:29.550] result() for ClusterFuture ...
[08:28:29.550] - result already collected: FutureResult
[08:28:29.550] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 409538 21.9     692222   37   692222 37.0
Vcells 732386  5.6    8388608   64  1923645 14.7
> 
> f <- future({ integer(10e6) })
[08:28:29.550] getGlobalsAndPackages() ...
[08:28:29.551] Searching for globals...
[08:28:29.552] - globals found: [2] ‘{’, ‘integer’
[08:28:29.552] Searching for globals ... DONE
[08:28:29.553] Resolving globals: FALSE
[08:28:29.553] 
[08:28:29.553] 
[08:28:29.553] getGlobalsAndPackages() ... DONE
[08:28:29.554] run() for ‘Future’ ...
[08:28:29.554] - state: ‘created’
[08:28:29.554] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:29.569] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:29.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:29.569]   - Field: ‘node’
[08:28:29.570]   - Field: ‘label’
[08:28:29.570]   - Field: ‘local’
[08:28:29.570]   - Field: ‘owner’
[08:28:29.570]   - Field: ‘envir’
[08:28:29.570]   - Field: ‘workers’
[08:28:29.571]   - Field: ‘packages’
[08:28:29.571]   - Field: ‘gc’
[08:28:29.571]   - Field: ‘conditions’
[08:28:29.571]   - Field: ‘persistent’
[08:28:29.571]   - Field: ‘expr’
[08:28:29.571]   - Field: ‘uuid’
[08:28:29.571]   - Field: ‘seed’
[08:28:29.571]   - Field: ‘version’
[08:28:29.571]   - Field: ‘result’
[08:28:29.572]   - Field: ‘asynchronous’
[08:28:29.572]   - Field: ‘calls’
[08:28:29.572]   - Field: ‘globals’
[08:28:29.572]   - Field: ‘stdout’
[08:28:29.572]   - Field: ‘earlySignal’
[08:28:29.572]   - Field: ‘lazy’
[08:28:29.572]   - Field: ‘state’
[08:28:29.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:29.572] - Launch lazy future ...
[08:28:29.573] Packages needed by the future expression (n = 0): <none>
[08:28:29.573] Packages needed by future strategies (n = 0): <none>
[08:28:29.573] {
[08:28:29.573]     {
[08:28:29.573]         {
[08:28:29.573]             ...future.startTime <- base::Sys.time()
[08:28:29.573]             {
[08:28:29.573]                 {
[08:28:29.573]                   {
[08:28:29.573]                     {
[08:28:29.573]                       base::local({
[08:28:29.573]                         has_future <- base::requireNamespace("future", 
[08:28:29.573]                           quietly = TRUE)
[08:28:29.573]                         if (has_future) {
[08:28:29.573]                           ns <- base::getNamespace("future")
[08:28:29.573]                           version <- ns[[".package"]][["version"]]
[08:28:29.573]                           if (is.null(version)) 
[08:28:29.573]                             version <- utils::packageVersion("future")
[08:28:29.573]                         }
[08:28:29.573]                         else {
[08:28:29.573]                           version <- NULL
[08:28:29.573]                         }
[08:28:29.573]                         if (!has_future || version < "1.8.0") {
[08:28:29.573]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:29.573]                             "", base::R.version$version.string), 
[08:28:29.573]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:29.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:29.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:29.573]                               "release", "version")], collapse = " "), 
[08:28:29.573]                             hostname = base::Sys.info()[["nodename"]])
[08:28:29.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:29.573]                             info)
[08:28:29.573]                           info <- base::paste(info, collapse = "; ")
[08:28:29.573]                           if (!has_future) {
[08:28:29.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:29.573]                               info)
[08:28:29.573]                           }
[08:28:29.573]                           else {
[08:28:29.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:29.573]                               info, version)
[08:28:29.573]                           }
[08:28:29.573]                           base::stop(msg)
[08:28:29.573]                         }
[08:28:29.573]                       })
[08:28:29.573]                     }
[08:28:29.573]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:29.573]                     base::options(mc.cores = 1L)
[08:28:29.573]                   }
[08:28:29.573]                   ...future.strategy.old <- future::plan("list")
[08:28:29.573]                   options(future.plan = NULL)
[08:28:29.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:29.573]                 }
[08:28:29.573]                 ...future.workdir <- getwd()
[08:28:29.573]             }
[08:28:29.573]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:29.573]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:29.573]         }
[08:28:29.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:29.573]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:29.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:29.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:29.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:29.573]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:29.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:29.573]             base::names(...future.oldOptions))
[08:28:29.573]     }
[08:28:29.573]     if (FALSE) {
[08:28:29.573]     }
[08:28:29.573]     else {
[08:28:29.573]         if (TRUE) {
[08:28:29.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:29.573]                 open = "w")
[08:28:29.573]         }
[08:28:29.573]         else {
[08:28:29.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:29.573]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:29.573]         }
[08:28:29.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:29.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:29.573]             base::sink(type = "output", split = FALSE)
[08:28:29.573]             base::close(...future.stdout)
[08:28:29.573]         }, add = TRUE)
[08:28:29.573]     }
[08:28:29.573]     ...future.frame <- base::sys.nframe()
[08:28:29.573]     ...future.conditions <- base::list()
[08:28:29.573]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:29.573]     if (FALSE) {
[08:28:29.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:29.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:29.573]     }
[08:28:29.573]     ...future.result <- base::tryCatch({
[08:28:29.573]         base::withCallingHandlers({
[08:28:29.573]             ...future.value <- base::withVisible(base::local({
[08:28:29.573]                 ...future.makeSendCondition <- base::local({
[08:28:29.573]                   sendCondition <- NULL
[08:28:29.573]                   function(frame = 1L) {
[08:28:29.573]                     if (is.function(sendCondition)) 
[08:28:29.573]                       return(sendCondition)
[08:28:29.573]                     ns <- getNamespace("parallel")
[08:28:29.573]                     if (exists("sendData", mode = "function", 
[08:28:29.573]                       envir = ns)) {
[08:28:29.573]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:29.573]                         envir = ns)
[08:28:29.573]                       envir <- sys.frame(frame)
[08:28:29.573]                       master <- NULL
[08:28:29.573]                       while (!identical(envir, .GlobalEnv) && 
[08:28:29.573]                         !identical(envir, emptyenv())) {
[08:28:29.573]                         if (exists("master", mode = "list", envir = envir, 
[08:28:29.573]                           inherits = FALSE)) {
[08:28:29.573]                           master <- get("master", mode = "list", 
[08:28:29.573]                             envir = envir, inherits = FALSE)
[08:28:29.573]                           if (inherits(master, c("SOCKnode", 
[08:28:29.573]                             "SOCK0node"))) {
[08:28:29.573]                             sendCondition <<- function(cond) {
[08:28:29.573]                               data <- list(type = "VALUE", value = cond, 
[08:28:29.573]                                 success = TRUE)
[08:28:29.573]                               parallel_sendData(master, data)
[08:28:29.573]                             }
[08:28:29.573]                             return(sendCondition)
[08:28:29.573]                           }
[08:28:29.573]                         }
[08:28:29.573]                         frame <- frame + 1L
[08:28:29.573]                         envir <- sys.frame(frame)
[08:28:29.573]                       }
[08:28:29.573]                     }
[08:28:29.573]                     sendCondition <<- function(cond) NULL
[08:28:29.573]                   }
[08:28:29.573]                 })
[08:28:29.573]                 withCallingHandlers({
[08:28:29.573]                   {
[08:28:29.573]                     integer(1e+07)
[08:28:29.573]                   }
[08:28:29.573]                 }, immediateCondition = function(cond) {
[08:28:29.573]                   sendCondition <- ...future.makeSendCondition()
[08:28:29.573]                   sendCondition(cond)
[08:28:29.573]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.573]                   {
[08:28:29.573]                     inherits <- base::inherits
[08:28:29.573]                     invokeRestart <- base::invokeRestart
[08:28:29.573]                     is.null <- base::is.null
[08:28:29.573]                     muffled <- FALSE
[08:28:29.573]                     if (inherits(cond, "message")) {
[08:28:29.573]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:29.573]                       if (muffled) 
[08:28:29.573]                         invokeRestart("muffleMessage")
[08:28:29.573]                     }
[08:28:29.573]                     else if (inherits(cond, "warning")) {
[08:28:29.573]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:29.573]                       if (muffled) 
[08:28:29.573]                         invokeRestart("muffleWarning")
[08:28:29.573]                     }
[08:28:29.573]                     else if (inherits(cond, "condition")) {
[08:28:29.573]                       if (!is.null(pattern)) {
[08:28:29.573]                         computeRestarts <- base::computeRestarts
[08:28:29.573]                         grepl <- base::grepl
[08:28:29.573]                         restarts <- computeRestarts(cond)
[08:28:29.573]                         for (restart in restarts) {
[08:28:29.573]                           name <- restart$name
[08:28:29.573]                           if (is.null(name)) 
[08:28:29.573]                             next
[08:28:29.573]                           if (!grepl(pattern, name)) 
[08:28:29.573]                             next
[08:28:29.573]                           invokeRestart(restart)
[08:28:29.573]                           muffled <- TRUE
[08:28:29.573]                           break
[08:28:29.573]                         }
[08:28:29.573]                       }
[08:28:29.573]                     }
[08:28:29.573]                     invisible(muffled)
[08:28:29.573]                   }
[08:28:29.573]                   muffleCondition(cond)
[08:28:29.573]                 })
[08:28:29.573]             }))
[08:28:29.573]             future::FutureResult(value = ...future.value$value, 
[08:28:29.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.573]                   ...future.rng), globalenv = if (FALSE) 
[08:28:29.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:29.573]                     ...future.globalenv.names))
[08:28:29.573]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:29.573]         }, condition = base::local({
[08:28:29.573]             c <- base::c
[08:28:29.573]             inherits <- base::inherits
[08:28:29.573]             invokeRestart <- base::invokeRestart
[08:28:29.573]             length <- base::length
[08:28:29.573]             list <- base::list
[08:28:29.573]             seq.int <- base::seq.int
[08:28:29.573]             signalCondition <- base::signalCondition
[08:28:29.573]             sys.calls <- base::sys.calls
[08:28:29.573]             `[[` <- base::`[[`
[08:28:29.573]             `+` <- base::`+`
[08:28:29.573]             `<<-` <- base::`<<-`
[08:28:29.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:29.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:29.573]                   3L)]
[08:28:29.573]             }
[08:28:29.573]             function(cond) {
[08:28:29.573]                 is_error <- inherits(cond, "error")
[08:28:29.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:29.573]                   NULL)
[08:28:29.573]                 if (is_error) {
[08:28:29.573]                   sessionInformation <- function() {
[08:28:29.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:29.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:29.573]                       search = base::search(), system = base::Sys.info())
[08:28:29.573]                   }
[08:28:29.573]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:29.573]                     cond$call), session = sessionInformation(), 
[08:28:29.573]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:29.573]                   signalCondition(cond)
[08:28:29.573]                 }
[08:28:29.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:29.573]                 "immediateCondition"))) {
[08:28:29.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:29.573]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:29.573]                   if (TRUE && !signal) {
[08:28:29.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.573]                     {
[08:28:29.573]                       inherits <- base::inherits
[08:28:29.573]                       invokeRestart <- base::invokeRestart
[08:28:29.573]                       is.null <- base::is.null
[08:28:29.573]                       muffled <- FALSE
[08:28:29.573]                       if (inherits(cond, "message")) {
[08:28:29.573]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.573]                         if (muffled) 
[08:28:29.573]                           invokeRestart("muffleMessage")
[08:28:29.573]                       }
[08:28:29.573]                       else if (inherits(cond, "warning")) {
[08:28:29.573]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.573]                         if (muffled) 
[08:28:29.573]                           invokeRestart("muffleWarning")
[08:28:29.573]                       }
[08:28:29.573]                       else if (inherits(cond, "condition")) {
[08:28:29.573]                         if (!is.null(pattern)) {
[08:28:29.573]                           computeRestarts <- base::computeRestarts
[08:28:29.573]                           grepl <- base::grepl
[08:28:29.573]                           restarts <- computeRestarts(cond)
[08:28:29.573]                           for (restart in restarts) {
[08:28:29.573]                             name <- restart$name
[08:28:29.573]                             if (is.null(name)) 
[08:28:29.573]                               next
[08:28:29.573]                             if (!grepl(pattern, name)) 
[08:28:29.573]                               next
[08:28:29.573]                             invokeRestart(restart)
[08:28:29.573]                             muffled <- TRUE
[08:28:29.573]                             break
[08:28:29.573]                           }
[08:28:29.573]                         }
[08:28:29.573]                       }
[08:28:29.573]                       invisible(muffled)
[08:28:29.573]                     }
[08:28:29.573]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.573]                   }
[08:28:29.573]                 }
[08:28:29.573]                 else {
[08:28:29.573]                   if (TRUE) {
[08:28:29.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.573]                     {
[08:28:29.573]                       inherits <- base::inherits
[08:28:29.573]                       invokeRestart <- base::invokeRestart
[08:28:29.573]                       is.null <- base::is.null
[08:28:29.573]                       muffled <- FALSE
[08:28:29.573]                       if (inherits(cond, "message")) {
[08:28:29.573]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.573]                         if (muffled) 
[08:28:29.573]                           invokeRestart("muffleMessage")
[08:28:29.573]                       }
[08:28:29.573]                       else if (inherits(cond, "warning")) {
[08:28:29.573]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.573]                         if (muffled) 
[08:28:29.573]                           invokeRestart("muffleWarning")
[08:28:29.573]                       }
[08:28:29.573]                       else if (inherits(cond, "condition")) {
[08:28:29.573]                         if (!is.null(pattern)) {
[08:28:29.573]                           computeRestarts <- base::computeRestarts
[08:28:29.573]                           grepl <- base::grepl
[08:28:29.573]                           restarts <- computeRestarts(cond)
[08:28:29.573]                           for (restart in restarts) {
[08:28:29.573]                             name <- restart$name
[08:28:29.573]                             if (is.null(name)) 
[08:28:29.573]                               next
[08:28:29.573]                             if (!grepl(pattern, name)) 
[08:28:29.573]                               next
[08:28:29.573]                             invokeRestart(restart)
[08:28:29.573]                             muffled <- TRUE
[08:28:29.573]                             break
[08:28:29.573]                           }
[08:28:29.573]                         }
[08:28:29.573]                       }
[08:28:29.573]                       invisible(muffled)
[08:28:29.573]                     }
[08:28:29.573]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.573]                   }
[08:28:29.573]                 }
[08:28:29.573]             }
[08:28:29.573]         }))
[08:28:29.573]     }, error = function(ex) {
[08:28:29.573]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:29.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.573]                 ...future.rng), started = ...future.startTime, 
[08:28:29.573]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:29.573]             version = "1.8"), class = "FutureResult")
[08:28:29.573]     }, finally = {
[08:28:29.573]         if (!identical(...future.workdir, getwd())) 
[08:28:29.573]             setwd(...future.workdir)
[08:28:29.573]         {
[08:28:29.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:29.573]                 ...future.oldOptions$nwarnings <- NULL
[08:28:29.573]             }
[08:28:29.573]             base::options(...future.oldOptions)
[08:28:29.573]             if (.Platform$OS.type == "windows") {
[08:28:29.573]                 old_names <- names(...future.oldEnvVars)
[08:28:29.573]                 envs <- base::Sys.getenv()
[08:28:29.573]                 names <- names(envs)
[08:28:29.573]                 common <- intersect(names, old_names)
[08:28:29.573]                 added <- setdiff(names, old_names)
[08:28:29.573]                 removed <- setdiff(old_names, names)
[08:28:29.573]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:29.573]                   envs[common]]
[08:28:29.573]                 NAMES <- toupper(changed)
[08:28:29.573]                 args <- list()
[08:28:29.573]                 for (kk in seq_along(NAMES)) {
[08:28:29.573]                   name <- changed[[kk]]
[08:28:29.573]                   NAME <- NAMES[[kk]]
[08:28:29.573]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.573]                     next
[08:28:29.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.573]                 }
[08:28:29.573]                 NAMES <- toupper(added)
[08:28:29.573]                 for (kk in seq_along(NAMES)) {
[08:28:29.573]                   name <- added[[kk]]
[08:28:29.573]                   NAME <- NAMES[[kk]]
[08:28:29.573]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.573]                     next
[08:28:29.573]                   args[[name]] <- ""
[08:28:29.573]                 }
[08:28:29.573]                 NAMES <- toupper(removed)
[08:28:29.573]                 for (kk in seq_along(NAMES)) {
[08:28:29.573]                   name <- removed[[kk]]
[08:28:29.573]                   NAME <- NAMES[[kk]]
[08:28:29.573]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.573]                     next
[08:28:29.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.573]                 }
[08:28:29.573]                 if (length(args) > 0) 
[08:28:29.573]                   base::do.call(base::Sys.setenv, args = args)
[08:28:29.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:29.573]             }
[08:28:29.573]             else {
[08:28:29.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:29.573]             }
[08:28:29.573]             {
[08:28:29.573]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:29.573]                   0L) {
[08:28:29.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:29.573]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:29.573]                   base::options(opts)
[08:28:29.573]                 }
[08:28:29.573]                 {
[08:28:29.573]                   {
[08:28:29.573]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:29.573]                     NULL
[08:28:29.573]                   }
[08:28:29.573]                   options(future.plan = NULL)
[08:28:29.573]                   if (is.na(NA_character_)) 
[08:28:29.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:29.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:29.573]                     .init = FALSE)
[08:28:29.573]                 }
[08:28:29.573]             }
[08:28:29.573]         }
[08:28:29.573]     })
[08:28:29.573]     if (TRUE) {
[08:28:29.573]         base::sink(type = "output", split = FALSE)
[08:28:29.573]         if (TRUE) {
[08:28:29.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:29.573]         }
[08:28:29.573]         else {
[08:28:29.573]             ...future.result["stdout"] <- base::list(NULL)
[08:28:29.573]         }
[08:28:29.573]         base::close(...future.stdout)
[08:28:29.573]         ...future.stdout <- NULL
[08:28:29.573]     }
[08:28:29.573]     ...future.result$conditions <- ...future.conditions
[08:28:29.573]     ...future.result$finished <- base::Sys.time()
[08:28:29.573]     ...future.result
[08:28:29.573] }
[08:28:29.576] MultisessionFuture started
[08:28:29.576] - Launch lazy future ... done
[08:28:29.577] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[08:28:29.577] result() for ClusterFuture ...
[08:28:29.577] receiveMessageFromWorker() for ClusterFuture ...
[08:28:29.577] - Validating connection of MultisessionFuture
[08:28:29.683] - received message: FutureResult
[08:28:29.683] - Received FutureResult
[08:28:29.683] - Erased future from FutureRegistry
[08:28:29.683] result() for ClusterFuture ...
[08:28:29.683] - result already collected: FutureResult
[08:28:29.684] result() for ClusterFuture ... done
[08:28:29.684] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:29.684] result() for ClusterFuture ... done
[08:28:29.684] result() for ClusterFuture ...
[08:28:29.684] - result already collected: FutureResult
[08:28:29.684] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[08:28:29.684] getGlobalsAndPackages() ...
[08:28:29.685] Searching for globals...
[08:28:29.685] - globals found: [2] ‘{’, ‘gc’
[08:28:29.686] Searching for globals ... DONE
[08:28:29.686] Resolving globals: FALSE
[08:28:29.686] 
[08:28:29.686] 
[08:28:29.686] getGlobalsAndPackages() ... DONE
[08:28:29.686] run() for ‘Future’ ...
[08:28:29.687] - state: ‘created’
[08:28:29.687] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:29.699] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:29.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:29.699]   - Field: ‘node’
[08:28:29.700]   - Field: ‘label’
[08:28:29.700]   - Field: ‘local’
[08:28:29.700]   - Field: ‘owner’
[08:28:29.700]   - Field: ‘envir’
[08:28:29.700]   - Field: ‘workers’
[08:28:29.700]   - Field: ‘packages’
[08:28:29.700]   - Field: ‘gc’
[08:28:29.700]   - Field: ‘conditions’
[08:28:29.700]   - Field: ‘persistent’
[08:28:29.700]   - Field: ‘expr’
[08:28:29.700]   - Field: ‘uuid’
[08:28:29.701]   - Field: ‘seed’
[08:28:29.701]   - Field: ‘version’
[08:28:29.701]   - Field: ‘result’
[08:28:29.701]   - Field: ‘asynchronous’
[08:28:29.701]   - Field: ‘calls’
[08:28:29.701]   - Field: ‘globals’
[08:28:29.701]   - Field: ‘stdout’
[08:28:29.701]   - Field: ‘earlySignal’
[08:28:29.701]   - Field: ‘lazy’
[08:28:29.701]   - Field: ‘state’
[08:28:29.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:29.701] - Launch lazy future ...
[08:28:29.702] Packages needed by the future expression (n = 0): <none>
[08:28:29.702] Packages needed by future strategies (n = 0): <none>
[08:28:29.702] {
[08:28:29.702]     {
[08:28:29.702]         {
[08:28:29.702]             ...future.startTime <- base::Sys.time()
[08:28:29.702]             {
[08:28:29.702]                 {
[08:28:29.702]                   {
[08:28:29.702]                     {
[08:28:29.702]                       base::local({
[08:28:29.702]                         has_future <- base::requireNamespace("future", 
[08:28:29.702]                           quietly = TRUE)
[08:28:29.702]                         if (has_future) {
[08:28:29.702]                           ns <- base::getNamespace("future")
[08:28:29.702]                           version <- ns[[".package"]][["version"]]
[08:28:29.702]                           if (is.null(version)) 
[08:28:29.702]                             version <- utils::packageVersion("future")
[08:28:29.702]                         }
[08:28:29.702]                         else {
[08:28:29.702]                           version <- NULL
[08:28:29.702]                         }
[08:28:29.702]                         if (!has_future || version < "1.8.0") {
[08:28:29.702]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:29.702]                             "", base::R.version$version.string), 
[08:28:29.702]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:29.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:29.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:29.702]                               "release", "version")], collapse = " "), 
[08:28:29.702]                             hostname = base::Sys.info()[["nodename"]])
[08:28:29.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:29.702]                             info)
[08:28:29.702]                           info <- base::paste(info, collapse = "; ")
[08:28:29.702]                           if (!has_future) {
[08:28:29.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:29.702]                               info)
[08:28:29.702]                           }
[08:28:29.702]                           else {
[08:28:29.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:29.702]                               info, version)
[08:28:29.702]                           }
[08:28:29.702]                           base::stop(msg)
[08:28:29.702]                         }
[08:28:29.702]                       })
[08:28:29.702]                     }
[08:28:29.702]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:29.702]                     base::options(mc.cores = 1L)
[08:28:29.702]                   }
[08:28:29.702]                   ...future.strategy.old <- future::plan("list")
[08:28:29.702]                   options(future.plan = NULL)
[08:28:29.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:29.702]                 }
[08:28:29.702]                 ...future.workdir <- getwd()
[08:28:29.702]             }
[08:28:29.702]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:29.702]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:29.702]         }
[08:28:29.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:29.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:29.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:29.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:29.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:29.702]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:29.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:29.702]             base::names(...future.oldOptions))
[08:28:29.702]     }
[08:28:29.702]     if (FALSE) {
[08:28:29.702]     }
[08:28:29.702]     else {
[08:28:29.702]         if (TRUE) {
[08:28:29.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:29.702]                 open = "w")
[08:28:29.702]         }
[08:28:29.702]         else {
[08:28:29.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:29.702]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:29.702]         }
[08:28:29.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:29.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:29.702]             base::sink(type = "output", split = FALSE)
[08:28:29.702]             base::close(...future.stdout)
[08:28:29.702]         }, add = TRUE)
[08:28:29.702]     }
[08:28:29.702]     ...future.frame <- base::sys.nframe()
[08:28:29.702]     ...future.conditions <- base::list()
[08:28:29.702]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:29.702]     if (FALSE) {
[08:28:29.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:29.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:29.702]     }
[08:28:29.702]     ...future.result <- base::tryCatch({
[08:28:29.702]         base::withCallingHandlers({
[08:28:29.702]             ...future.value <- base::withVisible(base::local({
[08:28:29.702]                 ...future.makeSendCondition <- base::local({
[08:28:29.702]                   sendCondition <- NULL
[08:28:29.702]                   function(frame = 1L) {
[08:28:29.702]                     if (is.function(sendCondition)) 
[08:28:29.702]                       return(sendCondition)
[08:28:29.702]                     ns <- getNamespace("parallel")
[08:28:29.702]                     if (exists("sendData", mode = "function", 
[08:28:29.702]                       envir = ns)) {
[08:28:29.702]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:29.702]                         envir = ns)
[08:28:29.702]                       envir <- sys.frame(frame)
[08:28:29.702]                       master <- NULL
[08:28:29.702]                       while (!identical(envir, .GlobalEnv) && 
[08:28:29.702]                         !identical(envir, emptyenv())) {
[08:28:29.702]                         if (exists("master", mode = "list", envir = envir, 
[08:28:29.702]                           inherits = FALSE)) {
[08:28:29.702]                           master <- get("master", mode = "list", 
[08:28:29.702]                             envir = envir, inherits = FALSE)
[08:28:29.702]                           if (inherits(master, c("SOCKnode", 
[08:28:29.702]                             "SOCK0node"))) {
[08:28:29.702]                             sendCondition <<- function(cond) {
[08:28:29.702]                               data <- list(type = "VALUE", value = cond, 
[08:28:29.702]                                 success = TRUE)
[08:28:29.702]                               parallel_sendData(master, data)
[08:28:29.702]                             }
[08:28:29.702]                             return(sendCondition)
[08:28:29.702]                           }
[08:28:29.702]                         }
[08:28:29.702]                         frame <- frame + 1L
[08:28:29.702]                         envir <- sys.frame(frame)
[08:28:29.702]                       }
[08:28:29.702]                     }
[08:28:29.702]                     sendCondition <<- function(cond) NULL
[08:28:29.702]                   }
[08:28:29.702]                 })
[08:28:29.702]                 withCallingHandlers({
[08:28:29.702]                   {
[08:28:29.702]                     gc()
[08:28:29.702]                   }
[08:28:29.702]                 }, immediateCondition = function(cond) {
[08:28:29.702]                   sendCondition <- ...future.makeSendCondition()
[08:28:29.702]                   sendCondition(cond)
[08:28:29.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.702]                   {
[08:28:29.702]                     inherits <- base::inherits
[08:28:29.702]                     invokeRestart <- base::invokeRestart
[08:28:29.702]                     is.null <- base::is.null
[08:28:29.702]                     muffled <- FALSE
[08:28:29.702]                     if (inherits(cond, "message")) {
[08:28:29.702]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:29.702]                       if (muffled) 
[08:28:29.702]                         invokeRestart("muffleMessage")
[08:28:29.702]                     }
[08:28:29.702]                     else if (inherits(cond, "warning")) {
[08:28:29.702]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:29.702]                       if (muffled) 
[08:28:29.702]                         invokeRestart("muffleWarning")
[08:28:29.702]                     }
[08:28:29.702]                     else if (inherits(cond, "condition")) {
[08:28:29.702]                       if (!is.null(pattern)) {
[08:28:29.702]                         computeRestarts <- base::computeRestarts
[08:28:29.702]                         grepl <- base::grepl
[08:28:29.702]                         restarts <- computeRestarts(cond)
[08:28:29.702]                         for (restart in restarts) {
[08:28:29.702]                           name <- restart$name
[08:28:29.702]                           if (is.null(name)) 
[08:28:29.702]                             next
[08:28:29.702]                           if (!grepl(pattern, name)) 
[08:28:29.702]                             next
[08:28:29.702]                           invokeRestart(restart)
[08:28:29.702]                           muffled <- TRUE
[08:28:29.702]                           break
[08:28:29.702]                         }
[08:28:29.702]                       }
[08:28:29.702]                     }
[08:28:29.702]                     invisible(muffled)
[08:28:29.702]                   }
[08:28:29.702]                   muffleCondition(cond)
[08:28:29.702]                 })
[08:28:29.702]             }))
[08:28:29.702]             future::FutureResult(value = ...future.value$value, 
[08:28:29.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.702]                   ...future.rng), globalenv = if (FALSE) 
[08:28:29.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:29.702]                     ...future.globalenv.names))
[08:28:29.702]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:29.702]         }, condition = base::local({
[08:28:29.702]             c <- base::c
[08:28:29.702]             inherits <- base::inherits
[08:28:29.702]             invokeRestart <- base::invokeRestart
[08:28:29.702]             length <- base::length
[08:28:29.702]             list <- base::list
[08:28:29.702]             seq.int <- base::seq.int
[08:28:29.702]             signalCondition <- base::signalCondition
[08:28:29.702]             sys.calls <- base::sys.calls
[08:28:29.702]             `[[` <- base::`[[`
[08:28:29.702]             `+` <- base::`+`
[08:28:29.702]             `<<-` <- base::`<<-`
[08:28:29.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:29.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:29.702]                   3L)]
[08:28:29.702]             }
[08:28:29.702]             function(cond) {
[08:28:29.702]                 is_error <- inherits(cond, "error")
[08:28:29.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:29.702]                   NULL)
[08:28:29.702]                 if (is_error) {
[08:28:29.702]                   sessionInformation <- function() {
[08:28:29.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:29.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:29.702]                       search = base::search(), system = base::Sys.info())
[08:28:29.702]                   }
[08:28:29.702]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:29.702]                     cond$call), session = sessionInformation(), 
[08:28:29.702]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:29.702]                   signalCondition(cond)
[08:28:29.702]                 }
[08:28:29.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:29.702]                 "immediateCondition"))) {
[08:28:29.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:29.702]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:29.702]                   if (TRUE && !signal) {
[08:28:29.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.702]                     {
[08:28:29.702]                       inherits <- base::inherits
[08:28:29.702]                       invokeRestart <- base::invokeRestart
[08:28:29.702]                       is.null <- base::is.null
[08:28:29.702]                       muffled <- FALSE
[08:28:29.702]                       if (inherits(cond, "message")) {
[08:28:29.702]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.702]                         if (muffled) 
[08:28:29.702]                           invokeRestart("muffleMessage")
[08:28:29.702]                       }
[08:28:29.702]                       else if (inherits(cond, "warning")) {
[08:28:29.702]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.702]                         if (muffled) 
[08:28:29.702]                           invokeRestart("muffleWarning")
[08:28:29.702]                       }
[08:28:29.702]                       else if (inherits(cond, "condition")) {
[08:28:29.702]                         if (!is.null(pattern)) {
[08:28:29.702]                           computeRestarts <- base::computeRestarts
[08:28:29.702]                           grepl <- base::grepl
[08:28:29.702]                           restarts <- computeRestarts(cond)
[08:28:29.702]                           for (restart in restarts) {
[08:28:29.702]                             name <- restart$name
[08:28:29.702]                             if (is.null(name)) 
[08:28:29.702]                               next
[08:28:29.702]                             if (!grepl(pattern, name)) 
[08:28:29.702]                               next
[08:28:29.702]                             invokeRestart(restart)
[08:28:29.702]                             muffled <- TRUE
[08:28:29.702]                             break
[08:28:29.702]                           }
[08:28:29.702]                         }
[08:28:29.702]                       }
[08:28:29.702]                       invisible(muffled)
[08:28:29.702]                     }
[08:28:29.702]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.702]                   }
[08:28:29.702]                 }
[08:28:29.702]                 else {
[08:28:29.702]                   if (TRUE) {
[08:28:29.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.702]                     {
[08:28:29.702]                       inherits <- base::inherits
[08:28:29.702]                       invokeRestart <- base::invokeRestart
[08:28:29.702]                       is.null <- base::is.null
[08:28:29.702]                       muffled <- FALSE
[08:28:29.702]                       if (inherits(cond, "message")) {
[08:28:29.702]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.702]                         if (muffled) 
[08:28:29.702]                           invokeRestart("muffleMessage")
[08:28:29.702]                       }
[08:28:29.702]                       else if (inherits(cond, "warning")) {
[08:28:29.702]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.702]                         if (muffled) 
[08:28:29.702]                           invokeRestart("muffleWarning")
[08:28:29.702]                       }
[08:28:29.702]                       else if (inherits(cond, "condition")) {
[08:28:29.702]                         if (!is.null(pattern)) {
[08:28:29.702]                           computeRestarts <- base::computeRestarts
[08:28:29.702]                           grepl <- base::grepl
[08:28:29.702]                           restarts <- computeRestarts(cond)
[08:28:29.702]                           for (restart in restarts) {
[08:28:29.702]                             name <- restart$name
[08:28:29.702]                             if (is.null(name)) 
[08:28:29.702]                               next
[08:28:29.702]                             if (!grepl(pattern, name)) 
[08:28:29.702]                               next
[08:28:29.702]                             invokeRestart(restart)
[08:28:29.702]                             muffled <- TRUE
[08:28:29.702]                             break
[08:28:29.702]                           }
[08:28:29.702]                         }
[08:28:29.702]                       }
[08:28:29.702]                       invisible(muffled)
[08:28:29.702]                     }
[08:28:29.702]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.702]                   }
[08:28:29.702]                 }
[08:28:29.702]             }
[08:28:29.702]         }))
[08:28:29.702]     }, error = function(ex) {
[08:28:29.702]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:29.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.702]                 ...future.rng), started = ...future.startTime, 
[08:28:29.702]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:29.702]             version = "1.8"), class = "FutureResult")
[08:28:29.702]     }, finally = {
[08:28:29.702]         if (!identical(...future.workdir, getwd())) 
[08:28:29.702]             setwd(...future.workdir)
[08:28:29.702]         {
[08:28:29.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:29.702]                 ...future.oldOptions$nwarnings <- NULL
[08:28:29.702]             }
[08:28:29.702]             base::options(...future.oldOptions)
[08:28:29.702]             if (.Platform$OS.type == "windows") {
[08:28:29.702]                 old_names <- names(...future.oldEnvVars)
[08:28:29.702]                 envs <- base::Sys.getenv()
[08:28:29.702]                 names <- names(envs)
[08:28:29.702]                 common <- intersect(names, old_names)
[08:28:29.702]                 added <- setdiff(names, old_names)
[08:28:29.702]                 removed <- setdiff(old_names, names)
[08:28:29.702]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:29.702]                   envs[common]]
[08:28:29.702]                 NAMES <- toupper(changed)
[08:28:29.702]                 args <- list()
[08:28:29.702]                 for (kk in seq_along(NAMES)) {
[08:28:29.702]                   name <- changed[[kk]]
[08:28:29.702]                   NAME <- NAMES[[kk]]
[08:28:29.702]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.702]                     next
[08:28:29.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.702]                 }
[08:28:29.702]                 NAMES <- toupper(added)
[08:28:29.702]                 for (kk in seq_along(NAMES)) {
[08:28:29.702]                   name <- added[[kk]]
[08:28:29.702]                   NAME <- NAMES[[kk]]
[08:28:29.702]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.702]                     next
[08:28:29.702]                   args[[name]] <- ""
[08:28:29.702]                 }
[08:28:29.702]                 NAMES <- toupper(removed)
[08:28:29.702]                 for (kk in seq_along(NAMES)) {
[08:28:29.702]                   name <- removed[[kk]]
[08:28:29.702]                   NAME <- NAMES[[kk]]
[08:28:29.702]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.702]                     next
[08:28:29.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.702]                 }
[08:28:29.702]                 if (length(args) > 0) 
[08:28:29.702]                   base::do.call(base::Sys.setenv, args = args)
[08:28:29.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:29.702]             }
[08:28:29.702]             else {
[08:28:29.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:29.702]             }
[08:28:29.702]             {
[08:28:29.702]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:29.702]                   0L) {
[08:28:29.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:29.702]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:29.702]                   base::options(opts)
[08:28:29.702]                 }
[08:28:29.702]                 {
[08:28:29.702]                   {
[08:28:29.702]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:29.702]                     NULL
[08:28:29.702]                   }
[08:28:29.702]                   options(future.plan = NULL)
[08:28:29.702]                   if (is.na(NA_character_)) 
[08:28:29.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:29.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:29.702]                     .init = FALSE)
[08:28:29.702]                 }
[08:28:29.702]             }
[08:28:29.702]         }
[08:28:29.702]     })
[08:28:29.702]     if (TRUE) {
[08:28:29.702]         base::sink(type = "output", split = FALSE)
[08:28:29.702]         if (TRUE) {
[08:28:29.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:29.702]         }
[08:28:29.702]         else {
[08:28:29.702]             ...future.result["stdout"] <- base::list(NULL)
[08:28:29.702]         }
[08:28:29.702]         base::close(...future.stdout)
[08:28:29.702]         ...future.stdout <- NULL
[08:28:29.702]     }
[08:28:29.702]     ...future.result$conditions <- ...future.conditions
[08:28:29.702]     ...future.result$finished <- base::Sys.time()
[08:28:29.702]     ...future.result
[08:28:29.702] }
[08:28:29.705] MultisessionFuture started
[08:28:29.705] - Launch lazy future ... done
[08:28:29.706] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[08:28:29.706] result() for ClusterFuture ...
[08:28:29.706] receiveMessageFromWorker() for ClusterFuture ...
[08:28:29.706] - Validating connection of MultisessionFuture
[08:28:29.773] - received message: FutureResult
[08:28:29.774] - Received FutureResult
[08:28:29.774] - Erased future from FutureRegistry
[08:28:29.774] result() for ClusterFuture ...
[08:28:29.774] - result already collected: FutureResult
[08:28:29.774] result() for ClusterFuture ... done
[08:28:29.774] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:29.774] result() for ClusterFuture ... done
[08:28:29.774] result() for ClusterFuture ...
[08:28:29.774] - result already collected: FutureResult
[08:28:29.774] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 409533 21.9     692222   37   692222   37
Vcells 732376  5.6    8388608   64  5754333   44
> 
> f <- future({ integer(10e6) }, gc = TRUE)
[08:28:29.775] getGlobalsAndPackages() ...
[08:28:29.775] Searching for globals...
[08:28:29.776] - globals found: [2] ‘{’, ‘integer’
[08:28:29.776] Searching for globals ... DONE
[08:28:29.776] Resolving globals: FALSE
[08:28:29.776] 
[08:28:29.776] 
[08:28:29.776] getGlobalsAndPackages() ... DONE
[08:28:29.777] run() for ‘Future’ ...
[08:28:29.777] - state: ‘created’
[08:28:29.777] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:29.789] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:29.790] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:29.790]   - Field: ‘node’
[08:28:29.790]   - Field: ‘label’
[08:28:29.790]   - Field: ‘local’
[08:28:29.790]   - Field: ‘owner’
[08:28:29.790]   - Field: ‘envir’
[08:28:29.790]   - Field: ‘workers’
[08:28:29.790]   - Field: ‘packages’
[08:28:29.790]   - Field: ‘gc’
[08:28:29.790]   - Field: ‘conditions’
[08:28:29.791]   - Field: ‘persistent’
[08:28:29.791]   - Field: ‘expr’
[08:28:29.791]   - Field: ‘uuid’
[08:28:29.791]   - Field: ‘seed’
[08:28:29.791]   - Field: ‘version’
[08:28:29.791]   - Field: ‘result’
[08:28:29.791]   - Field: ‘asynchronous’
[08:28:29.791]   - Field: ‘calls’
[08:28:29.791]   - Field: ‘globals’
[08:28:29.791]   - Field: ‘stdout’
[08:28:29.791]   - Field: ‘earlySignal’
[08:28:29.791]   - Field: ‘lazy’
[08:28:29.792]   - Field: ‘state’
[08:28:29.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:29.792] - Launch lazy future ...
[08:28:29.792] Packages needed by the future expression (n = 0): <none>
[08:28:29.792] Packages needed by future strategies (n = 0): <none>
[08:28:29.795] {
[08:28:29.795]     {
[08:28:29.795]         {
[08:28:29.795]             ...future.startTime <- base::Sys.time()
[08:28:29.795]             {
[08:28:29.795]                 {
[08:28:29.795]                   {
[08:28:29.795]                     {
[08:28:29.795]                       base::local({
[08:28:29.795]                         has_future <- base::requireNamespace("future", 
[08:28:29.795]                           quietly = TRUE)
[08:28:29.795]                         if (has_future) {
[08:28:29.795]                           ns <- base::getNamespace("future")
[08:28:29.795]                           version <- ns[[".package"]][["version"]]
[08:28:29.795]                           if (is.null(version)) 
[08:28:29.795]                             version <- utils::packageVersion("future")
[08:28:29.795]                         }
[08:28:29.795]                         else {
[08:28:29.795]                           version <- NULL
[08:28:29.795]                         }
[08:28:29.795]                         if (!has_future || version < "1.8.0") {
[08:28:29.795]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:29.795]                             "", base::R.version$version.string), 
[08:28:29.795]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:29.795]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:29.795]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:29.795]                               "release", "version")], collapse = " "), 
[08:28:29.795]                             hostname = base::Sys.info()[["nodename"]])
[08:28:29.795]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:29.795]                             info)
[08:28:29.795]                           info <- base::paste(info, collapse = "; ")
[08:28:29.795]                           if (!has_future) {
[08:28:29.795]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:29.795]                               info)
[08:28:29.795]                           }
[08:28:29.795]                           else {
[08:28:29.795]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:29.795]                               info, version)
[08:28:29.795]                           }
[08:28:29.795]                           base::stop(msg)
[08:28:29.795]                         }
[08:28:29.795]                       })
[08:28:29.795]                     }
[08:28:29.795]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:29.795]                     base::options(mc.cores = 1L)
[08:28:29.795]                   }
[08:28:29.795]                   ...future.strategy.old <- future::plan("list")
[08:28:29.795]                   options(future.plan = NULL)
[08:28:29.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:29.795]                 }
[08:28:29.795]                 ...future.workdir <- getwd()
[08:28:29.795]             }
[08:28:29.795]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:29.795]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:29.795]         }
[08:28:29.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:29.795]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:29.795]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:29.795]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:29.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:29.795]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:29.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:29.795]             base::names(...future.oldOptions))
[08:28:29.795]     }
[08:28:29.795]     if (FALSE) {
[08:28:29.795]     }
[08:28:29.795]     else {
[08:28:29.795]         if (TRUE) {
[08:28:29.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:29.795]                 open = "w")
[08:28:29.795]         }
[08:28:29.795]         else {
[08:28:29.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:29.795]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:29.795]         }
[08:28:29.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:29.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:29.795]             base::sink(type = "output", split = FALSE)
[08:28:29.795]             base::close(...future.stdout)
[08:28:29.795]         }, add = TRUE)
[08:28:29.795]     }
[08:28:29.795]     ...future.frame <- base::sys.nframe()
[08:28:29.795]     ...future.conditions <- base::list()
[08:28:29.795]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:29.795]     if (FALSE) {
[08:28:29.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:29.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:29.795]     }
[08:28:29.795]     ...future.result <- base::tryCatch({
[08:28:29.795]         base::withCallingHandlers({
[08:28:29.795]             ...future.value <- base::withVisible(base::local({
[08:28:29.795]                 ...future.makeSendCondition <- base::local({
[08:28:29.795]                   sendCondition <- NULL
[08:28:29.795]                   function(frame = 1L) {
[08:28:29.795]                     if (is.function(sendCondition)) 
[08:28:29.795]                       return(sendCondition)
[08:28:29.795]                     ns <- getNamespace("parallel")
[08:28:29.795]                     if (exists("sendData", mode = "function", 
[08:28:29.795]                       envir = ns)) {
[08:28:29.795]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:29.795]                         envir = ns)
[08:28:29.795]                       envir <- sys.frame(frame)
[08:28:29.795]                       master <- NULL
[08:28:29.795]                       while (!identical(envir, .GlobalEnv) && 
[08:28:29.795]                         !identical(envir, emptyenv())) {
[08:28:29.795]                         if (exists("master", mode = "list", envir = envir, 
[08:28:29.795]                           inherits = FALSE)) {
[08:28:29.795]                           master <- get("master", mode = "list", 
[08:28:29.795]                             envir = envir, inherits = FALSE)
[08:28:29.795]                           if (inherits(master, c("SOCKnode", 
[08:28:29.795]                             "SOCK0node"))) {
[08:28:29.795]                             sendCondition <<- function(cond) {
[08:28:29.795]                               data <- list(type = "VALUE", value = cond, 
[08:28:29.795]                                 success = TRUE)
[08:28:29.795]                               parallel_sendData(master, data)
[08:28:29.795]                             }
[08:28:29.795]                             return(sendCondition)
[08:28:29.795]                           }
[08:28:29.795]                         }
[08:28:29.795]                         frame <- frame + 1L
[08:28:29.795]                         envir <- sys.frame(frame)
[08:28:29.795]                       }
[08:28:29.795]                     }
[08:28:29.795]                     sendCondition <<- function(cond) NULL
[08:28:29.795]                   }
[08:28:29.795]                 })
[08:28:29.795]                 withCallingHandlers({
[08:28:29.795]                   {
[08:28:29.795]                     integer(1e+07)
[08:28:29.795]                   }
[08:28:29.795]                 }, immediateCondition = function(cond) {
[08:28:29.795]                   sendCondition <- ...future.makeSendCondition()
[08:28:29.795]                   sendCondition(cond)
[08:28:29.795]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.795]                   {
[08:28:29.795]                     inherits <- base::inherits
[08:28:29.795]                     invokeRestart <- base::invokeRestart
[08:28:29.795]                     is.null <- base::is.null
[08:28:29.795]                     muffled <- FALSE
[08:28:29.795]                     if (inherits(cond, "message")) {
[08:28:29.795]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:29.795]                       if (muffled) 
[08:28:29.795]                         invokeRestart("muffleMessage")
[08:28:29.795]                     }
[08:28:29.795]                     else if (inherits(cond, "warning")) {
[08:28:29.795]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:29.795]                       if (muffled) 
[08:28:29.795]                         invokeRestart("muffleWarning")
[08:28:29.795]                     }
[08:28:29.795]                     else if (inherits(cond, "condition")) {
[08:28:29.795]                       if (!is.null(pattern)) {
[08:28:29.795]                         computeRestarts <- base::computeRestarts
[08:28:29.795]                         grepl <- base::grepl
[08:28:29.795]                         restarts <- computeRestarts(cond)
[08:28:29.795]                         for (restart in restarts) {
[08:28:29.795]                           name <- restart$name
[08:28:29.795]                           if (is.null(name)) 
[08:28:29.795]                             next
[08:28:29.795]                           if (!grepl(pattern, name)) 
[08:28:29.795]                             next
[08:28:29.795]                           invokeRestart(restart)
[08:28:29.795]                           muffled <- TRUE
[08:28:29.795]                           break
[08:28:29.795]                         }
[08:28:29.795]                       }
[08:28:29.795]                     }
[08:28:29.795]                     invisible(muffled)
[08:28:29.795]                   }
[08:28:29.795]                   muffleCondition(cond)
[08:28:29.795]                 })
[08:28:29.795]             }))
[08:28:29.795]             future::FutureResult(value = ...future.value$value, 
[08:28:29.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.795]                   ...future.rng), globalenv = if (FALSE) 
[08:28:29.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:29.795]                     ...future.globalenv.names))
[08:28:29.795]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:29.795]         }, condition = base::local({
[08:28:29.795]             c <- base::c
[08:28:29.795]             inherits <- base::inherits
[08:28:29.795]             invokeRestart <- base::invokeRestart
[08:28:29.795]             length <- base::length
[08:28:29.795]             list <- base::list
[08:28:29.795]             seq.int <- base::seq.int
[08:28:29.795]             signalCondition <- base::signalCondition
[08:28:29.795]             sys.calls <- base::sys.calls
[08:28:29.795]             `[[` <- base::`[[`
[08:28:29.795]             `+` <- base::`+`
[08:28:29.795]             `<<-` <- base::`<<-`
[08:28:29.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:29.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:29.795]                   3L)]
[08:28:29.795]             }
[08:28:29.795]             function(cond) {
[08:28:29.795]                 is_error <- inherits(cond, "error")
[08:28:29.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:29.795]                   NULL)
[08:28:29.795]                 if (is_error) {
[08:28:29.795]                   sessionInformation <- function() {
[08:28:29.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:29.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:29.795]                       search = base::search(), system = base::Sys.info())
[08:28:29.795]                   }
[08:28:29.795]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:29.795]                     cond$call), session = sessionInformation(), 
[08:28:29.795]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:29.795]                   signalCondition(cond)
[08:28:29.795]                 }
[08:28:29.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:29.795]                 "immediateCondition"))) {
[08:28:29.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:29.795]                   ...future.conditions[[length(...future.conditions) + 
[08:28:29.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:29.795]                   if (TRUE && !signal) {
[08:28:29.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.795]                     {
[08:28:29.795]                       inherits <- base::inherits
[08:28:29.795]                       invokeRestart <- base::invokeRestart
[08:28:29.795]                       is.null <- base::is.null
[08:28:29.795]                       muffled <- FALSE
[08:28:29.795]                       if (inherits(cond, "message")) {
[08:28:29.795]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.795]                         if (muffled) 
[08:28:29.795]                           invokeRestart("muffleMessage")
[08:28:29.795]                       }
[08:28:29.795]                       else if (inherits(cond, "warning")) {
[08:28:29.795]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.795]                         if (muffled) 
[08:28:29.795]                           invokeRestart("muffleWarning")
[08:28:29.795]                       }
[08:28:29.795]                       else if (inherits(cond, "condition")) {
[08:28:29.795]                         if (!is.null(pattern)) {
[08:28:29.795]                           computeRestarts <- base::computeRestarts
[08:28:29.795]                           grepl <- base::grepl
[08:28:29.795]                           restarts <- computeRestarts(cond)
[08:28:29.795]                           for (restart in restarts) {
[08:28:29.795]                             name <- restart$name
[08:28:29.795]                             if (is.null(name)) 
[08:28:29.795]                               next
[08:28:29.795]                             if (!grepl(pattern, name)) 
[08:28:29.795]                               next
[08:28:29.795]                             invokeRestart(restart)
[08:28:29.795]                             muffled <- TRUE
[08:28:29.795]                             break
[08:28:29.795]                           }
[08:28:29.795]                         }
[08:28:29.795]                       }
[08:28:29.795]                       invisible(muffled)
[08:28:29.795]                     }
[08:28:29.795]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.795]                   }
[08:28:29.795]                 }
[08:28:29.795]                 else {
[08:28:29.795]                   if (TRUE) {
[08:28:29.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:29.795]                     {
[08:28:29.795]                       inherits <- base::inherits
[08:28:29.795]                       invokeRestart <- base::invokeRestart
[08:28:29.795]                       is.null <- base::is.null
[08:28:29.795]                       muffled <- FALSE
[08:28:29.795]                       if (inherits(cond, "message")) {
[08:28:29.795]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:29.795]                         if (muffled) 
[08:28:29.795]                           invokeRestart("muffleMessage")
[08:28:29.795]                       }
[08:28:29.795]                       else if (inherits(cond, "warning")) {
[08:28:29.795]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:29.795]                         if (muffled) 
[08:28:29.795]                           invokeRestart("muffleWarning")
[08:28:29.795]                       }
[08:28:29.795]                       else if (inherits(cond, "condition")) {
[08:28:29.795]                         if (!is.null(pattern)) {
[08:28:29.795]                           computeRestarts <- base::computeRestarts
[08:28:29.795]                           grepl <- base::grepl
[08:28:29.795]                           restarts <- computeRestarts(cond)
[08:28:29.795]                           for (restart in restarts) {
[08:28:29.795]                             name <- restart$name
[08:28:29.795]                             if (is.null(name)) 
[08:28:29.795]                               next
[08:28:29.795]                             if (!grepl(pattern, name)) 
[08:28:29.795]                               next
[08:28:29.795]                             invokeRestart(restart)
[08:28:29.795]                             muffled <- TRUE
[08:28:29.795]                             break
[08:28:29.795]                           }
[08:28:29.795]                         }
[08:28:29.795]                       }
[08:28:29.795]                       invisible(muffled)
[08:28:29.795]                     }
[08:28:29.795]                     muffleCondition(cond, pattern = "^muffle")
[08:28:29.795]                   }
[08:28:29.795]                 }
[08:28:29.795]             }
[08:28:29.795]         }))
[08:28:29.795]     }, error = function(ex) {
[08:28:29.795]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:29.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:29.795]                 ...future.rng), started = ...future.startTime, 
[08:28:29.795]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:29.795]             version = "1.8"), class = "FutureResult")
[08:28:29.795]     }, finally = {
[08:28:29.795]         if (!identical(...future.workdir, getwd())) 
[08:28:29.795]             setwd(...future.workdir)
[08:28:29.795]         {
[08:28:29.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:29.795]                 ...future.oldOptions$nwarnings <- NULL
[08:28:29.795]             }
[08:28:29.795]             base::options(...future.oldOptions)
[08:28:29.795]             if (.Platform$OS.type == "windows") {
[08:28:29.795]                 old_names <- names(...future.oldEnvVars)
[08:28:29.795]                 envs <- base::Sys.getenv()
[08:28:29.795]                 names <- names(envs)
[08:28:29.795]                 common <- intersect(names, old_names)
[08:28:29.795]                 added <- setdiff(names, old_names)
[08:28:29.795]                 removed <- setdiff(old_names, names)
[08:28:29.795]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:29.795]                   envs[common]]
[08:28:29.795]                 NAMES <- toupper(changed)
[08:28:29.795]                 args <- list()
[08:28:29.795]                 for (kk in seq_along(NAMES)) {
[08:28:29.795]                   name <- changed[[kk]]
[08:28:29.795]                   NAME <- NAMES[[kk]]
[08:28:29.795]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.795]                     next
[08:28:29.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.795]                 }
[08:28:29.795]                 NAMES <- toupper(added)
[08:28:29.795]                 for (kk in seq_along(NAMES)) {
[08:28:29.795]                   name <- added[[kk]]
[08:28:29.795]                   NAME <- NAMES[[kk]]
[08:28:29.795]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.795]                     next
[08:28:29.795]                   args[[name]] <- ""
[08:28:29.795]                 }
[08:28:29.795]                 NAMES <- toupper(removed)
[08:28:29.795]                 for (kk in seq_along(NAMES)) {
[08:28:29.795]                   name <- removed[[kk]]
[08:28:29.795]                   NAME <- NAMES[[kk]]
[08:28:29.795]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:29.795]                     next
[08:28:29.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:29.795]                 }
[08:28:29.795]                 if (length(args) > 0) 
[08:28:29.795]                   base::do.call(base::Sys.setenv, args = args)
[08:28:29.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:29.795]             }
[08:28:29.795]             else {
[08:28:29.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:29.795]             }
[08:28:29.795]             {
[08:28:29.795]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:29.795]                   0L) {
[08:28:29.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:29.795]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:29.795]                   base::options(opts)
[08:28:29.795]                 }
[08:28:29.795]                 {
[08:28:29.795]                   {
[08:28:29.795]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:29.795]                     NULL
[08:28:29.795]                   }
[08:28:29.795]                   options(future.plan = NULL)
[08:28:29.795]                   if (is.na(NA_character_)) 
[08:28:29.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:29.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:29.795]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:29.795]                     .init = FALSE)
[08:28:29.795]                 }
[08:28:29.795]             }
[08:28:29.795]         }
[08:28:29.795]     })
[08:28:29.795]     if (TRUE) {
[08:28:29.795]         base::sink(type = "output", split = FALSE)
[08:28:29.795]         if (TRUE) {
[08:28:29.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:29.795]         }
[08:28:29.795]         else {
[08:28:29.795]             ...future.result["stdout"] <- base::list(NULL)
[08:28:29.795]         }
[08:28:29.795]         base::close(...future.stdout)
[08:28:29.795]         ...future.stdout <- NULL
[08:28:29.795]     }
[08:28:29.795]     ...future.result$conditions <- ...future.conditions
[08:28:29.795]     ...future.result$finished <- base::Sys.time()
[08:28:29.795]     ...future.result
[08:28:29.795] }
[08:28:29.798] MultisessionFuture started
[08:28:29.798] - Launch lazy future ... done
[08:28:29.798] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[08:28:29.798] result() for ClusterFuture ...
[08:28:29.798] receiveMessageFromWorker() for ClusterFuture ...
[08:28:29.799] - Validating connection of MultisessionFuture
[08:28:29.888] - received message: FutureResult
[08:28:29.888] - Received FutureResult
[08:28:29.888] - Erased future from FutureRegistry
[08:28:29.888] result() for ClusterFuture ...
[08:28:29.888] - result already collected: FutureResult
[08:28:29.888] result() for ClusterFuture ... done
[08:28:29.888] - Garbage collecting worker ...
[08:28:30.138] - Garbage collecting worker ... done
[08:28:30.139] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:30.139] result() for ClusterFuture ... done
[08:28:30.139] result() for ClusterFuture ...
[08:28:30.139] - result already collected: FutureResult
[08:28:30.139] result() for ClusterFuture ... done
> str(v)
 int [1:10000000] 0 0 0 0 0 0 0 0 0 0 ...
> 
> f <- future({ gc() })
[08:28:30.140] getGlobalsAndPackages() ...
[08:28:30.140] Searching for globals...
[08:28:30.141] - globals found: [2] ‘{’, ‘gc’
[08:28:30.141] Searching for globals ... DONE
[08:28:30.141] Resolving globals: FALSE
[08:28:30.141] 
[08:28:30.141] 
[08:28:30.141] getGlobalsAndPackages() ... DONE
[08:28:30.142] run() for ‘Future’ ...
[08:28:30.142] - state: ‘created’
[08:28:30.142] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:30.154] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:30.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:30.154]   - Field: ‘node’
[08:28:30.155]   - Field: ‘label’
[08:28:30.155]   - Field: ‘local’
[08:28:30.155]   - Field: ‘owner’
[08:28:30.155]   - Field: ‘envir’
[08:28:30.155]   - Field: ‘workers’
[08:28:30.155]   - Field: ‘packages’
[08:28:30.155]   - Field: ‘gc’
[08:28:30.155]   - Field: ‘conditions’
[08:28:30.155]   - Field: ‘persistent’
[08:28:30.155]   - Field: ‘expr’
[08:28:30.155]   - Field: ‘uuid’
[08:28:30.156]   - Field: ‘seed’
[08:28:30.156]   - Field: ‘version’
[08:28:30.156]   - Field: ‘result’
[08:28:30.156]   - Field: ‘asynchronous’
[08:28:30.156]   - Field: ‘calls’
[08:28:30.156]   - Field: ‘globals’
[08:28:30.156]   - Field: ‘stdout’
[08:28:30.156]   - Field: ‘earlySignal’
[08:28:30.156]   - Field: ‘lazy’
[08:28:30.156]   - Field: ‘state’
[08:28:30.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:30.156] - Launch lazy future ...
[08:28:30.157] Packages needed by the future expression (n = 0): <none>
[08:28:30.157] Packages needed by future strategies (n = 0): <none>
[08:28:30.157] {
[08:28:30.157]     {
[08:28:30.157]         {
[08:28:30.157]             ...future.startTime <- base::Sys.time()
[08:28:30.157]             {
[08:28:30.157]                 {
[08:28:30.157]                   {
[08:28:30.157]                     {
[08:28:30.157]                       base::local({
[08:28:30.157]                         has_future <- base::requireNamespace("future", 
[08:28:30.157]                           quietly = TRUE)
[08:28:30.157]                         if (has_future) {
[08:28:30.157]                           ns <- base::getNamespace("future")
[08:28:30.157]                           version <- ns[[".package"]][["version"]]
[08:28:30.157]                           if (is.null(version)) 
[08:28:30.157]                             version <- utils::packageVersion("future")
[08:28:30.157]                         }
[08:28:30.157]                         else {
[08:28:30.157]                           version <- NULL
[08:28:30.157]                         }
[08:28:30.157]                         if (!has_future || version < "1.8.0") {
[08:28:30.157]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:30.157]                             "", base::R.version$version.string), 
[08:28:30.157]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:30.157]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:30.157]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:30.157]                               "release", "version")], collapse = " "), 
[08:28:30.157]                             hostname = base::Sys.info()[["nodename"]])
[08:28:30.157]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:30.157]                             info)
[08:28:30.157]                           info <- base::paste(info, collapse = "; ")
[08:28:30.157]                           if (!has_future) {
[08:28:30.157]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:30.157]                               info)
[08:28:30.157]                           }
[08:28:30.157]                           else {
[08:28:30.157]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:30.157]                               info, version)
[08:28:30.157]                           }
[08:28:30.157]                           base::stop(msg)
[08:28:30.157]                         }
[08:28:30.157]                       })
[08:28:30.157]                     }
[08:28:30.157]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:30.157]                     base::options(mc.cores = 1L)
[08:28:30.157]                   }
[08:28:30.157]                   ...future.strategy.old <- future::plan("list")
[08:28:30.157]                   options(future.plan = NULL)
[08:28:30.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:30.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:30.157]                 }
[08:28:30.157]                 ...future.workdir <- getwd()
[08:28:30.157]             }
[08:28:30.157]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:30.157]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:30.157]         }
[08:28:30.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:30.157]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:30.157]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:30.157]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:30.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:30.157]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:30.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:30.157]             base::names(...future.oldOptions))
[08:28:30.157]     }
[08:28:30.157]     if (FALSE) {
[08:28:30.157]     }
[08:28:30.157]     else {
[08:28:30.157]         if (TRUE) {
[08:28:30.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:30.157]                 open = "w")
[08:28:30.157]         }
[08:28:30.157]         else {
[08:28:30.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:30.157]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:30.157]         }
[08:28:30.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:30.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:30.157]             base::sink(type = "output", split = FALSE)
[08:28:30.157]             base::close(...future.stdout)
[08:28:30.157]         }, add = TRUE)
[08:28:30.157]     }
[08:28:30.157]     ...future.frame <- base::sys.nframe()
[08:28:30.157]     ...future.conditions <- base::list()
[08:28:30.157]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:30.157]     if (FALSE) {
[08:28:30.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:30.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:30.157]     }
[08:28:30.157]     ...future.result <- base::tryCatch({
[08:28:30.157]         base::withCallingHandlers({
[08:28:30.157]             ...future.value <- base::withVisible(base::local({
[08:28:30.157]                 ...future.makeSendCondition <- base::local({
[08:28:30.157]                   sendCondition <- NULL
[08:28:30.157]                   function(frame = 1L) {
[08:28:30.157]                     if (is.function(sendCondition)) 
[08:28:30.157]                       return(sendCondition)
[08:28:30.157]                     ns <- getNamespace("parallel")
[08:28:30.157]                     if (exists("sendData", mode = "function", 
[08:28:30.157]                       envir = ns)) {
[08:28:30.157]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:30.157]                         envir = ns)
[08:28:30.157]                       envir <- sys.frame(frame)
[08:28:30.157]                       master <- NULL
[08:28:30.157]                       while (!identical(envir, .GlobalEnv) && 
[08:28:30.157]                         !identical(envir, emptyenv())) {
[08:28:30.157]                         if (exists("master", mode = "list", envir = envir, 
[08:28:30.157]                           inherits = FALSE)) {
[08:28:30.157]                           master <- get("master", mode = "list", 
[08:28:30.157]                             envir = envir, inherits = FALSE)
[08:28:30.157]                           if (inherits(master, c("SOCKnode", 
[08:28:30.157]                             "SOCK0node"))) {
[08:28:30.157]                             sendCondition <<- function(cond) {
[08:28:30.157]                               data <- list(type = "VALUE", value = cond, 
[08:28:30.157]                                 success = TRUE)
[08:28:30.157]                               parallel_sendData(master, data)
[08:28:30.157]                             }
[08:28:30.157]                             return(sendCondition)
[08:28:30.157]                           }
[08:28:30.157]                         }
[08:28:30.157]                         frame <- frame + 1L
[08:28:30.157]                         envir <- sys.frame(frame)
[08:28:30.157]                       }
[08:28:30.157]                     }
[08:28:30.157]                     sendCondition <<- function(cond) NULL
[08:28:30.157]                   }
[08:28:30.157]                 })
[08:28:30.157]                 withCallingHandlers({
[08:28:30.157]                   {
[08:28:30.157]                     gc()
[08:28:30.157]                   }
[08:28:30.157]                 }, immediateCondition = function(cond) {
[08:28:30.157]                   sendCondition <- ...future.makeSendCondition()
[08:28:30.157]                   sendCondition(cond)
[08:28:30.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:30.157]                   {
[08:28:30.157]                     inherits <- base::inherits
[08:28:30.157]                     invokeRestart <- base::invokeRestart
[08:28:30.157]                     is.null <- base::is.null
[08:28:30.157]                     muffled <- FALSE
[08:28:30.157]                     if (inherits(cond, "message")) {
[08:28:30.157]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:30.157]                       if (muffled) 
[08:28:30.157]                         invokeRestart("muffleMessage")
[08:28:30.157]                     }
[08:28:30.157]                     else if (inherits(cond, "warning")) {
[08:28:30.157]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:30.157]                       if (muffled) 
[08:28:30.157]                         invokeRestart("muffleWarning")
[08:28:30.157]                     }
[08:28:30.157]                     else if (inherits(cond, "condition")) {
[08:28:30.157]                       if (!is.null(pattern)) {
[08:28:30.157]                         computeRestarts <- base::computeRestarts
[08:28:30.157]                         grepl <- base::grepl
[08:28:30.157]                         restarts <- computeRestarts(cond)
[08:28:30.157]                         for (restart in restarts) {
[08:28:30.157]                           name <- restart$name
[08:28:30.157]                           if (is.null(name)) 
[08:28:30.157]                             next
[08:28:30.157]                           if (!grepl(pattern, name)) 
[08:28:30.157]                             next
[08:28:30.157]                           invokeRestart(restart)
[08:28:30.157]                           muffled <- TRUE
[08:28:30.157]                           break
[08:28:30.157]                         }
[08:28:30.157]                       }
[08:28:30.157]                     }
[08:28:30.157]                     invisible(muffled)
[08:28:30.157]                   }
[08:28:30.157]                   muffleCondition(cond)
[08:28:30.157]                 })
[08:28:30.157]             }))
[08:28:30.157]             future::FutureResult(value = ...future.value$value, 
[08:28:30.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:30.157]                   ...future.rng), globalenv = if (FALSE) 
[08:28:30.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:30.157]                     ...future.globalenv.names))
[08:28:30.157]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:30.157]         }, condition = base::local({
[08:28:30.157]             c <- base::c
[08:28:30.157]             inherits <- base::inherits
[08:28:30.157]             invokeRestart <- base::invokeRestart
[08:28:30.157]             length <- base::length
[08:28:30.157]             list <- base::list
[08:28:30.157]             seq.int <- base::seq.int
[08:28:30.157]             signalCondition <- base::signalCondition
[08:28:30.157]             sys.calls <- base::sys.calls
[08:28:30.157]             `[[` <- base::`[[`
[08:28:30.157]             `+` <- base::`+`
[08:28:30.157]             `<<-` <- base::`<<-`
[08:28:30.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:30.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:30.157]                   3L)]
[08:28:30.157]             }
[08:28:30.157]             function(cond) {
[08:28:30.157]                 is_error <- inherits(cond, "error")
[08:28:30.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:30.157]                   NULL)
[08:28:30.157]                 if (is_error) {
[08:28:30.157]                   sessionInformation <- function() {
[08:28:30.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:30.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:30.157]                       search = base::search(), system = base::Sys.info())
[08:28:30.157]                   }
[08:28:30.157]                   ...future.conditions[[length(...future.conditions) + 
[08:28:30.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:30.157]                     cond$call), session = sessionInformation(), 
[08:28:30.157]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:30.157]                   signalCondition(cond)
[08:28:30.157]                 }
[08:28:30.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:30.157]                 "immediateCondition"))) {
[08:28:30.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:30.157]                   ...future.conditions[[length(...future.conditions) + 
[08:28:30.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:30.157]                   if (TRUE && !signal) {
[08:28:30.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:30.157]                     {
[08:28:30.157]                       inherits <- base::inherits
[08:28:30.157]                       invokeRestart <- base::invokeRestart
[08:28:30.157]                       is.null <- base::is.null
[08:28:30.157]                       muffled <- FALSE
[08:28:30.157]                       if (inherits(cond, "message")) {
[08:28:30.157]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:30.157]                         if (muffled) 
[08:28:30.157]                           invokeRestart("muffleMessage")
[08:28:30.157]                       }
[08:28:30.157]                       else if (inherits(cond, "warning")) {
[08:28:30.157]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:30.157]                         if (muffled) 
[08:28:30.157]                           invokeRestart("muffleWarning")
[08:28:30.157]                       }
[08:28:30.157]                       else if (inherits(cond, "condition")) {
[08:28:30.157]                         if (!is.null(pattern)) {
[08:28:30.157]                           computeRestarts <- base::computeRestarts
[08:28:30.157]                           grepl <- base::grepl
[08:28:30.157]                           restarts <- computeRestarts(cond)
[08:28:30.157]                           for (restart in restarts) {
[08:28:30.157]                             name <- restart$name
[08:28:30.157]                             if (is.null(name)) 
[08:28:30.157]                               next
[08:28:30.157]                             if (!grepl(pattern, name)) 
[08:28:30.157]                               next
[08:28:30.157]                             invokeRestart(restart)
[08:28:30.157]                             muffled <- TRUE
[08:28:30.157]                             break
[08:28:30.157]                           }
[08:28:30.157]                         }
[08:28:30.157]                       }
[08:28:30.157]                       invisible(muffled)
[08:28:30.157]                     }
[08:28:30.157]                     muffleCondition(cond, pattern = "^muffle")
[08:28:30.157]                   }
[08:28:30.157]                 }
[08:28:30.157]                 else {
[08:28:30.157]                   if (TRUE) {
[08:28:30.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:30.157]                     {
[08:28:30.157]                       inherits <- base::inherits
[08:28:30.157]                       invokeRestart <- base::invokeRestart
[08:28:30.157]                       is.null <- base::is.null
[08:28:30.157]                       muffled <- FALSE
[08:28:30.157]                       if (inherits(cond, "message")) {
[08:28:30.157]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:30.157]                         if (muffled) 
[08:28:30.157]                           invokeRestart("muffleMessage")
[08:28:30.157]                       }
[08:28:30.157]                       else if (inherits(cond, "warning")) {
[08:28:30.157]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:30.157]                         if (muffled) 
[08:28:30.157]                           invokeRestart("muffleWarning")
[08:28:30.157]                       }
[08:28:30.157]                       else if (inherits(cond, "condition")) {
[08:28:30.157]                         if (!is.null(pattern)) {
[08:28:30.157]                           computeRestarts <- base::computeRestarts
[08:28:30.157]                           grepl <- base::grepl
[08:28:30.157]                           restarts <- computeRestarts(cond)
[08:28:30.157]                           for (restart in restarts) {
[08:28:30.157]                             name <- restart$name
[08:28:30.157]                             if (is.null(name)) 
[08:28:30.157]                               next
[08:28:30.157]                             if (!grepl(pattern, name)) 
[08:28:30.157]                               next
[08:28:30.157]                             invokeRestart(restart)
[08:28:30.157]                             muffled <- TRUE
[08:28:30.157]                             break
[08:28:30.157]                           }
[08:28:30.157]                         }
[08:28:30.157]                       }
[08:28:30.157]                       invisible(muffled)
[08:28:30.157]                     }
[08:28:30.157]                     muffleCondition(cond, pattern = "^muffle")
[08:28:30.157]                   }
[08:28:30.157]                 }
[08:28:30.157]             }
[08:28:30.157]         }))
[08:28:30.157]     }, error = function(ex) {
[08:28:30.157]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:30.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:30.157]                 ...future.rng), started = ...future.startTime, 
[08:28:30.157]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:30.157]             version = "1.8"), class = "FutureResult")
[08:28:30.157]     }, finally = {
[08:28:30.157]         if (!identical(...future.workdir, getwd())) 
[08:28:30.157]             setwd(...future.workdir)
[08:28:30.157]         {
[08:28:30.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:30.157]                 ...future.oldOptions$nwarnings <- NULL
[08:28:30.157]             }
[08:28:30.157]             base::options(...future.oldOptions)
[08:28:30.157]             if (.Platform$OS.type == "windows") {
[08:28:30.157]                 old_names <- names(...future.oldEnvVars)
[08:28:30.157]                 envs <- base::Sys.getenv()
[08:28:30.157]                 names <- names(envs)
[08:28:30.157]                 common <- intersect(names, old_names)
[08:28:30.157]                 added <- setdiff(names, old_names)
[08:28:30.157]                 removed <- setdiff(old_names, names)
[08:28:30.157]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:30.157]                   envs[common]]
[08:28:30.157]                 NAMES <- toupper(changed)
[08:28:30.157]                 args <- list()
[08:28:30.157]                 for (kk in seq_along(NAMES)) {
[08:28:30.157]                   name <- changed[[kk]]
[08:28:30.157]                   NAME <- NAMES[[kk]]
[08:28:30.157]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:30.157]                     next
[08:28:30.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:30.157]                 }
[08:28:30.157]                 NAMES <- toupper(added)
[08:28:30.157]                 for (kk in seq_along(NAMES)) {
[08:28:30.157]                   name <- added[[kk]]
[08:28:30.157]                   NAME <- NAMES[[kk]]
[08:28:30.157]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:30.157]                     next
[08:28:30.157]                   args[[name]] <- ""
[08:28:30.157]                 }
[08:28:30.157]                 NAMES <- toupper(removed)
[08:28:30.157]                 for (kk in seq_along(NAMES)) {
[08:28:30.157]                   name <- removed[[kk]]
[08:28:30.157]                   NAME <- NAMES[[kk]]
[08:28:30.157]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:30.157]                     next
[08:28:30.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:30.157]                 }
[08:28:30.157]                 if (length(args) > 0) 
[08:28:30.157]                   base::do.call(base::Sys.setenv, args = args)
[08:28:30.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:30.157]             }
[08:28:30.157]             else {
[08:28:30.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:30.157]             }
[08:28:30.157]             {
[08:28:30.157]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:30.157]                   0L) {
[08:28:30.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:30.157]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:30.157]                   base::options(opts)
[08:28:30.157]                 }
[08:28:30.157]                 {
[08:28:30.157]                   {
[08:28:30.157]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:30.157]                     NULL
[08:28:30.157]                   }
[08:28:30.157]                   options(future.plan = NULL)
[08:28:30.157]                   if (is.na(NA_character_)) 
[08:28:30.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:30.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:30.157]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:30.157]                     .init = FALSE)
[08:28:30.157]                 }
[08:28:30.157]             }
[08:28:30.157]         }
[08:28:30.157]     })
[08:28:30.157]     if (TRUE) {
[08:28:30.157]         base::sink(type = "output", split = FALSE)
[08:28:30.157]         if (TRUE) {
[08:28:30.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:30.157]         }
[08:28:30.157]         else {
[08:28:30.157]             ...future.result["stdout"] <- base::list(NULL)
[08:28:30.157]         }
[08:28:30.157]         base::close(...future.stdout)
[08:28:30.157]         ...future.stdout <- NULL
[08:28:30.157]     }
[08:28:30.157]     ...future.result$conditions <- ...future.conditions
[08:28:30.157]     ...future.result$finished <- base::Sys.time()
[08:28:30.157]     ...future.result
[08:28:30.157] }
[08:28:30.160] MultisessionFuture started
[08:28:30.160] - Launch lazy future ... done
[08:28:30.161] run() for ‘MultisessionFuture’ ... done
> v <- value(f)
[08:28:30.161] result() for ClusterFuture ...
[08:28:30.161] receiveMessageFromWorker() for ClusterFuture ...
[08:28:30.161] - Validating connection of MultisessionFuture
[08:28:30.228] - received message: FutureResult
[08:28:30.228] - Received FutureResult
[08:28:30.229] - Erased future from FutureRegistry
[08:28:30.229] result() for ClusterFuture ...
[08:28:30.229] - result already collected: FutureResult
[08:28:30.229] result() for ClusterFuture ... done
[08:28:30.229] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:30.229] result() for ClusterFuture ... done
[08:28:30.229] result() for ClusterFuture ...
[08:28:30.229] - result already collected: FutureResult
[08:28:30.229] result() for ClusterFuture ... done
> print(v)
         used (Mb) gc trigger  (Mb) max used  (Mb)
Ncells 409681 21.9     912380  48.8   692222  37.0
Vcells 732466  5.6   13482749 102.9 15813665 120.7
> 
> message("*** multisession(..., gc = TRUE) ... TRUE")
*** multisession(..., gc = TRUE) ... TRUE
> 
> 
> message("*** multisession(...) - stopping with plan() change ...")
*** multisession(...) - stopping with plan() change ...
>   
> plan(multisession, workers = 2L)
[08:28:30.230] plan(): Setting new future strategy stack:
[08:28:30.230] List of future strategies:
[08:28:30.230] 1. multisession:
[08:28:30.230]    - args: function (..., workers = 2L, envir = parent.frame())
[08:28:30.230]    - tweaked: TRUE
[08:28:30.230]    - call: plan(multisession, workers = 2L)
[08:28:30.231] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:28:30.231] multisession:
[08:28:30.231] - args: function (..., workers = 2L, envir = parent.frame())
[08:28:30.231] - tweaked: TRUE
[08:28:30.231] - call: plan(multisession, workers = 2L)
[08:28:30.231] getGlobalsAndPackages() ...
[08:28:30.232] Not searching for globals
[08:28:30.232] - globals: [0] <none>
[08:28:30.232] getGlobalsAndPackages() ... DONE
[08:28:30.504] Packages needed by the future expression (n = 0): <none>
[08:28:30.504] Packages needed by future strategies (n = 0): <none>
[08:28:30.504] {
[08:28:30.504]     {
[08:28:30.504]         {
[08:28:30.504]             ...future.startTime <- base::Sys.time()
[08:28:30.504]             {
[08:28:30.504]                 {
[08:28:30.504]                   {
[08:28:30.504]                     {
[08:28:30.504]                       base::local({
[08:28:30.504]                         has_future <- base::requireNamespace("future", 
[08:28:30.504]                           quietly = TRUE)
[08:28:30.504]                         if (has_future) {
[08:28:30.504]                           ns <- base::getNamespace("future")
[08:28:30.504]                           version <- ns[[".package"]][["version"]]
[08:28:30.504]                           if (is.null(version)) 
[08:28:30.504]                             version <- utils::packageVersion("future")
[08:28:30.504]                         }
[08:28:30.504]                         else {
[08:28:30.504]                           version <- NULL
[08:28:30.504]                         }
[08:28:30.504]                         if (!has_future || version < "1.8.0") {
[08:28:30.504]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:30.504]                             "", base::R.version$version.string), 
[08:28:30.504]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:30.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:30.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:30.504]                               "release", "version")], collapse = " "), 
[08:28:30.504]                             hostname = base::Sys.info()[["nodename"]])
[08:28:30.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:30.504]                             info)
[08:28:30.504]                           info <- base::paste(info, collapse = "; ")
[08:28:30.504]                           if (!has_future) {
[08:28:30.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:30.504]                               info)
[08:28:30.504]                           }
[08:28:30.504]                           else {
[08:28:30.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:30.504]                               info, version)
[08:28:30.504]                           }
[08:28:30.504]                           base::stop(msg)
[08:28:30.504]                         }
[08:28:30.504]                       })
[08:28:30.504]                     }
[08:28:30.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:30.504]                     base::options(mc.cores = 1L)
[08:28:30.504]                   }
[08:28:30.504]                   ...future.strategy.old <- future::plan("list")
[08:28:30.504]                   options(future.plan = NULL)
[08:28:30.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:30.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:30.504]                 }
[08:28:30.504]                 ...future.workdir <- getwd()
[08:28:30.504]             }
[08:28:30.504]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:30.504]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:30.504]         }
[08:28:30.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:30.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:30.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:30.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:30.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:30.504]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:30.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:30.504]             base::names(...future.oldOptions))
[08:28:30.504]     }
[08:28:30.504]     if (FALSE) {
[08:28:30.504]     }
[08:28:30.504]     else {
[08:28:30.504]         if (TRUE) {
[08:28:30.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:30.504]                 open = "w")
[08:28:30.504]         }
[08:28:30.504]         else {
[08:28:30.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:30.504]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:30.504]         }
[08:28:30.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:30.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:30.504]             base::sink(type = "output", split = FALSE)
[08:28:30.504]             base::close(...future.stdout)
[08:28:30.504]         }, add = TRUE)
[08:28:30.504]     }
[08:28:30.504]     ...future.frame <- base::sys.nframe()
[08:28:30.504]     ...future.conditions <- base::list()
[08:28:30.504]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:30.504]     if (FALSE) {
[08:28:30.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:30.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:30.504]     }
[08:28:30.504]     ...future.result <- base::tryCatch({
[08:28:30.504]         base::withCallingHandlers({
[08:28:30.504]             ...future.value <- base::withVisible(base::local({
[08:28:30.504]                 ...future.makeSendCondition <- base::local({
[08:28:30.504]                   sendCondition <- NULL
[08:28:30.504]                   function(frame = 1L) {
[08:28:30.504]                     if (is.function(sendCondition)) 
[08:28:30.504]                       return(sendCondition)
[08:28:30.504]                     ns <- getNamespace("parallel")
[08:28:30.504]                     if (exists("sendData", mode = "function", 
[08:28:30.504]                       envir = ns)) {
[08:28:30.504]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:30.504]                         envir = ns)
[08:28:30.504]                       envir <- sys.frame(frame)
[08:28:30.504]                       master <- NULL
[08:28:30.504]                       while (!identical(envir, .GlobalEnv) && 
[08:28:30.504]                         !identical(envir, emptyenv())) {
[08:28:30.504]                         if (exists("master", mode = "list", envir = envir, 
[08:28:30.504]                           inherits = FALSE)) {
[08:28:30.504]                           master <- get("master", mode = "list", 
[08:28:30.504]                             envir = envir, inherits = FALSE)
[08:28:30.504]                           if (inherits(master, c("SOCKnode", 
[08:28:30.504]                             "SOCK0node"))) {
[08:28:30.504]                             sendCondition <<- function(cond) {
[08:28:30.504]                               data <- list(type = "VALUE", value = cond, 
[08:28:30.504]                                 success = TRUE)
[08:28:30.504]                               parallel_sendData(master, data)
[08:28:30.504]                             }
[08:28:30.504]                             return(sendCondition)
[08:28:30.504]                           }
[08:28:30.504]                         }
[08:28:30.504]                         frame <- frame + 1L
[08:28:30.504]                         envir <- sys.frame(frame)
[08:28:30.504]                       }
[08:28:30.504]                     }
[08:28:30.504]                     sendCondition <<- function(cond) NULL
[08:28:30.504]                   }
[08:28:30.504]                 })
[08:28:30.504]                 withCallingHandlers({
[08:28:30.504]                   NA
[08:28:30.504]                 }, immediateCondition = function(cond) {
[08:28:30.504]                   sendCondition <- ...future.makeSendCondition()
[08:28:30.504]                   sendCondition(cond)
[08:28:30.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:30.504]                   {
[08:28:30.504]                     inherits <- base::inherits
[08:28:30.504]                     invokeRestart <- base::invokeRestart
[08:28:30.504]                     is.null <- base::is.null
[08:28:30.504]                     muffled <- FALSE
[08:28:30.504]                     if (inherits(cond, "message")) {
[08:28:30.504]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:30.504]                       if (muffled) 
[08:28:30.504]                         invokeRestart("muffleMessage")
[08:28:30.504]                     }
[08:28:30.504]                     else if (inherits(cond, "warning")) {
[08:28:30.504]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:30.504]                       if (muffled) 
[08:28:30.504]                         invokeRestart("muffleWarning")
[08:28:30.504]                     }
[08:28:30.504]                     else if (inherits(cond, "condition")) {
[08:28:30.504]                       if (!is.null(pattern)) {
[08:28:30.504]                         computeRestarts <- base::computeRestarts
[08:28:30.504]                         grepl <- base::grepl
[08:28:30.504]                         restarts <- computeRestarts(cond)
[08:28:30.504]                         for (restart in restarts) {
[08:28:30.504]                           name <- restart$name
[08:28:30.504]                           if (is.null(name)) 
[08:28:30.504]                             next
[08:28:30.504]                           if (!grepl(pattern, name)) 
[08:28:30.504]                             next
[08:28:30.504]                           invokeRestart(restart)
[08:28:30.504]                           muffled <- TRUE
[08:28:30.504]                           break
[08:28:30.504]                         }
[08:28:30.504]                       }
[08:28:30.504]                     }
[08:28:30.504]                     invisible(muffled)
[08:28:30.504]                   }
[08:28:30.504]                   muffleCondition(cond)
[08:28:30.504]                 })
[08:28:30.504]             }))
[08:28:30.504]             future::FutureResult(value = ...future.value$value, 
[08:28:30.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:30.504]                   ...future.rng), globalenv = if (FALSE) 
[08:28:30.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:30.504]                     ...future.globalenv.names))
[08:28:30.504]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:30.504]         }, condition = base::local({
[08:28:30.504]             c <- base::c
[08:28:30.504]             inherits <- base::inherits
[08:28:30.504]             invokeRestart <- base::invokeRestart
[08:28:30.504]             length <- base::length
[08:28:30.504]             list <- base::list
[08:28:30.504]             seq.int <- base::seq.int
[08:28:30.504]             signalCondition <- base::signalCondition
[08:28:30.504]             sys.calls <- base::sys.calls
[08:28:30.504]             `[[` <- base::`[[`
[08:28:30.504]             `+` <- base::`+`
[08:28:30.504]             `<<-` <- base::`<<-`
[08:28:30.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:30.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:30.504]                   3L)]
[08:28:30.504]             }
[08:28:30.504]             function(cond) {
[08:28:30.504]                 is_error <- inherits(cond, "error")
[08:28:30.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:30.504]                   NULL)
[08:28:30.504]                 if (is_error) {
[08:28:30.504]                   sessionInformation <- function() {
[08:28:30.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:30.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:30.504]                       search = base::search(), system = base::Sys.info())
[08:28:30.504]                   }
[08:28:30.504]                   ...future.conditions[[length(...future.conditions) + 
[08:28:30.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:30.504]                     cond$call), session = sessionInformation(), 
[08:28:30.504]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:30.504]                   signalCondition(cond)
[08:28:30.504]                 }
[08:28:30.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:30.504]                 "immediateCondition"))) {
[08:28:30.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:30.504]                   ...future.conditions[[length(...future.conditions) + 
[08:28:30.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:30.504]                   if (TRUE && !signal) {
[08:28:30.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:30.504]                     {
[08:28:30.504]                       inherits <- base::inherits
[08:28:30.504]                       invokeRestart <- base::invokeRestart
[08:28:30.504]                       is.null <- base::is.null
[08:28:30.504]                       muffled <- FALSE
[08:28:30.504]                       if (inherits(cond, "message")) {
[08:28:30.504]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:30.504]                         if (muffled) 
[08:28:30.504]                           invokeRestart("muffleMessage")
[08:28:30.504]                       }
[08:28:30.504]                       else if (inherits(cond, "warning")) {
[08:28:30.504]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:30.504]                         if (muffled) 
[08:28:30.504]                           invokeRestart("muffleWarning")
[08:28:30.504]                       }
[08:28:30.504]                       else if (inherits(cond, "condition")) {
[08:28:30.504]                         if (!is.null(pattern)) {
[08:28:30.504]                           computeRestarts <- base::computeRestarts
[08:28:30.504]                           grepl <- base::grepl
[08:28:30.504]                           restarts <- computeRestarts(cond)
[08:28:30.504]                           for (restart in restarts) {
[08:28:30.504]                             name <- restart$name
[08:28:30.504]                             if (is.null(name)) 
[08:28:30.504]                               next
[08:28:30.504]                             if (!grepl(pattern, name)) 
[08:28:30.504]                               next
[08:28:30.504]                             invokeRestart(restart)
[08:28:30.504]                             muffled <- TRUE
[08:28:30.504]                             break
[08:28:30.504]                           }
[08:28:30.504]                         }
[08:28:30.504]                       }
[08:28:30.504]                       invisible(muffled)
[08:28:30.504]                     }
[08:28:30.504]                     muffleCondition(cond, pattern = "^muffle")
[08:28:30.504]                   }
[08:28:30.504]                 }
[08:28:30.504]                 else {
[08:28:30.504]                   if (TRUE) {
[08:28:30.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:30.504]                     {
[08:28:30.504]                       inherits <- base::inherits
[08:28:30.504]                       invokeRestart <- base::invokeRestart
[08:28:30.504]                       is.null <- base::is.null
[08:28:30.504]                       muffled <- FALSE
[08:28:30.504]                       if (inherits(cond, "message")) {
[08:28:30.504]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:30.504]                         if (muffled) 
[08:28:30.504]                           invokeRestart("muffleMessage")
[08:28:30.504]                       }
[08:28:30.504]                       else if (inherits(cond, "warning")) {
[08:28:30.504]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:30.504]                         if (muffled) 
[08:28:30.504]                           invokeRestart("muffleWarning")
[08:28:30.504]                       }
[08:28:30.504]                       else if (inherits(cond, "condition")) {
[08:28:30.504]                         if (!is.null(pattern)) {
[08:28:30.504]                           computeRestarts <- base::computeRestarts
[08:28:30.504]                           grepl <- base::grepl
[08:28:30.504]                           restarts <- computeRestarts(cond)
[08:28:30.504]                           for (restart in restarts) {
[08:28:30.504]                             name <- restart$name
[08:28:30.504]                             if (is.null(name)) 
[08:28:30.504]                               next
[08:28:30.504]                             if (!grepl(pattern, name)) 
[08:28:30.504]                               next
[08:28:30.504]                             invokeRestart(restart)
[08:28:30.504]                             muffled <- TRUE
[08:28:30.504]                             break
[08:28:30.504]                           }
[08:28:30.504]                         }
[08:28:30.504]                       }
[08:28:30.504]                       invisible(muffled)
[08:28:30.504]                     }
[08:28:30.504]                     muffleCondition(cond, pattern = "^muffle")
[08:28:30.504]                   }
[08:28:30.504]                 }
[08:28:30.504]             }
[08:28:30.504]         }))
[08:28:30.504]     }, error = function(ex) {
[08:28:30.504]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:30.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:30.504]                 ...future.rng), started = ...future.startTime, 
[08:28:30.504]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:30.504]             version = "1.8"), class = "FutureResult")
[08:28:30.504]     }, finally = {
[08:28:30.504]         if (!identical(...future.workdir, getwd())) 
[08:28:30.504]             setwd(...future.workdir)
[08:28:30.504]         {
[08:28:30.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:30.504]                 ...future.oldOptions$nwarnings <- NULL
[08:28:30.504]             }
[08:28:30.504]             base::options(...future.oldOptions)
[08:28:30.504]             if (.Platform$OS.type == "windows") {
[08:28:30.504]                 old_names <- names(...future.oldEnvVars)
[08:28:30.504]                 envs <- base::Sys.getenv()
[08:28:30.504]                 names <- names(envs)
[08:28:30.504]                 common <- intersect(names, old_names)
[08:28:30.504]                 added <- setdiff(names, old_names)
[08:28:30.504]                 removed <- setdiff(old_names, names)
[08:28:30.504]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:30.504]                   envs[common]]
[08:28:30.504]                 NAMES <- toupper(changed)
[08:28:30.504]                 args <- list()
[08:28:30.504]                 for (kk in seq_along(NAMES)) {
[08:28:30.504]                   name <- changed[[kk]]
[08:28:30.504]                   NAME <- NAMES[[kk]]
[08:28:30.504]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:30.504]                     next
[08:28:30.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:30.504]                 }
[08:28:30.504]                 NAMES <- toupper(added)
[08:28:30.504]                 for (kk in seq_along(NAMES)) {
[08:28:30.504]                   name <- added[[kk]]
[08:28:30.504]                   NAME <- NAMES[[kk]]
[08:28:30.504]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:30.504]                     next
[08:28:30.504]                   args[[name]] <- ""
[08:28:30.504]                 }
[08:28:30.504]                 NAMES <- toupper(removed)
[08:28:30.504]                 for (kk in seq_along(NAMES)) {
[08:28:30.504]                   name <- removed[[kk]]
[08:28:30.504]                   NAME <- NAMES[[kk]]
[08:28:30.504]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:30.504]                     next
[08:28:30.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:30.504]                 }
[08:28:30.504]                 if (length(args) > 0) 
[08:28:30.504]                   base::do.call(base::Sys.setenv, args = args)
[08:28:30.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:30.504]             }
[08:28:30.504]             else {
[08:28:30.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:30.504]             }
[08:28:30.504]             {
[08:28:30.504]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:30.504]                   0L) {
[08:28:30.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:30.504]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:30.504]                   base::options(opts)
[08:28:30.504]                 }
[08:28:30.504]                 {
[08:28:30.504]                   {
[08:28:30.504]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:30.504]                     NULL
[08:28:30.504]                   }
[08:28:30.504]                   options(future.plan = NULL)
[08:28:30.504]                   if (is.na(NA_character_)) 
[08:28:30.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:30.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:30.504]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:30.504]                     .init = FALSE)
[08:28:30.504]                 }
[08:28:30.504]             }
[08:28:30.504]         }
[08:28:30.504]     })
[08:28:30.504]     if (TRUE) {
[08:28:30.504]         base::sink(type = "output", split = FALSE)
[08:28:30.504]         if (TRUE) {
[08:28:30.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:30.504]         }
[08:28:30.504]         else {
[08:28:30.504]             ...future.result["stdout"] <- base::list(NULL)
[08:28:30.504]         }
[08:28:30.504]         base::close(...future.stdout)
[08:28:30.504]         ...future.stdout <- NULL
[08:28:30.504]     }
[08:28:30.504]     ...future.result$conditions <- ...future.conditions
[08:28:30.504]     ...future.result$finished <- base::Sys.time()
[08:28:30.504]     ...future.result
[08:28:30.504] }
[08:28:30.559] MultisessionFuture started
[08:28:30.559] result() for ClusterFuture ...
[08:28:30.559] receiveMessageFromWorker() for ClusterFuture ...
[08:28:30.560] - Validating connection of MultisessionFuture
[08:28:30.592] - received message: FutureResult
[08:28:30.592] - Received FutureResult
[08:28:30.592] - Erased future from FutureRegistry
[08:28:30.592] result() for ClusterFuture ...
[08:28:30.592] - result already collected: FutureResult
[08:28:30.592] result() for ClusterFuture ... done
[08:28:30.593] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:30.593] result() for ClusterFuture ... done
[08:28:30.593] result() for ClusterFuture ...
[08:28:30.593] - result already collected: FutureResult
[08:28:30.593] result() for ClusterFuture ... done
[08:28:30.593] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:28:30.593] plan(): nbrOfWorkers() = 2
> f <- future(1L)
[08:28:30.593] getGlobalsAndPackages() ...
[08:28:30.593] Searching for globals...
[08:28:30.594] 
[08:28:30.594] Searching for globals ... DONE
[08:28:30.594] - globals: [0] <none>
[08:28:30.594] getGlobalsAndPackages() ... DONE
[08:28:30.594] run() for ‘Future’ ...
[08:28:30.595] - state: ‘created’
[08:28:30.595] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:30.609] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:30.609] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:30.609]   - Field: ‘node’
[08:28:30.609]   - Field: ‘label’
[08:28:30.609]   - Field: ‘local’
[08:28:30.609]   - Field: ‘owner’
[08:28:30.609]   - Field: ‘envir’
[08:28:30.609]   - Field: ‘workers’
[08:28:30.609]   - Field: ‘packages’
[08:28:30.610]   - Field: ‘gc’
[08:28:30.610]   - Field: ‘conditions’
[08:28:30.610]   - Field: ‘persistent’
[08:28:30.610]   - Field: ‘expr’
[08:28:30.610]   - Field: ‘uuid’
[08:28:30.610]   - Field: ‘seed’
[08:28:30.610]   - Field: ‘version’
[08:28:30.610]   - Field: ‘result’
[08:28:30.610]   - Field: ‘asynchronous’
[08:28:30.610]   - Field: ‘calls’
[08:28:30.610]   - Field: ‘globals’
[08:28:30.610]   - Field: ‘stdout’
[08:28:30.611]   - Field: ‘earlySignal’
[08:28:30.611]   - Field: ‘lazy’
[08:28:30.611]   - Field: ‘state’
[08:28:30.611] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:30.611] - Launch lazy future ...
[08:28:30.611] Packages needed by the future expression (n = 0): <none>
[08:28:30.611] Packages needed by future strategies (n = 0): <none>
[08:28:30.612] {
[08:28:30.612]     {
[08:28:30.612]         {
[08:28:30.612]             ...future.startTime <- base::Sys.time()
[08:28:30.612]             {
[08:28:30.612]                 {
[08:28:30.612]                   {
[08:28:30.612]                     {
[08:28:30.612]                       base::local({
[08:28:30.612]                         has_future <- base::requireNamespace("future", 
[08:28:30.612]                           quietly = TRUE)
[08:28:30.612]                         if (has_future) {
[08:28:30.612]                           ns <- base::getNamespace("future")
[08:28:30.612]                           version <- ns[[".package"]][["version"]]
[08:28:30.612]                           if (is.null(version)) 
[08:28:30.612]                             version <- utils::packageVersion("future")
[08:28:30.612]                         }
[08:28:30.612]                         else {
[08:28:30.612]                           version <- NULL
[08:28:30.612]                         }
[08:28:30.612]                         if (!has_future || version < "1.8.0") {
[08:28:30.612]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:30.612]                             "", base::R.version$version.string), 
[08:28:30.612]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:30.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:30.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:30.612]                               "release", "version")], collapse = " "), 
[08:28:30.612]                             hostname = base::Sys.info()[["nodename"]])
[08:28:30.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:30.612]                             info)
[08:28:30.612]                           info <- base::paste(info, collapse = "; ")
[08:28:30.612]                           if (!has_future) {
[08:28:30.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:30.612]                               info)
[08:28:30.612]                           }
[08:28:30.612]                           else {
[08:28:30.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:30.612]                               info, version)
[08:28:30.612]                           }
[08:28:30.612]                           base::stop(msg)
[08:28:30.612]                         }
[08:28:30.612]                       })
[08:28:30.612]                     }
[08:28:30.612]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:30.612]                     base::options(mc.cores = 1L)
[08:28:30.612]                   }
[08:28:30.612]                   ...future.strategy.old <- future::plan("list")
[08:28:30.612]                   options(future.plan = NULL)
[08:28:30.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:30.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:30.612]                 }
[08:28:30.612]                 ...future.workdir <- getwd()
[08:28:30.612]             }
[08:28:30.612]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:30.612]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:30.612]         }
[08:28:30.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:30.612]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:30.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:30.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:30.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:30.612]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:30.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:30.612]             base::names(...future.oldOptions))
[08:28:30.612]     }
[08:28:30.612]     if (FALSE) {
[08:28:30.612]     }
[08:28:30.612]     else {
[08:28:30.612]         if (TRUE) {
[08:28:30.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:30.612]                 open = "w")
[08:28:30.612]         }
[08:28:30.612]         else {
[08:28:30.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:30.612]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:30.612]         }
[08:28:30.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:30.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:30.612]             base::sink(type = "output", split = FALSE)
[08:28:30.612]             base::close(...future.stdout)
[08:28:30.612]         }, add = TRUE)
[08:28:30.612]     }
[08:28:30.612]     ...future.frame <- base::sys.nframe()
[08:28:30.612]     ...future.conditions <- base::list()
[08:28:30.612]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:30.612]     if (FALSE) {
[08:28:30.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:30.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:30.612]     }
[08:28:30.612]     ...future.result <- base::tryCatch({
[08:28:30.612]         base::withCallingHandlers({
[08:28:30.612]             ...future.value <- base::withVisible(base::local({
[08:28:30.612]                 ...future.makeSendCondition <- base::local({
[08:28:30.612]                   sendCondition <- NULL
[08:28:30.612]                   function(frame = 1L) {
[08:28:30.612]                     if (is.function(sendCondition)) 
[08:28:30.612]                       return(sendCondition)
[08:28:30.612]                     ns <- getNamespace("parallel")
[08:28:30.612]                     if (exists("sendData", mode = "function", 
[08:28:30.612]                       envir = ns)) {
[08:28:30.612]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:30.612]                         envir = ns)
[08:28:30.612]                       envir <- sys.frame(frame)
[08:28:30.612]                       master <- NULL
[08:28:30.612]                       while (!identical(envir, .GlobalEnv) && 
[08:28:30.612]                         !identical(envir, emptyenv())) {
[08:28:30.612]                         if (exists("master", mode = "list", envir = envir, 
[08:28:30.612]                           inherits = FALSE)) {
[08:28:30.612]                           master <- get("master", mode = "list", 
[08:28:30.612]                             envir = envir, inherits = FALSE)
[08:28:30.612]                           if (inherits(master, c("SOCKnode", 
[08:28:30.612]                             "SOCK0node"))) {
[08:28:30.612]                             sendCondition <<- function(cond) {
[08:28:30.612]                               data <- list(type = "VALUE", value = cond, 
[08:28:30.612]                                 success = TRUE)
[08:28:30.612]                               parallel_sendData(master, data)
[08:28:30.612]                             }
[08:28:30.612]                             return(sendCondition)
[08:28:30.612]                           }
[08:28:30.612]                         }
[08:28:30.612]                         frame <- frame + 1L
[08:28:30.612]                         envir <- sys.frame(frame)
[08:28:30.612]                       }
[08:28:30.612]                     }
[08:28:30.612]                     sendCondition <<- function(cond) NULL
[08:28:30.612]                   }
[08:28:30.612]                 })
[08:28:30.612]                 withCallingHandlers({
[08:28:30.612]                   1L
[08:28:30.612]                 }, immediateCondition = function(cond) {
[08:28:30.612]                   sendCondition <- ...future.makeSendCondition()
[08:28:30.612]                   sendCondition(cond)
[08:28:30.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:30.612]                   {
[08:28:30.612]                     inherits <- base::inherits
[08:28:30.612]                     invokeRestart <- base::invokeRestart
[08:28:30.612]                     is.null <- base::is.null
[08:28:30.612]                     muffled <- FALSE
[08:28:30.612]                     if (inherits(cond, "message")) {
[08:28:30.612]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:30.612]                       if (muffled) 
[08:28:30.612]                         invokeRestart("muffleMessage")
[08:28:30.612]                     }
[08:28:30.612]                     else if (inherits(cond, "warning")) {
[08:28:30.612]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:30.612]                       if (muffled) 
[08:28:30.612]                         invokeRestart("muffleWarning")
[08:28:30.612]                     }
[08:28:30.612]                     else if (inherits(cond, "condition")) {
[08:28:30.612]                       if (!is.null(pattern)) {
[08:28:30.612]                         computeRestarts <- base::computeRestarts
[08:28:30.612]                         grepl <- base::grepl
[08:28:30.612]                         restarts <- computeRestarts(cond)
[08:28:30.612]                         for (restart in restarts) {
[08:28:30.612]                           name <- restart$name
[08:28:30.612]                           if (is.null(name)) 
[08:28:30.612]                             next
[08:28:30.612]                           if (!grepl(pattern, name)) 
[08:28:30.612]                             next
[08:28:30.612]                           invokeRestart(restart)
[08:28:30.612]                           muffled <- TRUE
[08:28:30.612]                           break
[08:28:30.612]                         }
[08:28:30.612]                       }
[08:28:30.612]                     }
[08:28:30.612]                     invisible(muffled)
[08:28:30.612]                   }
[08:28:30.612]                   muffleCondition(cond)
[08:28:30.612]                 })
[08:28:30.612]             }))
[08:28:30.612]             future::FutureResult(value = ...future.value$value, 
[08:28:30.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:30.612]                   ...future.rng), globalenv = if (FALSE) 
[08:28:30.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:30.612]                     ...future.globalenv.names))
[08:28:30.612]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:30.612]         }, condition = base::local({
[08:28:30.612]             c <- base::c
[08:28:30.612]             inherits <- base::inherits
[08:28:30.612]             invokeRestart <- base::invokeRestart
[08:28:30.612]             length <- base::length
[08:28:30.612]             list <- base::list
[08:28:30.612]             seq.int <- base::seq.int
[08:28:30.612]             signalCondition <- base::signalCondition
[08:28:30.612]             sys.calls <- base::sys.calls
[08:28:30.612]             `[[` <- base::`[[`
[08:28:30.612]             `+` <- base::`+`
[08:28:30.612]             `<<-` <- base::`<<-`
[08:28:30.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:30.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:30.612]                   3L)]
[08:28:30.612]             }
[08:28:30.612]             function(cond) {
[08:28:30.612]                 is_error <- inherits(cond, "error")
[08:28:30.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:30.612]                   NULL)
[08:28:30.612]                 if (is_error) {
[08:28:30.612]                   sessionInformation <- function() {
[08:28:30.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:30.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:30.612]                       search = base::search(), system = base::Sys.info())
[08:28:30.612]                   }
[08:28:30.612]                   ...future.conditions[[length(...future.conditions) + 
[08:28:30.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:30.612]                     cond$call), session = sessionInformation(), 
[08:28:30.612]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:30.612]                   signalCondition(cond)
[08:28:30.612]                 }
[08:28:30.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:30.612]                 "immediateCondition"))) {
[08:28:30.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:30.612]                   ...future.conditions[[length(...future.conditions) + 
[08:28:30.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:30.612]                   if (TRUE && !signal) {
[08:28:30.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:30.612]                     {
[08:28:30.612]                       inherits <- base::inherits
[08:28:30.612]                       invokeRestart <- base::invokeRestart
[08:28:30.612]                       is.null <- base::is.null
[08:28:30.612]                       muffled <- FALSE
[08:28:30.612]                       if (inherits(cond, "message")) {
[08:28:30.612]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:30.612]                         if (muffled) 
[08:28:30.612]                           invokeRestart("muffleMessage")
[08:28:30.612]                       }
[08:28:30.612]                       else if (inherits(cond, "warning")) {
[08:28:30.612]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:30.612]                         if (muffled) 
[08:28:30.612]                           invokeRestart("muffleWarning")
[08:28:30.612]                       }
[08:28:30.612]                       else if (inherits(cond, "condition")) {
[08:28:30.612]                         if (!is.null(pattern)) {
[08:28:30.612]                           computeRestarts <- base::computeRestarts
[08:28:30.612]                           grepl <- base::grepl
[08:28:30.612]                           restarts <- computeRestarts(cond)
[08:28:30.612]                           for (restart in restarts) {
[08:28:30.612]                             name <- restart$name
[08:28:30.612]                             if (is.null(name)) 
[08:28:30.612]                               next
[08:28:30.612]                             if (!grepl(pattern, name)) 
[08:28:30.612]                               next
[08:28:30.612]                             invokeRestart(restart)
[08:28:30.612]                             muffled <- TRUE
[08:28:30.612]                             break
[08:28:30.612]                           }
[08:28:30.612]                         }
[08:28:30.612]                       }
[08:28:30.612]                       invisible(muffled)
[08:28:30.612]                     }
[08:28:30.612]                     muffleCondition(cond, pattern = "^muffle")
[08:28:30.612]                   }
[08:28:30.612]                 }
[08:28:30.612]                 else {
[08:28:30.612]                   if (TRUE) {
[08:28:30.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:30.612]                     {
[08:28:30.612]                       inherits <- base::inherits
[08:28:30.612]                       invokeRestart <- base::invokeRestart
[08:28:30.612]                       is.null <- base::is.null
[08:28:30.612]                       muffled <- FALSE
[08:28:30.612]                       if (inherits(cond, "message")) {
[08:28:30.612]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:30.612]                         if (muffled) 
[08:28:30.612]                           invokeRestart("muffleMessage")
[08:28:30.612]                       }
[08:28:30.612]                       else if (inherits(cond, "warning")) {
[08:28:30.612]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:30.612]                         if (muffled) 
[08:28:30.612]                           invokeRestart("muffleWarning")
[08:28:30.612]                       }
[08:28:30.612]                       else if (inherits(cond, "condition")) {
[08:28:30.612]                         if (!is.null(pattern)) {
[08:28:30.612]                           computeRestarts <- base::computeRestarts
[08:28:30.612]                           grepl <- base::grepl
[08:28:30.612]                           restarts <- computeRestarts(cond)
[08:28:30.612]                           for (restart in restarts) {
[08:28:30.612]                             name <- restart$name
[08:28:30.612]                             if (is.null(name)) 
[08:28:30.612]                               next
[08:28:30.612]                             if (!grepl(pattern, name)) 
[08:28:30.612]                               next
[08:28:30.612]                             invokeRestart(restart)
[08:28:30.612]                             muffled <- TRUE
[08:28:30.612]                             break
[08:28:30.612]                           }
[08:28:30.612]                         }
[08:28:30.612]                       }
[08:28:30.612]                       invisible(muffled)
[08:28:30.612]                     }
[08:28:30.612]                     muffleCondition(cond, pattern = "^muffle")
[08:28:30.612]                   }
[08:28:30.612]                 }
[08:28:30.612]             }
[08:28:30.612]         }))
[08:28:30.612]     }, error = function(ex) {
[08:28:30.612]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:30.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:30.612]                 ...future.rng), started = ...future.startTime, 
[08:28:30.612]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:30.612]             version = "1.8"), class = "FutureResult")
[08:28:30.612]     }, finally = {
[08:28:30.612]         if (!identical(...future.workdir, getwd())) 
[08:28:30.612]             setwd(...future.workdir)
[08:28:30.612]         {
[08:28:30.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:30.612]                 ...future.oldOptions$nwarnings <- NULL
[08:28:30.612]             }
[08:28:30.612]             base::options(...future.oldOptions)
[08:28:30.612]             if (.Platform$OS.type == "windows") {
[08:28:30.612]                 old_names <- names(...future.oldEnvVars)
[08:28:30.612]                 envs <- base::Sys.getenv()
[08:28:30.612]                 names <- names(envs)
[08:28:30.612]                 common <- intersect(names, old_names)
[08:28:30.612]                 added <- setdiff(names, old_names)
[08:28:30.612]                 removed <- setdiff(old_names, names)
[08:28:30.612]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:30.612]                   envs[common]]
[08:28:30.612]                 NAMES <- toupper(changed)
[08:28:30.612]                 args <- list()
[08:28:30.612]                 for (kk in seq_along(NAMES)) {
[08:28:30.612]                   name <- changed[[kk]]
[08:28:30.612]                   NAME <- NAMES[[kk]]
[08:28:30.612]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:30.612]                     next
[08:28:30.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:30.612]                 }
[08:28:30.612]                 NAMES <- toupper(added)
[08:28:30.612]                 for (kk in seq_along(NAMES)) {
[08:28:30.612]                   name <- added[[kk]]
[08:28:30.612]                   NAME <- NAMES[[kk]]
[08:28:30.612]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:30.612]                     next
[08:28:30.612]                   args[[name]] <- ""
[08:28:30.612]                 }
[08:28:30.612]                 NAMES <- toupper(removed)
[08:28:30.612]                 for (kk in seq_along(NAMES)) {
[08:28:30.612]                   name <- removed[[kk]]
[08:28:30.612]                   NAME <- NAMES[[kk]]
[08:28:30.612]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:30.612]                     next
[08:28:30.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:30.612]                 }
[08:28:30.612]                 if (length(args) > 0) 
[08:28:30.612]                   base::do.call(base::Sys.setenv, args = args)
[08:28:30.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:30.612]             }
[08:28:30.612]             else {
[08:28:30.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:30.612]             }
[08:28:30.612]             {
[08:28:30.612]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:30.612]                   0L) {
[08:28:30.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:30.612]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:30.612]                   base::options(opts)
[08:28:30.612]                 }
[08:28:30.612]                 {
[08:28:30.612]                   {
[08:28:30.612]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:30.612]                     NULL
[08:28:30.612]                   }
[08:28:30.612]                   options(future.plan = NULL)
[08:28:30.612]                   if (is.na(NA_character_)) 
[08:28:30.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:30.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:30.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:30.612]                     .init = FALSE)
[08:28:30.612]                 }
[08:28:30.612]             }
[08:28:30.612]         }
[08:28:30.612]     })
[08:28:30.612]     if (TRUE) {
[08:28:30.612]         base::sink(type = "output", split = FALSE)
[08:28:30.612]         if (TRUE) {
[08:28:30.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:30.612]         }
[08:28:30.612]         else {
[08:28:30.612]             ...future.result["stdout"] <- base::list(NULL)
[08:28:30.612]         }
[08:28:30.612]         base::close(...future.stdout)
[08:28:30.612]         ...future.stdout <- NULL
[08:28:30.612]     }
[08:28:30.612]     ...future.result$conditions <- ...future.conditions
[08:28:30.612]     ...future.result$finished <- base::Sys.time()
[08:28:30.612]     ...future.result
[08:28:30.612] }
[08:28:30.615] MultisessionFuture started
[08:28:30.615] - Launch lazy future ... done
[08:28:30.615] run() for ‘MultisessionFuture’ ... done
> 
> ## Collect value, to speep up the stopping of the parallel workers,
> ## and to make sure we're not leaving any stray processes behind.
> v <- value(f)
[08:28:30.615] result() for ClusterFuture ...
[08:28:30.615] receiveMessageFromWorker() for ClusterFuture ...
[08:28:30.615] - Validating connection of MultisessionFuture
[08:28:30.657] - received message: FutureResult
[08:28:30.658] - Received FutureResult
[08:28:30.658] - Erased future from FutureRegistry
[08:28:30.658] result() for ClusterFuture ...
[08:28:30.658] - result already collected: FutureResult
[08:28:30.658] result() for ClusterFuture ... done
[08:28:30.658] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:30.658] result() for ClusterFuture ... done
[08:28:30.658] result() for ClusterFuture ...
[08:28:30.658] - result already collected: FutureResult
[08:28:30.658] result() for ClusterFuture ... done
> 
> cl <- ClusterRegistry("get")
> stopifnot(inherits(cl, "cluster"), length(cl) >= 1L)
> 
> plan(sequential)
[08:28:30.659] plan(): Setting new future strategy stack:
[08:28:30.659] List of future strategies:
[08:28:30.659] 1. sequential:
[08:28:30.659]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:30.659]    - tweaked: FALSE
[08:28:30.659]    - call: plan(sequential)
[08:28:30.660] plan(): nbrOfWorkers() = 1
> cl <- ClusterRegistry("get")
> stopifnot(is.null(cl), length(cl) == 0L)
>   
> message("*** multisession(...) - stopping with plan() change ... DONE")
*** multisession(...) - stopping with plan() change ... DONE
> 
> message("*** multisession() ... DONE")
*** multisession() ... DONE
> 
> source("incl/end.R")
[08:28:30.661] plan(): Setting new future strategy stack:
[08:28:30.661] List of future strategies:
[08:28:30.661] 1. FutureStrategy:
[08:28:30.661]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:30.661]    - tweaked: FALSE
[08:28:30.661]    - call: future::plan(oplan)
[08:28:30.661] plan(): nbrOfWorkers() = 1
> 
