
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:28:05.135] plan(): Setting new future strategy stack:
[08:28:05.135] List of future strategies:
[08:28:05.135] 1. sequential:
[08:28:05.135]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.135]    - tweaked: FALSE
[08:28:05.135]    - call: future::plan("sequential")
[08:28:05.149] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** Globals w/ non-standard evaluation (NSE) ...")
*** Globals w/ non-standard evaluation (NSE) ...
> 
> data <- data.frame(x = 1:5, y = 1:5)
> v0 <- subset(data, x < 3)$y
> 
> for (strategy in supportedStrategies()) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("- Strategy: %s ...", strategy))
+   
+   plan(strategy)
+ 
+   ## Assert option is passed on to future
+   options(future.globals.onMissing = "error")
+   opt1 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt1, "error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   opt2 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt2, "ignore"))
+ 
+   options(future.globals.onMissing = "error")
+   res <- try({ v1 %<-% subset(data, x < 3)$y }, silent = TRUE)
+   stopifnot(inherits(res, "try-error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   v2 %<-% subset(data, x < 3)$y
+   stopifnot(identical(v2, v0))
+ 
+   ## Nested futures (requires option is passed on to future)
+   plan(list(sequential, strategy))
+   options(future.globals.onMissing = "ignore")
+   v3 %<-% {
+     a %<-% subset(data, x < 3)$y
+     a
+   } %lazy% TRUE
+   stopifnot(identical(v3, v0))
+ 
+   ## Make sure to shut down nested parallel workers
+   void %<-% { plan(sequential) }
+   print(void)
+ 
+   message(sprintf("- Strategy: %s ... DONE", strategy))
+ }
- Strategy: sequential ...
[08:28:05.184] plan(): Setting new future strategy stack:
[08:28:05.184] List of future strategies:
[08:28:05.184] 1. sequential:
[08:28:05.184]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.184]    - tweaked: FALSE
[08:28:05.184]    - call: plan(strategy)
[08:28:05.197] plan(): nbrOfWorkers() = 1
[08:28:05.199] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:05.199] Searching for globals...
[08:28:05.202] - globals found: [1] ‘getOption’
[08:28:05.202] Searching for globals ... DONE
[08:28:05.202] Resolving globals: FALSE
[08:28:05.203] 
[08:28:05.203] 
[08:28:05.203] getGlobalsAndPackages() ... DONE
[08:28:05.204] run() for ‘Future’ ...
[08:28:05.204] - state: ‘created’
[08:28:05.204] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:05.204] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:05.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:05.204]   - Field: ‘label’
[08:28:05.205]   - Field: ‘local’
[08:28:05.205]   - Field: ‘owner’
[08:28:05.205]   - Field: ‘envir’
[08:28:05.205]   - Field: ‘packages’
[08:28:05.205]   - Field: ‘gc’
[08:28:05.205]   - Field: ‘conditions’
[08:28:05.205]   - Field: ‘expr’
[08:28:05.205]   - Field: ‘uuid’
[08:28:05.205]   - Field: ‘seed’
[08:28:05.205]   - Field: ‘version’
[08:28:05.205]   - Field: ‘result’
[08:28:05.206]   - Field: ‘asynchronous’
[08:28:05.206]   - Field: ‘calls’
[08:28:05.206]   - Field: ‘globals’
[08:28:05.206]   - Field: ‘stdout’
[08:28:05.206]   - Field: ‘earlySignal’
[08:28:05.206]   - Field: ‘lazy’
[08:28:05.206]   - Field: ‘state’
[08:28:05.206] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:05.206] - Launch lazy future ...
[08:28:05.207] Packages needed by the future expression (n = 0): <none>
[08:28:05.207] Packages needed by future strategies (n = 0): <none>
[08:28:05.208] {
[08:28:05.208]     {
[08:28:05.208]         {
[08:28:05.208]             ...future.startTime <- base::Sys.time()
[08:28:05.208]             {
[08:28:05.208]                 {
[08:28:05.208]                   {
[08:28:05.208]                     base::local({
[08:28:05.208]                       has_future <- base::requireNamespace("future", 
[08:28:05.208]                         quietly = TRUE)
[08:28:05.208]                       if (has_future) {
[08:28:05.208]                         ns <- base::getNamespace("future")
[08:28:05.208]                         version <- ns[[".package"]][["version"]]
[08:28:05.208]                         if (is.null(version)) 
[08:28:05.208]                           version <- utils::packageVersion("future")
[08:28:05.208]                       }
[08:28:05.208]                       else {
[08:28:05.208]                         version <- NULL
[08:28:05.208]                       }
[08:28:05.208]                       if (!has_future || version < "1.8.0") {
[08:28:05.208]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.208]                           "", base::R.version$version.string), 
[08:28:05.208]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:05.208]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.208]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.208]                             "release", "version")], collapse = " "), 
[08:28:05.208]                           hostname = base::Sys.info()[["nodename"]])
[08:28:05.208]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.208]                           info)
[08:28:05.208]                         info <- base::paste(info, collapse = "; ")
[08:28:05.208]                         if (!has_future) {
[08:28:05.208]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.208]                             info)
[08:28:05.208]                         }
[08:28:05.208]                         else {
[08:28:05.208]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.208]                             info, version)
[08:28:05.208]                         }
[08:28:05.208]                         base::stop(msg)
[08:28:05.208]                       }
[08:28:05.208]                     })
[08:28:05.208]                   }
[08:28:05.208]                   ...future.strategy.old <- future::plan("list")
[08:28:05.208]                   options(future.plan = NULL)
[08:28:05.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:05.208]                 }
[08:28:05.208]                 ...future.workdir <- getwd()
[08:28:05.208]             }
[08:28:05.208]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.208]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.208]         }
[08:28:05.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:05.208]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.208]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:05.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.208]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.208]             base::names(...future.oldOptions))
[08:28:05.208]     }
[08:28:05.208]     if (FALSE) {
[08:28:05.208]     }
[08:28:05.208]     else {
[08:28:05.208]         if (TRUE) {
[08:28:05.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.208]                 open = "w")
[08:28:05.208]         }
[08:28:05.208]         else {
[08:28:05.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.208]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.208]         }
[08:28:05.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.208]             base::sink(type = "output", split = FALSE)
[08:28:05.208]             base::close(...future.stdout)
[08:28:05.208]         }, add = TRUE)
[08:28:05.208]     }
[08:28:05.208]     ...future.frame <- base::sys.nframe()
[08:28:05.208]     ...future.conditions <- base::list()
[08:28:05.208]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.208]     if (FALSE) {
[08:28:05.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.208]     }
[08:28:05.208]     ...future.result <- base::tryCatch({
[08:28:05.208]         base::withCallingHandlers({
[08:28:05.208]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[08:28:05.208]             future::FutureResult(value = ...future.value$value, 
[08:28:05.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.208]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.208]                     ...future.globalenv.names))
[08:28:05.208]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.208]         }, condition = base::local({
[08:28:05.208]             c <- base::c
[08:28:05.208]             inherits <- base::inherits
[08:28:05.208]             invokeRestart <- base::invokeRestart
[08:28:05.208]             length <- base::length
[08:28:05.208]             list <- base::list
[08:28:05.208]             seq.int <- base::seq.int
[08:28:05.208]             signalCondition <- base::signalCondition
[08:28:05.208]             sys.calls <- base::sys.calls
[08:28:05.208]             `[[` <- base::`[[`
[08:28:05.208]             `+` <- base::`+`
[08:28:05.208]             `<<-` <- base::`<<-`
[08:28:05.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.208]                   3L)]
[08:28:05.208]             }
[08:28:05.208]             function(cond) {
[08:28:05.208]                 is_error <- inherits(cond, "error")
[08:28:05.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.208]                   NULL)
[08:28:05.208]                 if (is_error) {
[08:28:05.208]                   sessionInformation <- function() {
[08:28:05.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.208]                       search = base::search(), system = base::Sys.info())
[08:28:05.208]                   }
[08:28:05.208]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.208]                     cond$call), session = sessionInformation(), 
[08:28:05.208]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.208]                   signalCondition(cond)
[08:28:05.208]                 }
[08:28:05.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.208]                 "immediateCondition"))) {
[08:28:05.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.208]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.208]                   if (TRUE && !signal) {
[08:28:05.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.208]                     {
[08:28:05.208]                       inherits <- base::inherits
[08:28:05.208]                       invokeRestart <- base::invokeRestart
[08:28:05.208]                       is.null <- base::is.null
[08:28:05.208]                       muffled <- FALSE
[08:28:05.208]                       if (inherits(cond, "message")) {
[08:28:05.208]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.208]                         if (muffled) 
[08:28:05.208]                           invokeRestart("muffleMessage")
[08:28:05.208]                       }
[08:28:05.208]                       else if (inherits(cond, "warning")) {
[08:28:05.208]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.208]                         if (muffled) 
[08:28:05.208]                           invokeRestart("muffleWarning")
[08:28:05.208]                       }
[08:28:05.208]                       else if (inherits(cond, "condition")) {
[08:28:05.208]                         if (!is.null(pattern)) {
[08:28:05.208]                           computeRestarts <- base::computeRestarts
[08:28:05.208]                           grepl <- base::grepl
[08:28:05.208]                           restarts <- computeRestarts(cond)
[08:28:05.208]                           for (restart in restarts) {
[08:28:05.208]                             name <- restart$name
[08:28:05.208]                             if (is.null(name)) 
[08:28:05.208]                               next
[08:28:05.208]                             if (!grepl(pattern, name)) 
[08:28:05.208]                               next
[08:28:05.208]                             invokeRestart(restart)
[08:28:05.208]                             muffled <- TRUE
[08:28:05.208]                             break
[08:28:05.208]                           }
[08:28:05.208]                         }
[08:28:05.208]                       }
[08:28:05.208]                       invisible(muffled)
[08:28:05.208]                     }
[08:28:05.208]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.208]                   }
[08:28:05.208]                 }
[08:28:05.208]                 else {
[08:28:05.208]                   if (TRUE) {
[08:28:05.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.208]                     {
[08:28:05.208]                       inherits <- base::inherits
[08:28:05.208]                       invokeRestart <- base::invokeRestart
[08:28:05.208]                       is.null <- base::is.null
[08:28:05.208]                       muffled <- FALSE
[08:28:05.208]                       if (inherits(cond, "message")) {
[08:28:05.208]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.208]                         if (muffled) 
[08:28:05.208]                           invokeRestart("muffleMessage")
[08:28:05.208]                       }
[08:28:05.208]                       else if (inherits(cond, "warning")) {
[08:28:05.208]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.208]                         if (muffled) 
[08:28:05.208]                           invokeRestart("muffleWarning")
[08:28:05.208]                       }
[08:28:05.208]                       else if (inherits(cond, "condition")) {
[08:28:05.208]                         if (!is.null(pattern)) {
[08:28:05.208]                           computeRestarts <- base::computeRestarts
[08:28:05.208]                           grepl <- base::grepl
[08:28:05.208]                           restarts <- computeRestarts(cond)
[08:28:05.208]                           for (restart in restarts) {
[08:28:05.208]                             name <- restart$name
[08:28:05.208]                             if (is.null(name)) 
[08:28:05.208]                               next
[08:28:05.208]                             if (!grepl(pattern, name)) 
[08:28:05.208]                               next
[08:28:05.208]                             invokeRestart(restart)
[08:28:05.208]                             muffled <- TRUE
[08:28:05.208]                             break
[08:28:05.208]                           }
[08:28:05.208]                         }
[08:28:05.208]                       }
[08:28:05.208]                       invisible(muffled)
[08:28:05.208]                     }
[08:28:05.208]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.208]                   }
[08:28:05.208]                 }
[08:28:05.208]             }
[08:28:05.208]         }))
[08:28:05.208]     }, error = function(ex) {
[08:28:05.208]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.208]                 ...future.rng), started = ...future.startTime, 
[08:28:05.208]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.208]             version = "1.8"), class = "FutureResult")
[08:28:05.208]     }, finally = {
[08:28:05.208]         if (!identical(...future.workdir, getwd())) 
[08:28:05.208]             setwd(...future.workdir)
[08:28:05.208]         {
[08:28:05.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.208]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.208]             }
[08:28:05.208]             base::options(...future.oldOptions)
[08:28:05.208]             if (.Platform$OS.type == "windows") {
[08:28:05.208]                 old_names <- names(...future.oldEnvVars)
[08:28:05.208]                 envs <- base::Sys.getenv()
[08:28:05.208]                 names <- names(envs)
[08:28:05.208]                 common <- intersect(names, old_names)
[08:28:05.208]                 added <- setdiff(names, old_names)
[08:28:05.208]                 removed <- setdiff(old_names, names)
[08:28:05.208]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.208]                   envs[common]]
[08:28:05.208]                 NAMES <- toupper(changed)
[08:28:05.208]                 args <- list()
[08:28:05.208]                 for (kk in seq_along(NAMES)) {
[08:28:05.208]                   name <- changed[[kk]]
[08:28:05.208]                   NAME <- NAMES[[kk]]
[08:28:05.208]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.208]                     next
[08:28:05.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.208]                 }
[08:28:05.208]                 NAMES <- toupper(added)
[08:28:05.208]                 for (kk in seq_along(NAMES)) {
[08:28:05.208]                   name <- added[[kk]]
[08:28:05.208]                   NAME <- NAMES[[kk]]
[08:28:05.208]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.208]                     next
[08:28:05.208]                   args[[name]] <- ""
[08:28:05.208]                 }
[08:28:05.208]                 NAMES <- toupper(removed)
[08:28:05.208]                 for (kk in seq_along(NAMES)) {
[08:28:05.208]                   name <- removed[[kk]]
[08:28:05.208]                   NAME <- NAMES[[kk]]
[08:28:05.208]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.208]                     next
[08:28:05.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.208]                 }
[08:28:05.208]                 if (length(args) > 0) 
[08:28:05.208]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.208]             }
[08:28:05.208]             else {
[08:28:05.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.208]             }
[08:28:05.208]             {
[08:28:05.208]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.208]                   0L) {
[08:28:05.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.208]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.208]                   base::options(opts)
[08:28:05.208]                 }
[08:28:05.208]                 {
[08:28:05.208]                   {
[08:28:05.208]                     NULL
[08:28:05.208]                     RNGkind("Mersenne-Twister")
[08:28:05.208]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:05.208]                       inherits = FALSE)
[08:28:05.208]                   }
[08:28:05.208]                   options(future.plan = NULL)
[08:28:05.208]                   if (is.na(NA_character_)) 
[08:28:05.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.208]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.208]                     .init = FALSE)
[08:28:05.208]                 }
[08:28:05.208]             }
[08:28:05.208]         }
[08:28:05.208]     })
[08:28:05.208]     if (TRUE) {
[08:28:05.208]         base::sink(type = "output", split = FALSE)
[08:28:05.208]         if (TRUE) {
[08:28:05.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.208]         }
[08:28:05.208]         else {
[08:28:05.208]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.208]         }
[08:28:05.208]         base::close(...future.stdout)
[08:28:05.208]         ...future.stdout <- NULL
[08:28:05.208]     }
[08:28:05.208]     ...future.result$conditions <- ...future.conditions
[08:28:05.208]     ...future.result$finished <- base::Sys.time()
[08:28:05.208]     ...future.result
[08:28:05.208] }
[08:28:05.210] plan(): Setting new future strategy stack:
[08:28:05.210] List of future strategies:
[08:28:05.210] 1. sequential:
[08:28:05.210]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.210]    - tweaked: FALSE
[08:28:05.210]    - call: NULL
[08:28:05.210] plan(): nbrOfWorkers() = 1
[08:28:05.211] plan(): Setting new future strategy stack:
[08:28:05.211] List of future strategies:
[08:28:05.211] 1. sequential:
[08:28:05.211]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.211]    - tweaked: FALSE
[08:28:05.211]    - call: plan(strategy)
[08:28:05.212] plan(): nbrOfWorkers() = 1
[08:28:05.212] SequentialFuture started (and completed)
[08:28:05.212] - Launch lazy future ... done
[08:28:05.212] run() for ‘SequentialFuture’ ... done
[08:28:05.213] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.213] Searching for globals...
[08:28:05.214] - globals found: [1] ‘getOption’
[08:28:05.214] Searching for globals ... DONE
[08:28:05.214] Resolving globals: FALSE
[08:28:05.214] 
[08:28:05.214] 
[08:28:05.214] getGlobalsAndPackages() ... DONE
[08:28:05.214] run() for ‘Future’ ...
[08:28:05.215] - state: ‘created’
[08:28:05.215] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:05.215] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:05.215] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:05.215]   - Field: ‘label’
[08:28:05.215]   - Field: ‘local’
[08:28:05.215]   - Field: ‘owner’
[08:28:05.215]   - Field: ‘envir’
[08:28:05.215]   - Field: ‘packages’
[08:28:05.216]   - Field: ‘gc’
[08:28:05.216]   - Field: ‘conditions’
[08:28:05.216]   - Field: ‘expr’
[08:28:05.216]   - Field: ‘uuid’
[08:28:05.216]   - Field: ‘seed’
[08:28:05.216]   - Field: ‘version’
[08:28:05.216]   - Field: ‘result’
[08:28:05.216]   - Field: ‘asynchronous’
[08:28:05.216]   - Field: ‘calls’
[08:28:05.216]   - Field: ‘globals’
[08:28:05.216]   - Field: ‘stdout’
[08:28:05.216]   - Field: ‘earlySignal’
[08:28:05.217]   - Field: ‘lazy’
[08:28:05.217]   - Field: ‘state’
[08:28:05.217] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:05.217] - Launch lazy future ...
[08:28:05.217] Packages needed by the future expression (n = 0): <none>
[08:28:05.217] Packages needed by future strategies (n = 0): <none>
[08:28:05.217] {
[08:28:05.217]     {
[08:28:05.217]         {
[08:28:05.217]             ...future.startTime <- base::Sys.time()
[08:28:05.217]             {
[08:28:05.217]                 {
[08:28:05.217]                   {
[08:28:05.217]                     base::local({
[08:28:05.217]                       has_future <- base::requireNamespace("future", 
[08:28:05.217]                         quietly = TRUE)
[08:28:05.217]                       if (has_future) {
[08:28:05.217]                         ns <- base::getNamespace("future")
[08:28:05.217]                         version <- ns[[".package"]][["version"]]
[08:28:05.217]                         if (is.null(version)) 
[08:28:05.217]                           version <- utils::packageVersion("future")
[08:28:05.217]                       }
[08:28:05.217]                       else {
[08:28:05.217]                         version <- NULL
[08:28:05.217]                       }
[08:28:05.217]                       if (!has_future || version < "1.8.0") {
[08:28:05.217]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.217]                           "", base::R.version$version.string), 
[08:28:05.217]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:05.217]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.217]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.217]                             "release", "version")], collapse = " "), 
[08:28:05.217]                           hostname = base::Sys.info()[["nodename"]])
[08:28:05.217]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.217]                           info)
[08:28:05.217]                         info <- base::paste(info, collapse = "; ")
[08:28:05.217]                         if (!has_future) {
[08:28:05.217]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.217]                             info)
[08:28:05.217]                         }
[08:28:05.217]                         else {
[08:28:05.217]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.217]                             info, version)
[08:28:05.217]                         }
[08:28:05.217]                         base::stop(msg)
[08:28:05.217]                       }
[08:28:05.217]                     })
[08:28:05.217]                   }
[08:28:05.217]                   ...future.strategy.old <- future::plan("list")
[08:28:05.217]                   options(future.plan = NULL)
[08:28:05.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:05.217]                 }
[08:28:05.217]                 ...future.workdir <- getwd()
[08:28:05.217]             }
[08:28:05.217]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.217]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.217]         }
[08:28:05.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:05.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.217]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:05.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.217]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.217]             base::names(...future.oldOptions))
[08:28:05.217]     }
[08:28:05.217]     if (FALSE) {
[08:28:05.217]     }
[08:28:05.217]     else {
[08:28:05.217]         if (TRUE) {
[08:28:05.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.217]                 open = "w")
[08:28:05.217]         }
[08:28:05.217]         else {
[08:28:05.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.217]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.217]         }
[08:28:05.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.217]             base::sink(type = "output", split = FALSE)
[08:28:05.217]             base::close(...future.stdout)
[08:28:05.217]         }, add = TRUE)
[08:28:05.217]     }
[08:28:05.217]     ...future.frame <- base::sys.nframe()
[08:28:05.217]     ...future.conditions <- base::list()
[08:28:05.217]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.217]     if (FALSE) {
[08:28:05.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.217]     }
[08:28:05.217]     ...future.result <- base::tryCatch({
[08:28:05.217]         base::withCallingHandlers({
[08:28:05.217]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[08:28:05.217]             future::FutureResult(value = ...future.value$value, 
[08:28:05.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.217]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.217]                     ...future.globalenv.names))
[08:28:05.217]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.217]         }, condition = base::local({
[08:28:05.217]             c <- base::c
[08:28:05.217]             inherits <- base::inherits
[08:28:05.217]             invokeRestart <- base::invokeRestart
[08:28:05.217]             length <- base::length
[08:28:05.217]             list <- base::list
[08:28:05.217]             seq.int <- base::seq.int
[08:28:05.217]             signalCondition <- base::signalCondition
[08:28:05.217]             sys.calls <- base::sys.calls
[08:28:05.217]             `[[` <- base::`[[`
[08:28:05.217]             `+` <- base::`+`
[08:28:05.217]             `<<-` <- base::`<<-`
[08:28:05.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.217]                   3L)]
[08:28:05.217]             }
[08:28:05.217]             function(cond) {
[08:28:05.217]                 is_error <- inherits(cond, "error")
[08:28:05.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.217]                   NULL)
[08:28:05.217]                 if (is_error) {
[08:28:05.217]                   sessionInformation <- function() {
[08:28:05.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.217]                       search = base::search(), system = base::Sys.info())
[08:28:05.217]                   }
[08:28:05.217]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.217]                     cond$call), session = sessionInformation(), 
[08:28:05.217]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.217]                   signalCondition(cond)
[08:28:05.217]                 }
[08:28:05.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.217]                 "immediateCondition"))) {
[08:28:05.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.217]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.217]                   if (TRUE && !signal) {
[08:28:05.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.217]                     {
[08:28:05.217]                       inherits <- base::inherits
[08:28:05.217]                       invokeRestart <- base::invokeRestart
[08:28:05.217]                       is.null <- base::is.null
[08:28:05.217]                       muffled <- FALSE
[08:28:05.217]                       if (inherits(cond, "message")) {
[08:28:05.217]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.217]                         if (muffled) 
[08:28:05.217]                           invokeRestart("muffleMessage")
[08:28:05.217]                       }
[08:28:05.217]                       else if (inherits(cond, "warning")) {
[08:28:05.217]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.217]                         if (muffled) 
[08:28:05.217]                           invokeRestart("muffleWarning")
[08:28:05.217]                       }
[08:28:05.217]                       else if (inherits(cond, "condition")) {
[08:28:05.217]                         if (!is.null(pattern)) {
[08:28:05.217]                           computeRestarts <- base::computeRestarts
[08:28:05.217]                           grepl <- base::grepl
[08:28:05.217]                           restarts <- computeRestarts(cond)
[08:28:05.217]                           for (restart in restarts) {
[08:28:05.217]                             name <- restart$name
[08:28:05.217]                             if (is.null(name)) 
[08:28:05.217]                               next
[08:28:05.217]                             if (!grepl(pattern, name)) 
[08:28:05.217]                               next
[08:28:05.217]                             invokeRestart(restart)
[08:28:05.217]                             muffled <- TRUE
[08:28:05.217]                             break
[08:28:05.217]                           }
[08:28:05.217]                         }
[08:28:05.217]                       }
[08:28:05.217]                       invisible(muffled)
[08:28:05.217]                     }
[08:28:05.217]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.217]                   }
[08:28:05.217]                 }
[08:28:05.217]                 else {
[08:28:05.217]                   if (TRUE) {
[08:28:05.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.217]                     {
[08:28:05.217]                       inherits <- base::inherits
[08:28:05.217]                       invokeRestart <- base::invokeRestart
[08:28:05.217]                       is.null <- base::is.null
[08:28:05.217]                       muffled <- FALSE
[08:28:05.217]                       if (inherits(cond, "message")) {
[08:28:05.217]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.217]                         if (muffled) 
[08:28:05.217]                           invokeRestart("muffleMessage")
[08:28:05.217]                       }
[08:28:05.217]                       else if (inherits(cond, "warning")) {
[08:28:05.217]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.217]                         if (muffled) 
[08:28:05.217]                           invokeRestart("muffleWarning")
[08:28:05.217]                       }
[08:28:05.217]                       else if (inherits(cond, "condition")) {
[08:28:05.217]                         if (!is.null(pattern)) {
[08:28:05.217]                           computeRestarts <- base::computeRestarts
[08:28:05.217]                           grepl <- base::grepl
[08:28:05.217]                           restarts <- computeRestarts(cond)
[08:28:05.217]                           for (restart in restarts) {
[08:28:05.217]                             name <- restart$name
[08:28:05.217]                             if (is.null(name)) 
[08:28:05.217]                               next
[08:28:05.217]                             if (!grepl(pattern, name)) 
[08:28:05.217]                               next
[08:28:05.217]                             invokeRestart(restart)
[08:28:05.217]                             muffled <- TRUE
[08:28:05.217]                             break
[08:28:05.217]                           }
[08:28:05.217]                         }
[08:28:05.217]                       }
[08:28:05.217]                       invisible(muffled)
[08:28:05.217]                     }
[08:28:05.217]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.217]                   }
[08:28:05.217]                 }
[08:28:05.217]             }
[08:28:05.217]         }))
[08:28:05.217]     }, error = function(ex) {
[08:28:05.217]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.217]                 ...future.rng), started = ...future.startTime, 
[08:28:05.217]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.217]             version = "1.8"), class = "FutureResult")
[08:28:05.217]     }, finally = {
[08:28:05.217]         if (!identical(...future.workdir, getwd())) 
[08:28:05.217]             setwd(...future.workdir)
[08:28:05.217]         {
[08:28:05.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.217]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.217]             }
[08:28:05.217]             base::options(...future.oldOptions)
[08:28:05.217]             if (.Platform$OS.type == "windows") {
[08:28:05.217]                 old_names <- names(...future.oldEnvVars)
[08:28:05.217]                 envs <- base::Sys.getenv()
[08:28:05.217]                 names <- names(envs)
[08:28:05.217]                 common <- intersect(names, old_names)
[08:28:05.217]                 added <- setdiff(names, old_names)
[08:28:05.217]                 removed <- setdiff(old_names, names)
[08:28:05.217]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.217]                   envs[common]]
[08:28:05.217]                 NAMES <- toupper(changed)
[08:28:05.217]                 args <- list()
[08:28:05.217]                 for (kk in seq_along(NAMES)) {
[08:28:05.217]                   name <- changed[[kk]]
[08:28:05.217]                   NAME <- NAMES[[kk]]
[08:28:05.217]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.217]                     next
[08:28:05.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.217]                 }
[08:28:05.217]                 NAMES <- toupper(added)
[08:28:05.217]                 for (kk in seq_along(NAMES)) {
[08:28:05.217]                   name <- added[[kk]]
[08:28:05.217]                   NAME <- NAMES[[kk]]
[08:28:05.217]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.217]                     next
[08:28:05.217]                   args[[name]] <- ""
[08:28:05.217]                 }
[08:28:05.217]                 NAMES <- toupper(removed)
[08:28:05.217]                 for (kk in seq_along(NAMES)) {
[08:28:05.217]                   name <- removed[[kk]]
[08:28:05.217]                   NAME <- NAMES[[kk]]
[08:28:05.217]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.217]                     next
[08:28:05.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.217]                 }
[08:28:05.217]                 if (length(args) > 0) 
[08:28:05.217]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.217]             }
[08:28:05.217]             else {
[08:28:05.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.217]             }
[08:28:05.217]             {
[08:28:05.217]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.217]                   0L) {
[08:28:05.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.217]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.217]                   base::options(opts)
[08:28:05.217]                 }
[08:28:05.217]                 {
[08:28:05.217]                   {
[08:28:05.217]                     NULL
[08:28:05.217]                     RNGkind("Mersenne-Twister")
[08:28:05.217]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:05.217]                       inherits = FALSE)
[08:28:05.217]                   }
[08:28:05.217]                   options(future.plan = NULL)
[08:28:05.217]                   if (is.na(NA_character_)) 
[08:28:05.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.217]                     .init = FALSE)
[08:28:05.217]                 }
[08:28:05.217]             }
[08:28:05.217]         }
[08:28:05.217]     })
[08:28:05.217]     if (TRUE) {
[08:28:05.217]         base::sink(type = "output", split = FALSE)
[08:28:05.217]         if (TRUE) {
[08:28:05.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.217]         }
[08:28:05.217]         else {
[08:28:05.217]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.217]         }
[08:28:05.217]         base::close(...future.stdout)
[08:28:05.217]         ...future.stdout <- NULL
[08:28:05.217]     }
[08:28:05.217]     ...future.result$conditions <- ...future.conditions
[08:28:05.217]     ...future.result$finished <- base::Sys.time()
[08:28:05.217]     ...future.result
[08:28:05.217] }
[08:28:05.219] plan(): Setting new future strategy stack:
[08:28:05.219] List of future strategies:
[08:28:05.219] 1. sequential:
[08:28:05.219]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.219]    - tweaked: FALSE
[08:28:05.219]    - call: NULL
[08:28:05.220] plan(): nbrOfWorkers() = 1
[08:28:05.220] plan(): Setting new future strategy stack:
[08:28:05.220] List of future strategies:
[08:28:05.220] 1. sequential:
[08:28:05.220]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.220]    - tweaked: FALSE
[08:28:05.220]    - call: plan(strategy)
[08:28:05.221] plan(): nbrOfWorkers() = 1
[08:28:05.221] SequentialFuture started (and completed)
[08:28:05.221] - Launch lazy future ... done
[08:28:05.221] run() for ‘SequentialFuture’ ... done
[08:28:05.222] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:05.222] Searching for globals...
[08:28:05.225] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.225] Searching for globals...
[08:28:05.226] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[08:28:05.226] Searching for globals ... DONE
[08:28:05.226] Resolving globals: FALSE
[08:28:05.227] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:05.228] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:05.228] - globals: [1] ‘data’
[08:28:05.228] 
[08:28:05.228] getGlobalsAndPackages() ... DONE
[08:28:05.228] run() for ‘Future’ ...
[08:28:05.228] - state: ‘created’
[08:28:05.228] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:05.229] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:05.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:05.229]   - Field: ‘label’
[08:28:05.229]   - Field: ‘local’
[08:28:05.229]   - Field: ‘owner’
[08:28:05.229]   - Field: ‘envir’
[08:28:05.229]   - Field: ‘packages’
[08:28:05.229]   - Field: ‘gc’
[08:28:05.229]   - Field: ‘conditions’
[08:28:05.229]   - Field: ‘expr’
[08:28:05.229]   - Field: ‘uuid’
[08:28:05.230]   - Field: ‘seed’
[08:28:05.230]   - Field: ‘version’
[08:28:05.230]   - Field: ‘result’
[08:28:05.230]   - Field: ‘asynchronous’
[08:28:05.230]   - Field: ‘calls’
[08:28:05.230]   - Field: ‘globals’
[08:28:05.230]   - Field: ‘stdout’
[08:28:05.230]   - Field: ‘earlySignal’
[08:28:05.230]   - Field: ‘lazy’
[08:28:05.230]   - Field: ‘state’
[08:28:05.230] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:05.231] - Launch lazy future ...
[08:28:05.231] Packages needed by the future expression (n = 0): <none>
[08:28:05.231] Packages needed by future strategies (n = 0): <none>
[08:28:05.231] {
[08:28:05.231]     {
[08:28:05.231]         {
[08:28:05.231]             ...future.startTime <- base::Sys.time()
[08:28:05.231]             {
[08:28:05.231]                 {
[08:28:05.231]                   {
[08:28:05.231]                     base::local({
[08:28:05.231]                       has_future <- base::requireNamespace("future", 
[08:28:05.231]                         quietly = TRUE)
[08:28:05.231]                       if (has_future) {
[08:28:05.231]                         ns <- base::getNamespace("future")
[08:28:05.231]                         version <- ns[[".package"]][["version"]]
[08:28:05.231]                         if (is.null(version)) 
[08:28:05.231]                           version <- utils::packageVersion("future")
[08:28:05.231]                       }
[08:28:05.231]                       else {
[08:28:05.231]                         version <- NULL
[08:28:05.231]                       }
[08:28:05.231]                       if (!has_future || version < "1.8.0") {
[08:28:05.231]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.231]                           "", base::R.version$version.string), 
[08:28:05.231]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:05.231]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.231]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.231]                             "release", "version")], collapse = " "), 
[08:28:05.231]                           hostname = base::Sys.info()[["nodename"]])
[08:28:05.231]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.231]                           info)
[08:28:05.231]                         info <- base::paste(info, collapse = "; ")
[08:28:05.231]                         if (!has_future) {
[08:28:05.231]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.231]                             info)
[08:28:05.231]                         }
[08:28:05.231]                         else {
[08:28:05.231]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.231]                             info, version)
[08:28:05.231]                         }
[08:28:05.231]                         base::stop(msg)
[08:28:05.231]                       }
[08:28:05.231]                     })
[08:28:05.231]                   }
[08:28:05.231]                   ...future.strategy.old <- future::plan("list")
[08:28:05.231]                   options(future.plan = NULL)
[08:28:05.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:05.231]                 }
[08:28:05.231]                 ...future.workdir <- getwd()
[08:28:05.231]             }
[08:28:05.231]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.231]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.231]         }
[08:28:05.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:05.231]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.231]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:05.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.231]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.231]             base::names(...future.oldOptions))
[08:28:05.231]     }
[08:28:05.231]     if (FALSE) {
[08:28:05.231]     }
[08:28:05.231]     else {
[08:28:05.231]         if (TRUE) {
[08:28:05.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.231]                 open = "w")
[08:28:05.231]         }
[08:28:05.231]         else {
[08:28:05.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.231]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.231]         }
[08:28:05.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.231]             base::sink(type = "output", split = FALSE)
[08:28:05.231]             base::close(...future.stdout)
[08:28:05.231]         }, add = TRUE)
[08:28:05.231]     }
[08:28:05.231]     ...future.frame <- base::sys.nframe()
[08:28:05.231]     ...future.conditions <- base::list()
[08:28:05.231]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.231]     if (FALSE) {
[08:28:05.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.231]     }
[08:28:05.231]     ...future.result <- base::tryCatch({
[08:28:05.231]         base::withCallingHandlers({
[08:28:05.231]             ...future.value <- base::withVisible(base::local(subset(data, 
[08:28:05.231]                 x < 3)$y))
[08:28:05.231]             future::FutureResult(value = ...future.value$value, 
[08:28:05.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.231]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.231]                     ...future.globalenv.names))
[08:28:05.231]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.231]         }, condition = base::local({
[08:28:05.231]             c <- base::c
[08:28:05.231]             inherits <- base::inherits
[08:28:05.231]             invokeRestart <- base::invokeRestart
[08:28:05.231]             length <- base::length
[08:28:05.231]             list <- base::list
[08:28:05.231]             seq.int <- base::seq.int
[08:28:05.231]             signalCondition <- base::signalCondition
[08:28:05.231]             sys.calls <- base::sys.calls
[08:28:05.231]             `[[` <- base::`[[`
[08:28:05.231]             `+` <- base::`+`
[08:28:05.231]             `<<-` <- base::`<<-`
[08:28:05.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.231]                   3L)]
[08:28:05.231]             }
[08:28:05.231]             function(cond) {
[08:28:05.231]                 is_error <- inherits(cond, "error")
[08:28:05.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.231]                   NULL)
[08:28:05.231]                 if (is_error) {
[08:28:05.231]                   sessionInformation <- function() {
[08:28:05.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.231]                       search = base::search(), system = base::Sys.info())
[08:28:05.231]                   }
[08:28:05.231]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.231]                     cond$call), session = sessionInformation(), 
[08:28:05.231]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.231]                   signalCondition(cond)
[08:28:05.231]                 }
[08:28:05.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.231]                 "immediateCondition"))) {
[08:28:05.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.231]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.231]                   if (TRUE && !signal) {
[08:28:05.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.231]                     {
[08:28:05.231]                       inherits <- base::inherits
[08:28:05.231]                       invokeRestart <- base::invokeRestart
[08:28:05.231]                       is.null <- base::is.null
[08:28:05.231]                       muffled <- FALSE
[08:28:05.231]                       if (inherits(cond, "message")) {
[08:28:05.231]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.231]                         if (muffled) 
[08:28:05.231]                           invokeRestart("muffleMessage")
[08:28:05.231]                       }
[08:28:05.231]                       else if (inherits(cond, "warning")) {
[08:28:05.231]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.231]                         if (muffled) 
[08:28:05.231]                           invokeRestart("muffleWarning")
[08:28:05.231]                       }
[08:28:05.231]                       else if (inherits(cond, "condition")) {
[08:28:05.231]                         if (!is.null(pattern)) {
[08:28:05.231]                           computeRestarts <- base::computeRestarts
[08:28:05.231]                           grepl <- base::grepl
[08:28:05.231]                           restarts <- computeRestarts(cond)
[08:28:05.231]                           for (restart in restarts) {
[08:28:05.231]                             name <- restart$name
[08:28:05.231]                             if (is.null(name)) 
[08:28:05.231]                               next
[08:28:05.231]                             if (!grepl(pattern, name)) 
[08:28:05.231]                               next
[08:28:05.231]                             invokeRestart(restart)
[08:28:05.231]                             muffled <- TRUE
[08:28:05.231]                             break
[08:28:05.231]                           }
[08:28:05.231]                         }
[08:28:05.231]                       }
[08:28:05.231]                       invisible(muffled)
[08:28:05.231]                     }
[08:28:05.231]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.231]                   }
[08:28:05.231]                 }
[08:28:05.231]                 else {
[08:28:05.231]                   if (TRUE) {
[08:28:05.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.231]                     {
[08:28:05.231]                       inherits <- base::inherits
[08:28:05.231]                       invokeRestart <- base::invokeRestart
[08:28:05.231]                       is.null <- base::is.null
[08:28:05.231]                       muffled <- FALSE
[08:28:05.231]                       if (inherits(cond, "message")) {
[08:28:05.231]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.231]                         if (muffled) 
[08:28:05.231]                           invokeRestart("muffleMessage")
[08:28:05.231]                       }
[08:28:05.231]                       else if (inherits(cond, "warning")) {
[08:28:05.231]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.231]                         if (muffled) 
[08:28:05.231]                           invokeRestart("muffleWarning")
[08:28:05.231]                       }
[08:28:05.231]                       else if (inherits(cond, "condition")) {
[08:28:05.231]                         if (!is.null(pattern)) {
[08:28:05.231]                           computeRestarts <- base::computeRestarts
[08:28:05.231]                           grepl <- base::grepl
[08:28:05.231]                           restarts <- computeRestarts(cond)
[08:28:05.231]                           for (restart in restarts) {
[08:28:05.231]                             name <- restart$name
[08:28:05.231]                             if (is.null(name)) 
[08:28:05.231]                               next
[08:28:05.231]                             if (!grepl(pattern, name)) 
[08:28:05.231]                               next
[08:28:05.231]                             invokeRestart(restart)
[08:28:05.231]                             muffled <- TRUE
[08:28:05.231]                             break
[08:28:05.231]                           }
[08:28:05.231]                         }
[08:28:05.231]                       }
[08:28:05.231]                       invisible(muffled)
[08:28:05.231]                     }
[08:28:05.231]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.231]                   }
[08:28:05.231]                 }
[08:28:05.231]             }
[08:28:05.231]         }))
[08:28:05.231]     }, error = function(ex) {
[08:28:05.231]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.231]                 ...future.rng), started = ...future.startTime, 
[08:28:05.231]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.231]             version = "1.8"), class = "FutureResult")
[08:28:05.231]     }, finally = {
[08:28:05.231]         if (!identical(...future.workdir, getwd())) 
[08:28:05.231]             setwd(...future.workdir)
[08:28:05.231]         {
[08:28:05.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.231]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.231]             }
[08:28:05.231]             base::options(...future.oldOptions)
[08:28:05.231]             if (.Platform$OS.type == "windows") {
[08:28:05.231]                 old_names <- names(...future.oldEnvVars)
[08:28:05.231]                 envs <- base::Sys.getenv()
[08:28:05.231]                 names <- names(envs)
[08:28:05.231]                 common <- intersect(names, old_names)
[08:28:05.231]                 added <- setdiff(names, old_names)
[08:28:05.231]                 removed <- setdiff(old_names, names)
[08:28:05.231]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.231]                   envs[common]]
[08:28:05.231]                 NAMES <- toupper(changed)
[08:28:05.231]                 args <- list()
[08:28:05.231]                 for (kk in seq_along(NAMES)) {
[08:28:05.231]                   name <- changed[[kk]]
[08:28:05.231]                   NAME <- NAMES[[kk]]
[08:28:05.231]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.231]                     next
[08:28:05.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.231]                 }
[08:28:05.231]                 NAMES <- toupper(added)
[08:28:05.231]                 for (kk in seq_along(NAMES)) {
[08:28:05.231]                   name <- added[[kk]]
[08:28:05.231]                   NAME <- NAMES[[kk]]
[08:28:05.231]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.231]                     next
[08:28:05.231]                   args[[name]] <- ""
[08:28:05.231]                 }
[08:28:05.231]                 NAMES <- toupper(removed)
[08:28:05.231]                 for (kk in seq_along(NAMES)) {
[08:28:05.231]                   name <- removed[[kk]]
[08:28:05.231]                   NAME <- NAMES[[kk]]
[08:28:05.231]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.231]                     next
[08:28:05.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.231]                 }
[08:28:05.231]                 if (length(args) > 0) 
[08:28:05.231]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.231]             }
[08:28:05.231]             else {
[08:28:05.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.231]             }
[08:28:05.231]             {
[08:28:05.231]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.231]                   0L) {
[08:28:05.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.231]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.231]                   base::options(opts)
[08:28:05.231]                 }
[08:28:05.231]                 {
[08:28:05.231]                   {
[08:28:05.231]                     NULL
[08:28:05.231]                     RNGkind("Mersenne-Twister")
[08:28:05.231]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:05.231]                       inherits = FALSE)
[08:28:05.231]                   }
[08:28:05.231]                   options(future.plan = NULL)
[08:28:05.231]                   if (is.na(NA_character_)) 
[08:28:05.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.231]                     .init = FALSE)
[08:28:05.231]                 }
[08:28:05.231]             }
[08:28:05.231]         }
[08:28:05.231]     })
[08:28:05.231]     if (TRUE) {
[08:28:05.231]         base::sink(type = "output", split = FALSE)
[08:28:05.231]         if (TRUE) {
[08:28:05.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.231]         }
[08:28:05.231]         else {
[08:28:05.231]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.231]         }
[08:28:05.231]         base::close(...future.stdout)
[08:28:05.231]         ...future.stdout <- NULL
[08:28:05.231]     }
[08:28:05.231]     ...future.result$conditions <- ...future.conditions
[08:28:05.231]     ...future.result$finished <- base::Sys.time()
[08:28:05.231]     ...future.result
[08:28:05.231] }
[08:28:05.233] assign_globals() ...
[08:28:05.233] List of 1
[08:28:05.233]  $ data:'data.frame':	5 obs. of  2 variables:
[08:28:05.233]   ..$ x: int [1:5] 1 2 3 4 5
[08:28:05.233]   ..$ y: int [1:5] 1 2 3 4 5
[08:28:05.233]  - attr(*, "where")=List of 1
[08:28:05.233]   ..$ data:<environment: R_EmptyEnv> 
[08:28:05.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:05.233]  - attr(*, "resolved")= logi FALSE
[08:28:05.233]  - attr(*, "total_size")= num 356
[08:28:05.233]  - attr(*, "already-done")= logi TRUE
[08:28:05.238] - copied ‘data’ to environment
[08:28:05.238] assign_globals() ... done
[08:28:05.239] plan(): Setting new future strategy stack:
[08:28:05.239] List of future strategies:
[08:28:05.239] 1. sequential:
[08:28:05.239]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.239]    - tweaked: FALSE
[08:28:05.239]    - call: NULL
[08:28:05.239] plan(): nbrOfWorkers() = 1
[08:28:05.240] plan(): Setting new future strategy stack:
[08:28:05.240] List of future strategies:
[08:28:05.240] 1. sequential:
[08:28:05.240]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.240]    - tweaked: FALSE
[08:28:05.240]    - call: plan(strategy)
[08:28:05.241] plan(): nbrOfWorkers() = 1
[08:28:05.241] SequentialFuture started (and completed)
[08:28:05.241] - Launch lazy future ... done
[08:28:05.241] run() for ‘SequentialFuture’ ... done
[08:28:05.241] plan(): Setting new future strategy stack:
[08:28:05.241] List of future strategies:
[08:28:05.241] 1. sequential:
[08:28:05.241]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.241]    - tweaked: FALSE
[08:28:05.241]    - call: plan(list(sequential, strategy))
[08:28:05.241] 2. sequential:
[08:28:05.241]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.241]    - tweaked: FALSE
[08:28:05.241]    - call: plan(list(sequential, strategy))
[08:28:05.242] plan(): nbrOfWorkers() = 1
[08:28:05.242] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.242] Searching for globals...
[08:28:05.248] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[08:28:05.248] Searching for globals ... DONE
[08:28:05.248] Resolving globals: FALSE
[08:28:05.248] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:05.249] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:05.249] - globals: [1] ‘data’
[08:28:05.249] - packages: [1] ‘future’
[08:28:05.249] getGlobalsAndPackages() ... DONE
[08:28:05.249] run() for ‘Future’ ...
[08:28:05.250] - state: ‘created’
[08:28:05.250] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:05.250] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:05.250] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:05.250]   - Field: ‘label’
[08:28:05.250]   - Field: ‘local’
[08:28:05.250]   - Field: ‘owner’
[08:28:05.250]   - Field: ‘envir’
[08:28:05.251]   - Field: ‘packages’
[08:28:05.251]   - Field: ‘gc’
[08:28:05.251]   - Field: ‘conditions’
[08:28:05.251]   - Field: ‘expr’
[08:28:05.251]   - Field: ‘uuid’
[08:28:05.251]   - Field: ‘seed’
[08:28:05.251]   - Field: ‘version’
[08:28:05.251]   - Field: ‘result’
[08:28:05.251]   - Field: ‘asynchronous’
[08:28:05.251]   - Field: ‘calls’
[08:28:05.251]   - Field: ‘globals’
[08:28:05.251]   - Field: ‘stdout’
[08:28:05.252]   - Field: ‘earlySignal’
[08:28:05.252]   - Field: ‘lazy’
[08:28:05.252]   - Field: ‘state’
[08:28:05.252] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:05.252] - Launch lazy future ...
[08:28:05.252] Packages needed by the future expression (n = 1): ‘future’
[08:28:05.252] Packages needed by future strategies (n = 1): ‘future’
[08:28:05.255] {
[08:28:05.255]     {
[08:28:05.255]         {
[08:28:05.255]             ...future.startTime <- base::Sys.time()
[08:28:05.255]             {
[08:28:05.255]                 {
[08:28:05.255]                   {
[08:28:05.255]                     {
[08:28:05.255]                       base::local({
[08:28:05.255]                         has_future <- base::requireNamespace("future", 
[08:28:05.255]                           quietly = TRUE)
[08:28:05.255]                         if (has_future) {
[08:28:05.255]                           ns <- base::getNamespace("future")
[08:28:05.255]                           version <- ns[[".package"]][["version"]]
[08:28:05.255]                           if (is.null(version)) 
[08:28:05.255]                             version <- utils::packageVersion("future")
[08:28:05.255]                         }
[08:28:05.255]                         else {
[08:28:05.255]                           version <- NULL
[08:28:05.255]                         }
[08:28:05.255]                         if (!has_future || version < "1.8.0") {
[08:28:05.255]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.255]                             "", base::R.version$version.string), 
[08:28:05.255]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:05.255]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.255]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.255]                               "release", "version")], collapse = " "), 
[08:28:05.255]                             hostname = base::Sys.info()[["nodename"]])
[08:28:05.255]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.255]                             info)
[08:28:05.255]                           info <- base::paste(info, collapse = "; ")
[08:28:05.255]                           if (!has_future) {
[08:28:05.255]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.255]                               info)
[08:28:05.255]                           }
[08:28:05.255]                           else {
[08:28:05.255]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.255]                               info, version)
[08:28:05.255]                           }
[08:28:05.255]                           base::stop(msg)
[08:28:05.255]                         }
[08:28:05.255]                       })
[08:28:05.255]                     }
[08:28:05.255]                     base::local({
[08:28:05.255]                       for (pkg in "future") {
[08:28:05.255]                         base::loadNamespace(pkg)
[08:28:05.255]                         base::library(pkg, character.only = TRUE)
[08:28:05.255]                       }
[08:28:05.255]                     })
[08:28:05.255]                   }
[08:28:05.255]                   ...future.strategy.old <- future::plan("list")
[08:28:05.255]                   options(future.plan = NULL)
[08:28:05.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.255]                   future::plan(list(function (..., envir = parent.frame()) 
[08:28:05.255]                   {
[08:28:05.255]                     future <- SequentialFuture(..., envir = envir)
[08:28:05.255]                     if (!future$lazy) 
[08:28:05.255]                       future <- run(future)
[08:28:05.255]                     invisible(future)
[08:28:05.255]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:05.255]                 }
[08:28:05.255]                 ...future.workdir <- getwd()
[08:28:05.255]             }
[08:28:05.255]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.255]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.255]         }
[08:28:05.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:05.255]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.255]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:05.255]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.255]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.255]             base::names(...future.oldOptions))
[08:28:05.255]     }
[08:28:05.255]     if (FALSE) {
[08:28:05.255]     }
[08:28:05.255]     else {
[08:28:05.255]         if (TRUE) {
[08:28:05.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.255]                 open = "w")
[08:28:05.255]         }
[08:28:05.255]         else {
[08:28:05.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.255]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.255]         }
[08:28:05.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.255]             base::sink(type = "output", split = FALSE)
[08:28:05.255]             base::close(...future.stdout)
[08:28:05.255]         }, add = TRUE)
[08:28:05.255]     }
[08:28:05.255]     ...future.frame <- base::sys.nframe()
[08:28:05.255]     ...future.conditions <- base::list()
[08:28:05.255]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.255]     if (FALSE) {
[08:28:05.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.255]     }
[08:28:05.255]     ...future.result <- base::tryCatch({
[08:28:05.255]         base::withCallingHandlers({
[08:28:05.255]             ...future.value <- base::withVisible(base::local({
[08:28:05.255]                 a %<-% subset(data, x < 3)$y
[08:28:05.255]                 a
[08:28:05.255]             }))
[08:28:05.255]             future::FutureResult(value = ...future.value$value, 
[08:28:05.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.255]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.255]                     ...future.globalenv.names))
[08:28:05.255]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.255]         }, condition = base::local({
[08:28:05.255]             c <- base::c
[08:28:05.255]             inherits <- base::inherits
[08:28:05.255]             invokeRestart <- base::invokeRestart
[08:28:05.255]             length <- base::length
[08:28:05.255]             list <- base::list
[08:28:05.255]             seq.int <- base::seq.int
[08:28:05.255]             signalCondition <- base::signalCondition
[08:28:05.255]             sys.calls <- base::sys.calls
[08:28:05.255]             `[[` <- base::`[[`
[08:28:05.255]             `+` <- base::`+`
[08:28:05.255]             `<<-` <- base::`<<-`
[08:28:05.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.255]                   3L)]
[08:28:05.255]             }
[08:28:05.255]             function(cond) {
[08:28:05.255]                 is_error <- inherits(cond, "error")
[08:28:05.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.255]                   NULL)
[08:28:05.255]                 if (is_error) {
[08:28:05.255]                   sessionInformation <- function() {
[08:28:05.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.255]                       search = base::search(), system = base::Sys.info())
[08:28:05.255]                   }
[08:28:05.255]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.255]                     cond$call), session = sessionInformation(), 
[08:28:05.255]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.255]                   signalCondition(cond)
[08:28:05.255]                 }
[08:28:05.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.255]                 "immediateCondition"))) {
[08:28:05.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.255]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.255]                   if (TRUE && !signal) {
[08:28:05.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.255]                     {
[08:28:05.255]                       inherits <- base::inherits
[08:28:05.255]                       invokeRestart <- base::invokeRestart
[08:28:05.255]                       is.null <- base::is.null
[08:28:05.255]                       muffled <- FALSE
[08:28:05.255]                       if (inherits(cond, "message")) {
[08:28:05.255]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.255]                         if (muffled) 
[08:28:05.255]                           invokeRestart("muffleMessage")
[08:28:05.255]                       }
[08:28:05.255]                       else if (inherits(cond, "warning")) {
[08:28:05.255]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.255]                         if (muffled) 
[08:28:05.255]                           invokeRestart("muffleWarning")
[08:28:05.255]                       }
[08:28:05.255]                       else if (inherits(cond, "condition")) {
[08:28:05.255]                         if (!is.null(pattern)) {
[08:28:05.255]                           computeRestarts <- base::computeRestarts
[08:28:05.255]                           grepl <- base::grepl
[08:28:05.255]                           restarts <- computeRestarts(cond)
[08:28:05.255]                           for (restart in restarts) {
[08:28:05.255]                             name <- restart$name
[08:28:05.255]                             if (is.null(name)) 
[08:28:05.255]                               next
[08:28:05.255]                             if (!grepl(pattern, name)) 
[08:28:05.255]                               next
[08:28:05.255]                             invokeRestart(restart)
[08:28:05.255]                             muffled <- TRUE
[08:28:05.255]                             break
[08:28:05.255]                           }
[08:28:05.255]                         }
[08:28:05.255]                       }
[08:28:05.255]                       invisible(muffled)
[08:28:05.255]                     }
[08:28:05.255]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.255]                   }
[08:28:05.255]                 }
[08:28:05.255]                 else {
[08:28:05.255]                   if (TRUE) {
[08:28:05.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.255]                     {
[08:28:05.255]                       inherits <- base::inherits
[08:28:05.255]                       invokeRestart <- base::invokeRestart
[08:28:05.255]                       is.null <- base::is.null
[08:28:05.255]                       muffled <- FALSE
[08:28:05.255]                       if (inherits(cond, "message")) {
[08:28:05.255]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.255]                         if (muffled) 
[08:28:05.255]                           invokeRestart("muffleMessage")
[08:28:05.255]                       }
[08:28:05.255]                       else if (inherits(cond, "warning")) {
[08:28:05.255]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.255]                         if (muffled) 
[08:28:05.255]                           invokeRestart("muffleWarning")
[08:28:05.255]                       }
[08:28:05.255]                       else if (inherits(cond, "condition")) {
[08:28:05.255]                         if (!is.null(pattern)) {
[08:28:05.255]                           computeRestarts <- base::computeRestarts
[08:28:05.255]                           grepl <- base::grepl
[08:28:05.255]                           restarts <- computeRestarts(cond)
[08:28:05.255]                           for (restart in restarts) {
[08:28:05.255]                             name <- restart$name
[08:28:05.255]                             if (is.null(name)) 
[08:28:05.255]                               next
[08:28:05.255]                             if (!grepl(pattern, name)) 
[08:28:05.255]                               next
[08:28:05.255]                             invokeRestart(restart)
[08:28:05.255]                             muffled <- TRUE
[08:28:05.255]                             break
[08:28:05.255]                           }
[08:28:05.255]                         }
[08:28:05.255]                       }
[08:28:05.255]                       invisible(muffled)
[08:28:05.255]                     }
[08:28:05.255]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.255]                   }
[08:28:05.255]                 }
[08:28:05.255]             }
[08:28:05.255]         }))
[08:28:05.255]     }, error = function(ex) {
[08:28:05.255]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.255]                 ...future.rng), started = ...future.startTime, 
[08:28:05.255]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.255]             version = "1.8"), class = "FutureResult")
[08:28:05.255]     }, finally = {
[08:28:05.255]         if (!identical(...future.workdir, getwd())) 
[08:28:05.255]             setwd(...future.workdir)
[08:28:05.255]         {
[08:28:05.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.255]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.255]             }
[08:28:05.255]             base::options(...future.oldOptions)
[08:28:05.255]             if (.Platform$OS.type == "windows") {
[08:28:05.255]                 old_names <- names(...future.oldEnvVars)
[08:28:05.255]                 envs <- base::Sys.getenv()
[08:28:05.255]                 names <- names(envs)
[08:28:05.255]                 common <- intersect(names, old_names)
[08:28:05.255]                 added <- setdiff(names, old_names)
[08:28:05.255]                 removed <- setdiff(old_names, names)
[08:28:05.255]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.255]                   envs[common]]
[08:28:05.255]                 NAMES <- toupper(changed)
[08:28:05.255]                 args <- list()
[08:28:05.255]                 for (kk in seq_along(NAMES)) {
[08:28:05.255]                   name <- changed[[kk]]
[08:28:05.255]                   NAME <- NAMES[[kk]]
[08:28:05.255]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.255]                     next
[08:28:05.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.255]                 }
[08:28:05.255]                 NAMES <- toupper(added)
[08:28:05.255]                 for (kk in seq_along(NAMES)) {
[08:28:05.255]                   name <- added[[kk]]
[08:28:05.255]                   NAME <- NAMES[[kk]]
[08:28:05.255]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.255]                     next
[08:28:05.255]                   args[[name]] <- ""
[08:28:05.255]                 }
[08:28:05.255]                 NAMES <- toupper(removed)
[08:28:05.255]                 for (kk in seq_along(NAMES)) {
[08:28:05.255]                   name <- removed[[kk]]
[08:28:05.255]                   NAME <- NAMES[[kk]]
[08:28:05.255]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.255]                     next
[08:28:05.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.255]                 }
[08:28:05.255]                 if (length(args) > 0) 
[08:28:05.255]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.255]             }
[08:28:05.255]             else {
[08:28:05.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.255]             }
[08:28:05.255]             {
[08:28:05.255]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.255]                   0L) {
[08:28:05.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.255]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.255]                   base::options(opts)
[08:28:05.255]                 }
[08:28:05.255]                 {
[08:28:05.255]                   {
[08:28:05.255]                     NULL
[08:28:05.255]                     RNGkind("Mersenne-Twister")
[08:28:05.255]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:05.255]                       inherits = FALSE)
[08:28:05.255]                   }
[08:28:05.255]                   options(future.plan = NULL)
[08:28:05.255]                   if (is.na(NA_character_)) 
[08:28:05.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.255]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.255]                     .init = FALSE)
[08:28:05.255]                 }
[08:28:05.255]             }
[08:28:05.255]         }
[08:28:05.255]     })
[08:28:05.255]     if (TRUE) {
[08:28:05.255]         base::sink(type = "output", split = FALSE)
[08:28:05.255]         if (TRUE) {
[08:28:05.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.255]         }
[08:28:05.255]         else {
[08:28:05.255]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.255]         }
[08:28:05.255]         base::close(...future.stdout)
[08:28:05.255]         ...future.stdout <- NULL
[08:28:05.255]     }
[08:28:05.255]     ...future.result$conditions <- ...future.conditions
[08:28:05.255]     ...future.result$finished <- base::Sys.time()
[08:28:05.255]     ...future.result
[08:28:05.255] }
[08:28:05.257] assign_globals() ...
[08:28:05.257] List of 1
[08:28:05.257]  $ data:'data.frame':	5 obs. of  2 variables:
[08:28:05.257]   ..$ x: int [1:5] 1 2 3 4 5
[08:28:05.257]   ..$ y: int [1:5] 1 2 3 4 5
[08:28:05.257]  - attr(*, "where")=List of 1
[08:28:05.257]   ..$ data:<environment: R_EmptyEnv> 
[08:28:05.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:05.257]  - attr(*, "resolved")= logi FALSE
[08:28:05.257]  - attr(*, "total_size")= num 356
[08:28:05.257]  - attr(*, "already-done")= logi TRUE
[08:28:05.260] - copied ‘data’ to environment
[08:28:05.260] assign_globals() ... done
[08:28:05.261] plan(): Setting new future strategy stack:
[08:28:05.261] List of future strategies:
[08:28:05.261] 1. sequential:
[08:28:05.261]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.261]    - tweaked: FALSE
[08:28:05.261]    - call: plan(list(sequential, strategy))
[08:28:05.261] plan(): nbrOfWorkers() = 1
[08:28:05.293] plan(): Setting new future strategy stack:
[08:28:05.293] List of future strategies:
[08:28:05.293] 1. sequential:
[08:28:05.293]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.293]    - tweaked: FALSE
[08:28:05.293]    - call: plan(list(sequential, strategy))
[08:28:05.293] 2. sequential:
[08:28:05.293]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.293]    - tweaked: FALSE
[08:28:05.293]    - call: plan(list(sequential, strategy))
[08:28:05.294] plan(): nbrOfWorkers() = 1
[08:28:05.294] SequentialFuture started (and completed)
[08:28:05.294] signalConditions() ...
[08:28:05.295]  - include = ‘immediateCondition’
[08:28:05.295]  - exclude = 
[08:28:05.295]  - resignal = FALSE
[08:28:05.295]  - Number of conditions: 53
[08:28:05.295] signalConditions() ... done
[08:28:05.295] - Launch lazy future ... done
[08:28:05.295] run() for ‘SequentialFuture’ ... done
[08:28:05.295] signalConditions() ...
[08:28:05.295]  - include = ‘immediateCondition’
[08:28:05.295]  - exclude = 
[08:28:05.295]  - resignal = FALSE
[08:28:05.296]  - Number of conditions: 53
[08:28:05.296] signalConditions() ... done
[08:28:05.296] Future state: ‘finished’
[08:28:05.296] signalConditions() ...
[08:28:05.296]  - include = ‘condition’
[08:28:05.296]  - exclude = ‘immediateCondition’
[08:28:05.296]  - resignal = TRUE
[08:28:05.296]  - Number of conditions: 53
[08:28:05.296]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.262] getGlobalsAndPackages() ...
[08:28:05.296]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.297]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.276] Searching for globals...
[08:28:05.297]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.277] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[08:28:05.297]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.277] Searching for globals ... DONE
[08:28:05.297]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.277] Resolving globals: FALSE
[08:28:05.297]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.280] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:05.297]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.280] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:05.297]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.280] - globals: [1] ‘data’
[08:28:05.297]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.280] 
[08:28:05.298]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.281] getGlobalsAndPackages() ... DONE
[08:28:05.298]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.281] run() for ‘Future’ ...
[08:28:05.298]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.281] - state: ‘created’
[08:28:05.298]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.281] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:05.298]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.281] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:05.298]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.282] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:05.298]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.282]   - Field: ‘label’
[08:28:05.298]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.282]   - Field: ‘local’
[08:28:05.299]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.282]   - Field: ‘owner’
[08:28:05.299]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.282]   - Field: ‘envir’
[08:28:05.299]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.282]   - Field: ‘packages’
[08:28:05.299]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.282]   - Field: ‘gc’
[08:28:05.299]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.282]   - Field: ‘conditions’
[08:28:05.299]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.282]   - Field: ‘expr’
[08:28:05.299]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.283]   - Field: ‘uuid’
[08:28:05.300]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.283]   - Field: ‘seed’
[08:28:05.300]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.283]   - Field: ‘version’
[08:28:05.300]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.283]   - Field: ‘result’
[08:28:05.300]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.283]   - Field: ‘asynchronous’
[08:28:05.300]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.283]   - Field: ‘calls’
[08:28:05.300]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.283]   - Field: ‘globals’
[08:28:05.300]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.283]   - Field: ‘stdout’
[08:28:05.300]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.283]   - Field: ‘earlySignal’
[08:28:05.301]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.284]   - Field: ‘lazy’
[08:28:05.301]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.284]   - Field: ‘state’
[08:28:05.301]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.284] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:05.301]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.284] - Launch lazy future ...
[08:28:05.301]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.284] Packages needed by the future expression (n = 0): <none>
[08:28:05.301]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.284] Packages needed by future strategies (n = 0): <none>
[08:28:05.301]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.285] {
[08:28:05.285]     {
[08:28:05.285]         {
[08:28:05.285]             ...future.startTime <- base::Sys.time()
[08:28:05.285]             {
[08:28:05.285]                 {
[08:28:05.285]                   {
[08:28:05.285]                     base::local({
[08:28:05.285]                       has_future <- base::requireNamespace("future", 
[08:28:05.285]                         quietly = TRUE)
[08:28:05.285]                       if (has_future) {
[08:28:05.285]                         ns <- base::getNamespace("future")
[08:28:05.285]                         version <- ns[[".package"]][["version"]]
[08:28:05.285]                         if (is.null(version)) 
[08:28:05.285]                           version <- utils::packageVersion("future")
[08:28:05.285]                       }
[08:28:05.285]                       else {
[08:28:05.285]                         version <- NULL
[08:28:05.285]                       }
[08:28:05.285]                       if (!has_future || version < "1.8.0") {
[08:28:05.285]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.285]                           "", base::R.version$version.string), 
[08:28:05.285]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:05.285]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.285]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.285]                             "release", "version")], collapse = " "), 
[08:28:05.285]                           hostname = base::Sys.info()[["nodename"]])
[08:28:05.285]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.285]                           info)
[08:28:05.285]                         info <- base::paste(info, collapse = "; ")
[08:28:05.285]                         if (!has_future) {
[08:28:05.285]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.285]                             info)
[08:28:05.285]                         }
[08:28:05.285]                         else {
[08:28:05.285]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.285]                             info, version)
[08:28:05.285]                         }
[08:28:05.285]                         base::stop(msg)
[08:28:05.285]                       }
[08:28:05.285]                     })
[08:28:05.285]                   }
[08:28:05.285]                   ...future.strategy.old <- future::plan("list")
[08:28:05.285]                   options(future.plan = NULL)
[08:28:05.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:05.285]                 }
[08:28:05.285]                 ...future.workdir <- getwd()
[08:28:05.285]             }
[08:28:05.285]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.285]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.285]         }
[08:28:05.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:05.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.285]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:05.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.285]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.285]             base::names(...future.oldOptions))
[08:28:05.285]     }
[08:28:05.285]     if (FALSE) {
[08:28:05.285]     }
[08:28:05.285]     else {
[08:28:05.285]         if (TRUE) {
[08:28:05.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.285]                 open = "w")
[08:28:05.285]         }
[08:28:05.285]         else {
[08:28:05.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.285]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.285]         }
[08:28:05.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.285]             base::sink(type = "output", split = FALSE)
[08:28:05.285]             base::close(...future.stdout)
[08:28:05.285]         }, add = TRUE)
[08:28:05.285]     }
[08:28:05.285]     ...future.frame <- base::sys.nframe()
[08:28:05.285]     ...future.conditions <- base::list()
[08:28:05.285]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.285]     if (FALSE) {
[08:28:05.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.285]     }
[08:28:05.285]     ...future.result <- base::tryCatch({
[08:28:05.285]         base::withCallingHandlers({
[08:28:05.285]             ...future.value <- base::withVisible(base::local(subset(data, 
[08:28:05.285]                 x < 3)$y))
[08:28:05.285]             future::FutureResult(value = ...future.value$value, 
[08:28:05.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.285]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.285]                     ...future.globalenv.names))
[08:28:05.285]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.285]         }, condition = base::local({
[08:28:05.285]             c <- base::c
[08:28:05.285]             inherits <- base::inherits
[08:28:05.285]             invokeRestart <- base::invokeRestart
[08:28:05.285]             length <- base::length
[08:28:05.285]             list <- base::list
[08:28:05.285]             seq.int <- base::seq.int
[08:28:05.285]             signalCondition <- base::signalCondition
[08:28:05.285]             sys.calls <- base::sys.calls
[08:28:05.285]             `[[` <- base::`[[`
[08:28:05.285]             `+` <- base::`+`
[08:28:05.285]             `<<-` <- base::`<<-`
[08:28:05.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.285]                   3L)]
[08:28:05.285]             }
[08:28:05.285]             function(cond) {
[08:28:05.285]                 is_error <- inherits(cond, "error")
[08:28:05.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.285]                   NULL)
[08:28:05.285]                 if (is_error) {
[08:28:05.285]                   sessionInformation <- function() {
[08:28:05.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.285]                       search = base::search(), system = base::Sys.info())
[08:28:05.285]                   }
[08:28:05.285]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.285]                     cond$call), session = sessionInformation(), 
[08:28:05.285]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.285]                   signalCondition(cond)
[08:28:05.285]                 }
[08:28:05.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.285]                 "immediateCondition"))) {
[08:28:05.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.285]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.285]                   if (TRUE && !signal) {
[08:28:05.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.285]                     {
[08:28:05.285]                       inherits <- base::inherits
[08:28:05.285]                       invokeRestart <- base::invokeRestart
[08:28:05.285]                       is.null <- base::is.null
[08:28:05.285]                       muffled <- FALSE
[08:28:05.285]                       if (inherits(cond, "message")) {
[08:28:05.285]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.285]                         if (muffled) 
[08:28:05.285]                           invokeRestart("muffleMessage")
[08:28:05.285]                       }
[08:28:05.285]                       else if (inherits(cond, "warning")) {
[08:28:05.285]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.285]                         if (muffled) 
[08:28:05.285]                           invokeRestart("muffleWarning")
[08:28:05.285]                       }
[08:28:05.285]                       else if (inherits(cond, "condition")) {
[08:28:05.285]                         if (!is.null(pattern)) {
[08:28:05.285]                           computeRestarts <- base::computeRestarts
[08:28:05.285]                           grepl <- base::grepl
[08:28:05.285]                           restarts <- computeRestarts(cond)
[08:28:05.285]                           for (restart in restarts) {
[08:28:05.285]                             name <- restart$name
[08:28:05.285]                             if (is.null(name)) 
[08:28:05.285]                               next
[08:28:05.285]                             if (!grepl(pattern, name)) 
[08:28:05.285]                               next
[08:28:05.285]                             invokeRestart(restart)
[08:28:05.285]                             muffled <- TRUE
[08:28:05.285]                             break
[08:28:05.285]                           }
[08:28:05.285]                         }
[08:28:05.285]                       }
[08:28:05.285]                       invisible(muffled)
[08:28:05.285]                     }
[08:28:05.285]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.285]                   }
[08:28:05.285]                 }
[08:28:05.285]                 else {
[08:28:05.285]                   if (TRUE) {
[08:28:05.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.285]                     {
[08:28:05.285]                       inherits <- base::inherits
[08:28:05.285]                       invokeRestart <- base::invokeRestart
[08:28:05.285]                       is.null <- base::is.null
[08:28:05.285]                       muffled <- FALSE
[08:28:05.285]                       if (inherits(cond, "message")) {
[08:28:05.285]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.285]                         if (muffled) 
[08:28:05.285]                           invokeRestart("muffleMessage")
[08:28:05.285]                       }
[08:28:05.285]                       else if (inherits(cond, "warning")) {
[08:28:05.285]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.285]                         if (muffled) 
[08:28:05.285]                           invokeRestart("muffleWarning")
[08:28:05.285]                       }
[08:28:05.285]                       else if (inherits(cond, "condition")) {
[08:28:05.285]                         if (!is.null(pattern)) {
[08:28:05.285]                           computeRestarts <- base::computeRestarts
[08:28:05.285]                           grepl <- base::grepl
[08:28:05.285]                           restarts <- computeRestarts(cond)
[08:28:05.285]                           for (restart in restarts) {
[08:28:05.285]                             name <- restart$name
[08:28:05.285]                             if (is.null(name)) 
[08:28:05.285]                               next
[08:28:05.285]                             if (!grepl(pattern, name)) 
[08:28:05.285]                               next
[08:28:05.285]                             invokeRestart(restart)
[08:28:05.285]                             muffled <- TRUE
[08:28:05.285]                             break
[08:28:05.285]                           }
[08:28:05.285]                         }
[08:28:05.285]                       }
[08:28:05.285]                       invisible(muffled)
[08:28:05.285]                     }
[08:28:05.285]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.285]                   }
[08:28:05.285]                 }
[08:28:05.285]             }
[08:28:05.285]         }))
[08:28:05.285]     }, error = function(ex) {
[08:28:05.285]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.285]                 ...future.rng), started = ...future.startTime, 
[08:28:05.285]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.285]             version = "1.8"), class = "FutureResult")
[08:28:05.285]     }, finally = {
[08:28:05.285]         if (!identical(...future.workdir, getwd())) 
[08:28:05.285]             setwd(...future.workdir)
[08:28:05.285]         {
[08:28:05.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.285]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.285]             }
[08:28:05.285]             base::options(...future.oldOptions)
[08:28:05.285]             if (.Platform$OS.type == "windows") {
[08:28:05.285]                 old_names <- names(...future.oldEnvVars)
[08:28:05.285]                 envs <- base::Sys.getenv()
[08:28:05.285]                 names <- names(envs)
[08:28:05.285]                 common <- intersect(names, old_names)
[08:28:05.285]                 added <- setdiff(names, old_names)
[08:28:05.285]                 removed <- setdiff(old_names, names)
[08:28:05.285]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.285]                   envs[common]]
[08:28:05.285]                 NAMES <- toupper(changed)
[08:28:05.285]                 args <- list()
[08:28:05.285]                 for (kk in seq_along(NAMES)) {
[08:28:05.285]                   name <- changed[[kk]]
[08:28:05.285]                   NAME <- NAMES[[kk]]
[08:28:05.285]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.285]                     next
[08:28:05.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.285]                 }
[08:28:05.285]                 NAMES <- toupper(added)
[08:28:05.285]                 for (kk in seq_along(NAMES)) {
[08:28:05.285]                   name <- added[[kk]]
[08:28:05.285]                   NAME <- NAMES[[kk]]
[08:28:05.285]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.285]                     next
[08:28:05.285]                   args[[name]] <- ""
[08:28:05.285]                 }
[08:28:05.285]                 NAMES <- toupper(removed)
[08:28:05.285]                 for (kk in seq_along(NAMES)) {
[08:28:05.285]                   name <- removed[[kk]]
[08:28:05.285]                   NAME <- NAMES[[kk]]
[08:28:05.285]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.285]                     next
[08:28:05.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.285]                 }
[08:28:05.285]                 if (length(args) > 0) 
[08:28:05.285]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.285]             }
[08:28:05.285]             else {
[08:28:05.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.285]             }
[08:28:05.285]             {
[08:28:05.285]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.285]                   0L) {
[08:28:05.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.285]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.285]                   base::options(opts)
[08:28:05.285]                 }
[08:28:05.285]                 {
[08:28:05.285]                   {
[08:28:05.285]                     NULL
[08:28:05.285]                     RNGkind("Mersenne-Twister")
[08:28:05.285]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:05.285]                       inherits = FALSE)
[08:28:05.285]                   }
[08:28:05.285]                   options(future.plan = NULL)
[08:28:05.285]                   if (is.na(NA_character_)) 
[08:28:05.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.285]                     .init = FALSE)
[08:28:05.285]                 }
[08:28:05.285]             }
[08:28:05.285]         }
[08:28:05.285]     })
[08:28:05.285]     if (TRUE) {
[08:28:05.285]         base::sink(type = "output", split = FALSE)
[08:28:05.285]         if (TRUE) {
[08:28:05.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.285]         }
[08:28:05.285]         else {
[08:28:05.285]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.285]         }
[08:28:05.285]         base::close(...future.stdout)
[08:28:05.285]         ...future.stdout <- NULL
[08:28:05.285]     }
[08:28:05.285]     ...future.result$conditions <- ...future.conditions
[08:28:05.285]     ...future.result$finished <- base::Sys.time()
[08:28:05.285]     ...future.result
[08:28:05.285] }
[08:28:05.302]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.286] assign_globals() ...
[08:28:05.302]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.286] List of 1
[08:28:05.286]  $ data:'data.frame':	5 obs. of  2 variables:
[08:28:05.286]   ..$ x: int [1:5] 1 2 3 4 5
[08:28:05.286]   ..$ y: int [1:5] 1 2 3 4 5
[08:28:05.286]  - attr(*, "where")=List of 1
[08:28:05.286]   ..$ data:<environment: R_EmptyEnv> 
[08:28:05.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:05.286]  - attr(*, "resolved")= logi FALSE
[08:28:05.286]  - attr(*, "total_size")= num 356
[08:28:05.286]  - attr(*, "already-done")= logi TRUE
[08:28:05.302]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.290] - copied ‘data’ to environment
[08:28:05.302]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.290] assign_globals() ... done
[08:28:05.302]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.290] plan(): Setting new future strategy stack:
[08:28:05.302]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.290] List of future strategies:
[08:28:05.290] 1. sequential:
[08:28:05.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.290]    - tweaked: FALSE
[08:28:05.290]    - call: NULL
[08:28:05.302]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.291] plan(): nbrOfWorkers() = 1
[08:28:05.302]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.292] plan(): Setting new future strategy stack:
[08:28:05.303]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.292] List of future strategies:
[08:28:05.292] 1. sequential:
[08:28:05.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.292]    - tweaked: FALSE
[08:28:05.292]    - call: plan(list(sequential, strategy))
[08:28:05.303]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.292] plan(): nbrOfWorkers() = 1
[08:28:05.303]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.293] SequentialFuture started (and completed)
[08:28:05.303]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.293] - Launch lazy future ... done
[08:28:05.303]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.293] run() for ‘SequentialFuture’ ... done
[08:28:05.303] signalConditions() ... done
[08:28:05.304] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.304] Searching for globals...
[08:28:05.305] - globals found: [3] ‘{’, ‘plan’, ‘sequential’
[08:28:05.305] Searching for globals ... DONE
[08:28:05.305] Resolving globals: FALSE
[08:28:05.305] 
[08:28:05.305] - packages: [1] ‘future’
[08:28:05.305] getGlobalsAndPackages() ... DONE
[08:28:05.306] run() for ‘Future’ ...
[08:28:05.306] - state: ‘created’
[08:28:05.306] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:05.308] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:05.308] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:05.308]   - Field: ‘label’
[08:28:05.308]   - Field: ‘local’
[08:28:05.308]   - Field: ‘owner’
[08:28:05.309]   - Field: ‘envir’
[08:28:05.309]   - Field: ‘packages’
[08:28:05.309]   - Field: ‘gc’
[08:28:05.309]   - Field: ‘conditions’
[08:28:05.309]   - Field: ‘expr’
[08:28:05.309]   - Field: ‘uuid’
[08:28:05.309]   - Field: ‘seed’
[08:28:05.309]   - Field: ‘version’
[08:28:05.309]   - Field: ‘result’
[08:28:05.309]   - Field: ‘asynchronous’
[08:28:05.309]   - Field: ‘calls’
[08:28:05.310]   - Field: ‘globals’
[08:28:05.310]   - Field: ‘stdout’
[08:28:05.310]   - Field: ‘earlySignal’
[08:28:05.310]   - Field: ‘lazy’
[08:28:05.310]   - Field: ‘state’
[08:28:05.310] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:05.310] - Launch lazy future ...
[08:28:05.310] Packages needed by the future expression (n = 1): ‘future’
[08:28:05.310] Packages needed by future strategies (n = 1): ‘future’
[08:28:05.311] {
[08:28:05.311]     {
[08:28:05.311]         {
[08:28:05.311]             ...future.startTime <- base::Sys.time()
[08:28:05.311]             {
[08:28:05.311]                 {
[08:28:05.311]                   {
[08:28:05.311]                     {
[08:28:05.311]                       base::local({
[08:28:05.311]                         has_future <- base::requireNamespace("future", 
[08:28:05.311]                           quietly = TRUE)
[08:28:05.311]                         if (has_future) {
[08:28:05.311]                           ns <- base::getNamespace("future")
[08:28:05.311]                           version <- ns[[".package"]][["version"]]
[08:28:05.311]                           if (is.null(version)) 
[08:28:05.311]                             version <- utils::packageVersion("future")
[08:28:05.311]                         }
[08:28:05.311]                         else {
[08:28:05.311]                           version <- NULL
[08:28:05.311]                         }
[08:28:05.311]                         if (!has_future || version < "1.8.0") {
[08:28:05.311]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.311]                             "", base::R.version$version.string), 
[08:28:05.311]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:05.311]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.311]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.311]                               "release", "version")], collapse = " "), 
[08:28:05.311]                             hostname = base::Sys.info()[["nodename"]])
[08:28:05.311]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.311]                             info)
[08:28:05.311]                           info <- base::paste(info, collapse = "; ")
[08:28:05.311]                           if (!has_future) {
[08:28:05.311]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.311]                               info)
[08:28:05.311]                           }
[08:28:05.311]                           else {
[08:28:05.311]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.311]                               info, version)
[08:28:05.311]                           }
[08:28:05.311]                           base::stop(msg)
[08:28:05.311]                         }
[08:28:05.311]                       })
[08:28:05.311]                     }
[08:28:05.311]                     base::local({
[08:28:05.311]                       for (pkg in "future") {
[08:28:05.311]                         base::loadNamespace(pkg)
[08:28:05.311]                         base::library(pkg, character.only = TRUE)
[08:28:05.311]                       }
[08:28:05.311]                     })
[08:28:05.311]                   }
[08:28:05.311]                   ...future.strategy.old <- future::plan("list")
[08:28:05.311]                   options(future.plan = NULL)
[08:28:05.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.311]                   future::plan(list(function (..., envir = parent.frame()) 
[08:28:05.311]                   {
[08:28:05.311]                     future <- SequentialFuture(..., envir = envir)
[08:28:05.311]                     if (!future$lazy) 
[08:28:05.311]                       future <- run(future)
[08:28:05.311]                     invisible(future)
[08:28:05.311]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:05.311]                 }
[08:28:05.311]                 ...future.workdir <- getwd()
[08:28:05.311]             }
[08:28:05.311]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.311]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.311]         }
[08:28:05.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:05.311]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.311]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:05.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.311]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.311]             base::names(...future.oldOptions))
[08:28:05.311]     }
[08:28:05.311]     if (FALSE) {
[08:28:05.311]     }
[08:28:05.311]     else {
[08:28:05.311]         if (TRUE) {
[08:28:05.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.311]                 open = "w")
[08:28:05.311]         }
[08:28:05.311]         else {
[08:28:05.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.311]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.311]         }
[08:28:05.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.311]             base::sink(type = "output", split = FALSE)
[08:28:05.311]             base::close(...future.stdout)
[08:28:05.311]         }, add = TRUE)
[08:28:05.311]     }
[08:28:05.311]     ...future.frame <- base::sys.nframe()
[08:28:05.311]     ...future.conditions <- base::list()
[08:28:05.311]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.311]     if (FALSE) {
[08:28:05.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.311]     }
[08:28:05.311]     ...future.result <- base::tryCatch({
[08:28:05.311]         base::withCallingHandlers({
[08:28:05.311]             ...future.value <- base::withVisible(base::local({
[08:28:05.311]                 plan(sequential)
[08:28:05.311]             }))
[08:28:05.311]             future::FutureResult(value = ...future.value$value, 
[08:28:05.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.311]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.311]                     ...future.globalenv.names))
[08:28:05.311]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.311]         }, condition = base::local({
[08:28:05.311]             c <- base::c
[08:28:05.311]             inherits <- base::inherits
[08:28:05.311]             invokeRestart <- base::invokeRestart
[08:28:05.311]             length <- base::length
[08:28:05.311]             list <- base::list
[08:28:05.311]             seq.int <- base::seq.int
[08:28:05.311]             signalCondition <- base::signalCondition
[08:28:05.311]             sys.calls <- base::sys.calls
[08:28:05.311]             `[[` <- base::`[[`
[08:28:05.311]             `+` <- base::`+`
[08:28:05.311]             `<<-` <- base::`<<-`
[08:28:05.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.311]                   3L)]
[08:28:05.311]             }
[08:28:05.311]             function(cond) {
[08:28:05.311]                 is_error <- inherits(cond, "error")
[08:28:05.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.311]                   NULL)
[08:28:05.311]                 if (is_error) {
[08:28:05.311]                   sessionInformation <- function() {
[08:28:05.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.311]                       search = base::search(), system = base::Sys.info())
[08:28:05.311]                   }
[08:28:05.311]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.311]                     cond$call), session = sessionInformation(), 
[08:28:05.311]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.311]                   signalCondition(cond)
[08:28:05.311]                 }
[08:28:05.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.311]                 "immediateCondition"))) {
[08:28:05.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.311]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.311]                   if (TRUE && !signal) {
[08:28:05.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.311]                     {
[08:28:05.311]                       inherits <- base::inherits
[08:28:05.311]                       invokeRestart <- base::invokeRestart
[08:28:05.311]                       is.null <- base::is.null
[08:28:05.311]                       muffled <- FALSE
[08:28:05.311]                       if (inherits(cond, "message")) {
[08:28:05.311]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.311]                         if (muffled) 
[08:28:05.311]                           invokeRestart("muffleMessage")
[08:28:05.311]                       }
[08:28:05.311]                       else if (inherits(cond, "warning")) {
[08:28:05.311]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.311]                         if (muffled) 
[08:28:05.311]                           invokeRestart("muffleWarning")
[08:28:05.311]                       }
[08:28:05.311]                       else if (inherits(cond, "condition")) {
[08:28:05.311]                         if (!is.null(pattern)) {
[08:28:05.311]                           computeRestarts <- base::computeRestarts
[08:28:05.311]                           grepl <- base::grepl
[08:28:05.311]                           restarts <- computeRestarts(cond)
[08:28:05.311]                           for (restart in restarts) {
[08:28:05.311]                             name <- restart$name
[08:28:05.311]                             if (is.null(name)) 
[08:28:05.311]                               next
[08:28:05.311]                             if (!grepl(pattern, name)) 
[08:28:05.311]                               next
[08:28:05.311]                             invokeRestart(restart)
[08:28:05.311]                             muffled <- TRUE
[08:28:05.311]                             break
[08:28:05.311]                           }
[08:28:05.311]                         }
[08:28:05.311]                       }
[08:28:05.311]                       invisible(muffled)
[08:28:05.311]                     }
[08:28:05.311]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.311]                   }
[08:28:05.311]                 }
[08:28:05.311]                 else {
[08:28:05.311]                   if (TRUE) {
[08:28:05.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.311]                     {
[08:28:05.311]                       inherits <- base::inherits
[08:28:05.311]                       invokeRestart <- base::invokeRestart
[08:28:05.311]                       is.null <- base::is.null
[08:28:05.311]                       muffled <- FALSE
[08:28:05.311]                       if (inherits(cond, "message")) {
[08:28:05.311]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.311]                         if (muffled) 
[08:28:05.311]                           invokeRestart("muffleMessage")
[08:28:05.311]                       }
[08:28:05.311]                       else if (inherits(cond, "warning")) {
[08:28:05.311]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.311]                         if (muffled) 
[08:28:05.311]                           invokeRestart("muffleWarning")
[08:28:05.311]                       }
[08:28:05.311]                       else if (inherits(cond, "condition")) {
[08:28:05.311]                         if (!is.null(pattern)) {
[08:28:05.311]                           computeRestarts <- base::computeRestarts
[08:28:05.311]                           grepl <- base::grepl
[08:28:05.311]                           restarts <- computeRestarts(cond)
[08:28:05.311]                           for (restart in restarts) {
[08:28:05.311]                             name <- restart$name
[08:28:05.311]                             if (is.null(name)) 
[08:28:05.311]                               next
[08:28:05.311]                             if (!grepl(pattern, name)) 
[08:28:05.311]                               next
[08:28:05.311]                             invokeRestart(restart)
[08:28:05.311]                             muffled <- TRUE
[08:28:05.311]                             break
[08:28:05.311]                           }
[08:28:05.311]                         }
[08:28:05.311]                       }
[08:28:05.311]                       invisible(muffled)
[08:28:05.311]                     }
[08:28:05.311]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.311]                   }
[08:28:05.311]                 }
[08:28:05.311]             }
[08:28:05.311]         }))
[08:28:05.311]     }, error = function(ex) {
[08:28:05.311]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.311]                 ...future.rng), started = ...future.startTime, 
[08:28:05.311]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.311]             version = "1.8"), class = "FutureResult")
[08:28:05.311]     }, finally = {
[08:28:05.311]         if (!identical(...future.workdir, getwd())) 
[08:28:05.311]             setwd(...future.workdir)
[08:28:05.311]         {
[08:28:05.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.311]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.311]             }
[08:28:05.311]             base::options(...future.oldOptions)
[08:28:05.311]             if (.Platform$OS.type == "windows") {
[08:28:05.311]                 old_names <- names(...future.oldEnvVars)
[08:28:05.311]                 envs <- base::Sys.getenv()
[08:28:05.311]                 names <- names(envs)
[08:28:05.311]                 common <- intersect(names, old_names)
[08:28:05.311]                 added <- setdiff(names, old_names)
[08:28:05.311]                 removed <- setdiff(old_names, names)
[08:28:05.311]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.311]                   envs[common]]
[08:28:05.311]                 NAMES <- toupper(changed)
[08:28:05.311]                 args <- list()
[08:28:05.311]                 for (kk in seq_along(NAMES)) {
[08:28:05.311]                   name <- changed[[kk]]
[08:28:05.311]                   NAME <- NAMES[[kk]]
[08:28:05.311]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.311]                     next
[08:28:05.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.311]                 }
[08:28:05.311]                 NAMES <- toupper(added)
[08:28:05.311]                 for (kk in seq_along(NAMES)) {
[08:28:05.311]                   name <- added[[kk]]
[08:28:05.311]                   NAME <- NAMES[[kk]]
[08:28:05.311]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.311]                     next
[08:28:05.311]                   args[[name]] <- ""
[08:28:05.311]                 }
[08:28:05.311]                 NAMES <- toupper(removed)
[08:28:05.311]                 for (kk in seq_along(NAMES)) {
[08:28:05.311]                   name <- removed[[kk]]
[08:28:05.311]                   NAME <- NAMES[[kk]]
[08:28:05.311]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.311]                     next
[08:28:05.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.311]                 }
[08:28:05.311]                 if (length(args) > 0) 
[08:28:05.311]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.311]             }
[08:28:05.311]             else {
[08:28:05.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.311]             }
[08:28:05.311]             {
[08:28:05.311]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.311]                   0L) {
[08:28:05.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.311]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.311]                   base::options(opts)
[08:28:05.311]                 }
[08:28:05.311]                 {
[08:28:05.311]                   {
[08:28:05.311]                     NULL
[08:28:05.311]                     RNGkind("Mersenne-Twister")
[08:28:05.311]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:05.311]                       inherits = FALSE)
[08:28:05.311]                   }
[08:28:05.311]                   options(future.plan = NULL)
[08:28:05.311]                   if (is.na(NA_character_)) 
[08:28:05.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.311]                     .init = FALSE)
[08:28:05.311]                 }
[08:28:05.311]             }
[08:28:05.311]         }
[08:28:05.311]     })
[08:28:05.311]     if (TRUE) {
[08:28:05.311]         base::sink(type = "output", split = FALSE)
[08:28:05.311]         if (TRUE) {
[08:28:05.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.311]         }
[08:28:05.311]         else {
[08:28:05.311]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.311]         }
[08:28:05.311]         base::close(...future.stdout)
[08:28:05.311]         ...future.stdout <- NULL
[08:28:05.311]     }
[08:28:05.311]     ...future.result$conditions <- ...future.conditions
[08:28:05.311]     ...future.result$finished <- base::Sys.time()
[08:28:05.311]     ...future.result
[08:28:05.311] }
[08:28:05.313] plan(): Setting new future strategy stack:
[08:28:05.313] List of future strategies:
[08:28:05.313] 1. sequential:
[08:28:05.313]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.313]    - tweaked: FALSE
[08:28:05.313]    - call: plan(list(sequential, strategy))
[08:28:05.314] plan(): nbrOfWorkers() = 1
[08:28:05.329] plan(): Setting new future strategy stack:
[08:28:05.329] List of future strategies:
[08:28:05.329] 1. sequential:
[08:28:05.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.329]    - tweaked: FALSE
[08:28:05.329]    - call: plan(list(sequential, strategy))
[08:28:05.329] 2. sequential:
[08:28:05.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.329]    - tweaked: FALSE
[08:28:05.329]    - call: plan(list(sequential, strategy))
[08:28:05.329] plan(): nbrOfWorkers() = 1
[08:28:05.330] SequentialFuture started (and completed)
[08:28:05.330] signalConditions() ...
[08:28:05.330]  - include = ‘immediateCondition’
[08:28:05.330]  - exclude = 
[08:28:05.330]  - resignal = FALSE
[08:28:05.330]  - Number of conditions: 3
[08:28:05.332] signalConditions() ... done
[08:28:05.332] - Launch lazy future ... done
[08:28:05.332] run() for ‘SequentialFuture’ ... done
[08:28:05.332] signalConditions() ...
[08:28:05.332]  - include = ‘immediateCondition’
[08:28:05.332]  - exclude = 
[08:28:05.332]  - resignal = FALSE
[08:28:05.333]  - Number of conditions: 3
[08:28:05.333] signalConditions() ... done
[08:28:05.333] Future state: ‘finished’
[08:28:05.333] signalConditions() ...
[08:28:05.333]  - include = ‘condition’
[08:28:05.333]  - exclude = ‘immediateCondition’
[08:28:05.333]  - resignal = TRUE
[08:28:05.333]  - Number of conditions: 3
[08:28:05.333]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.314] plan(): Setting new future strategy stack:
[08:28:05.333]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.314] List of future strategies:
[08:28:05.314] 1. sequential:
[08:28:05.314]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.314]    - tweaked: FALSE
[08:28:05.314]    - call: plan(sequential)
[08:28:05.334]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.328] plan(): nbrOfWorkers() = 1
[08:28:05.334] signalConditions() ... done
List of future strategies:
1. sequential:
   - args: function (..., envir = parent.frame(), workers = "<NULL>")
   - tweaked: FALSE
   - call: plan(list(sequential, strategy))
- Strategy: sequential ... DONE
- Strategy: multicore ...
[08:28:05.334] plan(): Setting new future strategy stack:
[08:28:05.335] List of future strategies:
[08:28:05.335] 1. multicore:
[08:28:05.335]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:05.335]    - tweaked: FALSE
[08:28:05.335]    - call: plan(strategy)
[08:28:05.336] plan(): nbrOfWorkers() = 2
[08:28:05.337] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:05.337] Searching for globals...
[08:28:05.337] - globals found: [1] ‘getOption’
[08:28:05.337] Searching for globals ... DONE
[08:28:05.338] Resolving globals: FALSE
[08:28:05.338] 
[08:28:05.338] 
[08:28:05.338] getGlobalsAndPackages() ... DONE
[08:28:05.338] run() for ‘Future’ ...
[08:28:05.338] - state: ‘created’
[08:28:05.338] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:05.340] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:05.340] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:05.340]   - Field: ‘label’
[08:28:05.340]   - Field: ‘local’
[08:28:05.341]   - Field: ‘owner’
[08:28:05.341]   - Field: ‘envir’
[08:28:05.341]   - Field: ‘workers’
[08:28:05.341]   - Field: ‘packages’
[08:28:05.341]   - Field: ‘gc’
[08:28:05.341]   - Field: ‘job’
[08:28:05.341]   - Field: ‘conditions’
[08:28:05.341]   - Field: ‘expr’
[08:28:05.341]   - Field: ‘uuid’
[08:28:05.341]   - Field: ‘seed’
[08:28:05.341]   - Field: ‘version’
[08:28:05.342]   - Field: ‘result’
[08:28:05.342]   - Field: ‘asynchronous’
[08:28:05.342]   - Field: ‘calls’
[08:28:05.342]   - Field: ‘globals’
[08:28:05.342]   - Field: ‘stdout’
[08:28:05.342]   - Field: ‘earlySignal’
[08:28:05.342]   - Field: ‘lazy’
[08:28:05.342]   - Field: ‘state’
[08:28:05.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:05.342] - Launch lazy future ...
[08:28:05.343] Packages needed by the future expression (n = 0): <none>
[08:28:05.343] Packages needed by future strategies (n = 0): <none>
[08:28:05.344] {
[08:28:05.344]     {
[08:28:05.344]         {
[08:28:05.344]             ...future.startTime <- base::Sys.time()
[08:28:05.344]             {
[08:28:05.344]                 {
[08:28:05.344]                   {
[08:28:05.344]                     {
[08:28:05.344]                       base::local({
[08:28:05.344]                         has_future <- base::requireNamespace("future", 
[08:28:05.344]                           quietly = TRUE)
[08:28:05.344]                         if (has_future) {
[08:28:05.344]                           ns <- base::getNamespace("future")
[08:28:05.344]                           version <- ns[[".package"]][["version"]]
[08:28:05.344]                           if (is.null(version)) 
[08:28:05.344]                             version <- utils::packageVersion("future")
[08:28:05.344]                         }
[08:28:05.344]                         else {
[08:28:05.344]                           version <- NULL
[08:28:05.344]                         }
[08:28:05.344]                         if (!has_future || version < "1.8.0") {
[08:28:05.344]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.344]                             "", base::R.version$version.string), 
[08:28:05.344]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:05.344]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.344]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.344]                               "release", "version")], collapse = " "), 
[08:28:05.344]                             hostname = base::Sys.info()[["nodename"]])
[08:28:05.344]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.344]                             info)
[08:28:05.344]                           info <- base::paste(info, collapse = "; ")
[08:28:05.344]                           if (!has_future) {
[08:28:05.344]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.344]                               info)
[08:28:05.344]                           }
[08:28:05.344]                           else {
[08:28:05.344]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.344]                               info, version)
[08:28:05.344]                           }
[08:28:05.344]                           base::stop(msg)
[08:28:05.344]                         }
[08:28:05.344]                       })
[08:28:05.344]                     }
[08:28:05.344]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:05.344]                     base::options(mc.cores = 1L)
[08:28:05.344]                   }
[08:28:05.344]                   ...future.strategy.old <- future::plan("list")
[08:28:05.344]                   options(future.plan = NULL)
[08:28:05.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:05.344]                 }
[08:28:05.344]                 ...future.workdir <- getwd()
[08:28:05.344]             }
[08:28:05.344]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.344]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.344]         }
[08:28:05.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:05.344]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.344]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:05.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.344]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.344]             base::names(...future.oldOptions))
[08:28:05.344]     }
[08:28:05.344]     if (FALSE) {
[08:28:05.344]     }
[08:28:05.344]     else {
[08:28:05.344]         if (TRUE) {
[08:28:05.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.344]                 open = "w")
[08:28:05.344]         }
[08:28:05.344]         else {
[08:28:05.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.344]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.344]         }
[08:28:05.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.344]             base::sink(type = "output", split = FALSE)
[08:28:05.344]             base::close(...future.stdout)
[08:28:05.344]         }, add = TRUE)
[08:28:05.344]     }
[08:28:05.344]     ...future.frame <- base::sys.nframe()
[08:28:05.344]     ...future.conditions <- base::list()
[08:28:05.344]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.344]     if (FALSE) {
[08:28:05.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.344]     }
[08:28:05.344]     ...future.result <- base::tryCatch({
[08:28:05.344]         base::withCallingHandlers({
[08:28:05.344]             ...future.value <- base::withVisible(base::local({
[08:28:05.344]                 withCallingHandlers({
[08:28:05.344]                   getOption("future.globals.onMissing")
[08:28:05.344]                 }, immediateCondition = function(cond) {
[08:28:05.344]                   save_rds <- function (object, pathname, ...) 
[08:28:05.344]                   {
[08:28:05.344]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:05.344]                     if (file_test("-f", pathname_tmp)) {
[08:28:05.344]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.344]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:05.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.344]                         fi_tmp[["mtime"]])
[08:28:05.344]                     }
[08:28:05.344]                     tryCatch({
[08:28:05.344]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:05.344]                     }, error = function(ex) {
[08:28:05.344]                       msg <- conditionMessage(ex)
[08:28:05.344]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.344]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:05.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.344]                         fi_tmp[["mtime"]], msg)
[08:28:05.344]                       ex$message <- msg
[08:28:05.344]                       stop(ex)
[08:28:05.344]                     })
[08:28:05.344]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:05.344]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:05.344]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:05.344]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.344]                       fi <- file.info(pathname)
[08:28:05.344]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:05.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.344]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:05.344]                         fi[["size"]], fi[["mtime"]])
[08:28:05.344]                       stop(msg)
[08:28:05.344]                     }
[08:28:05.344]                     invisible(pathname)
[08:28:05.344]                   }
[08:28:05.344]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:05.344]                     rootPath = tempdir()) 
[08:28:05.344]                   {
[08:28:05.344]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:05.344]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:05.344]                       tmpdir = path, fileext = ".rds")
[08:28:05.344]                     save_rds(obj, file)
[08:28:05.344]                   }
[08:28:05.344]                   saveImmediateCondition(cond, path = "/tmp/RtmpifSr4D/.future/immediateConditions")
[08:28:05.344]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.344]                   {
[08:28:05.344]                     inherits <- base::inherits
[08:28:05.344]                     invokeRestart <- base::invokeRestart
[08:28:05.344]                     is.null <- base::is.null
[08:28:05.344]                     muffled <- FALSE
[08:28:05.344]                     if (inherits(cond, "message")) {
[08:28:05.344]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:05.344]                       if (muffled) 
[08:28:05.344]                         invokeRestart("muffleMessage")
[08:28:05.344]                     }
[08:28:05.344]                     else if (inherits(cond, "warning")) {
[08:28:05.344]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:05.344]                       if (muffled) 
[08:28:05.344]                         invokeRestart("muffleWarning")
[08:28:05.344]                     }
[08:28:05.344]                     else if (inherits(cond, "condition")) {
[08:28:05.344]                       if (!is.null(pattern)) {
[08:28:05.344]                         computeRestarts <- base::computeRestarts
[08:28:05.344]                         grepl <- base::grepl
[08:28:05.344]                         restarts <- computeRestarts(cond)
[08:28:05.344]                         for (restart in restarts) {
[08:28:05.344]                           name <- restart$name
[08:28:05.344]                           if (is.null(name)) 
[08:28:05.344]                             next
[08:28:05.344]                           if (!grepl(pattern, name)) 
[08:28:05.344]                             next
[08:28:05.344]                           invokeRestart(restart)
[08:28:05.344]                           muffled <- TRUE
[08:28:05.344]                           break
[08:28:05.344]                         }
[08:28:05.344]                       }
[08:28:05.344]                     }
[08:28:05.344]                     invisible(muffled)
[08:28:05.344]                   }
[08:28:05.344]                   muffleCondition(cond)
[08:28:05.344]                 })
[08:28:05.344]             }))
[08:28:05.344]             future::FutureResult(value = ...future.value$value, 
[08:28:05.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.344]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.344]                     ...future.globalenv.names))
[08:28:05.344]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.344]         }, condition = base::local({
[08:28:05.344]             c <- base::c
[08:28:05.344]             inherits <- base::inherits
[08:28:05.344]             invokeRestart <- base::invokeRestart
[08:28:05.344]             length <- base::length
[08:28:05.344]             list <- base::list
[08:28:05.344]             seq.int <- base::seq.int
[08:28:05.344]             signalCondition <- base::signalCondition
[08:28:05.344]             sys.calls <- base::sys.calls
[08:28:05.344]             `[[` <- base::`[[`
[08:28:05.344]             `+` <- base::`+`
[08:28:05.344]             `<<-` <- base::`<<-`
[08:28:05.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.344]                   3L)]
[08:28:05.344]             }
[08:28:05.344]             function(cond) {
[08:28:05.344]                 is_error <- inherits(cond, "error")
[08:28:05.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.344]                   NULL)
[08:28:05.344]                 if (is_error) {
[08:28:05.344]                   sessionInformation <- function() {
[08:28:05.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.344]                       search = base::search(), system = base::Sys.info())
[08:28:05.344]                   }
[08:28:05.344]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.344]                     cond$call), session = sessionInformation(), 
[08:28:05.344]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.344]                   signalCondition(cond)
[08:28:05.344]                 }
[08:28:05.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.344]                 "immediateCondition"))) {
[08:28:05.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.344]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.344]                   if (TRUE && !signal) {
[08:28:05.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.344]                     {
[08:28:05.344]                       inherits <- base::inherits
[08:28:05.344]                       invokeRestart <- base::invokeRestart
[08:28:05.344]                       is.null <- base::is.null
[08:28:05.344]                       muffled <- FALSE
[08:28:05.344]                       if (inherits(cond, "message")) {
[08:28:05.344]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.344]                         if (muffled) 
[08:28:05.344]                           invokeRestart("muffleMessage")
[08:28:05.344]                       }
[08:28:05.344]                       else if (inherits(cond, "warning")) {
[08:28:05.344]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.344]                         if (muffled) 
[08:28:05.344]                           invokeRestart("muffleWarning")
[08:28:05.344]                       }
[08:28:05.344]                       else if (inherits(cond, "condition")) {
[08:28:05.344]                         if (!is.null(pattern)) {
[08:28:05.344]                           computeRestarts <- base::computeRestarts
[08:28:05.344]                           grepl <- base::grepl
[08:28:05.344]                           restarts <- computeRestarts(cond)
[08:28:05.344]                           for (restart in restarts) {
[08:28:05.344]                             name <- restart$name
[08:28:05.344]                             if (is.null(name)) 
[08:28:05.344]                               next
[08:28:05.344]                             if (!grepl(pattern, name)) 
[08:28:05.344]                               next
[08:28:05.344]                             invokeRestart(restart)
[08:28:05.344]                             muffled <- TRUE
[08:28:05.344]                             break
[08:28:05.344]                           }
[08:28:05.344]                         }
[08:28:05.344]                       }
[08:28:05.344]                       invisible(muffled)
[08:28:05.344]                     }
[08:28:05.344]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.344]                   }
[08:28:05.344]                 }
[08:28:05.344]                 else {
[08:28:05.344]                   if (TRUE) {
[08:28:05.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.344]                     {
[08:28:05.344]                       inherits <- base::inherits
[08:28:05.344]                       invokeRestart <- base::invokeRestart
[08:28:05.344]                       is.null <- base::is.null
[08:28:05.344]                       muffled <- FALSE
[08:28:05.344]                       if (inherits(cond, "message")) {
[08:28:05.344]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.344]                         if (muffled) 
[08:28:05.344]                           invokeRestart("muffleMessage")
[08:28:05.344]                       }
[08:28:05.344]                       else if (inherits(cond, "warning")) {
[08:28:05.344]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.344]                         if (muffled) 
[08:28:05.344]                           invokeRestart("muffleWarning")
[08:28:05.344]                       }
[08:28:05.344]                       else if (inherits(cond, "condition")) {
[08:28:05.344]                         if (!is.null(pattern)) {
[08:28:05.344]                           computeRestarts <- base::computeRestarts
[08:28:05.344]                           grepl <- base::grepl
[08:28:05.344]                           restarts <- computeRestarts(cond)
[08:28:05.344]                           for (restart in restarts) {
[08:28:05.344]                             name <- restart$name
[08:28:05.344]                             if (is.null(name)) 
[08:28:05.344]                               next
[08:28:05.344]                             if (!grepl(pattern, name)) 
[08:28:05.344]                               next
[08:28:05.344]                             invokeRestart(restart)
[08:28:05.344]                             muffled <- TRUE
[08:28:05.344]                             break
[08:28:05.344]                           }
[08:28:05.344]                         }
[08:28:05.344]                       }
[08:28:05.344]                       invisible(muffled)
[08:28:05.344]                     }
[08:28:05.344]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.344]                   }
[08:28:05.344]                 }
[08:28:05.344]             }
[08:28:05.344]         }))
[08:28:05.344]     }, error = function(ex) {
[08:28:05.344]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.344]                 ...future.rng), started = ...future.startTime, 
[08:28:05.344]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.344]             version = "1.8"), class = "FutureResult")
[08:28:05.344]     }, finally = {
[08:28:05.344]         if (!identical(...future.workdir, getwd())) 
[08:28:05.344]             setwd(...future.workdir)
[08:28:05.344]         {
[08:28:05.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.344]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.344]             }
[08:28:05.344]             base::options(...future.oldOptions)
[08:28:05.344]             if (.Platform$OS.type == "windows") {
[08:28:05.344]                 old_names <- names(...future.oldEnvVars)
[08:28:05.344]                 envs <- base::Sys.getenv()
[08:28:05.344]                 names <- names(envs)
[08:28:05.344]                 common <- intersect(names, old_names)
[08:28:05.344]                 added <- setdiff(names, old_names)
[08:28:05.344]                 removed <- setdiff(old_names, names)
[08:28:05.344]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.344]                   envs[common]]
[08:28:05.344]                 NAMES <- toupper(changed)
[08:28:05.344]                 args <- list()
[08:28:05.344]                 for (kk in seq_along(NAMES)) {
[08:28:05.344]                   name <- changed[[kk]]
[08:28:05.344]                   NAME <- NAMES[[kk]]
[08:28:05.344]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.344]                     next
[08:28:05.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.344]                 }
[08:28:05.344]                 NAMES <- toupper(added)
[08:28:05.344]                 for (kk in seq_along(NAMES)) {
[08:28:05.344]                   name <- added[[kk]]
[08:28:05.344]                   NAME <- NAMES[[kk]]
[08:28:05.344]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.344]                     next
[08:28:05.344]                   args[[name]] <- ""
[08:28:05.344]                 }
[08:28:05.344]                 NAMES <- toupper(removed)
[08:28:05.344]                 for (kk in seq_along(NAMES)) {
[08:28:05.344]                   name <- removed[[kk]]
[08:28:05.344]                   NAME <- NAMES[[kk]]
[08:28:05.344]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.344]                     next
[08:28:05.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.344]                 }
[08:28:05.344]                 if (length(args) > 0) 
[08:28:05.344]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.344]             }
[08:28:05.344]             else {
[08:28:05.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.344]             }
[08:28:05.344]             {
[08:28:05.344]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.344]                   0L) {
[08:28:05.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.344]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.344]                   base::options(opts)
[08:28:05.344]                 }
[08:28:05.344]                 {
[08:28:05.344]                   {
[08:28:05.344]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:05.344]                     NULL
[08:28:05.344]                   }
[08:28:05.344]                   options(future.plan = NULL)
[08:28:05.344]                   if (is.na(NA_character_)) 
[08:28:05.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.344]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.344]                     .init = FALSE)
[08:28:05.344]                 }
[08:28:05.344]             }
[08:28:05.344]         }
[08:28:05.344]     })
[08:28:05.344]     if (TRUE) {
[08:28:05.344]         base::sink(type = "output", split = FALSE)
[08:28:05.344]         if (TRUE) {
[08:28:05.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.344]         }
[08:28:05.344]         else {
[08:28:05.344]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.344]         }
[08:28:05.344]         base::close(...future.stdout)
[08:28:05.344]         ...future.stdout <- NULL
[08:28:05.344]     }
[08:28:05.344]     ...future.result$conditions <- ...future.conditions
[08:28:05.344]     ...future.result$finished <- base::Sys.time()
[08:28:05.344]     ...future.result
[08:28:05.344] }
[08:28:05.346] requestCore(): workers = 2
[08:28:05.349] MulticoreFuture started
[08:28:05.350] - Launch lazy future ... done
[08:28:05.350] plan(): Setting new future strategy stack:
[08:28:05.350] run() for ‘MulticoreFuture’ ... done
[08:28:05.350] List of future strategies:
[08:28:05.350] 1. sequential:
[08:28:05.350]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.350]    - tweaked: FALSE
[08:28:05.350]    - call: NULL
[08:28:05.351] result() for MulticoreFuture ...
[08:28:05.351] plan(): nbrOfWorkers() = 1
[08:28:05.353] plan(): Setting new future strategy stack:
[08:28:05.353] List of future strategies:
[08:28:05.353] 1. multicore:
[08:28:05.353]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:05.353]    - tweaked: FALSE
[08:28:05.353]    - call: plan(strategy)
[08:28:05.357] plan(): nbrOfWorkers() = 2
[08:28:05.361] result() for MulticoreFuture ...
[08:28:05.362] result() for MulticoreFuture ... done
[08:28:05.362] result() for MulticoreFuture ... done
[08:28:05.362] result() for MulticoreFuture ...
[08:28:05.362] result() for MulticoreFuture ... done
[08:28:05.362] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.363] Searching for globals...
[08:28:05.363] - globals found: [1] ‘getOption’
[08:28:05.364] Searching for globals ... DONE
[08:28:05.364] Resolving globals: FALSE
[08:28:05.364] 
[08:28:05.364] 
[08:28:05.364] getGlobalsAndPackages() ... DONE
[08:28:05.365] run() for ‘Future’ ...
[08:28:05.365] - state: ‘created’
[08:28:05.365] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:05.367] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:05.367] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:05.367]   - Field: ‘label’
[08:28:05.368]   - Field: ‘local’
[08:28:05.368]   - Field: ‘owner’
[08:28:05.368]   - Field: ‘envir’
[08:28:05.368]   - Field: ‘workers’
[08:28:05.368]   - Field: ‘packages’
[08:28:05.368]   - Field: ‘gc’
[08:28:05.368]   - Field: ‘job’
[08:28:05.368]   - Field: ‘conditions’
[08:28:05.368]   - Field: ‘expr’
[08:28:05.368]   - Field: ‘uuid’
[08:28:05.369]   - Field: ‘seed’
[08:28:05.369]   - Field: ‘version’
[08:28:05.369]   - Field: ‘result’
[08:28:05.369]   - Field: ‘asynchronous’
[08:28:05.369]   - Field: ‘calls’
[08:28:05.369]   - Field: ‘globals’
[08:28:05.369]   - Field: ‘stdout’
[08:28:05.369]   - Field: ‘earlySignal’
[08:28:05.369]   - Field: ‘lazy’
[08:28:05.370]   - Field: ‘state’
[08:28:05.370] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:05.370] - Launch lazy future ...
[08:28:05.370] Packages needed by the future expression (n = 0): <none>
[08:28:05.370] Packages needed by future strategies (n = 0): <none>
[08:28:05.371] {
[08:28:05.371]     {
[08:28:05.371]         {
[08:28:05.371]             ...future.startTime <- base::Sys.time()
[08:28:05.371]             {
[08:28:05.371]                 {
[08:28:05.371]                   {
[08:28:05.371]                     {
[08:28:05.371]                       base::local({
[08:28:05.371]                         has_future <- base::requireNamespace("future", 
[08:28:05.371]                           quietly = TRUE)
[08:28:05.371]                         if (has_future) {
[08:28:05.371]                           ns <- base::getNamespace("future")
[08:28:05.371]                           version <- ns[[".package"]][["version"]]
[08:28:05.371]                           if (is.null(version)) 
[08:28:05.371]                             version <- utils::packageVersion("future")
[08:28:05.371]                         }
[08:28:05.371]                         else {
[08:28:05.371]                           version <- NULL
[08:28:05.371]                         }
[08:28:05.371]                         if (!has_future || version < "1.8.0") {
[08:28:05.371]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.371]                             "", base::R.version$version.string), 
[08:28:05.371]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:05.371]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.371]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.371]                               "release", "version")], collapse = " "), 
[08:28:05.371]                             hostname = base::Sys.info()[["nodename"]])
[08:28:05.371]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.371]                             info)
[08:28:05.371]                           info <- base::paste(info, collapse = "; ")
[08:28:05.371]                           if (!has_future) {
[08:28:05.371]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.371]                               info)
[08:28:05.371]                           }
[08:28:05.371]                           else {
[08:28:05.371]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.371]                               info, version)
[08:28:05.371]                           }
[08:28:05.371]                           base::stop(msg)
[08:28:05.371]                         }
[08:28:05.371]                       })
[08:28:05.371]                     }
[08:28:05.371]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:05.371]                     base::options(mc.cores = 1L)
[08:28:05.371]                   }
[08:28:05.371]                   ...future.strategy.old <- future::plan("list")
[08:28:05.371]                   options(future.plan = NULL)
[08:28:05.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:05.371]                 }
[08:28:05.371]                 ...future.workdir <- getwd()
[08:28:05.371]             }
[08:28:05.371]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.371]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.371]         }
[08:28:05.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:05.371]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.371]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:05.371]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.371]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.371]             base::names(...future.oldOptions))
[08:28:05.371]     }
[08:28:05.371]     if (FALSE) {
[08:28:05.371]     }
[08:28:05.371]     else {
[08:28:05.371]         if (TRUE) {
[08:28:05.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.371]                 open = "w")
[08:28:05.371]         }
[08:28:05.371]         else {
[08:28:05.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.371]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.371]         }
[08:28:05.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.371]             base::sink(type = "output", split = FALSE)
[08:28:05.371]             base::close(...future.stdout)
[08:28:05.371]         }, add = TRUE)
[08:28:05.371]     }
[08:28:05.371]     ...future.frame <- base::sys.nframe()
[08:28:05.371]     ...future.conditions <- base::list()
[08:28:05.371]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.371]     if (FALSE) {
[08:28:05.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.371]     }
[08:28:05.371]     ...future.result <- base::tryCatch({
[08:28:05.371]         base::withCallingHandlers({
[08:28:05.371]             ...future.value <- base::withVisible(base::local({
[08:28:05.371]                 withCallingHandlers({
[08:28:05.371]                   getOption("future.globals.onMissing")
[08:28:05.371]                 }, immediateCondition = function(cond) {
[08:28:05.371]                   save_rds <- function (object, pathname, ...) 
[08:28:05.371]                   {
[08:28:05.371]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:05.371]                     if (file_test("-f", pathname_tmp)) {
[08:28:05.371]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.371]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:05.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.371]                         fi_tmp[["mtime"]])
[08:28:05.371]                     }
[08:28:05.371]                     tryCatch({
[08:28:05.371]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:05.371]                     }, error = function(ex) {
[08:28:05.371]                       msg <- conditionMessage(ex)
[08:28:05.371]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.371]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:05.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.371]                         fi_tmp[["mtime"]], msg)
[08:28:05.371]                       ex$message <- msg
[08:28:05.371]                       stop(ex)
[08:28:05.371]                     })
[08:28:05.371]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:05.371]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:05.371]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:05.371]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.371]                       fi <- file.info(pathname)
[08:28:05.371]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:05.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.371]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:05.371]                         fi[["size"]], fi[["mtime"]])
[08:28:05.371]                       stop(msg)
[08:28:05.371]                     }
[08:28:05.371]                     invisible(pathname)
[08:28:05.371]                   }
[08:28:05.371]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:05.371]                     rootPath = tempdir()) 
[08:28:05.371]                   {
[08:28:05.371]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:05.371]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:05.371]                       tmpdir = path, fileext = ".rds")
[08:28:05.371]                     save_rds(obj, file)
[08:28:05.371]                   }
[08:28:05.371]                   saveImmediateCondition(cond, path = "/tmp/RtmpifSr4D/.future/immediateConditions")
[08:28:05.371]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.371]                   {
[08:28:05.371]                     inherits <- base::inherits
[08:28:05.371]                     invokeRestart <- base::invokeRestart
[08:28:05.371]                     is.null <- base::is.null
[08:28:05.371]                     muffled <- FALSE
[08:28:05.371]                     if (inherits(cond, "message")) {
[08:28:05.371]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:05.371]                       if (muffled) 
[08:28:05.371]                         invokeRestart("muffleMessage")
[08:28:05.371]                     }
[08:28:05.371]                     else if (inherits(cond, "warning")) {
[08:28:05.371]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:05.371]                       if (muffled) 
[08:28:05.371]                         invokeRestart("muffleWarning")
[08:28:05.371]                     }
[08:28:05.371]                     else if (inherits(cond, "condition")) {
[08:28:05.371]                       if (!is.null(pattern)) {
[08:28:05.371]                         computeRestarts <- base::computeRestarts
[08:28:05.371]                         grepl <- base::grepl
[08:28:05.371]                         restarts <- computeRestarts(cond)
[08:28:05.371]                         for (restart in restarts) {
[08:28:05.371]                           name <- restart$name
[08:28:05.371]                           if (is.null(name)) 
[08:28:05.371]                             next
[08:28:05.371]                           if (!grepl(pattern, name)) 
[08:28:05.371]                             next
[08:28:05.371]                           invokeRestart(restart)
[08:28:05.371]                           muffled <- TRUE
[08:28:05.371]                           break
[08:28:05.371]                         }
[08:28:05.371]                       }
[08:28:05.371]                     }
[08:28:05.371]                     invisible(muffled)
[08:28:05.371]                   }
[08:28:05.371]                   muffleCondition(cond)
[08:28:05.371]                 })
[08:28:05.371]             }))
[08:28:05.371]             future::FutureResult(value = ...future.value$value, 
[08:28:05.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.371]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.371]                     ...future.globalenv.names))
[08:28:05.371]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.371]         }, condition = base::local({
[08:28:05.371]             c <- base::c
[08:28:05.371]             inherits <- base::inherits
[08:28:05.371]             invokeRestart <- base::invokeRestart
[08:28:05.371]             length <- base::length
[08:28:05.371]             list <- base::list
[08:28:05.371]             seq.int <- base::seq.int
[08:28:05.371]             signalCondition <- base::signalCondition
[08:28:05.371]             sys.calls <- base::sys.calls
[08:28:05.371]             `[[` <- base::`[[`
[08:28:05.371]             `+` <- base::`+`
[08:28:05.371]             `<<-` <- base::`<<-`
[08:28:05.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.371]                   3L)]
[08:28:05.371]             }
[08:28:05.371]             function(cond) {
[08:28:05.371]                 is_error <- inherits(cond, "error")
[08:28:05.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.371]                   NULL)
[08:28:05.371]                 if (is_error) {
[08:28:05.371]                   sessionInformation <- function() {
[08:28:05.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.371]                       search = base::search(), system = base::Sys.info())
[08:28:05.371]                   }
[08:28:05.371]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.371]                     cond$call), session = sessionInformation(), 
[08:28:05.371]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.371]                   signalCondition(cond)
[08:28:05.371]                 }
[08:28:05.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.371]                 "immediateCondition"))) {
[08:28:05.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.371]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.371]                   if (TRUE && !signal) {
[08:28:05.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.371]                     {
[08:28:05.371]                       inherits <- base::inherits
[08:28:05.371]                       invokeRestart <- base::invokeRestart
[08:28:05.371]                       is.null <- base::is.null
[08:28:05.371]                       muffled <- FALSE
[08:28:05.371]                       if (inherits(cond, "message")) {
[08:28:05.371]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.371]                         if (muffled) 
[08:28:05.371]                           invokeRestart("muffleMessage")
[08:28:05.371]                       }
[08:28:05.371]                       else if (inherits(cond, "warning")) {
[08:28:05.371]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.371]                         if (muffled) 
[08:28:05.371]                           invokeRestart("muffleWarning")
[08:28:05.371]                       }
[08:28:05.371]                       else if (inherits(cond, "condition")) {
[08:28:05.371]                         if (!is.null(pattern)) {
[08:28:05.371]                           computeRestarts <- base::computeRestarts
[08:28:05.371]                           grepl <- base::grepl
[08:28:05.371]                           restarts <- computeRestarts(cond)
[08:28:05.371]                           for (restart in restarts) {
[08:28:05.371]                             name <- restart$name
[08:28:05.371]                             if (is.null(name)) 
[08:28:05.371]                               next
[08:28:05.371]                             if (!grepl(pattern, name)) 
[08:28:05.371]                               next
[08:28:05.371]                             invokeRestart(restart)
[08:28:05.371]                             muffled <- TRUE
[08:28:05.371]                             break
[08:28:05.371]                           }
[08:28:05.371]                         }
[08:28:05.371]                       }
[08:28:05.371]                       invisible(muffled)
[08:28:05.371]                     }
[08:28:05.371]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.371]                   }
[08:28:05.371]                 }
[08:28:05.371]                 else {
[08:28:05.371]                   if (TRUE) {
[08:28:05.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.371]                     {
[08:28:05.371]                       inherits <- base::inherits
[08:28:05.371]                       invokeRestart <- base::invokeRestart
[08:28:05.371]                       is.null <- base::is.null
[08:28:05.371]                       muffled <- FALSE
[08:28:05.371]                       if (inherits(cond, "message")) {
[08:28:05.371]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.371]                         if (muffled) 
[08:28:05.371]                           invokeRestart("muffleMessage")
[08:28:05.371]                       }
[08:28:05.371]                       else if (inherits(cond, "warning")) {
[08:28:05.371]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.371]                         if (muffled) 
[08:28:05.371]                           invokeRestart("muffleWarning")
[08:28:05.371]                       }
[08:28:05.371]                       else if (inherits(cond, "condition")) {
[08:28:05.371]                         if (!is.null(pattern)) {
[08:28:05.371]                           computeRestarts <- base::computeRestarts
[08:28:05.371]                           grepl <- base::grepl
[08:28:05.371]                           restarts <- computeRestarts(cond)
[08:28:05.371]                           for (restart in restarts) {
[08:28:05.371]                             name <- restart$name
[08:28:05.371]                             if (is.null(name)) 
[08:28:05.371]                               next
[08:28:05.371]                             if (!grepl(pattern, name)) 
[08:28:05.371]                               next
[08:28:05.371]                             invokeRestart(restart)
[08:28:05.371]                             muffled <- TRUE
[08:28:05.371]                             break
[08:28:05.371]                           }
[08:28:05.371]                         }
[08:28:05.371]                       }
[08:28:05.371]                       invisible(muffled)
[08:28:05.371]                     }
[08:28:05.371]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.371]                   }
[08:28:05.371]                 }
[08:28:05.371]             }
[08:28:05.371]         }))
[08:28:05.371]     }, error = function(ex) {
[08:28:05.371]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.371]                 ...future.rng), started = ...future.startTime, 
[08:28:05.371]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.371]             version = "1.8"), class = "FutureResult")
[08:28:05.371]     }, finally = {
[08:28:05.371]         if (!identical(...future.workdir, getwd())) 
[08:28:05.371]             setwd(...future.workdir)
[08:28:05.371]         {
[08:28:05.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.371]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.371]             }
[08:28:05.371]             base::options(...future.oldOptions)
[08:28:05.371]             if (.Platform$OS.type == "windows") {
[08:28:05.371]                 old_names <- names(...future.oldEnvVars)
[08:28:05.371]                 envs <- base::Sys.getenv()
[08:28:05.371]                 names <- names(envs)
[08:28:05.371]                 common <- intersect(names, old_names)
[08:28:05.371]                 added <- setdiff(names, old_names)
[08:28:05.371]                 removed <- setdiff(old_names, names)
[08:28:05.371]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.371]                   envs[common]]
[08:28:05.371]                 NAMES <- toupper(changed)
[08:28:05.371]                 args <- list()
[08:28:05.371]                 for (kk in seq_along(NAMES)) {
[08:28:05.371]                   name <- changed[[kk]]
[08:28:05.371]                   NAME <- NAMES[[kk]]
[08:28:05.371]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.371]                     next
[08:28:05.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.371]                 }
[08:28:05.371]                 NAMES <- toupper(added)
[08:28:05.371]                 for (kk in seq_along(NAMES)) {
[08:28:05.371]                   name <- added[[kk]]
[08:28:05.371]                   NAME <- NAMES[[kk]]
[08:28:05.371]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.371]                     next
[08:28:05.371]                   args[[name]] <- ""
[08:28:05.371]                 }
[08:28:05.371]                 NAMES <- toupper(removed)
[08:28:05.371]                 for (kk in seq_along(NAMES)) {
[08:28:05.371]                   name <- removed[[kk]]
[08:28:05.371]                   NAME <- NAMES[[kk]]
[08:28:05.371]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.371]                     next
[08:28:05.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.371]                 }
[08:28:05.371]                 if (length(args) > 0) 
[08:28:05.371]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.371]             }
[08:28:05.371]             else {
[08:28:05.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.371]             }
[08:28:05.371]             {
[08:28:05.371]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.371]                   0L) {
[08:28:05.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.371]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.371]                   base::options(opts)
[08:28:05.371]                 }
[08:28:05.371]                 {
[08:28:05.371]                   {
[08:28:05.371]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:05.371]                     NULL
[08:28:05.371]                   }
[08:28:05.371]                   options(future.plan = NULL)
[08:28:05.371]                   if (is.na(NA_character_)) 
[08:28:05.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.371]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.371]                     .init = FALSE)
[08:28:05.371]                 }
[08:28:05.371]             }
[08:28:05.371]         }
[08:28:05.371]     })
[08:28:05.371]     if (TRUE) {
[08:28:05.371]         base::sink(type = "output", split = FALSE)
[08:28:05.371]         if (TRUE) {
[08:28:05.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.371]         }
[08:28:05.371]         else {
[08:28:05.371]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.371]         }
[08:28:05.371]         base::close(...future.stdout)
[08:28:05.371]         ...future.stdout <- NULL
[08:28:05.371]     }
[08:28:05.371]     ...future.result$conditions <- ...future.conditions
[08:28:05.371]     ...future.result$finished <- base::Sys.time()
[08:28:05.371]     ...future.result
[08:28:05.371] }
[08:28:05.373] requestCore(): workers = 2
[08:28:05.376] MulticoreFuture started
[08:28:05.376] - Launch lazy future ... done
[08:28:05.377] run() for ‘MulticoreFuture’ ... done
[08:28:05.377] plan(): Setting new future strategy stack:
[08:28:05.377] result() for MulticoreFuture ...
[08:28:05.377] List of future strategies:
[08:28:05.377] 1. sequential:
[08:28:05.377]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.377]    - tweaked: FALSE
[08:28:05.377]    - call: NULL
[08:28:05.378] plan(): nbrOfWorkers() = 1
[08:28:05.380] plan(): Setting new future strategy stack:
[08:28:05.380] List of future strategies:
[08:28:05.380] 1. multicore:
[08:28:05.380]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:05.380]    - tweaked: FALSE
[08:28:05.380]    - call: plan(strategy)
[08:28:05.383] plan(): nbrOfWorkers() = 2
[08:28:05.389] result() for MulticoreFuture ...
[08:28:05.389] result() for MulticoreFuture ... done
[08:28:05.389] result() for MulticoreFuture ... done
[08:28:05.389] result() for MulticoreFuture ...
[08:28:05.390] result() for MulticoreFuture ... done
[08:28:05.390] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:05.390] Searching for globals...
[08:28:05.395] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.395] Searching for globals...
[08:28:05.397] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[08:28:05.397] Searching for globals ... DONE
[08:28:05.397] Resolving globals: FALSE
[08:28:05.398] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:05.398] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:05.398] - globals: [1] ‘data’
[08:28:05.398] 
[08:28:05.399] getGlobalsAndPackages() ... DONE
[08:28:05.399] run() for ‘Future’ ...
[08:28:05.399] - state: ‘created’
[08:28:05.399] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:05.401] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:05.401] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:05.402]   - Field: ‘label’
[08:28:05.402]   - Field: ‘local’
[08:28:05.402]   - Field: ‘owner’
[08:28:05.402]   - Field: ‘envir’
[08:28:05.402]   - Field: ‘workers’
[08:28:05.402]   - Field: ‘packages’
[08:28:05.402]   - Field: ‘gc’
[08:28:05.402]   - Field: ‘job’
[08:28:05.402]   - Field: ‘conditions’
[08:28:05.403]   - Field: ‘expr’
[08:28:05.403]   - Field: ‘uuid’
[08:28:05.403]   - Field: ‘seed’
[08:28:05.403]   - Field: ‘version’
[08:28:05.403]   - Field: ‘result’
[08:28:05.403]   - Field: ‘asynchronous’
[08:28:05.403]   - Field: ‘calls’
[08:28:05.403]   - Field: ‘globals’
[08:28:05.403]   - Field: ‘stdout’
[08:28:05.404]   - Field: ‘earlySignal’
[08:28:05.404]   - Field: ‘lazy’
[08:28:05.404]   - Field: ‘state’
[08:28:05.404] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:05.404] - Launch lazy future ...
[08:28:05.404] Packages needed by the future expression (n = 0): <none>
[08:28:05.404] Packages needed by future strategies (n = 0): <none>
[08:28:05.405] {
[08:28:05.405]     {
[08:28:05.405]         {
[08:28:05.405]             ...future.startTime <- base::Sys.time()
[08:28:05.405]             {
[08:28:05.405]                 {
[08:28:05.405]                   {
[08:28:05.405]                     {
[08:28:05.405]                       base::local({
[08:28:05.405]                         has_future <- base::requireNamespace("future", 
[08:28:05.405]                           quietly = TRUE)
[08:28:05.405]                         if (has_future) {
[08:28:05.405]                           ns <- base::getNamespace("future")
[08:28:05.405]                           version <- ns[[".package"]][["version"]]
[08:28:05.405]                           if (is.null(version)) 
[08:28:05.405]                             version <- utils::packageVersion("future")
[08:28:05.405]                         }
[08:28:05.405]                         else {
[08:28:05.405]                           version <- NULL
[08:28:05.405]                         }
[08:28:05.405]                         if (!has_future || version < "1.8.0") {
[08:28:05.405]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.405]                             "", base::R.version$version.string), 
[08:28:05.405]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:05.405]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.405]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.405]                               "release", "version")], collapse = " "), 
[08:28:05.405]                             hostname = base::Sys.info()[["nodename"]])
[08:28:05.405]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.405]                             info)
[08:28:05.405]                           info <- base::paste(info, collapse = "; ")
[08:28:05.405]                           if (!has_future) {
[08:28:05.405]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.405]                               info)
[08:28:05.405]                           }
[08:28:05.405]                           else {
[08:28:05.405]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.405]                               info, version)
[08:28:05.405]                           }
[08:28:05.405]                           base::stop(msg)
[08:28:05.405]                         }
[08:28:05.405]                       })
[08:28:05.405]                     }
[08:28:05.405]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:05.405]                     base::options(mc.cores = 1L)
[08:28:05.405]                   }
[08:28:05.405]                   ...future.strategy.old <- future::plan("list")
[08:28:05.405]                   options(future.plan = NULL)
[08:28:05.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:05.405]                 }
[08:28:05.405]                 ...future.workdir <- getwd()
[08:28:05.405]             }
[08:28:05.405]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.405]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.405]         }
[08:28:05.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:05.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.405]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:05.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.405]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.405]             base::names(...future.oldOptions))
[08:28:05.405]     }
[08:28:05.405]     if (FALSE) {
[08:28:05.405]     }
[08:28:05.405]     else {
[08:28:05.405]         if (TRUE) {
[08:28:05.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.405]                 open = "w")
[08:28:05.405]         }
[08:28:05.405]         else {
[08:28:05.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.405]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.405]         }
[08:28:05.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.405]             base::sink(type = "output", split = FALSE)
[08:28:05.405]             base::close(...future.stdout)
[08:28:05.405]         }, add = TRUE)
[08:28:05.405]     }
[08:28:05.405]     ...future.frame <- base::sys.nframe()
[08:28:05.405]     ...future.conditions <- base::list()
[08:28:05.405]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.405]     if (FALSE) {
[08:28:05.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.405]     }
[08:28:05.405]     ...future.result <- base::tryCatch({
[08:28:05.405]         base::withCallingHandlers({
[08:28:05.405]             ...future.value <- base::withVisible(base::local({
[08:28:05.405]                 withCallingHandlers({
[08:28:05.405]                   subset(data, x < 3)$y
[08:28:05.405]                 }, immediateCondition = function(cond) {
[08:28:05.405]                   save_rds <- function (object, pathname, ...) 
[08:28:05.405]                   {
[08:28:05.405]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:05.405]                     if (file_test("-f", pathname_tmp)) {
[08:28:05.405]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.405]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:05.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.405]                         fi_tmp[["mtime"]])
[08:28:05.405]                     }
[08:28:05.405]                     tryCatch({
[08:28:05.405]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:05.405]                     }, error = function(ex) {
[08:28:05.405]                       msg <- conditionMessage(ex)
[08:28:05.405]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.405]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:05.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.405]                         fi_tmp[["mtime"]], msg)
[08:28:05.405]                       ex$message <- msg
[08:28:05.405]                       stop(ex)
[08:28:05.405]                     })
[08:28:05.405]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:05.405]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:05.405]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:05.405]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.405]                       fi <- file.info(pathname)
[08:28:05.405]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:05.405]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.405]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:05.405]                         fi[["size"]], fi[["mtime"]])
[08:28:05.405]                       stop(msg)
[08:28:05.405]                     }
[08:28:05.405]                     invisible(pathname)
[08:28:05.405]                   }
[08:28:05.405]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:05.405]                     rootPath = tempdir()) 
[08:28:05.405]                   {
[08:28:05.405]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:05.405]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:05.405]                       tmpdir = path, fileext = ".rds")
[08:28:05.405]                     save_rds(obj, file)
[08:28:05.405]                   }
[08:28:05.405]                   saveImmediateCondition(cond, path = "/tmp/RtmpifSr4D/.future/immediateConditions")
[08:28:05.405]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.405]                   {
[08:28:05.405]                     inherits <- base::inherits
[08:28:05.405]                     invokeRestart <- base::invokeRestart
[08:28:05.405]                     is.null <- base::is.null
[08:28:05.405]                     muffled <- FALSE
[08:28:05.405]                     if (inherits(cond, "message")) {
[08:28:05.405]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:05.405]                       if (muffled) 
[08:28:05.405]                         invokeRestart("muffleMessage")
[08:28:05.405]                     }
[08:28:05.405]                     else if (inherits(cond, "warning")) {
[08:28:05.405]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:05.405]                       if (muffled) 
[08:28:05.405]                         invokeRestart("muffleWarning")
[08:28:05.405]                     }
[08:28:05.405]                     else if (inherits(cond, "condition")) {
[08:28:05.405]                       if (!is.null(pattern)) {
[08:28:05.405]                         computeRestarts <- base::computeRestarts
[08:28:05.405]                         grepl <- base::grepl
[08:28:05.405]                         restarts <- computeRestarts(cond)
[08:28:05.405]                         for (restart in restarts) {
[08:28:05.405]                           name <- restart$name
[08:28:05.405]                           if (is.null(name)) 
[08:28:05.405]                             next
[08:28:05.405]                           if (!grepl(pattern, name)) 
[08:28:05.405]                             next
[08:28:05.405]                           invokeRestart(restart)
[08:28:05.405]                           muffled <- TRUE
[08:28:05.405]                           break
[08:28:05.405]                         }
[08:28:05.405]                       }
[08:28:05.405]                     }
[08:28:05.405]                     invisible(muffled)
[08:28:05.405]                   }
[08:28:05.405]                   muffleCondition(cond)
[08:28:05.405]                 })
[08:28:05.405]             }))
[08:28:05.405]             future::FutureResult(value = ...future.value$value, 
[08:28:05.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.405]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.405]                     ...future.globalenv.names))
[08:28:05.405]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.405]         }, condition = base::local({
[08:28:05.405]             c <- base::c
[08:28:05.405]             inherits <- base::inherits
[08:28:05.405]             invokeRestart <- base::invokeRestart
[08:28:05.405]             length <- base::length
[08:28:05.405]             list <- base::list
[08:28:05.405]             seq.int <- base::seq.int
[08:28:05.405]             signalCondition <- base::signalCondition
[08:28:05.405]             sys.calls <- base::sys.calls
[08:28:05.405]             `[[` <- base::`[[`
[08:28:05.405]             `+` <- base::`+`
[08:28:05.405]             `<<-` <- base::`<<-`
[08:28:05.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.405]                   3L)]
[08:28:05.405]             }
[08:28:05.405]             function(cond) {
[08:28:05.405]                 is_error <- inherits(cond, "error")
[08:28:05.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.405]                   NULL)
[08:28:05.405]                 if (is_error) {
[08:28:05.405]                   sessionInformation <- function() {
[08:28:05.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.405]                       search = base::search(), system = base::Sys.info())
[08:28:05.405]                   }
[08:28:05.405]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.405]                     cond$call), session = sessionInformation(), 
[08:28:05.405]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.405]                   signalCondition(cond)
[08:28:05.405]                 }
[08:28:05.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.405]                 "immediateCondition"))) {
[08:28:05.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.405]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.405]                   if (TRUE && !signal) {
[08:28:05.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.405]                     {
[08:28:05.405]                       inherits <- base::inherits
[08:28:05.405]                       invokeRestart <- base::invokeRestart
[08:28:05.405]                       is.null <- base::is.null
[08:28:05.405]                       muffled <- FALSE
[08:28:05.405]                       if (inherits(cond, "message")) {
[08:28:05.405]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.405]                         if (muffled) 
[08:28:05.405]                           invokeRestart("muffleMessage")
[08:28:05.405]                       }
[08:28:05.405]                       else if (inherits(cond, "warning")) {
[08:28:05.405]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.405]                         if (muffled) 
[08:28:05.405]                           invokeRestart("muffleWarning")
[08:28:05.405]                       }
[08:28:05.405]                       else if (inherits(cond, "condition")) {
[08:28:05.405]                         if (!is.null(pattern)) {
[08:28:05.405]                           computeRestarts <- base::computeRestarts
[08:28:05.405]                           grepl <- base::grepl
[08:28:05.405]                           restarts <- computeRestarts(cond)
[08:28:05.405]                           for (restart in restarts) {
[08:28:05.405]                             name <- restart$name
[08:28:05.405]                             if (is.null(name)) 
[08:28:05.405]                               next
[08:28:05.405]                             if (!grepl(pattern, name)) 
[08:28:05.405]                               next
[08:28:05.405]                             invokeRestart(restart)
[08:28:05.405]                             muffled <- TRUE
[08:28:05.405]                             break
[08:28:05.405]                           }
[08:28:05.405]                         }
[08:28:05.405]                       }
[08:28:05.405]                       invisible(muffled)
[08:28:05.405]                     }
[08:28:05.405]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.405]                   }
[08:28:05.405]                 }
[08:28:05.405]                 else {
[08:28:05.405]                   if (TRUE) {
[08:28:05.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.405]                     {
[08:28:05.405]                       inherits <- base::inherits
[08:28:05.405]                       invokeRestart <- base::invokeRestart
[08:28:05.405]                       is.null <- base::is.null
[08:28:05.405]                       muffled <- FALSE
[08:28:05.405]                       if (inherits(cond, "message")) {
[08:28:05.405]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.405]                         if (muffled) 
[08:28:05.405]                           invokeRestart("muffleMessage")
[08:28:05.405]                       }
[08:28:05.405]                       else if (inherits(cond, "warning")) {
[08:28:05.405]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.405]                         if (muffled) 
[08:28:05.405]                           invokeRestart("muffleWarning")
[08:28:05.405]                       }
[08:28:05.405]                       else if (inherits(cond, "condition")) {
[08:28:05.405]                         if (!is.null(pattern)) {
[08:28:05.405]                           computeRestarts <- base::computeRestarts
[08:28:05.405]                           grepl <- base::grepl
[08:28:05.405]                           restarts <- computeRestarts(cond)
[08:28:05.405]                           for (restart in restarts) {
[08:28:05.405]                             name <- restart$name
[08:28:05.405]                             if (is.null(name)) 
[08:28:05.405]                               next
[08:28:05.405]                             if (!grepl(pattern, name)) 
[08:28:05.405]                               next
[08:28:05.405]                             invokeRestart(restart)
[08:28:05.405]                             muffled <- TRUE
[08:28:05.405]                             break
[08:28:05.405]                           }
[08:28:05.405]                         }
[08:28:05.405]                       }
[08:28:05.405]                       invisible(muffled)
[08:28:05.405]                     }
[08:28:05.405]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.405]                   }
[08:28:05.405]                 }
[08:28:05.405]             }
[08:28:05.405]         }))
[08:28:05.405]     }, error = function(ex) {
[08:28:05.405]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.405]                 ...future.rng), started = ...future.startTime, 
[08:28:05.405]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.405]             version = "1.8"), class = "FutureResult")
[08:28:05.405]     }, finally = {
[08:28:05.405]         if (!identical(...future.workdir, getwd())) 
[08:28:05.405]             setwd(...future.workdir)
[08:28:05.405]         {
[08:28:05.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.405]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.405]             }
[08:28:05.405]             base::options(...future.oldOptions)
[08:28:05.405]             if (.Platform$OS.type == "windows") {
[08:28:05.405]                 old_names <- names(...future.oldEnvVars)
[08:28:05.405]                 envs <- base::Sys.getenv()
[08:28:05.405]                 names <- names(envs)
[08:28:05.405]                 common <- intersect(names, old_names)
[08:28:05.405]                 added <- setdiff(names, old_names)
[08:28:05.405]                 removed <- setdiff(old_names, names)
[08:28:05.405]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.405]                   envs[common]]
[08:28:05.405]                 NAMES <- toupper(changed)
[08:28:05.405]                 args <- list()
[08:28:05.405]                 for (kk in seq_along(NAMES)) {
[08:28:05.405]                   name <- changed[[kk]]
[08:28:05.405]                   NAME <- NAMES[[kk]]
[08:28:05.405]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.405]                     next
[08:28:05.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.405]                 }
[08:28:05.405]                 NAMES <- toupper(added)
[08:28:05.405]                 for (kk in seq_along(NAMES)) {
[08:28:05.405]                   name <- added[[kk]]
[08:28:05.405]                   NAME <- NAMES[[kk]]
[08:28:05.405]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.405]                     next
[08:28:05.405]                   args[[name]] <- ""
[08:28:05.405]                 }
[08:28:05.405]                 NAMES <- toupper(removed)
[08:28:05.405]                 for (kk in seq_along(NAMES)) {
[08:28:05.405]                   name <- removed[[kk]]
[08:28:05.405]                   NAME <- NAMES[[kk]]
[08:28:05.405]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.405]                     next
[08:28:05.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.405]                 }
[08:28:05.405]                 if (length(args) > 0) 
[08:28:05.405]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.405]             }
[08:28:05.405]             else {
[08:28:05.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.405]             }
[08:28:05.405]             {
[08:28:05.405]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.405]                   0L) {
[08:28:05.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.405]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.405]                   base::options(opts)
[08:28:05.405]                 }
[08:28:05.405]                 {
[08:28:05.405]                   {
[08:28:05.405]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:05.405]                     NULL
[08:28:05.405]                   }
[08:28:05.405]                   options(future.plan = NULL)
[08:28:05.405]                   if (is.na(NA_character_)) 
[08:28:05.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.405]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.405]                     .init = FALSE)
[08:28:05.405]                 }
[08:28:05.405]             }
[08:28:05.405]         }
[08:28:05.405]     })
[08:28:05.405]     if (TRUE) {
[08:28:05.405]         base::sink(type = "output", split = FALSE)
[08:28:05.405]         if (TRUE) {
[08:28:05.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.405]         }
[08:28:05.405]         else {
[08:28:05.405]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.405]         }
[08:28:05.405]         base::close(...future.stdout)
[08:28:05.405]         ...future.stdout <- NULL
[08:28:05.405]     }
[08:28:05.405]     ...future.result$conditions <- ...future.conditions
[08:28:05.405]     ...future.result$finished <- base::Sys.time()
[08:28:05.405]     ...future.result
[08:28:05.405] }
[08:28:05.407] assign_globals() ...
[08:28:05.407] List of 1
[08:28:05.407]  $ data:'data.frame':	5 obs. of  2 variables:
[08:28:05.407]   ..$ x: int [1:5] 1 2 3 4 5
[08:28:05.407]   ..$ y: int [1:5] 1 2 3 4 5
[08:28:05.407]  - attr(*, "where")=List of 1
[08:28:05.407]   ..$ data:<environment: R_EmptyEnv> 
[08:28:05.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:05.407]  - attr(*, "resolved")= logi FALSE
[08:28:05.407]  - attr(*, "total_size")= num 356
[08:28:05.407]  - attr(*, "already-done")= logi TRUE
[08:28:05.411] - copied ‘data’ to environment
[08:28:05.412] assign_globals() ... done
[08:28:05.412] requestCore(): workers = 2
[08:28:05.414] MulticoreFuture started
[08:28:05.414] - Launch lazy future ... done
[08:28:05.415] run() for ‘MulticoreFuture’ ... done
[08:28:05.415] plan(): Setting new future strategy stack:
[08:28:05.415] result() for MulticoreFuture ...
[08:28:05.415] List of future strategies:
[08:28:05.415] 1. sequential:
[08:28:05.415]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.415]    - tweaked: FALSE
[08:28:05.415]    - call: NULL
[08:28:05.416] plan(): nbrOfWorkers() = 1
[08:28:05.418] plan(): Setting new future strategy stack:
[08:28:05.418] List of future strategies:
[08:28:05.418] 1. multicore:
[08:28:05.418]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:05.418]    - tweaked: FALSE
[08:28:05.418]    - call: plan(strategy)
[08:28:05.422] plan(): nbrOfWorkers() = 2
[08:28:05.422] result() for MulticoreFuture ...
[08:28:05.423] result() for MulticoreFuture ... done
[08:28:05.423] result() for MulticoreFuture ... done
[08:28:05.423] result() for MulticoreFuture ...
[08:28:05.423] result() for MulticoreFuture ... done
[08:28:05.423] plan(): Setting new future strategy stack:
[08:28:05.423] List of future strategies:
[08:28:05.423] 1. sequential:
[08:28:05.423]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.423]    - tweaked: FALSE
[08:28:05.423]    - call: plan(list(sequential, strategy))
[08:28:05.423] 2. multicore:
[08:28:05.423]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:05.423]    - tweaked: FALSE
[08:28:05.423]    - call: plan(list(sequential, strategy))
[08:28:05.424] plan(): nbrOfWorkers() = 1
[08:28:05.425] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.425] Searching for globals...
[08:28:05.429] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[08:28:05.429] Searching for globals ... DONE
[08:28:05.429] Resolving globals: FALSE
[08:28:05.430] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:05.430] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:05.430] - globals: [1] ‘data’
[08:28:05.430] - packages: [1] ‘future’
[08:28:05.431] getGlobalsAndPackages() ... DONE
[08:28:05.431] run() for ‘Future’ ...
[08:28:05.431] - state: ‘created’
[08:28:05.431] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:05.432] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:05.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:05.432]   - Field: ‘label’
[08:28:05.432]   - Field: ‘local’
[08:28:05.432]   - Field: ‘owner’
[08:28:05.432]   - Field: ‘envir’
[08:28:05.432]   - Field: ‘packages’
[08:28:05.432]   - Field: ‘gc’
[08:28:05.432]   - Field: ‘conditions’
[08:28:05.433]   - Field: ‘expr’
[08:28:05.433]   - Field: ‘uuid’
[08:28:05.433]   - Field: ‘seed’
[08:28:05.433]   - Field: ‘version’
[08:28:05.433]   - Field: ‘result’
[08:28:05.433]   - Field: ‘asynchronous’
[08:28:05.433]   - Field: ‘calls’
[08:28:05.433]   - Field: ‘globals’
[08:28:05.433]   - Field: ‘stdout’
[08:28:05.434]   - Field: ‘earlySignal’
[08:28:05.434]   - Field: ‘lazy’
[08:28:05.434]   - Field: ‘state’
[08:28:05.434] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:05.434] - Launch lazy future ...
[08:28:05.434] Packages needed by the future expression (n = 1): ‘future’
[08:28:05.434] Packages needed by future strategies (n = 1): ‘future’
[08:28:05.435] {
[08:28:05.435]     {
[08:28:05.435]         {
[08:28:05.435]             ...future.startTime <- base::Sys.time()
[08:28:05.435]             {
[08:28:05.435]                 {
[08:28:05.435]                   {
[08:28:05.435]                     {
[08:28:05.435]                       base::local({
[08:28:05.435]                         has_future <- base::requireNamespace("future", 
[08:28:05.435]                           quietly = TRUE)
[08:28:05.435]                         if (has_future) {
[08:28:05.435]                           ns <- base::getNamespace("future")
[08:28:05.435]                           version <- ns[[".package"]][["version"]]
[08:28:05.435]                           if (is.null(version)) 
[08:28:05.435]                             version <- utils::packageVersion("future")
[08:28:05.435]                         }
[08:28:05.435]                         else {
[08:28:05.435]                           version <- NULL
[08:28:05.435]                         }
[08:28:05.435]                         if (!has_future || version < "1.8.0") {
[08:28:05.435]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.435]                             "", base::R.version$version.string), 
[08:28:05.435]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:05.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.435]                               "release", "version")], collapse = " "), 
[08:28:05.435]                             hostname = base::Sys.info()[["nodename"]])
[08:28:05.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.435]                             info)
[08:28:05.435]                           info <- base::paste(info, collapse = "; ")
[08:28:05.435]                           if (!has_future) {
[08:28:05.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.435]                               info)
[08:28:05.435]                           }
[08:28:05.435]                           else {
[08:28:05.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.435]                               info, version)
[08:28:05.435]                           }
[08:28:05.435]                           base::stop(msg)
[08:28:05.435]                         }
[08:28:05.435]                       })
[08:28:05.435]                     }
[08:28:05.435]                     base::local({
[08:28:05.435]                       for (pkg in "future") {
[08:28:05.435]                         base::loadNamespace(pkg)
[08:28:05.435]                         base::library(pkg, character.only = TRUE)
[08:28:05.435]                       }
[08:28:05.435]                     })
[08:28:05.435]                   }
[08:28:05.435]                   ...future.strategy.old <- future::plan("list")
[08:28:05.435]                   options(future.plan = NULL)
[08:28:05.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.435]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[08:28:05.435]                     envir = parent.frame()) 
[08:28:05.435]                   {
[08:28:05.435]                     default_workers <- missing(workers)
[08:28:05.435]                     if (is.function(workers)) 
[08:28:05.435]                       workers <- workers()
[08:28:05.435]                     workers <- structure(as.integer(workers), 
[08:28:05.435]                       class = class(workers))
[08:28:05.435]                     stop_if_not(is.finite(workers), workers >= 
[08:28:05.435]                       1L)
[08:28:05.435]                     if ((workers == 1L && !inherits(workers, 
[08:28:05.435]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[08:28:05.435]                       if (default_workers) 
[08:28:05.435]                         supportsMulticore(warn = TRUE)
[08:28:05.435]                       return(sequential(..., envir = envir))
[08:28:05.435]                     }
[08:28:05.435]                     oopts <- options(mc.cores = workers)
[08:28:05.435]                     on.exit(options(oopts))
[08:28:05.435]                     future <- MulticoreFuture(..., workers = workers, 
[08:28:05.435]                       envir = envir)
[08:28:05.435]                     if (!future$lazy) 
[08:28:05.435]                       future <- run(future)
[08:28:05.435]                     invisible(future)
[08:28:05.435]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:05.435]                 }
[08:28:05.435]                 ...future.workdir <- getwd()
[08:28:05.435]             }
[08:28:05.435]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.435]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.435]         }
[08:28:05.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:05.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.435]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:05.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.435]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.435]             base::names(...future.oldOptions))
[08:28:05.435]     }
[08:28:05.435]     if (FALSE) {
[08:28:05.435]     }
[08:28:05.435]     else {
[08:28:05.435]         if (TRUE) {
[08:28:05.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.435]                 open = "w")
[08:28:05.435]         }
[08:28:05.435]         else {
[08:28:05.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.435]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.435]         }
[08:28:05.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.435]             base::sink(type = "output", split = FALSE)
[08:28:05.435]             base::close(...future.stdout)
[08:28:05.435]         }, add = TRUE)
[08:28:05.435]     }
[08:28:05.435]     ...future.frame <- base::sys.nframe()
[08:28:05.435]     ...future.conditions <- base::list()
[08:28:05.435]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.435]     if (FALSE) {
[08:28:05.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.435]     }
[08:28:05.435]     ...future.result <- base::tryCatch({
[08:28:05.435]         base::withCallingHandlers({
[08:28:05.435]             ...future.value <- base::withVisible(base::local({
[08:28:05.435]                 a %<-% subset(data, x < 3)$y
[08:28:05.435]                 a
[08:28:05.435]             }))
[08:28:05.435]             future::FutureResult(value = ...future.value$value, 
[08:28:05.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.435]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.435]                     ...future.globalenv.names))
[08:28:05.435]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.435]         }, condition = base::local({
[08:28:05.435]             c <- base::c
[08:28:05.435]             inherits <- base::inherits
[08:28:05.435]             invokeRestart <- base::invokeRestart
[08:28:05.435]             length <- base::length
[08:28:05.435]             list <- base::list
[08:28:05.435]             seq.int <- base::seq.int
[08:28:05.435]             signalCondition <- base::signalCondition
[08:28:05.435]             sys.calls <- base::sys.calls
[08:28:05.435]             `[[` <- base::`[[`
[08:28:05.435]             `+` <- base::`+`
[08:28:05.435]             `<<-` <- base::`<<-`
[08:28:05.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.435]                   3L)]
[08:28:05.435]             }
[08:28:05.435]             function(cond) {
[08:28:05.435]                 is_error <- inherits(cond, "error")
[08:28:05.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.435]                   NULL)
[08:28:05.435]                 if (is_error) {
[08:28:05.435]                   sessionInformation <- function() {
[08:28:05.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.435]                       search = base::search(), system = base::Sys.info())
[08:28:05.435]                   }
[08:28:05.435]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.435]                     cond$call), session = sessionInformation(), 
[08:28:05.435]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.435]                   signalCondition(cond)
[08:28:05.435]                 }
[08:28:05.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.435]                 "immediateCondition"))) {
[08:28:05.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.435]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.435]                   if (TRUE && !signal) {
[08:28:05.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.435]                     {
[08:28:05.435]                       inherits <- base::inherits
[08:28:05.435]                       invokeRestart <- base::invokeRestart
[08:28:05.435]                       is.null <- base::is.null
[08:28:05.435]                       muffled <- FALSE
[08:28:05.435]                       if (inherits(cond, "message")) {
[08:28:05.435]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.435]                         if (muffled) 
[08:28:05.435]                           invokeRestart("muffleMessage")
[08:28:05.435]                       }
[08:28:05.435]                       else if (inherits(cond, "warning")) {
[08:28:05.435]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.435]                         if (muffled) 
[08:28:05.435]                           invokeRestart("muffleWarning")
[08:28:05.435]                       }
[08:28:05.435]                       else if (inherits(cond, "condition")) {
[08:28:05.435]                         if (!is.null(pattern)) {
[08:28:05.435]                           computeRestarts <- base::computeRestarts
[08:28:05.435]                           grepl <- base::grepl
[08:28:05.435]                           restarts <- computeRestarts(cond)
[08:28:05.435]                           for (restart in restarts) {
[08:28:05.435]                             name <- restart$name
[08:28:05.435]                             if (is.null(name)) 
[08:28:05.435]                               next
[08:28:05.435]                             if (!grepl(pattern, name)) 
[08:28:05.435]                               next
[08:28:05.435]                             invokeRestart(restart)
[08:28:05.435]                             muffled <- TRUE
[08:28:05.435]                             break
[08:28:05.435]                           }
[08:28:05.435]                         }
[08:28:05.435]                       }
[08:28:05.435]                       invisible(muffled)
[08:28:05.435]                     }
[08:28:05.435]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.435]                   }
[08:28:05.435]                 }
[08:28:05.435]                 else {
[08:28:05.435]                   if (TRUE) {
[08:28:05.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.435]                     {
[08:28:05.435]                       inherits <- base::inherits
[08:28:05.435]                       invokeRestart <- base::invokeRestart
[08:28:05.435]                       is.null <- base::is.null
[08:28:05.435]                       muffled <- FALSE
[08:28:05.435]                       if (inherits(cond, "message")) {
[08:28:05.435]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.435]                         if (muffled) 
[08:28:05.435]                           invokeRestart("muffleMessage")
[08:28:05.435]                       }
[08:28:05.435]                       else if (inherits(cond, "warning")) {
[08:28:05.435]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.435]                         if (muffled) 
[08:28:05.435]                           invokeRestart("muffleWarning")
[08:28:05.435]                       }
[08:28:05.435]                       else if (inherits(cond, "condition")) {
[08:28:05.435]                         if (!is.null(pattern)) {
[08:28:05.435]                           computeRestarts <- base::computeRestarts
[08:28:05.435]                           grepl <- base::grepl
[08:28:05.435]                           restarts <- computeRestarts(cond)
[08:28:05.435]                           for (restart in restarts) {
[08:28:05.435]                             name <- restart$name
[08:28:05.435]                             if (is.null(name)) 
[08:28:05.435]                               next
[08:28:05.435]                             if (!grepl(pattern, name)) 
[08:28:05.435]                               next
[08:28:05.435]                             invokeRestart(restart)
[08:28:05.435]                             muffled <- TRUE
[08:28:05.435]                             break
[08:28:05.435]                           }
[08:28:05.435]                         }
[08:28:05.435]                       }
[08:28:05.435]                       invisible(muffled)
[08:28:05.435]                     }
[08:28:05.435]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.435]                   }
[08:28:05.435]                 }
[08:28:05.435]             }
[08:28:05.435]         }))
[08:28:05.435]     }, error = function(ex) {
[08:28:05.435]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.435]                 ...future.rng), started = ...future.startTime, 
[08:28:05.435]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.435]             version = "1.8"), class = "FutureResult")
[08:28:05.435]     }, finally = {
[08:28:05.435]         if (!identical(...future.workdir, getwd())) 
[08:28:05.435]             setwd(...future.workdir)
[08:28:05.435]         {
[08:28:05.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.435]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.435]             }
[08:28:05.435]             base::options(...future.oldOptions)
[08:28:05.435]             if (.Platform$OS.type == "windows") {
[08:28:05.435]                 old_names <- names(...future.oldEnvVars)
[08:28:05.435]                 envs <- base::Sys.getenv()
[08:28:05.435]                 names <- names(envs)
[08:28:05.435]                 common <- intersect(names, old_names)
[08:28:05.435]                 added <- setdiff(names, old_names)
[08:28:05.435]                 removed <- setdiff(old_names, names)
[08:28:05.435]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.435]                   envs[common]]
[08:28:05.435]                 NAMES <- toupper(changed)
[08:28:05.435]                 args <- list()
[08:28:05.435]                 for (kk in seq_along(NAMES)) {
[08:28:05.435]                   name <- changed[[kk]]
[08:28:05.435]                   NAME <- NAMES[[kk]]
[08:28:05.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.435]                     next
[08:28:05.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.435]                 }
[08:28:05.435]                 NAMES <- toupper(added)
[08:28:05.435]                 for (kk in seq_along(NAMES)) {
[08:28:05.435]                   name <- added[[kk]]
[08:28:05.435]                   NAME <- NAMES[[kk]]
[08:28:05.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.435]                     next
[08:28:05.435]                   args[[name]] <- ""
[08:28:05.435]                 }
[08:28:05.435]                 NAMES <- toupper(removed)
[08:28:05.435]                 for (kk in seq_along(NAMES)) {
[08:28:05.435]                   name <- removed[[kk]]
[08:28:05.435]                   NAME <- NAMES[[kk]]
[08:28:05.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.435]                     next
[08:28:05.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.435]                 }
[08:28:05.435]                 if (length(args) > 0) 
[08:28:05.435]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.435]             }
[08:28:05.435]             else {
[08:28:05.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.435]             }
[08:28:05.435]             {
[08:28:05.435]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.435]                   0L) {
[08:28:05.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.435]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.435]                   base::options(opts)
[08:28:05.435]                 }
[08:28:05.435]                 {
[08:28:05.435]                   {
[08:28:05.435]                     NULL
[08:28:05.435]                     RNGkind("Mersenne-Twister")
[08:28:05.435]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:05.435]                       inherits = FALSE)
[08:28:05.435]                   }
[08:28:05.435]                   options(future.plan = NULL)
[08:28:05.435]                   if (is.na(NA_character_)) 
[08:28:05.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.435]                     .init = FALSE)
[08:28:05.435]                 }
[08:28:05.435]             }
[08:28:05.435]         }
[08:28:05.435]     })
[08:28:05.435]     if (TRUE) {
[08:28:05.435]         base::sink(type = "output", split = FALSE)
[08:28:05.435]         if (TRUE) {
[08:28:05.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.435]         }
[08:28:05.435]         else {
[08:28:05.435]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.435]         }
[08:28:05.435]         base::close(...future.stdout)
[08:28:05.435]         ...future.stdout <- NULL
[08:28:05.435]     }
[08:28:05.435]     ...future.result$conditions <- ...future.conditions
[08:28:05.435]     ...future.result$finished <- base::Sys.time()
[08:28:05.435]     ...future.result
[08:28:05.435] }
[08:28:05.437] assign_globals() ...
[08:28:05.437] List of 1
[08:28:05.437]  $ data:'data.frame':	5 obs. of  2 variables:
[08:28:05.437]   ..$ x: int [1:5] 1 2 3 4 5
[08:28:05.437]   ..$ y: int [1:5] 1 2 3 4 5
[08:28:05.437]  - attr(*, "where")=List of 1
[08:28:05.437]   ..$ data:<environment: R_EmptyEnv> 
[08:28:05.437]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:05.437]  - attr(*, "resolved")= logi FALSE
[08:28:05.437]  - attr(*, "total_size")= num 356
[08:28:05.437]  - attr(*, "already-done")= logi TRUE
[08:28:05.444] - copied ‘data’ to environment
[08:28:05.444] assign_globals() ... done
[08:28:05.445] plan(): Setting new future strategy stack:
[08:28:05.445] List of future strategies:
[08:28:05.445] 1. multicore:
[08:28:05.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:05.445]    - tweaked: FALSE
[08:28:05.445]    - call: plan(list(sequential, strategy))
[08:28:05.447] plan(): nbrOfWorkers() = 2
[08:28:05.492] plan(): Setting new future strategy stack:
[08:28:05.492] List of future strategies:
[08:28:05.492] 1. sequential:
[08:28:05.492]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.492]    - tweaked: FALSE
[08:28:05.492]    - call: plan(list(sequential, strategy))
[08:28:05.492] 2. multicore:
[08:28:05.492]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:05.492]    - tweaked: FALSE
[08:28:05.492]    - call: plan(list(sequential, strategy))
[08:28:05.493] plan(): nbrOfWorkers() = 1
[08:28:05.493] SequentialFuture started (and completed)
[08:28:05.493] signalConditions() ...
[08:28:05.494]  - include = ‘immediateCondition’
[08:28:05.494]  - exclude = 
[08:28:05.494]  - resignal = FALSE
[08:28:05.494]  - Number of conditions: 56
[08:28:05.494] signalConditions() ... done
[08:28:05.494] - Launch lazy future ... done
[08:28:05.494] run() for ‘SequentialFuture’ ... done
[08:28:05.495] signalConditions() ...
[08:28:05.495]  - include = ‘immediateCondition’
[08:28:05.495]  - exclude = 
[08:28:05.495]  - resignal = FALSE
[08:28:05.495]  - Number of conditions: 56
[08:28:05.495] signalConditions() ... done
[08:28:05.495] Future state: ‘finished’
[08:28:05.495] signalConditions() ...
[08:28:05.495]  - include = ‘condition’
[08:28:05.496]  - exclude = ‘immediateCondition’
[08:28:05.496]  - resignal = TRUE
[08:28:05.496]  - Number of conditions: 56
[08:28:05.496]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.447] getGlobalsAndPackages() ...
[08:28:05.496]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.496]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.462] Searching for globals...
[08:28:05.496]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.466] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[08:28:05.497]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.466] Searching for globals ... DONE
[08:28:05.497]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.466] Resolving globals: FALSE
[08:28:05.497]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.466] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:05.497]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.467] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:05.497]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.467] - globals: [1] ‘data’
[08:28:05.497]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.467] 
[08:28:05.497]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.467] getGlobalsAndPackages() ... DONE
[08:28:05.498]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.467] run() for ‘Future’ ...
[08:28:05.498]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.468] - state: ‘created’
[08:28:05.498]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.468] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:05.498]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.470] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:05.498]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:05.498]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.470]   - Field: ‘label’
[08:28:05.499]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.470]   - Field: ‘local’
[08:28:05.499]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.470]   - Field: ‘owner’
[08:28:05.499]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.470]   - Field: ‘envir’
[08:28:05.499]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.470]   - Field: ‘workers’
[08:28:05.499]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.470]   - Field: ‘packages’
[08:28:05.499]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.470]   - Field: ‘gc’
[08:28:05.499]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.471]   - Field: ‘job’
[08:28:05.500]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.471]   - Field: ‘conditions’
[08:28:05.500]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.471]   - Field: ‘expr’
[08:28:05.500]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.471]   - Field: ‘uuid’
[08:28:05.500]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.471]   - Field: ‘seed’
[08:28:05.500]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.471]   - Field: ‘version’
[08:28:05.500]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.471]   - Field: ‘result’
[08:28:05.500]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.471]   - Field: ‘asynchronous’
[08:28:05.501]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.471]   - Field: ‘calls’
[08:28:05.501]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.472]   - Field: ‘globals’
[08:28:05.501]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.472]   - Field: ‘stdout’
[08:28:05.501]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.472]   - Field: ‘earlySignal’
[08:28:05.501]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.472]   - Field: ‘lazy’
[08:28:05.501]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.472]   - Field: ‘state’
[08:28:05.502]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:05.502]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.472] - Launch lazy future ...
[08:28:05.502]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.472] Packages needed by the future expression (n = 0): <none>
[08:28:05.502]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.473] Packages needed by future strategies (n = 0): <none>
[08:28:05.502]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.473] {
[08:28:05.473]     {
[08:28:05.473]         {
[08:28:05.473]             ...future.startTime <- base::Sys.time()
[08:28:05.473]             {
[08:28:05.473]                 {
[08:28:05.473]                   {
[08:28:05.473]                     {
[08:28:05.473]                       base::local({
[08:28:05.473]                         has_future <- base::requireNamespace("future", 
[08:28:05.473]                           quietly = TRUE)
[08:28:05.473]                         if (has_future) {
[08:28:05.473]                           ns <- base::getNamespace("future")
[08:28:05.473]                           version <- ns[[".package"]][["version"]]
[08:28:05.473]                           if (is.null(version)) 
[08:28:05.473]                             version <- utils::packageVersion("future")
[08:28:05.473]                         }
[08:28:05.473]                         else {
[08:28:05.473]                           version <- NULL
[08:28:05.473]                         }
[08:28:05.473]                         if (!has_future || version < "1.8.0") {
[08:28:05.473]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.473]                             "", base::R.version$version.string), 
[08:28:05.473]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:05.473]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.473]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.473]                               "release", "version")], collapse = " "), 
[08:28:05.473]                             hostname = base::Sys.info()[["nodename"]])
[08:28:05.473]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.473]                             info)
[08:28:05.473]                           info <- base::paste(info, collapse = "; ")
[08:28:05.473]                           if (!has_future) {
[08:28:05.473]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.473]                               info)
[08:28:05.473]                           }
[08:28:05.473]                           else {
[08:28:05.473]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.473]                               info, version)
[08:28:05.473]                           }
[08:28:05.473]                           base::stop(msg)
[08:28:05.473]                         }
[08:28:05.473]                       })
[08:28:05.473]                     }
[08:28:05.473]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:05.473]                     base::options(mc.cores = 1L)
[08:28:05.473]                   }
[08:28:05.473]                   ...future.strategy.old <- future::plan("list")
[08:28:05.473]                   options(future.plan = NULL)
[08:28:05.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:05.473]                 }
[08:28:05.473]                 ...future.workdir <- getwd()
[08:28:05.473]             }
[08:28:05.473]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.473]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.473]         }
[08:28:05.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:05.473]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.473]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:05.473]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.473]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.473]             base::names(...future.oldOptions))
[08:28:05.473]     }
[08:28:05.473]     if (FALSE) {
[08:28:05.473]     }
[08:28:05.473]     else {
[08:28:05.473]         if (TRUE) {
[08:28:05.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.473]                 open = "w")
[08:28:05.473]         }
[08:28:05.473]         else {
[08:28:05.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.473]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.473]         }
[08:28:05.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.473]             base::sink(type = "output", split = FALSE)
[08:28:05.473]             base::close(...future.stdout)
[08:28:05.473]         }, add = TRUE)
[08:28:05.473]     }
[08:28:05.473]     ...future.frame <- base::sys.nframe()
[08:28:05.473]     ...future.conditions <- base::list()
[08:28:05.473]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.473]     if (FALSE) {
[08:28:05.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.473]     }
[08:28:05.473]     ...future.result <- base::tryCatch({
[08:28:05.473]         base::withCallingHandlers({
[08:28:05.473]             ...future.value <- base::withVisible(base::local({
[08:28:05.473]                 withCallingHandlers({
[08:28:05.473]                   subset(data, x < 3)$y
[08:28:05.473]                 }, immediateCondition = function(cond) {
[08:28:05.473]                   save_rds <- function (object, pathname, ...) 
[08:28:05.473]                   {
[08:28:05.473]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:05.473]                     if (file_test("-f", pathname_tmp)) {
[08:28:05.473]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.473]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:05.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.473]                         fi_tmp[["mtime"]])
[08:28:05.473]                     }
[08:28:05.473]                     tryCatch({
[08:28:05.473]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:05.473]                     }, error = function(ex) {
[08:28:05.473]                       msg <- conditionMessage(ex)
[08:28:05.473]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.473]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:05.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.473]                         fi_tmp[["mtime"]], msg)
[08:28:05.473]                       ex$message <- msg
[08:28:05.473]                       stop(ex)
[08:28:05.473]                     })
[08:28:05.473]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:05.473]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:05.473]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:05.473]                       fi_tmp <- file.info(pathname_tmp)
[08:28:05.473]                       fi <- file.info(pathname)
[08:28:05.473]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:05.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:05.473]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:05.473]                         fi[["size"]], fi[["mtime"]])
[08:28:05.473]                       stop(msg)
[08:28:05.473]                     }
[08:28:05.473]                     invisible(pathname)
[08:28:05.473]                   }
[08:28:05.473]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:05.473]                     rootPath = tempdir()) 
[08:28:05.473]                   {
[08:28:05.473]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:05.473]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:05.473]                       tmpdir = path, fileext = ".rds")
[08:28:05.473]                     save_rds(obj, file)
[08:28:05.473]                   }
[08:28:05.473]                   saveImmediateCondition(cond, path = "/tmp/RtmpifSr4D/.future/immediateConditions")
[08:28:05.473]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.473]                   {
[08:28:05.473]                     inherits <- base::inherits
[08:28:05.473]                     invokeRestart <- base::invokeRestart
[08:28:05.473]                     is.null <- base::is.null
[08:28:05.473]                     muffled <- FALSE
[08:28:05.473]                     if (inherits(cond, "message")) {
[08:28:05.473]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:05.473]                       if (muffled) 
[08:28:05.473]                         invokeRestart("muffleMessage")
[08:28:05.473]                     }
[08:28:05.473]                     else if (inherits(cond, "warning")) {
[08:28:05.473]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:05.473]                       if (muffled) 
[08:28:05.473]                         invokeRestart("muffleWarning")
[08:28:05.473]                     }
[08:28:05.473]                     else if (inherits(cond, "condition")) {
[08:28:05.473]                       if (!is.null(pattern)) {
[08:28:05.473]                         computeRestarts <- base::computeRestarts
[08:28:05.473]                         grepl <- base::grepl
[08:28:05.473]                         restarts <- computeRestarts(cond)
[08:28:05.473]                         for (restart in restarts) {
[08:28:05.473]                           name <- restart$name
[08:28:05.473]                           if (is.null(name)) 
[08:28:05.473]                             next
[08:28:05.473]                           if (!grepl(pattern, name)) 
[08:28:05.473]                             next
[08:28:05.473]                           invokeRestart(restart)
[08:28:05.473]                           muffled <- TRUE
[08:28:05.473]                           break
[08:28:05.473]                         }
[08:28:05.473]                       }
[08:28:05.473]                     }
[08:28:05.473]                     invisible(muffled)
[08:28:05.473]                   }
[08:28:05.473]                   muffleCondition(cond)
[08:28:05.473]                 })
[08:28:05.473]             }))
[08:28:05.473]             future::FutureResult(value = ...future.value$value, 
[08:28:05.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.473]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.473]                     ...future.globalenv.names))
[08:28:05.473]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.473]         }, condition = base::local({
[08:28:05.473]             c <- base::c
[08:28:05.473]             inherits <- base::inherits
[08:28:05.473]             invokeRestart <- base::invokeRestart
[08:28:05.473]             length <- base::length
[08:28:05.473]             list <- base::list
[08:28:05.473]             seq.int <- base::seq.int
[08:28:05.473]             signalCondition <- base::signalCondition
[08:28:05.473]             sys.calls <- base::sys.calls
[08:28:05.473]             `[[` <- base::`[[`
[08:28:05.473]             `+` <- base::`+`
[08:28:05.473]             `<<-` <- base::`<<-`
[08:28:05.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.473]                   3L)]
[08:28:05.473]             }
[08:28:05.473]             function(cond) {
[08:28:05.473]                 is_error <- inherits(cond, "error")
[08:28:05.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.473]                   NULL)
[08:28:05.473]                 if (is_error) {
[08:28:05.473]                   sessionInformation <- function() {
[08:28:05.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.473]                       search = base::search(), system = base::Sys.info())
[08:28:05.473]                   }
[08:28:05.473]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.473]                     cond$call), session = sessionInformation(), 
[08:28:05.473]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.473]                   signalCondition(cond)
[08:28:05.473]                 }
[08:28:05.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.473]                 "immediateCondition"))) {
[08:28:05.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.473]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.473]                   if (TRUE && !signal) {
[08:28:05.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.473]                     {
[08:28:05.473]                       inherits <- base::inherits
[08:28:05.473]                       invokeRestart <- base::invokeRestart
[08:28:05.473]                       is.null <- base::is.null
[08:28:05.473]                       muffled <- FALSE
[08:28:05.473]                       if (inherits(cond, "message")) {
[08:28:05.473]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.473]                         if (muffled) 
[08:28:05.473]                           invokeRestart("muffleMessage")
[08:28:05.473]                       }
[08:28:05.473]                       else if (inherits(cond, "warning")) {
[08:28:05.473]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.473]                         if (muffled) 
[08:28:05.473]                           invokeRestart("muffleWarning")
[08:28:05.473]                       }
[08:28:05.473]                       else if (inherits(cond, "condition")) {
[08:28:05.473]                         if (!is.null(pattern)) {
[08:28:05.473]                           computeRestarts <- base::computeRestarts
[08:28:05.473]                           grepl <- base::grepl
[08:28:05.473]                           restarts <- computeRestarts(cond)
[08:28:05.473]                           for (restart in restarts) {
[08:28:05.473]                             name <- restart$name
[08:28:05.473]                             if (is.null(name)) 
[08:28:05.473]                               next
[08:28:05.473]                             if (!grepl(pattern, name)) 
[08:28:05.473]                               next
[08:28:05.473]                             invokeRestart(restart)
[08:28:05.473]                             muffled <- TRUE
[08:28:05.473]                             break
[08:28:05.473]                           }
[08:28:05.473]                         }
[08:28:05.473]                       }
[08:28:05.473]                       invisible(muffled)
[08:28:05.473]                     }
[08:28:05.473]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.473]                   }
[08:28:05.473]                 }
[08:28:05.473]                 else {
[08:28:05.473]                   if (TRUE) {
[08:28:05.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.473]                     {
[08:28:05.473]                       inherits <- base::inherits
[08:28:05.473]                       invokeRestart <- base::invokeRestart
[08:28:05.473]                       is.null <- base::is.null
[08:28:05.473]                       muffled <- FALSE
[08:28:05.473]                       if (inherits(cond, "message")) {
[08:28:05.473]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.473]                         if (muffled) 
[08:28:05.473]                           invokeRestart("muffleMessage")
[08:28:05.473]                       }
[08:28:05.473]                       else if (inherits(cond, "warning")) {
[08:28:05.473]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.473]                         if (muffled) 
[08:28:05.473]                           invokeRestart("muffleWarning")
[08:28:05.473]                       }
[08:28:05.473]                       else if (inherits(cond, "condition")) {
[08:28:05.473]                         if (!is.null(pattern)) {
[08:28:05.473]                           computeRestarts <- base::computeRestarts
[08:28:05.473]                           grepl <- base::grepl
[08:28:05.473]                           restarts <- computeRestarts(cond)
[08:28:05.473]                           for (restart in restarts) {
[08:28:05.473]                             name <- restart$name
[08:28:05.473]                             if (is.null(name)) 
[08:28:05.473]                               next
[08:28:05.473]                             if (!grepl(pattern, name)) 
[08:28:05.473]                               next
[08:28:05.473]                             invokeRestart(restart)
[08:28:05.473]                             muffled <- TRUE
[08:28:05.473]                             break
[08:28:05.473]                           }
[08:28:05.473]                         }
[08:28:05.473]                       }
[08:28:05.473]                       invisible(muffled)
[08:28:05.473]                     }
[08:28:05.473]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.473]                   }
[08:28:05.473]                 }
[08:28:05.473]             }
[08:28:05.473]         }))
[08:28:05.473]     }, error = function(ex) {
[08:28:05.473]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.473]                 ...future.rng), started = ...future.startTime, 
[08:28:05.473]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.473]             version = "1.8"), class = "FutureResult")
[08:28:05.473]     }, finally = {
[08:28:05.473]         if (!identical(...future.workdir, getwd())) 
[08:28:05.473]             setwd(...future.workdir)
[08:28:05.473]         {
[08:28:05.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.473]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.473]             }
[08:28:05.473]             base::options(...future.oldOptions)
[08:28:05.473]             if (.Platform$OS.type == "windows") {
[08:28:05.473]                 old_names <- names(...future.oldEnvVars)
[08:28:05.473]                 envs <- base::Sys.getenv()
[08:28:05.473]                 names <- names(envs)
[08:28:05.473]                 common <- intersect(names, old_names)
[08:28:05.473]                 added <- setdiff(names, old_names)
[08:28:05.473]                 removed <- setdiff(old_names, names)
[08:28:05.473]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.473]                   envs[common]]
[08:28:05.473]                 NAMES <- toupper(changed)
[08:28:05.473]                 args <- list()
[08:28:05.473]                 for (kk in seq_along(NAMES)) {
[08:28:05.473]                   name <- changed[[kk]]
[08:28:05.473]                   NAME <- NAMES[[kk]]
[08:28:05.473]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.473]                     next
[08:28:05.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.473]                 }
[08:28:05.473]                 NAMES <- toupper(added)
[08:28:05.473]                 for (kk in seq_along(NAMES)) {
[08:28:05.473]                   name <- added[[kk]]
[08:28:05.473]                   NAME <- NAMES[[kk]]
[08:28:05.473]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.473]                     next
[08:28:05.473]                   args[[name]] <- ""
[08:28:05.473]                 }
[08:28:05.473]                 NAMES <- toupper(removed)
[08:28:05.473]                 for (kk in seq_along(NAMES)) {
[08:28:05.473]                   name <- removed[[kk]]
[08:28:05.473]                   NAME <- NAMES[[kk]]
[08:28:05.473]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.473]                     next
[08:28:05.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.473]                 }
[08:28:05.473]                 if (length(args) > 0) 
[08:28:05.473]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.473]             }
[08:28:05.473]             else {
[08:28:05.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.473]             }
[08:28:05.473]             {
[08:28:05.473]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.473]                   0L) {
[08:28:05.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.473]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.473]                   base::options(opts)
[08:28:05.473]                 }
[08:28:05.473]                 {
[08:28:05.473]                   {
[08:28:05.473]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:05.473]                     NULL
[08:28:05.473]                   }
[08:28:05.473]                   options(future.plan = NULL)
[08:28:05.473]                   if (is.na(NA_character_)) 
[08:28:05.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.473]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.473]                     .init = FALSE)
[08:28:05.473]                 }
[08:28:05.473]             }
[08:28:05.473]         }
[08:28:05.473]     })
[08:28:05.473]     if (TRUE) {
[08:28:05.473]         base::sink(type = "output", split = FALSE)
[08:28:05.473]         if (TRUE) {
[08:28:05.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.473]         }
[08:28:05.473]         else {
[08:28:05.473]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.473]         }
[08:28:05.473]         base::close(...future.stdout)
[08:28:05.473]         ...future.stdout <- NULL
[08:28:05.473]     }
[08:28:05.473]     ...future.result$conditions <- ...future.conditions
[08:28:05.473]     ...future.result$finished <- base::Sys.time()
[08:28:05.473]     ...future.result
[08:28:05.473] }
[08:28:05.503]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.475] assign_globals() ...
[08:28:05.503]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.475] List of 1
[08:28:05.475]  $ data:'data.frame':	5 obs. of  2 variables:
[08:28:05.475]   ..$ x: int [1:5] 1 2 3 4 5
[08:28:05.475]   ..$ y: int [1:5] 1 2 3 4 5
[08:28:05.475]  - attr(*, "where")=List of 1
[08:28:05.475]   ..$ data:<environment: R_EmptyEnv> 
[08:28:05.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:05.475]  - attr(*, "resolved")= logi FALSE
[08:28:05.475]  - attr(*, "total_size")= num 356
[08:28:05.475]  - attr(*, "already-done")= logi TRUE
[08:28:05.503]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.479] - copied ‘data’ to environment
[08:28:05.503]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.479] assign_globals() ... done
[08:28:05.503]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.479] requestCore(): workers = 2
[08:28:05.503]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.481] MulticoreFuture started
[08:28:05.503]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.482] - Launch lazy future ... done
[08:28:05.506]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.483] run() for ‘MulticoreFuture’ ... done
[08:28:05.506]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.483] result() for MulticoreFuture ...
[08:28:05.506]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.491] result() for MulticoreFuture ...
[08:28:05.507]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.491] result() for MulticoreFuture ... done
[08:28:05.507]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.491] result() for MulticoreFuture ... done
[08:28:05.507]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.491] result() for MulticoreFuture ...
[08:28:05.507]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.491] result() for MulticoreFuture ... done
[08:28:05.507] signalConditions() ... done
[08:28:05.508] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.508] Searching for globals...
[08:28:05.509] - globals found: [3] ‘{’, ‘plan’, ‘sequential’
[08:28:05.509] Searching for globals ... DONE
[08:28:05.510] Resolving globals: FALSE
[08:28:05.510] 
[08:28:05.510] - packages: [1] ‘future’
[08:28:05.510] getGlobalsAndPackages() ... DONE
[08:28:05.511] run() for ‘Future’ ...
[08:28:05.511] - state: ‘created’
[08:28:05.511] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:05.511] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:05.511] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:05.512]   - Field: ‘label’
[08:28:05.512]   - Field: ‘local’
[08:28:05.512]   - Field: ‘owner’
[08:28:05.512]   - Field: ‘envir’
[08:28:05.512]   - Field: ‘packages’
[08:28:05.512]   - Field: ‘gc’
[08:28:05.512]   - Field: ‘conditions’
[08:28:05.512]   - Field: ‘expr’
[08:28:05.512]   - Field: ‘uuid’
[08:28:05.513]   - Field: ‘seed’
[08:28:05.513]   - Field: ‘version’
[08:28:05.513]   - Field: ‘result’
[08:28:05.513]   - Field: ‘asynchronous’
[08:28:05.513]   - Field: ‘calls’
[08:28:05.513]   - Field: ‘globals’
[08:28:05.513]   - Field: ‘stdout’
[08:28:05.513]   - Field: ‘earlySignal’
[08:28:05.513]   - Field: ‘lazy’
[08:28:05.513]   - Field: ‘state’
[08:28:05.514] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:05.514] - Launch lazy future ...
[08:28:05.514] Packages needed by the future expression (n = 1): ‘future’
[08:28:05.514] Packages needed by future strategies (n = 1): ‘future’
[08:28:05.515] {
[08:28:05.515]     {
[08:28:05.515]         {
[08:28:05.515]             ...future.startTime <- base::Sys.time()
[08:28:05.515]             {
[08:28:05.515]                 {
[08:28:05.515]                   {
[08:28:05.515]                     {
[08:28:05.515]                       base::local({
[08:28:05.515]                         has_future <- base::requireNamespace("future", 
[08:28:05.515]                           quietly = TRUE)
[08:28:05.515]                         if (has_future) {
[08:28:05.515]                           ns <- base::getNamespace("future")
[08:28:05.515]                           version <- ns[[".package"]][["version"]]
[08:28:05.515]                           if (is.null(version)) 
[08:28:05.515]                             version <- utils::packageVersion("future")
[08:28:05.515]                         }
[08:28:05.515]                         else {
[08:28:05.515]                           version <- NULL
[08:28:05.515]                         }
[08:28:05.515]                         if (!has_future || version < "1.8.0") {
[08:28:05.515]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:05.515]                             "", base::R.version$version.string), 
[08:28:05.515]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:05.515]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:05.515]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:05.515]                               "release", "version")], collapse = " "), 
[08:28:05.515]                             hostname = base::Sys.info()[["nodename"]])
[08:28:05.515]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:05.515]                             info)
[08:28:05.515]                           info <- base::paste(info, collapse = "; ")
[08:28:05.515]                           if (!has_future) {
[08:28:05.515]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:05.515]                               info)
[08:28:05.515]                           }
[08:28:05.515]                           else {
[08:28:05.515]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:05.515]                               info, version)
[08:28:05.515]                           }
[08:28:05.515]                           base::stop(msg)
[08:28:05.515]                         }
[08:28:05.515]                       })
[08:28:05.515]                     }
[08:28:05.515]                     base::local({
[08:28:05.515]                       for (pkg in "future") {
[08:28:05.515]                         base::loadNamespace(pkg)
[08:28:05.515]                         base::library(pkg, character.only = TRUE)
[08:28:05.515]                       }
[08:28:05.515]                     })
[08:28:05.515]                   }
[08:28:05.515]                   ...future.strategy.old <- future::plan("list")
[08:28:05.515]                   options(future.plan = NULL)
[08:28:05.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.515]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[08:28:05.515]                     envir = parent.frame()) 
[08:28:05.515]                   {
[08:28:05.515]                     default_workers <- missing(workers)
[08:28:05.515]                     if (is.function(workers)) 
[08:28:05.515]                       workers <- workers()
[08:28:05.515]                     workers <- structure(as.integer(workers), 
[08:28:05.515]                       class = class(workers))
[08:28:05.515]                     stop_if_not(is.finite(workers), workers >= 
[08:28:05.515]                       1L)
[08:28:05.515]                     if ((workers == 1L && !inherits(workers, 
[08:28:05.515]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[08:28:05.515]                       if (default_workers) 
[08:28:05.515]                         supportsMulticore(warn = TRUE)
[08:28:05.515]                       return(sequential(..., envir = envir))
[08:28:05.515]                     }
[08:28:05.515]                     oopts <- options(mc.cores = workers)
[08:28:05.515]                     on.exit(options(oopts))
[08:28:05.515]                     future <- MulticoreFuture(..., workers = workers, 
[08:28:05.515]                       envir = envir)
[08:28:05.515]                     if (!future$lazy) 
[08:28:05.515]                       future <- run(future)
[08:28:05.515]                     invisible(future)
[08:28:05.515]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:05.515]                 }
[08:28:05.515]                 ...future.workdir <- getwd()
[08:28:05.515]             }
[08:28:05.515]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:05.515]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:05.515]         }
[08:28:05.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:05.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:05.515]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:05.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:05.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:05.515]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:05.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:05.515]             base::names(...future.oldOptions))
[08:28:05.515]     }
[08:28:05.515]     if (FALSE) {
[08:28:05.515]     }
[08:28:05.515]     else {
[08:28:05.515]         if (TRUE) {
[08:28:05.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:05.515]                 open = "w")
[08:28:05.515]         }
[08:28:05.515]         else {
[08:28:05.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:05.515]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:05.515]         }
[08:28:05.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:05.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:05.515]             base::sink(type = "output", split = FALSE)
[08:28:05.515]             base::close(...future.stdout)
[08:28:05.515]         }, add = TRUE)
[08:28:05.515]     }
[08:28:05.515]     ...future.frame <- base::sys.nframe()
[08:28:05.515]     ...future.conditions <- base::list()
[08:28:05.515]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:05.515]     if (FALSE) {
[08:28:05.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:05.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:05.515]     }
[08:28:05.515]     ...future.result <- base::tryCatch({
[08:28:05.515]         base::withCallingHandlers({
[08:28:05.515]             ...future.value <- base::withVisible(base::local({
[08:28:05.515]                 plan(sequential)
[08:28:05.515]             }))
[08:28:05.515]             future::FutureResult(value = ...future.value$value, 
[08:28:05.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.515]                   ...future.rng), globalenv = if (FALSE) 
[08:28:05.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:05.515]                     ...future.globalenv.names))
[08:28:05.515]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:05.515]         }, condition = base::local({
[08:28:05.515]             c <- base::c
[08:28:05.515]             inherits <- base::inherits
[08:28:05.515]             invokeRestart <- base::invokeRestart
[08:28:05.515]             length <- base::length
[08:28:05.515]             list <- base::list
[08:28:05.515]             seq.int <- base::seq.int
[08:28:05.515]             signalCondition <- base::signalCondition
[08:28:05.515]             sys.calls <- base::sys.calls
[08:28:05.515]             `[[` <- base::`[[`
[08:28:05.515]             `+` <- base::`+`
[08:28:05.515]             `<<-` <- base::`<<-`
[08:28:05.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:05.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:05.515]                   3L)]
[08:28:05.515]             }
[08:28:05.515]             function(cond) {
[08:28:05.515]                 is_error <- inherits(cond, "error")
[08:28:05.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:05.515]                   NULL)
[08:28:05.515]                 if (is_error) {
[08:28:05.515]                   sessionInformation <- function() {
[08:28:05.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:05.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:05.515]                       search = base::search(), system = base::Sys.info())
[08:28:05.515]                   }
[08:28:05.515]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:05.515]                     cond$call), session = sessionInformation(), 
[08:28:05.515]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:05.515]                   signalCondition(cond)
[08:28:05.515]                 }
[08:28:05.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:05.515]                 "immediateCondition"))) {
[08:28:05.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:05.515]                   ...future.conditions[[length(...future.conditions) + 
[08:28:05.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:05.515]                   if (TRUE && !signal) {
[08:28:05.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.515]                     {
[08:28:05.515]                       inherits <- base::inherits
[08:28:05.515]                       invokeRestart <- base::invokeRestart
[08:28:05.515]                       is.null <- base::is.null
[08:28:05.515]                       muffled <- FALSE
[08:28:05.515]                       if (inherits(cond, "message")) {
[08:28:05.515]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.515]                         if (muffled) 
[08:28:05.515]                           invokeRestart("muffleMessage")
[08:28:05.515]                       }
[08:28:05.515]                       else if (inherits(cond, "warning")) {
[08:28:05.515]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.515]                         if (muffled) 
[08:28:05.515]                           invokeRestart("muffleWarning")
[08:28:05.515]                       }
[08:28:05.515]                       else if (inherits(cond, "condition")) {
[08:28:05.515]                         if (!is.null(pattern)) {
[08:28:05.515]                           computeRestarts <- base::computeRestarts
[08:28:05.515]                           grepl <- base::grepl
[08:28:05.515]                           restarts <- computeRestarts(cond)
[08:28:05.515]                           for (restart in restarts) {
[08:28:05.515]                             name <- restart$name
[08:28:05.515]                             if (is.null(name)) 
[08:28:05.515]                               next
[08:28:05.515]                             if (!grepl(pattern, name)) 
[08:28:05.515]                               next
[08:28:05.515]                             invokeRestart(restart)
[08:28:05.515]                             muffled <- TRUE
[08:28:05.515]                             break
[08:28:05.515]                           }
[08:28:05.515]                         }
[08:28:05.515]                       }
[08:28:05.515]                       invisible(muffled)
[08:28:05.515]                     }
[08:28:05.515]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.515]                   }
[08:28:05.515]                 }
[08:28:05.515]                 else {
[08:28:05.515]                   if (TRUE) {
[08:28:05.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:05.515]                     {
[08:28:05.515]                       inherits <- base::inherits
[08:28:05.515]                       invokeRestart <- base::invokeRestart
[08:28:05.515]                       is.null <- base::is.null
[08:28:05.515]                       muffled <- FALSE
[08:28:05.515]                       if (inherits(cond, "message")) {
[08:28:05.515]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:05.515]                         if (muffled) 
[08:28:05.515]                           invokeRestart("muffleMessage")
[08:28:05.515]                       }
[08:28:05.515]                       else if (inherits(cond, "warning")) {
[08:28:05.515]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:05.515]                         if (muffled) 
[08:28:05.515]                           invokeRestart("muffleWarning")
[08:28:05.515]                       }
[08:28:05.515]                       else if (inherits(cond, "condition")) {
[08:28:05.515]                         if (!is.null(pattern)) {
[08:28:05.515]                           computeRestarts <- base::computeRestarts
[08:28:05.515]                           grepl <- base::grepl
[08:28:05.515]                           restarts <- computeRestarts(cond)
[08:28:05.515]                           for (restart in restarts) {
[08:28:05.515]                             name <- restart$name
[08:28:05.515]                             if (is.null(name)) 
[08:28:05.515]                               next
[08:28:05.515]                             if (!grepl(pattern, name)) 
[08:28:05.515]                               next
[08:28:05.515]                             invokeRestart(restart)
[08:28:05.515]                             muffled <- TRUE
[08:28:05.515]                             break
[08:28:05.515]                           }
[08:28:05.515]                         }
[08:28:05.515]                       }
[08:28:05.515]                       invisible(muffled)
[08:28:05.515]                     }
[08:28:05.515]                     muffleCondition(cond, pattern = "^muffle")
[08:28:05.515]                   }
[08:28:05.515]                 }
[08:28:05.515]             }
[08:28:05.515]         }))
[08:28:05.515]     }, error = function(ex) {
[08:28:05.515]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:05.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:05.515]                 ...future.rng), started = ...future.startTime, 
[08:28:05.515]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:05.515]             version = "1.8"), class = "FutureResult")
[08:28:05.515]     }, finally = {
[08:28:05.515]         if (!identical(...future.workdir, getwd())) 
[08:28:05.515]             setwd(...future.workdir)
[08:28:05.515]         {
[08:28:05.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:05.515]                 ...future.oldOptions$nwarnings <- NULL
[08:28:05.515]             }
[08:28:05.515]             base::options(...future.oldOptions)
[08:28:05.515]             if (.Platform$OS.type == "windows") {
[08:28:05.515]                 old_names <- names(...future.oldEnvVars)
[08:28:05.515]                 envs <- base::Sys.getenv()
[08:28:05.515]                 names <- names(envs)
[08:28:05.515]                 common <- intersect(names, old_names)
[08:28:05.515]                 added <- setdiff(names, old_names)
[08:28:05.515]                 removed <- setdiff(old_names, names)
[08:28:05.515]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:05.515]                   envs[common]]
[08:28:05.515]                 NAMES <- toupper(changed)
[08:28:05.515]                 args <- list()
[08:28:05.515]                 for (kk in seq_along(NAMES)) {
[08:28:05.515]                   name <- changed[[kk]]
[08:28:05.515]                   NAME <- NAMES[[kk]]
[08:28:05.515]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.515]                     next
[08:28:05.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.515]                 }
[08:28:05.515]                 NAMES <- toupper(added)
[08:28:05.515]                 for (kk in seq_along(NAMES)) {
[08:28:05.515]                   name <- added[[kk]]
[08:28:05.515]                   NAME <- NAMES[[kk]]
[08:28:05.515]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.515]                     next
[08:28:05.515]                   args[[name]] <- ""
[08:28:05.515]                 }
[08:28:05.515]                 NAMES <- toupper(removed)
[08:28:05.515]                 for (kk in seq_along(NAMES)) {
[08:28:05.515]                   name <- removed[[kk]]
[08:28:05.515]                   NAME <- NAMES[[kk]]
[08:28:05.515]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:05.515]                     next
[08:28:05.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:05.515]                 }
[08:28:05.515]                 if (length(args) > 0) 
[08:28:05.515]                   base::do.call(base::Sys.setenv, args = args)
[08:28:05.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:05.515]             }
[08:28:05.515]             else {
[08:28:05.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:05.515]             }
[08:28:05.515]             {
[08:28:05.515]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:05.515]                   0L) {
[08:28:05.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:05.515]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:05.515]                   base::options(opts)
[08:28:05.515]                 }
[08:28:05.515]                 {
[08:28:05.515]                   {
[08:28:05.515]                     NULL
[08:28:05.515]                     RNGkind("Mersenne-Twister")
[08:28:05.515]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:05.515]                       inherits = FALSE)
[08:28:05.515]                   }
[08:28:05.515]                   options(future.plan = NULL)
[08:28:05.515]                   if (is.na(NA_character_)) 
[08:28:05.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:05.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:05.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:05.515]                     .init = FALSE)
[08:28:05.515]                 }
[08:28:05.515]             }
[08:28:05.515]         }
[08:28:05.515]     })
[08:28:05.515]     if (TRUE) {
[08:28:05.515]         base::sink(type = "output", split = FALSE)
[08:28:05.515]         if (TRUE) {
[08:28:05.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:05.515]         }
[08:28:05.515]         else {
[08:28:05.515]             ...future.result["stdout"] <- base::list(NULL)
[08:28:05.515]         }
[08:28:05.515]         base::close(...future.stdout)
[08:28:05.515]         ...future.stdout <- NULL
[08:28:05.515]     }
[08:28:05.515]     ...future.result$conditions <- ...future.conditions
[08:28:05.515]     ...future.result$finished <- base::Sys.time()
[08:28:05.515]     ...future.result
[08:28:05.515] }
[08:28:05.517] plan(): Setting new future strategy stack:
[08:28:05.517] List of future strategies:
[08:28:05.517] 1. multicore:
[08:28:05.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:05.517]    - tweaked: FALSE
[08:28:05.517]    - call: plan(list(sequential, strategy))
[08:28:05.519] plan(): nbrOfWorkers() = 2
[08:28:05.537] plan(): Setting new future strategy stack:
[08:28:05.537] List of future strategies:
[08:28:05.537] 1. sequential:
[08:28:05.537]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.537]    - tweaked: FALSE
[08:28:05.537]    - call: plan(list(sequential, strategy))
[08:28:05.537] 2. multicore:
[08:28:05.537]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:05.537]    - tweaked: FALSE
[08:28:05.537]    - call: plan(list(sequential, strategy))
[08:28:05.537] plan(): nbrOfWorkers() = 1
[08:28:05.537] SequentialFuture started (and completed)
[08:28:05.538] signalConditions() ...
[08:28:05.538]  - include = ‘immediateCondition’
[08:28:05.538]  - exclude = 
[08:28:05.538]  - resignal = FALSE
[08:28:05.538]  - Number of conditions: 3
[08:28:05.538] signalConditions() ... done
[08:28:05.538] - Launch lazy future ... done
[08:28:05.538] run() for ‘SequentialFuture’ ... done
[08:28:05.538] signalConditions() ...
[08:28:05.538]  - include = ‘immediateCondition’
[08:28:05.538]  - exclude = 
[08:28:05.539]  - resignal = FALSE
[08:28:05.539]  - Number of conditions: 3
[08:28:05.539] signalConditions() ... done
[08:28:05.539] Future state: ‘finished’
[08:28:05.539] signalConditions() ...
[08:28:05.539]  - include = ‘condition’
[08:28:05.539]  - exclude = ‘immediateCondition’
[08:28:05.539]  - resignal = TRUE
[08:28:05.539]  - Number of conditions: 3
[08:28:05.539]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.520] plan(): Setting new future strategy stack:
[08:28:05.539]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.520] List of future strategies:
[08:28:05.520] 1. sequential:
[08:28:05.520]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:05.520]    - tweaked: FALSE
[08:28:05.520]    - call: plan(sequential)
[08:28:05.540]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:05.536] plan(): nbrOfWorkers() = 1
[08:28:05.540] signalConditions() ... done
List of future strategies:
1. multicore:
   - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
   - tweaked: FALSE
   - call: plan(list(sequential, strategy))
- Strategy: multicore ... DONE
- Strategy: multisession ...
[08:28:05.540] plan(): Setting new future strategy stack:
[08:28:05.540] List of future strategies:
[08:28:05.540] 1. multisession:
[08:28:05.540]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:05.540]    - tweaked: FALSE
[08:28:05.540]    - call: plan(strategy)
[08:28:05.541] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:28:05.541] multisession:
[08:28:05.541] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:05.541] - tweaked: FALSE
[08:28:05.541] - call: plan(strategy)
[08:28:05.544] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:05.545] Not searching for globals
[08:28:05.545] - globals: [0] <none>
[08:28:05.545] getGlobalsAndPackages() ... DONE
[08:28:06.030] Packages needed by the future expression (n = 0): <none>
[08:28:06.030] Packages needed by future strategies (n = 0): <none>
[08:28:06.031] {
[08:28:06.031]     {
[08:28:06.031]         {
[08:28:06.031]             ...future.startTime <- base::Sys.time()
[08:28:06.031]             {
[08:28:06.031]                 {
[08:28:06.031]                   {
[08:28:06.031]                     {
[08:28:06.031]                       base::local({
[08:28:06.031]                         has_future <- base::requireNamespace("future", 
[08:28:06.031]                           quietly = TRUE)
[08:28:06.031]                         if (has_future) {
[08:28:06.031]                           ns <- base::getNamespace("future")
[08:28:06.031]                           version <- ns[[".package"]][["version"]]
[08:28:06.031]                           if (is.null(version)) 
[08:28:06.031]                             version <- utils::packageVersion("future")
[08:28:06.031]                         }
[08:28:06.031]                         else {
[08:28:06.031]                           version <- NULL
[08:28:06.031]                         }
[08:28:06.031]                         if (!has_future || version < "1.8.0") {
[08:28:06.031]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:06.031]                             "", base::R.version$version.string), 
[08:28:06.031]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:06.031]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:06.031]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:06.031]                               "release", "version")], collapse = " "), 
[08:28:06.031]                             hostname = base::Sys.info()[["nodename"]])
[08:28:06.031]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:06.031]                             info)
[08:28:06.031]                           info <- base::paste(info, collapse = "; ")
[08:28:06.031]                           if (!has_future) {
[08:28:06.031]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:06.031]                               info)
[08:28:06.031]                           }
[08:28:06.031]                           else {
[08:28:06.031]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:06.031]                               info, version)
[08:28:06.031]                           }
[08:28:06.031]                           base::stop(msg)
[08:28:06.031]                         }
[08:28:06.031]                       })
[08:28:06.031]                     }
[08:28:06.031]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:06.031]                     base::options(mc.cores = 1L)
[08:28:06.031]                   }
[08:28:06.031]                   ...future.strategy.old <- future::plan("list")
[08:28:06.031]                   options(future.plan = NULL)
[08:28:06.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:06.031]                 }
[08:28:06.031]                 ...future.workdir <- getwd()
[08:28:06.031]             }
[08:28:06.031]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:06.031]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:06.031]         }
[08:28:06.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:06.031]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:06.031]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:06.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:06.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:06.031]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:06.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:06.031]             base::names(...future.oldOptions))
[08:28:06.031]     }
[08:28:06.031]     if (FALSE) {
[08:28:06.031]     }
[08:28:06.031]     else {
[08:28:06.031]         if (TRUE) {
[08:28:06.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:06.031]                 open = "w")
[08:28:06.031]         }
[08:28:06.031]         else {
[08:28:06.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:06.031]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:06.031]         }
[08:28:06.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:06.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:06.031]             base::sink(type = "output", split = FALSE)
[08:28:06.031]             base::close(...future.stdout)
[08:28:06.031]         }, add = TRUE)
[08:28:06.031]     }
[08:28:06.031]     ...future.frame <- base::sys.nframe()
[08:28:06.031]     ...future.conditions <- base::list()
[08:28:06.031]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:06.031]     if (FALSE) {
[08:28:06.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:06.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:06.031]     }
[08:28:06.031]     ...future.result <- base::tryCatch({
[08:28:06.031]         base::withCallingHandlers({
[08:28:06.031]             ...future.value <- base::withVisible(base::local({
[08:28:06.031]                 ...future.makeSendCondition <- base::local({
[08:28:06.031]                   sendCondition <- NULL
[08:28:06.031]                   function(frame = 1L) {
[08:28:06.031]                     if (is.function(sendCondition)) 
[08:28:06.031]                       return(sendCondition)
[08:28:06.031]                     ns <- getNamespace("parallel")
[08:28:06.031]                     if (exists("sendData", mode = "function", 
[08:28:06.031]                       envir = ns)) {
[08:28:06.031]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:06.031]                         envir = ns)
[08:28:06.031]                       envir <- sys.frame(frame)
[08:28:06.031]                       master <- NULL
[08:28:06.031]                       while (!identical(envir, .GlobalEnv) && 
[08:28:06.031]                         !identical(envir, emptyenv())) {
[08:28:06.031]                         if (exists("master", mode = "list", envir = envir, 
[08:28:06.031]                           inherits = FALSE)) {
[08:28:06.031]                           master <- get("master", mode = "list", 
[08:28:06.031]                             envir = envir, inherits = FALSE)
[08:28:06.031]                           if (inherits(master, c("SOCKnode", 
[08:28:06.031]                             "SOCK0node"))) {
[08:28:06.031]                             sendCondition <<- function(cond) {
[08:28:06.031]                               data <- list(type = "VALUE", value = cond, 
[08:28:06.031]                                 success = TRUE)
[08:28:06.031]                               parallel_sendData(master, data)
[08:28:06.031]                             }
[08:28:06.031]                             return(sendCondition)
[08:28:06.031]                           }
[08:28:06.031]                         }
[08:28:06.031]                         frame <- frame + 1L
[08:28:06.031]                         envir <- sys.frame(frame)
[08:28:06.031]                       }
[08:28:06.031]                     }
[08:28:06.031]                     sendCondition <<- function(cond) NULL
[08:28:06.031]                   }
[08:28:06.031]                 })
[08:28:06.031]                 withCallingHandlers({
[08:28:06.031]                   NA
[08:28:06.031]                 }, immediateCondition = function(cond) {
[08:28:06.031]                   sendCondition <- ...future.makeSendCondition()
[08:28:06.031]                   sendCondition(cond)
[08:28:06.031]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.031]                   {
[08:28:06.031]                     inherits <- base::inherits
[08:28:06.031]                     invokeRestart <- base::invokeRestart
[08:28:06.031]                     is.null <- base::is.null
[08:28:06.031]                     muffled <- FALSE
[08:28:06.031]                     if (inherits(cond, "message")) {
[08:28:06.031]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:06.031]                       if (muffled) 
[08:28:06.031]                         invokeRestart("muffleMessage")
[08:28:06.031]                     }
[08:28:06.031]                     else if (inherits(cond, "warning")) {
[08:28:06.031]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:06.031]                       if (muffled) 
[08:28:06.031]                         invokeRestart("muffleWarning")
[08:28:06.031]                     }
[08:28:06.031]                     else if (inherits(cond, "condition")) {
[08:28:06.031]                       if (!is.null(pattern)) {
[08:28:06.031]                         computeRestarts <- base::computeRestarts
[08:28:06.031]                         grepl <- base::grepl
[08:28:06.031]                         restarts <- computeRestarts(cond)
[08:28:06.031]                         for (restart in restarts) {
[08:28:06.031]                           name <- restart$name
[08:28:06.031]                           if (is.null(name)) 
[08:28:06.031]                             next
[08:28:06.031]                           if (!grepl(pattern, name)) 
[08:28:06.031]                             next
[08:28:06.031]                           invokeRestart(restart)
[08:28:06.031]                           muffled <- TRUE
[08:28:06.031]                           break
[08:28:06.031]                         }
[08:28:06.031]                       }
[08:28:06.031]                     }
[08:28:06.031]                     invisible(muffled)
[08:28:06.031]                   }
[08:28:06.031]                   muffleCondition(cond)
[08:28:06.031]                 })
[08:28:06.031]             }))
[08:28:06.031]             future::FutureResult(value = ...future.value$value, 
[08:28:06.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.031]                   ...future.rng), globalenv = if (FALSE) 
[08:28:06.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:06.031]                     ...future.globalenv.names))
[08:28:06.031]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:06.031]         }, condition = base::local({
[08:28:06.031]             c <- base::c
[08:28:06.031]             inherits <- base::inherits
[08:28:06.031]             invokeRestart <- base::invokeRestart
[08:28:06.031]             length <- base::length
[08:28:06.031]             list <- base::list
[08:28:06.031]             seq.int <- base::seq.int
[08:28:06.031]             signalCondition <- base::signalCondition
[08:28:06.031]             sys.calls <- base::sys.calls
[08:28:06.031]             `[[` <- base::`[[`
[08:28:06.031]             `+` <- base::`+`
[08:28:06.031]             `<<-` <- base::`<<-`
[08:28:06.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:06.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:06.031]                   3L)]
[08:28:06.031]             }
[08:28:06.031]             function(cond) {
[08:28:06.031]                 is_error <- inherits(cond, "error")
[08:28:06.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:06.031]                   NULL)
[08:28:06.031]                 if (is_error) {
[08:28:06.031]                   sessionInformation <- function() {
[08:28:06.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:06.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:06.031]                       search = base::search(), system = base::Sys.info())
[08:28:06.031]                   }
[08:28:06.031]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:06.031]                     cond$call), session = sessionInformation(), 
[08:28:06.031]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:06.031]                   signalCondition(cond)
[08:28:06.031]                 }
[08:28:06.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:06.031]                 "immediateCondition"))) {
[08:28:06.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:06.031]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:06.031]                   if (TRUE && !signal) {
[08:28:06.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.031]                     {
[08:28:06.031]                       inherits <- base::inherits
[08:28:06.031]                       invokeRestart <- base::invokeRestart
[08:28:06.031]                       is.null <- base::is.null
[08:28:06.031]                       muffled <- FALSE
[08:28:06.031]                       if (inherits(cond, "message")) {
[08:28:06.031]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.031]                         if (muffled) 
[08:28:06.031]                           invokeRestart("muffleMessage")
[08:28:06.031]                       }
[08:28:06.031]                       else if (inherits(cond, "warning")) {
[08:28:06.031]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.031]                         if (muffled) 
[08:28:06.031]                           invokeRestart("muffleWarning")
[08:28:06.031]                       }
[08:28:06.031]                       else if (inherits(cond, "condition")) {
[08:28:06.031]                         if (!is.null(pattern)) {
[08:28:06.031]                           computeRestarts <- base::computeRestarts
[08:28:06.031]                           grepl <- base::grepl
[08:28:06.031]                           restarts <- computeRestarts(cond)
[08:28:06.031]                           for (restart in restarts) {
[08:28:06.031]                             name <- restart$name
[08:28:06.031]                             if (is.null(name)) 
[08:28:06.031]                               next
[08:28:06.031]                             if (!grepl(pattern, name)) 
[08:28:06.031]                               next
[08:28:06.031]                             invokeRestart(restart)
[08:28:06.031]                             muffled <- TRUE
[08:28:06.031]                             break
[08:28:06.031]                           }
[08:28:06.031]                         }
[08:28:06.031]                       }
[08:28:06.031]                       invisible(muffled)
[08:28:06.031]                     }
[08:28:06.031]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.031]                   }
[08:28:06.031]                 }
[08:28:06.031]                 else {
[08:28:06.031]                   if (TRUE) {
[08:28:06.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.031]                     {
[08:28:06.031]                       inherits <- base::inherits
[08:28:06.031]                       invokeRestart <- base::invokeRestart
[08:28:06.031]                       is.null <- base::is.null
[08:28:06.031]                       muffled <- FALSE
[08:28:06.031]                       if (inherits(cond, "message")) {
[08:28:06.031]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.031]                         if (muffled) 
[08:28:06.031]                           invokeRestart("muffleMessage")
[08:28:06.031]                       }
[08:28:06.031]                       else if (inherits(cond, "warning")) {
[08:28:06.031]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.031]                         if (muffled) 
[08:28:06.031]                           invokeRestart("muffleWarning")
[08:28:06.031]                       }
[08:28:06.031]                       else if (inherits(cond, "condition")) {
[08:28:06.031]                         if (!is.null(pattern)) {
[08:28:06.031]                           computeRestarts <- base::computeRestarts
[08:28:06.031]                           grepl <- base::grepl
[08:28:06.031]                           restarts <- computeRestarts(cond)
[08:28:06.031]                           for (restart in restarts) {
[08:28:06.031]                             name <- restart$name
[08:28:06.031]                             if (is.null(name)) 
[08:28:06.031]                               next
[08:28:06.031]                             if (!grepl(pattern, name)) 
[08:28:06.031]                               next
[08:28:06.031]                             invokeRestart(restart)
[08:28:06.031]                             muffled <- TRUE
[08:28:06.031]                             break
[08:28:06.031]                           }
[08:28:06.031]                         }
[08:28:06.031]                       }
[08:28:06.031]                       invisible(muffled)
[08:28:06.031]                     }
[08:28:06.031]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.031]                   }
[08:28:06.031]                 }
[08:28:06.031]             }
[08:28:06.031]         }))
[08:28:06.031]     }, error = function(ex) {
[08:28:06.031]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:06.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.031]                 ...future.rng), started = ...future.startTime, 
[08:28:06.031]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:06.031]             version = "1.8"), class = "FutureResult")
[08:28:06.031]     }, finally = {
[08:28:06.031]         if (!identical(...future.workdir, getwd())) 
[08:28:06.031]             setwd(...future.workdir)
[08:28:06.031]         {
[08:28:06.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:06.031]                 ...future.oldOptions$nwarnings <- NULL
[08:28:06.031]             }
[08:28:06.031]             base::options(...future.oldOptions)
[08:28:06.031]             if (.Platform$OS.type == "windows") {
[08:28:06.031]                 old_names <- names(...future.oldEnvVars)
[08:28:06.031]                 envs <- base::Sys.getenv()
[08:28:06.031]                 names <- names(envs)
[08:28:06.031]                 common <- intersect(names, old_names)
[08:28:06.031]                 added <- setdiff(names, old_names)
[08:28:06.031]                 removed <- setdiff(old_names, names)
[08:28:06.031]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:06.031]                   envs[common]]
[08:28:06.031]                 NAMES <- toupper(changed)
[08:28:06.031]                 args <- list()
[08:28:06.031]                 for (kk in seq_along(NAMES)) {
[08:28:06.031]                   name <- changed[[kk]]
[08:28:06.031]                   NAME <- NAMES[[kk]]
[08:28:06.031]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.031]                     next
[08:28:06.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.031]                 }
[08:28:06.031]                 NAMES <- toupper(added)
[08:28:06.031]                 for (kk in seq_along(NAMES)) {
[08:28:06.031]                   name <- added[[kk]]
[08:28:06.031]                   NAME <- NAMES[[kk]]
[08:28:06.031]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.031]                     next
[08:28:06.031]                   args[[name]] <- ""
[08:28:06.031]                 }
[08:28:06.031]                 NAMES <- toupper(removed)
[08:28:06.031]                 for (kk in seq_along(NAMES)) {
[08:28:06.031]                   name <- removed[[kk]]
[08:28:06.031]                   NAME <- NAMES[[kk]]
[08:28:06.031]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.031]                     next
[08:28:06.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.031]                 }
[08:28:06.031]                 if (length(args) > 0) 
[08:28:06.031]                   base::do.call(base::Sys.setenv, args = args)
[08:28:06.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:06.031]             }
[08:28:06.031]             else {
[08:28:06.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:06.031]             }
[08:28:06.031]             {
[08:28:06.031]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:06.031]                   0L) {
[08:28:06.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:06.031]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:06.031]                   base::options(opts)
[08:28:06.031]                 }
[08:28:06.031]                 {
[08:28:06.031]                   {
[08:28:06.031]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:06.031]                     NULL
[08:28:06.031]                   }
[08:28:06.031]                   options(future.plan = NULL)
[08:28:06.031]                   if (is.na(NA_character_)) 
[08:28:06.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:06.031]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:06.031]                     .init = FALSE)
[08:28:06.031]                 }
[08:28:06.031]             }
[08:28:06.031]         }
[08:28:06.031]     })
[08:28:06.031]     if (TRUE) {
[08:28:06.031]         base::sink(type = "output", split = FALSE)
[08:28:06.031]         if (TRUE) {
[08:28:06.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:06.031]         }
[08:28:06.031]         else {
[08:28:06.031]             ...future.result["stdout"] <- base::list(NULL)
[08:28:06.031]         }
[08:28:06.031]         base::close(...future.stdout)
[08:28:06.031]         ...future.stdout <- NULL
[08:28:06.031]     }
[08:28:06.031]     ...future.result$conditions <- ...future.conditions
[08:28:06.031]     ...future.result$finished <- base::Sys.time()
[08:28:06.031]     ...future.result
[08:28:06.031] }
[08:28:06.083] MultisessionFuture started
[08:28:06.083] result() for ClusterFuture ...
[08:28:06.084] receiveMessageFromWorker() for ClusterFuture ...
[08:28:06.084] - Validating connection of MultisessionFuture
[08:28:06.115] - received message: FutureResult
[08:28:06.115] - Received FutureResult
[08:28:06.115] - Erased future from FutureRegistry
[08:28:06.115] result() for ClusterFuture ...
[08:28:06.115] - result already collected: FutureResult
[08:28:06.115] result() for ClusterFuture ... done
[08:28:06.115] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:06.115] result() for ClusterFuture ... done
[08:28:06.115] result() for ClusterFuture ...
[08:28:06.115] - result already collected: FutureResult
[08:28:06.116] result() for ClusterFuture ... done
[08:28:06.116] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:28:06.117] plan(): nbrOfWorkers() = 2
[08:28:06.118] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:06.118] Searching for globals...
[08:28:06.118] - globals found: [1] ‘getOption’
[08:28:06.118] Searching for globals ... DONE
[08:28:06.118] Resolving globals: FALSE
[08:28:06.119] 
[08:28:06.119] 
[08:28:06.119] getGlobalsAndPackages() ... DONE
[08:28:06.119] run() for ‘Future’ ...
[08:28:06.119] - state: ‘created’
[08:28:06.119] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:06.133] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:06.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:06.133]   - Field: ‘node’
[08:28:06.133]   - Field: ‘label’
[08:28:06.133]   - Field: ‘local’
[08:28:06.133]   - Field: ‘owner’
[08:28:06.133]   - Field: ‘envir’
[08:28:06.134]   - Field: ‘workers’
[08:28:06.134]   - Field: ‘packages’
[08:28:06.134]   - Field: ‘gc’
[08:28:06.134]   - Field: ‘conditions’
[08:28:06.134]   - Field: ‘persistent’
[08:28:06.134]   - Field: ‘expr’
[08:28:06.134]   - Field: ‘uuid’
[08:28:06.134]   - Field: ‘seed’
[08:28:06.134]   - Field: ‘version’
[08:28:06.134]   - Field: ‘result’
[08:28:06.134]   - Field: ‘asynchronous’
[08:28:06.134]   - Field: ‘calls’
[08:28:06.135]   - Field: ‘globals’
[08:28:06.135]   - Field: ‘stdout’
[08:28:06.135]   - Field: ‘earlySignal’
[08:28:06.135]   - Field: ‘lazy’
[08:28:06.135]   - Field: ‘state’
[08:28:06.135] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:06.135] - Launch lazy future ...
[08:28:06.135] Packages needed by the future expression (n = 0): <none>
[08:28:06.135] Packages needed by future strategies (n = 0): <none>
[08:28:06.136] {
[08:28:06.136]     {
[08:28:06.136]         {
[08:28:06.136]             ...future.startTime <- base::Sys.time()
[08:28:06.136]             {
[08:28:06.136]                 {
[08:28:06.136]                   {
[08:28:06.136]                     {
[08:28:06.136]                       base::local({
[08:28:06.136]                         has_future <- base::requireNamespace("future", 
[08:28:06.136]                           quietly = TRUE)
[08:28:06.136]                         if (has_future) {
[08:28:06.136]                           ns <- base::getNamespace("future")
[08:28:06.136]                           version <- ns[[".package"]][["version"]]
[08:28:06.136]                           if (is.null(version)) 
[08:28:06.136]                             version <- utils::packageVersion("future")
[08:28:06.136]                         }
[08:28:06.136]                         else {
[08:28:06.136]                           version <- NULL
[08:28:06.136]                         }
[08:28:06.136]                         if (!has_future || version < "1.8.0") {
[08:28:06.136]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:06.136]                             "", base::R.version$version.string), 
[08:28:06.136]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:06.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:06.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:06.136]                               "release", "version")], collapse = " "), 
[08:28:06.136]                             hostname = base::Sys.info()[["nodename"]])
[08:28:06.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:06.136]                             info)
[08:28:06.136]                           info <- base::paste(info, collapse = "; ")
[08:28:06.136]                           if (!has_future) {
[08:28:06.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:06.136]                               info)
[08:28:06.136]                           }
[08:28:06.136]                           else {
[08:28:06.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:06.136]                               info, version)
[08:28:06.136]                           }
[08:28:06.136]                           base::stop(msg)
[08:28:06.136]                         }
[08:28:06.136]                       })
[08:28:06.136]                     }
[08:28:06.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:06.136]                     base::options(mc.cores = 1L)
[08:28:06.136]                   }
[08:28:06.136]                   ...future.strategy.old <- future::plan("list")
[08:28:06.136]                   options(future.plan = NULL)
[08:28:06.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:06.136]                 }
[08:28:06.136]                 ...future.workdir <- getwd()
[08:28:06.136]             }
[08:28:06.136]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:06.136]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:06.136]         }
[08:28:06.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:06.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:06.136]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:06.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:06.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:06.136]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:06.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:06.136]             base::names(...future.oldOptions))
[08:28:06.136]     }
[08:28:06.136]     if (FALSE) {
[08:28:06.136]     }
[08:28:06.136]     else {
[08:28:06.136]         if (TRUE) {
[08:28:06.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:06.136]                 open = "w")
[08:28:06.136]         }
[08:28:06.136]         else {
[08:28:06.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:06.136]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:06.136]         }
[08:28:06.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:06.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:06.136]             base::sink(type = "output", split = FALSE)
[08:28:06.136]             base::close(...future.stdout)
[08:28:06.136]         }, add = TRUE)
[08:28:06.136]     }
[08:28:06.136]     ...future.frame <- base::sys.nframe()
[08:28:06.136]     ...future.conditions <- base::list()
[08:28:06.136]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:06.136]     if (FALSE) {
[08:28:06.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:06.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:06.136]     }
[08:28:06.136]     ...future.result <- base::tryCatch({
[08:28:06.136]         base::withCallingHandlers({
[08:28:06.136]             ...future.value <- base::withVisible(base::local({
[08:28:06.136]                 ...future.makeSendCondition <- base::local({
[08:28:06.136]                   sendCondition <- NULL
[08:28:06.136]                   function(frame = 1L) {
[08:28:06.136]                     if (is.function(sendCondition)) 
[08:28:06.136]                       return(sendCondition)
[08:28:06.136]                     ns <- getNamespace("parallel")
[08:28:06.136]                     if (exists("sendData", mode = "function", 
[08:28:06.136]                       envir = ns)) {
[08:28:06.136]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:06.136]                         envir = ns)
[08:28:06.136]                       envir <- sys.frame(frame)
[08:28:06.136]                       master <- NULL
[08:28:06.136]                       while (!identical(envir, .GlobalEnv) && 
[08:28:06.136]                         !identical(envir, emptyenv())) {
[08:28:06.136]                         if (exists("master", mode = "list", envir = envir, 
[08:28:06.136]                           inherits = FALSE)) {
[08:28:06.136]                           master <- get("master", mode = "list", 
[08:28:06.136]                             envir = envir, inherits = FALSE)
[08:28:06.136]                           if (inherits(master, c("SOCKnode", 
[08:28:06.136]                             "SOCK0node"))) {
[08:28:06.136]                             sendCondition <<- function(cond) {
[08:28:06.136]                               data <- list(type = "VALUE", value = cond, 
[08:28:06.136]                                 success = TRUE)
[08:28:06.136]                               parallel_sendData(master, data)
[08:28:06.136]                             }
[08:28:06.136]                             return(sendCondition)
[08:28:06.136]                           }
[08:28:06.136]                         }
[08:28:06.136]                         frame <- frame + 1L
[08:28:06.136]                         envir <- sys.frame(frame)
[08:28:06.136]                       }
[08:28:06.136]                     }
[08:28:06.136]                     sendCondition <<- function(cond) NULL
[08:28:06.136]                   }
[08:28:06.136]                 })
[08:28:06.136]                 withCallingHandlers({
[08:28:06.136]                   getOption("future.globals.onMissing")
[08:28:06.136]                 }, immediateCondition = function(cond) {
[08:28:06.136]                   sendCondition <- ...future.makeSendCondition()
[08:28:06.136]                   sendCondition(cond)
[08:28:06.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.136]                   {
[08:28:06.136]                     inherits <- base::inherits
[08:28:06.136]                     invokeRestart <- base::invokeRestart
[08:28:06.136]                     is.null <- base::is.null
[08:28:06.136]                     muffled <- FALSE
[08:28:06.136]                     if (inherits(cond, "message")) {
[08:28:06.136]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:06.136]                       if (muffled) 
[08:28:06.136]                         invokeRestart("muffleMessage")
[08:28:06.136]                     }
[08:28:06.136]                     else if (inherits(cond, "warning")) {
[08:28:06.136]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:06.136]                       if (muffled) 
[08:28:06.136]                         invokeRestart("muffleWarning")
[08:28:06.136]                     }
[08:28:06.136]                     else if (inherits(cond, "condition")) {
[08:28:06.136]                       if (!is.null(pattern)) {
[08:28:06.136]                         computeRestarts <- base::computeRestarts
[08:28:06.136]                         grepl <- base::grepl
[08:28:06.136]                         restarts <- computeRestarts(cond)
[08:28:06.136]                         for (restart in restarts) {
[08:28:06.136]                           name <- restart$name
[08:28:06.136]                           if (is.null(name)) 
[08:28:06.136]                             next
[08:28:06.136]                           if (!grepl(pattern, name)) 
[08:28:06.136]                             next
[08:28:06.136]                           invokeRestart(restart)
[08:28:06.136]                           muffled <- TRUE
[08:28:06.136]                           break
[08:28:06.136]                         }
[08:28:06.136]                       }
[08:28:06.136]                     }
[08:28:06.136]                     invisible(muffled)
[08:28:06.136]                   }
[08:28:06.136]                   muffleCondition(cond)
[08:28:06.136]                 })
[08:28:06.136]             }))
[08:28:06.136]             future::FutureResult(value = ...future.value$value, 
[08:28:06.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.136]                   ...future.rng), globalenv = if (FALSE) 
[08:28:06.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:06.136]                     ...future.globalenv.names))
[08:28:06.136]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:06.136]         }, condition = base::local({
[08:28:06.136]             c <- base::c
[08:28:06.136]             inherits <- base::inherits
[08:28:06.136]             invokeRestart <- base::invokeRestart
[08:28:06.136]             length <- base::length
[08:28:06.136]             list <- base::list
[08:28:06.136]             seq.int <- base::seq.int
[08:28:06.136]             signalCondition <- base::signalCondition
[08:28:06.136]             sys.calls <- base::sys.calls
[08:28:06.136]             `[[` <- base::`[[`
[08:28:06.136]             `+` <- base::`+`
[08:28:06.136]             `<<-` <- base::`<<-`
[08:28:06.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:06.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:06.136]                   3L)]
[08:28:06.136]             }
[08:28:06.136]             function(cond) {
[08:28:06.136]                 is_error <- inherits(cond, "error")
[08:28:06.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:06.136]                   NULL)
[08:28:06.136]                 if (is_error) {
[08:28:06.136]                   sessionInformation <- function() {
[08:28:06.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:06.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:06.136]                       search = base::search(), system = base::Sys.info())
[08:28:06.136]                   }
[08:28:06.136]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:06.136]                     cond$call), session = sessionInformation(), 
[08:28:06.136]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:06.136]                   signalCondition(cond)
[08:28:06.136]                 }
[08:28:06.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:06.136]                 "immediateCondition"))) {
[08:28:06.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:06.136]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:06.136]                   if (TRUE && !signal) {
[08:28:06.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.136]                     {
[08:28:06.136]                       inherits <- base::inherits
[08:28:06.136]                       invokeRestart <- base::invokeRestart
[08:28:06.136]                       is.null <- base::is.null
[08:28:06.136]                       muffled <- FALSE
[08:28:06.136]                       if (inherits(cond, "message")) {
[08:28:06.136]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.136]                         if (muffled) 
[08:28:06.136]                           invokeRestart("muffleMessage")
[08:28:06.136]                       }
[08:28:06.136]                       else if (inherits(cond, "warning")) {
[08:28:06.136]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.136]                         if (muffled) 
[08:28:06.136]                           invokeRestart("muffleWarning")
[08:28:06.136]                       }
[08:28:06.136]                       else if (inherits(cond, "condition")) {
[08:28:06.136]                         if (!is.null(pattern)) {
[08:28:06.136]                           computeRestarts <- base::computeRestarts
[08:28:06.136]                           grepl <- base::grepl
[08:28:06.136]                           restarts <- computeRestarts(cond)
[08:28:06.136]                           for (restart in restarts) {
[08:28:06.136]                             name <- restart$name
[08:28:06.136]                             if (is.null(name)) 
[08:28:06.136]                               next
[08:28:06.136]                             if (!grepl(pattern, name)) 
[08:28:06.136]                               next
[08:28:06.136]                             invokeRestart(restart)
[08:28:06.136]                             muffled <- TRUE
[08:28:06.136]                             break
[08:28:06.136]                           }
[08:28:06.136]                         }
[08:28:06.136]                       }
[08:28:06.136]                       invisible(muffled)
[08:28:06.136]                     }
[08:28:06.136]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.136]                   }
[08:28:06.136]                 }
[08:28:06.136]                 else {
[08:28:06.136]                   if (TRUE) {
[08:28:06.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.136]                     {
[08:28:06.136]                       inherits <- base::inherits
[08:28:06.136]                       invokeRestart <- base::invokeRestart
[08:28:06.136]                       is.null <- base::is.null
[08:28:06.136]                       muffled <- FALSE
[08:28:06.136]                       if (inherits(cond, "message")) {
[08:28:06.136]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.136]                         if (muffled) 
[08:28:06.136]                           invokeRestart("muffleMessage")
[08:28:06.136]                       }
[08:28:06.136]                       else if (inherits(cond, "warning")) {
[08:28:06.136]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.136]                         if (muffled) 
[08:28:06.136]                           invokeRestart("muffleWarning")
[08:28:06.136]                       }
[08:28:06.136]                       else if (inherits(cond, "condition")) {
[08:28:06.136]                         if (!is.null(pattern)) {
[08:28:06.136]                           computeRestarts <- base::computeRestarts
[08:28:06.136]                           grepl <- base::grepl
[08:28:06.136]                           restarts <- computeRestarts(cond)
[08:28:06.136]                           for (restart in restarts) {
[08:28:06.136]                             name <- restart$name
[08:28:06.136]                             if (is.null(name)) 
[08:28:06.136]                               next
[08:28:06.136]                             if (!grepl(pattern, name)) 
[08:28:06.136]                               next
[08:28:06.136]                             invokeRestart(restart)
[08:28:06.136]                             muffled <- TRUE
[08:28:06.136]                             break
[08:28:06.136]                           }
[08:28:06.136]                         }
[08:28:06.136]                       }
[08:28:06.136]                       invisible(muffled)
[08:28:06.136]                     }
[08:28:06.136]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.136]                   }
[08:28:06.136]                 }
[08:28:06.136]             }
[08:28:06.136]         }))
[08:28:06.136]     }, error = function(ex) {
[08:28:06.136]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:06.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.136]                 ...future.rng), started = ...future.startTime, 
[08:28:06.136]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:06.136]             version = "1.8"), class = "FutureResult")
[08:28:06.136]     }, finally = {
[08:28:06.136]         if (!identical(...future.workdir, getwd())) 
[08:28:06.136]             setwd(...future.workdir)
[08:28:06.136]         {
[08:28:06.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:06.136]                 ...future.oldOptions$nwarnings <- NULL
[08:28:06.136]             }
[08:28:06.136]             base::options(...future.oldOptions)
[08:28:06.136]             if (.Platform$OS.type == "windows") {
[08:28:06.136]                 old_names <- names(...future.oldEnvVars)
[08:28:06.136]                 envs <- base::Sys.getenv()
[08:28:06.136]                 names <- names(envs)
[08:28:06.136]                 common <- intersect(names, old_names)
[08:28:06.136]                 added <- setdiff(names, old_names)
[08:28:06.136]                 removed <- setdiff(old_names, names)
[08:28:06.136]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:06.136]                   envs[common]]
[08:28:06.136]                 NAMES <- toupper(changed)
[08:28:06.136]                 args <- list()
[08:28:06.136]                 for (kk in seq_along(NAMES)) {
[08:28:06.136]                   name <- changed[[kk]]
[08:28:06.136]                   NAME <- NAMES[[kk]]
[08:28:06.136]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.136]                     next
[08:28:06.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.136]                 }
[08:28:06.136]                 NAMES <- toupper(added)
[08:28:06.136]                 for (kk in seq_along(NAMES)) {
[08:28:06.136]                   name <- added[[kk]]
[08:28:06.136]                   NAME <- NAMES[[kk]]
[08:28:06.136]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.136]                     next
[08:28:06.136]                   args[[name]] <- ""
[08:28:06.136]                 }
[08:28:06.136]                 NAMES <- toupper(removed)
[08:28:06.136]                 for (kk in seq_along(NAMES)) {
[08:28:06.136]                   name <- removed[[kk]]
[08:28:06.136]                   NAME <- NAMES[[kk]]
[08:28:06.136]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.136]                     next
[08:28:06.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.136]                 }
[08:28:06.136]                 if (length(args) > 0) 
[08:28:06.136]                   base::do.call(base::Sys.setenv, args = args)
[08:28:06.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:06.136]             }
[08:28:06.136]             else {
[08:28:06.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:06.136]             }
[08:28:06.136]             {
[08:28:06.136]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:06.136]                   0L) {
[08:28:06.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:06.136]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:06.136]                   base::options(opts)
[08:28:06.136]                 }
[08:28:06.136]                 {
[08:28:06.136]                   {
[08:28:06.136]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:06.136]                     NULL
[08:28:06.136]                   }
[08:28:06.136]                   options(future.plan = NULL)
[08:28:06.136]                   if (is.na(NA_character_)) 
[08:28:06.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:06.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:06.136]                     .init = FALSE)
[08:28:06.136]                 }
[08:28:06.136]             }
[08:28:06.136]         }
[08:28:06.136]     })
[08:28:06.136]     if (TRUE) {
[08:28:06.136]         base::sink(type = "output", split = FALSE)
[08:28:06.136]         if (TRUE) {
[08:28:06.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:06.136]         }
[08:28:06.136]         else {
[08:28:06.136]             ...future.result["stdout"] <- base::list(NULL)
[08:28:06.136]         }
[08:28:06.136]         base::close(...future.stdout)
[08:28:06.136]         ...future.stdout <- NULL
[08:28:06.136]     }
[08:28:06.136]     ...future.result$conditions <- ...future.conditions
[08:28:06.136]     ...future.result$finished <- base::Sys.time()
[08:28:06.136]     ...future.result
[08:28:06.136] }
[08:28:06.139] MultisessionFuture started
[08:28:06.139] - Launch lazy future ... done
[08:28:06.139] run() for ‘MultisessionFuture’ ... done
[08:28:06.139] result() for ClusterFuture ...
[08:28:06.139] receiveMessageFromWorker() for ClusterFuture ...
[08:28:06.139] - Validating connection of MultisessionFuture
[08:28:06.181] - received message: FutureResult
[08:28:06.181] - Received FutureResult
[08:28:06.181] - Erased future from FutureRegistry
[08:28:06.181] result() for ClusterFuture ...
[08:28:06.182] - result already collected: FutureResult
[08:28:06.182] result() for ClusterFuture ... done
[08:28:06.182] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:06.182] result() for ClusterFuture ... done
[08:28:06.182] result() for ClusterFuture ...
[08:28:06.182] - result already collected: FutureResult
[08:28:06.182] result() for ClusterFuture ... done
[08:28:06.182] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:06.183] Searching for globals...
[08:28:06.183] - globals found: [1] ‘getOption’
[08:28:06.183] Searching for globals ... DONE
[08:28:06.183] Resolving globals: FALSE
[08:28:06.184] 
[08:28:06.184] 
[08:28:06.184] getGlobalsAndPackages() ... DONE
[08:28:06.184] run() for ‘Future’ ...
[08:28:06.184] - state: ‘created’
[08:28:06.184] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:06.199] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:06.199] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:06.199]   - Field: ‘node’
[08:28:06.199]   - Field: ‘label’
[08:28:06.199]   - Field: ‘local’
[08:28:06.199]   - Field: ‘owner’
[08:28:06.199]   - Field: ‘envir’
[08:28:06.199]   - Field: ‘workers’
[08:28:06.199]   - Field: ‘packages’
[08:28:06.199]   - Field: ‘gc’
[08:28:06.200]   - Field: ‘conditions’
[08:28:06.200]   - Field: ‘persistent’
[08:28:06.200]   - Field: ‘expr’
[08:28:06.200]   - Field: ‘uuid’
[08:28:06.200]   - Field: ‘seed’
[08:28:06.200]   - Field: ‘version’
[08:28:06.200]   - Field: ‘result’
[08:28:06.200]   - Field: ‘asynchronous’
[08:28:06.200]   - Field: ‘calls’
[08:28:06.200]   - Field: ‘globals’
[08:28:06.200]   - Field: ‘stdout’
[08:28:06.200]   - Field: ‘earlySignal’
[08:28:06.201]   - Field: ‘lazy’
[08:28:06.201]   - Field: ‘state’
[08:28:06.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:06.201] - Launch lazy future ...
[08:28:06.201] Packages needed by the future expression (n = 0): <none>
[08:28:06.201] Packages needed by future strategies (n = 0): <none>
[08:28:06.202] {
[08:28:06.202]     {
[08:28:06.202]         {
[08:28:06.202]             ...future.startTime <- base::Sys.time()
[08:28:06.202]             {
[08:28:06.202]                 {
[08:28:06.202]                   {
[08:28:06.202]                     {
[08:28:06.202]                       base::local({
[08:28:06.202]                         has_future <- base::requireNamespace("future", 
[08:28:06.202]                           quietly = TRUE)
[08:28:06.202]                         if (has_future) {
[08:28:06.202]                           ns <- base::getNamespace("future")
[08:28:06.202]                           version <- ns[[".package"]][["version"]]
[08:28:06.202]                           if (is.null(version)) 
[08:28:06.202]                             version <- utils::packageVersion("future")
[08:28:06.202]                         }
[08:28:06.202]                         else {
[08:28:06.202]                           version <- NULL
[08:28:06.202]                         }
[08:28:06.202]                         if (!has_future || version < "1.8.0") {
[08:28:06.202]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:06.202]                             "", base::R.version$version.string), 
[08:28:06.202]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:06.202]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:06.202]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:06.202]                               "release", "version")], collapse = " "), 
[08:28:06.202]                             hostname = base::Sys.info()[["nodename"]])
[08:28:06.202]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:06.202]                             info)
[08:28:06.202]                           info <- base::paste(info, collapse = "; ")
[08:28:06.202]                           if (!has_future) {
[08:28:06.202]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:06.202]                               info)
[08:28:06.202]                           }
[08:28:06.202]                           else {
[08:28:06.202]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:06.202]                               info, version)
[08:28:06.202]                           }
[08:28:06.202]                           base::stop(msg)
[08:28:06.202]                         }
[08:28:06.202]                       })
[08:28:06.202]                     }
[08:28:06.202]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:06.202]                     base::options(mc.cores = 1L)
[08:28:06.202]                   }
[08:28:06.202]                   ...future.strategy.old <- future::plan("list")
[08:28:06.202]                   options(future.plan = NULL)
[08:28:06.202]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.202]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:06.202]                 }
[08:28:06.202]                 ...future.workdir <- getwd()
[08:28:06.202]             }
[08:28:06.202]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:06.202]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:06.202]         }
[08:28:06.202]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:06.202]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:06.202]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:06.202]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:06.202]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:06.202]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:06.202]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:06.202]             base::names(...future.oldOptions))
[08:28:06.202]     }
[08:28:06.202]     if (FALSE) {
[08:28:06.202]     }
[08:28:06.202]     else {
[08:28:06.202]         if (TRUE) {
[08:28:06.202]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:06.202]                 open = "w")
[08:28:06.202]         }
[08:28:06.202]         else {
[08:28:06.202]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:06.202]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:06.202]         }
[08:28:06.202]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:06.202]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:06.202]             base::sink(type = "output", split = FALSE)
[08:28:06.202]             base::close(...future.stdout)
[08:28:06.202]         }, add = TRUE)
[08:28:06.202]     }
[08:28:06.202]     ...future.frame <- base::sys.nframe()
[08:28:06.202]     ...future.conditions <- base::list()
[08:28:06.202]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:06.202]     if (FALSE) {
[08:28:06.202]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:06.202]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:06.202]     }
[08:28:06.202]     ...future.result <- base::tryCatch({
[08:28:06.202]         base::withCallingHandlers({
[08:28:06.202]             ...future.value <- base::withVisible(base::local({
[08:28:06.202]                 ...future.makeSendCondition <- base::local({
[08:28:06.202]                   sendCondition <- NULL
[08:28:06.202]                   function(frame = 1L) {
[08:28:06.202]                     if (is.function(sendCondition)) 
[08:28:06.202]                       return(sendCondition)
[08:28:06.202]                     ns <- getNamespace("parallel")
[08:28:06.202]                     if (exists("sendData", mode = "function", 
[08:28:06.202]                       envir = ns)) {
[08:28:06.202]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:06.202]                         envir = ns)
[08:28:06.202]                       envir <- sys.frame(frame)
[08:28:06.202]                       master <- NULL
[08:28:06.202]                       while (!identical(envir, .GlobalEnv) && 
[08:28:06.202]                         !identical(envir, emptyenv())) {
[08:28:06.202]                         if (exists("master", mode = "list", envir = envir, 
[08:28:06.202]                           inherits = FALSE)) {
[08:28:06.202]                           master <- get("master", mode = "list", 
[08:28:06.202]                             envir = envir, inherits = FALSE)
[08:28:06.202]                           if (inherits(master, c("SOCKnode", 
[08:28:06.202]                             "SOCK0node"))) {
[08:28:06.202]                             sendCondition <<- function(cond) {
[08:28:06.202]                               data <- list(type = "VALUE", value = cond, 
[08:28:06.202]                                 success = TRUE)
[08:28:06.202]                               parallel_sendData(master, data)
[08:28:06.202]                             }
[08:28:06.202]                             return(sendCondition)
[08:28:06.202]                           }
[08:28:06.202]                         }
[08:28:06.202]                         frame <- frame + 1L
[08:28:06.202]                         envir <- sys.frame(frame)
[08:28:06.202]                       }
[08:28:06.202]                     }
[08:28:06.202]                     sendCondition <<- function(cond) NULL
[08:28:06.202]                   }
[08:28:06.202]                 })
[08:28:06.202]                 withCallingHandlers({
[08:28:06.202]                   getOption("future.globals.onMissing")
[08:28:06.202]                 }, immediateCondition = function(cond) {
[08:28:06.202]                   sendCondition <- ...future.makeSendCondition()
[08:28:06.202]                   sendCondition(cond)
[08:28:06.202]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.202]                   {
[08:28:06.202]                     inherits <- base::inherits
[08:28:06.202]                     invokeRestart <- base::invokeRestart
[08:28:06.202]                     is.null <- base::is.null
[08:28:06.202]                     muffled <- FALSE
[08:28:06.202]                     if (inherits(cond, "message")) {
[08:28:06.202]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:06.202]                       if (muffled) 
[08:28:06.202]                         invokeRestart("muffleMessage")
[08:28:06.202]                     }
[08:28:06.202]                     else if (inherits(cond, "warning")) {
[08:28:06.202]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:06.202]                       if (muffled) 
[08:28:06.202]                         invokeRestart("muffleWarning")
[08:28:06.202]                     }
[08:28:06.202]                     else if (inherits(cond, "condition")) {
[08:28:06.202]                       if (!is.null(pattern)) {
[08:28:06.202]                         computeRestarts <- base::computeRestarts
[08:28:06.202]                         grepl <- base::grepl
[08:28:06.202]                         restarts <- computeRestarts(cond)
[08:28:06.202]                         for (restart in restarts) {
[08:28:06.202]                           name <- restart$name
[08:28:06.202]                           if (is.null(name)) 
[08:28:06.202]                             next
[08:28:06.202]                           if (!grepl(pattern, name)) 
[08:28:06.202]                             next
[08:28:06.202]                           invokeRestart(restart)
[08:28:06.202]                           muffled <- TRUE
[08:28:06.202]                           break
[08:28:06.202]                         }
[08:28:06.202]                       }
[08:28:06.202]                     }
[08:28:06.202]                     invisible(muffled)
[08:28:06.202]                   }
[08:28:06.202]                   muffleCondition(cond)
[08:28:06.202]                 })
[08:28:06.202]             }))
[08:28:06.202]             future::FutureResult(value = ...future.value$value, 
[08:28:06.202]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.202]                   ...future.rng), globalenv = if (FALSE) 
[08:28:06.202]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:06.202]                     ...future.globalenv.names))
[08:28:06.202]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:06.202]         }, condition = base::local({
[08:28:06.202]             c <- base::c
[08:28:06.202]             inherits <- base::inherits
[08:28:06.202]             invokeRestart <- base::invokeRestart
[08:28:06.202]             length <- base::length
[08:28:06.202]             list <- base::list
[08:28:06.202]             seq.int <- base::seq.int
[08:28:06.202]             signalCondition <- base::signalCondition
[08:28:06.202]             sys.calls <- base::sys.calls
[08:28:06.202]             `[[` <- base::`[[`
[08:28:06.202]             `+` <- base::`+`
[08:28:06.202]             `<<-` <- base::`<<-`
[08:28:06.202]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:06.202]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:06.202]                   3L)]
[08:28:06.202]             }
[08:28:06.202]             function(cond) {
[08:28:06.202]                 is_error <- inherits(cond, "error")
[08:28:06.202]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:06.202]                   NULL)
[08:28:06.202]                 if (is_error) {
[08:28:06.202]                   sessionInformation <- function() {
[08:28:06.202]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:06.202]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:06.202]                       search = base::search(), system = base::Sys.info())
[08:28:06.202]                   }
[08:28:06.202]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.202]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:06.202]                     cond$call), session = sessionInformation(), 
[08:28:06.202]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:06.202]                   signalCondition(cond)
[08:28:06.202]                 }
[08:28:06.202]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:06.202]                 "immediateCondition"))) {
[08:28:06.202]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:06.202]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.202]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:06.202]                   if (TRUE && !signal) {
[08:28:06.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.202]                     {
[08:28:06.202]                       inherits <- base::inherits
[08:28:06.202]                       invokeRestart <- base::invokeRestart
[08:28:06.202]                       is.null <- base::is.null
[08:28:06.202]                       muffled <- FALSE
[08:28:06.202]                       if (inherits(cond, "message")) {
[08:28:06.202]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.202]                         if (muffled) 
[08:28:06.202]                           invokeRestart("muffleMessage")
[08:28:06.202]                       }
[08:28:06.202]                       else if (inherits(cond, "warning")) {
[08:28:06.202]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.202]                         if (muffled) 
[08:28:06.202]                           invokeRestart("muffleWarning")
[08:28:06.202]                       }
[08:28:06.202]                       else if (inherits(cond, "condition")) {
[08:28:06.202]                         if (!is.null(pattern)) {
[08:28:06.202]                           computeRestarts <- base::computeRestarts
[08:28:06.202]                           grepl <- base::grepl
[08:28:06.202]                           restarts <- computeRestarts(cond)
[08:28:06.202]                           for (restart in restarts) {
[08:28:06.202]                             name <- restart$name
[08:28:06.202]                             if (is.null(name)) 
[08:28:06.202]                               next
[08:28:06.202]                             if (!grepl(pattern, name)) 
[08:28:06.202]                               next
[08:28:06.202]                             invokeRestart(restart)
[08:28:06.202]                             muffled <- TRUE
[08:28:06.202]                             break
[08:28:06.202]                           }
[08:28:06.202]                         }
[08:28:06.202]                       }
[08:28:06.202]                       invisible(muffled)
[08:28:06.202]                     }
[08:28:06.202]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.202]                   }
[08:28:06.202]                 }
[08:28:06.202]                 else {
[08:28:06.202]                   if (TRUE) {
[08:28:06.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.202]                     {
[08:28:06.202]                       inherits <- base::inherits
[08:28:06.202]                       invokeRestart <- base::invokeRestart
[08:28:06.202]                       is.null <- base::is.null
[08:28:06.202]                       muffled <- FALSE
[08:28:06.202]                       if (inherits(cond, "message")) {
[08:28:06.202]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.202]                         if (muffled) 
[08:28:06.202]                           invokeRestart("muffleMessage")
[08:28:06.202]                       }
[08:28:06.202]                       else if (inherits(cond, "warning")) {
[08:28:06.202]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.202]                         if (muffled) 
[08:28:06.202]                           invokeRestart("muffleWarning")
[08:28:06.202]                       }
[08:28:06.202]                       else if (inherits(cond, "condition")) {
[08:28:06.202]                         if (!is.null(pattern)) {
[08:28:06.202]                           computeRestarts <- base::computeRestarts
[08:28:06.202]                           grepl <- base::grepl
[08:28:06.202]                           restarts <- computeRestarts(cond)
[08:28:06.202]                           for (restart in restarts) {
[08:28:06.202]                             name <- restart$name
[08:28:06.202]                             if (is.null(name)) 
[08:28:06.202]                               next
[08:28:06.202]                             if (!grepl(pattern, name)) 
[08:28:06.202]                               next
[08:28:06.202]                             invokeRestart(restart)
[08:28:06.202]                             muffled <- TRUE
[08:28:06.202]                             break
[08:28:06.202]                           }
[08:28:06.202]                         }
[08:28:06.202]                       }
[08:28:06.202]                       invisible(muffled)
[08:28:06.202]                     }
[08:28:06.202]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.202]                   }
[08:28:06.202]                 }
[08:28:06.202]             }
[08:28:06.202]         }))
[08:28:06.202]     }, error = function(ex) {
[08:28:06.202]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:06.202]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.202]                 ...future.rng), started = ...future.startTime, 
[08:28:06.202]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:06.202]             version = "1.8"), class = "FutureResult")
[08:28:06.202]     }, finally = {
[08:28:06.202]         if (!identical(...future.workdir, getwd())) 
[08:28:06.202]             setwd(...future.workdir)
[08:28:06.202]         {
[08:28:06.202]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:06.202]                 ...future.oldOptions$nwarnings <- NULL
[08:28:06.202]             }
[08:28:06.202]             base::options(...future.oldOptions)
[08:28:06.202]             if (.Platform$OS.type == "windows") {
[08:28:06.202]                 old_names <- names(...future.oldEnvVars)
[08:28:06.202]                 envs <- base::Sys.getenv()
[08:28:06.202]                 names <- names(envs)
[08:28:06.202]                 common <- intersect(names, old_names)
[08:28:06.202]                 added <- setdiff(names, old_names)
[08:28:06.202]                 removed <- setdiff(old_names, names)
[08:28:06.202]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:06.202]                   envs[common]]
[08:28:06.202]                 NAMES <- toupper(changed)
[08:28:06.202]                 args <- list()
[08:28:06.202]                 for (kk in seq_along(NAMES)) {
[08:28:06.202]                   name <- changed[[kk]]
[08:28:06.202]                   NAME <- NAMES[[kk]]
[08:28:06.202]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.202]                     next
[08:28:06.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.202]                 }
[08:28:06.202]                 NAMES <- toupper(added)
[08:28:06.202]                 for (kk in seq_along(NAMES)) {
[08:28:06.202]                   name <- added[[kk]]
[08:28:06.202]                   NAME <- NAMES[[kk]]
[08:28:06.202]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.202]                     next
[08:28:06.202]                   args[[name]] <- ""
[08:28:06.202]                 }
[08:28:06.202]                 NAMES <- toupper(removed)
[08:28:06.202]                 for (kk in seq_along(NAMES)) {
[08:28:06.202]                   name <- removed[[kk]]
[08:28:06.202]                   NAME <- NAMES[[kk]]
[08:28:06.202]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.202]                     next
[08:28:06.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.202]                 }
[08:28:06.202]                 if (length(args) > 0) 
[08:28:06.202]                   base::do.call(base::Sys.setenv, args = args)
[08:28:06.202]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:06.202]             }
[08:28:06.202]             else {
[08:28:06.202]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:06.202]             }
[08:28:06.202]             {
[08:28:06.202]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:06.202]                   0L) {
[08:28:06.202]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:06.202]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:06.202]                   base::options(opts)
[08:28:06.202]                 }
[08:28:06.202]                 {
[08:28:06.202]                   {
[08:28:06.202]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:06.202]                     NULL
[08:28:06.202]                   }
[08:28:06.202]                   options(future.plan = NULL)
[08:28:06.202]                   if (is.na(NA_character_)) 
[08:28:06.202]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.202]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:06.202]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:06.202]                     .init = FALSE)
[08:28:06.202]                 }
[08:28:06.202]             }
[08:28:06.202]         }
[08:28:06.202]     })
[08:28:06.202]     if (TRUE) {
[08:28:06.202]         base::sink(type = "output", split = FALSE)
[08:28:06.202]         if (TRUE) {
[08:28:06.202]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:06.202]         }
[08:28:06.202]         else {
[08:28:06.202]             ...future.result["stdout"] <- base::list(NULL)
[08:28:06.202]         }
[08:28:06.202]         base::close(...future.stdout)
[08:28:06.202]         ...future.stdout <- NULL
[08:28:06.202]     }
[08:28:06.202]     ...future.result$conditions <- ...future.conditions
[08:28:06.202]     ...future.result$finished <- base::Sys.time()
[08:28:06.202]     ...future.result
[08:28:06.202] }
[08:28:06.205] MultisessionFuture started
[08:28:06.205] - Launch lazy future ... done
[08:28:06.205] run() for ‘MultisessionFuture’ ... done
[08:28:06.205] result() for ClusterFuture ...
[08:28:06.206] receiveMessageFromWorker() for ClusterFuture ...
[08:28:06.206] - Validating connection of MultisessionFuture
[08:28:06.247] - received message: FutureResult
[08:28:06.247] - Received FutureResult
[08:28:06.248] - Erased future from FutureRegistry
[08:28:06.248] result() for ClusterFuture ...
[08:28:06.248] - result already collected: FutureResult
[08:28:06.248] result() for ClusterFuture ... done
[08:28:06.248] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:06.248] result() for ClusterFuture ... done
[08:28:06.248] result() for ClusterFuture ...
[08:28:06.248] - result already collected: FutureResult
[08:28:06.248] result() for ClusterFuture ... done
[08:28:06.249] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:06.249] Searching for globals...
[08:28:06.251] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:06.251] Searching for globals...
[08:28:06.252] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[08:28:06.252] Searching for globals ... DONE
[08:28:06.252] Resolving globals: FALSE
[08:28:06.253] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:06.253] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:06.253] - globals: [1] ‘data’
[08:28:06.254] 
[08:28:06.254] getGlobalsAndPackages() ... DONE
[08:28:06.254] run() for ‘Future’ ...
[08:28:06.254] - state: ‘created’
[08:28:06.254] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:06.269] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:06.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:06.269]   - Field: ‘node’
[08:28:06.269]   - Field: ‘label’
[08:28:06.269]   - Field: ‘local’
[08:28:06.270]   - Field: ‘owner’
[08:28:06.270]   - Field: ‘envir’
[08:28:06.270]   - Field: ‘workers’
[08:28:06.270]   - Field: ‘packages’
[08:28:06.270]   - Field: ‘gc’
[08:28:06.270]   - Field: ‘conditions’
[08:28:06.270]   - Field: ‘persistent’
[08:28:06.270]   - Field: ‘expr’
[08:28:06.270]   - Field: ‘uuid’
[08:28:06.270]   - Field: ‘seed’
[08:28:06.271]   - Field: ‘version’
[08:28:06.271]   - Field: ‘result’
[08:28:06.271]   - Field: ‘asynchronous’
[08:28:06.271]   - Field: ‘calls’
[08:28:06.271]   - Field: ‘globals’
[08:28:06.271]   - Field: ‘stdout’
[08:28:06.271]   - Field: ‘earlySignal’
[08:28:06.271]   - Field: ‘lazy’
[08:28:06.271]   - Field: ‘state’
[08:28:06.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:06.272] - Launch lazy future ...
[08:28:06.272] Packages needed by the future expression (n = 0): <none>
[08:28:06.272] Packages needed by future strategies (n = 0): <none>
[08:28:06.273] {
[08:28:06.273]     {
[08:28:06.273]         {
[08:28:06.273]             ...future.startTime <- base::Sys.time()
[08:28:06.273]             {
[08:28:06.273]                 {
[08:28:06.273]                   {
[08:28:06.273]                     {
[08:28:06.273]                       base::local({
[08:28:06.273]                         has_future <- base::requireNamespace("future", 
[08:28:06.273]                           quietly = TRUE)
[08:28:06.273]                         if (has_future) {
[08:28:06.273]                           ns <- base::getNamespace("future")
[08:28:06.273]                           version <- ns[[".package"]][["version"]]
[08:28:06.273]                           if (is.null(version)) 
[08:28:06.273]                             version <- utils::packageVersion("future")
[08:28:06.273]                         }
[08:28:06.273]                         else {
[08:28:06.273]                           version <- NULL
[08:28:06.273]                         }
[08:28:06.273]                         if (!has_future || version < "1.8.0") {
[08:28:06.273]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:06.273]                             "", base::R.version$version.string), 
[08:28:06.273]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:06.273]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:06.273]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:06.273]                               "release", "version")], collapse = " "), 
[08:28:06.273]                             hostname = base::Sys.info()[["nodename"]])
[08:28:06.273]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:06.273]                             info)
[08:28:06.273]                           info <- base::paste(info, collapse = "; ")
[08:28:06.273]                           if (!has_future) {
[08:28:06.273]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:06.273]                               info)
[08:28:06.273]                           }
[08:28:06.273]                           else {
[08:28:06.273]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:06.273]                               info, version)
[08:28:06.273]                           }
[08:28:06.273]                           base::stop(msg)
[08:28:06.273]                         }
[08:28:06.273]                       })
[08:28:06.273]                     }
[08:28:06.273]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:06.273]                     base::options(mc.cores = 1L)
[08:28:06.273]                   }
[08:28:06.273]                   ...future.strategy.old <- future::plan("list")
[08:28:06.273]                   options(future.plan = NULL)
[08:28:06.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:06.273]                 }
[08:28:06.273]                 ...future.workdir <- getwd()
[08:28:06.273]             }
[08:28:06.273]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:06.273]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:06.273]         }
[08:28:06.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:06.273]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:06.273]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:06.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:06.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:06.273]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:06.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:06.273]             base::names(...future.oldOptions))
[08:28:06.273]     }
[08:28:06.273]     if (FALSE) {
[08:28:06.273]     }
[08:28:06.273]     else {
[08:28:06.273]         if (TRUE) {
[08:28:06.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:06.273]                 open = "w")
[08:28:06.273]         }
[08:28:06.273]         else {
[08:28:06.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:06.273]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:06.273]         }
[08:28:06.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:06.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:06.273]             base::sink(type = "output", split = FALSE)
[08:28:06.273]             base::close(...future.stdout)
[08:28:06.273]         }, add = TRUE)
[08:28:06.273]     }
[08:28:06.273]     ...future.frame <- base::sys.nframe()
[08:28:06.273]     ...future.conditions <- base::list()
[08:28:06.273]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:06.273]     if (FALSE) {
[08:28:06.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:06.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:06.273]     }
[08:28:06.273]     ...future.result <- base::tryCatch({
[08:28:06.273]         base::withCallingHandlers({
[08:28:06.273]             ...future.value <- base::withVisible(base::local({
[08:28:06.273]                 ...future.makeSendCondition <- base::local({
[08:28:06.273]                   sendCondition <- NULL
[08:28:06.273]                   function(frame = 1L) {
[08:28:06.273]                     if (is.function(sendCondition)) 
[08:28:06.273]                       return(sendCondition)
[08:28:06.273]                     ns <- getNamespace("parallel")
[08:28:06.273]                     if (exists("sendData", mode = "function", 
[08:28:06.273]                       envir = ns)) {
[08:28:06.273]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:06.273]                         envir = ns)
[08:28:06.273]                       envir <- sys.frame(frame)
[08:28:06.273]                       master <- NULL
[08:28:06.273]                       while (!identical(envir, .GlobalEnv) && 
[08:28:06.273]                         !identical(envir, emptyenv())) {
[08:28:06.273]                         if (exists("master", mode = "list", envir = envir, 
[08:28:06.273]                           inherits = FALSE)) {
[08:28:06.273]                           master <- get("master", mode = "list", 
[08:28:06.273]                             envir = envir, inherits = FALSE)
[08:28:06.273]                           if (inherits(master, c("SOCKnode", 
[08:28:06.273]                             "SOCK0node"))) {
[08:28:06.273]                             sendCondition <<- function(cond) {
[08:28:06.273]                               data <- list(type = "VALUE", value = cond, 
[08:28:06.273]                                 success = TRUE)
[08:28:06.273]                               parallel_sendData(master, data)
[08:28:06.273]                             }
[08:28:06.273]                             return(sendCondition)
[08:28:06.273]                           }
[08:28:06.273]                         }
[08:28:06.273]                         frame <- frame + 1L
[08:28:06.273]                         envir <- sys.frame(frame)
[08:28:06.273]                       }
[08:28:06.273]                     }
[08:28:06.273]                     sendCondition <<- function(cond) NULL
[08:28:06.273]                   }
[08:28:06.273]                 })
[08:28:06.273]                 withCallingHandlers({
[08:28:06.273]                   subset(data, x < 3)$y
[08:28:06.273]                 }, immediateCondition = function(cond) {
[08:28:06.273]                   sendCondition <- ...future.makeSendCondition()
[08:28:06.273]                   sendCondition(cond)
[08:28:06.273]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.273]                   {
[08:28:06.273]                     inherits <- base::inherits
[08:28:06.273]                     invokeRestart <- base::invokeRestart
[08:28:06.273]                     is.null <- base::is.null
[08:28:06.273]                     muffled <- FALSE
[08:28:06.273]                     if (inherits(cond, "message")) {
[08:28:06.273]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:06.273]                       if (muffled) 
[08:28:06.273]                         invokeRestart("muffleMessage")
[08:28:06.273]                     }
[08:28:06.273]                     else if (inherits(cond, "warning")) {
[08:28:06.273]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:06.273]                       if (muffled) 
[08:28:06.273]                         invokeRestart("muffleWarning")
[08:28:06.273]                     }
[08:28:06.273]                     else if (inherits(cond, "condition")) {
[08:28:06.273]                       if (!is.null(pattern)) {
[08:28:06.273]                         computeRestarts <- base::computeRestarts
[08:28:06.273]                         grepl <- base::grepl
[08:28:06.273]                         restarts <- computeRestarts(cond)
[08:28:06.273]                         for (restart in restarts) {
[08:28:06.273]                           name <- restart$name
[08:28:06.273]                           if (is.null(name)) 
[08:28:06.273]                             next
[08:28:06.273]                           if (!grepl(pattern, name)) 
[08:28:06.273]                             next
[08:28:06.273]                           invokeRestart(restart)
[08:28:06.273]                           muffled <- TRUE
[08:28:06.273]                           break
[08:28:06.273]                         }
[08:28:06.273]                       }
[08:28:06.273]                     }
[08:28:06.273]                     invisible(muffled)
[08:28:06.273]                   }
[08:28:06.273]                   muffleCondition(cond)
[08:28:06.273]                 })
[08:28:06.273]             }))
[08:28:06.273]             future::FutureResult(value = ...future.value$value, 
[08:28:06.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.273]                   ...future.rng), globalenv = if (FALSE) 
[08:28:06.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:06.273]                     ...future.globalenv.names))
[08:28:06.273]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:06.273]         }, condition = base::local({
[08:28:06.273]             c <- base::c
[08:28:06.273]             inherits <- base::inherits
[08:28:06.273]             invokeRestart <- base::invokeRestart
[08:28:06.273]             length <- base::length
[08:28:06.273]             list <- base::list
[08:28:06.273]             seq.int <- base::seq.int
[08:28:06.273]             signalCondition <- base::signalCondition
[08:28:06.273]             sys.calls <- base::sys.calls
[08:28:06.273]             `[[` <- base::`[[`
[08:28:06.273]             `+` <- base::`+`
[08:28:06.273]             `<<-` <- base::`<<-`
[08:28:06.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:06.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:06.273]                   3L)]
[08:28:06.273]             }
[08:28:06.273]             function(cond) {
[08:28:06.273]                 is_error <- inherits(cond, "error")
[08:28:06.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:06.273]                   NULL)
[08:28:06.273]                 if (is_error) {
[08:28:06.273]                   sessionInformation <- function() {
[08:28:06.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:06.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:06.273]                       search = base::search(), system = base::Sys.info())
[08:28:06.273]                   }
[08:28:06.273]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:06.273]                     cond$call), session = sessionInformation(), 
[08:28:06.273]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:06.273]                   signalCondition(cond)
[08:28:06.273]                 }
[08:28:06.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:06.273]                 "immediateCondition"))) {
[08:28:06.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:06.273]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:06.273]                   if (TRUE && !signal) {
[08:28:06.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.273]                     {
[08:28:06.273]                       inherits <- base::inherits
[08:28:06.273]                       invokeRestart <- base::invokeRestart
[08:28:06.273]                       is.null <- base::is.null
[08:28:06.273]                       muffled <- FALSE
[08:28:06.273]                       if (inherits(cond, "message")) {
[08:28:06.273]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.273]                         if (muffled) 
[08:28:06.273]                           invokeRestart("muffleMessage")
[08:28:06.273]                       }
[08:28:06.273]                       else if (inherits(cond, "warning")) {
[08:28:06.273]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.273]                         if (muffled) 
[08:28:06.273]                           invokeRestart("muffleWarning")
[08:28:06.273]                       }
[08:28:06.273]                       else if (inherits(cond, "condition")) {
[08:28:06.273]                         if (!is.null(pattern)) {
[08:28:06.273]                           computeRestarts <- base::computeRestarts
[08:28:06.273]                           grepl <- base::grepl
[08:28:06.273]                           restarts <- computeRestarts(cond)
[08:28:06.273]                           for (restart in restarts) {
[08:28:06.273]                             name <- restart$name
[08:28:06.273]                             if (is.null(name)) 
[08:28:06.273]                               next
[08:28:06.273]                             if (!grepl(pattern, name)) 
[08:28:06.273]                               next
[08:28:06.273]                             invokeRestart(restart)
[08:28:06.273]                             muffled <- TRUE
[08:28:06.273]                             break
[08:28:06.273]                           }
[08:28:06.273]                         }
[08:28:06.273]                       }
[08:28:06.273]                       invisible(muffled)
[08:28:06.273]                     }
[08:28:06.273]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.273]                   }
[08:28:06.273]                 }
[08:28:06.273]                 else {
[08:28:06.273]                   if (TRUE) {
[08:28:06.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.273]                     {
[08:28:06.273]                       inherits <- base::inherits
[08:28:06.273]                       invokeRestart <- base::invokeRestart
[08:28:06.273]                       is.null <- base::is.null
[08:28:06.273]                       muffled <- FALSE
[08:28:06.273]                       if (inherits(cond, "message")) {
[08:28:06.273]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.273]                         if (muffled) 
[08:28:06.273]                           invokeRestart("muffleMessage")
[08:28:06.273]                       }
[08:28:06.273]                       else if (inherits(cond, "warning")) {
[08:28:06.273]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.273]                         if (muffled) 
[08:28:06.273]                           invokeRestart("muffleWarning")
[08:28:06.273]                       }
[08:28:06.273]                       else if (inherits(cond, "condition")) {
[08:28:06.273]                         if (!is.null(pattern)) {
[08:28:06.273]                           computeRestarts <- base::computeRestarts
[08:28:06.273]                           grepl <- base::grepl
[08:28:06.273]                           restarts <- computeRestarts(cond)
[08:28:06.273]                           for (restart in restarts) {
[08:28:06.273]                             name <- restart$name
[08:28:06.273]                             if (is.null(name)) 
[08:28:06.273]                               next
[08:28:06.273]                             if (!grepl(pattern, name)) 
[08:28:06.273]                               next
[08:28:06.273]                             invokeRestart(restart)
[08:28:06.273]                             muffled <- TRUE
[08:28:06.273]                             break
[08:28:06.273]                           }
[08:28:06.273]                         }
[08:28:06.273]                       }
[08:28:06.273]                       invisible(muffled)
[08:28:06.273]                     }
[08:28:06.273]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.273]                   }
[08:28:06.273]                 }
[08:28:06.273]             }
[08:28:06.273]         }))
[08:28:06.273]     }, error = function(ex) {
[08:28:06.273]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:06.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.273]                 ...future.rng), started = ...future.startTime, 
[08:28:06.273]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:06.273]             version = "1.8"), class = "FutureResult")
[08:28:06.273]     }, finally = {
[08:28:06.273]         if (!identical(...future.workdir, getwd())) 
[08:28:06.273]             setwd(...future.workdir)
[08:28:06.273]         {
[08:28:06.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:06.273]                 ...future.oldOptions$nwarnings <- NULL
[08:28:06.273]             }
[08:28:06.273]             base::options(...future.oldOptions)
[08:28:06.273]             if (.Platform$OS.type == "windows") {
[08:28:06.273]                 old_names <- names(...future.oldEnvVars)
[08:28:06.273]                 envs <- base::Sys.getenv()
[08:28:06.273]                 names <- names(envs)
[08:28:06.273]                 common <- intersect(names, old_names)
[08:28:06.273]                 added <- setdiff(names, old_names)
[08:28:06.273]                 removed <- setdiff(old_names, names)
[08:28:06.273]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:06.273]                   envs[common]]
[08:28:06.273]                 NAMES <- toupper(changed)
[08:28:06.273]                 args <- list()
[08:28:06.273]                 for (kk in seq_along(NAMES)) {
[08:28:06.273]                   name <- changed[[kk]]
[08:28:06.273]                   NAME <- NAMES[[kk]]
[08:28:06.273]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.273]                     next
[08:28:06.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.273]                 }
[08:28:06.273]                 NAMES <- toupper(added)
[08:28:06.273]                 for (kk in seq_along(NAMES)) {
[08:28:06.273]                   name <- added[[kk]]
[08:28:06.273]                   NAME <- NAMES[[kk]]
[08:28:06.273]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.273]                     next
[08:28:06.273]                   args[[name]] <- ""
[08:28:06.273]                 }
[08:28:06.273]                 NAMES <- toupper(removed)
[08:28:06.273]                 for (kk in seq_along(NAMES)) {
[08:28:06.273]                   name <- removed[[kk]]
[08:28:06.273]                   NAME <- NAMES[[kk]]
[08:28:06.273]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.273]                     next
[08:28:06.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.273]                 }
[08:28:06.273]                 if (length(args) > 0) 
[08:28:06.273]                   base::do.call(base::Sys.setenv, args = args)
[08:28:06.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:06.273]             }
[08:28:06.273]             else {
[08:28:06.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:06.273]             }
[08:28:06.273]             {
[08:28:06.273]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:06.273]                   0L) {
[08:28:06.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:06.273]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:06.273]                   base::options(opts)
[08:28:06.273]                 }
[08:28:06.273]                 {
[08:28:06.273]                   {
[08:28:06.273]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:06.273]                     NULL
[08:28:06.273]                   }
[08:28:06.273]                   options(future.plan = NULL)
[08:28:06.273]                   if (is.na(NA_character_)) 
[08:28:06.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:06.273]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:06.273]                     .init = FALSE)
[08:28:06.273]                 }
[08:28:06.273]             }
[08:28:06.273]         }
[08:28:06.273]     })
[08:28:06.273]     if (TRUE) {
[08:28:06.273]         base::sink(type = "output", split = FALSE)
[08:28:06.273]         if (TRUE) {
[08:28:06.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:06.273]         }
[08:28:06.273]         else {
[08:28:06.273]             ...future.result["stdout"] <- base::list(NULL)
[08:28:06.273]         }
[08:28:06.273]         base::close(...future.stdout)
[08:28:06.273]         ...future.stdout <- NULL
[08:28:06.273]     }
[08:28:06.273]     ...future.result$conditions <- ...future.conditions
[08:28:06.273]     ...future.result$finished <- base::Sys.time()
[08:28:06.273]     ...future.result
[08:28:06.273] }
[08:28:06.276] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[08:28:06.276] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[08:28:06.276] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[08:28:06.276] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[08:28:06.277] MultisessionFuture started
[08:28:06.277] - Launch lazy future ... done
[08:28:06.277] run() for ‘MultisessionFuture’ ... done
[08:28:06.277] result() for ClusterFuture ...
[08:28:06.278] receiveMessageFromWorker() for ClusterFuture ...
[08:28:06.278] - Validating connection of MultisessionFuture
[08:28:06.320] - received message: FutureResult
[08:28:06.320] - Received FutureResult
[08:28:06.320] - Erased future from FutureRegistry
[08:28:06.320] result() for ClusterFuture ...
[08:28:06.320] - result already collected: FutureResult
[08:28:06.320] result() for ClusterFuture ... done
[08:28:06.320] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:06.320] result() for ClusterFuture ... done
[08:28:06.321] result() for ClusterFuture ...
[08:28:06.321] - result already collected: FutureResult
[08:28:06.321] result() for ClusterFuture ... done
[08:28:06.321] plan(): Setting new future strategy stack:
[08:28:06.321] List of future strategies:
[08:28:06.321] 1. sequential:
[08:28:06.321]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:06.321]    - tweaked: FALSE
[08:28:06.321]    - call: plan(list(sequential, strategy))
[08:28:06.321] 2. multisession:
[08:28:06.321]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:06.321]    - tweaked: FALSE
[08:28:06.321]    - call: plan(list(sequential, strategy))
[08:28:06.323] plan(): nbrOfWorkers() = 1
[08:28:06.323] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:06.323] Searching for globals...
[08:28:06.329] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[08:28:06.329] Searching for globals ... DONE
[08:28:06.329] Resolving globals: FALSE
[08:28:06.330] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:06.331] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:06.331] - globals: [1] ‘data’
[08:28:06.331] - packages: [1] ‘future’
[08:28:06.331] getGlobalsAndPackages() ... DONE
[08:28:06.332] run() for ‘Future’ ...
[08:28:06.332] - state: ‘created’
[08:28:06.332] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:06.333] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:06.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:06.333]   - Field: ‘label’
[08:28:06.333]   - Field: ‘local’
[08:28:06.333]   - Field: ‘owner’
[08:28:06.333]   - Field: ‘envir’
[08:28:06.334]   - Field: ‘packages’
[08:28:06.334]   - Field: ‘gc’
[08:28:06.334]   - Field: ‘conditions’
[08:28:06.334]   - Field: ‘expr’
[08:28:06.334]   - Field: ‘uuid’
[08:28:06.334]   - Field: ‘seed’
[08:28:06.335]   - Field: ‘version’
[08:28:06.335]   - Field: ‘result’
[08:28:06.335]   - Field: ‘asynchronous’
[08:28:06.335]   - Field: ‘calls’
[08:28:06.335]   - Field: ‘globals’
[08:28:06.335]   - Field: ‘stdout’
[08:28:06.335]   - Field: ‘earlySignal’
[08:28:06.336]   - Field: ‘lazy’
[08:28:06.336]   - Field: ‘state’
[08:28:06.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:06.336] - Launch lazy future ...
[08:28:06.336] Packages needed by the future expression (n = 1): ‘future’
[08:28:06.337] Packages needed by future strategies (n = 1): ‘future’
[08:28:06.338] {
[08:28:06.338]     {
[08:28:06.338]         {
[08:28:06.338]             ...future.startTime <- base::Sys.time()
[08:28:06.338]             {
[08:28:06.338]                 {
[08:28:06.338]                   {
[08:28:06.338]                     {
[08:28:06.338]                       base::local({
[08:28:06.338]                         has_future <- base::requireNamespace("future", 
[08:28:06.338]                           quietly = TRUE)
[08:28:06.338]                         if (has_future) {
[08:28:06.338]                           ns <- base::getNamespace("future")
[08:28:06.338]                           version <- ns[[".package"]][["version"]]
[08:28:06.338]                           if (is.null(version)) 
[08:28:06.338]                             version <- utils::packageVersion("future")
[08:28:06.338]                         }
[08:28:06.338]                         else {
[08:28:06.338]                           version <- NULL
[08:28:06.338]                         }
[08:28:06.338]                         if (!has_future || version < "1.8.0") {
[08:28:06.338]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:06.338]                             "", base::R.version$version.string), 
[08:28:06.338]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:06.338]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:06.338]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:06.338]                               "release", "version")], collapse = " "), 
[08:28:06.338]                             hostname = base::Sys.info()[["nodename"]])
[08:28:06.338]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:06.338]                             info)
[08:28:06.338]                           info <- base::paste(info, collapse = "; ")
[08:28:06.338]                           if (!has_future) {
[08:28:06.338]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:06.338]                               info)
[08:28:06.338]                           }
[08:28:06.338]                           else {
[08:28:06.338]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:06.338]                               info, version)
[08:28:06.338]                           }
[08:28:06.338]                           base::stop(msg)
[08:28:06.338]                         }
[08:28:06.338]                       })
[08:28:06.338]                     }
[08:28:06.338]                     base::local({
[08:28:06.338]                       for (pkg in "future") {
[08:28:06.338]                         base::loadNamespace(pkg)
[08:28:06.338]                         base::library(pkg, character.only = TRUE)
[08:28:06.338]                       }
[08:28:06.338]                     })
[08:28:06.338]                   }
[08:28:06.338]                   ...future.strategy.old <- future::plan("list")
[08:28:06.338]                   options(future.plan = NULL)
[08:28:06.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.338]                   future::plan(list(function (..., workers = availableCores(), 
[08:28:06.338]                     lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:06.338]                     envir = parent.frame()) 
[08:28:06.338]                   {
[08:28:06.338]                     if (is.function(workers)) 
[08:28:06.338]                       workers <- workers()
[08:28:06.338]                     workers <- structure(as.integer(workers), 
[08:28:06.338]                       class = class(workers))
[08:28:06.338]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[08:28:06.338]                       workers >= 1)
[08:28:06.338]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[08:28:06.338]                       return(sequential(..., lazy = TRUE, envir = envir))
[08:28:06.338]                     }
[08:28:06.338]                     future <- MultisessionFuture(..., workers = workers, 
[08:28:06.338]                       lazy = lazy, rscript_libs = rscript_libs, 
[08:28:06.338]                       envir = envir)
[08:28:06.338]                     if (!future$lazy) 
[08:28:06.338]                       future <- run(future)
[08:28:06.338]                     invisible(future)
[08:28:06.338]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:06.338]                 }
[08:28:06.338]                 ...future.workdir <- getwd()
[08:28:06.338]             }
[08:28:06.338]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:06.338]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:06.338]         }
[08:28:06.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:06.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:06.338]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:06.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:06.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:06.338]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:06.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:06.338]             base::names(...future.oldOptions))
[08:28:06.338]     }
[08:28:06.338]     if (FALSE) {
[08:28:06.338]     }
[08:28:06.338]     else {
[08:28:06.338]         if (TRUE) {
[08:28:06.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:06.338]                 open = "w")
[08:28:06.338]         }
[08:28:06.338]         else {
[08:28:06.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:06.338]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:06.338]         }
[08:28:06.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:06.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:06.338]             base::sink(type = "output", split = FALSE)
[08:28:06.338]             base::close(...future.stdout)
[08:28:06.338]         }, add = TRUE)
[08:28:06.338]     }
[08:28:06.338]     ...future.frame <- base::sys.nframe()
[08:28:06.338]     ...future.conditions <- base::list()
[08:28:06.338]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:06.338]     if (FALSE) {
[08:28:06.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:06.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:06.338]     }
[08:28:06.338]     ...future.result <- base::tryCatch({
[08:28:06.338]         base::withCallingHandlers({
[08:28:06.338]             ...future.value <- base::withVisible(base::local({
[08:28:06.338]                 a %<-% subset(data, x < 3)$y
[08:28:06.338]                 a
[08:28:06.338]             }))
[08:28:06.338]             future::FutureResult(value = ...future.value$value, 
[08:28:06.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.338]                   ...future.rng), globalenv = if (FALSE) 
[08:28:06.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:06.338]                     ...future.globalenv.names))
[08:28:06.338]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:06.338]         }, condition = base::local({
[08:28:06.338]             c <- base::c
[08:28:06.338]             inherits <- base::inherits
[08:28:06.338]             invokeRestart <- base::invokeRestart
[08:28:06.338]             length <- base::length
[08:28:06.338]             list <- base::list
[08:28:06.338]             seq.int <- base::seq.int
[08:28:06.338]             signalCondition <- base::signalCondition
[08:28:06.338]             sys.calls <- base::sys.calls
[08:28:06.338]             `[[` <- base::`[[`
[08:28:06.338]             `+` <- base::`+`
[08:28:06.338]             `<<-` <- base::`<<-`
[08:28:06.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:06.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:06.338]                   3L)]
[08:28:06.338]             }
[08:28:06.338]             function(cond) {
[08:28:06.338]                 is_error <- inherits(cond, "error")
[08:28:06.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:06.338]                   NULL)
[08:28:06.338]                 if (is_error) {
[08:28:06.338]                   sessionInformation <- function() {
[08:28:06.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:06.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:06.338]                       search = base::search(), system = base::Sys.info())
[08:28:06.338]                   }
[08:28:06.338]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:06.338]                     cond$call), session = sessionInformation(), 
[08:28:06.338]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:06.338]                   signalCondition(cond)
[08:28:06.338]                 }
[08:28:06.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:06.338]                 "immediateCondition"))) {
[08:28:06.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:06.338]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:06.338]                   if (TRUE && !signal) {
[08:28:06.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.338]                     {
[08:28:06.338]                       inherits <- base::inherits
[08:28:06.338]                       invokeRestart <- base::invokeRestart
[08:28:06.338]                       is.null <- base::is.null
[08:28:06.338]                       muffled <- FALSE
[08:28:06.338]                       if (inherits(cond, "message")) {
[08:28:06.338]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.338]                         if (muffled) 
[08:28:06.338]                           invokeRestart("muffleMessage")
[08:28:06.338]                       }
[08:28:06.338]                       else if (inherits(cond, "warning")) {
[08:28:06.338]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.338]                         if (muffled) 
[08:28:06.338]                           invokeRestart("muffleWarning")
[08:28:06.338]                       }
[08:28:06.338]                       else if (inherits(cond, "condition")) {
[08:28:06.338]                         if (!is.null(pattern)) {
[08:28:06.338]                           computeRestarts <- base::computeRestarts
[08:28:06.338]                           grepl <- base::grepl
[08:28:06.338]                           restarts <- computeRestarts(cond)
[08:28:06.338]                           for (restart in restarts) {
[08:28:06.338]                             name <- restart$name
[08:28:06.338]                             if (is.null(name)) 
[08:28:06.338]                               next
[08:28:06.338]                             if (!grepl(pattern, name)) 
[08:28:06.338]                               next
[08:28:06.338]                             invokeRestart(restart)
[08:28:06.338]                             muffled <- TRUE
[08:28:06.338]                             break
[08:28:06.338]                           }
[08:28:06.338]                         }
[08:28:06.338]                       }
[08:28:06.338]                       invisible(muffled)
[08:28:06.338]                     }
[08:28:06.338]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.338]                   }
[08:28:06.338]                 }
[08:28:06.338]                 else {
[08:28:06.338]                   if (TRUE) {
[08:28:06.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.338]                     {
[08:28:06.338]                       inherits <- base::inherits
[08:28:06.338]                       invokeRestart <- base::invokeRestart
[08:28:06.338]                       is.null <- base::is.null
[08:28:06.338]                       muffled <- FALSE
[08:28:06.338]                       if (inherits(cond, "message")) {
[08:28:06.338]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.338]                         if (muffled) 
[08:28:06.338]                           invokeRestart("muffleMessage")
[08:28:06.338]                       }
[08:28:06.338]                       else if (inherits(cond, "warning")) {
[08:28:06.338]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.338]                         if (muffled) 
[08:28:06.338]                           invokeRestart("muffleWarning")
[08:28:06.338]                       }
[08:28:06.338]                       else if (inherits(cond, "condition")) {
[08:28:06.338]                         if (!is.null(pattern)) {
[08:28:06.338]                           computeRestarts <- base::computeRestarts
[08:28:06.338]                           grepl <- base::grepl
[08:28:06.338]                           restarts <- computeRestarts(cond)
[08:28:06.338]                           for (restart in restarts) {
[08:28:06.338]                             name <- restart$name
[08:28:06.338]                             if (is.null(name)) 
[08:28:06.338]                               next
[08:28:06.338]                             if (!grepl(pattern, name)) 
[08:28:06.338]                               next
[08:28:06.338]                             invokeRestart(restart)
[08:28:06.338]                             muffled <- TRUE
[08:28:06.338]                             break
[08:28:06.338]                           }
[08:28:06.338]                         }
[08:28:06.338]                       }
[08:28:06.338]                       invisible(muffled)
[08:28:06.338]                     }
[08:28:06.338]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.338]                   }
[08:28:06.338]                 }
[08:28:06.338]             }
[08:28:06.338]         }))
[08:28:06.338]     }, error = function(ex) {
[08:28:06.338]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:06.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.338]                 ...future.rng), started = ...future.startTime, 
[08:28:06.338]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:06.338]             version = "1.8"), class = "FutureResult")
[08:28:06.338]     }, finally = {
[08:28:06.338]         if (!identical(...future.workdir, getwd())) 
[08:28:06.338]             setwd(...future.workdir)
[08:28:06.338]         {
[08:28:06.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:06.338]                 ...future.oldOptions$nwarnings <- NULL
[08:28:06.338]             }
[08:28:06.338]             base::options(...future.oldOptions)
[08:28:06.338]             if (.Platform$OS.type == "windows") {
[08:28:06.338]                 old_names <- names(...future.oldEnvVars)
[08:28:06.338]                 envs <- base::Sys.getenv()
[08:28:06.338]                 names <- names(envs)
[08:28:06.338]                 common <- intersect(names, old_names)
[08:28:06.338]                 added <- setdiff(names, old_names)
[08:28:06.338]                 removed <- setdiff(old_names, names)
[08:28:06.338]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:06.338]                   envs[common]]
[08:28:06.338]                 NAMES <- toupper(changed)
[08:28:06.338]                 args <- list()
[08:28:06.338]                 for (kk in seq_along(NAMES)) {
[08:28:06.338]                   name <- changed[[kk]]
[08:28:06.338]                   NAME <- NAMES[[kk]]
[08:28:06.338]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.338]                     next
[08:28:06.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.338]                 }
[08:28:06.338]                 NAMES <- toupper(added)
[08:28:06.338]                 for (kk in seq_along(NAMES)) {
[08:28:06.338]                   name <- added[[kk]]
[08:28:06.338]                   NAME <- NAMES[[kk]]
[08:28:06.338]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.338]                     next
[08:28:06.338]                   args[[name]] <- ""
[08:28:06.338]                 }
[08:28:06.338]                 NAMES <- toupper(removed)
[08:28:06.338]                 for (kk in seq_along(NAMES)) {
[08:28:06.338]                   name <- removed[[kk]]
[08:28:06.338]                   NAME <- NAMES[[kk]]
[08:28:06.338]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.338]                     next
[08:28:06.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.338]                 }
[08:28:06.338]                 if (length(args) > 0) 
[08:28:06.338]                   base::do.call(base::Sys.setenv, args = args)
[08:28:06.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:06.338]             }
[08:28:06.338]             else {
[08:28:06.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:06.338]             }
[08:28:06.338]             {
[08:28:06.338]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:06.338]                   0L) {
[08:28:06.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:06.338]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:06.338]                   base::options(opts)
[08:28:06.338]                 }
[08:28:06.338]                 {
[08:28:06.338]                   {
[08:28:06.338]                     NULL
[08:28:06.338]                     RNGkind("Mersenne-Twister")
[08:28:06.338]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:06.338]                       inherits = FALSE)
[08:28:06.338]                   }
[08:28:06.338]                   options(future.plan = NULL)
[08:28:06.338]                   if (is.na(NA_character_)) 
[08:28:06.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:06.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:06.338]                     .init = FALSE)
[08:28:06.338]                 }
[08:28:06.338]             }
[08:28:06.338]         }
[08:28:06.338]     })
[08:28:06.338]     if (TRUE) {
[08:28:06.338]         base::sink(type = "output", split = FALSE)
[08:28:06.338]         if (TRUE) {
[08:28:06.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:06.338]         }
[08:28:06.338]         else {
[08:28:06.338]             ...future.result["stdout"] <- base::list(NULL)
[08:28:06.338]         }
[08:28:06.338]         base::close(...future.stdout)
[08:28:06.338]         ...future.stdout <- NULL
[08:28:06.338]     }
[08:28:06.338]     ...future.result$conditions <- ...future.conditions
[08:28:06.338]     ...future.result$finished <- base::Sys.time()
[08:28:06.338]     ...future.result
[08:28:06.338] }
[08:28:06.341] assign_globals() ...
[08:28:06.341] List of 1
[08:28:06.341]  $ data:'data.frame':	5 obs. of  2 variables:
[08:28:06.341]   ..$ x: int [1:5] 1 2 3 4 5
[08:28:06.341]   ..$ y: int [1:5] 1 2 3 4 5
[08:28:06.341]  - attr(*, "where")=List of 1
[08:28:06.341]   ..$ data:<environment: R_EmptyEnv> 
[08:28:06.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:06.341]  - attr(*, "resolved")= logi FALSE
[08:28:06.341]  - attr(*, "total_size")= num 356
[08:28:06.341]  - attr(*, "already-done")= logi TRUE
[08:28:06.346] - copied ‘data’ to environment
[08:28:06.346] assign_globals() ... done
[08:28:06.346] plan(): Setting new future strategy stack:
[08:28:06.347] List of future strategies:
[08:28:06.347] 1. multisession:
[08:28:06.347]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:06.347]    - tweaked: FALSE
[08:28:06.347]    - call: plan(list(sequential, strategy))
[08:28:06.349] plan(): nbrOfWorkers() = 2
[08:28:06.762] plan(): Setting new future strategy stack:
[08:28:06.762] List of future strategies:
[08:28:06.762] 1. sequential:
[08:28:06.762]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:06.762]    - tweaked: FALSE
[08:28:06.762]    - call: plan(list(sequential, strategy))
[08:28:06.762] 2. multisession:
[08:28:06.762]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:06.762]    - tweaked: FALSE
[08:28:06.762]    - call: plan(list(sequential, strategy))
[08:28:06.763] plan(): nbrOfWorkers() = 1
[08:28:06.763] SequentialFuture started (and completed)
[08:28:06.763] signalConditions() ...
[08:28:06.763]  - include = ‘immediateCondition’
[08:28:06.763]  - exclude = 
[08:28:06.763]  - resignal = FALSE
[08:28:06.763]  - Number of conditions: 64
[08:28:06.763] signalConditions() ... done
[08:28:06.763] - Launch lazy future ... done
[08:28:06.764] run() for ‘SequentialFuture’ ... done
[08:28:06.764] signalConditions() ...
[08:28:06.764]  - include = ‘immediateCondition’
[08:28:06.764]  - exclude = 
[08:28:06.764]  - resignal = FALSE
[08:28:06.764]  - Number of conditions: 64
[08:28:06.764] signalConditions() ... done
[08:28:06.764] Future state: ‘finished’
[08:28:06.765] signalConditions() ...
[08:28:06.765]  - include = ‘condition’
[08:28:06.765]  - exclude = ‘immediateCondition’
[08:28:06.765]  - resignal = TRUE
[08:28:06.765]  - Number of conditions: 64
[08:28:06.765]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.349] getGlobalsAndPackages() ...
[08:28:06.765]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:06.765]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.368] Searching for globals...
[08:28:06.765]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.369] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[08:28:06.766]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.369] Searching for globals ... DONE
[08:28:06.766]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.369] Resolving globals: FALSE
[08:28:06.766]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.369] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:06.766]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.370] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:06.766]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.370] - globals: [1] ‘data’
[08:28:06.766]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.370] 
[08:28:06.766]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.370] getGlobalsAndPackages() ... DONE
[08:28:06.766]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.370] run() for ‘Future’ ...
[08:28:06.766]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.370] - state: ‘created’
[08:28:06.767]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.371] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:06.767]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.631] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:06.767]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:06.767]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.631]   - Field: ‘node’
[08:28:06.767]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.631]   - Field: ‘label’
[08:28:06.767]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.631]   - Field: ‘local’
[08:28:06.767]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.631]   - Field: ‘owner’
[08:28:06.767]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.631]   - Field: ‘envir’
[08:28:06.768]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.631]   - Field: ‘workers’
[08:28:06.768]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.632]   - Field: ‘packages’
[08:28:06.768]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.632]   - Field: ‘gc’
[08:28:06.768]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.632]   - Field: ‘conditions’
[08:28:06.768]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.632]   - Field: ‘persistent’
[08:28:06.768]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.632]   - Field: ‘expr’
[08:28:06.768]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.632]   - Field: ‘uuid’
[08:28:06.768]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.632]   - Field: ‘seed’
[08:28:06.769]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.632]   - Field: ‘version’
[08:28:06.769]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.632]   - Field: ‘result’
[08:28:06.769]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.633]   - Field: ‘asynchronous’
[08:28:06.769]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.633]   - Field: ‘calls’
[08:28:06.769]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.633]   - Field: ‘globals’
[08:28:06.769]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.633]   - Field: ‘stdout’
[08:28:06.769]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.633]   - Field: ‘earlySignal’
[08:28:06.769]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.633]   - Field: ‘lazy’
[08:28:06.769]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.633]   - Field: ‘state’
[08:28:06.770]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.633] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:06.770]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.633] - Launch lazy future ...
[08:28:06.770]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.634] Packages needed by the future expression (n = 0): <none>
[08:28:06.770]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.634] Packages needed by future strategies (n = 0): <none>
[08:28:06.770]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.634] {
[08:28:06.634]     {
[08:28:06.634]         {
[08:28:06.634]             ...future.startTime <- base::Sys.time()
[08:28:06.634]             {
[08:28:06.634]                 {
[08:28:06.634]                   {
[08:28:06.634]                     {
[08:28:06.634]                       base::local({
[08:28:06.634]                         has_future <- base::requireNamespace("future", 
[08:28:06.634]                           quietly = TRUE)
[08:28:06.634]                         if (has_future) {
[08:28:06.634]                           ns <- base::getNamespace("future")
[08:28:06.634]                           version <- ns[[".package"]][["version"]]
[08:28:06.634]                           if (is.null(version)) 
[08:28:06.634]                             version <- utils::packageVersion("future")
[08:28:06.634]                         }
[08:28:06.634]                         else {
[08:28:06.634]                           version <- NULL
[08:28:06.634]                         }
[08:28:06.634]                         if (!has_future || version < "1.8.0") {
[08:28:06.634]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:06.634]                             "", base::R.version$version.string), 
[08:28:06.634]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:06.634]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:06.634]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:06.634]                               "release", "version")], collapse = " "), 
[08:28:06.634]                             hostname = base::Sys.info()[["nodename"]])
[08:28:06.634]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:06.634]                             info)
[08:28:06.634]                           info <- base::paste(info, collapse = "; ")
[08:28:06.634]                           if (!has_future) {
[08:28:06.634]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:06.634]                               info)
[08:28:06.634]                           }
[08:28:06.634]                           else {
[08:28:06.634]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:06.634]                               info, version)
[08:28:06.634]                           }
[08:28:06.634]                           base::stop(msg)
[08:28:06.634]                         }
[08:28:06.634]                       })
[08:28:06.634]                     }
[08:28:06.634]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:06.634]                     base::options(mc.cores = 1L)
[08:28:06.634]                   }
[08:28:06.634]                   ...future.strategy.old <- future::plan("list")
[08:28:06.634]                   options(future.plan = NULL)
[08:28:06.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:06.634]                 }
[08:28:06.634]                 ...future.workdir <- getwd()
[08:28:06.634]             }
[08:28:06.634]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:06.634]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:06.634]         }
[08:28:06.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:06.634]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:06.634]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:06.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:06.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:06.634]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:06.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:06.634]             base::names(...future.oldOptions))
[08:28:06.634]     }
[08:28:06.634]     if (FALSE) {
[08:28:06.634]     }
[08:28:06.634]     else {
[08:28:06.634]         if (TRUE) {
[08:28:06.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:06.634]                 open = "w")
[08:28:06.634]         }
[08:28:06.634]         else {
[08:28:06.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:06.634]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:06.634]         }
[08:28:06.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:06.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:06.634]             base::sink(type = "output", split = FALSE)
[08:28:06.634]             base::close(...future.stdout)
[08:28:06.634]         }, add = TRUE)
[08:28:06.634]     }
[08:28:06.634]     ...future.frame <- base::sys.nframe()
[08:28:06.634]     ...future.conditions <- base::list()
[08:28:06.634]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:06.634]     if (FALSE) {
[08:28:06.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:06.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:06.634]     }
[08:28:06.634]     ...future.result <- base::tryCatch({
[08:28:06.634]         base::withCallingHandlers({
[08:28:06.634]             ...future.value <- base::withVisible(base::local({
[08:28:06.634]                 ...future.makeSendCondition <- base::local({
[08:28:06.634]                   sendCondition <- NULL
[08:28:06.634]                   function(frame = 1L) {
[08:28:06.634]                     if (is.function(sendCondition)) 
[08:28:06.634]                       return(sendCondition)
[08:28:06.634]                     ns <- getNamespace("parallel")
[08:28:06.634]                     if (exists("sendData", mode = "function", 
[08:28:06.634]                       envir = ns)) {
[08:28:06.634]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:06.634]                         envir = ns)
[08:28:06.634]                       envir <- sys.frame(frame)
[08:28:06.634]                       master <- NULL
[08:28:06.634]                       while (!identical(envir, .GlobalEnv) && 
[08:28:06.634]                         !identical(envir, emptyenv())) {
[08:28:06.634]                         if (exists("master", mode = "list", envir = envir, 
[08:28:06.634]                           inherits = FALSE)) {
[08:28:06.634]                           master <- get("master", mode = "list", 
[08:28:06.634]                             envir = envir, inherits = FALSE)
[08:28:06.634]                           if (inherits(master, c("SOCKnode", 
[08:28:06.634]                             "SOCK0node"))) {
[08:28:06.634]                             sendCondition <<- function(cond) {
[08:28:06.634]                               data <- list(type = "VALUE", value = cond, 
[08:28:06.634]                                 success = TRUE)
[08:28:06.634]                               parallel_sendData(master, data)
[08:28:06.634]                             }
[08:28:06.634]                             return(sendCondition)
[08:28:06.634]                           }
[08:28:06.634]                         }
[08:28:06.634]                         frame <- frame + 1L
[08:28:06.634]                         envir <- sys.frame(frame)
[08:28:06.634]                       }
[08:28:06.634]                     }
[08:28:06.634]                     sendCondition <<- function(cond) NULL
[08:28:06.634]                   }
[08:28:06.634]                 })
[08:28:06.634]                 withCallingHandlers({
[08:28:06.634]                   subset(data, x < 3)$y
[08:28:06.634]                 }, immediateCondition = function(cond) {
[08:28:06.634]                   sendCondition <- ...future.makeSendCondition()
[08:28:06.634]                   sendCondition(cond)
[08:28:06.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.634]                   {
[08:28:06.634]                     inherits <- base::inherits
[08:28:06.634]                     invokeRestart <- base::invokeRestart
[08:28:06.634]                     is.null <- base::is.null
[08:28:06.634]                     muffled <- FALSE
[08:28:06.634]                     if (inherits(cond, "message")) {
[08:28:06.634]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:06.634]                       if (muffled) 
[08:28:06.634]                         invokeRestart("muffleMessage")
[08:28:06.634]                     }
[08:28:06.634]                     else if (inherits(cond, "warning")) {
[08:28:06.634]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:06.634]                       if (muffled) 
[08:28:06.634]                         invokeRestart("muffleWarning")
[08:28:06.634]                     }
[08:28:06.634]                     else if (inherits(cond, "condition")) {
[08:28:06.634]                       if (!is.null(pattern)) {
[08:28:06.634]                         computeRestarts <- base::computeRestarts
[08:28:06.634]                         grepl <- base::grepl
[08:28:06.634]                         restarts <- computeRestarts(cond)
[08:28:06.634]                         for (restart in restarts) {
[08:28:06.634]                           name <- restart$name
[08:28:06.634]                           if (is.null(name)) 
[08:28:06.634]                             next
[08:28:06.634]                           if (!grepl(pattern, name)) 
[08:28:06.634]                             next
[08:28:06.634]                           invokeRestart(restart)
[08:28:06.634]                           muffled <- TRUE
[08:28:06.634]                           break
[08:28:06.634]                         }
[08:28:06.634]                       }
[08:28:06.634]                     }
[08:28:06.634]                     invisible(muffled)
[08:28:06.634]                   }
[08:28:06.634]                   muffleCondition(cond)
[08:28:06.634]                 })
[08:28:06.634]             }))
[08:28:06.634]             future::FutureResult(value = ...future.value$value, 
[08:28:06.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.634]                   ...future.rng), globalenv = if (FALSE) 
[08:28:06.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:06.634]                     ...future.globalenv.names))
[08:28:06.634]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:06.634]         }, condition = base::local({
[08:28:06.634]             c <- base::c
[08:28:06.634]             inherits <- base::inherits
[08:28:06.634]             invokeRestart <- base::invokeRestart
[08:28:06.634]             length <- base::length
[08:28:06.634]             list <- base::list
[08:28:06.634]             seq.int <- base::seq.int
[08:28:06.634]             signalCondition <- base::signalCondition
[08:28:06.634]             sys.calls <- base::sys.calls
[08:28:06.634]             `[[` <- base::`[[`
[08:28:06.634]             `+` <- base::`+`
[08:28:06.634]             `<<-` <- base::`<<-`
[08:28:06.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:06.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:06.634]                   3L)]
[08:28:06.634]             }
[08:28:06.634]             function(cond) {
[08:28:06.634]                 is_error <- inherits(cond, "error")
[08:28:06.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:06.634]                   NULL)
[08:28:06.634]                 if (is_error) {
[08:28:06.634]                   sessionInformation <- function() {
[08:28:06.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:06.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:06.634]                       search = base::search(), system = base::Sys.info())
[08:28:06.634]                   }
[08:28:06.634]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:06.634]                     cond$call), session = sessionInformation(), 
[08:28:06.634]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:06.634]                   signalCondition(cond)
[08:28:06.634]                 }
[08:28:06.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:06.634]                 "immediateCondition"))) {
[08:28:06.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:06.634]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:06.634]                   if (TRUE && !signal) {
[08:28:06.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.634]                     {
[08:28:06.634]                       inherits <- base::inherits
[08:28:06.634]                       invokeRestart <- base::invokeRestart
[08:28:06.634]                       is.null <- base::is.null
[08:28:06.634]                       muffled <- FALSE
[08:28:06.634]                       if (inherits(cond, "message")) {
[08:28:06.634]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.634]                         if (muffled) 
[08:28:06.634]                           invokeRestart("muffleMessage")
[08:28:06.634]                       }
[08:28:06.634]                       else if (inherits(cond, "warning")) {
[08:28:06.634]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.634]                         if (muffled) 
[08:28:06.634]                           invokeRestart("muffleWarning")
[08:28:06.634]                       }
[08:28:06.634]                       else if (inherits(cond, "condition")) {
[08:28:06.634]                         if (!is.null(pattern)) {
[08:28:06.634]                           computeRestarts <- base::computeRestarts
[08:28:06.634]                           grepl <- base::grepl
[08:28:06.634]                           restarts <- computeRestarts(cond)
[08:28:06.634]                           for (restart in restarts) {
[08:28:06.634]                             name <- restart$name
[08:28:06.634]                             if (is.null(name)) 
[08:28:06.634]                               next
[08:28:06.634]                             if (!grepl(pattern, name)) 
[08:28:06.634]                               next
[08:28:06.634]                             invokeRestart(restart)
[08:28:06.634]                             muffled <- TRUE
[08:28:06.634]                             break
[08:28:06.634]                           }
[08:28:06.634]                         }
[08:28:06.634]                       }
[08:28:06.634]                       invisible(muffled)
[08:28:06.634]                     }
[08:28:06.634]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.634]                   }
[08:28:06.634]                 }
[08:28:06.634]                 else {
[08:28:06.634]                   if (TRUE) {
[08:28:06.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.634]                     {
[08:28:06.634]                       inherits <- base::inherits
[08:28:06.634]                       invokeRestart <- base::invokeRestart
[08:28:06.634]                       is.null <- base::is.null
[08:28:06.634]                       muffled <- FALSE
[08:28:06.634]                       if (inherits(cond, "message")) {
[08:28:06.634]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.634]                         if (muffled) 
[08:28:06.634]                           invokeRestart("muffleMessage")
[08:28:06.634]                       }
[08:28:06.634]                       else if (inherits(cond, "warning")) {
[08:28:06.634]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.634]                         if (muffled) 
[08:28:06.634]                           invokeRestart("muffleWarning")
[08:28:06.634]                       }
[08:28:06.634]                       else if (inherits(cond, "condition")) {
[08:28:06.634]                         if (!is.null(pattern)) {
[08:28:06.634]                           computeRestarts <- base::computeRestarts
[08:28:06.634]                           grepl <- base::grepl
[08:28:06.634]                           restarts <- computeRestarts(cond)
[08:28:06.634]                           for (restart in restarts) {
[08:28:06.634]                             name <- restart$name
[08:28:06.634]                             if (is.null(name)) 
[08:28:06.634]                               next
[08:28:06.634]                             if (!grepl(pattern, name)) 
[08:28:06.634]                               next
[08:28:06.634]                             invokeRestart(restart)
[08:28:06.634]                             muffled <- TRUE
[08:28:06.634]                             break
[08:28:06.634]                           }
[08:28:06.634]                         }
[08:28:06.634]                       }
[08:28:06.634]                       invisible(muffled)
[08:28:06.634]                     }
[08:28:06.634]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.634]                   }
[08:28:06.634]                 }
[08:28:06.634]             }
[08:28:06.634]         }))
[08:28:06.634]     }, error = function(ex) {
[08:28:06.634]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:06.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.634]                 ...future.rng), started = ...future.startTime, 
[08:28:06.634]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:06.634]             version = "1.8"), class = "FutureResult")
[08:28:06.634]     }, finally = {
[08:28:06.634]         if (!identical(...future.workdir, getwd())) 
[08:28:06.634]             setwd(...future.workdir)
[08:28:06.634]         {
[08:28:06.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:06.634]                 ...future.oldOptions$nwarnings <- NULL
[08:28:06.634]             }
[08:28:06.634]             base::options(...future.oldOptions)
[08:28:06.634]             if (.Platform$OS.type == "windows") {
[08:28:06.634]                 old_names <- names(...future.oldEnvVars)
[08:28:06.634]                 envs <- base::Sys.getenv()
[08:28:06.634]                 names <- names(envs)
[08:28:06.634]                 common <- intersect(names, old_names)
[08:28:06.634]                 added <- setdiff(names, old_names)
[08:28:06.634]                 removed <- setdiff(old_names, names)
[08:28:06.634]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:06.634]                   envs[common]]
[08:28:06.634]                 NAMES <- toupper(changed)
[08:28:06.634]                 args <- list()
[08:28:06.634]                 for (kk in seq_along(NAMES)) {
[08:28:06.634]                   name <- changed[[kk]]
[08:28:06.634]                   NAME <- NAMES[[kk]]
[08:28:06.634]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.634]                     next
[08:28:06.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.634]                 }
[08:28:06.634]                 NAMES <- toupper(added)
[08:28:06.634]                 for (kk in seq_along(NAMES)) {
[08:28:06.634]                   name <- added[[kk]]
[08:28:06.634]                   NAME <- NAMES[[kk]]
[08:28:06.634]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.634]                     next
[08:28:06.634]                   args[[name]] <- ""
[08:28:06.634]                 }
[08:28:06.634]                 NAMES <- toupper(removed)
[08:28:06.634]                 for (kk in seq_along(NAMES)) {
[08:28:06.634]                   name <- removed[[kk]]
[08:28:06.634]                   NAME <- NAMES[[kk]]
[08:28:06.634]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.634]                     next
[08:28:06.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.634]                 }
[08:28:06.634]                 if (length(args) > 0) 
[08:28:06.634]                   base::do.call(base::Sys.setenv, args = args)
[08:28:06.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:06.634]             }
[08:28:06.634]             else {
[08:28:06.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:06.634]             }
[08:28:06.634]             {
[08:28:06.634]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:06.634]                   0L) {
[08:28:06.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:06.634]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:06.634]                   base::options(opts)
[08:28:06.634]                 }
[08:28:06.634]                 {
[08:28:06.634]                   {
[08:28:06.634]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:06.634]                     NULL
[08:28:06.634]                   }
[08:28:06.634]                   options(future.plan = NULL)
[08:28:06.634]                   if (is.na(NA_character_)) 
[08:28:06.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:06.634]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:06.634]                     .init = FALSE)
[08:28:06.634]                 }
[08:28:06.634]             }
[08:28:06.634]         }
[08:28:06.634]     })
[08:28:06.634]     if (TRUE) {
[08:28:06.634]         base::sink(type = "output", split = FALSE)
[08:28:06.634]         if (TRUE) {
[08:28:06.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:06.634]         }
[08:28:06.634]         else {
[08:28:06.634]             ...future.result["stdout"] <- base::list(NULL)
[08:28:06.634]         }
[08:28:06.634]         base::close(...future.stdout)
[08:28:06.634]         ...future.stdout <- NULL
[08:28:06.634]     }
[08:28:06.634]     ...future.result$conditions <- ...future.conditions
[08:28:06.634]     ...future.result$finished <- base::Sys.time()
[08:28:06.634]     ...future.result
[08:28:06.634] }
[08:28:06.770]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.686] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[08:28:06.771]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.686] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[08:28:06.771]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.687] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[08:28:06.771]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.687] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[08:28:06.771]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.687] MultisessionFuture started
[08:28:06.771]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.687] - Launch lazy future ... done
[08:28:06.771]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.688] run() for ‘MultisessionFuture’ ... done
[08:28:06.771]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.688] result() for ClusterFuture ...
[08:28:06.771]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.688] receiveMessageFromWorker() for ClusterFuture ...
[08:28:06.771]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.688] - Validating connection of MultisessionFuture
[08:28:06.772]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.760] - received message: FutureResult
[08:28:06.772]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.760] - Received FutureResult
[08:28:06.772]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.760] - Erased future from FutureRegistry
[08:28:06.772]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.761] result() for ClusterFuture ...
[08:28:06.772]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.761] - result already collected: FutureResult
[08:28:06.772]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.761] result() for ClusterFuture ... done
[08:28:06.772]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.761] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:06.772]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.761] result() for ClusterFuture ... done
[08:28:06.773]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.761] result() for ClusterFuture ...
[08:28:06.773]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.761] - result already collected: FutureResult
[08:28:06.773]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.761] result() for ClusterFuture ... done
[08:28:06.773] signalConditions() ... done
[08:28:06.773] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[08:28:06.773] Searching for globals...
[08:28:06.774] - globals found: [3] ‘{’, ‘plan’, ‘sequential’
[08:28:06.774] Searching for globals ... DONE
[08:28:06.774] Resolving globals: FALSE
[08:28:06.775] 
[08:28:06.775] - packages: [1] ‘future’
[08:28:06.775] getGlobalsAndPackages() ... DONE
[08:28:06.775] run() for ‘Future’ ...
[08:28:06.775] - state: ‘created’
[08:28:06.776] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:06.776] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:06.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:06.776]   - Field: ‘label’
[08:28:06.776]   - Field: ‘local’
[08:28:06.776]   - Field: ‘owner’
[08:28:06.776]   - Field: ‘envir’
[08:28:06.776]   - Field: ‘packages’
[08:28:06.776]   - Field: ‘gc’
[08:28:06.777]   - Field: ‘conditions’
[08:28:06.777]   - Field: ‘expr’
[08:28:06.777]   - Field: ‘uuid’
[08:28:06.777]   - Field: ‘seed’
[08:28:06.777]   - Field: ‘version’
[08:28:06.777]   - Field: ‘result’
[08:28:06.777]   - Field: ‘asynchronous’
[08:28:06.777]   - Field: ‘calls’
[08:28:06.777]   - Field: ‘globals’
[08:28:06.777]   - Field: ‘stdout’
[08:28:06.777]   - Field: ‘earlySignal’
[08:28:06.777]   - Field: ‘lazy’
[08:28:06.778]   - Field: ‘state’
[08:28:06.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:06.778] - Launch lazy future ...
[08:28:06.778] Packages needed by the future expression (n = 1): ‘future’
[08:28:06.778] Packages needed by future strategies (n = 1): ‘future’
[08:28:06.779] {
[08:28:06.779]     {
[08:28:06.779]         {
[08:28:06.779]             ...future.startTime <- base::Sys.time()
[08:28:06.779]             {
[08:28:06.779]                 {
[08:28:06.779]                   {
[08:28:06.779]                     {
[08:28:06.779]                       base::local({
[08:28:06.779]                         has_future <- base::requireNamespace("future", 
[08:28:06.779]                           quietly = TRUE)
[08:28:06.779]                         if (has_future) {
[08:28:06.779]                           ns <- base::getNamespace("future")
[08:28:06.779]                           version <- ns[[".package"]][["version"]]
[08:28:06.779]                           if (is.null(version)) 
[08:28:06.779]                             version <- utils::packageVersion("future")
[08:28:06.779]                         }
[08:28:06.779]                         else {
[08:28:06.779]                           version <- NULL
[08:28:06.779]                         }
[08:28:06.779]                         if (!has_future || version < "1.8.0") {
[08:28:06.779]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:06.779]                             "", base::R.version$version.string), 
[08:28:06.779]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:06.779]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:06.779]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:06.779]                               "release", "version")], collapse = " "), 
[08:28:06.779]                             hostname = base::Sys.info()[["nodename"]])
[08:28:06.779]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:06.779]                             info)
[08:28:06.779]                           info <- base::paste(info, collapse = "; ")
[08:28:06.779]                           if (!has_future) {
[08:28:06.779]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:06.779]                               info)
[08:28:06.779]                           }
[08:28:06.779]                           else {
[08:28:06.779]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:06.779]                               info, version)
[08:28:06.779]                           }
[08:28:06.779]                           base::stop(msg)
[08:28:06.779]                         }
[08:28:06.779]                       })
[08:28:06.779]                     }
[08:28:06.779]                     base::local({
[08:28:06.779]                       for (pkg in "future") {
[08:28:06.779]                         base::loadNamespace(pkg)
[08:28:06.779]                         base::library(pkg, character.only = TRUE)
[08:28:06.779]                       }
[08:28:06.779]                     })
[08:28:06.779]                   }
[08:28:06.779]                   ...future.strategy.old <- future::plan("list")
[08:28:06.779]                   options(future.plan = NULL)
[08:28:06.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.779]                   future::plan(list(function (..., workers = availableCores(), 
[08:28:06.779]                     lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:06.779]                     envir = parent.frame()) 
[08:28:06.779]                   {
[08:28:06.779]                     if (is.function(workers)) 
[08:28:06.779]                       workers <- workers()
[08:28:06.779]                     workers <- structure(as.integer(workers), 
[08:28:06.779]                       class = class(workers))
[08:28:06.779]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[08:28:06.779]                       workers >= 1)
[08:28:06.779]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[08:28:06.779]                       return(sequential(..., lazy = TRUE, envir = envir))
[08:28:06.779]                     }
[08:28:06.779]                     future <- MultisessionFuture(..., workers = workers, 
[08:28:06.779]                       lazy = lazy, rscript_libs = rscript_libs, 
[08:28:06.779]                       envir = envir)
[08:28:06.779]                     if (!future$lazy) 
[08:28:06.779]                       future <- run(future)
[08:28:06.779]                     invisible(future)
[08:28:06.779]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:06.779]                 }
[08:28:06.779]                 ...future.workdir <- getwd()
[08:28:06.779]             }
[08:28:06.779]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:06.779]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:06.779]         }
[08:28:06.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[08:28:06.779]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:06.779]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[08:28:06.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:06.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:06.779]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:06.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:06.779]             base::names(...future.oldOptions))
[08:28:06.779]     }
[08:28:06.779]     if (FALSE) {
[08:28:06.779]     }
[08:28:06.779]     else {
[08:28:06.779]         if (TRUE) {
[08:28:06.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:06.779]                 open = "w")
[08:28:06.779]         }
[08:28:06.779]         else {
[08:28:06.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:06.779]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:06.779]         }
[08:28:06.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:06.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:06.779]             base::sink(type = "output", split = FALSE)
[08:28:06.779]             base::close(...future.stdout)
[08:28:06.779]         }, add = TRUE)
[08:28:06.779]     }
[08:28:06.779]     ...future.frame <- base::sys.nframe()
[08:28:06.779]     ...future.conditions <- base::list()
[08:28:06.779]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:06.779]     if (FALSE) {
[08:28:06.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:06.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:06.779]     }
[08:28:06.779]     ...future.result <- base::tryCatch({
[08:28:06.779]         base::withCallingHandlers({
[08:28:06.779]             ...future.value <- base::withVisible(base::local({
[08:28:06.779]                 plan(sequential)
[08:28:06.779]             }))
[08:28:06.779]             future::FutureResult(value = ...future.value$value, 
[08:28:06.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.779]                   ...future.rng), globalenv = if (FALSE) 
[08:28:06.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:06.779]                     ...future.globalenv.names))
[08:28:06.779]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:06.779]         }, condition = base::local({
[08:28:06.779]             c <- base::c
[08:28:06.779]             inherits <- base::inherits
[08:28:06.779]             invokeRestart <- base::invokeRestart
[08:28:06.779]             length <- base::length
[08:28:06.779]             list <- base::list
[08:28:06.779]             seq.int <- base::seq.int
[08:28:06.779]             signalCondition <- base::signalCondition
[08:28:06.779]             sys.calls <- base::sys.calls
[08:28:06.779]             `[[` <- base::`[[`
[08:28:06.779]             `+` <- base::`+`
[08:28:06.779]             `<<-` <- base::`<<-`
[08:28:06.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:06.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:06.779]                   3L)]
[08:28:06.779]             }
[08:28:06.779]             function(cond) {
[08:28:06.779]                 is_error <- inherits(cond, "error")
[08:28:06.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:06.779]                   NULL)
[08:28:06.779]                 if (is_error) {
[08:28:06.779]                   sessionInformation <- function() {
[08:28:06.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:06.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:06.779]                       search = base::search(), system = base::Sys.info())
[08:28:06.779]                   }
[08:28:06.779]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:06.779]                     cond$call), session = sessionInformation(), 
[08:28:06.779]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:06.779]                   signalCondition(cond)
[08:28:06.779]                 }
[08:28:06.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:06.779]                 "immediateCondition"))) {
[08:28:06.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:06.779]                   ...future.conditions[[length(...future.conditions) + 
[08:28:06.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:06.779]                   if (TRUE && !signal) {
[08:28:06.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.779]                     {
[08:28:06.779]                       inherits <- base::inherits
[08:28:06.779]                       invokeRestart <- base::invokeRestart
[08:28:06.779]                       is.null <- base::is.null
[08:28:06.779]                       muffled <- FALSE
[08:28:06.779]                       if (inherits(cond, "message")) {
[08:28:06.779]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.779]                         if (muffled) 
[08:28:06.779]                           invokeRestart("muffleMessage")
[08:28:06.779]                       }
[08:28:06.779]                       else if (inherits(cond, "warning")) {
[08:28:06.779]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.779]                         if (muffled) 
[08:28:06.779]                           invokeRestart("muffleWarning")
[08:28:06.779]                       }
[08:28:06.779]                       else if (inherits(cond, "condition")) {
[08:28:06.779]                         if (!is.null(pattern)) {
[08:28:06.779]                           computeRestarts <- base::computeRestarts
[08:28:06.779]                           grepl <- base::grepl
[08:28:06.779]                           restarts <- computeRestarts(cond)
[08:28:06.779]                           for (restart in restarts) {
[08:28:06.779]                             name <- restart$name
[08:28:06.779]                             if (is.null(name)) 
[08:28:06.779]                               next
[08:28:06.779]                             if (!grepl(pattern, name)) 
[08:28:06.779]                               next
[08:28:06.779]                             invokeRestart(restart)
[08:28:06.779]                             muffled <- TRUE
[08:28:06.779]                             break
[08:28:06.779]                           }
[08:28:06.779]                         }
[08:28:06.779]                       }
[08:28:06.779]                       invisible(muffled)
[08:28:06.779]                     }
[08:28:06.779]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.779]                   }
[08:28:06.779]                 }
[08:28:06.779]                 else {
[08:28:06.779]                   if (TRUE) {
[08:28:06.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:06.779]                     {
[08:28:06.779]                       inherits <- base::inherits
[08:28:06.779]                       invokeRestart <- base::invokeRestart
[08:28:06.779]                       is.null <- base::is.null
[08:28:06.779]                       muffled <- FALSE
[08:28:06.779]                       if (inherits(cond, "message")) {
[08:28:06.779]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:06.779]                         if (muffled) 
[08:28:06.779]                           invokeRestart("muffleMessage")
[08:28:06.779]                       }
[08:28:06.779]                       else if (inherits(cond, "warning")) {
[08:28:06.779]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:06.779]                         if (muffled) 
[08:28:06.779]                           invokeRestart("muffleWarning")
[08:28:06.779]                       }
[08:28:06.779]                       else if (inherits(cond, "condition")) {
[08:28:06.779]                         if (!is.null(pattern)) {
[08:28:06.779]                           computeRestarts <- base::computeRestarts
[08:28:06.779]                           grepl <- base::grepl
[08:28:06.779]                           restarts <- computeRestarts(cond)
[08:28:06.779]                           for (restart in restarts) {
[08:28:06.779]                             name <- restart$name
[08:28:06.779]                             if (is.null(name)) 
[08:28:06.779]                               next
[08:28:06.779]                             if (!grepl(pattern, name)) 
[08:28:06.779]                               next
[08:28:06.779]                             invokeRestart(restart)
[08:28:06.779]                             muffled <- TRUE
[08:28:06.779]                             break
[08:28:06.779]                           }
[08:28:06.779]                         }
[08:28:06.779]                       }
[08:28:06.779]                       invisible(muffled)
[08:28:06.779]                     }
[08:28:06.779]                     muffleCondition(cond, pattern = "^muffle")
[08:28:06.779]                   }
[08:28:06.779]                 }
[08:28:06.779]             }
[08:28:06.779]         }))
[08:28:06.779]     }, error = function(ex) {
[08:28:06.779]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:06.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:06.779]                 ...future.rng), started = ...future.startTime, 
[08:28:06.779]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:06.779]             version = "1.8"), class = "FutureResult")
[08:28:06.779]     }, finally = {
[08:28:06.779]         if (!identical(...future.workdir, getwd())) 
[08:28:06.779]             setwd(...future.workdir)
[08:28:06.779]         {
[08:28:06.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:06.779]                 ...future.oldOptions$nwarnings <- NULL
[08:28:06.779]             }
[08:28:06.779]             base::options(...future.oldOptions)
[08:28:06.779]             if (.Platform$OS.type == "windows") {
[08:28:06.779]                 old_names <- names(...future.oldEnvVars)
[08:28:06.779]                 envs <- base::Sys.getenv()
[08:28:06.779]                 names <- names(envs)
[08:28:06.779]                 common <- intersect(names, old_names)
[08:28:06.779]                 added <- setdiff(names, old_names)
[08:28:06.779]                 removed <- setdiff(old_names, names)
[08:28:06.779]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:06.779]                   envs[common]]
[08:28:06.779]                 NAMES <- toupper(changed)
[08:28:06.779]                 args <- list()
[08:28:06.779]                 for (kk in seq_along(NAMES)) {
[08:28:06.779]                   name <- changed[[kk]]
[08:28:06.779]                   NAME <- NAMES[[kk]]
[08:28:06.779]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.779]                     next
[08:28:06.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.779]                 }
[08:28:06.779]                 NAMES <- toupper(added)
[08:28:06.779]                 for (kk in seq_along(NAMES)) {
[08:28:06.779]                   name <- added[[kk]]
[08:28:06.779]                   NAME <- NAMES[[kk]]
[08:28:06.779]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.779]                     next
[08:28:06.779]                   args[[name]] <- ""
[08:28:06.779]                 }
[08:28:06.779]                 NAMES <- toupper(removed)
[08:28:06.779]                 for (kk in seq_along(NAMES)) {
[08:28:06.779]                   name <- removed[[kk]]
[08:28:06.779]                   NAME <- NAMES[[kk]]
[08:28:06.779]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:06.779]                     next
[08:28:06.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:06.779]                 }
[08:28:06.779]                 if (length(args) > 0) 
[08:28:06.779]                   base::do.call(base::Sys.setenv, args = args)
[08:28:06.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:06.779]             }
[08:28:06.779]             else {
[08:28:06.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:06.779]             }
[08:28:06.779]             {
[08:28:06.779]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:06.779]                   0L) {
[08:28:06.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:06.779]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:06.779]                   base::options(opts)
[08:28:06.779]                 }
[08:28:06.779]                 {
[08:28:06.779]                   {
[08:28:06.779]                     NULL
[08:28:06.779]                     RNGkind("Mersenne-Twister")
[08:28:06.779]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:06.779]                       inherits = FALSE)
[08:28:06.779]                   }
[08:28:06.779]                   options(future.plan = NULL)
[08:28:06.779]                   if (is.na(NA_character_)) 
[08:28:06.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:06.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:06.779]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:06.779]                     .init = FALSE)
[08:28:06.779]                 }
[08:28:06.779]             }
[08:28:06.779]         }
[08:28:06.779]     })
[08:28:06.779]     if (TRUE) {
[08:28:06.779]         base::sink(type = "output", split = FALSE)
[08:28:06.779]         if (TRUE) {
[08:28:06.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:06.779]         }
[08:28:06.779]         else {
[08:28:06.779]             ...future.result["stdout"] <- base::list(NULL)
[08:28:06.779]         }
[08:28:06.779]         base::close(...future.stdout)
[08:28:06.779]         ...future.stdout <- NULL
[08:28:06.779]     }
[08:28:06.779]     ...future.result$conditions <- ...future.conditions
[08:28:06.779]     ...future.result$finished <- base::Sys.time()
[08:28:06.779]     ...future.result
[08:28:06.779] }
[08:28:06.781] plan(): Setting new future strategy stack:
[08:28:06.781] List of future strategies:
[08:28:06.781] 1. multisession:
[08:28:06.781]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:06.781]    - tweaked: FALSE
[08:28:06.781]    - call: plan(list(sequential, strategy))
[08:28:06.782] plan(): nbrOfWorkers() = 2
[08:28:06.798] plan(): Setting new future strategy stack:
[08:28:06.798] List of future strategies:
[08:28:06.798] 1. sequential:
[08:28:06.798]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:06.798]    - tweaked: FALSE
[08:28:06.798]    - call: plan(list(sequential, strategy))
[08:28:06.798] 2. multisession:
[08:28:06.798]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:06.798]    - tweaked: FALSE
[08:28:06.798]    - call: plan(list(sequential, strategy))
[08:28:06.799] plan(): nbrOfWorkers() = 1
[08:28:06.799] SequentialFuture started (and completed)
[08:28:06.799] signalConditions() ...
[08:28:06.799]  - include = ‘immediateCondition’
[08:28:06.799]  - exclude = 
[08:28:06.799]  - resignal = FALSE
[08:28:06.800]  - Number of conditions: 3
[08:28:06.800] signalConditions() ... done
[08:28:06.800] - Launch lazy future ... done
[08:28:06.800] run() for ‘SequentialFuture’ ... done
[08:28:06.800] signalConditions() ...
[08:28:06.800]  - include = ‘immediateCondition’
[08:28:06.801]  - exclude = 
[08:28:06.801]  - resignal = FALSE
[08:28:06.801]  - Number of conditions: 3
[08:28:06.801] signalConditions() ... done
[08:28:06.801] Future state: ‘finished’
[08:28:06.801] signalConditions() ...
[08:28:06.801]  - include = ‘condition’
[08:28:06.802]  - exclude = ‘immediateCondition’
[08:28:06.802]  - resignal = TRUE
[08:28:06.802]  - Number of conditions: 3
[08:28:06.802]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.783] plan(): Setting new future strategy stack:
[08:28:06.802]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.783] List of future strategies:
[08:28:06.783] 1. sequential:
[08:28:06.783]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:06.783]    - tweaked: FALSE
[08:28:06.783]    - call: plan(sequential)
[08:28:06.803]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:06.797] plan(): nbrOfWorkers() = 1
[08:28:06.803] signalConditions() ... done
List of future strategies:
1. multisession:
   - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
   - tweaked: FALSE
   - call: plan(list(sequential, strategy))
- Strategy: multisession ... DONE
> 
> 
> message("*** Globals w/ non-standard evaluation (NSE) ... DONE")
*** Globals w/ non-standard evaluation (NSE) ... DONE
> 
> source("incl/end.R")
[08:28:06.804] plan(): Setting new future strategy stack:
[08:28:06.804] List of future strategies:
[08:28:06.804] 1. FutureStrategy:
[08:28:06.804]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:06.804]    - tweaked: FALSE
[08:28:06.804]    - call: future::plan(oplan)
[08:28:06.805] plan(): nbrOfWorkers() = 1
> 
