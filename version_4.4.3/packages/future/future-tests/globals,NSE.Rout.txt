
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:01:42.996] plan(): Setting new future strategy stack:
[11:01:42.997] List of future strategies:
[11:01:42.997] 1. sequential:
[11:01:42.997]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:42.997]    - tweaked: FALSE
[11:01:42.997]    - call: future::plan("sequential")
[11:01:43.010] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** Globals w/ non-standard evaluation (NSE) ...")
*** Globals w/ non-standard evaluation (NSE) ...
> 
> data <- data.frame(x = 1:5, y = 1:5)
> v0 <- subset(data, x < 3)$y
> 
> for (strategy in supportedStrategies()) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("- Strategy: %s ...", strategy))
+   
+   plan(strategy)
+ 
+   ## Assert option is passed on to future
+   options(future.globals.onMissing = "error")
+   opt1 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt1, "error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   opt2 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt2, "ignore"))
+ 
+   options(future.globals.onMissing = "error")
+   res <- try({ v1 %<-% subset(data, x < 3)$y }, silent = TRUE)
+   stopifnot(inherits(res, "try-error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   v2 %<-% subset(data, x < 3)$y
+   stopifnot(identical(v2, v0))
+ 
+   ## Nested futures (requires option is passed on to future)
+   plan(list(sequential, strategy))
+   options(future.globals.onMissing = "ignore")
+   v3 %<-% {
+     a %<-% subset(data, x < 3)$y
+     a
+   } %lazy% TRUE
+   stopifnot(identical(v3, v0))
+ 
+   ## Make sure to shut down nested parallel workers
+   void %<-% { plan(sequential) }
+   print(void)
+ 
+   message(sprintf("- Strategy: %s ... DONE", strategy))
+ }
- Strategy: sequential ...
[11:01:43.044] plan(): Setting new future strategy stack:
[11:01:43.044] List of future strategies:
[11:01:43.044] 1. sequential:
[11:01:43.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.044]    - tweaked: FALSE
[11:01:43.044]    - call: plan(strategy)
[11:01:43.056] plan(): nbrOfWorkers() = 1
[11:01:43.057] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:43.058] Searching for globals...
[11:01:43.061] - globals found: [1] ‘getOption’
[11:01:43.061] Searching for globals ... DONE
[11:01:43.061] Resolving globals: FALSE
[11:01:43.062] 
[11:01:43.062] 
[11:01:43.062] getGlobalsAndPackages() ... DONE
[11:01:43.062] run() for ‘Future’ ...
[11:01:43.063] - state: ‘created’
[11:01:43.063] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:43.063] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:43.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:43.063]   - Field: ‘label’
[11:01:43.063]   - Field: ‘local’
[11:01:43.063]   - Field: ‘owner’
[11:01:43.064]   - Field: ‘envir’
[11:01:43.064]   - Field: ‘packages’
[11:01:43.064]   - Field: ‘gc’
[11:01:43.064]   - Field: ‘conditions’
[11:01:43.064]   - Field: ‘expr’
[11:01:43.064]   - Field: ‘uuid’
[11:01:43.064]   - Field: ‘seed’
[11:01:43.064]   - Field: ‘version’
[11:01:43.064]   - Field: ‘result’
[11:01:43.064]   - Field: ‘asynchronous’
[11:01:43.064]   - Field: ‘calls’
[11:01:43.065]   - Field: ‘globals’
[11:01:43.065]   - Field: ‘stdout’
[11:01:43.065]   - Field: ‘earlySignal’
[11:01:43.065]   - Field: ‘lazy’
[11:01:43.065]   - Field: ‘state’
[11:01:43.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:43.065] - Launch lazy future ...
[11:01:43.066] Packages needed by the future expression (n = 0): <none>
[11:01:43.066] Packages needed by future strategies (n = 0): <none>
[11:01:43.066] {
[11:01:43.066]     {
[11:01:43.066]         {
[11:01:43.066]             ...future.startTime <- base::Sys.time()
[11:01:43.066]             {
[11:01:43.066]                 {
[11:01:43.066]                   {
[11:01:43.066]                     base::local({
[11:01:43.066]                       has_future <- base::requireNamespace("future", 
[11:01:43.066]                         quietly = TRUE)
[11:01:43.066]                       if (has_future) {
[11:01:43.066]                         ns <- base::getNamespace("future")
[11:01:43.066]                         version <- ns[[".package"]][["version"]]
[11:01:43.066]                         if (is.null(version)) 
[11:01:43.066]                           version <- utils::packageVersion("future")
[11:01:43.066]                       }
[11:01:43.066]                       else {
[11:01:43.066]                         version <- NULL
[11:01:43.066]                       }
[11:01:43.066]                       if (!has_future || version < "1.8.0") {
[11:01:43.066]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.066]                           "", base::R.version$version.string), 
[11:01:43.066]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:43.066]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.066]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.066]                             "release", "version")], collapse = " "), 
[11:01:43.066]                           hostname = base::Sys.info()[["nodename"]])
[11:01:43.066]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.066]                           info)
[11:01:43.066]                         info <- base::paste(info, collapse = "; ")
[11:01:43.066]                         if (!has_future) {
[11:01:43.066]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.066]                             info)
[11:01:43.066]                         }
[11:01:43.066]                         else {
[11:01:43.066]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.066]                             info, version)
[11:01:43.066]                         }
[11:01:43.066]                         base::stop(msg)
[11:01:43.066]                       }
[11:01:43.066]                     })
[11:01:43.066]                   }
[11:01:43.066]                   ...future.strategy.old <- future::plan("list")
[11:01:43.066]                   options(future.plan = NULL)
[11:01:43.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:43.066]                 }
[11:01:43.066]                 ...future.workdir <- getwd()
[11:01:43.066]             }
[11:01:43.066]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.066]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.066]         }
[11:01:43.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:43.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.066]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:43.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.066]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.066]             base::names(...future.oldOptions))
[11:01:43.066]     }
[11:01:43.066]     if (FALSE) {
[11:01:43.066]     }
[11:01:43.066]     else {
[11:01:43.066]         if (TRUE) {
[11:01:43.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.066]                 open = "w")
[11:01:43.066]         }
[11:01:43.066]         else {
[11:01:43.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.066]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.066]         }
[11:01:43.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.066]             base::sink(type = "output", split = FALSE)
[11:01:43.066]             base::close(...future.stdout)
[11:01:43.066]         }, add = TRUE)
[11:01:43.066]     }
[11:01:43.066]     ...future.frame <- base::sys.nframe()
[11:01:43.066]     ...future.conditions <- base::list()
[11:01:43.066]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.066]     if (FALSE) {
[11:01:43.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.066]     }
[11:01:43.066]     ...future.result <- base::tryCatch({
[11:01:43.066]         base::withCallingHandlers({
[11:01:43.066]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[11:01:43.066]             future::FutureResult(value = ...future.value$value, 
[11:01:43.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.066]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.066]                     ...future.globalenv.names))
[11:01:43.066]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.066]         }, condition = base::local({
[11:01:43.066]             c <- base::c
[11:01:43.066]             inherits <- base::inherits
[11:01:43.066]             invokeRestart <- base::invokeRestart
[11:01:43.066]             length <- base::length
[11:01:43.066]             list <- base::list
[11:01:43.066]             seq.int <- base::seq.int
[11:01:43.066]             signalCondition <- base::signalCondition
[11:01:43.066]             sys.calls <- base::sys.calls
[11:01:43.066]             `[[` <- base::`[[`
[11:01:43.066]             `+` <- base::`+`
[11:01:43.066]             `<<-` <- base::`<<-`
[11:01:43.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.066]                   3L)]
[11:01:43.066]             }
[11:01:43.066]             function(cond) {
[11:01:43.066]                 is_error <- inherits(cond, "error")
[11:01:43.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.066]                   NULL)
[11:01:43.066]                 if (is_error) {
[11:01:43.066]                   sessionInformation <- function() {
[11:01:43.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.066]                       search = base::search(), system = base::Sys.info())
[11:01:43.066]                   }
[11:01:43.066]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.066]                     cond$call), session = sessionInformation(), 
[11:01:43.066]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.066]                   signalCondition(cond)
[11:01:43.066]                 }
[11:01:43.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.066]                 "immediateCondition"))) {
[11:01:43.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.066]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.066]                   if (TRUE && !signal) {
[11:01:43.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.066]                     {
[11:01:43.066]                       inherits <- base::inherits
[11:01:43.066]                       invokeRestart <- base::invokeRestart
[11:01:43.066]                       is.null <- base::is.null
[11:01:43.066]                       muffled <- FALSE
[11:01:43.066]                       if (inherits(cond, "message")) {
[11:01:43.066]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.066]                         if (muffled) 
[11:01:43.066]                           invokeRestart("muffleMessage")
[11:01:43.066]                       }
[11:01:43.066]                       else if (inherits(cond, "warning")) {
[11:01:43.066]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.066]                         if (muffled) 
[11:01:43.066]                           invokeRestart("muffleWarning")
[11:01:43.066]                       }
[11:01:43.066]                       else if (inherits(cond, "condition")) {
[11:01:43.066]                         if (!is.null(pattern)) {
[11:01:43.066]                           computeRestarts <- base::computeRestarts
[11:01:43.066]                           grepl <- base::grepl
[11:01:43.066]                           restarts <- computeRestarts(cond)
[11:01:43.066]                           for (restart in restarts) {
[11:01:43.066]                             name <- restart$name
[11:01:43.066]                             if (is.null(name)) 
[11:01:43.066]                               next
[11:01:43.066]                             if (!grepl(pattern, name)) 
[11:01:43.066]                               next
[11:01:43.066]                             invokeRestart(restart)
[11:01:43.066]                             muffled <- TRUE
[11:01:43.066]                             break
[11:01:43.066]                           }
[11:01:43.066]                         }
[11:01:43.066]                       }
[11:01:43.066]                       invisible(muffled)
[11:01:43.066]                     }
[11:01:43.066]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.066]                   }
[11:01:43.066]                 }
[11:01:43.066]                 else {
[11:01:43.066]                   if (TRUE) {
[11:01:43.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.066]                     {
[11:01:43.066]                       inherits <- base::inherits
[11:01:43.066]                       invokeRestart <- base::invokeRestart
[11:01:43.066]                       is.null <- base::is.null
[11:01:43.066]                       muffled <- FALSE
[11:01:43.066]                       if (inherits(cond, "message")) {
[11:01:43.066]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.066]                         if (muffled) 
[11:01:43.066]                           invokeRestart("muffleMessage")
[11:01:43.066]                       }
[11:01:43.066]                       else if (inherits(cond, "warning")) {
[11:01:43.066]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.066]                         if (muffled) 
[11:01:43.066]                           invokeRestart("muffleWarning")
[11:01:43.066]                       }
[11:01:43.066]                       else if (inherits(cond, "condition")) {
[11:01:43.066]                         if (!is.null(pattern)) {
[11:01:43.066]                           computeRestarts <- base::computeRestarts
[11:01:43.066]                           grepl <- base::grepl
[11:01:43.066]                           restarts <- computeRestarts(cond)
[11:01:43.066]                           for (restart in restarts) {
[11:01:43.066]                             name <- restart$name
[11:01:43.066]                             if (is.null(name)) 
[11:01:43.066]                               next
[11:01:43.066]                             if (!grepl(pattern, name)) 
[11:01:43.066]                               next
[11:01:43.066]                             invokeRestart(restart)
[11:01:43.066]                             muffled <- TRUE
[11:01:43.066]                             break
[11:01:43.066]                           }
[11:01:43.066]                         }
[11:01:43.066]                       }
[11:01:43.066]                       invisible(muffled)
[11:01:43.066]                     }
[11:01:43.066]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.066]                   }
[11:01:43.066]                 }
[11:01:43.066]             }
[11:01:43.066]         }))
[11:01:43.066]     }, error = function(ex) {
[11:01:43.066]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.066]                 ...future.rng), started = ...future.startTime, 
[11:01:43.066]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.066]             version = "1.8"), class = "FutureResult")
[11:01:43.066]     }, finally = {
[11:01:43.066]         if (!identical(...future.workdir, getwd())) 
[11:01:43.066]             setwd(...future.workdir)
[11:01:43.066]         {
[11:01:43.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.066]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.066]             }
[11:01:43.066]             base::options(...future.oldOptions)
[11:01:43.066]             if (.Platform$OS.type == "windows") {
[11:01:43.066]                 old_names <- names(...future.oldEnvVars)
[11:01:43.066]                 envs <- base::Sys.getenv()
[11:01:43.066]                 names <- names(envs)
[11:01:43.066]                 common <- intersect(names, old_names)
[11:01:43.066]                 added <- setdiff(names, old_names)
[11:01:43.066]                 removed <- setdiff(old_names, names)
[11:01:43.066]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.066]                   envs[common]]
[11:01:43.066]                 NAMES <- toupper(changed)
[11:01:43.066]                 args <- list()
[11:01:43.066]                 for (kk in seq_along(NAMES)) {
[11:01:43.066]                   name <- changed[[kk]]
[11:01:43.066]                   NAME <- NAMES[[kk]]
[11:01:43.066]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.066]                     next
[11:01:43.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.066]                 }
[11:01:43.066]                 NAMES <- toupper(added)
[11:01:43.066]                 for (kk in seq_along(NAMES)) {
[11:01:43.066]                   name <- added[[kk]]
[11:01:43.066]                   NAME <- NAMES[[kk]]
[11:01:43.066]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.066]                     next
[11:01:43.066]                   args[[name]] <- ""
[11:01:43.066]                 }
[11:01:43.066]                 NAMES <- toupper(removed)
[11:01:43.066]                 for (kk in seq_along(NAMES)) {
[11:01:43.066]                   name <- removed[[kk]]
[11:01:43.066]                   NAME <- NAMES[[kk]]
[11:01:43.066]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.066]                     next
[11:01:43.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.066]                 }
[11:01:43.066]                 if (length(args) > 0) 
[11:01:43.066]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.066]             }
[11:01:43.066]             else {
[11:01:43.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.066]             }
[11:01:43.066]             {
[11:01:43.066]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.066]                   0L) {
[11:01:43.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.066]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.066]                   base::options(opts)
[11:01:43.066]                 }
[11:01:43.066]                 {
[11:01:43.066]                   {
[11:01:43.066]                     NULL
[11:01:43.066]                     RNGkind("Mersenne-Twister")
[11:01:43.066]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:43.066]                       inherits = FALSE)
[11:01:43.066]                   }
[11:01:43.066]                   options(future.plan = NULL)
[11:01:43.066]                   if (is.na(NA_character_)) 
[11:01:43.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.066]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.066]                     .init = FALSE)
[11:01:43.066]                 }
[11:01:43.066]             }
[11:01:43.066]         }
[11:01:43.066]     })
[11:01:43.066]     if (TRUE) {
[11:01:43.066]         base::sink(type = "output", split = FALSE)
[11:01:43.066]         if (TRUE) {
[11:01:43.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.066]         }
[11:01:43.066]         else {
[11:01:43.066]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.066]         }
[11:01:43.066]         base::close(...future.stdout)
[11:01:43.066]         ...future.stdout <- NULL
[11:01:43.066]     }
[11:01:43.066]     ...future.result$conditions <- ...future.conditions
[11:01:43.066]     ...future.result$finished <- base::Sys.time()
[11:01:43.066]     ...future.result
[11:01:43.066] }
[11:01:43.068] plan(): Setting new future strategy stack:
[11:01:43.068] List of future strategies:
[11:01:43.068] 1. sequential:
[11:01:43.068]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.068]    - tweaked: FALSE
[11:01:43.068]    - call: NULL
[11:01:43.069] plan(): nbrOfWorkers() = 1
[11:01:43.070] plan(): Setting new future strategy stack:
[11:01:43.070] List of future strategies:
[11:01:43.070] 1. sequential:
[11:01:43.070]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.070]    - tweaked: FALSE
[11:01:43.070]    - call: plan(strategy)
[11:01:43.071] plan(): nbrOfWorkers() = 1
[11:01:43.071] SequentialFuture started (and completed)
[11:01:43.071] - Launch lazy future ... done
[11:01:43.071] run() for ‘SequentialFuture’ ... done
[11:01:43.072] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.072] Searching for globals...
[11:01:43.072] - globals found: [1] ‘getOption’
[11:01:43.072] Searching for globals ... DONE
[11:01:43.073] Resolving globals: FALSE
[11:01:43.073] 
[11:01:43.073] 
[11:01:43.073] getGlobalsAndPackages() ... DONE
[11:01:43.073] run() for ‘Future’ ...
[11:01:43.073] - state: ‘created’
[11:01:43.073] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:43.074] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:43.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:43.074]   - Field: ‘label’
[11:01:43.074]   - Field: ‘local’
[11:01:43.074]   - Field: ‘owner’
[11:01:43.074]   - Field: ‘envir’
[11:01:43.074]   - Field: ‘packages’
[11:01:43.074]   - Field: ‘gc’
[11:01:43.074]   - Field: ‘conditions’
[11:01:43.074]   - Field: ‘expr’
[11:01:43.075]   - Field: ‘uuid’
[11:01:43.075]   - Field: ‘seed’
[11:01:43.075]   - Field: ‘version’
[11:01:43.075]   - Field: ‘result’
[11:01:43.075]   - Field: ‘asynchronous’
[11:01:43.075]   - Field: ‘calls’
[11:01:43.075]   - Field: ‘globals’
[11:01:43.075]   - Field: ‘stdout’
[11:01:43.075]   - Field: ‘earlySignal’
[11:01:43.075]   - Field: ‘lazy’
[11:01:43.075]   - Field: ‘state’
[11:01:43.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:43.076] - Launch lazy future ...
[11:01:43.076] Packages needed by the future expression (n = 0): <none>
[11:01:43.076] Packages needed by future strategies (n = 0): <none>
[11:01:43.076] {
[11:01:43.076]     {
[11:01:43.076]         {
[11:01:43.076]             ...future.startTime <- base::Sys.time()
[11:01:43.076]             {
[11:01:43.076]                 {
[11:01:43.076]                   {
[11:01:43.076]                     base::local({
[11:01:43.076]                       has_future <- base::requireNamespace("future", 
[11:01:43.076]                         quietly = TRUE)
[11:01:43.076]                       if (has_future) {
[11:01:43.076]                         ns <- base::getNamespace("future")
[11:01:43.076]                         version <- ns[[".package"]][["version"]]
[11:01:43.076]                         if (is.null(version)) 
[11:01:43.076]                           version <- utils::packageVersion("future")
[11:01:43.076]                       }
[11:01:43.076]                       else {
[11:01:43.076]                         version <- NULL
[11:01:43.076]                       }
[11:01:43.076]                       if (!has_future || version < "1.8.0") {
[11:01:43.076]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.076]                           "", base::R.version$version.string), 
[11:01:43.076]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:43.076]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.076]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.076]                             "release", "version")], collapse = " "), 
[11:01:43.076]                           hostname = base::Sys.info()[["nodename"]])
[11:01:43.076]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.076]                           info)
[11:01:43.076]                         info <- base::paste(info, collapse = "; ")
[11:01:43.076]                         if (!has_future) {
[11:01:43.076]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.076]                             info)
[11:01:43.076]                         }
[11:01:43.076]                         else {
[11:01:43.076]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.076]                             info, version)
[11:01:43.076]                         }
[11:01:43.076]                         base::stop(msg)
[11:01:43.076]                       }
[11:01:43.076]                     })
[11:01:43.076]                   }
[11:01:43.076]                   ...future.strategy.old <- future::plan("list")
[11:01:43.076]                   options(future.plan = NULL)
[11:01:43.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:43.076]                 }
[11:01:43.076]                 ...future.workdir <- getwd()
[11:01:43.076]             }
[11:01:43.076]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.076]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.076]         }
[11:01:43.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.076]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.076]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.076]             base::names(...future.oldOptions))
[11:01:43.076]     }
[11:01:43.076]     if (FALSE) {
[11:01:43.076]     }
[11:01:43.076]     else {
[11:01:43.076]         if (TRUE) {
[11:01:43.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.076]                 open = "w")
[11:01:43.076]         }
[11:01:43.076]         else {
[11:01:43.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.076]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.076]         }
[11:01:43.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.076]             base::sink(type = "output", split = FALSE)
[11:01:43.076]             base::close(...future.stdout)
[11:01:43.076]         }, add = TRUE)
[11:01:43.076]     }
[11:01:43.076]     ...future.frame <- base::sys.nframe()
[11:01:43.076]     ...future.conditions <- base::list()
[11:01:43.076]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.076]     if (FALSE) {
[11:01:43.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.076]     }
[11:01:43.076]     ...future.result <- base::tryCatch({
[11:01:43.076]         base::withCallingHandlers({
[11:01:43.076]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[11:01:43.076]             future::FutureResult(value = ...future.value$value, 
[11:01:43.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.076]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.076]                     ...future.globalenv.names))
[11:01:43.076]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.076]         }, condition = base::local({
[11:01:43.076]             c <- base::c
[11:01:43.076]             inherits <- base::inherits
[11:01:43.076]             invokeRestart <- base::invokeRestart
[11:01:43.076]             length <- base::length
[11:01:43.076]             list <- base::list
[11:01:43.076]             seq.int <- base::seq.int
[11:01:43.076]             signalCondition <- base::signalCondition
[11:01:43.076]             sys.calls <- base::sys.calls
[11:01:43.076]             `[[` <- base::`[[`
[11:01:43.076]             `+` <- base::`+`
[11:01:43.076]             `<<-` <- base::`<<-`
[11:01:43.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.076]                   3L)]
[11:01:43.076]             }
[11:01:43.076]             function(cond) {
[11:01:43.076]                 is_error <- inherits(cond, "error")
[11:01:43.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.076]                   NULL)
[11:01:43.076]                 if (is_error) {
[11:01:43.076]                   sessionInformation <- function() {
[11:01:43.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.076]                       search = base::search(), system = base::Sys.info())
[11:01:43.076]                   }
[11:01:43.076]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.076]                     cond$call), session = sessionInformation(), 
[11:01:43.076]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.076]                   signalCondition(cond)
[11:01:43.076]                 }
[11:01:43.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.076]                 "immediateCondition"))) {
[11:01:43.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.076]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.076]                   if (TRUE && !signal) {
[11:01:43.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.076]                     {
[11:01:43.076]                       inherits <- base::inherits
[11:01:43.076]                       invokeRestart <- base::invokeRestart
[11:01:43.076]                       is.null <- base::is.null
[11:01:43.076]                       muffled <- FALSE
[11:01:43.076]                       if (inherits(cond, "message")) {
[11:01:43.076]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.076]                         if (muffled) 
[11:01:43.076]                           invokeRestart("muffleMessage")
[11:01:43.076]                       }
[11:01:43.076]                       else if (inherits(cond, "warning")) {
[11:01:43.076]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.076]                         if (muffled) 
[11:01:43.076]                           invokeRestart("muffleWarning")
[11:01:43.076]                       }
[11:01:43.076]                       else if (inherits(cond, "condition")) {
[11:01:43.076]                         if (!is.null(pattern)) {
[11:01:43.076]                           computeRestarts <- base::computeRestarts
[11:01:43.076]                           grepl <- base::grepl
[11:01:43.076]                           restarts <- computeRestarts(cond)
[11:01:43.076]                           for (restart in restarts) {
[11:01:43.076]                             name <- restart$name
[11:01:43.076]                             if (is.null(name)) 
[11:01:43.076]                               next
[11:01:43.076]                             if (!grepl(pattern, name)) 
[11:01:43.076]                               next
[11:01:43.076]                             invokeRestart(restart)
[11:01:43.076]                             muffled <- TRUE
[11:01:43.076]                             break
[11:01:43.076]                           }
[11:01:43.076]                         }
[11:01:43.076]                       }
[11:01:43.076]                       invisible(muffled)
[11:01:43.076]                     }
[11:01:43.076]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.076]                   }
[11:01:43.076]                 }
[11:01:43.076]                 else {
[11:01:43.076]                   if (TRUE) {
[11:01:43.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.076]                     {
[11:01:43.076]                       inherits <- base::inherits
[11:01:43.076]                       invokeRestart <- base::invokeRestart
[11:01:43.076]                       is.null <- base::is.null
[11:01:43.076]                       muffled <- FALSE
[11:01:43.076]                       if (inherits(cond, "message")) {
[11:01:43.076]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.076]                         if (muffled) 
[11:01:43.076]                           invokeRestart("muffleMessage")
[11:01:43.076]                       }
[11:01:43.076]                       else if (inherits(cond, "warning")) {
[11:01:43.076]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.076]                         if (muffled) 
[11:01:43.076]                           invokeRestart("muffleWarning")
[11:01:43.076]                       }
[11:01:43.076]                       else if (inherits(cond, "condition")) {
[11:01:43.076]                         if (!is.null(pattern)) {
[11:01:43.076]                           computeRestarts <- base::computeRestarts
[11:01:43.076]                           grepl <- base::grepl
[11:01:43.076]                           restarts <- computeRestarts(cond)
[11:01:43.076]                           for (restart in restarts) {
[11:01:43.076]                             name <- restart$name
[11:01:43.076]                             if (is.null(name)) 
[11:01:43.076]                               next
[11:01:43.076]                             if (!grepl(pattern, name)) 
[11:01:43.076]                               next
[11:01:43.076]                             invokeRestart(restart)
[11:01:43.076]                             muffled <- TRUE
[11:01:43.076]                             break
[11:01:43.076]                           }
[11:01:43.076]                         }
[11:01:43.076]                       }
[11:01:43.076]                       invisible(muffled)
[11:01:43.076]                     }
[11:01:43.076]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.076]                   }
[11:01:43.076]                 }
[11:01:43.076]             }
[11:01:43.076]         }))
[11:01:43.076]     }, error = function(ex) {
[11:01:43.076]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.076]                 ...future.rng), started = ...future.startTime, 
[11:01:43.076]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.076]             version = "1.8"), class = "FutureResult")
[11:01:43.076]     }, finally = {
[11:01:43.076]         if (!identical(...future.workdir, getwd())) 
[11:01:43.076]             setwd(...future.workdir)
[11:01:43.076]         {
[11:01:43.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.076]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.076]             }
[11:01:43.076]             base::options(...future.oldOptions)
[11:01:43.076]             if (.Platform$OS.type == "windows") {
[11:01:43.076]                 old_names <- names(...future.oldEnvVars)
[11:01:43.076]                 envs <- base::Sys.getenv()
[11:01:43.076]                 names <- names(envs)
[11:01:43.076]                 common <- intersect(names, old_names)
[11:01:43.076]                 added <- setdiff(names, old_names)
[11:01:43.076]                 removed <- setdiff(old_names, names)
[11:01:43.076]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.076]                   envs[common]]
[11:01:43.076]                 NAMES <- toupper(changed)
[11:01:43.076]                 args <- list()
[11:01:43.076]                 for (kk in seq_along(NAMES)) {
[11:01:43.076]                   name <- changed[[kk]]
[11:01:43.076]                   NAME <- NAMES[[kk]]
[11:01:43.076]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.076]                     next
[11:01:43.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.076]                 }
[11:01:43.076]                 NAMES <- toupper(added)
[11:01:43.076]                 for (kk in seq_along(NAMES)) {
[11:01:43.076]                   name <- added[[kk]]
[11:01:43.076]                   NAME <- NAMES[[kk]]
[11:01:43.076]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.076]                     next
[11:01:43.076]                   args[[name]] <- ""
[11:01:43.076]                 }
[11:01:43.076]                 NAMES <- toupper(removed)
[11:01:43.076]                 for (kk in seq_along(NAMES)) {
[11:01:43.076]                   name <- removed[[kk]]
[11:01:43.076]                   NAME <- NAMES[[kk]]
[11:01:43.076]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.076]                     next
[11:01:43.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.076]                 }
[11:01:43.076]                 if (length(args) > 0) 
[11:01:43.076]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.076]             }
[11:01:43.076]             else {
[11:01:43.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.076]             }
[11:01:43.076]             {
[11:01:43.076]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.076]                   0L) {
[11:01:43.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.076]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.076]                   base::options(opts)
[11:01:43.076]                 }
[11:01:43.076]                 {
[11:01:43.076]                   {
[11:01:43.076]                     NULL
[11:01:43.076]                     RNGkind("Mersenne-Twister")
[11:01:43.076]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:43.076]                       inherits = FALSE)
[11:01:43.076]                   }
[11:01:43.076]                   options(future.plan = NULL)
[11:01:43.076]                   if (is.na(NA_character_)) 
[11:01:43.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.076]                     .init = FALSE)
[11:01:43.076]                 }
[11:01:43.076]             }
[11:01:43.076]         }
[11:01:43.076]     })
[11:01:43.076]     if (TRUE) {
[11:01:43.076]         base::sink(type = "output", split = FALSE)
[11:01:43.076]         if (TRUE) {
[11:01:43.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.076]         }
[11:01:43.076]         else {
[11:01:43.076]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.076]         }
[11:01:43.076]         base::close(...future.stdout)
[11:01:43.076]         ...future.stdout <- NULL
[11:01:43.076]     }
[11:01:43.076]     ...future.result$conditions <- ...future.conditions
[11:01:43.076]     ...future.result$finished <- base::Sys.time()
[11:01:43.076]     ...future.result
[11:01:43.076] }
[11:01:43.078] plan(): Setting new future strategy stack:
[11:01:43.078] List of future strategies:
[11:01:43.078] 1. sequential:
[11:01:43.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.078]    - tweaked: FALSE
[11:01:43.078]    - call: NULL
[11:01:43.078] plan(): nbrOfWorkers() = 1
[11:01:43.079] plan(): Setting new future strategy stack:
[11:01:43.079] List of future strategies:
[11:01:43.079] 1. sequential:
[11:01:43.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.079]    - tweaked: FALSE
[11:01:43.079]    - call: plan(strategy)
[11:01:43.080] plan(): nbrOfWorkers() = 1
[11:01:43.080] SequentialFuture started (and completed)
[11:01:43.080] - Launch lazy future ... done
[11:01:43.080] run() for ‘SequentialFuture’ ... done
[11:01:43.080] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:43.080] Searching for globals...
[11:01:43.083] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.084] Searching for globals...
[11:01:43.085] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[11:01:43.085] Searching for globals ... DONE
[11:01:43.085] Resolving globals: FALSE
[11:01:43.085] The total size of the 1 globals is 356 bytes (356 bytes)
[11:01:43.086] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:01:43.086] - globals: [1] ‘data’
[11:01:43.086] 
[11:01:43.086] getGlobalsAndPackages() ... DONE
[11:01:43.086] run() for ‘Future’ ...
[11:01:43.086] - state: ‘created’
[11:01:43.087] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:43.087] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:43.087] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:43.087]   - Field: ‘label’
[11:01:43.087]   - Field: ‘local’
[11:01:43.087]   - Field: ‘owner’
[11:01:43.087]   - Field: ‘envir’
[11:01:43.087]   - Field: ‘packages’
[11:01:43.087]   - Field: ‘gc’
[11:01:43.088]   - Field: ‘conditions’
[11:01:43.088]   - Field: ‘expr’
[11:01:43.088]   - Field: ‘uuid’
[11:01:43.088]   - Field: ‘seed’
[11:01:43.088]   - Field: ‘version’
[11:01:43.088]   - Field: ‘result’
[11:01:43.088]   - Field: ‘asynchronous’
[11:01:43.088]   - Field: ‘calls’
[11:01:43.088]   - Field: ‘globals’
[11:01:43.088]   - Field: ‘stdout’
[11:01:43.088]   - Field: ‘earlySignal’
[11:01:43.088]   - Field: ‘lazy’
[11:01:43.089]   - Field: ‘state’
[11:01:43.089] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:43.089] - Launch lazy future ...
[11:01:43.089] Packages needed by the future expression (n = 0): <none>
[11:01:43.089] Packages needed by future strategies (n = 0): <none>
[11:01:43.089] {
[11:01:43.089]     {
[11:01:43.089]         {
[11:01:43.089]             ...future.startTime <- base::Sys.time()
[11:01:43.089]             {
[11:01:43.089]                 {
[11:01:43.089]                   {
[11:01:43.089]                     base::local({
[11:01:43.089]                       has_future <- base::requireNamespace("future", 
[11:01:43.089]                         quietly = TRUE)
[11:01:43.089]                       if (has_future) {
[11:01:43.089]                         ns <- base::getNamespace("future")
[11:01:43.089]                         version <- ns[[".package"]][["version"]]
[11:01:43.089]                         if (is.null(version)) 
[11:01:43.089]                           version <- utils::packageVersion("future")
[11:01:43.089]                       }
[11:01:43.089]                       else {
[11:01:43.089]                         version <- NULL
[11:01:43.089]                       }
[11:01:43.089]                       if (!has_future || version < "1.8.0") {
[11:01:43.089]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.089]                           "", base::R.version$version.string), 
[11:01:43.089]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:43.089]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.089]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.089]                             "release", "version")], collapse = " "), 
[11:01:43.089]                           hostname = base::Sys.info()[["nodename"]])
[11:01:43.089]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.089]                           info)
[11:01:43.089]                         info <- base::paste(info, collapse = "; ")
[11:01:43.089]                         if (!has_future) {
[11:01:43.089]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.089]                             info)
[11:01:43.089]                         }
[11:01:43.089]                         else {
[11:01:43.089]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.089]                             info, version)
[11:01:43.089]                         }
[11:01:43.089]                         base::stop(msg)
[11:01:43.089]                       }
[11:01:43.089]                     })
[11:01:43.089]                   }
[11:01:43.089]                   ...future.strategy.old <- future::plan("list")
[11:01:43.089]                   options(future.plan = NULL)
[11:01:43.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:43.089]                 }
[11:01:43.089]                 ...future.workdir <- getwd()
[11:01:43.089]             }
[11:01:43.089]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.089]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.089]         }
[11:01:43.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.089]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.089]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.089]             base::names(...future.oldOptions))
[11:01:43.089]     }
[11:01:43.089]     if (FALSE) {
[11:01:43.089]     }
[11:01:43.089]     else {
[11:01:43.089]         if (TRUE) {
[11:01:43.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.089]                 open = "w")
[11:01:43.089]         }
[11:01:43.089]         else {
[11:01:43.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.089]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.089]         }
[11:01:43.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.089]             base::sink(type = "output", split = FALSE)
[11:01:43.089]             base::close(...future.stdout)
[11:01:43.089]         }, add = TRUE)
[11:01:43.089]     }
[11:01:43.089]     ...future.frame <- base::sys.nframe()
[11:01:43.089]     ...future.conditions <- base::list()
[11:01:43.089]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.089]     if (FALSE) {
[11:01:43.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.089]     }
[11:01:43.089]     ...future.result <- base::tryCatch({
[11:01:43.089]         base::withCallingHandlers({
[11:01:43.089]             ...future.value <- base::withVisible(base::local(subset(data, 
[11:01:43.089]                 x < 3)$y))
[11:01:43.089]             future::FutureResult(value = ...future.value$value, 
[11:01:43.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.089]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.089]                     ...future.globalenv.names))
[11:01:43.089]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.089]         }, condition = base::local({
[11:01:43.089]             c <- base::c
[11:01:43.089]             inherits <- base::inherits
[11:01:43.089]             invokeRestart <- base::invokeRestart
[11:01:43.089]             length <- base::length
[11:01:43.089]             list <- base::list
[11:01:43.089]             seq.int <- base::seq.int
[11:01:43.089]             signalCondition <- base::signalCondition
[11:01:43.089]             sys.calls <- base::sys.calls
[11:01:43.089]             `[[` <- base::`[[`
[11:01:43.089]             `+` <- base::`+`
[11:01:43.089]             `<<-` <- base::`<<-`
[11:01:43.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.089]                   3L)]
[11:01:43.089]             }
[11:01:43.089]             function(cond) {
[11:01:43.089]                 is_error <- inherits(cond, "error")
[11:01:43.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.089]                   NULL)
[11:01:43.089]                 if (is_error) {
[11:01:43.089]                   sessionInformation <- function() {
[11:01:43.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.089]                       search = base::search(), system = base::Sys.info())
[11:01:43.089]                   }
[11:01:43.089]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.089]                     cond$call), session = sessionInformation(), 
[11:01:43.089]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.089]                   signalCondition(cond)
[11:01:43.089]                 }
[11:01:43.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.089]                 "immediateCondition"))) {
[11:01:43.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.089]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.089]                   if (TRUE && !signal) {
[11:01:43.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.089]                     {
[11:01:43.089]                       inherits <- base::inherits
[11:01:43.089]                       invokeRestart <- base::invokeRestart
[11:01:43.089]                       is.null <- base::is.null
[11:01:43.089]                       muffled <- FALSE
[11:01:43.089]                       if (inherits(cond, "message")) {
[11:01:43.089]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.089]                         if (muffled) 
[11:01:43.089]                           invokeRestart("muffleMessage")
[11:01:43.089]                       }
[11:01:43.089]                       else if (inherits(cond, "warning")) {
[11:01:43.089]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.089]                         if (muffled) 
[11:01:43.089]                           invokeRestart("muffleWarning")
[11:01:43.089]                       }
[11:01:43.089]                       else if (inherits(cond, "condition")) {
[11:01:43.089]                         if (!is.null(pattern)) {
[11:01:43.089]                           computeRestarts <- base::computeRestarts
[11:01:43.089]                           grepl <- base::grepl
[11:01:43.089]                           restarts <- computeRestarts(cond)
[11:01:43.089]                           for (restart in restarts) {
[11:01:43.089]                             name <- restart$name
[11:01:43.089]                             if (is.null(name)) 
[11:01:43.089]                               next
[11:01:43.089]                             if (!grepl(pattern, name)) 
[11:01:43.089]                               next
[11:01:43.089]                             invokeRestart(restart)
[11:01:43.089]                             muffled <- TRUE
[11:01:43.089]                             break
[11:01:43.089]                           }
[11:01:43.089]                         }
[11:01:43.089]                       }
[11:01:43.089]                       invisible(muffled)
[11:01:43.089]                     }
[11:01:43.089]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.089]                   }
[11:01:43.089]                 }
[11:01:43.089]                 else {
[11:01:43.089]                   if (TRUE) {
[11:01:43.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.089]                     {
[11:01:43.089]                       inherits <- base::inherits
[11:01:43.089]                       invokeRestart <- base::invokeRestart
[11:01:43.089]                       is.null <- base::is.null
[11:01:43.089]                       muffled <- FALSE
[11:01:43.089]                       if (inherits(cond, "message")) {
[11:01:43.089]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.089]                         if (muffled) 
[11:01:43.089]                           invokeRestart("muffleMessage")
[11:01:43.089]                       }
[11:01:43.089]                       else if (inherits(cond, "warning")) {
[11:01:43.089]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.089]                         if (muffled) 
[11:01:43.089]                           invokeRestart("muffleWarning")
[11:01:43.089]                       }
[11:01:43.089]                       else if (inherits(cond, "condition")) {
[11:01:43.089]                         if (!is.null(pattern)) {
[11:01:43.089]                           computeRestarts <- base::computeRestarts
[11:01:43.089]                           grepl <- base::grepl
[11:01:43.089]                           restarts <- computeRestarts(cond)
[11:01:43.089]                           for (restart in restarts) {
[11:01:43.089]                             name <- restart$name
[11:01:43.089]                             if (is.null(name)) 
[11:01:43.089]                               next
[11:01:43.089]                             if (!grepl(pattern, name)) 
[11:01:43.089]                               next
[11:01:43.089]                             invokeRestart(restart)
[11:01:43.089]                             muffled <- TRUE
[11:01:43.089]                             break
[11:01:43.089]                           }
[11:01:43.089]                         }
[11:01:43.089]                       }
[11:01:43.089]                       invisible(muffled)
[11:01:43.089]                     }
[11:01:43.089]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.089]                   }
[11:01:43.089]                 }
[11:01:43.089]             }
[11:01:43.089]         }))
[11:01:43.089]     }, error = function(ex) {
[11:01:43.089]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.089]                 ...future.rng), started = ...future.startTime, 
[11:01:43.089]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.089]             version = "1.8"), class = "FutureResult")
[11:01:43.089]     }, finally = {
[11:01:43.089]         if (!identical(...future.workdir, getwd())) 
[11:01:43.089]             setwd(...future.workdir)
[11:01:43.089]         {
[11:01:43.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.089]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.089]             }
[11:01:43.089]             base::options(...future.oldOptions)
[11:01:43.089]             if (.Platform$OS.type == "windows") {
[11:01:43.089]                 old_names <- names(...future.oldEnvVars)
[11:01:43.089]                 envs <- base::Sys.getenv()
[11:01:43.089]                 names <- names(envs)
[11:01:43.089]                 common <- intersect(names, old_names)
[11:01:43.089]                 added <- setdiff(names, old_names)
[11:01:43.089]                 removed <- setdiff(old_names, names)
[11:01:43.089]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.089]                   envs[common]]
[11:01:43.089]                 NAMES <- toupper(changed)
[11:01:43.089]                 args <- list()
[11:01:43.089]                 for (kk in seq_along(NAMES)) {
[11:01:43.089]                   name <- changed[[kk]]
[11:01:43.089]                   NAME <- NAMES[[kk]]
[11:01:43.089]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.089]                     next
[11:01:43.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.089]                 }
[11:01:43.089]                 NAMES <- toupper(added)
[11:01:43.089]                 for (kk in seq_along(NAMES)) {
[11:01:43.089]                   name <- added[[kk]]
[11:01:43.089]                   NAME <- NAMES[[kk]]
[11:01:43.089]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.089]                     next
[11:01:43.089]                   args[[name]] <- ""
[11:01:43.089]                 }
[11:01:43.089]                 NAMES <- toupper(removed)
[11:01:43.089]                 for (kk in seq_along(NAMES)) {
[11:01:43.089]                   name <- removed[[kk]]
[11:01:43.089]                   NAME <- NAMES[[kk]]
[11:01:43.089]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.089]                     next
[11:01:43.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.089]                 }
[11:01:43.089]                 if (length(args) > 0) 
[11:01:43.089]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.089]             }
[11:01:43.089]             else {
[11:01:43.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.089]             }
[11:01:43.089]             {
[11:01:43.089]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.089]                   0L) {
[11:01:43.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.089]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.089]                   base::options(opts)
[11:01:43.089]                 }
[11:01:43.089]                 {
[11:01:43.089]                   {
[11:01:43.089]                     NULL
[11:01:43.089]                     RNGkind("Mersenne-Twister")
[11:01:43.089]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:43.089]                       inherits = FALSE)
[11:01:43.089]                   }
[11:01:43.089]                   options(future.plan = NULL)
[11:01:43.089]                   if (is.na(NA_character_)) 
[11:01:43.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.089]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.089]                     .init = FALSE)
[11:01:43.089]                 }
[11:01:43.089]             }
[11:01:43.089]         }
[11:01:43.089]     })
[11:01:43.089]     if (TRUE) {
[11:01:43.089]         base::sink(type = "output", split = FALSE)
[11:01:43.089]         if (TRUE) {
[11:01:43.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.089]         }
[11:01:43.089]         else {
[11:01:43.089]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.089]         }
[11:01:43.089]         base::close(...future.stdout)
[11:01:43.089]         ...future.stdout <- NULL
[11:01:43.089]     }
[11:01:43.089]     ...future.result$conditions <- ...future.conditions
[11:01:43.089]     ...future.result$finished <- base::Sys.time()
[11:01:43.089]     ...future.result
[11:01:43.089] }
[11:01:43.091] assign_globals() ...
[11:01:43.091] List of 1
[11:01:43.091]  $ data:'data.frame':	5 obs. of  2 variables:
[11:01:43.091]   ..$ x: int [1:5] 1 2 3 4 5
[11:01:43.091]   ..$ y: int [1:5] 1 2 3 4 5
[11:01:43.091]  - attr(*, "where")=List of 1
[11:01:43.091]   ..$ data:<environment: R_EmptyEnv> 
[11:01:43.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:43.091]  - attr(*, "resolved")= logi FALSE
[11:01:43.091]  - attr(*, "total_size")= num 356
[11:01:43.091]  - attr(*, "already-done")= logi TRUE
[11:01:43.096] - copied ‘data’ to environment
[11:01:43.096] assign_globals() ... done
[11:01:43.096] plan(): Setting new future strategy stack:
[11:01:43.096] List of future strategies:
[11:01:43.096] 1. sequential:
[11:01:43.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.096]    - tweaked: FALSE
[11:01:43.096]    - call: NULL
[11:01:43.097] plan(): nbrOfWorkers() = 1
[11:01:43.097] plan(): Setting new future strategy stack:
[11:01:43.098] List of future strategies:
[11:01:43.098] 1. sequential:
[11:01:43.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.098]    - tweaked: FALSE
[11:01:43.098]    - call: plan(strategy)
[11:01:43.098] plan(): nbrOfWorkers() = 1
[11:01:43.098] SequentialFuture started (and completed)
[11:01:43.098] - Launch lazy future ... done
[11:01:43.098] run() for ‘SequentialFuture’ ... done
[11:01:43.099] plan(): Setting new future strategy stack:
[11:01:43.099] List of future strategies:
[11:01:43.099] 1. sequential:
[11:01:43.099]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.099]    - tweaked: FALSE
[11:01:43.099]    - call: plan(list(sequential, strategy))
[11:01:43.099] 2. sequential:
[11:01:43.099]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.099]    - tweaked: FALSE
[11:01:43.099]    - call: plan(list(sequential, strategy))
[11:01:43.099] plan(): nbrOfWorkers() = 1
[11:01:43.100] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.100] Searching for globals...
[11:01:43.104] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[11:01:43.104] Searching for globals ... DONE
[11:01:43.105] Resolving globals: FALSE
[11:01:43.105] The total size of the 1 globals is 356 bytes (356 bytes)
[11:01:43.105] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:01:43.105] - globals: [1] ‘data’
[11:01:43.106] - packages: [1] ‘future’
[11:01:43.106] getGlobalsAndPackages() ... DONE
[11:01:43.106] run() for ‘Future’ ...
[11:01:43.106] - state: ‘created’
[11:01:43.106] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:43.106] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:43.107] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:43.107]   - Field: ‘label’
[11:01:43.107]   - Field: ‘local’
[11:01:43.107]   - Field: ‘owner’
[11:01:43.107]   - Field: ‘envir’
[11:01:43.107]   - Field: ‘packages’
[11:01:43.107]   - Field: ‘gc’
[11:01:43.107]   - Field: ‘conditions’
[11:01:43.107]   - Field: ‘expr’
[11:01:43.107]   - Field: ‘uuid’
[11:01:43.107]   - Field: ‘seed’
[11:01:43.107]   - Field: ‘version’
[11:01:43.108]   - Field: ‘result’
[11:01:43.108]   - Field: ‘asynchronous’
[11:01:43.108]   - Field: ‘calls’
[11:01:43.108]   - Field: ‘globals’
[11:01:43.108]   - Field: ‘stdout’
[11:01:43.108]   - Field: ‘earlySignal’
[11:01:43.108]   - Field: ‘lazy’
[11:01:43.108]   - Field: ‘state’
[11:01:43.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:43.108] - Launch lazy future ...
[11:01:43.108] Packages needed by the future expression (n = 1): ‘future’
[11:01:43.109] Packages needed by future strategies (n = 1): ‘future’
[11:01:43.110] {
[11:01:43.110]     {
[11:01:43.110]         {
[11:01:43.110]             ...future.startTime <- base::Sys.time()
[11:01:43.110]             {
[11:01:43.110]                 {
[11:01:43.110]                   {
[11:01:43.110]                     {
[11:01:43.110]                       base::local({
[11:01:43.110]                         has_future <- base::requireNamespace("future", 
[11:01:43.110]                           quietly = TRUE)
[11:01:43.110]                         if (has_future) {
[11:01:43.110]                           ns <- base::getNamespace("future")
[11:01:43.110]                           version <- ns[[".package"]][["version"]]
[11:01:43.110]                           if (is.null(version)) 
[11:01:43.110]                             version <- utils::packageVersion("future")
[11:01:43.110]                         }
[11:01:43.110]                         else {
[11:01:43.110]                           version <- NULL
[11:01:43.110]                         }
[11:01:43.110]                         if (!has_future || version < "1.8.0") {
[11:01:43.110]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.110]                             "", base::R.version$version.string), 
[11:01:43.110]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:43.110]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.110]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.110]                               "release", "version")], collapse = " "), 
[11:01:43.110]                             hostname = base::Sys.info()[["nodename"]])
[11:01:43.110]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.110]                             info)
[11:01:43.110]                           info <- base::paste(info, collapse = "; ")
[11:01:43.110]                           if (!has_future) {
[11:01:43.110]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.110]                               info)
[11:01:43.110]                           }
[11:01:43.110]                           else {
[11:01:43.110]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.110]                               info, version)
[11:01:43.110]                           }
[11:01:43.110]                           base::stop(msg)
[11:01:43.110]                         }
[11:01:43.110]                       })
[11:01:43.110]                     }
[11:01:43.110]                     base::local({
[11:01:43.110]                       for (pkg in "future") {
[11:01:43.110]                         base::loadNamespace(pkg)
[11:01:43.110]                         base::library(pkg, character.only = TRUE)
[11:01:43.110]                       }
[11:01:43.110]                     })
[11:01:43.110]                   }
[11:01:43.110]                   ...future.strategy.old <- future::plan("list")
[11:01:43.110]                   options(future.plan = NULL)
[11:01:43.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.110]                   future::plan(list(function (..., envir = parent.frame()) 
[11:01:43.110]                   {
[11:01:43.110]                     future <- SequentialFuture(..., envir = envir)
[11:01:43.110]                     if (!future$lazy) 
[11:01:43.110]                       future <- run(future)
[11:01:43.110]                     invisible(future)
[11:01:43.110]                   }), .cleanup = FALSE, .init = FALSE)
[11:01:43.110]                 }
[11:01:43.110]                 ...future.workdir <- getwd()
[11:01:43.110]             }
[11:01:43.110]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.110]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.110]         }
[11:01:43.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.110]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.110]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.110]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.110]             base::names(...future.oldOptions))
[11:01:43.110]     }
[11:01:43.110]     if (FALSE) {
[11:01:43.110]     }
[11:01:43.110]     else {
[11:01:43.110]         if (TRUE) {
[11:01:43.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.110]                 open = "w")
[11:01:43.110]         }
[11:01:43.110]         else {
[11:01:43.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.110]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.110]         }
[11:01:43.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.110]             base::sink(type = "output", split = FALSE)
[11:01:43.110]             base::close(...future.stdout)
[11:01:43.110]         }, add = TRUE)
[11:01:43.110]     }
[11:01:43.110]     ...future.frame <- base::sys.nframe()
[11:01:43.110]     ...future.conditions <- base::list()
[11:01:43.110]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.110]     if (FALSE) {
[11:01:43.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.110]     }
[11:01:43.110]     ...future.result <- base::tryCatch({
[11:01:43.110]         base::withCallingHandlers({
[11:01:43.110]             ...future.value <- base::withVisible(base::local({
[11:01:43.110]                 a %<-% subset(data, x < 3)$y
[11:01:43.110]                 a
[11:01:43.110]             }))
[11:01:43.110]             future::FutureResult(value = ...future.value$value, 
[11:01:43.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.110]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.110]                     ...future.globalenv.names))
[11:01:43.110]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.110]         }, condition = base::local({
[11:01:43.110]             c <- base::c
[11:01:43.110]             inherits <- base::inherits
[11:01:43.110]             invokeRestart <- base::invokeRestart
[11:01:43.110]             length <- base::length
[11:01:43.110]             list <- base::list
[11:01:43.110]             seq.int <- base::seq.int
[11:01:43.110]             signalCondition <- base::signalCondition
[11:01:43.110]             sys.calls <- base::sys.calls
[11:01:43.110]             `[[` <- base::`[[`
[11:01:43.110]             `+` <- base::`+`
[11:01:43.110]             `<<-` <- base::`<<-`
[11:01:43.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.110]                   3L)]
[11:01:43.110]             }
[11:01:43.110]             function(cond) {
[11:01:43.110]                 is_error <- inherits(cond, "error")
[11:01:43.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.110]                   NULL)
[11:01:43.110]                 if (is_error) {
[11:01:43.110]                   sessionInformation <- function() {
[11:01:43.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.110]                       search = base::search(), system = base::Sys.info())
[11:01:43.110]                   }
[11:01:43.110]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.110]                     cond$call), session = sessionInformation(), 
[11:01:43.110]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.110]                   signalCondition(cond)
[11:01:43.110]                 }
[11:01:43.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.110]                 "immediateCondition"))) {
[11:01:43.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.110]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.110]                   if (TRUE && !signal) {
[11:01:43.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.110]                     {
[11:01:43.110]                       inherits <- base::inherits
[11:01:43.110]                       invokeRestart <- base::invokeRestart
[11:01:43.110]                       is.null <- base::is.null
[11:01:43.110]                       muffled <- FALSE
[11:01:43.110]                       if (inherits(cond, "message")) {
[11:01:43.110]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.110]                         if (muffled) 
[11:01:43.110]                           invokeRestart("muffleMessage")
[11:01:43.110]                       }
[11:01:43.110]                       else if (inherits(cond, "warning")) {
[11:01:43.110]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.110]                         if (muffled) 
[11:01:43.110]                           invokeRestart("muffleWarning")
[11:01:43.110]                       }
[11:01:43.110]                       else if (inherits(cond, "condition")) {
[11:01:43.110]                         if (!is.null(pattern)) {
[11:01:43.110]                           computeRestarts <- base::computeRestarts
[11:01:43.110]                           grepl <- base::grepl
[11:01:43.110]                           restarts <- computeRestarts(cond)
[11:01:43.110]                           for (restart in restarts) {
[11:01:43.110]                             name <- restart$name
[11:01:43.110]                             if (is.null(name)) 
[11:01:43.110]                               next
[11:01:43.110]                             if (!grepl(pattern, name)) 
[11:01:43.110]                               next
[11:01:43.110]                             invokeRestart(restart)
[11:01:43.110]                             muffled <- TRUE
[11:01:43.110]                             break
[11:01:43.110]                           }
[11:01:43.110]                         }
[11:01:43.110]                       }
[11:01:43.110]                       invisible(muffled)
[11:01:43.110]                     }
[11:01:43.110]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.110]                   }
[11:01:43.110]                 }
[11:01:43.110]                 else {
[11:01:43.110]                   if (TRUE) {
[11:01:43.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.110]                     {
[11:01:43.110]                       inherits <- base::inherits
[11:01:43.110]                       invokeRestart <- base::invokeRestart
[11:01:43.110]                       is.null <- base::is.null
[11:01:43.110]                       muffled <- FALSE
[11:01:43.110]                       if (inherits(cond, "message")) {
[11:01:43.110]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.110]                         if (muffled) 
[11:01:43.110]                           invokeRestart("muffleMessage")
[11:01:43.110]                       }
[11:01:43.110]                       else if (inherits(cond, "warning")) {
[11:01:43.110]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.110]                         if (muffled) 
[11:01:43.110]                           invokeRestart("muffleWarning")
[11:01:43.110]                       }
[11:01:43.110]                       else if (inherits(cond, "condition")) {
[11:01:43.110]                         if (!is.null(pattern)) {
[11:01:43.110]                           computeRestarts <- base::computeRestarts
[11:01:43.110]                           grepl <- base::grepl
[11:01:43.110]                           restarts <- computeRestarts(cond)
[11:01:43.110]                           for (restart in restarts) {
[11:01:43.110]                             name <- restart$name
[11:01:43.110]                             if (is.null(name)) 
[11:01:43.110]                               next
[11:01:43.110]                             if (!grepl(pattern, name)) 
[11:01:43.110]                               next
[11:01:43.110]                             invokeRestart(restart)
[11:01:43.110]                             muffled <- TRUE
[11:01:43.110]                             break
[11:01:43.110]                           }
[11:01:43.110]                         }
[11:01:43.110]                       }
[11:01:43.110]                       invisible(muffled)
[11:01:43.110]                     }
[11:01:43.110]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.110]                   }
[11:01:43.110]                 }
[11:01:43.110]             }
[11:01:43.110]         }))
[11:01:43.110]     }, error = function(ex) {
[11:01:43.110]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.110]                 ...future.rng), started = ...future.startTime, 
[11:01:43.110]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.110]             version = "1.8"), class = "FutureResult")
[11:01:43.110]     }, finally = {
[11:01:43.110]         if (!identical(...future.workdir, getwd())) 
[11:01:43.110]             setwd(...future.workdir)
[11:01:43.110]         {
[11:01:43.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.110]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.110]             }
[11:01:43.110]             base::options(...future.oldOptions)
[11:01:43.110]             if (.Platform$OS.type == "windows") {
[11:01:43.110]                 old_names <- names(...future.oldEnvVars)
[11:01:43.110]                 envs <- base::Sys.getenv()
[11:01:43.110]                 names <- names(envs)
[11:01:43.110]                 common <- intersect(names, old_names)
[11:01:43.110]                 added <- setdiff(names, old_names)
[11:01:43.110]                 removed <- setdiff(old_names, names)
[11:01:43.110]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.110]                   envs[common]]
[11:01:43.110]                 NAMES <- toupper(changed)
[11:01:43.110]                 args <- list()
[11:01:43.110]                 for (kk in seq_along(NAMES)) {
[11:01:43.110]                   name <- changed[[kk]]
[11:01:43.110]                   NAME <- NAMES[[kk]]
[11:01:43.110]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.110]                     next
[11:01:43.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.110]                 }
[11:01:43.110]                 NAMES <- toupper(added)
[11:01:43.110]                 for (kk in seq_along(NAMES)) {
[11:01:43.110]                   name <- added[[kk]]
[11:01:43.110]                   NAME <- NAMES[[kk]]
[11:01:43.110]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.110]                     next
[11:01:43.110]                   args[[name]] <- ""
[11:01:43.110]                 }
[11:01:43.110]                 NAMES <- toupper(removed)
[11:01:43.110]                 for (kk in seq_along(NAMES)) {
[11:01:43.110]                   name <- removed[[kk]]
[11:01:43.110]                   NAME <- NAMES[[kk]]
[11:01:43.110]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.110]                     next
[11:01:43.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.110]                 }
[11:01:43.110]                 if (length(args) > 0) 
[11:01:43.110]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.110]             }
[11:01:43.110]             else {
[11:01:43.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.110]             }
[11:01:43.110]             {
[11:01:43.110]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.110]                   0L) {
[11:01:43.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.110]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.110]                   base::options(opts)
[11:01:43.110]                 }
[11:01:43.110]                 {
[11:01:43.110]                   {
[11:01:43.110]                     NULL
[11:01:43.110]                     RNGkind("Mersenne-Twister")
[11:01:43.110]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:43.110]                       inherits = FALSE)
[11:01:43.110]                   }
[11:01:43.110]                   options(future.plan = NULL)
[11:01:43.110]                   if (is.na(NA_character_)) 
[11:01:43.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.110]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.110]                     .init = FALSE)
[11:01:43.110]                 }
[11:01:43.110]             }
[11:01:43.110]         }
[11:01:43.110]     })
[11:01:43.110]     if (TRUE) {
[11:01:43.110]         base::sink(type = "output", split = FALSE)
[11:01:43.110]         if (TRUE) {
[11:01:43.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.110]         }
[11:01:43.110]         else {
[11:01:43.110]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.110]         }
[11:01:43.110]         base::close(...future.stdout)
[11:01:43.110]         ...future.stdout <- NULL
[11:01:43.110]     }
[11:01:43.110]     ...future.result$conditions <- ...future.conditions
[11:01:43.110]     ...future.result$finished <- base::Sys.time()
[11:01:43.110]     ...future.result
[11:01:43.110] }
[11:01:43.112] assign_globals() ...
[11:01:43.112] List of 1
[11:01:43.112]  $ data:'data.frame':	5 obs. of  2 variables:
[11:01:43.112]   ..$ x: int [1:5] 1 2 3 4 5
[11:01:43.112]   ..$ y: int [1:5] 1 2 3 4 5
[11:01:43.112]  - attr(*, "where")=List of 1
[11:01:43.112]   ..$ data:<environment: R_EmptyEnv> 
[11:01:43.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:43.112]  - attr(*, "resolved")= logi FALSE
[11:01:43.112]  - attr(*, "total_size")= num 356
[11:01:43.112]  - attr(*, "already-done")= logi TRUE
[11:01:43.115] - copied ‘data’ to environment
[11:01:43.115] assign_globals() ... done
[11:01:43.115] plan(): Setting new future strategy stack:
[11:01:43.115] List of future strategies:
[11:01:43.115] 1. sequential:
[11:01:43.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.115]    - tweaked: FALSE
[11:01:43.115]    - call: plan(list(sequential, strategy))
[11:01:43.116] plan(): nbrOfWorkers() = 1
[11:01:43.143] plan(): Setting new future strategy stack:
[11:01:43.144] List of future strategies:
[11:01:43.144] 1. sequential:
[11:01:43.144]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.144]    - tweaked: FALSE
[11:01:43.144]    - call: plan(list(sequential, strategy))
[11:01:43.144] 2. sequential:
[11:01:43.144]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.144]    - tweaked: FALSE
[11:01:43.144]    - call: plan(list(sequential, strategy))
[11:01:43.144] plan(): nbrOfWorkers() = 1
[11:01:43.144] SequentialFuture started (and completed)
[11:01:43.145] signalConditions() ...
[11:01:43.145]  - include = ‘immediateCondition’
[11:01:43.145]  - exclude = 
[11:01:43.145]  - resignal = FALSE
[11:01:43.145]  - Number of conditions: 53
[11:01:43.145] signalConditions() ... done
[11:01:43.145] - Launch lazy future ... done
[11:01:43.145] run() for ‘SequentialFuture’ ... done
[11:01:43.145] signalConditions() ...
[11:01:43.145]  - include = ‘immediateCondition’
[11:01:43.145]  - exclude = 
[11:01:43.145]  - resignal = FALSE
[11:01:43.146]  - Number of conditions: 53
[11:01:43.146] signalConditions() ... done
[11:01:43.146] Future state: ‘finished’
[11:01:43.146] signalConditions() ...
[11:01:43.146]  - include = ‘condition’
[11:01:43.146]  - exclude = ‘immediateCondition’
[11:01:43.146]  - resignal = TRUE
[11:01:43.146]  - Number of conditions: 53
[11:01:43.146]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.116] getGlobalsAndPackages() ...
[11:01:43.146]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.146]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.129] Searching for globals...
[11:01:43.147]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.130] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[11:01:43.147]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.130] Searching for globals ... DONE
[11:01:43.147]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.130] Resolving globals: FALSE
[11:01:43.147]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.132] The total size of the 1 globals is 356 bytes (356 bytes)
[11:01:43.147]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.132] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:01:43.147]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.132] - globals: [1] ‘data’
[11:01:43.147]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.132] 
[11:01:43.147]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.132] getGlobalsAndPackages() ... DONE
[11:01:43.148]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.133] run() for ‘Future’ ...
[11:01:43.148]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.133] - state: ‘created’
[11:01:43.148]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.133] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:43.148]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.133] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:43.148]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:43.148]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.133]   - Field: ‘label’
[11:01:43.148]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.133]   - Field: ‘local’
[11:01:43.148]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.133]   - Field: ‘owner’
[11:01:43.148]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.134]   - Field: ‘envir’
[11:01:43.149]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.134]   - Field: ‘packages’
[11:01:43.149]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.134]   - Field: ‘gc’
[11:01:43.149]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.134]   - Field: ‘conditions’
[11:01:43.149]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.134]   - Field: ‘expr’
[11:01:43.149]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.134]   - Field: ‘uuid’
[11:01:43.149]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.134]   - Field: ‘seed’
[11:01:43.149]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.134]   - Field: ‘version’
[11:01:43.149]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.134]   - Field: ‘result’
[11:01:43.149]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.134]   - Field: ‘asynchronous’
[11:01:43.150]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.135]   - Field: ‘calls’
[11:01:43.150]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.135]   - Field: ‘globals’
[11:01:43.150]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.135]   - Field: ‘stdout’
[11:01:43.150]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.135]   - Field: ‘earlySignal’
[11:01:43.150]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.135]   - Field: ‘lazy’
[11:01:43.150]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.135]   - Field: ‘state’
[11:01:43.150]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:43.150]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.135] - Launch lazy future ...
[11:01:43.150]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.135] Packages needed by the future expression (n = 0): <none>
[11:01:43.151]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.136] Packages needed by future strategies (n = 0): <none>
[11:01:43.151]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.136] {
[11:01:43.136]     {
[11:01:43.136]         {
[11:01:43.136]             ...future.startTime <- base::Sys.time()
[11:01:43.136]             {
[11:01:43.136]                 {
[11:01:43.136]                   {
[11:01:43.136]                     base::local({
[11:01:43.136]                       has_future <- base::requireNamespace("future", 
[11:01:43.136]                         quietly = TRUE)
[11:01:43.136]                       if (has_future) {
[11:01:43.136]                         ns <- base::getNamespace("future")
[11:01:43.136]                         version <- ns[[".package"]][["version"]]
[11:01:43.136]                         if (is.null(version)) 
[11:01:43.136]                           version <- utils::packageVersion("future")
[11:01:43.136]                       }
[11:01:43.136]                       else {
[11:01:43.136]                         version <- NULL
[11:01:43.136]                       }
[11:01:43.136]                       if (!has_future || version < "1.8.0") {
[11:01:43.136]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.136]                           "", base::R.version$version.string), 
[11:01:43.136]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:43.136]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.136]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.136]                             "release", "version")], collapse = " "), 
[11:01:43.136]                           hostname = base::Sys.info()[["nodename"]])
[11:01:43.136]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.136]                           info)
[11:01:43.136]                         info <- base::paste(info, collapse = "; ")
[11:01:43.136]                         if (!has_future) {
[11:01:43.136]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.136]                             info)
[11:01:43.136]                         }
[11:01:43.136]                         else {
[11:01:43.136]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.136]                             info, version)
[11:01:43.136]                         }
[11:01:43.136]                         base::stop(msg)
[11:01:43.136]                       }
[11:01:43.136]                     })
[11:01:43.136]                   }
[11:01:43.136]                   ...future.strategy.old <- future::plan("list")
[11:01:43.136]                   options(future.plan = NULL)
[11:01:43.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:43.136]                 }
[11:01:43.136]                 ...future.workdir <- getwd()
[11:01:43.136]             }
[11:01:43.136]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.136]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.136]         }
[11:01:43.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.136]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.136]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.136]             base::names(...future.oldOptions))
[11:01:43.136]     }
[11:01:43.136]     if (FALSE) {
[11:01:43.136]     }
[11:01:43.136]     else {
[11:01:43.136]         if (TRUE) {
[11:01:43.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.136]                 open = "w")
[11:01:43.136]         }
[11:01:43.136]         else {
[11:01:43.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.136]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.136]         }
[11:01:43.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.136]             base::sink(type = "output", split = FALSE)
[11:01:43.136]             base::close(...future.stdout)
[11:01:43.136]         }, add = TRUE)
[11:01:43.136]     }
[11:01:43.136]     ...future.frame <- base::sys.nframe()
[11:01:43.136]     ...future.conditions <- base::list()
[11:01:43.136]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.136]     if (FALSE) {
[11:01:43.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.136]     }
[11:01:43.136]     ...future.result <- base::tryCatch({
[11:01:43.136]         base::withCallingHandlers({
[11:01:43.136]             ...future.value <- base::withVisible(base::local(subset(data, 
[11:01:43.136]                 x < 3)$y))
[11:01:43.136]             future::FutureResult(value = ...future.value$value, 
[11:01:43.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.136]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.136]                     ...future.globalenv.names))
[11:01:43.136]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.136]         }, condition = base::local({
[11:01:43.136]             c <- base::c
[11:01:43.136]             inherits <- base::inherits
[11:01:43.136]             invokeRestart <- base::invokeRestart
[11:01:43.136]             length <- base::length
[11:01:43.136]             list <- base::list
[11:01:43.136]             seq.int <- base::seq.int
[11:01:43.136]             signalCondition <- base::signalCondition
[11:01:43.136]             sys.calls <- base::sys.calls
[11:01:43.136]             `[[` <- base::`[[`
[11:01:43.136]             `+` <- base::`+`
[11:01:43.136]             `<<-` <- base::`<<-`
[11:01:43.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.136]                   3L)]
[11:01:43.136]             }
[11:01:43.136]             function(cond) {
[11:01:43.136]                 is_error <- inherits(cond, "error")
[11:01:43.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.136]                   NULL)
[11:01:43.136]                 if (is_error) {
[11:01:43.136]                   sessionInformation <- function() {
[11:01:43.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.136]                       search = base::search(), system = base::Sys.info())
[11:01:43.136]                   }
[11:01:43.136]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.136]                     cond$call), session = sessionInformation(), 
[11:01:43.136]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.136]                   signalCondition(cond)
[11:01:43.136]                 }
[11:01:43.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.136]                 "immediateCondition"))) {
[11:01:43.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.136]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.136]                   if (TRUE && !signal) {
[11:01:43.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.136]                     {
[11:01:43.136]                       inherits <- base::inherits
[11:01:43.136]                       invokeRestart <- base::invokeRestart
[11:01:43.136]                       is.null <- base::is.null
[11:01:43.136]                       muffled <- FALSE
[11:01:43.136]                       if (inherits(cond, "message")) {
[11:01:43.136]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.136]                         if (muffled) 
[11:01:43.136]                           invokeRestart("muffleMessage")
[11:01:43.136]                       }
[11:01:43.136]                       else if (inherits(cond, "warning")) {
[11:01:43.136]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.136]                         if (muffled) 
[11:01:43.136]                           invokeRestart("muffleWarning")
[11:01:43.136]                       }
[11:01:43.136]                       else if (inherits(cond, "condition")) {
[11:01:43.136]                         if (!is.null(pattern)) {
[11:01:43.136]                           computeRestarts <- base::computeRestarts
[11:01:43.136]                           grepl <- base::grepl
[11:01:43.136]                           restarts <- computeRestarts(cond)
[11:01:43.136]                           for (restart in restarts) {
[11:01:43.136]                             name <- restart$name
[11:01:43.136]                             if (is.null(name)) 
[11:01:43.136]                               next
[11:01:43.136]                             if (!grepl(pattern, name)) 
[11:01:43.136]                               next
[11:01:43.136]                             invokeRestart(restart)
[11:01:43.136]                             muffled <- TRUE
[11:01:43.136]                             break
[11:01:43.136]                           }
[11:01:43.136]                         }
[11:01:43.136]                       }
[11:01:43.136]                       invisible(muffled)
[11:01:43.136]                     }
[11:01:43.136]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.136]                   }
[11:01:43.136]                 }
[11:01:43.136]                 else {
[11:01:43.136]                   if (TRUE) {
[11:01:43.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.136]                     {
[11:01:43.136]                       inherits <- base::inherits
[11:01:43.136]                       invokeRestart <- base::invokeRestart
[11:01:43.136]                       is.null <- base::is.null
[11:01:43.136]                       muffled <- FALSE
[11:01:43.136]                       if (inherits(cond, "message")) {
[11:01:43.136]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.136]                         if (muffled) 
[11:01:43.136]                           invokeRestart("muffleMessage")
[11:01:43.136]                       }
[11:01:43.136]                       else if (inherits(cond, "warning")) {
[11:01:43.136]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.136]                         if (muffled) 
[11:01:43.136]                           invokeRestart("muffleWarning")
[11:01:43.136]                       }
[11:01:43.136]                       else if (inherits(cond, "condition")) {
[11:01:43.136]                         if (!is.null(pattern)) {
[11:01:43.136]                           computeRestarts <- base::computeRestarts
[11:01:43.136]                           grepl <- base::grepl
[11:01:43.136]                           restarts <- computeRestarts(cond)
[11:01:43.136]                           for (restart in restarts) {
[11:01:43.136]                             name <- restart$name
[11:01:43.136]                             if (is.null(name)) 
[11:01:43.136]                               next
[11:01:43.136]                             if (!grepl(pattern, name)) 
[11:01:43.136]                               next
[11:01:43.136]                             invokeRestart(restart)
[11:01:43.136]                             muffled <- TRUE
[11:01:43.136]                             break
[11:01:43.136]                           }
[11:01:43.136]                         }
[11:01:43.136]                       }
[11:01:43.136]                       invisible(muffled)
[11:01:43.136]                     }
[11:01:43.136]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.136]                   }
[11:01:43.136]                 }
[11:01:43.136]             }
[11:01:43.136]         }))
[11:01:43.136]     }, error = function(ex) {
[11:01:43.136]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.136]                 ...future.rng), started = ...future.startTime, 
[11:01:43.136]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.136]             version = "1.8"), class = "FutureResult")
[11:01:43.136]     }, finally = {
[11:01:43.136]         if (!identical(...future.workdir, getwd())) 
[11:01:43.136]             setwd(...future.workdir)
[11:01:43.136]         {
[11:01:43.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.136]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.136]             }
[11:01:43.136]             base::options(...future.oldOptions)
[11:01:43.136]             if (.Platform$OS.type == "windows") {
[11:01:43.136]                 old_names <- names(...future.oldEnvVars)
[11:01:43.136]                 envs <- base::Sys.getenv()
[11:01:43.136]                 names <- names(envs)
[11:01:43.136]                 common <- intersect(names, old_names)
[11:01:43.136]                 added <- setdiff(names, old_names)
[11:01:43.136]                 removed <- setdiff(old_names, names)
[11:01:43.136]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.136]                   envs[common]]
[11:01:43.136]                 NAMES <- toupper(changed)
[11:01:43.136]                 args <- list()
[11:01:43.136]                 for (kk in seq_along(NAMES)) {
[11:01:43.136]                   name <- changed[[kk]]
[11:01:43.136]                   NAME <- NAMES[[kk]]
[11:01:43.136]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.136]                     next
[11:01:43.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.136]                 }
[11:01:43.136]                 NAMES <- toupper(added)
[11:01:43.136]                 for (kk in seq_along(NAMES)) {
[11:01:43.136]                   name <- added[[kk]]
[11:01:43.136]                   NAME <- NAMES[[kk]]
[11:01:43.136]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.136]                     next
[11:01:43.136]                   args[[name]] <- ""
[11:01:43.136]                 }
[11:01:43.136]                 NAMES <- toupper(removed)
[11:01:43.136]                 for (kk in seq_along(NAMES)) {
[11:01:43.136]                   name <- removed[[kk]]
[11:01:43.136]                   NAME <- NAMES[[kk]]
[11:01:43.136]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.136]                     next
[11:01:43.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.136]                 }
[11:01:43.136]                 if (length(args) > 0) 
[11:01:43.136]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.136]             }
[11:01:43.136]             else {
[11:01:43.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.136]             }
[11:01:43.136]             {
[11:01:43.136]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.136]                   0L) {
[11:01:43.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.136]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.136]                   base::options(opts)
[11:01:43.136]                 }
[11:01:43.136]                 {
[11:01:43.136]                   {
[11:01:43.136]                     NULL
[11:01:43.136]                     RNGkind("Mersenne-Twister")
[11:01:43.136]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:43.136]                       inherits = FALSE)
[11:01:43.136]                   }
[11:01:43.136]                   options(future.plan = NULL)
[11:01:43.136]                   if (is.na(NA_character_)) 
[11:01:43.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.136]                     .init = FALSE)
[11:01:43.136]                 }
[11:01:43.136]             }
[11:01:43.136]         }
[11:01:43.136]     })
[11:01:43.136]     if (TRUE) {
[11:01:43.136]         base::sink(type = "output", split = FALSE)
[11:01:43.136]         if (TRUE) {
[11:01:43.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.136]         }
[11:01:43.136]         else {
[11:01:43.136]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.136]         }
[11:01:43.136]         base::close(...future.stdout)
[11:01:43.136]         ...future.stdout <- NULL
[11:01:43.136]     }
[11:01:43.136]     ...future.result$conditions <- ...future.conditions
[11:01:43.136]     ...future.result$finished <- base::Sys.time()
[11:01:43.136]     ...future.result
[11:01:43.136] }
[11:01:43.151]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.137] assign_globals() ...
[11:01:43.151]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.137] List of 1
[11:01:43.137]  $ data:'data.frame':	5 obs. of  2 variables:
[11:01:43.137]   ..$ x: int [1:5] 1 2 3 4 5
[11:01:43.137]   ..$ y: int [1:5] 1 2 3 4 5
[11:01:43.137]  - attr(*, "where")=List of 1
[11:01:43.137]   ..$ data:<environment: R_EmptyEnv> 
[11:01:43.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:43.137]  - attr(*, "resolved")= logi FALSE
[11:01:43.137]  - attr(*, "total_size")= num 356
[11:01:43.137]  - attr(*, "already-done")= logi TRUE
[11:01:43.151]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.140] - copied ‘data’ to environment
[11:01:43.151]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.141] assign_globals() ... done
[11:01:43.151]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.141] plan(): Setting new future strategy stack:
[11:01:43.152]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.141] List of future strategies:
[11:01:43.141] 1. sequential:
[11:01:43.141]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.141]    - tweaked: FALSE
[11:01:43.141]    - call: NULL
[11:01:43.152]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.141] plan(): nbrOfWorkers() = 1
[11:01:43.152]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.142] plan(): Setting new future strategy stack:
[11:01:43.152]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.142] List of future strategies:
[11:01:43.142] 1. sequential:
[11:01:43.142]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.142]    - tweaked: FALSE
[11:01:43.142]    - call: plan(list(sequential, strategy))
[11:01:43.152]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.143] plan(): nbrOfWorkers() = 1
[11:01:43.152]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.143] SequentialFuture started (and completed)
[11:01:43.152]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.143] - Launch lazy future ... done
[11:01:43.152]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.143] run() for ‘SequentialFuture’ ... done
[11:01:43.153] signalConditions() ... done
[11:01:43.153] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.153] Searching for globals...
[11:01:43.154] - globals found: [3] ‘{’, ‘plan’, ‘sequential’
[11:01:43.154] Searching for globals ... DONE
[11:01:43.154] Resolving globals: FALSE
[11:01:43.154] 
[11:01:43.154] - packages: [1] ‘future’
[11:01:43.154] getGlobalsAndPackages() ... DONE
[11:01:43.155] run() for ‘Future’ ...
[11:01:43.155] - state: ‘created’
[11:01:43.155] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:43.156] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:43.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:43.156]   - Field: ‘label’
[11:01:43.156]   - Field: ‘local’
[11:01:43.156]   - Field: ‘owner’
[11:01:43.156]   - Field: ‘envir’
[11:01:43.156]   - Field: ‘packages’
[11:01:43.157]   - Field: ‘gc’
[11:01:43.157]   - Field: ‘conditions’
[11:01:43.157]   - Field: ‘expr’
[11:01:43.157]   - Field: ‘uuid’
[11:01:43.157]   - Field: ‘seed’
[11:01:43.157]   - Field: ‘version’
[11:01:43.157]   - Field: ‘result’
[11:01:43.157]   - Field: ‘asynchronous’
[11:01:43.157]   - Field: ‘calls’
[11:01:43.157]   - Field: ‘globals’
[11:01:43.157]   - Field: ‘stdout’
[11:01:43.157]   - Field: ‘earlySignal’
[11:01:43.158]   - Field: ‘lazy’
[11:01:43.158]   - Field: ‘state’
[11:01:43.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:43.158] - Launch lazy future ...
[11:01:43.158] Packages needed by the future expression (n = 1): ‘future’
[11:01:43.158] Packages needed by future strategies (n = 1): ‘future’
[11:01:43.158] {
[11:01:43.158]     {
[11:01:43.158]         {
[11:01:43.158]             ...future.startTime <- base::Sys.time()
[11:01:43.158]             {
[11:01:43.158]                 {
[11:01:43.158]                   {
[11:01:43.158]                     {
[11:01:43.158]                       base::local({
[11:01:43.158]                         has_future <- base::requireNamespace("future", 
[11:01:43.158]                           quietly = TRUE)
[11:01:43.158]                         if (has_future) {
[11:01:43.158]                           ns <- base::getNamespace("future")
[11:01:43.158]                           version <- ns[[".package"]][["version"]]
[11:01:43.158]                           if (is.null(version)) 
[11:01:43.158]                             version <- utils::packageVersion("future")
[11:01:43.158]                         }
[11:01:43.158]                         else {
[11:01:43.158]                           version <- NULL
[11:01:43.158]                         }
[11:01:43.158]                         if (!has_future || version < "1.8.0") {
[11:01:43.158]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.158]                             "", base::R.version$version.string), 
[11:01:43.158]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:43.158]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.158]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.158]                               "release", "version")], collapse = " "), 
[11:01:43.158]                             hostname = base::Sys.info()[["nodename"]])
[11:01:43.158]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.158]                             info)
[11:01:43.158]                           info <- base::paste(info, collapse = "; ")
[11:01:43.158]                           if (!has_future) {
[11:01:43.158]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.158]                               info)
[11:01:43.158]                           }
[11:01:43.158]                           else {
[11:01:43.158]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.158]                               info, version)
[11:01:43.158]                           }
[11:01:43.158]                           base::stop(msg)
[11:01:43.158]                         }
[11:01:43.158]                       })
[11:01:43.158]                     }
[11:01:43.158]                     base::local({
[11:01:43.158]                       for (pkg in "future") {
[11:01:43.158]                         base::loadNamespace(pkg)
[11:01:43.158]                         base::library(pkg, character.only = TRUE)
[11:01:43.158]                       }
[11:01:43.158]                     })
[11:01:43.158]                   }
[11:01:43.158]                   ...future.strategy.old <- future::plan("list")
[11:01:43.158]                   options(future.plan = NULL)
[11:01:43.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.158]                   future::plan(list(function (..., envir = parent.frame()) 
[11:01:43.158]                   {
[11:01:43.158]                     future <- SequentialFuture(..., envir = envir)
[11:01:43.158]                     if (!future$lazy) 
[11:01:43.158]                       future <- run(future)
[11:01:43.158]                     invisible(future)
[11:01:43.158]                   }), .cleanup = FALSE, .init = FALSE)
[11:01:43.158]                 }
[11:01:43.158]                 ...future.workdir <- getwd()
[11:01:43.158]             }
[11:01:43.158]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.158]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.158]         }
[11:01:43.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.158]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.158]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.158]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.158]             base::names(...future.oldOptions))
[11:01:43.158]     }
[11:01:43.158]     if (FALSE) {
[11:01:43.158]     }
[11:01:43.158]     else {
[11:01:43.158]         if (TRUE) {
[11:01:43.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.158]                 open = "w")
[11:01:43.158]         }
[11:01:43.158]         else {
[11:01:43.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.158]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.158]         }
[11:01:43.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.158]             base::sink(type = "output", split = FALSE)
[11:01:43.158]             base::close(...future.stdout)
[11:01:43.158]         }, add = TRUE)
[11:01:43.158]     }
[11:01:43.158]     ...future.frame <- base::sys.nframe()
[11:01:43.158]     ...future.conditions <- base::list()
[11:01:43.158]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.158]     if (FALSE) {
[11:01:43.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.158]     }
[11:01:43.158]     ...future.result <- base::tryCatch({
[11:01:43.158]         base::withCallingHandlers({
[11:01:43.158]             ...future.value <- base::withVisible(base::local({
[11:01:43.158]                 plan(sequential)
[11:01:43.158]             }))
[11:01:43.158]             future::FutureResult(value = ...future.value$value, 
[11:01:43.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.158]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.158]                     ...future.globalenv.names))
[11:01:43.158]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.158]         }, condition = base::local({
[11:01:43.158]             c <- base::c
[11:01:43.158]             inherits <- base::inherits
[11:01:43.158]             invokeRestart <- base::invokeRestart
[11:01:43.158]             length <- base::length
[11:01:43.158]             list <- base::list
[11:01:43.158]             seq.int <- base::seq.int
[11:01:43.158]             signalCondition <- base::signalCondition
[11:01:43.158]             sys.calls <- base::sys.calls
[11:01:43.158]             `[[` <- base::`[[`
[11:01:43.158]             `+` <- base::`+`
[11:01:43.158]             `<<-` <- base::`<<-`
[11:01:43.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.158]                   3L)]
[11:01:43.158]             }
[11:01:43.158]             function(cond) {
[11:01:43.158]                 is_error <- inherits(cond, "error")
[11:01:43.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.158]                   NULL)
[11:01:43.158]                 if (is_error) {
[11:01:43.158]                   sessionInformation <- function() {
[11:01:43.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.158]                       search = base::search(), system = base::Sys.info())
[11:01:43.158]                   }
[11:01:43.158]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.158]                     cond$call), session = sessionInformation(), 
[11:01:43.158]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.158]                   signalCondition(cond)
[11:01:43.158]                 }
[11:01:43.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.158]                 "immediateCondition"))) {
[11:01:43.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.158]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.158]                   if (TRUE && !signal) {
[11:01:43.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.158]                     {
[11:01:43.158]                       inherits <- base::inherits
[11:01:43.158]                       invokeRestart <- base::invokeRestart
[11:01:43.158]                       is.null <- base::is.null
[11:01:43.158]                       muffled <- FALSE
[11:01:43.158]                       if (inherits(cond, "message")) {
[11:01:43.158]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.158]                         if (muffled) 
[11:01:43.158]                           invokeRestart("muffleMessage")
[11:01:43.158]                       }
[11:01:43.158]                       else if (inherits(cond, "warning")) {
[11:01:43.158]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.158]                         if (muffled) 
[11:01:43.158]                           invokeRestart("muffleWarning")
[11:01:43.158]                       }
[11:01:43.158]                       else if (inherits(cond, "condition")) {
[11:01:43.158]                         if (!is.null(pattern)) {
[11:01:43.158]                           computeRestarts <- base::computeRestarts
[11:01:43.158]                           grepl <- base::grepl
[11:01:43.158]                           restarts <- computeRestarts(cond)
[11:01:43.158]                           for (restart in restarts) {
[11:01:43.158]                             name <- restart$name
[11:01:43.158]                             if (is.null(name)) 
[11:01:43.158]                               next
[11:01:43.158]                             if (!grepl(pattern, name)) 
[11:01:43.158]                               next
[11:01:43.158]                             invokeRestart(restart)
[11:01:43.158]                             muffled <- TRUE
[11:01:43.158]                             break
[11:01:43.158]                           }
[11:01:43.158]                         }
[11:01:43.158]                       }
[11:01:43.158]                       invisible(muffled)
[11:01:43.158]                     }
[11:01:43.158]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.158]                   }
[11:01:43.158]                 }
[11:01:43.158]                 else {
[11:01:43.158]                   if (TRUE) {
[11:01:43.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.158]                     {
[11:01:43.158]                       inherits <- base::inherits
[11:01:43.158]                       invokeRestart <- base::invokeRestart
[11:01:43.158]                       is.null <- base::is.null
[11:01:43.158]                       muffled <- FALSE
[11:01:43.158]                       if (inherits(cond, "message")) {
[11:01:43.158]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.158]                         if (muffled) 
[11:01:43.158]                           invokeRestart("muffleMessage")
[11:01:43.158]                       }
[11:01:43.158]                       else if (inherits(cond, "warning")) {
[11:01:43.158]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.158]                         if (muffled) 
[11:01:43.158]                           invokeRestart("muffleWarning")
[11:01:43.158]                       }
[11:01:43.158]                       else if (inherits(cond, "condition")) {
[11:01:43.158]                         if (!is.null(pattern)) {
[11:01:43.158]                           computeRestarts <- base::computeRestarts
[11:01:43.158]                           grepl <- base::grepl
[11:01:43.158]                           restarts <- computeRestarts(cond)
[11:01:43.158]                           for (restart in restarts) {
[11:01:43.158]                             name <- restart$name
[11:01:43.158]                             if (is.null(name)) 
[11:01:43.158]                               next
[11:01:43.158]                             if (!grepl(pattern, name)) 
[11:01:43.158]                               next
[11:01:43.158]                             invokeRestart(restart)
[11:01:43.158]                             muffled <- TRUE
[11:01:43.158]                             break
[11:01:43.158]                           }
[11:01:43.158]                         }
[11:01:43.158]                       }
[11:01:43.158]                       invisible(muffled)
[11:01:43.158]                     }
[11:01:43.158]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.158]                   }
[11:01:43.158]                 }
[11:01:43.158]             }
[11:01:43.158]         }))
[11:01:43.158]     }, error = function(ex) {
[11:01:43.158]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.158]                 ...future.rng), started = ...future.startTime, 
[11:01:43.158]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.158]             version = "1.8"), class = "FutureResult")
[11:01:43.158]     }, finally = {
[11:01:43.158]         if (!identical(...future.workdir, getwd())) 
[11:01:43.158]             setwd(...future.workdir)
[11:01:43.158]         {
[11:01:43.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.158]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.158]             }
[11:01:43.158]             base::options(...future.oldOptions)
[11:01:43.158]             if (.Platform$OS.type == "windows") {
[11:01:43.158]                 old_names <- names(...future.oldEnvVars)
[11:01:43.158]                 envs <- base::Sys.getenv()
[11:01:43.158]                 names <- names(envs)
[11:01:43.158]                 common <- intersect(names, old_names)
[11:01:43.158]                 added <- setdiff(names, old_names)
[11:01:43.158]                 removed <- setdiff(old_names, names)
[11:01:43.158]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.158]                   envs[common]]
[11:01:43.158]                 NAMES <- toupper(changed)
[11:01:43.158]                 args <- list()
[11:01:43.158]                 for (kk in seq_along(NAMES)) {
[11:01:43.158]                   name <- changed[[kk]]
[11:01:43.158]                   NAME <- NAMES[[kk]]
[11:01:43.158]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.158]                     next
[11:01:43.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.158]                 }
[11:01:43.158]                 NAMES <- toupper(added)
[11:01:43.158]                 for (kk in seq_along(NAMES)) {
[11:01:43.158]                   name <- added[[kk]]
[11:01:43.158]                   NAME <- NAMES[[kk]]
[11:01:43.158]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.158]                     next
[11:01:43.158]                   args[[name]] <- ""
[11:01:43.158]                 }
[11:01:43.158]                 NAMES <- toupper(removed)
[11:01:43.158]                 for (kk in seq_along(NAMES)) {
[11:01:43.158]                   name <- removed[[kk]]
[11:01:43.158]                   NAME <- NAMES[[kk]]
[11:01:43.158]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.158]                     next
[11:01:43.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.158]                 }
[11:01:43.158]                 if (length(args) > 0) 
[11:01:43.158]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.158]             }
[11:01:43.158]             else {
[11:01:43.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.158]             }
[11:01:43.158]             {
[11:01:43.158]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.158]                   0L) {
[11:01:43.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.158]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.158]                   base::options(opts)
[11:01:43.158]                 }
[11:01:43.158]                 {
[11:01:43.158]                   {
[11:01:43.158]                     NULL
[11:01:43.158]                     RNGkind("Mersenne-Twister")
[11:01:43.158]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:43.158]                       inherits = FALSE)
[11:01:43.158]                   }
[11:01:43.158]                   options(future.plan = NULL)
[11:01:43.158]                   if (is.na(NA_character_)) 
[11:01:43.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.158]                     .init = FALSE)
[11:01:43.158]                 }
[11:01:43.158]             }
[11:01:43.158]         }
[11:01:43.158]     })
[11:01:43.158]     if (TRUE) {
[11:01:43.158]         base::sink(type = "output", split = FALSE)
[11:01:43.158]         if (TRUE) {
[11:01:43.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.158]         }
[11:01:43.158]         else {
[11:01:43.158]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.158]         }
[11:01:43.158]         base::close(...future.stdout)
[11:01:43.158]         ...future.stdout <- NULL
[11:01:43.158]     }
[11:01:43.158]     ...future.result$conditions <- ...future.conditions
[11:01:43.158]     ...future.result$finished <- base::Sys.time()
[11:01:43.158]     ...future.result
[11:01:43.158] }
[11:01:43.160] plan(): Setting new future strategy stack:
[11:01:43.160] List of future strategies:
[11:01:43.160] 1. sequential:
[11:01:43.160]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.160]    - tweaked: FALSE
[11:01:43.160]    - call: plan(list(sequential, strategy))
[11:01:43.161] plan(): nbrOfWorkers() = 1
[11:01:43.175] plan(): Setting new future strategy stack:
[11:01:43.175] List of future strategies:
[11:01:43.175] 1. sequential:
[11:01:43.175]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.175]    - tweaked: FALSE
[11:01:43.175]    - call: plan(list(sequential, strategy))
[11:01:43.175] 2. sequential:
[11:01:43.175]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.175]    - tweaked: FALSE
[11:01:43.175]    - call: plan(list(sequential, strategy))
[11:01:43.175] plan(): nbrOfWorkers() = 1
[11:01:43.176] SequentialFuture started (and completed)
[11:01:43.176] signalConditions() ...
[11:01:43.176]  - include = ‘immediateCondition’
[11:01:43.176]  - exclude = 
[11:01:43.176]  - resignal = FALSE
[11:01:43.176]  - Number of conditions: 3
[11:01:43.177] signalConditions() ... done
[11:01:43.177] - Launch lazy future ... done
[11:01:43.177] run() for ‘SequentialFuture’ ... done
[11:01:43.177] signalConditions() ...
[11:01:43.177]  - include = ‘immediateCondition’
[11:01:43.177]  - exclude = 
[11:01:43.177]  - resignal = FALSE
[11:01:43.178]  - Number of conditions: 3
[11:01:43.178] signalConditions() ... done
[11:01:43.178] Future state: ‘finished’
[11:01:43.178] signalConditions() ...
[11:01:43.178]  - include = ‘condition’
[11:01:43.178]  - exclude = ‘immediateCondition’
[11:01:43.178]  - resignal = TRUE
[11:01:43.178]  - Number of conditions: 3
[11:01:43.178]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.161] plan(): Setting new future strategy stack:
[11:01:43.178]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.161] List of future strategies:
[11:01:43.161] 1. sequential:
[11:01:43.161]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.161]    - tweaked: FALSE
[11:01:43.161]    - call: plan(sequential)
[11:01:43.178]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.174] plan(): nbrOfWorkers() = 1
[11:01:43.179] signalConditions() ... done
List of future strategies:
1. sequential:
   - args: function (..., envir = parent.frame(), workers = "<NULL>")
   - tweaked: FALSE
   - call: plan(list(sequential, strategy))
- Strategy: sequential ... DONE
- Strategy: multicore ...
[11:01:43.179] plan(): Setting new future strategy stack:
[11:01:43.179] List of future strategies:
[11:01:43.179] 1. multicore:
[11:01:43.179]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:43.179]    - tweaked: FALSE
[11:01:43.179]    - call: plan(strategy)
[11:01:43.181] plan(): nbrOfWorkers() = 2
[11:01:43.181] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:43.181] Searching for globals...
[11:01:43.182] - globals found: [1] ‘getOption’
[11:01:43.182] Searching for globals ... DONE
[11:01:43.182] Resolving globals: FALSE
[11:01:43.182] 
[11:01:43.182] 
[11:01:43.182] getGlobalsAndPackages() ... DONE
[11:01:43.183] run() for ‘Future’ ...
[11:01:43.183] - state: ‘created’
[11:01:43.183] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:43.184] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:43.184] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:43.185]   - Field: ‘label’
[11:01:43.185]   - Field: ‘local’
[11:01:43.185]   - Field: ‘owner’
[11:01:43.185]   - Field: ‘envir’
[11:01:43.185]   - Field: ‘workers’
[11:01:43.185]   - Field: ‘packages’
[11:01:43.185]   - Field: ‘gc’
[11:01:43.185]   - Field: ‘job’
[11:01:43.185]   - Field: ‘conditions’
[11:01:43.185]   - Field: ‘expr’
[11:01:43.185]   - Field: ‘uuid’
[11:01:43.185]   - Field: ‘seed’
[11:01:43.186]   - Field: ‘version’
[11:01:43.186]   - Field: ‘result’
[11:01:43.186]   - Field: ‘asynchronous’
[11:01:43.186]   - Field: ‘calls’
[11:01:43.186]   - Field: ‘globals’
[11:01:43.186]   - Field: ‘stdout’
[11:01:43.186]   - Field: ‘earlySignal’
[11:01:43.186]   - Field: ‘lazy’
[11:01:43.186]   - Field: ‘state’
[11:01:43.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:43.186] - Launch lazy future ...
[11:01:43.187] Packages needed by the future expression (n = 0): <none>
[11:01:43.187] Packages needed by future strategies (n = 0): <none>
[11:01:43.188] {
[11:01:43.188]     {
[11:01:43.188]         {
[11:01:43.188]             ...future.startTime <- base::Sys.time()
[11:01:43.188]             {
[11:01:43.188]                 {
[11:01:43.188]                   {
[11:01:43.188]                     {
[11:01:43.188]                       base::local({
[11:01:43.188]                         has_future <- base::requireNamespace("future", 
[11:01:43.188]                           quietly = TRUE)
[11:01:43.188]                         if (has_future) {
[11:01:43.188]                           ns <- base::getNamespace("future")
[11:01:43.188]                           version <- ns[[".package"]][["version"]]
[11:01:43.188]                           if (is.null(version)) 
[11:01:43.188]                             version <- utils::packageVersion("future")
[11:01:43.188]                         }
[11:01:43.188]                         else {
[11:01:43.188]                           version <- NULL
[11:01:43.188]                         }
[11:01:43.188]                         if (!has_future || version < "1.8.0") {
[11:01:43.188]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.188]                             "", base::R.version$version.string), 
[11:01:43.188]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:43.188]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.188]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.188]                               "release", "version")], collapse = " "), 
[11:01:43.188]                             hostname = base::Sys.info()[["nodename"]])
[11:01:43.188]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.188]                             info)
[11:01:43.188]                           info <- base::paste(info, collapse = "; ")
[11:01:43.188]                           if (!has_future) {
[11:01:43.188]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.188]                               info)
[11:01:43.188]                           }
[11:01:43.188]                           else {
[11:01:43.188]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.188]                               info, version)
[11:01:43.188]                           }
[11:01:43.188]                           base::stop(msg)
[11:01:43.188]                         }
[11:01:43.188]                       })
[11:01:43.188]                     }
[11:01:43.188]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:43.188]                     base::options(mc.cores = 1L)
[11:01:43.188]                   }
[11:01:43.188]                   ...future.strategy.old <- future::plan("list")
[11:01:43.188]                   options(future.plan = NULL)
[11:01:43.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:43.188]                 }
[11:01:43.188]                 ...future.workdir <- getwd()
[11:01:43.188]             }
[11:01:43.188]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.188]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.188]         }
[11:01:43.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:43.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.188]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:43.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.188]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.188]             base::names(...future.oldOptions))
[11:01:43.188]     }
[11:01:43.188]     if (FALSE) {
[11:01:43.188]     }
[11:01:43.188]     else {
[11:01:43.188]         if (TRUE) {
[11:01:43.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.188]                 open = "w")
[11:01:43.188]         }
[11:01:43.188]         else {
[11:01:43.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.188]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.188]         }
[11:01:43.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.188]             base::sink(type = "output", split = FALSE)
[11:01:43.188]             base::close(...future.stdout)
[11:01:43.188]         }, add = TRUE)
[11:01:43.188]     }
[11:01:43.188]     ...future.frame <- base::sys.nframe()
[11:01:43.188]     ...future.conditions <- base::list()
[11:01:43.188]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.188]     if (FALSE) {
[11:01:43.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.188]     }
[11:01:43.188]     ...future.result <- base::tryCatch({
[11:01:43.188]         base::withCallingHandlers({
[11:01:43.188]             ...future.value <- base::withVisible(base::local({
[11:01:43.188]                 withCallingHandlers({
[11:01:43.188]                   getOption("future.globals.onMissing")
[11:01:43.188]                 }, immediateCondition = function(cond) {
[11:01:43.188]                   save_rds <- function (object, pathname, ...) 
[11:01:43.188]                   {
[11:01:43.188]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:43.188]                     if (file_test("-f", pathname_tmp)) {
[11:01:43.188]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.188]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:43.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.188]                         fi_tmp[["mtime"]])
[11:01:43.188]                     }
[11:01:43.188]                     tryCatch({
[11:01:43.188]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:43.188]                     }, error = function(ex) {
[11:01:43.188]                       msg <- conditionMessage(ex)
[11:01:43.188]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.188]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:43.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.188]                         fi_tmp[["mtime"]], msg)
[11:01:43.188]                       ex$message <- msg
[11:01:43.188]                       stop(ex)
[11:01:43.188]                     })
[11:01:43.188]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:43.188]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:43.188]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:43.188]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.188]                       fi <- file.info(pathname)
[11:01:43.188]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:43.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.188]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:43.188]                         fi[["size"]], fi[["mtime"]])
[11:01:43.188]                       stop(msg)
[11:01:43.188]                     }
[11:01:43.188]                     invisible(pathname)
[11:01:43.188]                   }
[11:01:43.188]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:43.188]                     rootPath = tempdir()) 
[11:01:43.188]                   {
[11:01:43.188]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:43.188]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:43.188]                       tmpdir = path, fileext = ".rds")
[11:01:43.188]                     save_rds(obj, file)
[11:01:43.188]                   }
[11:01:43.188]                   saveImmediateCondition(cond, path = "/tmp/RtmpDE64kE/.future/immediateConditions")
[11:01:43.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.188]                   {
[11:01:43.188]                     inherits <- base::inherits
[11:01:43.188]                     invokeRestart <- base::invokeRestart
[11:01:43.188]                     is.null <- base::is.null
[11:01:43.188]                     muffled <- FALSE
[11:01:43.188]                     if (inherits(cond, "message")) {
[11:01:43.188]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:43.188]                       if (muffled) 
[11:01:43.188]                         invokeRestart("muffleMessage")
[11:01:43.188]                     }
[11:01:43.188]                     else if (inherits(cond, "warning")) {
[11:01:43.188]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:43.188]                       if (muffled) 
[11:01:43.188]                         invokeRestart("muffleWarning")
[11:01:43.188]                     }
[11:01:43.188]                     else if (inherits(cond, "condition")) {
[11:01:43.188]                       if (!is.null(pattern)) {
[11:01:43.188]                         computeRestarts <- base::computeRestarts
[11:01:43.188]                         grepl <- base::grepl
[11:01:43.188]                         restarts <- computeRestarts(cond)
[11:01:43.188]                         for (restart in restarts) {
[11:01:43.188]                           name <- restart$name
[11:01:43.188]                           if (is.null(name)) 
[11:01:43.188]                             next
[11:01:43.188]                           if (!grepl(pattern, name)) 
[11:01:43.188]                             next
[11:01:43.188]                           invokeRestart(restart)
[11:01:43.188]                           muffled <- TRUE
[11:01:43.188]                           break
[11:01:43.188]                         }
[11:01:43.188]                       }
[11:01:43.188]                     }
[11:01:43.188]                     invisible(muffled)
[11:01:43.188]                   }
[11:01:43.188]                   muffleCondition(cond)
[11:01:43.188]                 })
[11:01:43.188]             }))
[11:01:43.188]             future::FutureResult(value = ...future.value$value, 
[11:01:43.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.188]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.188]                     ...future.globalenv.names))
[11:01:43.188]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.188]         }, condition = base::local({
[11:01:43.188]             c <- base::c
[11:01:43.188]             inherits <- base::inherits
[11:01:43.188]             invokeRestart <- base::invokeRestart
[11:01:43.188]             length <- base::length
[11:01:43.188]             list <- base::list
[11:01:43.188]             seq.int <- base::seq.int
[11:01:43.188]             signalCondition <- base::signalCondition
[11:01:43.188]             sys.calls <- base::sys.calls
[11:01:43.188]             `[[` <- base::`[[`
[11:01:43.188]             `+` <- base::`+`
[11:01:43.188]             `<<-` <- base::`<<-`
[11:01:43.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.188]                   3L)]
[11:01:43.188]             }
[11:01:43.188]             function(cond) {
[11:01:43.188]                 is_error <- inherits(cond, "error")
[11:01:43.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.188]                   NULL)
[11:01:43.188]                 if (is_error) {
[11:01:43.188]                   sessionInformation <- function() {
[11:01:43.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.188]                       search = base::search(), system = base::Sys.info())
[11:01:43.188]                   }
[11:01:43.188]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.188]                     cond$call), session = sessionInformation(), 
[11:01:43.188]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.188]                   signalCondition(cond)
[11:01:43.188]                 }
[11:01:43.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.188]                 "immediateCondition"))) {
[11:01:43.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.188]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.188]                   if (TRUE && !signal) {
[11:01:43.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.188]                     {
[11:01:43.188]                       inherits <- base::inherits
[11:01:43.188]                       invokeRestart <- base::invokeRestart
[11:01:43.188]                       is.null <- base::is.null
[11:01:43.188]                       muffled <- FALSE
[11:01:43.188]                       if (inherits(cond, "message")) {
[11:01:43.188]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.188]                         if (muffled) 
[11:01:43.188]                           invokeRestart("muffleMessage")
[11:01:43.188]                       }
[11:01:43.188]                       else if (inherits(cond, "warning")) {
[11:01:43.188]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.188]                         if (muffled) 
[11:01:43.188]                           invokeRestart("muffleWarning")
[11:01:43.188]                       }
[11:01:43.188]                       else if (inherits(cond, "condition")) {
[11:01:43.188]                         if (!is.null(pattern)) {
[11:01:43.188]                           computeRestarts <- base::computeRestarts
[11:01:43.188]                           grepl <- base::grepl
[11:01:43.188]                           restarts <- computeRestarts(cond)
[11:01:43.188]                           for (restart in restarts) {
[11:01:43.188]                             name <- restart$name
[11:01:43.188]                             if (is.null(name)) 
[11:01:43.188]                               next
[11:01:43.188]                             if (!grepl(pattern, name)) 
[11:01:43.188]                               next
[11:01:43.188]                             invokeRestart(restart)
[11:01:43.188]                             muffled <- TRUE
[11:01:43.188]                             break
[11:01:43.188]                           }
[11:01:43.188]                         }
[11:01:43.188]                       }
[11:01:43.188]                       invisible(muffled)
[11:01:43.188]                     }
[11:01:43.188]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.188]                   }
[11:01:43.188]                 }
[11:01:43.188]                 else {
[11:01:43.188]                   if (TRUE) {
[11:01:43.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.188]                     {
[11:01:43.188]                       inherits <- base::inherits
[11:01:43.188]                       invokeRestart <- base::invokeRestart
[11:01:43.188]                       is.null <- base::is.null
[11:01:43.188]                       muffled <- FALSE
[11:01:43.188]                       if (inherits(cond, "message")) {
[11:01:43.188]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.188]                         if (muffled) 
[11:01:43.188]                           invokeRestart("muffleMessage")
[11:01:43.188]                       }
[11:01:43.188]                       else if (inherits(cond, "warning")) {
[11:01:43.188]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.188]                         if (muffled) 
[11:01:43.188]                           invokeRestart("muffleWarning")
[11:01:43.188]                       }
[11:01:43.188]                       else if (inherits(cond, "condition")) {
[11:01:43.188]                         if (!is.null(pattern)) {
[11:01:43.188]                           computeRestarts <- base::computeRestarts
[11:01:43.188]                           grepl <- base::grepl
[11:01:43.188]                           restarts <- computeRestarts(cond)
[11:01:43.188]                           for (restart in restarts) {
[11:01:43.188]                             name <- restart$name
[11:01:43.188]                             if (is.null(name)) 
[11:01:43.188]                               next
[11:01:43.188]                             if (!grepl(pattern, name)) 
[11:01:43.188]                               next
[11:01:43.188]                             invokeRestart(restart)
[11:01:43.188]                             muffled <- TRUE
[11:01:43.188]                             break
[11:01:43.188]                           }
[11:01:43.188]                         }
[11:01:43.188]                       }
[11:01:43.188]                       invisible(muffled)
[11:01:43.188]                     }
[11:01:43.188]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.188]                   }
[11:01:43.188]                 }
[11:01:43.188]             }
[11:01:43.188]         }))
[11:01:43.188]     }, error = function(ex) {
[11:01:43.188]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.188]                 ...future.rng), started = ...future.startTime, 
[11:01:43.188]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.188]             version = "1.8"), class = "FutureResult")
[11:01:43.188]     }, finally = {
[11:01:43.188]         if (!identical(...future.workdir, getwd())) 
[11:01:43.188]             setwd(...future.workdir)
[11:01:43.188]         {
[11:01:43.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.188]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.188]             }
[11:01:43.188]             base::options(...future.oldOptions)
[11:01:43.188]             if (.Platform$OS.type == "windows") {
[11:01:43.188]                 old_names <- names(...future.oldEnvVars)
[11:01:43.188]                 envs <- base::Sys.getenv()
[11:01:43.188]                 names <- names(envs)
[11:01:43.188]                 common <- intersect(names, old_names)
[11:01:43.188]                 added <- setdiff(names, old_names)
[11:01:43.188]                 removed <- setdiff(old_names, names)
[11:01:43.188]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.188]                   envs[common]]
[11:01:43.188]                 NAMES <- toupper(changed)
[11:01:43.188]                 args <- list()
[11:01:43.188]                 for (kk in seq_along(NAMES)) {
[11:01:43.188]                   name <- changed[[kk]]
[11:01:43.188]                   NAME <- NAMES[[kk]]
[11:01:43.188]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.188]                     next
[11:01:43.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.188]                 }
[11:01:43.188]                 NAMES <- toupper(added)
[11:01:43.188]                 for (kk in seq_along(NAMES)) {
[11:01:43.188]                   name <- added[[kk]]
[11:01:43.188]                   NAME <- NAMES[[kk]]
[11:01:43.188]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.188]                     next
[11:01:43.188]                   args[[name]] <- ""
[11:01:43.188]                 }
[11:01:43.188]                 NAMES <- toupper(removed)
[11:01:43.188]                 for (kk in seq_along(NAMES)) {
[11:01:43.188]                   name <- removed[[kk]]
[11:01:43.188]                   NAME <- NAMES[[kk]]
[11:01:43.188]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.188]                     next
[11:01:43.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.188]                 }
[11:01:43.188]                 if (length(args) > 0) 
[11:01:43.188]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.188]             }
[11:01:43.188]             else {
[11:01:43.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.188]             }
[11:01:43.188]             {
[11:01:43.188]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.188]                   0L) {
[11:01:43.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.188]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.188]                   base::options(opts)
[11:01:43.188]                 }
[11:01:43.188]                 {
[11:01:43.188]                   {
[11:01:43.188]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:43.188]                     NULL
[11:01:43.188]                   }
[11:01:43.188]                   options(future.plan = NULL)
[11:01:43.188]                   if (is.na(NA_character_)) 
[11:01:43.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.188]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.188]                     .init = FALSE)
[11:01:43.188]                 }
[11:01:43.188]             }
[11:01:43.188]         }
[11:01:43.188]     })
[11:01:43.188]     if (TRUE) {
[11:01:43.188]         base::sink(type = "output", split = FALSE)
[11:01:43.188]         if (TRUE) {
[11:01:43.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.188]         }
[11:01:43.188]         else {
[11:01:43.188]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.188]         }
[11:01:43.188]         base::close(...future.stdout)
[11:01:43.188]         ...future.stdout <- NULL
[11:01:43.188]     }
[11:01:43.188]     ...future.result$conditions <- ...future.conditions
[11:01:43.188]     ...future.result$finished <- base::Sys.time()
[11:01:43.188]     ...future.result
[11:01:43.188] }
[11:01:43.190] requestCore(): workers = 2
[11:01:43.193] MulticoreFuture started
[11:01:43.193] - Launch lazy future ... done
[11:01:43.193] run() for ‘MulticoreFuture’ ... done
[11:01:43.193] plan(): Setting new future strategy stack:
[11:01:43.194] result() for MulticoreFuture ...
[11:01:43.193] List of future strategies:
[11:01:43.193] 1. sequential:
[11:01:43.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.193]    - tweaked: FALSE
[11:01:43.193]    - call: NULL
[11:01:43.195] plan(): nbrOfWorkers() = 1
[11:01:43.196] plan(): Setting new future strategy stack:
[11:01:43.197] List of future strategies:
[11:01:43.197] 1. multicore:
[11:01:43.197]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:43.197]    - tweaked: FALSE
[11:01:43.197]    - call: plan(strategy)
[11:01:43.200] plan(): nbrOfWorkers() = 2
[11:01:43.204] result() for MulticoreFuture ...
[11:01:43.204] result() for MulticoreFuture ... done
[11:01:43.204] result() for MulticoreFuture ... done
[11:01:43.204] result() for MulticoreFuture ...
[11:01:43.204] result() for MulticoreFuture ... done
[11:01:43.204] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.205] Searching for globals...
[11:01:43.205] - globals found: [1] ‘getOption’
[11:01:43.206] Searching for globals ... DONE
[11:01:43.206] Resolving globals: FALSE
[11:01:43.206] 
[11:01:43.206] 
[11:01:43.206] getGlobalsAndPackages() ... DONE
[11:01:43.207] run() for ‘Future’ ...
[11:01:43.207] - state: ‘created’
[11:01:43.207] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:43.209] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:43.209] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:43.209]   - Field: ‘label’
[11:01:43.209]   - Field: ‘local’
[11:01:43.209]   - Field: ‘owner’
[11:01:43.209]   - Field: ‘envir’
[11:01:43.209]   - Field: ‘workers’
[11:01:43.210]   - Field: ‘packages’
[11:01:43.210]   - Field: ‘gc’
[11:01:43.210]   - Field: ‘job’
[11:01:43.210]   - Field: ‘conditions’
[11:01:43.210]   - Field: ‘expr’
[11:01:43.210]   - Field: ‘uuid’
[11:01:43.210]   - Field: ‘seed’
[11:01:43.210]   - Field: ‘version’
[11:01:43.210]   - Field: ‘result’
[11:01:43.210]   - Field: ‘asynchronous’
[11:01:43.211]   - Field: ‘calls’
[11:01:43.211]   - Field: ‘globals’
[11:01:43.211]   - Field: ‘stdout’
[11:01:43.211]   - Field: ‘earlySignal’
[11:01:43.211]   - Field: ‘lazy’
[11:01:43.211]   - Field: ‘state’
[11:01:43.211] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:43.211] - Launch lazy future ...
[11:01:43.212] Packages needed by the future expression (n = 0): <none>
[11:01:43.212] Packages needed by future strategies (n = 0): <none>
[11:01:43.212] {
[11:01:43.212]     {
[11:01:43.212]         {
[11:01:43.212]             ...future.startTime <- base::Sys.time()
[11:01:43.212]             {
[11:01:43.212]                 {
[11:01:43.212]                   {
[11:01:43.212]                     {
[11:01:43.212]                       base::local({
[11:01:43.212]                         has_future <- base::requireNamespace("future", 
[11:01:43.212]                           quietly = TRUE)
[11:01:43.212]                         if (has_future) {
[11:01:43.212]                           ns <- base::getNamespace("future")
[11:01:43.212]                           version <- ns[[".package"]][["version"]]
[11:01:43.212]                           if (is.null(version)) 
[11:01:43.212]                             version <- utils::packageVersion("future")
[11:01:43.212]                         }
[11:01:43.212]                         else {
[11:01:43.212]                           version <- NULL
[11:01:43.212]                         }
[11:01:43.212]                         if (!has_future || version < "1.8.0") {
[11:01:43.212]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.212]                             "", base::R.version$version.string), 
[11:01:43.212]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:43.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.212]                               "release", "version")], collapse = " "), 
[11:01:43.212]                             hostname = base::Sys.info()[["nodename"]])
[11:01:43.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.212]                             info)
[11:01:43.212]                           info <- base::paste(info, collapse = "; ")
[11:01:43.212]                           if (!has_future) {
[11:01:43.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.212]                               info)
[11:01:43.212]                           }
[11:01:43.212]                           else {
[11:01:43.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.212]                               info, version)
[11:01:43.212]                           }
[11:01:43.212]                           base::stop(msg)
[11:01:43.212]                         }
[11:01:43.212]                       })
[11:01:43.212]                     }
[11:01:43.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:43.212]                     base::options(mc.cores = 1L)
[11:01:43.212]                   }
[11:01:43.212]                   ...future.strategy.old <- future::plan("list")
[11:01:43.212]                   options(future.plan = NULL)
[11:01:43.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:43.212]                 }
[11:01:43.212]                 ...future.workdir <- getwd()
[11:01:43.212]             }
[11:01:43.212]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.212]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.212]         }
[11:01:43.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.212]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.212]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.212]             base::names(...future.oldOptions))
[11:01:43.212]     }
[11:01:43.212]     if (FALSE) {
[11:01:43.212]     }
[11:01:43.212]     else {
[11:01:43.212]         if (TRUE) {
[11:01:43.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.212]                 open = "w")
[11:01:43.212]         }
[11:01:43.212]         else {
[11:01:43.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.212]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.212]         }
[11:01:43.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.212]             base::sink(type = "output", split = FALSE)
[11:01:43.212]             base::close(...future.stdout)
[11:01:43.212]         }, add = TRUE)
[11:01:43.212]     }
[11:01:43.212]     ...future.frame <- base::sys.nframe()
[11:01:43.212]     ...future.conditions <- base::list()
[11:01:43.212]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.212]     if (FALSE) {
[11:01:43.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.212]     }
[11:01:43.212]     ...future.result <- base::tryCatch({
[11:01:43.212]         base::withCallingHandlers({
[11:01:43.212]             ...future.value <- base::withVisible(base::local({
[11:01:43.212]                 withCallingHandlers({
[11:01:43.212]                   getOption("future.globals.onMissing")
[11:01:43.212]                 }, immediateCondition = function(cond) {
[11:01:43.212]                   save_rds <- function (object, pathname, ...) 
[11:01:43.212]                   {
[11:01:43.212]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:43.212]                     if (file_test("-f", pathname_tmp)) {
[11:01:43.212]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.212]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:43.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.212]                         fi_tmp[["mtime"]])
[11:01:43.212]                     }
[11:01:43.212]                     tryCatch({
[11:01:43.212]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:43.212]                     }, error = function(ex) {
[11:01:43.212]                       msg <- conditionMessage(ex)
[11:01:43.212]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.212]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:43.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.212]                         fi_tmp[["mtime"]], msg)
[11:01:43.212]                       ex$message <- msg
[11:01:43.212]                       stop(ex)
[11:01:43.212]                     })
[11:01:43.212]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:43.212]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:43.212]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:43.212]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.212]                       fi <- file.info(pathname)
[11:01:43.212]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:43.212]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.212]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:43.212]                         fi[["size"]], fi[["mtime"]])
[11:01:43.212]                       stop(msg)
[11:01:43.212]                     }
[11:01:43.212]                     invisible(pathname)
[11:01:43.212]                   }
[11:01:43.212]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:43.212]                     rootPath = tempdir()) 
[11:01:43.212]                   {
[11:01:43.212]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:43.212]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:43.212]                       tmpdir = path, fileext = ".rds")
[11:01:43.212]                     save_rds(obj, file)
[11:01:43.212]                   }
[11:01:43.212]                   saveImmediateCondition(cond, path = "/tmp/RtmpDE64kE/.future/immediateConditions")
[11:01:43.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.212]                   {
[11:01:43.212]                     inherits <- base::inherits
[11:01:43.212]                     invokeRestart <- base::invokeRestart
[11:01:43.212]                     is.null <- base::is.null
[11:01:43.212]                     muffled <- FALSE
[11:01:43.212]                     if (inherits(cond, "message")) {
[11:01:43.212]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:43.212]                       if (muffled) 
[11:01:43.212]                         invokeRestart("muffleMessage")
[11:01:43.212]                     }
[11:01:43.212]                     else if (inherits(cond, "warning")) {
[11:01:43.212]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:43.212]                       if (muffled) 
[11:01:43.212]                         invokeRestart("muffleWarning")
[11:01:43.212]                     }
[11:01:43.212]                     else if (inherits(cond, "condition")) {
[11:01:43.212]                       if (!is.null(pattern)) {
[11:01:43.212]                         computeRestarts <- base::computeRestarts
[11:01:43.212]                         grepl <- base::grepl
[11:01:43.212]                         restarts <- computeRestarts(cond)
[11:01:43.212]                         for (restart in restarts) {
[11:01:43.212]                           name <- restart$name
[11:01:43.212]                           if (is.null(name)) 
[11:01:43.212]                             next
[11:01:43.212]                           if (!grepl(pattern, name)) 
[11:01:43.212]                             next
[11:01:43.212]                           invokeRestart(restart)
[11:01:43.212]                           muffled <- TRUE
[11:01:43.212]                           break
[11:01:43.212]                         }
[11:01:43.212]                       }
[11:01:43.212]                     }
[11:01:43.212]                     invisible(muffled)
[11:01:43.212]                   }
[11:01:43.212]                   muffleCondition(cond)
[11:01:43.212]                 })
[11:01:43.212]             }))
[11:01:43.212]             future::FutureResult(value = ...future.value$value, 
[11:01:43.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.212]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.212]                     ...future.globalenv.names))
[11:01:43.212]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.212]         }, condition = base::local({
[11:01:43.212]             c <- base::c
[11:01:43.212]             inherits <- base::inherits
[11:01:43.212]             invokeRestart <- base::invokeRestart
[11:01:43.212]             length <- base::length
[11:01:43.212]             list <- base::list
[11:01:43.212]             seq.int <- base::seq.int
[11:01:43.212]             signalCondition <- base::signalCondition
[11:01:43.212]             sys.calls <- base::sys.calls
[11:01:43.212]             `[[` <- base::`[[`
[11:01:43.212]             `+` <- base::`+`
[11:01:43.212]             `<<-` <- base::`<<-`
[11:01:43.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.212]                   3L)]
[11:01:43.212]             }
[11:01:43.212]             function(cond) {
[11:01:43.212]                 is_error <- inherits(cond, "error")
[11:01:43.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.212]                   NULL)
[11:01:43.212]                 if (is_error) {
[11:01:43.212]                   sessionInformation <- function() {
[11:01:43.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.212]                       search = base::search(), system = base::Sys.info())
[11:01:43.212]                   }
[11:01:43.212]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.212]                     cond$call), session = sessionInformation(), 
[11:01:43.212]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.212]                   signalCondition(cond)
[11:01:43.212]                 }
[11:01:43.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.212]                 "immediateCondition"))) {
[11:01:43.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.212]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.212]                   if (TRUE && !signal) {
[11:01:43.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.212]                     {
[11:01:43.212]                       inherits <- base::inherits
[11:01:43.212]                       invokeRestart <- base::invokeRestart
[11:01:43.212]                       is.null <- base::is.null
[11:01:43.212]                       muffled <- FALSE
[11:01:43.212]                       if (inherits(cond, "message")) {
[11:01:43.212]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.212]                         if (muffled) 
[11:01:43.212]                           invokeRestart("muffleMessage")
[11:01:43.212]                       }
[11:01:43.212]                       else if (inherits(cond, "warning")) {
[11:01:43.212]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.212]                         if (muffled) 
[11:01:43.212]                           invokeRestart("muffleWarning")
[11:01:43.212]                       }
[11:01:43.212]                       else if (inherits(cond, "condition")) {
[11:01:43.212]                         if (!is.null(pattern)) {
[11:01:43.212]                           computeRestarts <- base::computeRestarts
[11:01:43.212]                           grepl <- base::grepl
[11:01:43.212]                           restarts <- computeRestarts(cond)
[11:01:43.212]                           for (restart in restarts) {
[11:01:43.212]                             name <- restart$name
[11:01:43.212]                             if (is.null(name)) 
[11:01:43.212]                               next
[11:01:43.212]                             if (!grepl(pattern, name)) 
[11:01:43.212]                               next
[11:01:43.212]                             invokeRestart(restart)
[11:01:43.212]                             muffled <- TRUE
[11:01:43.212]                             break
[11:01:43.212]                           }
[11:01:43.212]                         }
[11:01:43.212]                       }
[11:01:43.212]                       invisible(muffled)
[11:01:43.212]                     }
[11:01:43.212]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.212]                   }
[11:01:43.212]                 }
[11:01:43.212]                 else {
[11:01:43.212]                   if (TRUE) {
[11:01:43.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.212]                     {
[11:01:43.212]                       inherits <- base::inherits
[11:01:43.212]                       invokeRestart <- base::invokeRestart
[11:01:43.212]                       is.null <- base::is.null
[11:01:43.212]                       muffled <- FALSE
[11:01:43.212]                       if (inherits(cond, "message")) {
[11:01:43.212]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.212]                         if (muffled) 
[11:01:43.212]                           invokeRestart("muffleMessage")
[11:01:43.212]                       }
[11:01:43.212]                       else if (inherits(cond, "warning")) {
[11:01:43.212]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.212]                         if (muffled) 
[11:01:43.212]                           invokeRestart("muffleWarning")
[11:01:43.212]                       }
[11:01:43.212]                       else if (inherits(cond, "condition")) {
[11:01:43.212]                         if (!is.null(pattern)) {
[11:01:43.212]                           computeRestarts <- base::computeRestarts
[11:01:43.212]                           grepl <- base::grepl
[11:01:43.212]                           restarts <- computeRestarts(cond)
[11:01:43.212]                           for (restart in restarts) {
[11:01:43.212]                             name <- restart$name
[11:01:43.212]                             if (is.null(name)) 
[11:01:43.212]                               next
[11:01:43.212]                             if (!grepl(pattern, name)) 
[11:01:43.212]                               next
[11:01:43.212]                             invokeRestart(restart)
[11:01:43.212]                             muffled <- TRUE
[11:01:43.212]                             break
[11:01:43.212]                           }
[11:01:43.212]                         }
[11:01:43.212]                       }
[11:01:43.212]                       invisible(muffled)
[11:01:43.212]                     }
[11:01:43.212]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.212]                   }
[11:01:43.212]                 }
[11:01:43.212]             }
[11:01:43.212]         }))
[11:01:43.212]     }, error = function(ex) {
[11:01:43.212]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.212]                 ...future.rng), started = ...future.startTime, 
[11:01:43.212]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.212]             version = "1.8"), class = "FutureResult")
[11:01:43.212]     }, finally = {
[11:01:43.212]         if (!identical(...future.workdir, getwd())) 
[11:01:43.212]             setwd(...future.workdir)
[11:01:43.212]         {
[11:01:43.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.212]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.212]             }
[11:01:43.212]             base::options(...future.oldOptions)
[11:01:43.212]             if (.Platform$OS.type == "windows") {
[11:01:43.212]                 old_names <- names(...future.oldEnvVars)
[11:01:43.212]                 envs <- base::Sys.getenv()
[11:01:43.212]                 names <- names(envs)
[11:01:43.212]                 common <- intersect(names, old_names)
[11:01:43.212]                 added <- setdiff(names, old_names)
[11:01:43.212]                 removed <- setdiff(old_names, names)
[11:01:43.212]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.212]                   envs[common]]
[11:01:43.212]                 NAMES <- toupper(changed)
[11:01:43.212]                 args <- list()
[11:01:43.212]                 for (kk in seq_along(NAMES)) {
[11:01:43.212]                   name <- changed[[kk]]
[11:01:43.212]                   NAME <- NAMES[[kk]]
[11:01:43.212]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.212]                     next
[11:01:43.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.212]                 }
[11:01:43.212]                 NAMES <- toupper(added)
[11:01:43.212]                 for (kk in seq_along(NAMES)) {
[11:01:43.212]                   name <- added[[kk]]
[11:01:43.212]                   NAME <- NAMES[[kk]]
[11:01:43.212]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.212]                     next
[11:01:43.212]                   args[[name]] <- ""
[11:01:43.212]                 }
[11:01:43.212]                 NAMES <- toupper(removed)
[11:01:43.212]                 for (kk in seq_along(NAMES)) {
[11:01:43.212]                   name <- removed[[kk]]
[11:01:43.212]                   NAME <- NAMES[[kk]]
[11:01:43.212]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.212]                     next
[11:01:43.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.212]                 }
[11:01:43.212]                 if (length(args) > 0) 
[11:01:43.212]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.212]             }
[11:01:43.212]             else {
[11:01:43.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.212]             }
[11:01:43.212]             {
[11:01:43.212]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.212]                   0L) {
[11:01:43.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.212]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.212]                   base::options(opts)
[11:01:43.212]                 }
[11:01:43.212]                 {
[11:01:43.212]                   {
[11:01:43.212]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:43.212]                     NULL
[11:01:43.212]                   }
[11:01:43.212]                   options(future.plan = NULL)
[11:01:43.212]                   if (is.na(NA_character_)) 
[11:01:43.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.212]                     .init = FALSE)
[11:01:43.212]                 }
[11:01:43.212]             }
[11:01:43.212]         }
[11:01:43.212]     })
[11:01:43.212]     if (TRUE) {
[11:01:43.212]         base::sink(type = "output", split = FALSE)
[11:01:43.212]         if (TRUE) {
[11:01:43.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.212]         }
[11:01:43.212]         else {
[11:01:43.212]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.212]         }
[11:01:43.212]         base::close(...future.stdout)
[11:01:43.212]         ...future.stdout <- NULL
[11:01:43.212]     }
[11:01:43.212]     ...future.result$conditions <- ...future.conditions
[11:01:43.212]     ...future.result$finished <- base::Sys.time()
[11:01:43.212]     ...future.result
[11:01:43.212] }
[11:01:43.215] requestCore(): workers = 2
[11:01:43.216] MulticoreFuture started
[11:01:43.217] - Launch lazy future ... done
[11:01:43.217] run() for ‘MulticoreFuture’ ... done
[11:01:43.217] result() for MulticoreFuture ...
[11:01:43.217] plan(): Setting new future strategy stack:
[11:01:43.217] List of future strategies:
[11:01:43.217] 1. sequential:
[11:01:43.217]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.217]    - tweaked: FALSE
[11:01:43.217]    - call: NULL
[11:01:43.218] plan(): nbrOfWorkers() = 1
[11:01:43.220] plan(): Setting new future strategy stack:
[11:01:43.220] List of future strategies:
[11:01:43.220] 1. multicore:
[11:01:43.220]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:43.220]    - tweaked: FALSE
[11:01:43.220]    - call: plan(strategy)
[11:01:43.223] plan(): nbrOfWorkers() = 2
[11:01:43.229] result() for MulticoreFuture ...
[11:01:43.229] result() for MulticoreFuture ... done
[11:01:43.229] result() for MulticoreFuture ... done
[11:01:43.229] result() for MulticoreFuture ...
[11:01:43.229] result() for MulticoreFuture ... done
[11:01:43.230] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:43.230] Searching for globals...
[11:01:43.234] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.235] Searching for globals...
[11:01:43.236] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[11:01:43.236] Searching for globals ... DONE
[11:01:43.236] Resolving globals: FALSE
[11:01:43.237] The total size of the 1 globals is 356 bytes (356 bytes)
[11:01:43.237] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:01:43.237] - globals: [1] ‘data’
[11:01:43.238] 
[11:01:43.238] getGlobalsAndPackages() ... DONE
[11:01:43.238] run() for ‘Future’ ...
[11:01:43.238] - state: ‘created’
[11:01:43.238] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:43.240] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:43.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:43.240]   - Field: ‘label’
[11:01:43.241]   - Field: ‘local’
[11:01:43.241]   - Field: ‘owner’
[11:01:43.241]   - Field: ‘envir’
[11:01:43.241]   - Field: ‘workers’
[11:01:43.241]   - Field: ‘packages’
[11:01:43.241]   - Field: ‘gc’
[11:01:43.241]   - Field: ‘job’
[11:01:43.241]   - Field: ‘conditions’
[11:01:43.241]   - Field: ‘expr’
[11:01:43.242]   - Field: ‘uuid’
[11:01:43.242]   - Field: ‘seed’
[11:01:43.242]   - Field: ‘version’
[11:01:43.242]   - Field: ‘result’
[11:01:43.242]   - Field: ‘asynchronous’
[11:01:43.242]   - Field: ‘calls’
[11:01:43.242]   - Field: ‘globals’
[11:01:43.242]   - Field: ‘stdout’
[11:01:43.242]   - Field: ‘earlySignal’
[11:01:43.243]   - Field: ‘lazy’
[11:01:43.243]   - Field: ‘state’
[11:01:43.243] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:43.243] - Launch lazy future ...
[11:01:43.243] Packages needed by the future expression (n = 0): <none>
[11:01:43.243] Packages needed by future strategies (n = 0): <none>
[11:01:43.244] {
[11:01:43.244]     {
[11:01:43.244]         {
[11:01:43.244]             ...future.startTime <- base::Sys.time()
[11:01:43.244]             {
[11:01:43.244]                 {
[11:01:43.244]                   {
[11:01:43.244]                     {
[11:01:43.244]                       base::local({
[11:01:43.244]                         has_future <- base::requireNamespace("future", 
[11:01:43.244]                           quietly = TRUE)
[11:01:43.244]                         if (has_future) {
[11:01:43.244]                           ns <- base::getNamespace("future")
[11:01:43.244]                           version <- ns[[".package"]][["version"]]
[11:01:43.244]                           if (is.null(version)) 
[11:01:43.244]                             version <- utils::packageVersion("future")
[11:01:43.244]                         }
[11:01:43.244]                         else {
[11:01:43.244]                           version <- NULL
[11:01:43.244]                         }
[11:01:43.244]                         if (!has_future || version < "1.8.0") {
[11:01:43.244]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.244]                             "", base::R.version$version.string), 
[11:01:43.244]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:43.244]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.244]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.244]                               "release", "version")], collapse = " "), 
[11:01:43.244]                             hostname = base::Sys.info()[["nodename"]])
[11:01:43.244]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.244]                             info)
[11:01:43.244]                           info <- base::paste(info, collapse = "; ")
[11:01:43.244]                           if (!has_future) {
[11:01:43.244]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.244]                               info)
[11:01:43.244]                           }
[11:01:43.244]                           else {
[11:01:43.244]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.244]                               info, version)
[11:01:43.244]                           }
[11:01:43.244]                           base::stop(msg)
[11:01:43.244]                         }
[11:01:43.244]                       })
[11:01:43.244]                     }
[11:01:43.244]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:43.244]                     base::options(mc.cores = 1L)
[11:01:43.244]                   }
[11:01:43.244]                   ...future.strategy.old <- future::plan("list")
[11:01:43.244]                   options(future.plan = NULL)
[11:01:43.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:43.244]                 }
[11:01:43.244]                 ...future.workdir <- getwd()
[11:01:43.244]             }
[11:01:43.244]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.244]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.244]         }
[11:01:43.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.244]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.244]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.244]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.244]             base::names(...future.oldOptions))
[11:01:43.244]     }
[11:01:43.244]     if (FALSE) {
[11:01:43.244]     }
[11:01:43.244]     else {
[11:01:43.244]         if (TRUE) {
[11:01:43.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.244]                 open = "w")
[11:01:43.244]         }
[11:01:43.244]         else {
[11:01:43.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.244]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.244]         }
[11:01:43.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.244]             base::sink(type = "output", split = FALSE)
[11:01:43.244]             base::close(...future.stdout)
[11:01:43.244]         }, add = TRUE)
[11:01:43.244]     }
[11:01:43.244]     ...future.frame <- base::sys.nframe()
[11:01:43.244]     ...future.conditions <- base::list()
[11:01:43.244]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.244]     if (FALSE) {
[11:01:43.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.244]     }
[11:01:43.244]     ...future.result <- base::tryCatch({
[11:01:43.244]         base::withCallingHandlers({
[11:01:43.244]             ...future.value <- base::withVisible(base::local({
[11:01:43.244]                 withCallingHandlers({
[11:01:43.244]                   subset(data, x < 3)$y
[11:01:43.244]                 }, immediateCondition = function(cond) {
[11:01:43.244]                   save_rds <- function (object, pathname, ...) 
[11:01:43.244]                   {
[11:01:43.244]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:43.244]                     if (file_test("-f", pathname_tmp)) {
[11:01:43.244]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.244]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:43.244]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.244]                         fi_tmp[["mtime"]])
[11:01:43.244]                     }
[11:01:43.244]                     tryCatch({
[11:01:43.244]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:43.244]                     }, error = function(ex) {
[11:01:43.244]                       msg <- conditionMessage(ex)
[11:01:43.244]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.244]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:43.244]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.244]                         fi_tmp[["mtime"]], msg)
[11:01:43.244]                       ex$message <- msg
[11:01:43.244]                       stop(ex)
[11:01:43.244]                     })
[11:01:43.244]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:43.244]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:43.244]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:43.244]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.244]                       fi <- file.info(pathname)
[11:01:43.244]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:43.244]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.244]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:43.244]                         fi[["size"]], fi[["mtime"]])
[11:01:43.244]                       stop(msg)
[11:01:43.244]                     }
[11:01:43.244]                     invisible(pathname)
[11:01:43.244]                   }
[11:01:43.244]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:43.244]                     rootPath = tempdir()) 
[11:01:43.244]                   {
[11:01:43.244]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:43.244]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:43.244]                       tmpdir = path, fileext = ".rds")
[11:01:43.244]                     save_rds(obj, file)
[11:01:43.244]                   }
[11:01:43.244]                   saveImmediateCondition(cond, path = "/tmp/RtmpDE64kE/.future/immediateConditions")
[11:01:43.244]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.244]                   {
[11:01:43.244]                     inherits <- base::inherits
[11:01:43.244]                     invokeRestart <- base::invokeRestart
[11:01:43.244]                     is.null <- base::is.null
[11:01:43.244]                     muffled <- FALSE
[11:01:43.244]                     if (inherits(cond, "message")) {
[11:01:43.244]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:43.244]                       if (muffled) 
[11:01:43.244]                         invokeRestart("muffleMessage")
[11:01:43.244]                     }
[11:01:43.244]                     else if (inherits(cond, "warning")) {
[11:01:43.244]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:43.244]                       if (muffled) 
[11:01:43.244]                         invokeRestart("muffleWarning")
[11:01:43.244]                     }
[11:01:43.244]                     else if (inherits(cond, "condition")) {
[11:01:43.244]                       if (!is.null(pattern)) {
[11:01:43.244]                         computeRestarts <- base::computeRestarts
[11:01:43.244]                         grepl <- base::grepl
[11:01:43.244]                         restarts <- computeRestarts(cond)
[11:01:43.244]                         for (restart in restarts) {
[11:01:43.244]                           name <- restart$name
[11:01:43.244]                           if (is.null(name)) 
[11:01:43.244]                             next
[11:01:43.244]                           if (!grepl(pattern, name)) 
[11:01:43.244]                             next
[11:01:43.244]                           invokeRestart(restart)
[11:01:43.244]                           muffled <- TRUE
[11:01:43.244]                           break
[11:01:43.244]                         }
[11:01:43.244]                       }
[11:01:43.244]                     }
[11:01:43.244]                     invisible(muffled)
[11:01:43.244]                   }
[11:01:43.244]                   muffleCondition(cond)
[11:01:43.244]                 })
[11:01:43.244]             }))
[11:01:43.244]             future::FutureResult(value = ...future.value$value, 
[11:01:43.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.244]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.244]                     ...future.globalenv.names))
[11:01:43.244]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.244]         }, condition = base::local({
[11:01:43.244]             c <- base::c
[11:01:43.244]             inherits <- base::inherits
[11:01:43.244]             invokeRestart <- base::invokeRestart
[11:01:43.244]             length <- base::length
[11:01:43.244]             list <- base::list
[11:01:43.244]             seq.int <- base::seq.int
[11:01:43.244]             signalCondition <- base::signalCondition
[11:01:43.244]             sys.calls <- base::sys.calls
[11:01:43.244]             `[[` <- base::`[[`
[11:01:43.244]             `+` <- base::`+`
[11:01:43.244]             `<<-` <- base::`<<-`
[11:01:43.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.244]                   3L)]
[11:01:43.244]             }
[11:01:43.244]             function(cond) {
[11:01:43.244]                 is_error <- inherits(cond, "error")
[11:01:43.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.244]                   NULL)
[11:01:43.244]                 if (is_error) {
[11:01:43.244]                   sessionInformation <- function() {
[11:01:43.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.244]                       search = base::search(), system = base::Sys.info())
[11:01:43.244]                   }
[11:01:43.244]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.244]                     cond$call), session = sessionInformation(), 
[11:01:43.244]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.244]                   signalCondition(cond)
[11:01:43.244]                 }
[11:01:43.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.244]                 "immediateCondition"))) {
[11:01:43.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.244]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.244]                   if (TRUE && !signal) {
[11:01:43.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.244]                     {
[11:01:43.244]                       inherits <- base::inherits
[11:01:43.244]                       invokeRestart <- base::invokeRestart
[11:01:43.244]                       is.null <- base::is.null
[11:01:43.244]                       muffled <- FALSE
[11:01:43.244]                       if (inherits(cond, "message")) {
[11:01:43.244]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.244]                         if (muffled) 
[11:01:43.244]                           invokeRestart("muffleMessage")
[11:01:43.244]                       }
[11:01:43.244]                       else if (inherits(cond, "warning")) {
[11:01:43.244]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.244]                         if (muffled) 
[11:01:43.244]                           invokeRestart("muffleWarning")
[11:01:43.244]                       }
[11:01:43.244]                       else if (inherits(cond, "condition")) {
[11:01:43.244]                         if (!is.null(pattern)) {
[11:01:43.244]                           computeRestarts <- base::computeRestarts
[11:01:43.244]                           grepl <- base::grepl
[11:01:43.244]                           restarts <- computeRestarts(cond)
[11:01:43.244]                           for (restart in restarts) {
[11:01:43.244]                             name <- restart$name
[11:01:43.244]                             if (is.null(name)) 
[11:01:43.244]                               next
[11:01:43.244]                             if (!grepl(pattern, name)) 
[11:01:43.244]                               next
[11:01:43.244]                             invokeRestart(restart)
[11:01:43.244]                             muffled <- TRUE
[11:01:43.244]                             break
[11:01:43.244]                           }
[11:01:43.244]                         }
[11:01:43.244]                       }
[11:01:43.244]                       invisible(muffled)
[11:01:43.244]                     }
[11:01:43.244]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.244]                   }
[11:01:43.244]                 }
[11:01:43.244]                 else {
[11:01:43.244]                   if (TRUE) {
[11:01:43.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.244]                     {
[11:01:43.244]                       inherits <- base::inherits
[11:01:43.244]                       invokeRestart <- base::invokeRestart
[11:01:43.244]                       is.null <- base::is.null
[11:01:43.244]                       muffled <- FALSE
[11:01:43.244]                       if (inherits(cond, "message")) {
[11:01:43.244]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.244]                         if (muffled) 
[11:01:43.244]                           invokeRestart("muffleMessage")
[11:01:43.244]                       }
[11:01:43.244]                       else if (inherits(cond, "warning")) {
[11:01:43.244]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.244]                         if (muffled) 
[11:01:43.244]                           invokeRestart("muffleWarning")
[11:01:43.244]                       }
[11:01:43.244]                       else if (inherits(cond, "condition")) {
[11:01:43.244]                         if (!is.null(pattern)) {
[11:01:43.244]                           computeRestarts <- base::computeRestarts
[11:01:43.244]                           grepl <- base::grepl
[11:01:43.244]                           restarts <- computeRestarts(cond)
[11:01:43.244]                           for (restart in restarts) {
[11:01:43.244]                             name <- restart$name
[11:01:43.244]                             if (is.null(name)) 
[11:01:43.244]                               next
[11:01:43.244]                             if (!grepl(pattern, name)) 
[11:01:43.244]                               next
[11:01:43.244]                             invokeRestart(restart)
[11:01:43.244]                             muffled <- TRUE
[11:01:43.244]                             break
[11:01:43.244]                           }
[11:01:43.244]                         }
[11:01:43.244]                       }
[11:01:43.244]                       invisible(muffled)
[11:01:43.244]                     }
[11:01:43.244]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.244]                   }
[11:01:43.244]                 }
[11:01:43.244]             }
[11:01:43.244]         }))
[11:01:43.244]     }, error = function(ex) {
[11:01:43.244]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.244]                 ...future.rng), started = ...future.startTime, 
[11:01:43.244]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.244]             version = "1.8"), class = "FutureResult")
[11:01:43.244]     }, finally = {
[11:01:43.244]         if (!identical(...future.workdir, getwd())) 
[11:01:43.244]             setwd(...future.workdir)
[11:01:43.244]         {
[11:01:43.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.244]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.244]             }
[11:01:43.244]             base::options(...future.oldOptions)
[11:01:43.244]             if (.Platform$OS.type == "windows") {
[11:01:43.244]                 old_names <- names(...future.oldEnvVars)
[11:01:43.244]                 envs <- base::Sys.getenv()
[11:01:43.244]                 names <- names(envs)
[11:01:43.244]                 common <- intersect(names, old_names)
[11:01:43.244]                 added <- setdiff(names, old_names)
[11:01:43.244]                 removed <- setdiff(old_names, names)
[11:01:43.244]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.244]                   envs[common]]
[11:01:43.244]                 NAMES <- toupper(changed)
[11:01:43.244]                 args <- list()
[11:01:43.244]                 for (kk in seq_along(NAMES)) {
[11:01:43.244]                   name <- changed[[kk]]
[11:01:43.244]                   NAME <- NAMES[[kk]]
[11:01:43.244]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.244]                     next
[11:01:43.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.244]                 }
[11:01:43.244]                 NAMES <- toupper(added)
[11:01:43.244]                 for (kk in seq_along(NAMES)) {
[11:01:43.244]                   name <- added[[kk]]
[11:01:43.244]                   NAME <- NAMES[[kk]]
[11:01:43.244]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.244]                     next
[11:01:43.244]                   args[[name]] <- ""
[11:01:43.244]                 }
[11:01:43.244]                 NAMES <- toupper(removed)
[11:01:43.244]                 for (kk in seq_along(NAMES)) {
[11:01:43.244]                   name <- removed[[kk]]
[11:01:43.244]                   NAME <- NAMES[[kk]]
[11:01:43.244]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.244]                     next
[11:01:43.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.244]                 }
[11:01:43.244]                 if (length(args) > 0) 
[11:01:43.244]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.244]             }
[11:01:43.244]             else {
[11:01:43.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.244]             }
[11:01:43.244]             {
[11:01:43.244]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.244]                   0L) {
[11:01:43.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.244]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.244]                   base::options(opts)
[11:01:43.244]                 }
[11:01:43.244]                 {
[11:01:43.244]                   {
[11:01:43.244]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:43.244]                     NULL
[11:01:43.244]                   }
[11:01:43.244]                   options(future.plan = NULL)
[11:01:43.244]                   if (is.na(NA_character_)) 
[11:01:43.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.244]                     .init = FALSE)
[11:01:43.244]                 }
[11:01:43.244]             }
[11:01:43.244]         }
[11:01:43.244]     })
[11:01:43.244]     if (TRUE) {
[11:01:43.244]         base::sink(type = "output", split = FALSE)
[11:01:43.244]         if (TRUE) {
[11:01:43.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.244]         }
[11:01:43.244]         else {
[11:01:43.244]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.244]         }
[11:01:43.244]         base::close(...future.stdout)
[11:01:43.244]         ...future.stdout <- NULL
[11:01:43.244]     }
[11:01:43.244]     ...future.result$conditions <- ...future.conditions
[11:01:43.244]     ...future.result$finished <- base::Sys.time()
[11:01:43.244]     ...future.result
[11:01:43.244] }
[11:01:43.246] assign_globals() ...
[11:01:43.246] List of 1
[11:01:43.246]  $ data:'data.frame':	5 obs. of  2 variables:
[11:01:43.246]   ..$ x: int [1:5] 1 2 3 4 5
[11:01:43.246]   ..$ y: int [1:5] 1 2 3 4 5
[11:01:43.246]  - attr(*, "where")=List of 1
[11:01:43.246]   ..$ data:<environment: R_EmptyEnv> 
[11:01:43.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:43.246]  - attr(*, "resolved")= logi FALSE
[11:01:43.246]  - attr(*, "total_size")= num 356
[11:01:43.246]  - attr(*, "already-done")= logi TRUE
[11:01:43.250] - copied ‘data’ to environment
[11:01:43.250] assign_globals() ... done
[11:01:43.250] requestCore(): workers = 2
[11:01:43.252] MulticoreFuture started
[11:01:43.252] - Launch lazy future ... done
[11:01:43.252] run() for ‘MulticoreFuture’ ... done
[11:01:43.253] result() for MulticoreFuture ...
[11:01:43.253] plan(): Setting new future strategy stack:
[11:01:43.253] List of future strategies:
[11:01:43.253] 1. sequential:
[11:01:43.253]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.253]    - tweaked: FALSE
[11:01:43.253]    - call: NULL
[11:01:43.254] plan(): nbrOfWorkers() = 1
[11:01:43.256] plan(): Setting new future strategy stack:
[11:01:43.256] List of future strategies:
[11:01:43.256] 1. multicore:
[11:01:43.256]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:43.256]    - tweaked: FALSE
[11:01:43.256]    - call: plan(strategy)
[11:01:43.259] plan(): nbrOfWorkers() = 2
[11:01:43.260] result() for MulticoreFuture ...
[11:01:43.260] result() for MulticoreFuture ... done
[11:01:43.260] result() for MulticoreFuture ... done
[11:01:43.261] result() for MulticoreFuture ...
[11:01:43.261] result() for MulticoreFuture ... done
[11:01:43.261] plan(): Setting new future strategy stack:
[11:01:43.261] List of future strategies:
[11:01:43.261] 1. sequential:
[11:01:43.261]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.261]    - tweaked: FALSE
[11:01:43.261]    - call: plan(list(sequential, strategy))
[11:01:43.261] 2. multicore:
[11:01:43.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:43.261]    - tweaked: FALSE
[11:01:43.261]    - call: plan(list(sequential, strategy))
[11:01:43.262] plan(): nbrOfWorkers() = 1
[11:01:43.262] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.263] Searching for globals...
[11:01:43.266] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[11:01:43.266] Searching for globals ... DONE
[11:01:43.266] Resolving globals: FALSE
[11:01:43.267] The total size of the 1 globals is 356 bytes (356 bytes)
[11:01:43.267] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:01:43.268] - globals: [1] ‘data’
[11:01:43.268] - packages: [1] ‘future’
[11:01:43.268] getGlobalsAndPackages() ... DONE
[11:01:43.268] run() for ‘Future’ ...
[11:01:43.268] - state: ‘created’
[11:01:43.269] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:43.269] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:43.269] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:43.269]   - Field: ‘label’
[11:01:43.269]   - Field: ‘local’
[11:01:43.269]   - Field: ‘owner’
[11:01:43.269]   - Field: ‘envir’
[11:01:43.270]   - Field: ‘packages’
[11:01:43.270]   - Field: ‘gc’
[11:01:43.270]   - Field: ‘conditions’
[11:01:43.270]   - Field: ‘expr’
[11:01:43.270]   - Field: ‘uuid’
[11:01:43.270]   - Field: ‘seed’
[11:01:43.270]   - Field: ‘version’
[11:01:43.270]   - Field: ‘result’
[11:01:43.270]   - Field: ‘asynchronous’
[11:01:43.270]   - Field: ‘calls’
[11:01:43.271]   - Field: ‘globals’
[11:01:43.271]   - Field: ‘stdout’
[11:01:43.271]   - Field: ‘earlySignal’
[11:01:43.271]   - Field: ‘lazy’
[11:01:43.271]   - Field: ‘state’
[11:01:43.271] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:43.271] - Launch lazy future ...
[11:01:43.271] Packages needed by the future expression (n = 1): ‘future’
[11:01:43.272] Packages needed by future strategies (n = 1): ‘future’
[11:01:43.272] {
[11:01:43.272]     {
[11:01:43.272]         {
[11:01:43.272]             ...future.startTime <- base::Sys.time()
[11:01:43.272]             {
[11:01:43.272]                 {
[11:01:43.272]                   {
[11:01:43.272]                     {
[11:01:43.272]                       base::local({
[11:01:43.272]                         has_future <- base::requireNamespace("future", 
[11:01:43.272]                           quietly = TRUE)
[11:01:43.272]                         if (has_future) {
[11:01:43.272]                           ns <- base::getNamespace("future")
[11:01:43.272]                           version <- ns[[".package"]][["version"]]
[11:01:43.272]                           if (is.null(version)) 
[11:01:43.272]                             version <- utils::packageVersion("future")
[11:01:43.272]                         }
[11:01:43.272]                         else {
[11:01:43.272]                           version <- NULL
[11:01:43.272]                         }
[11:01:43.272]                         if (!has_future || version < "1.8.0") {
[11:01:43.272]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.272]                             "", base::R.version$version.string), 
[11:01:43.272]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:43.272]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.272]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.272]                               "release", "version")], collapse = " "), 
[11:01:43.272]                             hostname = base::Sys.info()[["nodename"]])
[11:01:43.272]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.272]                             info)
[11:01:43.272]                           info <- base::paste(info, collapse = "; ")
[11:01:43.272]                           if (!has_future) {
[11:01:43.272]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.272]                               info)
[11:01:43.272]                           }
[11:01:43.272]                           else {
[11:01:43.272]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.272]                               info, version)
[11:01:43.272]                           }
[11:01:43.272]                           base::stop(msg)
[11:01:43.272]                         }
[11:01:43.272]                       })
[11:01:43.272]                     }
[11:01:43.272]                     base::local({
[11:01:43.272]                       for (pkg in "future") {
[11:01:43.272]                         base::loadNamespace(pkg)
[11:01:43.272]                         base::library(pkg, character.only = TRUE)
[11:01:43.272]                       }
[11:01:43.272]                     })
[11:01:43.272]                   }
[11:01:43.272]                   ...future.strategy.old <- future::plan("list")
[11:01:43.272]                   options(future.plan = NULL)
[11:01:43.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.272]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[11:01:43.272]                     envir = parent.frame()) 
[11:01:43.272]                   {
[11:01:43.272]                     default_workers <- missing(workers)
[11:01:43.272]                     if (is.function(workers)) 
[11:01:43.272]                       workers <- workers()
[11:01:43.272]                     workers <- structure(as.integer(workers), 
[11:01:43.272]                       class = class(workers))
[11:01:43.272]                     stop_if_not(is.finite(workers), workers >= 
[11:01:43.272]                       1L)
[11:01:43.272]                     if ((workers == 1L && !inherits(workers, 
[11:01:43.272]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[11:01:43.272]                       if (default_workers) 
[11:01:43.272]                         supportsMulticore(warn = TRUE)
[11:01:43.272]                       return(sequential(..., envir = envir))
[11:01:43.272]                     }
[11:01:43.272]                     oopts <- options(mc.cores = workers)
[11:01:43.272]                     on.exit(options(oopts))
[11:01:43.272]                     future <- MulticoreFuture(..., workers = workers, 
[11:01:43.272]                       envir = envir)
[11:01:43.272]                     if (!future$lazy) 
[11:01:43.272]                       future <- run(future)
[11:01:43.272]                     invisible(future)
[11:01:43.272]                   }), .cleanup = FALSE, .init = FALSE)
[11:01:43.272]                 }
[11:01:43.272]                 ...future.workdir <- getwd()
[11:01:43.272]             }
[11:01:43.272]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.272]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.272]         }
[11:01:43.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.272]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.272]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.272]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.272]             base::names(...future.oldOptions))
[11:01:43.272]     }
[11:01:43.272]     if (FALSE) {
[11:01:43.272]     }
[11:01:43.272]     else {
[11:01:43.272]         if (TRUE) {
[11:01:43.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.272]                 open = "w")
[11:01:43.272]         }
[11:01:43.272]         else {
[11:01:43.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.272]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.272]         }
[11:01:43.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.272]             base::sink(type = "output", split = FALSE)
[11:01:43.272]             base::close(...future.stdout)
[11:01:43.272]         }, add = TRUE)
[11:01:43.272]     }
[11:01:43.272]     ...future.frame <- base::sys.nframe()
[11:01:43.272]     ...future.conditions <- base::list()
[11:01:43.272]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.272]     if (FALSE) {
[11:01:43.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.272]     }
[11:01:43.272]     ...future.result <- base::tryCatch({
[11:01:43.272]         base::withCallingHandlers({
[11:01:43.272]             ...future.value <- base::withVisible(base::local({
[11:01:43.272]                 a %<-% subset(data, x < 3)$y
[11:01:43.272]                 a
[11:01:43.272]             }))
[11:01:43.272]             future::FutureResult(value = ...future.value$value, 
[11:01:43.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.272]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.272]                     ...future.globalenv.names))
[11:01:43.272]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.272]         }, condition = base::local({
[11:01:43.272]             c <- base::c
[11:01:43.272]             inherits <- base::inherits
[11:01:43.272]             invokeRestart <- base::invokeRestart
[11:01:43.272]             length <- base::length
[11:01:43.272]             list <- base::list
[11:01:43.272]             seq.int <- base::seq.int
[11:01:43.272]             signalCondition <- base::signalCondition
[11:01:43.272]             sys.calls <- base::sys.calls
[11:01:43.272]             `[[` <- base::`[[`
[11:01:43.272]             `+` <- base::`+`
[11:01:43.272]             `<<-` <- base::`<<-`
[11:01:43.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.272]                   3L)]
[11:01:43.272]             }
[11:01:43.272]             function(cond) {
[11:01:43.272]                 is_error <- inherits(cond, "error")
[11:01:43.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.272]                   NULL)
[11:01:43.272]                 if (is_error) {
[11:01:43.272]                   sessionInformation <- function() {
[11:01:43.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.272]                       search = base::search(), system = base::Sys.info())
[11:01:43.272]                   }
[11:01:43.272]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.272]                     cond$call), session = sessionInformation(), 
[11:01:43.272]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.272]                   signalCondition(cond)
[11:01:43.272]                 }
[11:01:43.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.272]                 "immediateCondition"))) {
[11:01:43.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.272]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.272]                   if (TRUE && !signal) {
[11:01:43.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.272]                     {
[11:01:43.272]                       inherits <- base::inherits
[11:01:43.272]                       invokeRestart <- base::invokeRestart
[11:01:43.272]                       is.null <- base::is.null
[11:01:43.272]                       muffled <- FALSE
[11:01:43.272]                       if (inherits(cond, "message")) {
[11:01:43.272]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.272]                         if (muffled) 
[11:01:43.272]                           invokeRestart("muffleMessage")
[11:01:43.272]                       }
[11:01:43.272]                       else if (inherits(cond, "warning")) {
[11:01:43.272]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.272]                         if (muffled) 
[11:01:43.272]                           invokeRestart("muffleWarning")
[11:01:43.272]                       }
[11:01:43.272]                       else if (inherits(cond, "condition")) {
[11:01:43.272]                         if (!is.null(pattern)) {
[11:01:43.272]                           computeRestarts <- base::computeRestarts
[11:01:43.272]                           grepl <- base::grepl
[11:01:43.272]                           restarts <- computeRestarts(cond)
[11:01:43.272]                           for (restart in restarts) {
[11:01:43.272]                             name <- restart$name
[11:01:43.272]                             if (is.null(name)) 
[11:01:43.272]                               next
[11:01:43.272]                             if (!grepl(pattern, name)) 
[11:01:43.272]                               next
[11:01:43.272]                             invokeRestart(restart)
[11:01:43.272]                             muffled <- TRUE
[11:01:43.272]                             break
[11:01:43.272]                           }
[11:01:43.272]                         }
[11:01:43.272]                       }
[11:01:43.272]                       invisible(muffled)
[11:01:43.272]                     }
[11:01:43.272]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.272]                   }
[11:01:43.272]                 }
[11:01:43.272]                 else {
[11:01:43.272]                   if (TRUE) {
[11:01:43.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.272]                     {
[11:01:43.272]                       inherits <- base::inherits
[11:01:43.272]                       invokeRestart <- base::invokeRestart
[11:01:43.272]                       is.null <- base::is.null
[11:01:43.272]                       muffled <- FALSE
[11:01:43.272]                       if (inherits(cond, "message")) {
[11:01:43.272]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.272]                         if (muffled) 
[11:01:43.272]                           invokeRestart("muffleMessage")
[11:01:43.272]                       }
[11:01:43.272]                       else if (inherits(cond, "warning")) {
[11:01:43.272]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.272]                         if (muffled) 
[11:01:43.272]                           invokeRestart("muffleWarning")
[11:01:43.272]                       }
[11:01:43.272]                       else if (inherits(cond, "condition")) {
[11:01:43.272]                         if (!is.null(pattern)) {
[11:01:43.272]                           computeRestarts <- base::computeRestarts
[11:01:43.272]                           grepl <- base::grepl
[11:01:43.272]                           restarts <- computeRestarts(cond)
[11:01:43.272]                           for (restart in restarts) {
[11:01:43.272]                             name <- restart$name
[11:01:43.272]                             if (is.null(name)) 
[11:01:43.272]                               next
[11:01:43.272]                             if (!grepl(pattern, name)) 
[11:01:43.272]                               next
[11:01:43.272]                             invokeRestart(restart)
[11:01:43.272]                             muffled <- TRUE
[11:01:43.272]                             break
[11:01:43.272]                           }
[11:01:43.272]                         }
[11:01:43.272]                       }
[11:01:43.272]                       invisible(muffled)
[11:01:43.272]                     }
[11:01:43.272]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.272]                   }
[11:01:43.272]                 }
[11:01:43.272]             }
[11:01:43.272]         }))
[11:01:43.272]     }, error = function(ex) {
[11:01:43.272]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.272]                 ...future.rng), started = ...future.startTime, 
[11:01:43.272]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.272]             version = "1.8"), class = "FutureResult")
[11:01:43.272]     }, finally = {
[11:01:43.272]         if (!identical(...future.workdir, getwd())) 
[11:01:43.272]             setwd(...future.workdir)
[11:01:43.272]         {
[11:01:43.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.272]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.272]             }
[11:01:43.272]             base::options(...future.oldOptions)
[11:01:43.272]             if (.Platform$OS.type == "windows") {
[11:01:43.272]                 old_names <- names(...future.oldEnvVars)
[11:01:43.272]                 envs <- base::Sys.getenv()
[11:01:43.272]                 names <- names(envs)
[11:01:43.272]                 common <- intersect(names, old_names)
[11:01:43.272]                 added <- setdiff(names, old_names)
[11:01:43.272]                 removed <- setdiff(old_names, names)
[11:01:43.272]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.272]                   envs[common]]
[11:01:43.272]                 NAMES <- toupper(changed)
[11:01:43.272]                 args <- list()
[11:01:43.272]                 for (kk in seq_along(NAMES)) {
[11:01:43.272]                   name <- changed[[kk]]
[11:01:43.272]                   NAME <- NAMES[[kk]]
[11:01:43.272]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.272]                     next
[11:01:43.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.272]                 }
[11:01:43.272]                 NAMES <- toupper(added)
[11:01:43.272]                 for (kk in seq_along(NAMES)) {
[11:01:43.272]                   name <- added[[kk]]
[11:01:43.272]                   NAME <- NAMES[[kk]]
[11:01:43.272]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.272]                     next
[11:01:43.272]                   args[[name]] <- ""
[11:01:43.272]                 }
[11:01:43.272]                 NAMES <- toupper(removed)
[11:01:43.272]                 for (kk in seq_along(NAMES)) {
[11:01:43.272]                   name <- removed[[kk]]
[11:01:43.272]                   NAME <- NAMES[[kk]]
[11:01:43.272]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.272]                     next
[11:01:43.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.272]                 }
[11:01:43.272]                 if (length(args) > 0) 
[11:01:43.272]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.272]             }
[11:01:43.272]             else {
[11:01:43.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.272]             }
[11:01:43.272]             {
[11:01:43.272]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.272]                   0L) {
[11:01:43.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.272]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.272]                   base::options(opts)
[11:01:43.272]                 }
[11:01:43.272]                 {
[11:01:43.272]                   {
[11:01:43.272]                     NULL
[11:01:43.272]                     RNGkind("Mersenne-Twister")
[11:01:43.272]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:43.272]                       inherits = FALSE)
[11:01:43.272]                   }
[11:01:43.272]                   options(future.plan = NULL)
[11:01:43.272]                   if (is.na(NA_character_)) 
[11:01:43.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.272]                     .init = FALSE)
[11:01:43.272]                 }
[11:01:43.272]             }
[11:01:43.272]         }
[11:01:43.272]     })
[11:01:43.272]     if (TRUE) {
[11:01:43.272]         base::sink(type = "output", split = FALSE)
[11:01:43.272]         if (TRUE) {
[11:01:43.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.272]         }
[11:01:43.272]         else {
[11:01:43.272]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.272]         }
[11:01:43.272]         base::close(...future.stdout)
[11:01:43.272]         ...future.stdout <- NULL
[11:01:43.272]     }
[11:01:43.272]     ...future.result$conditions <- ...future.conditions
[11:01:43.272]     ...future.result$finished <- base::Sys.time()
[11:01:43.272]     ...future.result
[11:01:43.272] }
[11:01:43.274] assign_globals() ...
[11:01:43.274] List of 1
[11:01:43.274]  $ data:'data.frame':	5 obs. of  2 variables:
[11:01:43.274]   ..$ x: int [1:5] 1 2 3 4 5
[11:01:43.274]   ..$ y: int [1:5] 1 2 3 4 5
[11:01:43.274]  - attr(*, "where")=List of 1
[11:01:43.274]   ..$ data:<environment: R_EmptyEnv> 
[11:01:43.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:43.274]  - attr(*, "resolved")= logi FALSE
[11:01:43.274]  - attr(*, "total_size")= num 356
[11:01:43.274]  - attr(*, "already-done")= logi TRUE
[11:01:43.280] - copied ‘data’ to environment
[11:01:43.280] assign_globals() ... done
[11:01:43.281] plan(): Setting new future strategy stack:
[11:01:43.281] List of future strategies:
[11:01:43.281] 1. multicore:
[11:01:43.281]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:43.281]    - tweaked: FALSE
[11:01:43.281]    - call: plan(list(sequential, strategy))
[11:01:43.283] plan(): nbrOfWorkers() = 2
[11:01:43.323] plan(): Setting new future strategy stack:
[11:01:43.324] List of future strategies:
[11:01:43.324] 1. sequential:
[11:01:43.324]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.324]    - tweaked: FALSE
[11:01:43.324]    - call: plan(list(sequential, strategy))
[11:01:43.324] 2. multicore:
[11:01:43.324]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:43.324]    - tweaked: FALSE
[11:01:43.324]    - call: plan(list(sequential, strategy))
[11:01:43.324] plan(): nbrOfWorkers() = 1
[11:01:43.325] SequentialFuture started (and completed)
[11:01:43.325] signalConditions() ...
[11:01:43.325]  - include = ‘immediateCondition’
[11:01:43.325]  - exclude = 
[11:01:43.325]  - resignal = FALSE
[11:01:43.325]  - Number of conditions: 56
[11:01:43.325] signalConditions() ... done
[11:01:43.325] - Launch lazy future ... done
[11:01:43.326] run() for ‘SequentialFuture’ ... done
[11:01:43.326] signalConditions() ...
[11:01:43.326]  - include = ‘immediateCondition’
[11:01:43.326]  - exclude = 
[11:01:43.326]  - resignal = FALSE
[11:01:43.326]  - Number of conditions: 56
[11:01:43.326] signalConditions() ... done
[11:01:43.326] Future state: ‘finished’
[11:01:43.327] signalConditions() ...
[11:01:43.327]  - include = ‘condition’
[11:01:43.327]  - exclude = ‘immediateCondition’
[11:01:43.327]  - resignal = TRUE
[11:01:43.327]  - Number of conditions: 56
[11:01:43.327]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.283] getGlobalsAndPackages() ...
[11:01:43.327]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.327]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.298] Searching for globals...
[11:01:43.328]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.300] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[11:01:43.328]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.300] Searching for globals ... DONE
[11:01:43.328]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.300] Resolving globals: FALSE
[11:01:43.328]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.300] The total size of the 1 globals is 356 bytes (356 bytes)
[11:01:43.328]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.301] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:01:43.328]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.301] - globals: [1] ‘data’
[11:01:43.328]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.301] 
[11:01:43.329]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.301] getGlobalsAndPackages() ... DONE
[11:01:43.329]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.301] run() for ‘Future’ ...
[11:01:43.329]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.301] - state: ‘created’
[11:01:43.329]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.301] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:43.329]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.303] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:43.329]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.303] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:43.329]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.303]   - Field: ‘label’
[11:01:43.330]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.303]   - Field: ‘local’
[11:01:43.330]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.303]   - Field: ‘owner’
[11:01:43.330]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.304]   - Field: ‘envir’
[11:01:43.330]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.304]   - Field: ‘workers’
[11:01:43.330]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.304]   - Field: ‘packages’
[11:01:43.330]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.304]   - Field: ‘gc’
[11:01:43.330]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.304]   - Field: ‘job’
[11:01:43.331]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.304]   - Field: ‘conditions’
[11:01:43.331]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.304]   - Field: ‘expr’
[11:01:43.331]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.304]   - Field: ‘uuid’
[11:01:43.331]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.304]   - Field: ‘seed’
[11:01:43.331]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.304]   - Field: ‘version’
[11:01:43.331]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.305]   - Field: ‘result’
[11:01:43.331]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.305]   - Field: ‘asynchronous’
[11:01:43.332]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.305]   - Field: ‘calls’
[11:01:43.332]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.305]   - Field: ‘globals’
[11:01:43.332]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.305]   - Field: ‘stdout’
[11:01:43.332]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.305]   - Field: ‘earlySignal’
[11:01:43.332]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.305]   - Field: ‘lazy’
[11:01:43.332]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.305]   - Field: ‘state’
[11:01:43.332]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:43.333]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.305] - Launch lazy future ...
[11:01:43.333]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.306] Packages needed by the future expression (n = 0): <none>
[11:01:43.333]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.306] Packages needed by future strategies (n = 0): <none>
[11:01:43.333]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.306] {
[11:01:43.306]     {
[11:01:43.306]         {
[11:01:43.306]             ...future.startTime <- base::Sys.time()
[11:01:43.306]             {
[11:01:43.306]                 {
[11:01:43.306]                   {
[11:01:43.306]                     {
[11:01:43.306]                       base::local({
[11:01:43.306]                         has_future <- base::requireNamespace("future", 
[11:01:43.306]                           quietly = TRUE)
[11:01:43.306]                         if (has_future) {
[11:01:43.306]                           ns <- base::getNamespace("future")
[11:01:43.306]                           version <- ns[[".package"]][["version"]]
[11:01:43.306]                           if (is.null(version)) 
[11:01:43.306]                             version <- utils::packageVersion("future")
[11:01:43.306]                         }
[11:01:43.306]                         else {
[11:01:43.306]                           version <- NULL
[11:01:43.306]                         }
[11:01:43.306]                         if (!has_future || version < "1.8.0") {
[11:01:43.306]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.306]                             "", base::R.version$version.string), 
[11:01:43.306]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:43.306]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.306]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.306]                               "release", "version")], collapse = " "), 
[11:01:43.306]                             hostname = base::Sys.info()[["nodename"]])
[11:01:43.306]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.306]                             info)
[11:01:43.306]                           info <- base::paste(info, collapse = "; ")
[11:01:43.306]                           if (!has_future) {
[11:01:43.306]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.306]                               info)
[11:01:43.306]                           }
[11:01:43.306]                           else {
[11:01:43.306]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.306]                               info, version)
[11:01:43.306]                           }
[11:01:43.306]                           base::stop(msg)
[11:01:43.306]                         }
[11:01:43.306]                       })
[11:01:43.306]                     }
[11:01:43.306]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:43.306]                     base::options(mc.cores = 1L)
[11:01:43.306]                   }
[11:01:43.306]                   ...future.strategy.old <- future::plan("list")
[11:01:43.306]                   options(future.plan = NULL)
[11:01:43.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:43.306]                 }
[11:01:43.306]                 ...future.workdir <- getwd()
[11:01:43.306]             }
[11:01:43.306]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.306]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.306]         }
[11:01:43.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.306]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.306]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.306]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.306]             base::names(...future.oldOptions))
[11:01:43.306]     }
[11:01:43.306]     if (FALSE) {
[11:01:43.306]     }
[11:01:43.306]     else {
[11:01:43.306]         if (TRUE) {
[11:01:43.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.306]                 open = "w")
[11:01:43.306]         }
[11:01:43.306]         else {
[11:01:43.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.306]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.306]         }
[11:01:43.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.306]             base::sink(type = "output", split = FALSE)
[11:01:43.306]             base::close(...future.stdout)
[11:01:43.306]         }, add = TRUE)
[11:01:43.306]     }
[11:01:43.306]     ...future.frame <- base::sys.nframe()
[11:01:43.306]     ...future.conditions <- base::list()
[11:01:43.306]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.306]     if (FALSE) {
[11:01:43.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.306]     }
[11:01:43.306]     ...future.result <- base::tryCatch({
[11:01:43.306]         base::withCallingHandlers({
[11:01:43.306]             ...future.value <- base::withVisible(base::local({
[11:01:43.306]                 withCallingHandlers({
[11:01:43.306]                   subset(data, x < 3)$y
[11:01:43.306]                 }, immediateCondition = function(cond) {
[11:01:43.306]                   save_rds <- function (object, pathname, ...) 
[11:01:43.306]                   {
[11:01:43.306]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:43.306]                     if (file_test("-f", pathname_tmp)) {
[11:01:43.306]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.306]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:43.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.306]                         fi_tmp[["mtime"]])
[11:01:43.306]                     }
[11:01:43.306]                     tryCatch({
[11:01:43.306]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:43.306]                     }, error = function(ex) {
[11:01:43.306]                       msg <- conditionMessage(ex)
[11:01:43.306]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.306]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:43.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.306]                         fi_tmp[["mtime"]], msg)
[11:01:43.306]                       ex$message <- msg
[11:01:43.306]                       stop(ex)
[11:01:43.306]                     })
[11:01:43.306]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:43.306]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:43.306]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:43.306]                       fi_tmp <- file.info(pathname_tmp)
[11:01:43.306]                       fi <- file.info(pathname)
[11:01:43.306]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:43.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:43.306]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:43.306]                         fi[["size"]], fi[["mtime"]])
[11:01:43.306]                       stop(msg)
[11:01:43.306]                     }
[11:01:43.306]                     invisible(pathname)
[11:01:43.306]                   }
[11:01:43.306]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:43.306]                     rootPath = tempdir()) 
[11:01:43.306]                   {
[11:01:43.306]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:43.306]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:43.306]                       tmpdir = path, fileext = ".rds")
[11:01:43.306]                     save_rds(obj, file)
[11:01:43.306]                   }
[11:01:43.306]                   saveImmediateCondition(cond, path = "/tmp/RtmpDE64kE/.future/immediateConditions")
[11:01:43.306]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.306]                   {
[11:01:43.306]                     inherits <- base::inherits
[11:01:43.306]                     invokeRestart <- base::invokeRestart
[11:01:43.306]                     is.null <- base::is.null
[11:01:43.306]                     muffled <- FALSE
[11:01:43.306]                     if (inherits(cond, "message")) {
[11:01:43.306]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:43.306]                       if (muffled) 
[11:01:43.306]                         invokeRestart("muffleMessage")
[11:01:43.306]                     }
[11:01:43.306]                     else if (inherits(cond, "warning")) {
[11:01:43.306]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:43.306]                       if (muffled) 
[11:01:43.306]                         invokeRestart("muffleWarning")
[11:01:43.306]                     }
[11:01:43.306]                     else if (inherits(cond, "condition")) {
[11:01:43.306]                       if (!is.null(pattern)) {
[11:01:43.306]                         computeRestarts <- base::computeRestarts
[11:01:43.306]                         grepl <- base::grepl
[11:01:43.306]                         restarts <- computeRestarts(cond)
[11:01:43.306]                         for (restart in restarts) {
[11:01:43.306]                           name <- restart$name
[11:01:43.306]                           if (is.null(name)) 
[11:01:43.306]                             next
[11:01:43.306]                           if (!grepl(pattern, name)) 
[11:01:43.306]                             next
[11:01:43.306]                           invokeRestart(restart)
[11:01:43.306]                           muffled <- TRUE
[11:01:43.306]                           break
[11:01:43.306]                         }
[11:01:43.306]                       }
[11:01:43.306]                     }
[11:01:43.306]                     invisible(muffled)
[11:01:43.306]                   }
[11:01:43.306]                   muffleCondition(cond)
[11:01:43.306]                 })
[11:01:43.306]             }))
[11:01:43.306]             future::FutureResult(value = ...future.value$value, 
[11:01:43.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.306]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.306]                     ...future.globalenv.names))
[11:01:43.306]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.306]         }, condition = base::local({
[11:01:43.306]             c <- base::c
[11:01:43.306]             inherits <- base::inherits
[11:01:43.306]             invokeRestart <- base::invokeRestart
[11:01:43.306]             length <- base::length
[11:01:43.306]             list <- base::list
[11:01:43.306]             seq.int <- base::seq.int
[11:01:43.306]             signalCondition <- base::signalCondition
[11:01:43.306]             sys.calls <- base::sys.calls
[11:01:43.306]             `[[` <- base::`[[`
[11:01:43.306]             `+` <- base::`+`
[11:01:43.306]             `<<-` <- base::`<<-`
[11:01:43.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.306]                   3L)]
[11:01:43.306]             }
[11:01:43.306]             function(cond) {
[11:01:43.306]                 is_error <- inherits(cond, "error")
[11:01:43.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.306]                   NULL)
[11:01:43.306]                 if (is_error) {
[11:01:43.306]                   sessionInformation <- function() {
[11:01:43.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.306]                       search = base::search(), system = base::Sys.info())
[11:01:43.306]                   }
[11:01:43.306]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.306]                     cond$call), session = sessionInformation(), 
[11:01:43.306]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.306]                   signalCondition(cond)
[11:01:43.306]                 }
[11:01:43.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.306]                 "immediateCondition"))) {
[11:01:43.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.306]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.306]                   if (TRUE && !signal) {
[11:01:43.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.306]                     {
[11:01:43.306]                       inherits <- base::inherits
[11:01:43.306]                       invokeRestart <- base::invokeRestart
[11:01:43.306]                       is.null <- base::is.null
[11:01:43.306]                       muffled <- FALSE
[11:01:43.306]                       if (inherits(cond, "message")) {
[11:01:43.306]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.306]                         if (muffled) 
[11:01:43.306]                           invokeRestart("muffleMessage")
[11:01:43.306]                       }
[11:01:43.306]                       else if (inherits(cond, "warning")) {
[11:01:43.306]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.306]                         if (muffled) 
[11:01:43.306]                           invokeRestart("muffleWarning")
[11:01:43.306]                       }
[11:01:43.306]                       else if (inherits(cond, "condition")) {
[11:01:43.306]                         if (!is.null(pattern)) {
[11:01:43.306]                           computeRestarts <- base::computeRestarts
[11:01:43.306]                           grepl <- base::grepl
[11:01:43.306]                           restarts <- computeRestarts(cond)
[11:01:43.306]                           for (restart in restarts) {
[11:01:43.306]                             name <- restart$name
[11:01:43.306]                             if (is.null(name)) 
[11:01:43.306]                               next
[11:01:43.306]                             if (!grepl(pattern, name)) 
[11:01:43.306]                               next
[11:01:43.306]                             invokeRestart(restart)
[11:01:43.306]                             muffled <- TRUE
[11:01:43.306]                             break
[11:01:43.306]                           }
[11:01:43.306]                         }
[11:01:43.306]                       }
[11:01:43.306]                       invisible(muffled)
[11:01:43.306]                     }
[11:01:43.306]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.306]                   }
[11:01:43.306]                 }
[11:01:43.306]                 else {
[11:01:43.306]                   if (TRUE) {
[11:01:43.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.306]                     {
[11:01:43.306]                       inherits <- base::inherits
[11:01:43.306]                       invokeRestart <- base::invokeRestart
[11:01:43.306]                       is.null <- base::is.null
[11:01:43.306]                       muffled <- FALSE
[11:01:43.306]                       if (inherits(cond, "message")) {
[11:01:43.306]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.306]                         if (muffled) 
[11:01:43.306]                           invokeRestart("muffleMessage")
[11:01:43.306]                       }
[11:01:43.306]                       else if (inherits(cond, "warning")) {
[11:01:43.306]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.306]                         if (muffled) 
[11:01:43.306]                           invokeRestart("muffleWarning")
[11:01:43.306]                       }
[11:01:43.306]                       else if (inherits(cond, "condition")) {
[11:01:43.306]                         if (!is.null(pattern)) {
[11:01:43.306]                           computeRestarts <- base::computeRestarts
[11:01:43.306]                           grepl <- base::grepl
[11:01:43.306]                           restarts <- computeRestarts(cond)
[11:01:43.306]                           for (restart in restarts) {
[11:01:43.306]                             name <- restart$name
[11:01:43.306]                             if (is.null(name)) 
[11:01:43.306]                               next
[11:01:43.306]                             if (!grepl(pattern, name)) 
[11:01:43.306]                               next
[11:01:43.306]                             invokeRestart(restart)
[11:01:43.306]                             muffled <- TRUE
[11:01:43.306]                             break
[11:01:43.306]                           }
[11:01:43.306]                         }
[11:01:43.306]                       }
[11:01:43.306]                       invisible(muffled)
[11:01:43.306]                     }
[11:01:43.306]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.306]                   }
[11:01:43.306]                 }
[11:01:43.306]             }
[11:01:43.306]         }))
[11:01:43.306]     }, error = function(ex) {
[11:01:43.306]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.306]                 ...future.rng), started = ...future.startTime, 
[11:01:43.306]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.306]             version = "1.8"), class = "FutureResult")
[11:01:43.306]     }, finally = {
[11:01:43.306]         if (!identical(...future.workdir, getwd())) 
[11:01:43.306]             setwd(...future.workdir)
[11:01:43.306]         {
[11:01:43.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.306]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.306]             }
[11:01:43.306]             base::options(...future.oldOptions)
[11:01:43.306]             if (.Platform$OS.type == "windows") {
[11:01:43.306]                 old_names <- names(...future.oldEnvVars)
[11:01:43.306]                 envs <- base::Sys.getenv()
[11:01:43.306]                 names <- names(envs)
[11:01:43.306]                 common <- intersect(names, old_names)
[11:01:43.306]                 added <- setdiff(names, old_names)
[11:01:43.306]                 removed <- setdiff(old_names, names)
[11:01:43.306]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.306]                   envs[common]]
[11:01:43.306]                 NAMES <- toupper(changed)
[11:01:43.306]                 args <- list()
[11:01:43.306]                 for (kk in seq_along(NAMES)) {
[11:01:43.306]                   name <- changed[[kk]]
[11:01:43.306]                   NAME <- NAMES[[kk]]
[11:01:43.306]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.306]                     next
[11:01:43.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.306]                 }
[11:01:43.306]                 NAMES <- toupper(added)
[11:01:43.306]                 for (kk in seq_along(NAMES)) {
[11:01:43.306]                   name <- added[[kk]]
[11:01:43.306]                   NAME <- NAMES[[kk]]
[11:01:43.306]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.306]                     next
[11:01:43.306]                   args[[name]] <- ""
[11:01:43.306]                 }
[11:01:43.306]                 NAMES <- toupper(removed)
[11:01:43.306]                 for (kk in seq_along(NAMES)) {
[11:01:43.306]                   name <- removed[[kk]]
[11:01:43.306]                   NAME <- NAMES[[kk]]
[11:01:43.306]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.306]                     next
[11:01:43.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.306]                 }
[11:01:43.306]                 if (length(args) > 0) 
[11:01:43.306]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.306]             }
[11:01:43.306]             else {
[11:01:43.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.306]             }
[11:01:43.306]             {
[11:01:43.306]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.306]                   0L) {
[11:01:43.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.306]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.306]                   base::options(opts)
[11:01:43.306]                 }
[11:01:43.306]                 {
[11:01:43.306]                   {
[11:01:43.306]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:43.306]                     NULL
[11:01:43.306]                   }
[11:01:43.306]                   options(future.plan = NULL)
[11:01:43.306]                   if (is.na(NA_character_)) 
[11:01:43.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.306]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.306]                     .init = FALSE)
[11:01:43.306]                 }
[11:01:43.306]             }
[11:01:43.306]         }
[11:01:43.306]     })
[11:01:43.306]     if (TRUE) {
[11:01:43.306]         base::sink(type = "output", split = FALSE)
[11:01:43.306]         if (TRUE) {
[11:01:43.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.306]         }
[11:01:43.306]         else {
[11:01:43.306]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.306]         }
[11:01:43.306]         base::close(...future.stdout)
[11:01:43.306]         ...future.stdout <- NULL
[11:01:43.306]     }
[11:01:43.306]     ...future.result$conditions <- ...future.conditions
[11:01:43.306]     ...future.result$finished <- base::Sys.time()
[11:01:43.306]     ...future.result
[11:01:43.306] }
[11:01:43.333]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.308] assign_globals() ...
[11:01:43.334]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.308] List of 1
[11:01:43.308]  $ data:'data.frame':	5 obs. of  2 variables:
[11:01:43.308]   ..$ x: int [1:5] 1 2 3 4 5
[11:01:43.308]   ..$ y: int [1:5] 1 2 3 4 5
[11:01:43.308]  - attr(*, "where")=List of 1
[11:01:43.308]   ..$ data:<environment: R_EmptyEnv> 
[11:01:43.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:43.308]  - attr(*, "resolved")= logi FALSE
[11:01:43.308]  - attr(*, "total_size")= num 356
[11:01:43.308]  - attr(*, "already-done")= logi TRUE
[11:01:43.334]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.311] - copied ‘data’ to environment
[11:01:43.334]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.311] assign_globals() ... done
[11:01:43.334]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.312] requestCore(): workers = 2
[11:01:43.334]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.314] MulticoreFuture started
[11:01:43.334]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.314] - Launch lazy future ... done
[11:01:43.336]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.314] run() for ‘MulticoreFuture’ ... done
[11:01:43.336]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.315] result() for MulticoreFuture ...
[11:01:43.336]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.322] result() for MulticoreFuture ...
[11:01:43.337]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.322] result() for MulticoreFuture ... done
[11:01:43.337]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.322] result() for MulticoreFuture ... done
[11:01:43.337]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.323] result() for MulticoreFuture ...
[11:01:43.337]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.323] result() for MulticoreFuture ... done
[11:01:43.337] signalConditions() ... done
[11:01:43.338] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.338] Searching for globals...
[11:01:43.339] - globals found: [3] ‘{’, ‘plan’, ‘sequential’
[11:01:43.339] Searching for globals ... DONE
[11:01:43.339] Resolving globals: FALSE
[11:01:43.340] 
[11:01:43.340] - packages: [1] ‘future’
[11:01:43.340] getGlobalsAndPackages() ... DONE
[11:01:43.340] run() for ‘Future’ ...
[11:01:43.341] - state: ‘created’
[11:01:43.341] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:43.341] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:43.341] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:43.341]   - Field: ‘label’
[11:01:43.341]   - Field: ‘local’
[11:01:43.342]   - Field: ‘owner’
[11:01:43.342]   - Field: ‘envir’
[11:01:43.342]   - Field: ‘packages’
[11:01:43.342]   - Field: ‘gc’
[11:01:43.342]   - Field: ‘conditions’
[11:01:43.342]   - Field: ‘expr’
[11:01:43.342]   - Field: ‘uuid’
[11:01:43.342]   - Field: ‘seed’
[11:01:43.342]   - Field: ‘version’
[11:01:43.342]   - Field: ‘result’
[11:01:43.342]   - Field: ‘asynchronous’
[11:01:43.343]   - Field: ‘calls’
[11:01:43.343]   - Field: ‘globals’
[11:01:43.343]   - Field: ‘stdout’
[11:01:43.343]   - Field: ‘earlySignal’
[11:01:43.343]   - Field: ‘lazy’
[11:01:43.343]   - Field: ‘state’
[11:01:43.343] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:43.343] - Launch lazy future ...
[11:01:43.344] Packages needed by the future expression (n = 1): ‘future’
[11:01:43.344] Packages needed by future strategies (n = 1): ‘future’
[11:01:43.344] {
[11:01:43.344]     {
[11:01:43.344]         {
[11:01:43.344]             ...future.startTime <- base::Sys.time()
[11:01:43.344]             {
[11:01:43.344]                 {
[11:01:43.344]                   {
[11:01:43.344]                     {
[11:01:43.344]                       base::local({
[11:01:43.344]                         has_future <- base::requireNamespace("future", 
[11:01:43.344]                           quietly = TRUE)
[11:01:43.344]                         if (has_future) {
[11:01:43.344]                           ns <- base::getNamespace("future")
[11:01:43.344]                           version <- ns[[".package"]][["version"]]
[11:01:43.344]                           if (is.null(version)) 
[11:01:43.344]                             version <- utils::packageVersion("future")
[11:01:43.344]                         }
[11:01:43.344]                         else {
[11:01:43.344]                           version <- NULL
[11:01:43.344]                         }
[11:01:43.344]                         if (!has_future || version < "1.8.0") {
[11:01:43.344]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.344]                             "", base::R.version$version.string), 
[11:01:43.344]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:43.344]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.344]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.344]                               "release", "version")], collapse = " "), 
[11:01:43.344]                             hostname = base::Sys.info()[["nodename"]])
[11:01:43.344]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.344]                             info)
[11:01:43.344]                           info <- base::paste(info, collapse = "; ")
[11:01:43.344]                           if (!has_future) {
[11:01:43.344]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.344]                               info)
[11:01:43.344]                           }
[11:01:43.344]                           else {
[11:01:43.344]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.344]                               info, version)
[11:01:43.344]                           }
[11:01:43.344]                           base::stop(msg)
[11:01:43.344]                         }
[11:01:43.344]                       })
[11:01:43.344]                     }
[11:01:43.344]                     base::local({
[11:01:43.344]                       for (pkg in "future") {
[11:01:43.344]                         base::loadNamespace(pkg)
[11:01:43.344]                         base::library(pkg, character.only = TRUE)
[11:01:43.344]                       }
[11:01:43.344]                     })
[11:01:43.344]                   }
[11:01:43.344]                   ...future.strategy.old <- future::plan("list")
[11:01:43.344]                   options(future.plan = NULL)
[11:01:43.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.344]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[11:01:43.344]                     envir = parent.frame()) 
[11:01:43.344]                   {
[11:01:43.344]                     default_workers <- missing(workers)
[11:01:43.344]                     if (is.function(workers)) 
[11:01:43.344]                       workers <- workers()
[11:01:43.344]                     workers <- structure(as.integer(workers), 
[11:01:43.344]                       class = class(workers))
[11:01:43.344]                     stop_if_not(is.finite(workers), workers >= 
[11:01:43.344]                       1L)
[11:01:43.344]                     if ((workers == 1L && !inherits(workers, 
[11:01:43.344]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[11:01:43.344]                       if (default_workers) 
[11:01:43.344]                         supportsMulticore(warn = TRUE)
[11:01:43.344]                       return(sequential(..., envir = envir))
[11:01:43.344]                     }
[11:01:43.344]                     oopts <- options(mc.cores = workers)
[11:01:43.344]                     on.exit(options(oopts))
[11:01:43.344]                     future <- MulticoreFuture(..., workers = workers, 
[11:01:43.344]                       envir = envir)
[11:01:43.344]                     if (!future$lazy) 
[11:01:43.344]                       future <- run(future)
[11:01:43.344]                     invisible(future)
[11:01:43.344]                   }), .cleanup = FALSE, .init = FALSE)
[11:01:43.344]                 }
[11:01:43.344]                 ...future.workdir <- getwd()
[11:01:43.344]             }
[11:01:43.344]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.344]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.344]         }
[11:01:43.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.344]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.344]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.344]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.344]             base::names(...future.oldOptions))
[11:01:43.344]     }
[11:01:43.344]     if (FALSE) {
[11:01:43.344]     }
[11:01:43.344]     else {
[11:01:43.344]         if (TRUE) {
[11:01:43.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.344]                 open = "w")
[11:01:43.344]         }
[11:01:43.344]         else {
[11:01:43.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.344]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.344]         }
[11:01:43.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.344]             base::sink(type = "output", split = FALSE)
[11:01:43.344]             base::close(...future.stdout)
[11:01:43.344]         }, add = TRUE)
[11:01:43.344]     }
[11:01:43.344]     ...future.frame <- base::sys.nframe()
[11:01:43.344]     ...future.conditions <- base::list()
[11:01:43.344]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.344]     if (FALSE) {
[11:01:43.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.344]     }
[11:01:43.344]     ...future.result <- base::tryCatch({
[11:01:43.344]         base::withCallingHandlers({
[11:01:43.344]             ...future.value <- base::withVisible(base::local({
[11:01:43.344]                 plan(sequential)
[11:01:43.344]             }))
[11:01:43.344]             future::FutureResult(value = ...future.value$value, 
[11:01:43.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.344]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.344]                     ...future.globalenv.names))
[11:01:43.344]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.344]         }, condition = base::local({
[11:01:43.344]             c <- base::c
[11:01:43.344]             inherits <- base::inherits
[11:01:43.344]             invokeRestart <- base::invokeRestart
[11:01:43.344]             length <- base::length
[11:01:43.344]             list <- base::list
[11:01:43.344]             seq.int <- base::seq.int
[11:01:43.344]             signalCondition <- base::signalCondition
[11:01:43.344]             sys.calls <- base::sys.calls
[11:01:43.344]             `[[` <- base::`[[`
[11:01:43.344]             `+` <- base::`+`
[11:01:43.344]             `<<-` <- base::`<<-`
[11:01:43.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.344]                   3L)]
[11:01:43.344]             }
[11:01:43.344]             function(cond) {
[11:01:43.344]                 is_error <- inherits(cond, "error")
[11:01:43.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.344]                   NULL)
[11:01:43.344]                 if (is_error) {
[11:01:43.344]                   sessionInformation <- function() {
[11:01:43.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.344]                       search = base::search(), system = base::Sys.info())
[11:01:43.344]                   }
[11:01:43.344]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.344]                     cond$call), session = sessionInformation(), 
[11:01:43.344]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.344]                   signalCondition(cond)
[11:01:43.344]                 }
[11:01:43.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.344]                 "immediateCondition"))) {
[11:01:43.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.344]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.344]                   if (TRUE && !signal) {
[11:01:43.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.344]                     {
[11:01:43.344]                       inherits <- base::inherits
[11:01:43.344]                       invokeRestart <- base::invokeRestart
[11:01:43.344]                       is.null <- base::is.null
[11:01:43.344]                       muffled <- FALSE
[11:01:43.344]                       if (inherits(cond, "message")) {
[11:01:43.344]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.344]                         if (muffled) 
[11:01:43.344]                           invokeRestart("muffleMessage")
[11:01:43.344]                       }
[11:01:43.344]                       else if (inherits(cond, "warning")) {
[11:01:43.344]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.344]                         if (muffled) 
[11:01:43.344]                           invokeRestart("muffleWarning")
[11:01:43.344]                       }
[11:01:43.344]                       else if (inherits(cond, "condition")) {
[11:01:43.344]                         if (!is.null(pattern)) {
[11:01:43.344]                           computeRestarts <- base::computeRestarts
[11:01:43.344]                           grepl <- base::grepl
[11:01:43.344]                           restarts <- computeRestarts(cond)
[11:01:43.344]                           for (restart in restarts) {
[11:01:43.344]                             name <- restart$name
[11:01:43.344]                             if (is.null(name)) 
[11:01:43.344]                               next
[11:01:43.344]                             if (!grepl(pattern, name)) 
[11:01:43.344]                               next
[11:01:43.344]                             invokeRestart(restart)
[11:01:43.344]                             muffled <- TRUE
[11:01:43.344]                             break
[11:01:43.344]                           }
[11:01:43.344]                         }
[11:01:43.344]                       }
[11:01:43.344]                       invisible(muffled)
[11:01:43.344]                     }
[11:01:43.344]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.344]                   }
[11:01:43.344]                 }
[11:01:43.344]                 else {
[11:01:43.344]                   if (TRUE) {
[11:01:43.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.344]                     {
[11:01:43.344]                       inherits <- base::inherits
[11:01:43.344]                       invokeRestart <- base::invokeRestart
[11:01:43.344]                       is.null <- base::is.null
[11:01:43.344]                       muffled <- FALSE
[11:01:43.344]                       if (inherits(cond, "message")) {
[11:01:43.344]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.344]                         if (muffled) 
[11:01:43.344]                           invokeRestart("muffleMessage")
[11:01:43.344]                       }
[11:01:43.344]                       else if (inherits(cond, "warning")) {
[11:01:43.344]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.344]                         if (muffled) 
[11:01:43.344]                           invokeRestart("muffleWarning")
[11:01:43.344]                       }
[11:01:43.344]                       else if (inherits(cond, "condition")) {
[11:01:43.344]                         if (!is.null(pattern)) {
[11:01:43.344]                           computeRestarts <- base::computeRestarts
[11:01:43.344]                           grepl <- base::grepl
[11:01:43.344]                           restarts <- computeRestarts(cond)
[11:01:43.344]                           for (restart in restarts) {
[11:01:43.344]                             name <- restart$name
[11:01:43.344]                             if (is.null(name)) 
[11:01:43.344]                               next
[11:01:43.344]                             if (!grepl(pattern, name)) 
[11:01:43.344]                               next
[11:01:43.344]                             invokeRestart(restart)
[11:01:43.344]                             muffled <- TRUE
[11:01:43.344]                             break
[11:01:43.344]                           }
[11:01:43.344]                         }
[11:01:43.344]                       }
[11:01:43.344]                       invisible(muffled)
[11:01:43.344]                     }
[11:01:43.344]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.344]                   }
[11:01:43.344]                 }
[11:01:43.344]             }
[11:01:43.344]         }))
[11:01:43.344]     }, error = function(ex) {
[11:01:43.344]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.344]                 ...future.rng), started = ...future.startTime, 
[11:01:43.344]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.344]             version = "1.8"), class = "FutureResult")
[11:01:43.344]     }, finally = {
[11:01:43.344]         if (!identical(...future.workdir, getwd())) 
[11:01:43.344]             setwd(...future.workdir)
[11:01:43.344]         {
[11:01:43.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.344]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.344]             }
[11:01:43.344]             base::options(...future.oldOptions)
[11:01:43.344]             if (.Platform$OS.type == "windows") {
[11:01:43.344]                 old_names <- names(...future.oldEnvVars)
[11:01:43.344]                 envs <- base::Sys.getenv()
[11:01:43.344]                 names <- names(envs)
[11:01:43.344]                 common <- intersect(names, old_names)
[11:01:43.344]                 added <- setdiff(names, old_names)
[11:01:43.344]                 removed <- setdiff(old_names, names)
[11:01:43.344]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.344]                   envs[common]]
[11:01:43.344]                 NAMES <- toupper(changed)
[11:01:43.344]                 args <- list()
[11:01:43.344]                 for (kk in seq_along(NAMES)) {
[11:01:43.344]                   name <- changed[[kk]]
[11:01:43.344]                   NAME <- NAMES[[kk]]
[11:01:43.344]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.344]                     next
[11:01:43.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.344]                 }
[11:01:43.344]                 NAMES <- toupper(added)
[11:01:43.344]                 for (kk in seq_along(NAMES)) {
[11:01:43.344]                   name <- added[[kk]]
[11:01:43.344]                   NAME <- NAMES[[kk]]
[11:01:43.344]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.344]                     next
[11:01:43.344]                   args[[name]] <- ""
[11:01:43.344]                 }
[11:01:43.344]                 NAMES <- toupper(removed)
[11:01:43.344]                 for (kk in seq_along(NAMES)) {
[11:01:43.344]                   name <- removed[[kk]]
[11:01:43.344]                   NAME <- NAMES[[kk]]
[11:01:43.344]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.344]                     next
[11:01:43.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.344]                 }
[11:01:43.344]                 if (length(args) > 0) 
[11:01:43.344]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.344]             }
[11:01:43.344]             else {
[11:01:43.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.344]             }
[11:01:43.344]             {
[11:01:43.344]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.344]                   0L) {
[11:01:43.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.344]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.344]                   base::options(opts)
[11:01:43.344]                 }
[11:01:43.344]                 {
[11:01:43.344]                   {
[11:01:43.344]                     NULL
[11:01:43.344]                     RNGkind("Mersenne-Twister")
[11:01:43.344]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:43.344]                       inherits = FALSE)
[11:01:43.344]                   }
[11:01:43.344]                   options(future.plan = NULL)
[11:01:43.344]                   if (is.na(NA_character_)) 
[11:01:43.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.344]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.344]                     .init = FALSE)
[11:01:43.344]                 }
[11:01:43.344]             }
[11:01:43.344]         }
[11:01:43.344]     })
[11:01:43.344]     if (TRUE) {
[11:01:43.344]         base::sink(type = "output", split = FALSE)
[11:01:43.344]         if (TRUE) {
[11:01:43.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.344]         }
[11:01:43.344]         else {
[11:01:43.344]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.344]         }
[11:01:43.344]         base::close(...future.stdout)
[11:01:43.344]         ...future.stdout <- NULL
[11:01:43.344]     }
[11:01:43.344]     ...future.result$conditions <- ...future.conditions
[11:01:43.344]     ...future.result$finished <- base::Sys.time()
[11:01:43.344]     ...future.result
[11:01:43.344] }
[11:01:43.347] plan(): Setting new future strategy stack:
[11:01:43.347] List of future strategies:
[11:01:43.347] 1. multicore:
[11:01:43.347]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:43.347]    - tweaked: FALSE
[11:01:43.347]    - call: plan(list(sequential, strategy))
[11:01:43.348] plan(): nbrOfWorkers() = 2
[11:01:43.364] plan(): Setting new future strategy stack:
[11:01:43.364] List of future strategies:
[11:01:43.364] 1. sequential:
[11:01:43.364]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.364]    - tweaked: FALSE
[11:01:43.364]    - call: plan(list(sequential, strategy))
[11:01:43.364] 2. multicore:
[11:01:43.364]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:43.364]    - tweaked: FALSE
[11:01:43.364]    - call: plan(list(sequential, strategy))
[11:01:43.365] plan(): nbrOfWorkers() = 1
[11:01:43.365] SequentialFuture started (and completed)
[11:01:43.365] signalConditions() ...
[11:01:43.365]  - include = ‘immediateCondition’
[11:01:43.365]  - exclude = 
[11:01:43.366]  - resignal = FALSE
[11:01:43.366]  - Number of conditions: 3
[11:01:43.366] signalConditions() ... done
[11:01:43.366] - Launch lazy future ... done
[11:01:43.366] run() for ‘SequentialFuture’ ... done
[11:01:43.366] signalConditions() ...
[11:01:43.366]  - include = ‘immediateCondition’
[11:01:43.366]  - exclude = 
[11:01:43.366]  - resignal = FALSE
[11:01:43.366]  - Number of conditions: 3
[11:01:43.366] signalConditions() ... done
[11:01:43.367] Future state: ‘finished’
[11:01:43.367] signalConditions() ...
[11:01:43.367]  - include = ‘condition’
[11:01:43.367]  - exclude = ‘immediateCondition’
[11:01:43.367]  - resignal = TRUE
[11:01:43.367]  - Number of conditions: 3
[11:01:43.367]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.349] plan(): Setting new future strategy stack:
[11:01:43.367]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.349] List of future strategies:
[11:01:43.349] 1. sequential:
[11:01:43.349]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:43.349]    - tweaked: FALSE
[11:01:43.349]    - call: plan(sequential)
[11:01:43.367]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:43.364] plan(): nbrOfWorkers() = 1
[11:01:43.367] signalConditions() ... done
List of future strategies:
1. multicore:
   - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
   - tweaked: FALSE
   - call: plan(list(sequential, strategy))
- Strategy: multicore ... DONE
- Strategy: multisession ...
[11:01:43.368] plan(): Setting new future strategy stack:
[11:01:43.368] List of future strategies:
[11:01:43.368] 1. multisession:
[11:01:43.368]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:43.368]    - tweaked: FALSE
[11:01:43.368]    - call: plan(strategy)
[11:01:43.368] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:01:43.368] multisession:
[11:01:43.368] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:43.368] - tweaked: FALSE
[11:01:43.368] - call: plan(strategy)
[11:01:43.372] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:43.372] Not searching for globals
[11:01:43.372] - globals: [0] <none>
[11:01:43.372] getGlobalsAndPackages() ... DONE
[11:01:43.850] Packages needed by the future expression (n = 0): <none>
[11:01:43.850] Packages needed by future strategies (n = 0): <none>
[11:01:43.851] {
[11:01:43.851]     {
[11:01:43.851]         {
[11:01:43.851]             ...future.startTime <- base::Sys.time()
[11:01:43.851]             {
[11:01:43.851]                 {
[11:01:43.851]                   {
[11:01:43.851]                     {
[11:01:43.851]                       base::local({
[11:01:43.851]                         has_future <- base::requireNamespace("future", 
[11:01:43.851]                           quietly = TRUE)
[11:01:43.851]                         if (has_future) {
[11:01:43.851]                           ns <- base::getNamespace("future")
[11:01:43.851]                           version <- ns[[".package"]][["version"]]
[11:01:43.851]                           if (is.null(version)) 
[11:01:43.851]                             version <- utils::packageVersion("future")
[11:01:43.851]                         }
[11:01:43.851]                         else {
[11:01:43.851]                           version <- NULL
[11:01:43.851]                         }
[11:01:43.851]                         if (!has_future || version < "1.8.0") {
[11:01:43.851]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.851]                             "", base::R.version$version.string), 
[11:01:43.851]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:43.851]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.851]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.851]                               "release", "version")], collapse = " "), 
[11:01:43.851]                             hostname = base::Sys.info()[["nodename"]])
[11:01:43.851]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.851]                             info)
[11:01:43.851]                           info <- base::paste(info, collapse = "; ")
[11:01:43.851]                           if (!has_future) {
[11:01:43.851]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.851]                               info)
[11:01:43.851]                           }
[11:01:43.851]                           else {
[11:01:43.851]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.851]                               info, version)
[11:01:43.851]                           }
[11:01:43.851]                           base::stop(msg)
[11:01:43.851]                         }
[11:01:43.851]                       })
[11:01:43.851]                     }
[11:01:43.851]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:43.851]                     base::options(mc.cores = 1L)
[11:01:43.851]                   }
[11:01:43.851]                   ...future.strategy.old <- future::plan("list")
[11:01:43.851]                   options(future.plan = NULL)
[11:01:43.851]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.851]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:43.851]                 }
[11:01:43.851]                 ...future.workdir <- getwd()
[11:01:43.851]             }
[11:01:43.851]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.851]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.851]         }
[11:01:43.851]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:43.851]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.851]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:43.851]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.851]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.851]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.851]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.851]             base::names(...future.oldOptions))
[11:01:43.851]     }
[11:01:43.851]     if (FALSE) {
[11:01:43.851]     }
[11:01:43.851]     else {
[11:01:43.851]         if (TRUE) {
[11:01:43.851]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.851]                 open = "w")
[11:01:43.851]         }
[11:01:43.851]         else {
[11:01:43.851]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.851]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.851]         }
[11:01:43.851]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.851]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.851]             base::sink(type = "output", split = FALSE)
[11:01:43.851]             base::close(...future.stdout)
[11:01:43.851]         }, add = TRUE)
[11:01:43.851]     }
[11:01:43.851]     ...future.frame <- base::sys.nframe()
[11:01:43.851]     ...future.conditions <- base::list()
[11:01:43.851]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.851]     if (FALSE) {
[11:01:43.851]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.851]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.851]     }
[11:01:43.851]     ...future.result <- base::tryCatch({
[11:01:43.851]         base::withCallingHandlers({
[11:01:43.851]             ...future.value <- base::withVisible(base::local({
[11:01:43.851]                 ...future.makeSendCondition <- base::local({
[11:01:43.851]                   sendCondition <- NULL
[11:01:43.851]                   function(frame = 1L) {
[11:01:43.851]                     if (is.function(sendCondition)) 
[11:01:43.851]                       return(sendCondition)
[11:01:43.851]                     ns <- getNamespace("parallel")
[11:01:43.851]                     if (exists("sendData", mode = "function", 
[11:01:43.851]                       envir = ns)) {
[11:01:43.851]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:43.851]                         envir = ns)
[11:01:43.851]                       envir <- sys.frame(frame)
[11:01:43.851]                       master <- NULL
[11:01:43.851]                       while (!identical(envir, .GlobalEnv) && 
[11:01:43.851]                         !identical(envir, emptyenv())) {
[11:01:43.851]                         if (exists("master", mode = "list", envir = envir, 
[11:01:43.851]                           inherits = FALSE)) {
[11:01:43.851]                           master <- get("master", mode = "list", 
[11:01:43.851]                             envir = envir, inherits = FALSE)
[11:01:43.851]                           if (inherits(master, c("SOCKnode", 
[11:01:43.851]                             "SOCK0node"))) {
[11:01:43.851]                             sendCondition <<- function(cond) {
[11:01:43.851]                               data <- list(type = "VALUE", value = cond, 
[11:01:43.851]                                 success = TRUE)
[11:01:43.851]                               parallel_sendData(master, data)
[11:01:43.851]                             }
[11:01:43.851]                             return(sendCondition)
[11:01:43.851]                           }
[11:01:43.851]                         }
[11:01:43.851]                         frame <- frame + 1L
[11:01:43.851]                         envir <- sys.frame(frame)
[11:01:43.851]                       }
[11:01:43.851]                     }
[11:01:43.851]                     sendCondition <<- function(cond) NULL
[11:01:43.851]                   }
[11:01:43.851]                 })
[11:01:43.851]                 withCallingHandlers({
[11:01:43.851]                   NA
[11:01:43.851]                 }, immediateCondition = function(cond) {
[11:01:43.851]                   sendCondition <- ...future.makeSendCondition()
[11:01:43.851]                   sendCondition(cond)
[11:01:43.851]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.851]                   {
[11:01:43.851]                     inherits <- base::inherits
[11:01:43.851]                     invokeRestart <- base::invokeRestart
[11:01:43.851]                     is.null <- base::is.null
[11:01:43.851]                     muffled <- FALSE
[11:01:43.851]                     if (inherits(cond, "message")) {
[11:01:43.851]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:43.851]                       if (muffled) 
[11:01:43.851]                         invokeRestart("muffleMessage")
[11:01:43.851]                     }
[11:01:43.851]                     else if (inherits(cond, "warning")) {
[11:01:43.851]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:43.851]                       if (muffled) 
[11:01:43.851]                         invokeRestart("muffleWarning")
[11:01:43.851]                     }
[11:01:43.851]                     else if (inherits(cond, "condition")) {
[11:01:43.851]                       if (!is.null(pattern)) {
[11:01:43.851]                         computeRestarts <- base::computeRestarts
[11:01:43.851]                         grepl <- base::grepl
[11:01:43.851]                         restarts <- computeRestarts(cond)
[11:01:43.851]                         for (restart in restarts) {
[11:01:43.851]                           name <- restart$name
[11:01:43.851]                           if (is.null(name)) 
[11:01:43.851]                             next
[11:01:43.851]                           if (!grepl(pattern, name)) 
[11:01:43.851]                             next
[11:01:43.851]                           invokeRestart(restart)
[11:01:43.851]                           muffled <- TRUE
[11:01:43.851]                           break
[11:01:43.851]                         }
[11:01:43.851]                       }
[11:01:43.851]                     }
[11:01:43.851]                     invisible(muffled)
[11:01:43.851]                   }
[11:01:43.851]                   muffleCondition(cond)
[11:01:43.851]                 })
[11:01:43.851]             }))
[11:01:43.851]             future::FutureResult(value = ...future.value$value, 
[11:01:43.851]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.851]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.851]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.851]                     ...future.globalenv.names))
[11:01:43.851]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.851]         }, condition = base::local({
[11:01:43.851]             c <- base::c
[11:01:43.851]             inherits <- base::inherits
[11:01:43.851]             invokeRestart <- base::invokeRestart
[11:01:43.851]             length <- base::length
[11:01:43.851]             list <- base::list
[11:01:43.851]             seq.int <- base::seq.int
[11:01:43.851]             signalCondition <- base::signalCondition
[11:01:43.851]             sys.calls <- base::sys.calls
[11:01:43.851]             `[[` <- base::`[[`
[11:01:43.851]             `+` <- base::`+`
[11:01:43.851]             `<<-` <- base::`<<-`
[11:01:43.851]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.851]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.851]                   3L)]
[11:01:43.851]             }
[11:01:43.851]             function(cond) {
[11:01:43.851]                 is_error <- inherits(cond, "error")
[11:01:43.851]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.851]                   NULL)
[11:01:43.851]                 if (is_error) {
[11:01:43.851]                   sessionInformation <- function() {
[11:01:43.851]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.851]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.851]                       search = base::search(), system = base::Sys.info())
[11:01:43.851]                   }
[11:01:43.851]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.851]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.851]                     cond$call), session = sessionInformation(), 
[11:01:43.851]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.851]                   signalCondition(cond)
[11:01:43.851]                 }
[11:01:43.851]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.851]                 "immediateCondition"))) {
[11:01:43.851]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.851]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.851]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.851]                   if (TRUE && !signal) {
[11:01:43.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.851]                     {
[11:01:43.851]                       inherits <- base::inherits
[11:01:43.851]                       invokeRestart <- base::invokeRestart
[11:01:43.851]                       is.null <- base::is.null
[11:01:43.851]                       muffled <- FALSE
[11:01:43.851]                       if (inherits(cond, "message")) {
[11:01:43.851]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.851]                         if (muffled) 
[11:01:43.851]                           invokeRestart("muffleMessage")
[11:01:43.851]                       }
[11:01:43.851]                       else if (inherits(cond, "warning")) {
[11:01:43.851]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.851]                         if (muffled) 
[11:01:43.851]                           invokeRestart("muffleWarning")
[11:01:43.851]                       }
[11:01:43.851]                       else if (inherits(cond, "condition")) {
[11:01:43.851]                         if (!is.null(pattern)) {
[11:01:43.851]                           computeRestarts <- base::computeRestarts
[11:01:43.851]                           grepl <- base::grepl
[11:01:43.851]                           restarts <- computeRestarts(cond)
[11:01:43.851]                           for (restart in restarts) {
[11:01:43.851]                             name <- restart$name
[11:01:43.851]                             if (is.null(name)) 
[11:01:43.851]                               next
[11:01:43.851]                             if (!grepl(pattern, name)) 
[11:01:43.851]                               next
[11:01:43.851]                             invokeRestart(restart)
[11:01:43.851]                             muffled <- TRUE
[11:01:43.851]                             break
[11:01:43.851]                           }
[11:01:43.851]                         }
[11:01:43.851]                       }
[11:01:43.851]                       invisible(muffled)
[11:01:43.851]                     }
[11:01:43.851]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.851]                   }
[11:01:43.851]                 }
[11:01:43.851]                 else {
[11:01:43.851]                   if (TRUE) {
[11:01:43.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.851]                     {
[11:01:43.851]                       inherits <- base::inherits
[11:01:43.851]                       invokeRestart <- base::invokeRestart
[11:01:43.851]                       is.null <- base::is.null
[11:01:43.851]                       muffled <- FALSE
[11:01:43.851]                       if (inherits(cond, "message")) {
[11:01:43.851]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.851]                         if (muffled) 
[11:01:43.851]                           invokeRestart("muffleMessage")
[11:01:43.851]                       }
[11:01:43.851]                       else if (inherits(cond, "warning")) {
[11:01:43.851]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.851]                         if (muffled) 
[11:01:43.851]                           invokeRestart("muffleWarning")
[11:01:43.851]                       }
[11:01:43.851]                       else if (inherits(cond, "condition")) {
[11:01:43.851]                         if (!is.null(pattern)) {
[11:01:43.851]                           computeRestarts <- base::computeRestarts
[11:01:43.851]                           grepl <- base::grepl
[11:01:43.851]                           restarts <- computeRestarts(cond)
[11:01:43.851]                           for (restart in restarts) {
[11:01:43.851]                             name <- restart$name
[11:01:43.851]                             if (is.null(name)) 
[11:01:43.851]                               next
[11:01:43.851]                             if (!grepl(pattern, name)) 
[11:01:43.851]                               next
[11:01:43.851]                             invokeRestart(restart)
[11:01:43.851]                             muffled <- TRUE
[11:01:43.851]                             break
[11:01:43.851]                           }
[11:01:43.851]                         }
[11:01:43.851]                       }
[11:01:43.851]                       invisible(muffled)
[11:01:43.851]                     }
[11:01:43.851]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.851]                   }
[11:01:43.851]                 }
[11:01:43.851]             }
[11:01:43.851]         }))
[11:01:43.851]     }, error = function(ex) {
[11:01:43.851]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.851]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.851]                 ...future.rng), started = ...future.startTime, 
[11:01:43.851]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.851]             version = "1.8"), class = "FutureResult")
[11:01:43.851]     }, finally = {
[11:01:43.851]         if (!identical(...future.workdir, getwd())) 
[11:01:43.851]             setwd(...future.workdir)
[11:01:43.851]         {
[11:01:43.851]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.851]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.851]             }
[11:01:43.851]             base::options(...future.oldOptions)
[11:01:43.851]             if (.Platform$OS.type == "windows") {
[11:01:43.851]                 old_names <- names(...future.oldEnvVars)
[11:01:43.851]                 envs <- base::Sys.getenv()
[11:01:43.851]                 names <- names(envs)
[11:01:43.851]                 common <- intersect(names, old_names)
[11:01:43.851]                 added <- setdiff(names, old_names)
[11:01:43.851]                 removed <- setdiff(old_names, names)
[11:01:43.851]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.851]                   envs[common]]
[11:01:43.851]                 NAMES <- toupper(changed)
[11:01:43.851]                 args <- list()
[11:01:43.851]                 for (kk in seq_along(NAMES)) {
[11:01:43.851]                   name <- changed[[kk]]
[11:01:43.851]                   NAME <- NAMES[[kk]]
[11:01:43.851]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.851]                     next
[11:01:43.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.851]                 }
[11:01:43.851]                 NAMES <- toupper(added)
[11:01:43.851]                 for (kk in seq_along(NAMES)) {
[11:01:43.851]                   name <- added[[kk]]
[11:01:43.851]                   NAME <- NAMES[[kk]]
[11:01:43.851]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.851]                     next
[11:01:43.851]                   args[[name]] <- ""
[11:01:43.851]                 }
[11:01:43.851]                 NAMES <- toupper(removed)
[11:01:43.851]                 for (kk in seq_along(NAMES)) {
[11:01:43.851]                   name <- removed[[kk]]
[11:01:43.851]                   NAME <- NAMES[[kk]]
[11:01:43.851]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.851]                     next
[11:01:43.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.851]                 }
[11:01:43.851]                 if (length(args) > 0) 
[11:01:43.851]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.851]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.851]             }
[11:01:43.851]             else {
[11:01:43.851]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.851]             }
[11:01:43.851]             {
[11:01:43.851]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.851]                   0L) {
[11:01:43.851]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.851]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.851]                   base::options(opts)
[11:01:43.851]                 }
[11:01:43.851]                 {
[11:01:43.851]                   {
[11:01:43.851]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:43.851]                     NULL
[11:01:43.851]                   }
[11:01:43.851]                   options(future.plan = NULL)
[11:01:43.851]                   if (is.na(NA_character_)) 
[11:01:43.851]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.851]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.851]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.851]                     .init = FALSE)
[11:01:43.851]                 }
[11:01:43.851]             }
[11:01:43.851]         }
[11:01:43.851]     })
[11:01:43.851]     if (TRUE) {
[11:01:43.851]         base::sink(type = "output", split = FALSE)
[11:01:43.851]         if (TRUE) {
[11:01:43.851]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.851]         }
[11:01:43.851]         else {
[11:01:43.851]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.851]         }
[11:01:43.851]         base::close(...future.stdout)
[11:01:43.851]         ...future.stdout <- NULL
[11:01:43.851]     }
[11:01:43.851]     ...future.result$conditions <- ...future.conditions
[11:01:43.851]     ...future.result$finished <- base::Sys.time()
[11:01:43.851]     ...future.result
[11:01:43.851] }
[11:01:43.902] MultisessionFuture started
[11:01:43.902] result() for ClusterFuture ...
[11:01:43.903] receiveMessageFromWorker() for ClusterFuture ...
[11:01:43.903] - Validating connection of MultisessionFuture
[11:01:43.933] - received message: FutureResult
[11:01:43.933] - Received FutureResult
[11:01:43.933] - Erased future from FutureRegistry
[11:01:43.933] result() for ClusterFuture ...
[11:01:43.933] - result already collected: FutureResult
[11:01:43.933] result() for ClusterFuture ... done
[11:01:43.933] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:43.934] result() for ClusterFuture ... done
[11:01:43.934] result() for ClusterFuture ...
[11:01:43.934] - result already collected: FutureResult
[11:01:43.934] result() for ClusterFuture ... done
[11:01:43.934] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:01:43.936] plan(): nbrOfWorkers() = 2
[11:01:43.936] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:43.936] Searching for globals...
[11:01:43.937] - globals found: [1] ‘getOption’
[11:01:43.937] Searching for globals ... DONE
[11:01:43.937] Resolving globals: FALSE
[11:01:43.937] 
[11:01:43.937] 
[11:01:43.937] getGlobalsAndPackages() ... DONE
[11:01:43.938] run() for ‘Future’ ...
[11:01:43.938] - state: ‘created’
[11:01:43.938] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:43.951] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:43.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:43.952]   - Field: ‘node’
[11:01:43.952]   - Field: ‘label’
[11:01:43.952]   - Field: ‘local’
[11:01:43.952]   - Field: ‘owner’
[11:01:43.952]   - Field: ‘envir’
[11:01:43.952]   - Field: ‘workers’
[11:01:43.952]   - Field: ‘packages’
[11:01:43.952]   - Field: ‘gc’
[11:01:43.952]   - Field: ‘conditions’
[11:01:43.952]   - Field: ‘persistent’
[11:01:43.952]   - Field: ‘expr’
[11:01:43.952]   - Field: ‘uuid’
[11:01:43.953]   - Field: ‘seed’
[11:01:43.953]   - Field: ‘version’
[11:01:43.953]   - Field: ‘result’
[11:01:43.953]   - Field: ‘asynchronous’
[11:01:43.953]   - Field: ‘calls’
[11:01:43.953]   - Field: ‘globals’
[11:01:43.953]   - Field: ‘stdout’
[11:01:43.953]   - Field: ‘earlySignal’
[11:01:43.953]   - Field: ‘lazy’
[11:01:43.953]   - Field: ‘state’
[11:01:43.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:43.953] - Launch lazy future ...
[11:01:43.954] Packages needed by the future expression (n = 0): <none>
[11:01:43.954] Packages needed by future strategies (n = 0): <none>
[11:01:43.954] {
[11:01:43.954]     {
[11:01:43.954]         {
[11:01:43.954]             ...future.startTime <- base::Sys.time()
[11:01:43.954]             {
[11:01:43.954]                 {
[11:01:43.954]                   {
[11:01:43.954]                     {
[11:01:43.954]                       base::local({
[11:01:43.954]                         has_future <- base::requireNamespace("future", 
[11:01:43.954]                           quietly = TRUE)
[11:01:43.954]                         if (has_future) {
[11:01:43.954]                           ns <- base::getNamespace("future")
[11:01:43.954]                           version <- ns[[".package"]][["version"]]
[11:01:43.954]                           if (is.null(version)) 
[11:01:43.954]                             version <- utils::packageVersion("future")
[11:01:43.954]                         }
[11:01:43.954]                         else {
[11:01:43.954]                           version <- NULL
[11:01:43.954]                         }
[11:01:43.954]                         if (!has_future || version < "1.8.0") {
[11:01:43.954]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:43.954]                             "", base::R.version$version.string), 
[11:01:43.954]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:43.954]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:43.954]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:43.954]                               "release", "version")], collapse = " "), 
[11:01:43.954]                             hostname = base::Sys.info()[["nodename"]])
[11:01:43.954]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:43.954]                             info)
[11:01:43.954]                           info <- base::paste(info, collapse = "; ")
[11:01:43.954]                           if (!has_future) {
[11:01:43.954]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:43.954]                               info)
[11:01:43.954]                           }
[11:01:43.954]                           else {
[11:01:43.954]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:43.954]                               info, version)
[11:01:43.954]                           }
[11:01:43.954]                           base::stop(msg)
[11:01:43.954]                         }
[11:01:43.954]                       })
[11:01:43.954]                     }
[11:01:43.954]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:43.954]                     base::options(mc.cores = 1L)
[11:01:43.954]                   }
[11:01:43.954]                   ...future.strategy.old <- future::plan("list")
[11:01:43.954]                   options(future.plan = NULL)
[11:01:43.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:43.954]                 }
[11:01:43.954]                 ...future.workdir <- getwd()
[11:01:43.954]             }
[11:01:43.954]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:43.954]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:43.954]         }
[11:01:43.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:43.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:43.954]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:43.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:43.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:43.954]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:43.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:43.954]             base::names(...future.oldOptions))
[11:01:43.954]     }
[11:01:43.954]     if (FALSE) {
[11:01:43.954]     }
[11:01:43.954]     else {
[11:01:43.954]         if (TRUE) {
[11:01:43.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:43.954]                 open = "w")
[11:01:43.954]         }
[11:01:43.954]         else {
[11:01:43.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:43.954]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:43.954]         }
[11:01:43.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:43.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:43.954]             base::sink(type = "output", split = FALSE)
[11:01:43.954]             base::close(...future.stdout)
[11:01:43.954]         }, add = TRUE)
[11:01:43.954]     }
[11:01:43.954]     ...future.frame <- base::sys.nframe()
[11:01:43.954]     ...future.conditions <- base::list()
[11:01:43.954]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:43.954]     if (FALSE) {
[11:01:43.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:43.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:43.954]     }
[11:01:43.954]     ...future.result <- base::tryCatch({
[11:01:43.954]         base::withCallingHandlers({
[11:01:43.954]             ...future.value <- base::withVisible(base::local({
[11:01:43.954]                 ...future.makeSendCondition <- base::local({
[11:01:43.954]                   sendCondition <- NULL
[11:01:43.954]                   function(frame = 1L) {
[11:01:43.954]                     if (is.function(sendCondition)) 
[11:01:43.954]                       return(sendCondition)
[11:01:43.954]                     ns <- getNamespace("parallel")
[11:01:43.954]                     if (exists("sendData", mode = "function", 
[11:01:43.954]                       envir = ns)) {
[11:01:43.954]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:43.954]                         envir = ns)
[11:01:43.954]                       envir <- sys.frame(frame)
[11:01:43.954]                       master <- NULL
[11:01:43.954]                       while (!identical(envir, .GlobalEnv) && 
[11:01:43.954]                         !identical(envir, emptyenv())) {
[11:01:43.954]                         if (exists("master", mode = "list", envir = envir, 
[11:01:43.954]                           inherits = FALSE)) {
[11:01:43.954]                           master <- get("master", mode = "list", 
[11:01:43.954]                             envir = envir, inherits = FALSE)
[11:01:43.954]                           if (inherits(master, c("SOCKnode", 
[11:01:43.954]                             "SOCK0node"))) {
[11:01:43.954]                             sendCondition <<- function(cond) {
[11:01:43.954]                               data <- list(type = "VALUE", value = cond, 
[11:01:43.954]                                 success = TRUE)
[11:01:43.954]                               parallel_sendData(master, data)
[11:01:43.954]                             }
[11:01:43.954]                             return(sendCondition)
[11:01:43.954]                           }
[11:01:43.954]                         }
[11:01:43.954]                         frame <- frame + 1L
[11:01:43.954]                         envir <- sys.frame(frame)
[11:01:43.954]                       }
[11:01:43.954]                     }
[11:01:43.954]                     sendCondition <<- function(cond) NULL
[11:01:43.954]                   }
[11:01:43.954]                 })
[11:01:43.954]                 withCallingHandlers({
[11:01:43.954]                   getOption("future.globals.onMissing")
[11:01:43.954]                 }, immediateCondition = function(cond) {
[11:01:43.954]                   sendCondition <- ...future.makeSendCondition()
[11:01:43.954]                   sendCondition(cond)
[11:01:43.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.954]                   {
[11:01:43.954]                     inherits <- base::inherits
[11:01:43.954]                     invokeRestart <- base::invokeRestart
[11:01:43.954]                     is.null <- base::is.null
[11:01:43.954]                     muffled <- FALSE
[11:01:43.954]                     if (inherits(cond, "message")) {
[11:01:43.954]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:43.954]                       if (muffled) 
[11:01:43.954]                         invokeRestart("muffleMessage")
[11:01:43.954]                     }
[11:01:43.954]                     else if (inherits(cond, "warning")) {
[11:01:43.954]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:43.954]                       if (muffled) 
[11:01:43.954]                         invokeRestart("muffleWarning")
[11:01:43.954]                     }
[11:01:43.954]                     else if (inherits(cond, "condition")) {
[11:01:43.954]                       if (!is.null(pattern)) {
[11:01:43.954]                         computeRestarts <- base::computeRestarts
[11:01:43.954]                         grepl <- base::grepl
[11:01:43.954]                         restarts <- computeRestarts(cond)
[11:01:43.954]                         for (restart in restarts) {
[11:01:43.954]                           name <- restart$name
[11:01:43.954]                           if (is.null(name)) 
[11:01:43.954]                             next
[11:01:43.954]                           if (!grepl(pattern, name)) 
[11:01:43.954]                             next
[11:01:43.954]                           invokeRestart(restart)
[11:01:43.954]                           muffled <- TRUE
[11:01:43.954]                           break
[11:01:43.954]                         }
[11:01:43.954]                       }
[11:01:43.954]                     }
[11:01:43.954]                     invisible(muffled)
[11:01:43.954]                   }
[11:01:43.954]                   muffleCondition(cond)
[11:01:43.954]                 })
[11:01:43.954]             }))
[11:01:43.954]             future::FutureResult(value = ...future.value$value, 
[11:01:43.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.954]                   ...future.rng), globalenv = if (FALSE) 
[11:01:43.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:43.954]                     ...future.globalenv.names))
[11:01:43.954]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:43.954]         }, condition = base::local({
[11:01:43.954]             c <- base::c
[11:01:43.954]             inherits <- base::inherits
[11:01:43.954]             invokeRestart <- base::invokeRestart
[11:01:43.954]             length <- base::length
[11:01:43.954]             list <- base::list
[11:01:43.954]             seq.int <- base::seq.int
[11:01:43.954]             signalCondition <- base::signalCondition
[11:01:43.954]             sys.calls <- base::sys.calls
[11:01:43.954]             `[[` <- base::`[[`
[11:01:43.954]             `+` <- base::`+`
[11:01:43.954]             `<<-` <- base::`<<-`
[11:01:43.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:43.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:43.954]                   3L)]
[11:01:43.954]             }
[11:01:43.954]             function(cond) {
[11:01:43.954]                 is_error <- inherits(cond, "error")
[11:01:43.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:43.954]                   NULL)
[11:01:43.954]                 if (is_error) {
[11:01:43.954]                   sessionInformation <- function() {
[11:01:43.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:43.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:43.954]                       search = base::search(), system = base::Sys.info())
[11:01:43.954]                   }
[11:01:43.954]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:43.954]                     cond$call), session = sessionInformation(), 
[11:01:43.954]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:43.954]                   signalCondition(cond)
[11:01:43.954]                 }
[11:01:43.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:43.954]                 "immediateCondition"))) {
[11:01:43.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:43.954]                   ...future.conditions[[length(...future.conditions) + 
[11:01:43.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:43.954]                   if (TRUE && !signal) {
[11:01:43.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.954]                     {
[11:01:43.954]                       inherits <- base::inherits
[11:01:43.954]                       invokeRestart <- base::invokeRestart
[11:01:43.954]                       is.null <- base::is.null
[11:01:43.954]                       muffled <- FALSE
[11:01:43.954]                       if (inherits(cond, "message")) {
[11:01:43.954]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.954]                         if (muffled) 
[11:01:43.954]                           invokeRestart("muffleMessage")
[11:01:43.954]                       }
[11:01:43.954]                       else if (inherits(cond, "warning")) {
[11:01:43.954]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.954]                         if (muffled) 
[11:01:43.954]                           invokeRestart("muffleWarning")
[11:01:43.954]                       }
[11:01:43.954]                       else if (inherits(cond, "condition")) {
[11:01:43.954]                         if (!is.null(pattern)) {
[11:01:43.954]                           computeRestarts <- base::computeRestarts
[11:01:43.954]                           grepl <- base::grepl
[11:01:43.954]                           restarts <- computeRestarts(cond)
[11:01:43.954]                           for (restart in restarts) {
[11:01:43.954]                             name <- restart$name
[11:01:43.954]                             if (is.null(name)) 
[11:01:43.954]                               next
[11:01:43.954]                             if (!grepl(pattern, name)) 
[11:01:43.954]                               next
[11:01:43.954]                             invokeRestart(restart)
[11:01:43.954]                             muffled <- TRUE
[11:01:43.954]                             break
[11:01:43.954]                           }
[11:01:43.954]                         }
[11:01:43.954]                       }
[11:01:43.954]                       invisible(muffled)
[11:01:43.954]                     }
[11:01:43.954]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.954]                   }
[11:01:43.954]                 }
[11:01:43.954]                 else {
[11:01:43.954]                   if (TRUE) {
[11:01:43.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:43.954]                     {
[11:01:43.954]                       inherits <- base::inherits
[11:01:43.954]                       invokeRestart <- base::invokeRestart
[11:01:43.954]                       is.null <- base::is.null
[11:01:43.954]                       muffled <- FALSE
[11:01:43.954]                       if (inherits(cond, "message")) {
[11:01:43.954]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:43.954]                         if (muffled) 
[11:01:43.954]                           invokeRestart("muffleMessage")
[11:01:43.954]                       }
[11:01:43.954]                       else if (inherits(cond, "warning")) {
[11:01:43.954]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:43.954]                         if (muffled) 
[11:01:43.954]                           invokeRestart("muffleWarning")
[11:01:43.954]                       }
[11:01:43.954]                       else if (inherits(cond, "condition")) {
[11:01:43.954]                         if (!is.null(pattern)) {
[11:01:43.954]                           computeRestarts <- base::computeRestarts
[11:01:43.954]                           grepl <- base::grepl
[11:01:43.954]                           restarts <- computeRestarts(cond)
[11:01:43.954]                           for (restart in restarts) {
[11:01:43.954]                             name <- restart$name
[11:01:43.954]                             if (is.null(name)) 
[11:01:43.954]                               next
[11:01:43.954]                             if (!grepl(pattern, name)) 
[11:01:43.954]                               next
[11:01:43.954]                             invokeRestart(restart)
[11:01:43.954]                             muffled <- TRUE
[11:01:43.954]                             break
[11:01:43.954]                           }
[11:01:43.954]                         }
[11:01:43.954]                       }
[11:01:43.954]                       invisible(muffled)
[11:01:43.954]                     }
[11:01:43.954]                     muffleCondition(cond, pattern = "^muffle")
[11:01:43.954]                   }
[11:01:43.954]                 }
[11:01:43.954]             }
[11:01:43.954]         }))
[11:01:43.954]     }, error = function(ex) {
[11:01:43.954]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:43.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:43.954]                 ...future.rng), started = ...future.startTime, 
[11:01:43.954]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:43.954]             version = "1.8"), class = "FutureResult")
[11:01:43.954]     }, finally = {
[11:01:43.954]         if (!identical(...future.workdir, getwd())) 
[11:01:43.954]             setwd(...future.workdir)
[11:01:43.954]         {
[11:01:43.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:43.954]                 ...future.oldOptions$nwarnings <- NULL
[11:01:43.954]             }
[11:01:43.954]             base::options(...future.oldOptions)
[11:01:43.954]             if (.Platform$OS.type == "windows") {
[11:01:43.954]                 old_names <- names(...future.oldEnvVars)
[11:01:43.954]                 envs <- base::Sys.getenv()
[11:01:43.954]                 names <- names(envs)
[11:01:43.954]                 common <- intersect(names, old_names)
[11:01:43.954]                 added <- setdiff(names, old_names)
[11:01:43.954]                 removed <- setdiff(old_names, names)
[11:01:43.954]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:43.954]                   envs[common]]
[11:01:43.954]                 NAMES <- toupper(changed)
[11:01:43.954]                 args <- list()
[11:01:43.954]                 for (kk in seq_along(NAMES)) {
[11:01:43.954]                   name <- changed[[kk]]
[11:01:43.954]                   NAME <- NAMES[[kk]]
[11:01:43.954]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.954]                     next
[11:01:43.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.954]                 }
[11:01:43.954]                 NAMES <- toupper(added)
[11:01:43.954]                 for (kk in seq_along(NAMES)) {
[11:01:43.954]                   name <- added[[kk]]
[11:01:43.954]                   NAME <- NAMES[[kk]]
[11:01:43.954]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.954]                     next
[11:01:43.954]                   args[[name]] <- ""
[11:01:43.954]                 }
[11:01:43.954]                 NAMES <- toupper(removed)
[11:01:43.954]                 for (kk in seq_along(NAMES)) {
[11:01:43.954]                   name <- removed[[kk]]
[11:01:43.954]                   NAME <- NAMES[[kk]]
[11:01:43.954]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:43.954]                     next
[11:01:43.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:43.954]                 }
[11:01:43.954]                 if (length(args) > 0) 
[11:01:43.954]                   base::do.call(base::Sys.setenv, args = args)
[11:01:43.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:43.954]             }
[11:01:43.954]             else {
[11:01:43.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:43.954]             }
[11:01:43.954]             {
[11:01:43.954]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:43.954]                   0L) {
[11:01:43.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:43.954]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:43.954]                   base::options(opts)
[11:01:43.954]                 }
[11:01:43.954]                 {
[11:01:43.954]                   {
[11:01:43.954]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:43.954]                     NULL
[11:01:43.954]                   }
[11:01:43.954]                   options(future.plan = NULL)
[11:01:43.954]                   if (is.na(NA_character_)) 
[11:01:43.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:43.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:43.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:43.954]                     .init = FALSE)
[11:01:43.954]                 }
[11:01:43.954]             }
[11:01:43.954]         }
[11:01:43.954]     })
[11:01:43.954]     if (TRUE) {
[11:01:43.954]         base::sink(type = "output", split = FALSE)
[11:01:43.954]         if (TRUE) {
[11:01:43.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:43.954]         }
[11:01:43.954]         else {
[11:01:43.954]             ...future.result["stdout"] <- base::list(NULL)
[11:01:43.954]         }
[11:01:43.954]         base::close(...future.stdout)
[11:01:43.954]         ...future.stdout <- NULL
[11:01:43.954]     }
[11:01:43.954]     ...future.result$conditions <- ...future.conditions
[11:01:43.954]     ...future.result$finished <- base::Sys.time()
[11:01:43.954]     ...future.result
[11:01:43.954] }
[11:01:43.957] MultisessionFuture started
[11:01:43.957] - Launch lazy future ... done
[11:01:43.957] run() for ‘MultisessionFuture’ ... done
[11:01:43.958] result() for ClusterFuture ...
[11:01:43.958] receiveMessageFromWorker() for ClusterFuture ...
[11:01:43.958] - Validating connection of MultisessionFuture
[11:01:43.999] - received message: FutureResult
[11:01:43.999] - Received FutureResult
[11:01:43.999] - Erased future from FutureRegistry
[11:01:43.999] result() for ClusterFuture ...
[11:01:43.999] - result already collected: FutureResult
[11:01:43.999] result() for ClusterFuture ... done
[11:01:43.999] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:44.000] result() for ClusterFuture ... done
[11:01:44.000] result() for ClusterFuture ...
[11:01:44.000] - result already collected: FutureResult
[11:01:44.000] result() for ClusterFuture ... done
[11:01:44.000] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:44.000] Searching for globals...
[11:01:44.001] - globals found: [1] ‘getOption’
[11:01:44.001] Searching for globals ... DONE
[11:01:44.001] Resolving globals: FALSE
[11:01:44.001] 
[11:01:44.001] 
[11:01:44.001] getGlobalsAndPackages() ... DONE
[11:01:44.002] run() for ‘Future’ ...
[11:01:44.002] - state: ‘created’
[11:01:44.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:44.016] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:44.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:44.016]   - Field: ‘node’
[11:01:44.016]   - Field: ‘label’
[11:01:44.016]   - Field: ‘local’
[11:01:44.017]   - Field: ‘owner’
[11:01:44.017]   - Field: ‘envir’
[11:01:44.017]   - Field: ‘workers’
[11:01:44.017]   - Field: ‘packages’
[11:01:44.017]   - Field: ‘gc’
[11:01:44.017]   - Field: ‘conditions’
[11:01:44.017]   - Field: ‘persistent’
[11:01:44.017]   - Field: ‘expr’
[11:01:44.017]   - Field: ‘uuid’
[11:01:44.017]   - Field: ‘seed’
[11:01:44.017]   - Field: ‘version’
[11:01:44.017]   - Field: ‘result’
[11:01:44.018]   - Field: ‘asynchronous’
[11:01:44.018]   - Field: ‘calls’
[11:01:44.018]   - Field: ‘globals’
[11:01:44.018]   - Field: ‘stdout’
[11:01:44.018]   - Field: ‘earlySignal’
[11:01:44.018]   - Field: ‘lazy’
[11:01:44.018]   - Field: ‘state’
[11:01:44.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:44.018] - Launch lazy future ...
[11:01:44.019] Packages needed by the future expression (n = 0): <none>
[11:01:44.019] Packages needed by future strategies (n = 0): <none>
[11:01:44.019] {
[11:01:44.019]     {
[11:01:44.019]         {
[11:01:44.019]             ...future.startTime <- base::Sys.time()
[11:01:44.019]             {
[11:01:44.019]                 {
[11:01:44.019]                   {
[11:01:44.019]                     {
[11:01:44.019]                       base::local({
[11:01:44.019]                         has_future <- base::requireNamespace("future", 
[11:01:44.019]                           quietly = TRUE)
[11:01:44.019]                         if (has_future) {
[11:01:44.019]                           ns <- base::getNamespace("future")
[11:01:44.019]                           version <- ns[[".package"]][["version"]]
[11:01:44.019]                           if (is.null(version)) 
[11:01:44.019]                             version <- utils::packageVersion("future")
[11:01:44.019]                         }
[11:01:44.019]                         else {
[11:01:44.019]                           version <- NULL
[11:01:44.019]                         }
[11:01:44.019]                         if (!has_future || version < "1.8.0") {
[11:01:44.019]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:44.019]                             "", base::R.version$version.string), 
[11:01:44.019]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:44.019]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:44.019]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:44.019]                               "release", "version")], collapse = " "), 
[11:01:44.019]                             hostname = base::Sys.info()[["nodename"]])
[11:01:44.019]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:44.019]                             info)
[11:01:44.019]                           info <- base::paste(info, collapse = "; ")
[11:01:44.019]                           if (!has_future) {
[11:01:44.019]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:44.019]                               info)
[11:01:44.019]                           }
[11:01:44.019]                           else {
[11:01:44.019]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:44.019]                               info, version)
[11:01:44.019]                           }
[11:01:44.019]                           base::stop(msg)
[11:01:44.019]                         }
[11:01:44.019]                       })
[11:01:44.019]                     }
[11:01:44.019]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:44.019]                     base::options(mc.cores = 1L)
[11:01:44.019]                   }
[11:01:44.019]                   ...future.strategy.old <- future::plan("list")
[11:01:44.019]                   options(future.plan = NULL)
[11:01:44.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:44.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:44.019]                 }
[11:01:44.019]                 ...future.workdir <- getwd()
[11:01:44.019]             }
[11:01:44.019]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:44.019]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:44.019]         }
[11:01:44.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:44.019]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:44.019]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:44.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:44.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:44.019]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:44.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:44.019]             base::names(...future.oldOptions))
[11:01:44.019]     }
[11:01:44.019]     if (FALSE) {
[11:01:44.019]     }
[11:01:44.019]     else {
[11:01:44.019]         if (TRUE) {
[11:01:44.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:44.019]                 open = "w")
[11:01:44.019]         }
[11:01:44.019]         else {
[11:01:44.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:44.019]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:44.019]         }
[11:01:44.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:44.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:44.019]             base::sink(type = "output", split = FALSE)
[11:01:44.019]             base::close(...future.stdout)
[11:01:44.019]         }, add = TRUE)
[11:01:44.019]     }
[11:01:44.019]     ...future.frame <- base::sys.nframe()
[11:01:44.019]     ...future.conditions <- base::list()
[11:01:44.019]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:44.019]     if (FALSE) {
[11:01:44.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:44.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:44.019]     }
[11:01:44.019]     ...future.result <- base::tryCatch({
[11:01:44.019]         base::withCallingHandlers({
[11:01:44.019]             ...future.value <- base::withVisible(base::local({
[11:01:44.019]                 ...future.makeSendCondition <- base::local({
[11:01:44.019]                   sendCondition <- NULL
[11:01:44.019]                   function(frame = 1L) {
[11:01:44.019]                     if (is.function(sendCondition)) 
[11:01:44.019]                       return(sendCondition)
[11:01:44.019]                     ns <- getNamespace("parallel")
[11:01:44.019]                     if (exists("sendData", mode = "function", 
[11:01:44.019]                       envir = ns)) {
[11:01:44.019]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:44.019]                         envir = ns)
[11:01:44.019]                       envir <- sys.frame(frame)
[11:01:44.019]                       master <- NULL
[11:01:44.019]                       while (!identical(envir, .GlobalEnv) && 
[11:01:44.019]                         !identical(envir, emptyenv())) {
[11:01:44.019]                         if (exists("master", mode = "list", envir = envir, 
[11:01:44.019]                           inherits = FALSE)) {
[11:01:44.019]                           master <- get("master", mode = "list", 
[11:01:44.019]                             envir = envir, inherits = FALSE)
[11:01:44.019]                           if (inherits(master, c("SOCKnode", 
[11:01:44.019]                             "SOCK0node"))) {
[11:01:44.019]                             sendCondition <<- function(cond) {
[11:01:44.019]                               data <- list(type = "VALUE", value = cond, 
[11:01:44.019]                                 success = TRUE)
[11:01:44.019]                               parallel_sendData(master, data)
[11:01:44.019]                             }
[11:01:44.019]                             return(sendCondition)
[11:01:44.019]                           }
[11:01:44.019]                         }
[11:01:44.019]                         frame <- frame + 1L
[11:01:44.019]                         envir <- sys.frame(frame)
[11:01:44.019]                       }
[11:01:44.019]                     }
[11:01:44.019]                     sendCondition <<- function(cond) NULL
[11:01:44.019]                   }
[11:01:44.019]                 })
[11:01:44.019]                 withCallingHandlers({
[11:01:44.019]                   getOption("future.globals.onMissing")
[11:01:44.019]                 }, immediateCondition = function(cond) {
[11:01:44.019]                   sendCondition <- ...future.makeSendCondition()
[11:01:44.019]                   sendCondition(cond)
[11:01:44.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.019]                   {
[11:01:44.019]                     inherits <- base::inherits
[11:01:44.019]                     invokeRestart <- base::invokeRestart
[11:01:44.019]                     is.null <- base::is.null
[11:01:44.019]                     muffled <- FALSE
[11:01:44.019]                     if (inherits(cond, "message")) {
[11:01:44.019]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:44.019]                       if (muffled) 
[11:01:44.019]                         invokeRestart("muffleMessage")
[11:01:44.019]                     }
[11:01:44.019]                     else if (inherits(cond, "warning")) {
[11:01:44.019]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:44.019]                       if (muffled) 
[11:01:44.019]                         invokeRestart("muffleWarning")
[11:01:44.019]                     }
[11:01:44.019]                     else if (inherits(cond, "condition")) {
[11:01:44.019]                       if (!is.null(pattern)) {
[11:01:44.019]                         computeRestarts <- base::computeRestarts
[11:01:44.019]                         grepl <- base::grepl
[11:01:44.019]                         restarts <- computeRestarts(cond)
[11:01:44.019]                         for (restart in restarts) {
[11:01:44.019]                           name <- restart$name
[11:01:44.019]                           if (is.null(name)) 
[11:01:44.019]                             next
[11:01:44.019]                           if (!grepl(pattern, name)) 
[11:01:44.019]                             next
[11:01:44.019]                           invokeRestart(restart)
[11:01:44.019]                           muffled <- TRUE
[11:01:44.019]                           break
[11:01:44.019]                         }
[11:01:44.019]                       }
[11:01:44.019]                     }
[11:01:44.019]                     invisible(muffled)
[11:01:44.019]                   }
[11:01:44.019]                   muffleCondition(cond)
[11:01:44.019]                 })
[11:01:44.019]             }))
[11:01:44.019]             future::FutureResult(value = ...future.value$value, 
[11:01:44.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:44.019]                   ...future.rng), globalenv = if (FALSE) 
[11:01:44.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:44.019]                     ...future.globalenv.names))
[11:01:44.019]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:44.019]         }, condition = base::local({
[11:01:44.019]             c <- base::c
[11:01:44.019]             inherits <- base::inherits
[11:01:44.019]             invokeRestart <- base::invokeRestart
[11:01:44.019]             length <- base::length
[11:01:44.019]             list <- base::list
[11:01:44.019]             seq.int <- base::seq.int
[11:01:44.019]             signalCondition <- base::signalCondition
[11:01:44.019]             sys.calls <- base::sys.calls
[11:01:44.019]             `[[` <- base::`[[`
[11:01:44.019]             `+` <- base::`+`
[11:01:44.019]             `<<-` <- base::`<<-`
[11:01:44.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:44.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:44.019]                   3L)]
[11:01:44.019]             }
[11:01:44.019]             function(cond) {
[11:01:44.019]                 is_error <- inherits(cond, "error")
[11:01:44.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:44.019]                   NULL)
[11:01:44.019]                 if (is_error) {
[11:01:44.019]                   sessionInformation <- function() {
[11:01:44.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:44.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:44.019]                       search = base::search(), system = base::Sys.info())
[11:01:44.019]                   }
[11:01:44.019]                   ...future.conditions[[length(...future.conditions) + 
[11:01:44.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:44.019]                     cond$call), session = sessionInformation(), 
[11:01:44.019]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:44.019]                   signalCondition(cond)
[11:01:44.019]                 }
[11:01:44.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:44.019]                 "immediateCondition"))) {
[11:01:44.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:44.019]                   ...future.conditions[[length(...future.conditions) + 
[11:01:44.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:44.019]                   if (TRUE && !signal) {
[11:01:44.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.019]                     {
[11:01:44.019]                       inherits <- base::inherits
[11:01:44.019]                       invokeRestart <- base::invokeRestart
[11:01:44.019]                       is.null <- base::is.null
[11:01:44.019]                       muffled <- FALSE
[11:01:44.019]                       if (inherits(cond, "message")) {
[11:01:44.019]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:44.019]                         if (muffled) 
[11:01:44.019]                           invokeRestart("muffleMessage")
[11:01:44.019]                       }
[11:01:44.019]                       else if (inherits(cond, "warning")) {
[11:01:44.019]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:44.019]                         if (muffled) 
[11:01:44.019]                           invokeRestart("muffleWarning")
[11:01:44.019]                       }
[11:01:44.019]                       else if (inherits(cond, "condition")) {
[11:01:44.019]                         if (!is.null(pattern)) {
[11:01:44.019]                           computeRestarts <- base::computeRestarts
[11:01:44.019]                           grepl <- base::grepl
[11:01:44.019]                           restarts <- computeRestarts(cond)
[11:01:44.019]                           for (restart in restarts) {
[11:01:44.019]                             name <- restart$name
[11:01:44.019]                             if (is.null(name)) 
[11:01:44.019]                               next
[11:01:44.019]                             if (!grepl(pattern, name)) 
[11:01:44.019]                               next
[11:01:44.019]                             invokeRestart(restart)
[11:01:44.019]                             muffled <- TRUE
[11:01:44.019]                             break
[11:01:44.019]                           }
[11:01:44.019]                         }
[11:01:44.019]                       }
[11:01:44.019]                       invisible(muffled)
[11:01:44.019]                     }
[11:01:44.019]                     muffleCondition(cond, pattern = "^muffle")
[11:01:44.019]                   }
[11:01:44.019]                 }
[11:01:44.019]                 else {
[11:01:44.019]                   if (TRUE) {
[11:01:44.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.019]                     {
[11:01:44.019]                       inherits <- base::inherits
[11:01:44.019]                       invokeRestart <- base::invokeRestart
[11:01:44.019]                       is.null <- base::is.null
[11:01:44.019]                       muffled <- FALSE
[11:01:44.019]                       if (inherits(cond, "message")) {
[11:01:44.019]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:44.019]                         if (muffled) 
[11:01:44.019]                           invokeRestart("muffleMessage")
[11:01:44.019]                       }
[11:01:44.019]                       else if (inherits(cond, "warning")) {
[11:01:44.019]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:44.019]                         if (muffled) 
[11:01:44.019]                           invokeRestart("muffleWarning")
[11:01:44.019]                       }
[11:01:44.019]                       else if (inherits(cond, "condition")) {
[11:01:44.019]                         if (!is.null(pattern)) {
[11:01:44.019]                           computeRestarts <- base::computeRestarts
[11:01:44.019]                           grepl <- base::grepl
[11:01:44.019]                           restarts <- computeRestarts(cond)
[11:01:44.019]                           for (restart in restarts) {
[11:01:44.019]                             name <- restart$name
[11:01:44.019]                             if (is.null(name)) 
[11:01:44.019]                               next
[11:01:44.019]                             if (!grepl(pattern, name)) 
[11:01:44.019]                               next
[11:01:44.019]                             invokeRestart(restart)
[11:01:44.019]                             muffled <- TRUE
[11:01:44.019]                             break
[11:01:44.019]                           }
[11:01:44.019]                         }
[11:01:44.019]                       }
[11:01:44.019]                       invisible(muffled)
[11:01:44.019]                     }
[11:01:44.019]                     muffleCondition(cond, pattern = "^muffle")
[11:01:44.019]                   }
[11:01:44.019]                 }
[11:01:44.019]             }
[11:01:44.019]         }))
[11:01:44.019]     }, error = function(ex) {
[11:01:44.019]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:44.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:44.019]                 ...future.rng), started = ...future.startTime, 
[11:01:44.019]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:44.019]             version = "1.8"), class = "FutureResult")
[11:01:44.019]     }, finally = {
[11:01:44.019]         if (!identical(...future.workdir, getwd())) 
[11:01:44.019]             setwd(...future.workdir)
[11:01:44.019]         {
[11:01:44.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:44.019]                 ...future.oldOptions$nwarnings <- NULL
[11:01:44.019]             }
[11:01:44.019]             base::options(...future.oldOptions)
[11:01:44.019]             if (.Platform$OS.type == "windows") {
[11:01:44.019]                 old_names <- names(...future.oldEnvVars)
[11:01:44.019]                 envs <- base::Sys.getenv()
[11:01:44.019]                 names <- names(envs)
[11:01:44.019]                 common <- intersect(names, old_names)
[11:01:44.019]                 added <- setdiff(names, old_names)
[11:01:44.019]                 removed <- setdiff(old_names, names)
[11:01:44.019]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:44.019]                   envs[common]]
[11:01:44.019]                 NAMES <- toupper(changed)
[11:01:44.019]                 args <- list()
[11:01:44.019]                 for (kk in seq_along(NAMES)) {
[11:01:44.019]                   name <- changed[[kk]]
[11:01:44.019]                   NAME <- NAMES[[kk]]
[11:01:44.019]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.019]                     next
[11:01:44.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:44.019]                 }
[11:01:44.019]                 NAMES <- toupper(added)
[11:01:44.019]                 for (kk in seq_along(NAMES)) {
[11:01:44.019]                   name <- added[[kk]]
[11:01:44.019]                   NAME <- NAMES[[kk]]
[11:01:44.019]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.019]                     next
[11:01:44.019]                   args[[name]] <- ""
[11:01:44.019]                 }
[11:01:44.019]                 NAMES <- toupper(removed)
[11:01:44.019]                 for (kk in seq_along(NAMES)) {
[11:01:44.019]                   name <- removed[[kk]]
[11:01:44.019]                   NAME <- NAMES[[kk]]
[11:01:44.019]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.019]                     next
[11:01:44.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:44.019]                 }
[11:01:44.019]                 if (length(args) > 0) 
[11:01:44.019]                   base::do.call(base::Sys.setenv, args = args)
[11:01:44.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:44.019]             }
[11:01:44.019]             else {
[11:01:44.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:44.019]             }
[11:01:44.019]             {
[11:01:44.019]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:44.019]                   0L) {
[11:01:44.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:44.019]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:44.019]                   base::options(opts)
[11:01:44.019]                 }
[11:01:44.019]                 {
[11:01:44.019]                   {
[11:01:44.019]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:44.019]                     NULL
[11:01:44.019]                   }
[11:01:44.019]                   options(future.plan = NULL)
[11:01:44.019]                   if (is.na(NA_character_)) 
[11:01:44.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:44.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:44.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:44.019]                     .init = FALSE)
[11:01:44.019]                 }
[11:01:44.019]             }
[11:01:44.019]         }
[11:01:44.019]     })
[11:01:44.019]     if (TRUE) {
[11:01:44.019]         base::sink(type = "output", split = FALSE)
[11:01:44.019]         if (TRUE) {
[11:01:44.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:44.019]         }
[11:01:44.019]         else {
[11:01:44.019]             ...future.result["stdout"] <- base::list(NULL)
[11:01:44.019]         }
[11:01:44.019]         base::close(...future.stdout)
[11:01:44.019]         ...future.stdout <- NULL
[11:01:44.019]     }
[11:01:44.019]     ...future.result$conditions <- ...future.conditions
[11:01:44.019]     ...future.result$finished <- base::Sys.time()
[11:01:44.019]     ...future.result
[11:01:44.019] }
[11:01:44.022] MultisessionFuture started
[11:01:44.022] - Launch lazy future ... done
[11:01:44.022] run() for ‘MultisessionFuture’ ... done
[11:01:44.022] result() for ClusterFuture ...
[11:01:44.023] receiveMessageFromWorker() for ClusterFuture ...
[11:01:44.023] - Validating connection of MultisessionFuture
[11:01:44.064] - received message: FutureResult
[11:01:44.064] - Received FutureResult
[11:01:44.064] - Erased future from FutureRegistry
[11:01:44.064] result() for ClusterFuture ...
[11:01:44.064] - result already collected: FutureResult
[11:01:44.064] result() for ClusterFuture ... done
[11:01:44.065] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:44.065] result() for ClusterFuture ... done
[11:01:44.065] result() for ClusterFuture ...
[11:01:44.065] - result already collected: FutureResult
[11:01:44.065] result() for ClusterFuture ... done
[11:01:44.065] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:44.066] Searching for globals...
[11:01:44.067] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:44.067] Searching for globals...
[11:01:44.068] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[11:01:44.068] Searching for globals ... DONE
[11:01:44.069] Resolving globals: FALSE
[11:01:44.069] The total size of the 1 globals is 356 bytes (356 bytes)
[11:01:44.069] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:01:44.070] - globals: [1] ‘data’
[11:01:44.070] 
[11:01:44.070] getGlobalsAndPackages() ... DONE
[11:01:44.070] run() for ‘Future’ ...
[11:01:44.070] - state: ‘created’
[11:01:44.070] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:44.085] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:44.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:44.085]   - Field: ‘node’
[11:01:44.085]   - Field: ‘label’
[11:01:44.085]   - Field: ‘local’
[11:01:44.085]   - Field: ‘owner’
[11:01:44.085]   - Field: ‘envir’
[11:01:44.085]   - Field: ‘workers’
[11:01:44.085]   - Field: ‘packages’
[11:01:44.086]   - Field: ‘gc’
[11:01:44.086]   - Field: ‘conditions’
[11:01:44.086]   - Field: ‘persistent’
[11:01:44.086]   - Field: ‘expr’
[11:01:44.086]   - Field: ‘uuid’
[11:01:44.086]   - Field: ‘seed’
[11:01:44.086]   - Field: ‘version’
[11:01:44.086]   - Field: ‘result’
[11:01:44.086]   - Field: ‘asynchronous’
[11:01:44.086]   - Field: ‘calls’
[11:01:44.087]   - Field: ‘globals’
[11:01:44.087]   - Field: ‘stdout’
[11:01:44.087]   - Field: ‘earlySignal’
[11:01:44.087]   - Field: ‘lazy’
[11:01:44.087]   - Field: ‘state’
[11:01:44.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:44.087] - Launch lazy future ...
[11:01:44.088] Packages needed by the future expression (n = 0): <none>
[11:01:44.088] Packages needed by future strategies (n = 0): <none>
[11:01:44.088] {
[11:01:44.088]     {
[11:01:44.088]         {
[11:01:44.088]             ...future.startTime <- base::Sys.time()
[11:01:44.088]             {
[11:01:44.088]                 {
[11:01:44.088]                   {
[11:01:44.088]                     {
[11:01:44.088]                       base::local({
[11:01:44.088]                         has_future <- base::requireNamespace("future", 
[11:01:44.088]                           quietly = TRUE)
[11:01:44.088]                         if (has_future) {
[11:01:44.088]                           ns <- base::getNamespace("future")
[11:01:44.088]                           version <- ns[[".package"]][["version"]]
[11:01:44.088]                           if (is.null(version)) 
[11:01:44.088]                             version <- utils::packageVersion("future")
[11:01:44.088]                         }
[11:01:44.088]                         else {
[11:01:44.088]                           version <- NULL
[11:01:44.088]                         }
[11:01:44.088]                         if (!has_future || version < "1.8.0") {
[11:01:44.088]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:44.088]                             "", base::R.version$version.string), 
[11:01:44.088]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:44.088]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:44.088]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:44.088]                               "release", "version")], collapse = " "), 
[11:01:44.088]                             hostname = base::Sys.info()[["nodename"]])
[11:01:44.088]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:44.088]                             info)
[11:01:44.088]                           info <- base::paste(info, collapse = "; ")
[11:01:44.088]                           if (!has_future) {
[11:01:44.088]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:44.088]                               info)
[11:01:44.088]                           }
[11:01:44.088]                           else {
[11:01:44.088]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:44.088]                               info, version)
[11:01:44.088]                           }
[11:01:44.088]                           base::stop(msg)
[11:01:44.088]                         }
[11:01:44.088]                       })
[11:01:44.088]                     }
[11:01:44.088]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:44.088]                     base::options(mc.cores = 1L)
[11:01:44.088]                   }
[11:01:44.088]                   ...future.strategy.old <- future::plan("list")
[11:01:44.088]                   options(future.plan = NULL)
[11:01:44.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:44.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:44.088]                 }
[11:01:44.088]                 ...future.workdir <- getwd()
[11:01:44.088]             }
[11:01:44.088]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:44.088]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:44.088]         }
[11:01:44.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:44.088]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:44.088]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:44.088]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:44.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:44.088]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:44.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:44.088]             base::names(...future.oldOptions))
[11:01:44.088]     }
[11:01:44.088]     if (FALSE) {
[11:01:44.088]     }
[11:01:44.088]     else {
[11:01:44.088]         if (TRUE) {
[11:01:44.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:44.088]                 open = "w")
[11:01:44.088]         }
[11:01:44.088]         else {
[11:01:44.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:44.088]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:44.088]         }
[11:01:44.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:44.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:44.088]             base::sink(type = "output", split = FALSE)
[11:01:44.088]             base::close(...future.stdout)
[11:01:44.088]         }, add = TRUE)
[11:01:44.088]     }
[11:01:44.088]     ...future.frame <- base::sys.nframe()
[11:01:44.088]     ...future.conditions <- base::list()
[11:01:44.088]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:44.088]     if (FALSE) {
[11:01:44.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:44.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:44.088]     }
[11:01:44.088]     ...future.result <- base::tryCatch({
[11:01:44.088]         base::withCallingHandlers({
[11:01:44.088]             ...future.value <- base::withVisible(base::local({
[11:01:44.088]                 ...future.makeSendCondition <- base::local({
[11:01:44.088]                   sendCondition <- NULL
[11:01:44.088]                   function(frame = 1L) {
[11:01:44.088]                     if (is.function(sendCondition)) 
[11:01:44.088]                       return(sendCondition)
[11:01:44.088]                     ns <- getNamespace("parallel")
[11:01:44.088]                     if (exists("sendData", mode = "function", 
[11:01:44.088]                       envir = ns)) {
[11:01:44.088]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:44.088]                         envir = ns)
[11:01:44.088]                       envir <- sys.frame(frame)
[11:01:44.088]                       master <- NULL
[11:01:44.088]                       while (!identical(envir, .GlobalEnv) && 
[11:01:44.088]                         !identical(envir, emptyenv())) {
[11:01:44.088]                         if (exists("master", mode = "list", envir = envir, 
[11:01:44.088]                           inherits = FALSE)) {
[11:01:44.088]                           master <- get("master", mode = "list", 
[11:01:44.088]                             envir = envir, inherits = FALSE)
[11:01:44.088]                           if (inherits(master, c("SOCKnode", 
[11:01:44.088]                             "SOCK0node"))) {
[11:01:44.088]                             sendCondition <<- function(cond) {
[11:01:44.088]                               data <- list(type = "VALUE", value = cond, 
[11:01:44.088]                                 success = TRUE)
[11:01:44.088]                               parallel_sendData(master, data)
[11:01:44.088]                             }
[11:01:44.088]                             return(sendCondition)
[11:01:44.088]                           }
[11:01:44.088]                         }
[11:01:44.088]                         frame <- frame + 1L
[11:01:44.088]                         envir <- sys.frame(frame)
[11:01:44.088]                       }
[11:01:44.088]                     }
[11:01:44.088]                     sendCondition <<- function(cond) NULL
[11:01:44.088]                   }
[11:01:44.088]                 })
[11:01:44.088]                 withCallingHandlers({
[11:01:44.088]                   subset(data, x < 3)$y
[11:01:44.088]                 }, immediateCondition = function(cond) {
[11:01:44.088]                   sendCondition <- ...future.makeSendCondition()
[11:01:44.088]                   sendCondition(cond)
[11:01:44.088]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.088]                   {
[11:01:44.088]                     inherits <- base::inherits
[11:01:44.088]                     invokeRestart <- base::invokeRestart
[11:01:44.088]                     is.null <- base::is.null
[11:01:44.088]                     muffled <- FALSE
[11:01:44.088]                     if (inherits(cond, "message")) {
[11:01:44.088]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:44.088]                       if (muffled) 
[11:01:44.088]                         invokeRestart("muffleMessage")
[11:01:44.088]                     }
[11:01:44.088]                     else if (inherits(cond, "warning")) {
[11:01:44.088]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:44.088]                       if (muffled) 
[11:01:44.088]                         invokeRestart("muffleWarning")
[11:01:44.088]                     }
[11:01:44.088]                     else if (inherits(cond, "condition")) {
[11:01:44.088]                       if (!is.null(pattern)) {
[11:01:44.088]                         computeRestarts <- base::computeRestarts
[11:01:44.088]                         grepl <- base::grepl
[11:01:44.088]                         restarts <- computeRestarts(cond)
[11:01:44.088]                         for (restart in restarts) {
[11:01:44.088]                           name <- restart$name
[11:01:44.088]                           if (is.null(name)) 
[11:01:44.088]                             next
[11:01:44.088]                           if (!grepl(pattern, name)) 
[11:01:44.088]                             next
[11:01:44.088]                           invokeRestart(restart)
[11:01:44.088]                           muffled <- TRUE
[11:01:44.088]                           break
[11:01:44.088]                         }
[11:01:44.088]                       }
[11:01:44.088]                     }
[11:01:44.088]                     invisible(muffled)
[11:01:44.088]                   }
[11:01:44.088]                   muffleCondition(cond)
[11:01:44.088]                 })
[11:01:44.088]             }))
[11:01:44.088]             future::FutureResult(value = ...future.value$value, 
[11:01:44.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:44.088]                   ...future.rng), globalenv = if (FALSE) 
[11:01:44.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:44.088]                     ...future.globalenv.names))
[11:01:44.088]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:44.088]         }, condition = base::local({
[11:01:44.088]             c <- base::c
[11:01:44.088]             inherits <- base::inherits
[11:01:44.088]             invokeRestart <- base::invokeRestart
[11:01:44.088]             length <- base::length
[11:01:44.088]             list <- base::list
[11:01:44.088]             seq.int <- base::seq.int
[11:01:44.088]             signalCondition <- base::signalCondition
[11:01:44.088]             sys.calls <- base::sys.calls
[11:01:44.088]             `[[` <- base::`[[`
[11:01:44.088]             `+` <- base::`+`
[11:01:44.088]             `<<-` <- base::`<<-`
[11:01:44.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:44.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:44.088]                   3L)]
[11:01:44.088]             }
[11:01:44.088]             function(cond) {
[11:01:44.088]                 is_error <- inherits(cond, "error")
[11:01:44.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:44.088]                   NULL)
[11:01:44.088]                 if (is_error) {
[11:01:44.088]                   sessionInformation <- function() {
[11:01:44.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:44.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:44.088]                       search = base::search(), system = base::Sys.info())
[11:01:44.088]                   }
[11:01:44.088]                   ...future.conditions[[length(...future.conditions) + 
[11:01:44.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:44.088]                     cond$call), session = sessionInformation(), 
[11:01:44.088]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:44.088]                   signalCondition(cond)
[11:01:44.088]                 }
[11:01:44.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:44.088]                 "immediateCondition"))) {
[11:01:44.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:44.088]                   ...future.conditions[[length(...future.conditions) + 
[11:01:44.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:44.088]                   if (TRUE && !signal) {
[11:01:44.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.088]                     {
[11:01:44.088]                       inherits <- base::inherits
[11:01:44.088]                       invokeRestart <- base::invokeRestart
[11:01:44.088]                       is.null <- base::is.null
[11:01:44.088]                       muffled <- FALSE
[11:01:44.088]                       if (inherits(cond, "message")) {
[11:01:44.088]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:44.088]                         if (muffled) 
[11:01:44.088]                           invokeRestart("muffleMessage")
[11:01:44.088]                       }
[11:01:44.088]                       else if (inherits(cond, "warning")) {
[11:01:44.088]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:44.088]                         if (muffled) 
[11:01:44.088]                           invokeRestart("muffleWarning")
[11:01:44.088]                       }
[11:01:44.088]                       else if (inherits(cond, "condition")) {
[11:01:44.088]                         if (!is.null(pattern)) {
[11:01:44.088]                           computeRestarts <- base::computeRestarts
[11:01:44.088]                           grepl <- base::grepl
[11:01:44.088]                           restarts <- computeRestarts(cond)
[11:01:44.088]                           for (restart in restarts) {
[11:01:44.088]                             name <- restart$name
[11:01:44.088]                             if (is.null(name)) 
[11:01:44.088]                               next
[11:01:44.088]                             if (!grepl(pattern, name)) 
[11:01:44.088]                               next
[11:01:44.088]                             invokeRestart(restart)
[11:01:44.088]                             muffled <- TRUE
[11:01:44.088]                             break
[11:01:44.088]                           }
[11:01:44.088]                         }
[11:01:44.088]                       }
[11:01:44.088]                       invisible(muffled)
[11:01:44.088]                     }
[11:01:44.088]                     muffleCondition(cond, pattern = "^muffle")
[11:01:44.088]                   }
[11:01:44.088]                 }
[11:01:44.088]                 else {
[11:01:44.088]                   if (TRUE) {
[11:01:44.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.088]                     {
[11:01:44.088]                       inherits <- base::inherits
[11:01:44.088]                       invokeRestart <- base::invokeRestart
[11:01:44.088]                       is.null <- base::is.null
[11:01:44.088]                       muffled <- FALSE
[11:01:44.088]                       if (inherits(cond, "message")) {
[11:01:44.088]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:44.088]                         if (muffled) 
[11:01:44.088]                           invokeRestart("muffleMessage")
[11:01:44.088]                       }
[11:01:44.088]                       else if (inherits(cond, "warning")) {
[11:01:44.088]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:44.088]                         if (muffled) 
[11:01:44.088]                           invokeRestart("muffleWarning")
[11:01:44.088]                       }
[11:01:44.088]                       else if (inherits(cond, "condition")) {
[11:01:44.088]                         if (!is.null(pattern)) {
[11:01:44.088]                           computeRestarts <- base::computeRestarts
[11:01:44.088]                           grepl <- base::grepl
[11:01:44.088]                           restarts <- computeRestarts(cond)
[11:01:44.088]                           for (restart in restarts) {
[11:01:44.088]                             name <- restart$name
[11:01:44.088]                             if (is.null(name)) 
[11:01:44.088]                               next
[11:01:44.088]                             if (!grepl(pattern, name)) 
[11:01:44.088]                               next
[11:01:44.088]                             invokeRestart(restart)
[11:01:44.088]                             muffled <- TRUE
[11:01:44.088]                             break
[11:01:44.088]                           }
[11:01:44.088]                         }
[11:01:44.088]                       }
[11:01:44.088]                       invisible(muffled)
[11:01:44.088]                     }
[11:01:44.088]                     muffleCondition(cond, pattern = "^muffle")
[11:01:44.088]                   }
[11:01:44.088]                 }
[11:01:44.088]             }
[11:01:44.088]         }))
[11:01:44.088]     }, error = function(ex) {
[11:01:44.088]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:44.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:44.088]                 ...future.rng), started = ...future.startTime, 
[11:01:44.088]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:44.088]             version = "1.8"), class = "FutureResult")
[11:01:44.088]     }, finally = {
[11:01:44.088]         if (!identical(...future.workdir, getwd())) 
[11:01:44.088]             setwd(...future.workdir)
[11:01:44.088]         {
[11:01:44.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:44.088]                 ...future.oldOptions$nwarnings <- NULL
[11:01:44.088]             }
[11:01:44.088]             base::options(...future.oldOptions)
[11:01:44.088]             if (.Platform$OS.type == "windows") {
[11:01:44.088]                 old_names <- names(...future.oldEnvVars)
[11:01:44.088]                 envs <- base::Sys.getenv()
[11:01:44.088]                 names <- names(envs)
[11:01:44.088]                 common <- intersect(names, old_names)
[11:01:44.088]                 added <- setdiff(names, old_names)
[11:01:44.088]                 removed <- setdiff(old_names, names)
[11:01:44.088]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:44.088]                   envs[common]]
[11:01:44.088]                 NAMES <- toupper(changed)
[11:01:44.088]                 args <- list()
[11:01:44.088]                 for (kk in seq_along(NAMES)) {
[11:01:44.088]                   name <- changed[[kk]]
[11:01:44.088]                   NAME <- NAMES[[kk]]
[11:01:44.088]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.088]                     next
[11:01:44.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:44.088]                 }
[11:01:44.088]                 NAMES <- toupper(added)
[11:01:44.088]                 for (kk in seq_along(NAMES)) {
[11:01:44.088]                   name <- added[[kk]]
[11:01:44.088]                   NAME <- NAMES[[kk]]
[11:01:44.088]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.088]                     next
[11:01:44.088]                   args[[name]] <- ""
[11:01:44.088]                 }
[11:01:44.088]                 NAMES <- toupper(removed)
[11:01:44.088]                 for (kk in seq_along(NAMES)) {
[11:01:44.088]                   name <- removed[[kk]]
[11:01:44.088]                   NAME <- NAMES[[kk]]
[11:01:44.088]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.088]                     next
[11:01:44.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:44.088]                 }
[11:01:44.088]                 if (length(args) > 0) 
[11:01:44.088]                   base::do.call(base::Sys.setenv, args = args)
[11:01:44.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:44.088]             }
[11:01:44.088]             else {
[11:01:44.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:44.088]             }
[11:01:44.088]             {
[11:01:44.088]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:44.088]                   0L) {
[11:01:44.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:44.088]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:44.088]                   base::options(opts)
[11:01:44.088]                 }
[11:01:44.088]                 {
[11:01:44.088]                   {
[11:01:44.088]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:44.088]                     NULL
[11:01:44.088]                   }
[11:01:44.088]                   options(future.plan = NULL)
[11:01:44.088]                   if (is.na(NA_character_)) 
[11:01:44.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:44.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:44.088]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:44.088]                     .init = FALSE)
[11:01:44.088]                 }
[11:01:44.088]             }
[11:01:44.088]         }
[11:01:44.088]     })
[11:01:44.088]     if (TRUE) {
[11:01:44.088]         base::sink(type = "output", split = FALSE)
[11:01:44.088]         if (TRUE) {
[11:01:44.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:44.088]         }
[11:01:44.088]         else {
[11:01:44.088]             ...future.result["stdout"] <- base::list(NULL)
[11:01:44.088]         }
[11:01:44.088]         base::close(...future.stdout)
[11:01:44.088]         ...future.stdout <- NULL
[11:01:44.088]     }
[11:01:44.088]     ...future.result$conditions <- ...future.conditions
[11:01:44.088]     ...future.result$finished <- base::Sys.time()
[11:01:44.088]     ...future.result
[11:01:44.088] }
[11:01:44.091] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[11:01:44.091] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[11:01:44.091] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[11:01:44.092] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[11:01:44.092] MultisessionFuture started
[11:01:44.092] - Launch lazy future ... done
[11:01:44.092] run() for ‘MultisessionFuture’ ... done
[11:01:44.093] result() for ClusterFuture ...
[11:01:44.093] receiveMessageFromWorker() for ClusterFuture ...
[11:01:44.093] - Validating connection of MultisessionFuture
[11:01:44.134] - received message: FutureResult
[11:01:44.134] - Received FutureResult
[11:01:44.134] - Erased future from FutureRegistry
[11:01:44.135] result() for ClusterFuture ...
[11:01:44.135] - result already collected: FutureResult
[11:01:44.135] result() for ClusterFuture ... done
[11:01:44.135] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:44.135] result() for ClusterFuture ... done
[11:01:44.135] result() for ClusterFuture ...
[11:01:44.135] - result already collected: FutureResult
[11:01:44.135] result() for ClusterFuture ... done
[11:01:44.135] plan(): Setting new future strategy stack:
[11:01:44.136] List of future strategies:
[11:01:44.136] 1. sequential:
[11:01:44.136]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:44.136]    - tweaked: FALSE
[11:01:44.136]    - call: plan(list(sequential, strategy))
[11:01:44.136] 2. multisession:
[11:01:44.136]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:44.136]    - tweaked: FALSE
[11:01:44.136]    - call: plan(list(sequential, strategy))
[11:01:44.137] plan(): nbrOfWorkers() = 1
[11:01:44.137] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:44.138] Searching for globals...
[11:01:44.143] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[11:01:44.143] Searching for globals ... DONE
[11:01:44.144] Resolving globals: FALSE
[11:01:44.145] The total size of the 1 globals is 356 bytes (356 bytes)
[11:01:44.145] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:01:44.145] - globals: [1] ‘data’
[11:01:44.146] - packages: [1] ‘future’
[11:01:44.146] getGlobalsAndPackages() ... DONE
[11:01:44.146] run() for ‘Future’ ...
[11:01:44.147] - state: ‘created’
[11:01:44.147] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:44.147] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:44.148] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:44.148]   - Field: ‘label’
[11:01:44.148]   - Field: ‘local’
[11:01:44.148]   - Field: ‘owner’
[11:01:44.148]   - Field: ‘envir’
[11:01:44.149]   - Field: ‘packages’
[11:01:44.149]   - Field: ‘gc’
[11:01:44.149]   - Field: ‘conditions’
[11:01:44.149]   - Field: ‘expr’
[11:01:44.149]   - Field: ‘uuid’
[11:01:44.150]   - Field: ‘seed’
[11:01:44.150]   - Field: ‘version’
[11:01:44.150]   - Field: ‘result’
[11:01:44.150]   - Field: ‘asynchronous’
[11:01:44.150]   - Field: ‘calls’
[11:01:44.150]   - Field: ‘globals’
[11:01:44.151]   - Field: ‘stdout’
[11:01:44.151]   - Field: ‘earlySignal’
[11:01:44.151]   - Field: ‘lazy’
[11:01:44.151]   - Field: ‘state’
[11:01:44.151] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:44.152] - Launch lazy future ...
[11:01:44.152] Packages needed by the future expression (n = 1): ‘future’
[11:01:44.152] Packages needed by future strategies (n = 1): ‘future’
[11:01:44.153] {
[11:01:44.153]     {
[11:01:44.153]         {
[11:01:44.153]             ...future.startTime <- base::Sys.time()
[11:01:44.153]             {
[11:01:44.153]                 {
[11:01:44.153]                   {
[11:01:44.153]                     {
[11:01:44.153]                       base::local({
[11:01:44.153]                         has_future <- base::requireNamespace("future", 
[11:01:44.153]                           quietly = TRUE)
[11:01:44.153]                         if (has_future) {
[11:01:44.153]                           ns <- base::getNamespace("future")
[11:01:44.153]                           version <- ns[[".package"]][["version"]]
[11:01:44.153]                           if (is.null(version)) 
[11:01:44.153]                             version <- utils::packageVersion("future")
[11:01:44.153]                         }
[11:01:44.153]                         else {
[11:01:44.153]                           version <- NULL
[11:01:44.153]                         }
[11:01:44.153]                         if (!has_future || version < "1.8.0") {
[11:01:44.153]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:44.153]                             "", base::R.version$version.string), 
[11:01:44.153]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:44.153]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:44.153]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:44.153]                               "release", "version")], collapse = " "), 
[11:01:44.153]                             hostname = base::Sys.info()[["nodename"]])
[11:01:44.153]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:44.153]                             info)
[11:01:44.153]                           info <- base::paste(info, collapse = "; ")
[11:01:44.153]                           if (!has_future) {
[11:01:44.153]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:44.153]                               info)
[11:01:44.153]                           }
[11:01:44.153]                           else {
[11:01:44.153]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:44.153]                               info, version)
[11:01:44.153]                           }
[11:01:44.153]                           base::stop(msg)
[11:01:44.153]                         }
[11:01:44.153]                       })
[11:01:44.153]                     }
[11:01:44.153]                     base::local({
[11:01:44.153]                       for (pkg in "future") {
[11:01:44.153]                         base::loadNamespace(pkg)
[11:01:44.153]                         base::library(pkg, character.only = TRUE)
[11:01:44.153]                       }
[11:01:44.153]                     })
[11:01:44.153]                   }
[11:01:44.153]                   ...future.strategy.old <- future::plan("list")
[11:01:44.153]                   options(future.plan = NULL)
[11:01:44.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:44.153]                   future::plan(list(function (..., workers = availableCores(), 
[11:01:44.153]                     lazy = FALSE, rscript_libs = .libPaths(), 
[11:01:44.153]                     envir = parent.frame()) 
[11:01:44.153]                   {
[11:01:44.153]                     if (is.function(workers)) 
[11:01:44.153]                       workers <- workers()
[11:01:44.153]                     workers <- structure(as.integer(workers), 
[11:01:44.153]                       class = class(workers))
[11:01:44.153]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[11:01:44.153]                       workers >= 1)
[11:01:44.153]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[11:01:44.153]                       return(sequential(..., lazy = TRUE, envir = envir))
[11:01:44.153]                     }
[11:01:44.153]                     future <- MultisessionFuture(..., workers = workers, 
[11:01:44.153]                       lazy = lazy, rscript_libs = rscript_libs, 
[11:01:44.153]                       envir = envir)
[11:01:44.153]                     if (!future$lazy) 
[11:01:44.153]                       future <- run(future)
[11:01:44.153]                     invisible(future)
[11:01:44.153]                   }), .cleanup = FALSE, .init = FALSE)
[11:01:44.153]                 }
[11:01:44.153]                 ...future.workdir <- getwd()
[11:01:44.153]             }
[11:01:44.153]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:44.153]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:44.153]         }
[11:01:44.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:44.153]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:44.153]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:44.153]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:44.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:44.153]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:44.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:44.153]             base::names(...future.oldOptions))
[11:01:44.153]     }
[11:01:44.153]     if (FALSE) {
[11:01:44.153]     }
[11:01:44.153]     else {
[11:01:44.153]         if (TRUE) {
[11:01:44.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:44.153]                 open = "w")
[11:01:44.153]         }
[11:01:44.153]         else {
[11:01:44.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:44.153]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:44.153]         }
[11:01:44.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:44.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:44.153]             base::sink(type = "output", split = FALSE)
[11:01:44.153]             base::close(...future.stdout)
[11:01:44.153]         }, add = TRUE)
[11:01:44.153]     }
[11:01:44.153]     ...future.frame <- base::sys.nframe()
[11:01:44.153]     ...future.conditions <- base::list()
[11:01:44.153]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:44.153]     if (FALSE) {
[11:01:44.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:44.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:44.153]     }
[11:01:44.153]     ...future.result <- base::tryCatch({
[11:01:44.153]         base::withCallingHandlers({
[11:01:44.153]             ...future.value <- base::withVisible(base::local({
[11:01:44.153]                 a %<-% subset(data, x < 3)$y
[11:01:44.153]                 a
[11:01:44.153]             }))
[11:01:44.153]             future::FutureResult(value = ...future.value$value, 
[11:01:44.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:44.153]                   ...future.rng), globalenv = if (FALSE) 
[11:01:44.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:44.153]                     ...future.globalenv.names))
[11:01:44.153]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:44.153]         }, condition = base::local({
[11:01:44.153]             c <- base::c
[11:01:44.153]             inherits <- base::inherits
[11:01:44.153]             invokeRestart <- base::invokeRestart
[11:01:44.153]             length <- base::length
[11:01:44.153]             list <- base::list
[11:01:44.153]             seq.int <- base::seq.int
[11:01:44.153]             signalCondition <- base::signalCondition
[11:01:44.153]             sys.calls <- base::sys.calls
[11:01:44.153]             `[[` <- base::`[[`
[11:01:44.153]             `+` <- base::`+`
[11:01:44.153]             `<<-` <- base::`<<-`
[11:01:44.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:44.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:44.153]                   3L)]
[11:01:44.153]             }
[11:01:44.153]             function(cond) {
[11:01:44.153]                 is_error <- inherits(cond, "error")
[11:01:44.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:44.153]                   NULL)
[11:01:44.153]                 if (is_error) {
[11:01:44.153]                   sessionInformation <- function() {
[11:01:44.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:44.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:44.153]                       search = base::search(), system = base::Sys.info())
[11:01:44.153]                   }
[11:01:44.153]                   ...future.conditions[[length(...future.conditions) + 
[11:01:44.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:44.153]                     cond$call), session = sessionInformation(), 
[11:01:44.153]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:44.153]                   signalCondition(cond)
[11:01:44.153]                 }
[11:01:44.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:44.153]                 "immediateCondition"))) {
[11:01:44.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:44.153]                   ...future.conditions[[length(...future.conditions) + 
[11:01:44.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:44.153]                   if (TRUE && !signal) {
[11:01:44.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.153]                     {
[11:01:44.153]                       inherits <- base::inherits
[11:01:44.153]                       invokeRestart <- base::invokeRestart
[11:01:44.153]                       is.null <- base::is.null
[11:01:44.153]                       muffled <- FALSE
[11:01:44.153]                       if (inherits(cond, "message")) {
[11:01:44.153]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:44.153]                         if (muffled) 
[11:01:44.153]                           invokeRestart("muffleMessage")
[11:01:44.153]                       }
[11:01:44.153]                       else if (inherits(cond, "warning")) {
[11:01:44.153]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:44.153]                         if (muffled) 
[11:01:44.153]                           invokeRestart("muffleWarning")
[11:01:44.153]                       }
[11:01:44.153]                       else if (inherits(cond, "condition")) {
[11:01:44.153]                         if (!is.null(pattern)) {
[11:01:44.153]                           computeRestarts <- base::computeRestarts
[11:01:44.153]                           grepl <- base::grepl
[11:01:44.153]                           restarts <- computeRestarts(cond)
[11:01:44.153]                           for (restart in restarts) {
[11:01:44.153]                             name <- restart$name
[11:01:44.153]                             if (is.null(name)) 
[11:01:44.153]                               next
[11:01:44.153]                             if (!grepl(pattern, name)) 
[11:01:44.153]                               next
[11:01:44.153]                             invokeRestart(restart)
[11:01:44.153]                             muffled <- TRUE
[11:01:44.153]                             break
[11:01:44.153]                           }
[11:01:44.153]                         }
[11:01:44.153]                       }
[11:01:44.153]                       invisible(muffled)
[11:01:44.153]                     }
[11:01:44.153]                     muffleCondition(cond, pattern = "^muffle")
[11:01:44.153]                   }
[11:01:44.153]                 }
[11:01:44.153]                 else {
[11:01:44.153]                   if (TRUE) {
[11:01:44.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.153]                     {
[11:01:44.153]                       inherits <- base::inherits
[11:01:44.153]                       invokeRestart <- base::invokeRestart
[11:01:44.153]                       is.null <- base::is.null
[11:01:44.153]                       muffled <- FALSE
[11:01:44.153]                       if (inherits(cond, "message")) {
[11:01:44.153]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:44.153]                         if (muffled) 
[11:01:44.153]                           invokeRestart("muffleMessage")
[11:01:44.153]                       }
[11:01:44.153]                       else if (inherits(cond, "warning")) {
[11:01:44.153]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:44.153]                         if (muffled) 
[11:01:44.153]                           invokeRestart("muffleWarning")
[11:01:44.153]                       }
[11:01:44.153]                       else if (inherits(cond, "condition")) {
[11:01:44.153]                         if (!is.null(pattern)) {
[11:01:44.153]                           computeRestarts <- base::computeRestarts
[11:01:44.153]                           grepl <- base::grepl
[11:01:44.153]                           restarts <- computeRestarts(cond)
[11:01:44.153]                           for (restart in restarts) {
[11:01:44.153]                             name <- restart$name
[11:01:44.153]                             if (is.null(name)) 
[11:01:44.153]                               next
[11:01:44.153]                             if (!grepl(pattern, name)) 
[11:01:44.153]                               next
[11:01:44.153]                             invokeRestart(restart)
[11:01:44.153]                             muffled <- TRUE
[11:01:44.153]                             break
[11:01:44.153]                           }
[11:01:44.153]                         }
[11:01:44.153]                       }
[11:01:44.153]                       invisible(muffled)
[11:01:44.153]                     }
[11:01:44.153]                     muffleCondition(cond, pattern = "^muffle")
[11:01:44.153]                   }
[11:01:44.153]                 }
[11:01:44.153]             }
[11:01:44.153]         }))
[11:01:44.153]     }, error = function(ex) {
[11:01:44.153]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:44.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:44.153]                 ...future.rng), started = ...future.startTime, 
[11:01:44.153]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:44.153]             version = "1.8"), class = "FutureResult")
[11:01:44.153]     }, finally = {
[11:01:44.153]         if (!identical(...future.workdir, getwd())) 
[11:01:44.153]             setwd(...future.workdir)
[11:01:44.153]         {
[11:01:44.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:44.153]                 ...future.oldOptions$nwarnings <- NULL
[11:01:44.153]             }
[11:01:44.153]             base::options(...future.oldOptions)
[11:01:44.153]             if (.Platform$OS.type == "windows") {
[11:01:44.153]                 old_names <- names(...future.oldEnvVars)
[11:01:44.153]                 envs <- base::Sys.getenv()
[11:01:44.153]                 names <- names(envs)
[11:01:44.153]                 common <- intersect(names, old_names)
[11:01:44.153]                 added <- setdiff(names, old_names)
[11:01:44.153]                 removed <- setdiff(old_names, names)
[11:01:44.153]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:44.153]                   envs[common]]
[11:01:44.153]                 NAMES <- toupper(changed)
[11:01:44.153]                 args <- list()
[11:01:44.153]                 for (kk in seq_along(NAMES)) {
[11:01:44.153]                   name <- changed[[kk]]
[11:01:44.153]                   NAME <- NAMES[[kk]]
[11:01:44.153]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.153]                     next
[11:01:44.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:44.153]                 }
[11:01:44.153]                 NAMES <- toupper(added)
[11:01:44.153]                 for (kk in seq_along(NAMES)) {
[11:01:44.153]                   name <- added[[kk]]
[11:01:44.153]                   NAME <- NAMES[[kk]]
[11:01:44.153]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.153]                     next
[11:01:44.153]                   args[[name]] <- ""
[11:01:44.153]                 }
[11:01:44.153]                 NAMES <- toupper(removed)
[11:01:44.153]                 for (kk in seq_along(NAMES)) {
[11:01:44.153]                   name <- removed[[kk]]
[11:01:44.153]                   NAME <- NAMES[[kk]]
[11:01:44.153]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.153]                     next
[11:01:44.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:44.153]                 }
[11:01:44.153]                 if (length(args) > 0) 
[11:01:44.153]                   base::do.call(base::Sys.setenv, args = args)
[11:01:44.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:44.153]             }
[11:01:44.153]             else {
[11:01:44.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:44.153]             }
[11:01:44.153]             {
[11:01:44.153]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:44.153]                   0L) {
[11:01:44.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:44.153]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:44.153]                   base::options(opts)
[11:01:44.153]                 }
[11:01:44.153]                 {
[11:01:44.153]                   {
[11:01:44.153]                     NULL
[11:01:44.153]                     RNGkind("Mersenne-Twister")
[11:01:44.153]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:44.153]                       inherits = FALSE)
[11:01:44.153]                   }
[11:01:44.153]                   options(future.plan = NULL)
[11:01:44.153]                   if (is.na(NA_character_)) 
[11:01:44.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:44.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:44.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:44.153]                     .init = FALSE)
[11:01:44.153]                 }
[11:01:44.153]             }
[11:01:44.153]         }
[11:01:44.153]     })
[11:01:44.153]     if (TRUE) {
[11:01:44.153]         base::sink(type = "output", split = FALSE)
[11:01:44.153]         if (TRUE) {
[11:01:44.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:44.153]         }
[11:01:44.153]         else {
[11:01:44.153]             ...future.result["stdout"] <- base::list(NULL)
[11:01:44.153]         }
[11:01:44.153]         base::close(...future.stdout)
[11:01:44.153]         ...future.stdout <- NULL
[11:01:44.153]     }
[11:01:44.153]     ...future.result$conditions <- ...future.conditions
[11:01:44.153]     ...future.result$finished <- base::Sys.time()
[11:01:44.153]     ...future.result
[11:01:44.153] }
[11:01:44.156] assign_globals() ...
[11:01:44.156] List of 1
[11:01:44.156]  $ data:'data.frame':	5 obs. of  2 variables:
[11:01:44.156]   ..$ x: int [1:5] 1 2 3 4 5
[11:01:44.156]   ..$ y: int [1:5] 1 2 3 4 5
[11:01:44.156]  - attr(*, "where")=List of 1
[11:01:44.156]   ..$ data:<environment: R_EmptyEnv> 
[11:01:44.156]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:44.156]  - attr(*, "resolved")= logi FALSE
[11:01:44.156]  - attr(*, "total_size")= num 356
[11:01:44.156]  - attr(*, "already-done")= logi TRUE
[11:01:44.160] - copied ‘data’ to environment
[11:01:44.160] assign_globals() ... done
[11:01:44.160] plan(): Setting new future strategy stack:
[11:01:44.160] List of future strategies:
[11:01:44.160] 1. multisession:
[11:01:44.160]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:44.160]    - tweaked: FALSE
[11:01:44.160]    - call: plan(list(sequential, strategy))
[11:01:44.162] plan(): nbrOfWorkers() = 2
[11:01:44.567] plan(): Setting new future strategy stack:
[11:01:44.567] List of future strategies:
[11:01:44.567] 1. sequential:
[11:01:44.567]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:44.567]    - tweaked: FALSE
[11:01:44.567]    - call: plan(list(sequential, strategy))
[11:01:44.567] 2. multisession:
[11:01:44.567]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:44.567]    - tweaked: FALSE
[11:01:44.567]    - call: plan(list(sequential, strategy))
[11:01:44.568] plan(): nbrOfWorkers() = 1
[11:01:44.568] SequentialFuture started (and completed)
[11:01:44.568] signalConditions() ...
[11:01:44.568]  - include = ‘immediateCondition’
[11:01:44.568]  - exclude = 
[11:01:44.569]  - resignal = FALSE
[11:01:44.569]  - Number of conditions: 64
[11:01:44.569] signalConditions() ... done
[11:01:44.569] - Launch lazy future ... done
[11:01:44.569] run() for ‘SequentialFuture’ ... done
[11:01:44.569] signalConditions() ...
[11:01:44.569]  - include = ‘immediateCondition’
[11:01:44.569]  - exclude = 
[11:01:44.569]  - resignal = FALSE
[11:01:44.569]  - Number of conditions: 64
[11:01:44.570] signalConditions() ... done
[11:01:44.570] Future state: ‘finished’
[11:01:44.570] signalConditions() ...
[11:01:44.570]  - include = ‘condition’
[11:01:44.570]  - exclude = ‘immediateCondition’
[11:01:44.570]  - resignal = TRUE
[11:01:44.570]  - Number of conditions: 64
[11:01:44.570]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.163] getGlobalsAndPackages() ...
[11:01:44.570]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:44.570]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.180] Searching for globals...
[11:01:44.571]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.181] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[11:01:44.571]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.182] Searching for globals ... DONE
[11:01:44.571]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.182] Resolving globals: FALSE
[11:01:44.571]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.182] The total size of the 1 globals is 356 bytes (356 bytes)
[11:01:44.571]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.182] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:01:44.571]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.183] - globals: [1] ‘data’
[11:01:44.571]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.183] 
[11:01:44.571]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.183] getGlobalsAndPackages() ... DONE
[11:01:44.571]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.183] run() for ‘Future’ ...
[11:01:44.572]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.183] - state: ‘created’
[11:01:44.572]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.183] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:44.572]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.438] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:44.572]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:44.572]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.439]   - Field: ‘node’
[11:01:44.572]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.439]   - Field: ‘label’
[11:01:44.572]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.439]   - Field: ‘local’
[11:01:44.572]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.439]   - Field: ‘owner’
[11:01:44.573]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.439]   - Field: ‘envir’
[11:01:44.573]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.439]   - Field: ‘workers’
[11:01:44.573]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.439]   - Field: ‘packages’
[11:01:44.573]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.440]   - Field: ‘gc’
[11:01:44.573]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.440]   - Field: ‘conditions’
[11:01:44.573]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.440]   - Field: ‘persistent’
[11:01:44.573]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.440]   - Field: ‘expr’
[11:01:44.573]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.440]   - Field: ‘uuid’
[11:01:44.574]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.440]   - Field: ‘seed’
[11:01:44.574]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.440]   - Field: ‘version’
[11:01:44.574]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.440]   - Field: ‘result’
[11:01:44.574]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.440]   - Field: ‘asynchronous’
[11:01:44.574]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.440]   - Field: ‘calls’
[11:01:44.574]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.441]   - Field: ‘globals’
[11:01:44.574]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.441]   - Field: ‘stdout’
[11:01:44.574]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.441]   - Field: ‘earlySignal’
[11:01:44.575]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.441]   - Field: ‘lazy’
[11:01:44.575]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.441]   - Field: ‘state’
[11:01:44.575]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:44.575]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.441] - Launch lazy future ...
[11:01:44.575]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.441] Packages needed by the future expression (n = 0): <none>
[11:01:44.575]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.442] Packages needed by future strategies (n = 0): <none>
[11:01:44.575]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.442] {
[11:01:44.442]     {
[11:01:44.442]         {
[11:01:44.442]             ...future.startTime <- base::Sys.time()
[11:01:44.442]             {
[11:01:44.442]                 {
[11:01:44.442]                   {
[11:01:44.442]                     {
[11:01:44.442]                       base::local({
[11:01:44.442]                         has_future <- base::requireNamespace("future", 
[11:01:44.442]                           quietly = TRUE)
[11:01:44.442]                         if (has_future) {
[11:01:44.442]                           ns <- base::getNamespace("future")
[11:01:44.442]                           version <- ns[[".package"]][["version"]]
[11:01:44.442]                           if (is.null(version)) 
[11:01:44.442]                             version <- utils::packageVersion("future")
[11:01:44.442]                         }
[11:01:44.442]                         else {
[11:01:44.442]                           version <- NULL
[11:01:44.442]                         }
[11:01:44.442]                         if (!has_future || version < "1.8.0") {
[11:01:44.442]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:44.442]                             "", base::R.version$version.string), 
[11:01:44.442]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:44.442]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:44.442]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:44.442]                               "release", "version")], collapse = " "), 
[11:01:44.442]                             hostname = base::Sys.info()[["nodename"]])
[11:01:44.442]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:44.442]                             info)
[11:01:44.442]                           info <- base::paste(info, collapse = "; ")
[11:01:44.442]                           if (!has_future) {
[11:01:44.442]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:44.442]                               info)
[11:01:44.442]                           }
[11:01:44.442]                           else {
[11:01:44.442]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:44.442]                               info, version)
[11:01:44.442]                           }
[11:01:44.442]                           base::stop(msg)
[11:01:44.442]                         }
[11:01:44.442]                       })
[11:01:44.442]                     }
[11:01:44.442]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:44.442]                     base::options(mc.cores = 1L)
[11:01:44.442]                   }
[11:01:44.442]                   ...future.strategy.old <- future::plan("list")
[11:01:44.442]                   options(future.plan = NULL)
[11:01:44.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:44.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:44.442]                 }
[11:01:44.442]                 ...future.workdir <- getwd()
[11:01:44.442]             }
[11:01:44.442]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:44.442]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:44.442]         }
[11:01:44.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:44.442]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:44.442]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:44.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:44.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:44.442]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:44.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:44.442]             base::names(...future.oldOptions))
[11:01:44.442]     }
[11:01:44.442]     if (FALSE) {
[11:01:44.442]     }
[11:01:44.442]     else {
[11:01:44.442]         if (TRUE) {
[11:01:44.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:44.442]                 open = "w")
[11:01:44.442]         }
[11:01:44.442]         else {
[11:01:44.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:44.442]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:44.442]         }
[11:01:44.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:44.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:44.442]             base::sink(type = "output", split = FALSE)
[11:01:44.442]             base::close(...future.stdout)
[11:01:44.442]         }, add = TRUE)
[11:01:44.442]     }
[11:01:44.442]     ...future.frame <- base::sys.nframe()
[11:01:44.442]     ...future.conditions <- base::list()
[11:01:44.442]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:44.442]     if (FALSE) {
[11:01:44.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:44.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:44.442]     }
[11:01:44.442]     ...future.result <- base::tryCatch({
[11:01:44.442]         base::withCallingHandlers({
[11:01:44.442]             ...future.value <- base::withVisible(base::local({
[11:01:44.442]                 ...future.makeSendCondition <- base::local({
[11:01:44.442]                   sendCondition <- NULL
[11:01:44.442]                   function(frame = 1L) {
[11:01:44.442]                     if (is.function(sendCondition)) 
[11:01:44.442]                       return(sendCondition)
[11:01:44.442]                     ns <- getNamespace("parallel")
[11:01:44.442]                     if (exists("sendData", mode = "function", 
[11:01:44.442]                       envir = ns)) {
[11:01:44.442]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:44.442]                         envir = ns)
[11:01:44.442]                       envir <- sys.frame(frame)
[11:01:44.442]                       master <- NULL
[11:01:44.442]                       while (!identical(envir, .GlobalEnv) && 
[11:01:44.442]                         !identical(envir, emptyenv())) {
[11:01:44.442]                         if (exists("master", mode = "list", envir = envir, 
[11:01:44.442]                           inherits = FALSE)) {
[11:01:44.442]                           master <- get("master", mode = "list", 
[11:01:44.442]                             envir = envir, inherits = FALSE)
[11:01:44.442]                           if (inherits(master, c("SOCKnode", 
[11:01:44.442]                             "SOCK0node"))) {
[11:01:44.442]                             sendCondition <<- function(cond) {
[11:01:44.442]                               data <- list(type = "VALUE", value = cond, 
[11:01:44.442]                                 success = TRUE)
[11:01:44.442]                               parallel_sendData(master, data)
[11:01:44.442]                             }
[11:01:44.442]                             return(sendCondition)
[11:01:44.442]                           }
[11:01:44.442]                         }
[11:01:44.442]                         frame <- frame + 1L
[11:01:44.442]                         envir <- sys.frame(frame)
[11:01:44.442]                       }
[11:01:44.442]                     }
[11:01:44.442]                     sendCondition <<- function(cond) NULL
[11:01:44.442]                   }
[11:01:44.442]                 })
[11:01:44.442]                 withCallingHandlers({
[11:01:44.442]                   subset(data, x < 3)$y
[11:01:44.442]                 }, immediateCondition = function(cond) {
[11:01:44.442]                   sendCondition <- ...future.makeSendCondition()
[11:01:44.442]                   sendCondition(cond)
[11:01:44.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.442]                   {
[11:01:44.442]                     inherits <- base::inherits
[11:01:44.442]                     invokeRestart <- base::invokeRestart
[11:01:44.442]                     is.null <- base::is.null
[11:01:44.442]                     muffled <- FALSE
[11:01:44.442]                     if (inherits(cond, "message")) {
[11:01:44.442]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:44.442]                       if (muffled) 
[11:01:44.442]                         invokeRestart("muffleMessage")
[11:01:44.442]                     }
[11:01:44.442]                     else if (inherits(cond, "warning")) {
[11:01:44.442]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:44.442]                       if (muffled) 
[11:01:44.442]                         invokeRestart("muffleWarning")
[11:01:44.442]                     }
[11:01:44.442]                     else if (inherits(cond, "condition")) {
[11:01:44.442]                       if (!is.null(pattern)) {
[11:01:44.442]                         computeRestarts <- base::computeRestarts
[11:01:44.442]                         grepl <- base::grepl
[11:01:44.442]                         restarts <- computeRestarts(cond)
[11:01:44.442]                         for (restart in restarts) {
[11:01:44.442]                           name <- restart$name
[11:01:44.442]                           if (is.null(name)) 
[11:01:44.442]                             next
[11:01:44.442]                           if (!grepl(pattern, name)) 
[11:01:44.442]                             next
[11:01:44.442]                           invokeRestart(restart)
[11:01:44.442]                           muffled <- TRUE
[11:01:44.442]                           break
[11:01:44.442]                         }
[11:01:44.442]                       }
[11:01:44.442]                     }
[11:01:44.442]                     invisible(muffled)
[11:01:44.442]                   }
[11:01:44.442]                   muffleCondition(cond)
[11:01:44.442]                 })
[11:01:44.442]             }))
[11:01:44.442]             future::FutureResult(value = ...future.value$value, 
[11:01:44.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:44.442]                   ...future.rng), globalenv = if (FALSE) 
[11:01:44.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:44.442]                     ...future.globalenv.names))
[11:01:44.442]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:44.442]         }, condition = base::local({
[11:01:44.442]             c <- base::c
[11:01:44.442]             inherits <- base::inherits
[11:01:44.442]             invokeRestart <- base::invokeRestart
[11:01:44.442]             length <- base::length
[11:01:44.442]             list <- base::list
[11:01:44.442]             seq.int <- base::seq.int
[11:01:44.442]             signalCondition <- base::signalCondition
[11:01:44.442]             sys.calls <- base::sys.calls
[11:01:44.442]             `[[` <- base::`[[`
[11:01:44.442]             `+` <- base::`+`
[11:01:44.442]             `<<-` <- base::`<<-`
[11:01:44.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:44.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:44.442]                   3L)]
[11:01:44.442]             }
[11:01:44.442]             function(cond) {
[11:01:44.442]                 is_error <- inherits(cond, "error")
[11:01:44.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:44.442]                   NULL)
[11:01:44.442]                 if (is_error) {
[11:01:44.442]                   sessionInformation <- function() {
[11:01:44.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:44.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:44.442]                       search = base::search(), system = base::Sys.info())
[11:01:44.442]                   }
[11:01:44.442]                   ...future.conditions[[length(...future.conditions) + 
[11:01:44.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:44.442]                     cond$call), session = sessionInformation(), 
[11:01:44.442]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:44.442]                   signalCondition(cond)
[11:01:44.442]                 }
[11:01:44.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:44.442]                 "immediateCondition"))) {
[11:01:44.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:44.442]                   ...future.conditions[[length(...future.conditions) + 
[11:01:44.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:44.442]                   if (TRUE && !signal) {
[11:01:44.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.442]                     {
[11:01:44.442]                       inherits <- base::inherits
[11:01:44.442]                       invokeRestart <- base::invokeRestart
[11:01:44.442]                       is.null <- base::is.null
[11:01:44.442]                       muffled <- FALSE
[11:01:44.442]                       if (inherits(cond, "message")) {
[11:01:44.442]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:44.442]                         if (muffled) 
[11:01:44.442]                           invokeRestart("muffleMessage")
[11:01:44.442]                       }
[11:01:44.442]                       else if (inherits(cond, "warning")) {
[11:01:44.442]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:44.442]                         if (muffled) 
[11:01:44.442]                           invokeRestart("muffleWarning")
[11:01:44.442]                       }
[11:01:44.442]                       else if (inherits(cond, "condition")) {
[11:01:44.442]                         if (!is.null(pattern)) {
[11:01:44.442]                           computeRestarts <- base::computeRestarts
[11:01:44.442]                           grepl <- base::grepl
[11:01:44.442]                           restarts <- computeRestarts(cond)
[11:01:44.442]                           for (restart in restarts) {
[11:01:44.442]                             name <- restart$name
[11:01:44.442]                             if (is.null(name)) 
[11:01:44.442]                               next
[11:01:44.442]                             if (!grepl(pattern, name)) 
[11:01:44.442]                               next
[11:01:44.442]                             invokeRestart(restart)
[11:01:44.442]                             muffled <- TRUE
[11:01:44.442]                             break
[11:01:44.442]                           }
[11:01:44.442]                         }
[11:01:44.442]                       }
[11:01:44.442]                       invisible(muffled)
[11:01:44.442]                     }
[11:01:44.442]                     muffleCondition(cond, pattern = "^muffle")
[11:01:44.442]                   }
[11:01:44.442]                 }
[11:01:44.442]                 else {
[11:01:44.442]                   if (TRUE) {
[11:01:44.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.442]                     {
[11:01:44.442]                       inherits <- base::inherits
[11:01:44.442]                       invokeRestart <- base::invokeRestart
[11:01:44.442]                       is.null <- base::is.null
[11:01:44.442]                       muffled <- FALSE
[11:01:44.442]                       if (inherits(cond, "message")) {
[11:01:44.442]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:44.442]                         if (muffled) 
[11:01:44.442]                           invokeRestart("muffleMessage")
[11:01:44.442]                       }
[11:01:44.442]                       else if (inherits(cond, "warning")) {
[11:01:44.442]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:44.442]                         if (muffled) 
[11:01:44.442]                           invokeRestart("muffleWarning")
[11:01:44.442]                       }
[11:01:44.442]                       else if (inherits(cond, "condition")) {
[11:01:44.442]                         if (!is.null(pattern)) {
[11:01:44.442]                           computeRestarts <- base::computeRestarts
[11:01:44.442]                           grepl <- base::grepl
[11:01:44.442]                           restarts <- computeRestarts(cond)
[11:01:44.442]                           for (restart in restarts) {
[11:01:44.442]                             name <- restart$name
[11:01:44.442]                             if (is.null(name)) 
[11:01:44.442]                               next
[11:01:44.442]                             if (!grepl(pattern, name)) 
[11:01:44.442]                               next
[11:01:44.442]                             invokeRestart(restart)
[11:01:44.442]                             muffled <- TRUE
[11:01:44.442]                             break
[11:01:44.442]                           }
[11:01:44.442]                         }
[11:01:44.442]                       }
[11:01:44.442]                       invisible(muffled)
[11:01:44.442]                     }
[11:01:44.442]                     muffleCondition(cond, pattern = "^muffle")
[11:01:44.442]                   }
[11:01:44.442]                 }
[11:01:44.442]             }
[11:01:44.442]         }))
[11:01:44.442]     }, error = function(ex) {
[11:01:44.442]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:44.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:44.442]                 ...future.rng), started = ...future.startTime, 
[11:01:44.442]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:44.442]             version = "1.8"), class = "FutureResult")
[11:01:44.442]     }, finally = {
[11:01:44.442]         if (!identical(...future.workdir, getwd())) 
[11:01:44.442]             setwd(...future.workdir)
[11:01:44.442]         {
[11:01:44.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:44.442]                 ...future.oldOptions$nwarnings <- NULL
[11:01:44.442]             }
[11:01:44.442]             base::options(...future.oldOptions)
[11:01:44.442]             if (.Platform$OS.type == "windows") {
[11:01:44.442]                 old_names <- names(...future.oldEnvVars)
[11:01:44.442]                 envs <- base::Sys.getenv()
[11:01:44.442]                 names <- names(envs)
[11:01:44.442]                 common <- intersect(names, old_names)
[11:01:44.442]                 added <- setdiff(names, old_names)
[11:01:44.442]                 removed <- setdiff(old_names, names)
[11:01:44.442]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:44.442]                   envs[common]]
[11:01:44.442]                 NAMES <- toupper(changed)
[11:01:44.442]                 args <- list()
[11:01:44.442]                 for (kk in seq_along(NAMES)) {
[11:01:44.442]                   name <- changed[[kk]]
[11:01:44.442]                   NAME <- NAMES[[kk]]
[11:01:44.442]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.442]                     next
[11:01:44.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:44.442]                 }
[11:01:44.442]                 NAMES <- toupper(added)
[11:01:44.442]                 for (kk in seq_along(NAMES)) {
[11:01:44.442]                   name <- added[[kk]]
[11:01:44.442]                   NAME <- NAMES[[kk]]
[11:01:44.442]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.442]                     next
[11:01:44.442]                   args[[name]] <- ""
[11:01:44.442]                 }
[11:01:44.442]                 NAMES <- toupper(removed)
[11:01:44.442]                 for (kk in seq_along(NAMES)) {
[11:01:44.442]                   name <- removed[[kk]]
[11:01:44.442]                   NAME <- NAMES[[kk]]
[11:01:44.442]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.442]                     next
[11:01:44.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:44.442]                 }
[11:01:44.442]                 if (length(args) > 0) 
[11:01:44.442]                   base::do.call(base::Sys.setenv, args = args)
[11:01:44.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:44.442]             }
[11:01:44.442]             else {
[11:01:44.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:44.442]             }
[11:01:44.442]             {
[11:01:44.442]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:44.442]                   0L) {
[11:01:44.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:44.442]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:44.442]                   base::options(opts)
[11:01:44.442]                 }
[11:01:44.442]                 {
[11:01:44.442]                   {
[11:01:44.442]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:44.442]                     NULL
[11:01:44.442]                   }
[11:01:44.442]                   options(future.plan = NULL)
[11:01:44.442]                   if (is.na(NA_character_)) 
[11:01:44.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:44.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:44.442]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:44.442]                     .init = FALSE)
[11:01:44.442]                 }
[11:01:44.442]             }
[11:01:44.442]         }
[11:01:44.442]     })
[11:01:44.442]     if (TRUE) {
[11:01:44.442]         base::sink(type = "output", split = FALSE)
[11:01:44.442]         if (TRUE) {
[11:01:44.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:44.442]         }
[11:01:44.442]         else {
[11:01:44.442]             ...future.result["stdout"] <- base::list(NULL)
[11:01:44.442]         }
[11:01:44.442]         base::close(...future.stdout)
[11:01:44.442]         ...future.stdout <- NULL
[11:01:44.442]     }
[11:01:44.442]     ...future.result$conditions <- ...future.conditions
[11:01:44.442]     ...future.result$finished <- base::Sys.time()
[11:01:44.442]     ...future.result
[11:01:44.442] }
[11:01:44.576]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.493] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[11:01:44.576]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.493] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[11:01:44.576]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.493] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[11:01:44.576]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.493] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[11:01:44.576]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.494] MultisessionFuture started
[11:01:44.576]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.494] - Launch lazy future ... done
[11:01:44.576]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.494] run() for ‘MultisessionFuture’ ... done
[11:01:44.576]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.494] result() for ClusterFuture ...
[11:01:44.577]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.494] receiveMessageFromWorker() for ClusterFuture ...
[11:01:44.577]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.494] - Validating connection of MultisessionFuture
[11:01:44.577]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.565] - received message: FutureResult
[11:01:44.577]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.566] - Received FutureResult
[11:01:44.577]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.566] - Erased future from FutureRegistry
[11:01:44.577]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.566] result() for ClusterFuture ...
[11:01:44.577]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.566] - result already collected: FutureResult
[11:01:44.577]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.566] result() for ClusterFuture ... done
[11:01:44.577]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.566] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:44.578]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.566] result() for ClusterFuture ... done
[11:01:44.578]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.566] result() for ClusterFuture ...
[11:01:44.578]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.567] - result already collected: FutureResult
[11:01:44.578]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.567] result() for ClusterFuture ... done
[11:01:44.578] signalConditions() ... done
[11:01:44.578] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[11:01:44.579] Searching for globals...
[11:01:44.579] - globals found: [3] ‘{’, ‘plan’, ‘sequential’
[11:01:44.580] Searching for globals ... DONE
[11:01:44.580] Resolving globals: FALSE
[11:01:44.580] 
[11:01:44.580] - packages: [1] ‘future’
[11:01:44.580] getGlobalsAndPackages() ... DONE
[11:01:44.580] run() for ‘Future’ ...
[11:01:44.581] - state: ‘created’
[11:01:44.581] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:44.581] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:44.581] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:44.581]   - Field: ‘label’
[11:01:44.581]   - Field: ‘local’
[11:01:44.581]   - Field: ‘owner’
[11:01:44.581]   - Field: ‘envir’
[11:01:44.581]   - Field: ‘packages’
[11:01:44.582]   - Field: ‘gc’
[11:01:44.582]   - Field: ‘conditions’
[11:01:44.582]   - Field: ‘expr’
[11:01:44.582]   - Field: ‘uuid’
[11:01:44.582]   - Field: ‘seed’
[11:01:44.582]   - Field: ‘version’
[11:01:44.582]   - Field: ‘result’
[11:01:44.582]   - Field: ‘asynchronous’
[11:01:44.582]   - Field: ‘calls’
[11:01:44.582]   - Field: ‘globals’
[11:01:44.582]   - Field: ‘stdout’
[11:01:44.582]   - Field: ‘earlySignal’
[11:01:44.583]   - Field: ‘lazy’
[11:01:44.583]   - Field: ‘state’
[11:01:44.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:44.583] - Launch lazy future ...
[11:01:44.583] Packages needed by the future expression (n = 1): ‘future’
[11:01:44.583] Packages needed by future strategies (n = 1): ‘future’
[11:01:44.584] {
[11:01:44.584]     {
[11:01:44.584]         {
[11:01:44.584]             ...future.startTime <- base::Sys.time()
[11:01:44.584]             {
[11:01:44.584]                 {
[11:01:44.584]                   {
[11:01:44.584]                     {
[11:01:44.584]                       base::local({
[11:01:44.584]                         has_future <- base::requireNamespace("future", 
[11:01:44.584]                           quietly = TRUE)
[11:01:44.584]                         if (has_future) {
[11:01:44.584]                           ns <- base::getNamespace("future")
[11:01:44.584]                           version <- ns[[".package"]][["version"]]
[11:01:44.584]                           if (is.null(version)) 
[11:01:44.584]                             version <- utils::packageVersion("future")
[11:01:44.584]                         }
[11:01:44.584]                         else {
[11:01:44.584]                           version <- NULL
[11:01:44.584]                         }
[11:01:44.584]                         if (!has_future || version < "1.8.0") {
[11:01:44.584]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:44.584]                             "", base::R.version$version.string), 
[11:01:44.584]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:44.584]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:44.584]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:44.584]                               "release", "version")], collapse = " "), 
[11:01:44.584]                             hostname = base::Sys.info()[["nodename"]])
[11:01:44.584]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:44.584]                             info)
[11:01:44.584]                           info <- base::paste(info, collapse = "; ")
[11:01:44.584]                           if (!has_future) {
[11:01:44.584]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:44.584]                               info)
[11:01:44.584]                           }
[11:01:44.584]                           else {
[11:01:44.584]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:44.584]                               info, version)
[11:01:44.584]                           }
[11:01:44.584]                           base::stop(msg)
[11:01:44.584]                         }
[11:01:44.584]                       })
[11:01:44.584]                     }
[11:01:44.584]                     base::local({
[11:01:44.584]                       for (pkg in "future") {
[11:01:44.584]                         base::loadNamespace(pkg)
[11:01:44.584]                         base::library(pkg, character.only = TRUE)
[11:01:44.584]                       }
[11:01:44.584]                     })
[11:01:44.584]                   }
[11:01:44.584]                   ...future.strategy.old <- future::plan("list")
[11:01:44.584]                   options(future.plan = NULL)
[11:01:44.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:44.584]                   future::plan(list(function (..., workers = availableCores(), 
[11:01:44.584]                     lazy = FALSE, rscript_libs = .libPaths(), 
[11:01:44.584]                     envir = parent.frame()) 
[11:01:44.584]                   {
[11:01:44.584]                     if (is.function(workers)) 
[11:01:44.584]                       workers <- workers()
[11:01:44.584]                     workers <- structure(as.integer(workers), 
[11:01:44.584]                       class = class(workers))
[11:01:44.584]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[11:01:44.584]                       workers >= 1)
[11:01:44.584]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[11:01:44.584]                       return(sequential(..., lazy = TRUE, envir = envir))
[11:01:44.584]                     }
[11:01:44.584]                     future <- MultisessionFuture(..., workers = workers, 
[11:01:44.584]                       lazy = lazy, rscript_libs = rscript_libs, 
[11:01:44.584]                       envir = envir)
[11:01:44.584]                     if (!future$lazy) 
[11:01:44.584]                       future <- run(future)
[11:01:44.584]                     invisible(future)
[11:01:44.584]                   }), .cleanup = FALSE, .init = FALSE)
[11:01:44.584]                 }
[11:01:44.584]                 ...future.workdir <- getwd()
[11:01:44.584]             }
[11:01:44.584]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:44.584]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:44.584]         }
[11:01:44.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[11:01:44.584]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:44.584]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[11:01:44.584]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:44.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:44.584]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:44.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:44.584]             base::names(...future.oldOptions))
[11:01:44.584]     }
[11:01:44.584]     if (FALSE) {
[11:01:44.584]     }
[11:01:44.584]     else {
[11:01:44.584]         if (TRUE) {
[11:01:44.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:44.584]                 open = "w")
[11:01:44.584]         }
[11:01:44.584]         else {
[11:01:44.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:44.584]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:44.584]         }
[11:01:44.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:44.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:44.584]             base::sink(type = "output", split = FALSE)
[11:01:44.584]             base::close(...future.stdout)
[11:01:44.584]         }, add = TRUE)
[11:01:44.584]     }
[11:01:44.584]     ...future.frame <- base::sys.nframe()
[11:01:44.584]     ...future.conditions <- base::list()
[11:01:44.584]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:44.584]     if (FALSE) {
[11:01:44.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:44.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:44.584]     }
[11:01:44.584]     ...future.result <- base::tryCatch({
[11:01:44.584]         base::withCallingHandlers({
[11:01:44.584]             ...future.value <- base::withVisible(base::local({
[11:01:44.584]                 plan(sequential)
[11:01:44.584]             }))
[11:01:44.584]             future::FutureResult(value = ...future.value$value, 
[11:01:44.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:44.584]                   ...future.rng), globalenv = if (FALSE) 
[11:01:44.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:44.584]                     ...future.globalenv.names))
[11:01:44.584]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:44.584]         }, condition = base::local({
[11:01:44.584]             c <- base::c
[11:01:44.584]             inherits <- base::inherits
[11:01:44.584]             invokeRestart <- base::invokeRestart
[11:01:44.584]             length <- base::length
[11:01:44.584]             list <- base::list
[11:01:44.584]             seq.int <- base::seq.int
[11:01:44.584]             signalCondition <- base::signalCondition
[11:01:44.584]             sys.calls <- base::sys.calls
[11:01:44.584]             `[[` <- base::`[[`
[11:01:44.584]             `+` <- base::`+`
[11:01:44.584]             `<<-` <- base::`<<-`
[11:01:44.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:44.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:44.584]                   3L)]
[11:01:44.584]             }
[11:01:44.584]             function(cond) {
[11:01:44.584]                 is_error <- inherits(cond, "error")
[11:01:44.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:44.584]                   NULL)
[11:01:44.584]                 if (is_error) {
[11:01:44.584]                   sessionInformation <- function() {
[11:01:44.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:44.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:44.584]                       search = base::search(), system = base::Sys.info())
[11:01:44.584]                   }
[11:01:44.584]                   ...future.conditions[[length(...future.conditions) + 
[11:01:44.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:44.584]                     cond$call), session = sessionInformation(), 
[11:01:44.584]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:44.584]                   signalCondition(cond)
[11:01:44.584]                 }
[11:01:44.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:44.584]                 "immediateCondition"))) {
[11:01:44.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:44.584]                   ...future.conditions[[length(...future.conditions) + 
[11:01:44.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:44.584]                   if (TRUE && !signal) {
[11:01:44.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.584]                     {
[11:01:44.584]                       inherits <- base::inherits
[11:01:44.584]                       invokeRestart <- base::invokeRestart
[11:01:44.584]                       is.null <- base::is.null
[11:01:44.584]                       muffled <- FALSE
[11:01:44.584]                       if (inherits(cond, "message")) {
[11:01:44.584]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:44.584]                         if (muffled) 
[11:01:44.584]                           invokeRestart("muffleMessage")
[11:01:44.584]                       }
[11:01:44.584]                       else if (inherits(cond, "warning")) {
[11:01:44.584]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:44.584]                         if (muffled) 
[11:01:44.584]                           invokeRestart("muffleWarning")
[11:01:44.584]                       }
[11:01:44.584]                       else if (inherits(cond, "condition")) {
[11:01:44.584]                         if (!is.null(pattern)) {
[11:01:44.584]                           computeRestarts <- base::computeRestarts
[11:01:44.584]                           grepl <- base::grepl
[11:01:44.584]                           restarts <- computeRestarts(cond)
[11:01:44.584]                           for (restart in restarts) {
[11:01:44.584]                             name <- restart$name
[11:01:44.584]                             if (is.null(name)) 
[11:01:44.584]                               next
[11:01:44.584]                             if (!grepl(pattern, name)) 
[11:01:44.584]                               next
[11:01:44.584]                             invokeRestart(restart)
[11:01:44.584]                             muffled <- TRUE
[11:01:44.584]                             break
[11:01:44.584]                           }
[11:01:44.584]                         }
[11:01:44.584]                       }
[11:01:44.584]                       invisible(muffled)
[11:01:44.584]                     }
[11:01:44.584]                     muffleCondition(cond, pattern = "^muffle")
[11:01:44.584]                   }
[11:01:44.584]                 }
[11:01:44.584]                 else {
[11:01:44.584]                   if (TRUE) {
[11:01:44.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:44.584]                     {
[11:01:44.584]                       inherits <- base::inherits
[11:01:44.584]                       invokeRestart <- base::invokeRestart
[11:01:44.584]                       is.null <- base::is.null
[11:01:44.584]                       muffled <- FALSE
[11:01:44.584]                       if (inherits(cond, "message")) {
[11:01:44.584]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:44.584]                         if (muffled) 
[11:01:44.584]                           invokeRestart("muffleMessage")
[11:01:44.584]                       }
[11:01:44.584]                       else if (inherits(cond, "warning")) {
[11:01:44.584]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:44.584]                         if (muffled) 
[11:01:44.584]                           invokeRestart("muffleWarning")
[11:01:44.584]                       }
[11:01:44.584]                       else if (inherits(cond, "condition")) {
[11:01:44.584]                         if (!is.null(pattern)) {
[11:01:44.584]                           computeRestarts <- base::computeRestarts
[11:01:44.584]                           grepl <- base::grepl
[11:01:44.584]                           restarts <- computeRestarts(cond)
[11:01:44.584]                           for (restart in restarts) {
[11:01:44.584]                             name <- restart$name
[11:01:44.584]                             if (is.null(name)) 
[11:01:44.584]                               next
[11:01:44.584]                             if (!grepl(pattern, name)) 
[11:01:44.584]                               next
[11:01:44.584]                             invokeRestart(restart)
[11:01:44.584]                             muffled <- TRUE
[11:01:44.584]                             break
[11:01:44.584]                           }
[11:01:44.584]                         }
[11:01:44.584]                       }
[11:01:44.584]                       invisible(muffled)
[11:01:44.584]                     }
[11:01:44.584]                     muffleCondition(cond, pattern = "^muffle")
[11:01:44.584]                   }
[11:01:44.584]                 }
[11:01:44.584]             }
[11:01:44.584]         }))
[11:01:44.584]     }, error = function(ex) {
[11:01:44.584]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:44.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:44.584]                 ...future.rng), started = ...future.startTime, 
[11:01:44.584]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:44.584]             version = "1.8"), class = "FutureResult")
[11:01:44.584]     }, finally = {
[11:01:44.584]         if (!identical(...future.workdir, getwd())) 
[11:01:44.584]             setwd(...future.workdir)
[11:01:44.584]         {
[11:01:44.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:44.584]                 ...future.oldOptions$nwarnings <- NULL
[11:01:44.584]             }
[11:01:44.584]             base::options(...future.oldOptions)
[11:01:44.584]             if (.Platform$OS.type == "windows") {
[11:01:44.584]                 old_names <- names(...future.oldEnvVars)
[11:01:44.584]                 envs <- base::Sys.getenv()
[11:01:44.584]                 names <- names(envs)
[11:01:44.584]                 common <- intersect(names, old_names)
[11:01:44.584]                 added <- setdiff(names, old_names)
[11:01:44.584]                 removed <- setdiff(old_names, names)
[11:01:44.584]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:44.584]                   envs[common]]
[11:01:44.584]                 NAMES <- toupper(changed)
[11:01:44.584]                 args <- list()
[11:01:44.584]                 for (kk in seq_along(NAMES)) {
[11:01:44.584]                   name <- changed[[kk]]
[11:01:44.584]                   NAME <- NAMES[[kk]]
[11:01:44.584]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.584]                     next
[11:01:44.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:44.584]                 }
[11:01:44.584]                 NAMES <- toupper(added)
[11:01:44.584]                 for (kk in seq_along(NAMES)) {
[11:01:44.584]                   name <- added[[kk]]
[11:01:44.584]                   NAME <- NAMES[[kk]]
[11:01:44.584]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.584]                     next
[11:01:44.584]                   args[[name]] <- ""
[11:01:44.584]                 }
[11:01:44.584]                 NAMES <- toupper(removed)
[11:01:44.584]                 for (kk in seq_along(NAMES)) {
[11:01:44.584]                   name <- removed[[kk]]
[11:01:44.584]                   NAME <- NAMES[[kk]]
[11:01:44.584]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:44.584]                     next
[11:01:44.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:44.584]                 }
[11:01:44.584]                 if (length(args) > 0) 
[11:01:44.584]                   base::do.call(base::Sys.setenv, args = args)
[11:01:44.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:44.584]             }
[11:01:44.584]             else {
[11:01:44.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:44.584]             }
[11:01:44.584]             {
[11:01:44.584]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:44.584]                   0L) {
[11:01:44.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:44.584]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:44.584]                   base::options(opts)
[11:01:44.584]                 }
[11:01:44.584]                 {
[11:01:44.584]                   {
[11:01:44.584]                     NULL
[11:01:44.584]                     RNGkind("Mersenne-Twister")
[11:01:44.584]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:44.584]                       inherits = FALSE)
[11:01:44.584]                   }
[11:01:44.584]                   options(future.plan = NULL)
[11:01:44.584]                   if (is.na(NA_character_)) 
[11:01:44.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:44.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:44.584]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:44.584]                     .init = FALSE)
[11:01:44.584]                 }
[11:01:44.584]             }
[11:01:44.584]         }
[11:01:44.584]     })
[11:01:44.584]     if (TRUE) {
[11:01:44.584]         base::sink(type = "output", split = FALSE)
[11:01:44.584]         if (TRUE) {
[11:01:44.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:44.584]         }
[11:01:44.584]         else {
[11:01:44.584]             ...future.result["stdout"] <- base::list(NULL)
[11:01:44.584]         }
[11:01:44.584]         base::close(...future.stdout)
[11:01:44.584]         ...future.stdout <- NULL
[11:01:44.584]     }
[11:01:44.584]     ...future.result$conditions <- ...future.conditions
[11:01:44.584]     ...future.result$finished <- base::Sys.time()
[11:01:44.584]     ...future.result
[11:01:44.584] }
[11:01:44.586] plan(): Setting new future strategy stack:
[11:01:44.586] List of future strategies:
[11:01:44.586] 1. multisession:
[11:01:44.586]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:44.586]    - tweaked: FALSE
[11:01:44.586]    - call: plan(list(sequential, strategy))
[11:01:44.587] plan(): nbrOfWorkers() = 2
[11:01:44.602] plan(): Setting new future strategy stack:
[11:01:44.602] List of future strategies:
[11:01:44.602] 1. sequential:
[11:01:44.602]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:44.602]    - tweaked: FALSE
[11:01:44.602]    - call: plan(list(sequential, strategy))
[11:01:44.602] 2. multisession:
[11:01:44.602]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:44.602]    - tweaked: FALSE
[11:01:44.602]    - call: plan(list(sequential, strategy))
[11:01:44.603] plan(): nbrOfWorkers() = 1
[11:01:44.604] SequentialFuture started (and completed)
[11:01:44.604] signalConditions() ...
[11:01:44.604]  - include = ‘immediateCondition’
[11:01:44.604]  - exclude = 
[11:01:44.604]  - resignal = FALSE
[11:01:44.604]  - Number of conditions: 3
[11:01:44.605] signalConditions() ... done
[11:01:44.605] - Launch lazy future ... done
[11:01:44.605] run() for ‘SequentialFuture’ ... done
[11:01:44.605] signalConditions() ...
[11:01:44.605]  - include = ‘immediateCondition’
[11:01:44.605]  - exclude = 
[11:01:44.606]  - resignal = FALSE
[11:01:44.606]  - Number of conditions: 3
[11:01:44.606] signalConditions() ... done
[11:01:44.606] Future state: ‘finished’
[11:01:44.606] signalConditions() ...
[11:01:44.606]  - include = ‘condition’
[11:01:44.606]  - exclude = ‘immediateCondition’
[11:01:44.607]  - resignal = TRUE
[11:01:44.607]  - Number of conditions: 3
[11:01:44.607]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.588] plan(): Setting new future strategy stack:
[11:01:44.607]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.588] List of future strategies:
[11:01:44.588] 1. sequential:
[11:01:44.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:44.588]    - tweaked: FALSE
[11:01:44.588]    - call: plan(sequential)
[11:01:44.607]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:44.602] plan(): nbrOfWorkers() = 1
[11:01:44.608] signalConditions() ... done
List of future strategies:
1. multisession:
   - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
   - tweaked: FALSE
   - call: plan(list(sequential, strategy))
- Strategy: multisession ... DONE
> 
> 
> message("*** Globals w/ non-standard evaluation (NSE) ... DONE")
*** Globals w/ non-standard evaluation (NSE) ... DONE
> 
> source("incl/end.R")
[11:01:44.609] plan(): Setting new future strategy stack:
[11:01:44.609] List of future strategies:
[11:01:44.609] 1. FutureStrategy:
[11:01:44.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:44.609]    - tweaked: FALSE
[11:01:44.609]    - call: future::plan(oplan)
[11:01:44.610] plan(): nbrOfWorkers() = 1
> 
