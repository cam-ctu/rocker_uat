
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:21:33.937] plan(): Setting new future strategy stack:
[10:21:33.937] List of future strategies:
[10:21:33.937] 1. sequential:
[10:21:33.937]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:33.937]    - tweaked: FALSE
[10:21:33.937]    - call: future::plan("sequential")
[10:21:33.951] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** Globals w/ non-standard evaluation (NSE) ...")
*** Globals w/ non-standard evaluation (NSE) ...
> 
> data <- data.frame(x = 1:5, y = 1:5)
> v0 <- subset(data, x < 3)$y
> 
> for (strategy in supportedStrategies()) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("- Strategy: %s ...", strategy))
+   
+   plan(strategy)
+ 
+   ## Assert option is passed on to future
+   options(future.globals.onMissing = "error")
+   opt1 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt1, "error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   opt2 %<-% getOption("future.globals.onMissing")
+   stopifnot(identical(opt2, "ignore"))
+ 
+   options(future.globals.onMissing = "error")
+   res <- try({ v1 %<-% subset(data, x < 3)$y }, silent = TRUE)
+   stopifnot(inherits(res, "try-error"))
+ 
+   options(future.globals.onMissing = "ignore")
+   v2 %<-% subset(data, x < 3)$y
+   stopifnot(identical(v2, v0))
+ 
+   ## Nested futures (requires option is passed on to future)
+   plan(list(sequential, strategy))
+   options(future.globals.onMissing = "ignore")
+   v3 %<-% {
+     a %<-% subset(data, x < 3)$y
+     a
+   } %lazy% TRUE
+   stopifnot(identical(v3, v0))
+ 
+   ## Make sure to shut down nested parallel workers
+   void %<-% { plan(sequential) }
+   print(void)
+ 
+   message(sprintf("- Strategy: %s ... DONE", strategy))
+ }
- Strategy: sequential ...
[10:21:33.985] plan(): Setting new future strategy stack:
[10:21:33.985] List of future strategies:
[10:21:33.985] 1. sequential:
[10:21:33.985]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:33.985]    - tweaked: FALSE
[10:21:33.985]    - call: plan(strategy)
[10:21:33.997] plan(): nbrOfWorkers() = 1
[10:21:33.999] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:33.999] Searching for globals...
[10:21:34.002] - globals found: [1] ‘getOption’
[10:21:34.002] Searching for globals ... DONE
[10:21:34.002] Resolving globals: FALSE
[10:21:34.003] 
[10:21:34.003] 
[10:21:34.003] getGlobalsAndPackages() ... DONE
[10:21:34.003] run() for ‘Future’ ...
[10:21:34.004] - state: ‘created’
[10:21:34.004] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:34.004] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:34.004] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:34.004]   - Field: ‘label’
[10:21:34.004]   - Field: ‘local’
[10:21:34.004]   - Field: ‘owner’
[10:21:34.005]   - Field: ‘envir’
[10:21:34.005]   - Field: ‘packages’
[10:21:34.005]   - Field: ‘gc’
[10:21:34.005]   - Field: ‘conditions’
[10:21:34.005]   - Field: ‘expr’
[10:21:34.005]   - Field: ‘uuid’
[10:21:34.005]   - Field: ‘seed’
[10:21:34.005]   - Field: ‘version’
[10:21:34.005]   - Field: ‘result’
[10:21:34.005]   - Field: ‘asynchronous’
[10:21:34.005]   - Field: ‘calls’
[10:21:34.005]   - Field: ‘globals’
[10:21:34.006]   - Field: ‘stdout’
[10:21:34.006]   - Field: ‘earlySignal’
[10:21:34.006]   - Field: ‘lazy’
[10:21:34.006]   - Field: ‘state’
[10:21:34.006] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:34.006] - Launch lazy future ...
[10:21:34.007] Packages needed by the future expression (n = 0): <none>
[10:21:34.007] Packages needed by future strategies (n = 0): <none>
[10:21:34.007] {
[10:21:34.007]     {
[10:21:34.007]         {
[10:21:34.007]             ...future.startTime <- base::Sys.time()
[10:21:34.007]             {
[10:21:34.007]                 {
[10:21:34.007]                   {
[10:21:34.007]                     base::local({
[10:21:34.007]                       has_future <- base::requireNamespace("future", 
[10:21:34.007]                         quietly = TRUE)
[10:21:34.007]                       if (has_future) {
[10:21:34.007]                         ns <- base::getNamespace("future")
[10:21:34.007]                         version <- ns[[".package"]][["version"]]
[10:21:34.007]                         if (is.null(version)) 
[10:21:34.007]                           version <- utils::packageVersion("future")
[10:21:34.007]                       }
[10:21:34.007]                       else {
[10:21:34.007]                         version <- NULL
[10:21:34.007]                       }
[10:21:34.007]                       if (!has_future || version < "1.8.0") {
[10:21:34.007]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.007]                           "", base::R.version$version.string), 
[10:21:34.007]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:34.007]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.007]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.007]                             "release", "version")], collapse = " "), 
[10:21:34.007]                           hostname = base::Sys.info()[["nodename"]])
[10:21:34.007]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.007]                           info)
[10:21:34.007]                         info <- base::paste(info, collapse = "; ")
[10:21:34.007]                         if (!has_future) {
[10:21:34.007]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.007]                             info)
[10:21:34.007]                         }
[10:21:34.007]                         else {
[10:21:34.007]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.007]                             info, version)
[10:21:34.007]                         }
[10:21:34.007]                         base::stop(msg)
[10:21:34.007]                       }
[10:21:34.007]                     })
[10:21:34.007]                   }
[10:21:34.007]                   ...future.strategy.old <- future::plan("list")
[10:21:34.007]                   options(future.plan = NULL)
[10:21:34.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.007]                 }
[10:21:34.007]                 ...future.workdir <- getwd()
[10:21:34.007]             }
[10:21:34.007]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.007]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.007]         }
[10:21:34.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:34.007]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.007]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:34.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.007]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.007]             base::names(...future.oldOptions))
[10:21:34.007]     }
[10:21:34.007]     if (FALSE) {
[10:21:34.007]     }
[10:21:34.007]     else {
[10:21:34.007]         if (TRUE) {
[10:21:34.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.007]                 open = "w")
[10:21:34.007]         }
[10:21:34.007]         else {
[10:21:34.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.007]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.007]         }
[10:21:34.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.007]             base::sink(type = "output", split = FALSE)
[10:21:34.007]             base::close(...future.stdout)
[10:21:34.007]         }, add = TRUE)
[10:21:34.007]     }
[10:21:34.007]     ...future.frame <- base::sys.nframe()
[10:21:34.007]     ...future.conditions <- base::list()
[10:21:34.007]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.007]     if (FALSE) {
[10:21:34.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.007]     }
[10:21:34.007]     ...future.result <- base::tryCatch({
[10:21:34.007]         base::withCallingHandlers({
[10:21:34.007]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[10:21:34.007]             future::FutureResult(value = ...future.value$value, 
[10:21:34.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.007]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.007]                     ...future.globalenv.names))
[10:21:34.007]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.007]         }, condition = base::local({
[10:21:34.007]             c <- base::c
[10:21:34.007]             inherits <- base::inherits
[10:21:34.007]             invokeRestart <- base::invokeRestart
[10:21:34.007]             length <- base::length
[10:21:34.007]             list <- base::list
[10:21:34.007]             seq.int <- base::seq.int
[10:21:34.007]             signalCondition <- base::signalCondition
[10:21:34.007]             sys.calls <- base::sys.calls
[10:21:34.007]             `[[` <- base::`[[`
[10:21:34.007]             `+` <- base::`+`
[10:21:34.007]             `<<-` <- base::`<<-`
[10:21:34.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.007]                   3L)]
[10:21:34.007]             }
[10:21:34.007]             function(cond) {
[10:21:34.007]                 is_error <- inherits(cond, "error")
[10:21:34.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.007]                   NULL)
[10:21:34.007]                 if (is_error) {
[10:21:34.007]                   sessionInformation <- function() {
[10:21:34.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.007]                       search = base::search(), system = base::Sys.info())
[10:21:34.007]                   }
[10:21:34.007]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.007]                     cond$call), session = sessionInformation(), 
[10:21:34.007]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.007]                   signalCondition(cond)
[10:21:34.007]                 }
[10:21:34.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.007]                 "immediateCondition"))) {
[10:21:34.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.007]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.007]                   if (TRUE && !signal) {
[10:21:34.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.007]                     {
[10:21:34.007]                       inherits <- base::inherits
[10:21:34.007]                       invokeRestart <- base::invokeRestart
[10:21:34.007]                       is.null <- base::is.null
[10:21:34.007]                       muffled <- FALSE
[10:21:34.007]                       if (inherits(cond, "message")) {
[10:21:34.007]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.007]                         if (muffled) 
[10:21:34.007]                           invokeRestart("muffleMessage")
[10:21:34.007]                       }
[10:21:34.007]                       else if (inherits(cond, "warning")) {
[10:21:34.007]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.007]                         if (muffled) 
[10:21:34.007]                           invokeRestart("muffleWarning")
[10:21:34.007]                       }
[10:21:34.007]                       else if (inherits(cond, "condition")) {
[10:21:34.007]                         if (!is.null(pattern)) {
[10:21:34.007]                           computeRestarts <- base::computeRestarts
[10:21:34.007]                           grepl <- base::grepl
[10:21:34.007]                           restarts <- computeRestarts(cond)
[10:21:34.007]                           for (restart in restarts) {
[10:21:34.007]                             name <- restart$name
[10:21:34.007]                             if (is.null(name)) 
[10:21:34.007]                               next
[10:21:34.007]                             if (!grepl(pattern, name)) 
[10:21:34.007]                               next
[10:21:34.007]                             invokeRestart(restart)
[10:21:34.007]                             muffled <- TRUE
[10:21:34.007]                             break
[10:21:34.007]                           }
[10:21:34.007]                         }
[10:21:34.007]                       }
[10:21:34.007]                       invisible(muffled)
[10:21:34.007]                     }
[10:21:34.007]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.007]                   }
[10:21:34.007]                 }
[10:21:34.007]                 else {
[10:21:34.007]                   if (TRUE) {
[10:21:34.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.007]                     {
[10:21:34.007]                       inherits <- base::inherits
[10:21:34.007]                       invokeRestart <- base::invokeRestart
[10:21:34.007]                       is.null <- base::is.null
[10:21:34.007]                       muffled <- FALSE
[10:21:34.007]                       if (inherits(cond, "message")) {
[10:21:34.007]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.007]                         if (muffled) 
[10:21:34.007]                           invokeRestart("muffleMessage")
[10:21:34.007]                       }
[10:21:34.007]                       else if (inherits(cond, "warning")) {
[10:21:34.007]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.007]                         if (muffled) 
[10:21:34.007]                           invokeRestart("muffleWarning")
[10:21:34.007]                       }
[10:21:34.007]                       else if (inherits(cond, "condition")) {
[10:21:34.007]                         if (!is.null(pattern)) {
[10:21:34.007]                           computeRestarts <- base::computeRestarts
[10:21:34.007]                           grepl <- base::grepl
[10:21:34.007]                           restarts <- computeRestarts(cond)
[10:21:34.007]                           for (restart in restarts) {
[10:21:34.007]                             name <- restart$name
[10:21:34.007]                             if (is.null(name)) 
[10:21:34.007]                               next
[10:21:34.007]                             if (!grepl(pattern, name)) 
[10:21:34.007]                               next
[10:21:34.007]                             invokeRestart(restart)
[10:21:34.007]                             muffled <- TRUE
[10:21:34.007]                             break
[10:21:34.007]                           }
[10:21:34.007]                         }
[10:21:34.007]                       }
[10:21:34.007]                       invisible(muffled)
[10:21:34.007]                     }
[10:21:34.007]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.007]                   }
[10:21:34.007]                 }
[10:21:34.007]             }
[10:21:34.007]         }))
[10:21:34.007]     }, error = function(ex) {
[10:21:34.007]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.007]                 ...future.rng), started = ...future.startTime, 
[10:21:34.007]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.007]             version = "1.8"), class = "FutureResult")
[10:21:34.007]     }, finally = {
[10:21:34.007]         if (!identical(...future.workdir, getwd())) 
[10:21:34.007]             setwd(...future.workdir)
[10:21:34.007]         {
[10:21:34.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.007]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.007]             }
[10:21:34.007]             base::options(...future.oldOptions)
[10:21:34.007]             if (.Platform$OS.type == "windows") {
[10:21:34.007]                 old_names <- names(...future.oldEnvVars)
[10:21:34.007]                 envs <- base::Sys.getenv()
[10:21:34.007]                 names <- names(envs)
[10:21:34.007]                 common <- intersect(names, old_names)
[10:21:34.007]                 added <- setdiff(names, old_names)
[10:21:34.007]                 removed <- setdiff(old_names, names)
[10:21:34.007]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.007]                   envs[common]]
[10:21:34.007]                 NAMES <- toupper(changed)
[10:21:34.007]                 args <- list()
[10:21:34.007]                 for (kk in seq_along(NAMES)) {
[10:21:34.007]                   name <- changed[[kk]]
[10:21:34.007]                   NAME <- NAMES[[kk]]
[10:21:34.007]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.007]                     next
[10:21:34.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.007]                 }
[10:21:34.007]                 NAMES <- toupper(added)
[10:21:34.007]                 for (kk in seq_along(NAMES)) {
[10:21:34.007]                   name <- added[[kk]]
[10:21:34.007]                   NAME <- NAMES[[kk]]
[10:21:34.007]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.007]                     next
[10:21:34.007]                   args[[name]] <- ""
[10:21:34.007]                 }
[10:21:34.007]                 NAMES <- toupper(removed)
[10:21:34.007]                 for (kk in seq_along(NAMES)) {
[10:21:34.007]                   name <- removed[[kk]]
[10:21:34.007]                   NAME <- NAMES[[kk]]
[10:21:34.007]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.007]                     next
[10:21:34.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.007]                 }
[10:21:34.007]                 if (length(args) > 0) 
[10:21:34.007]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.007]             }
[10:21:34.007]             else {
[10:21:34.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.007]             }
[10:21:34.007]             {
[10:21:34.007]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.007]                   0L) {
[10:21:34.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.007]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.007]                   base::options(opts)
[10:21:34.007]                 }
[10:21:34.007]                 {
[10:21:34.007]                   {
[10:21:34.007]                     NULL
[10:21:34.007]                     RNGkind("Mersenne-Twister")
[10:21:34.007]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:34.007]                       inherits = FALSE)
[10:21:34.007]                   }
[10:21:34.007]                   options(future.plan = NULL)
[10:21:34.007]                   if (is.na(NA_character_)) 
[10:21:34.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.007]                     .init = FALSE)
[10:21:34.007]                 }
[10:21:34.007]             }
[10:21:34.007]         }
[10:21:34.007]     })
[10:21:34.007]     if (TRUE) {
[10:21:34.007]         base::sink(type = "output", split = FALSE)
[10:21:34.007]         if (TRUE) {
[10:21:34.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.007]         }
[10:21:34.007]         else {
[10:21:34.007]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.007]         }
[10:21:34.007]         base::close(...future.stdout)
[10:21:34.007]         ...future.stdout <- NULL
[10:21:34.007]     }
[10:21:34.007]     ...future.result$conditions <- ...future.conditions
[10:21:34.007]     ...future.result$finished <- base::Sys.time()
[10:21:34.007]     ...future.result
[10:21:34.007] }
[10:21:34.009] plan(): Setting new future strategy stack:
[10:21:34.009] List of future strategies:
[10:21:34.009] 1. sequential:
[10:21:34.009]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.009]    - tweaked: FALSE
[10:21:34.009]    - call: NULL
[10:21:34.010] plan(): nbrOfWorkers() = 1
[10:21:34.011] plan(): Setting new future strategy stack:
[10:21:34.011] List of future strategies:
[10:21:34.011] 1. sequential:
[10:21:34.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.011]    - tweaked: FALSE
[10:21:34.011]    - call: plan(strategy)
[10:21:34.011] plan(): nbrOfWorkers() = 1
[10:21:34.011] SequentialFuture started (and completed)
[10:21:34.012] - Launch lazy future ... done
[10:21:34.012] run() for ‘SequentialFuture’ ... done
[10:21:34.012] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.013] Searching for globals...
[10:21:34.013] - globals found: [1] ‘getOption’
[10:21:34.013] Searching for globals ... DONE
[10:21:34.013] Resolving globals: FALSE
[10:21:34.014] 
[10:21:34.014] 
[10:21:34.014] getGlobalsAndPackages() ... DONE
[10:21:34.014] run() for ‘Future’ ...
[10:21:34.014] - state: ‘created’
[10:21:34.014] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:34.014] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:34.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:34.015]   - Field: ‘label’
[10:21:34.015]   - Field: ‘local’
[10:21:34.015]   - Field: ‘owner’
[10:21:34.015]   - Field: ‘envir’
[10:21:34.015]   - Field: ‘packages’
[10:21:34.015]   - Field: ‘gc’
[10:21:34.015]   - Field: ‘conditions’
[10:21:34.015]   - Field: ‘expr’
[10:21:34.015]   - Field: ‘uuid’
[10:21:34.015]   - Field: ‘seed’
[10:21:34.015]   - Field: ‘version’
[10:21:34.015]   - Field: ‘result’
[10:21:34.016]   - Field: ‘asynchronous’
[10:21:34.016]   - Field: ‘calls’
[10:21:34.016]   - Field: ‘globals’
[10:21:34.016]   - Field: ‘stdout’
[10:21:34.016]   - Field: ‘earlySignal’
[10:21:34.016]   - Field: ‘lazy’
[10:21:34.016]   - Field: ‘state’
[10:21:34.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:34.016] - Launch lazy future ...
[10:21:34.016] Packages needed by the future expression (n = 0): <none>
[10:21:34.016] Packages needed by future strategies (n = 0): <none>
[10:21:34.017] {
[10:21:34.017]     {
[10:21:34.017]         {
[10:21:34.017]             ...future.startTime <- base::Sys.time()
[10:21:34.017]             {
[10:21:34.017]                 {
[10:21:34.017]                   {
[10:21:34.017]                     base::local({
[10:21:34.017]                       has_future <- base::requireNamespace("future", 
[10:21:34.017]                         quietly = TRUE)
[10:21:34.017]                       if (has_future) {
[10:21:34.017]                         ns <- base::getNamespace("future")
[10:21:34.017]                         version <- ns[[".package"]][["version"]]
[10:21:34.017]                         if (is.null(version)) 
[10:21:34.017]                           version <- utils::packageVersion("future")
[10:21:34.017]                       }
[10:21:34.017]                       else {
[10:21:34.017]                         version <- NULL
[10:21:34.017]                       }
[10:21:34.017]                       if (!has_future || version < "1.8.0") {
[10:21:34.017]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.017]                           "", base::R.version$version.string), 
[10:21:34.017]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:34.017]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.017]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.017]                             "release", "version")], collapse = " "), 
[10:21:34.017]                           hostname = base::Sys.info()[["nodename"]])
[10:21:34.017]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.017]                           info)
[10:21:34.017]                         info <- base::paste(info, collapse = "; ")
[10:21:34.017]                         if (!has_future) {
[10:21:34.017]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.017]                             info)
[10:21:34.017]                         }
[10:21:34.017]                         else {
[10:21:34.017]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.017]                             info, version)
[10:21:34.017]                         }
[10:21:34.017]                         base::stop(msg)
[10:21:34.017]                       }
[10:21:34.017]                     })
[10:21:34.017]                   }
[10:21:34.017]                   ...future.strategy.old <- future::plan("list")
[10:21:34.017]                   options(future.plan = NULL)
[10:21:34.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.017]                 }
[10:21:34.017]                 ...future.workdir <- getwd()
[10:21:34.017]             }
[10:21:34.017]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.017]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.017]         }
[10:21:34.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.017]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.017]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.017]             base::names(...future.oldOptions))
[10:21:34.017]     }
[10:21:34.017]     if (FALSE) {
[10:21:34.017]     }
[10:21:34.017]     else {
[10:21:34.017]         if (TRUE) {
[10:21:34.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.017]                 open = "w")
[10:21:34.017]         }
[10:21:34.017]         else {
[10:21:34.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.017]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.017]         }
[10:21:34.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.017]             base::sink(type = "output", split = FALSE)
[10:21:34.017]             base::close(...future.stdout)
[10:21:34.017]         }, add = TRUE)
[10:21:34.017]     }
[10:21:34.017]     ...future.frame <- base::sys.nframe()
[10:21:34.017]     ...future.conditions <- base::list()
[10:21:34.017]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.017]     if (FALSE) {
[10:21:34.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.017]     }
[10:21:34.017]     ...future.result <- base::tryCatch({
[10:21:34.017]         base::withCallingHandlers({
[10:21:34.017]             ...future.value <- base::withVisible(base::local(getOption("future.globals.onMissing")))
[10:21:34.017]             future::FutureResult(value = ...future.value$value, 
[10:21:34.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.017]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.017]                     ...future.globalenv.names))
[10:21:34.017]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.017]         }, condition = base::local({
[10:21:34.017]             c <- base::c
[10:21:34.017]             inherits <- base::inherits
[10:21:34.017]             invokeRestart <- base::invokeRestart
[10:21:34.017]             length <- base::length
[10:21:34.017]             list <- base::list
[10:21:34.017]             seq.int <- base::seq.int
[10:21:34.017]             signalCondition <- base::signalCondition
[10:21:34.017]             sys.calls <- base::sys.calls
[10:21:34.017]             `[[` <- base::`[[`
[10:21:34.017]             `+` <- base::`+`
[10:21:34.017]             `<<-` <- base::`<<-`
[10:21:34.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.017]                   3L)]
[10:21:34.017]             }
[10:21:34.017]             function(cond) {
[10:21:34.017]                 is_error <- inherits(cond, "error")
[10:21:34.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.017]                   NULL)
[10:21:34.017]                 if (is_error) {
[10:21:34.017]                   sessionInformation <- function() {
[10:21:34.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.017]                       search = base::search(), system = base::Sys.info())
[10:21:34.017]                   }
[10:21:34.017]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.017]                     cond$call), session = sessionInformation(), 
[10:21:34.017]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.017]                   signalCondition(cond)
[10:21:34.017]                 }
[10:21:34.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.017]                 "immediateCondition"))) {
[10:21:34.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.017]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.017]                   if (TRUE && !signal) {
[10:21:34.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.017]                     {
[10:21:34.017]                       inherits <- base::inherits
[10:21:34.017]                       invokeRestart <- base::invokeRestart
[10:21:34.017]                       is.null <- base::is.null
[10:21:34.017]                       muffled <- FALSE
[10:21:34.017]                       if (inherits(cond, "message")) {
[10:21:34.017]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.017]                         if (muffled) 
[10:21:34.017]                           invokeRestart("muffleMessage")
[10:21:34.017]                       }
[10:21:34.017]                       else if (inherits(cond, "warning")) {
[10:21:34.017]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.017]                         if (muffled) 
[10:21:34.017]                           invokeRestart("muffleWarning")
[10:21:34.017]                       }
[10:21:34.017]                       else if (inherits(cond, "condition")) {
[10:21:34.017]                         if (!is.null(pattern)) {
[10:21:34.017]                           computeRestarts <- base::computeRestarts
[10:21:34.017]                           grepl <- base::grepl
[10:21:34.017]                           restarts <- computeRestarts(cond)
[10:21:34.017]                           for (restart in restarts) {
[10:21:34.017]                             name <- restart$name
[10:21:34.017]                             if (is.null(name)) 
[10:21:34.017]                               next
[10:21:34.017]                             if (!grepl(pattern, name)) 
[10:21:34.017]                               next
[10:21:34.017]                             invokeRestart(restart)
[10:21:34.017]                             muffled <- TRUE
[10:21:34.017]                             break
[10:21:34.017]                           }
[10:21:34.017]                         }
[10:21:34.017]                       }
[10:21:34.017]                       invisible(muffled)
[10:21:34.017]                     }
[10:21:34.017]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.017]                   }
[10:21:34.017]                 }
[10:21:34.017]                 else {
[10:21:34.017]                   if (TRUE) {
[10:21:34.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.017]                     {
[10:21:34.017]                       inherits <- base::inherits
[10:21:34.017]                       invokeRestart <- base::invokeRestart
[10:21:34.017]                       is.null <- base::is.null
[10:21:34.017]                       muffled <- FALSE
[10:21:34.017]                       if (inherits(cond, "message")) {
[10:21:34.017]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.017]                         if (muffled) 
[10:21:34.017]                           invokeRestart("muffleMessage")
[10:21:34.017]                       }
[10:21:34.017]                       else if (inherits(cond, "warning")) {
[10:21:34.017]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.017]                         if (muffled) 
[10:21:34.017]                           invokeRestart("muffleWarning")
[10:21:34.017]                       }
[10:21:34.017]                       else if (inherits(cond, "condition")) {
[10:21:34.017]                         if (!is.null(pattern)) {
[10:21:34.017]                           computeRestarts <- base::computeRestarts
[10:21:34.017]                           grepl <- base::grepl
[10:21:34.017]                           restarts <- computeRestarts(cond)
[10:21:34.017]                           for (restart in restarts) {
[10:21:34.017]                             name <- restart$name
[10:21:34.017]                             if (is.null(name)) 
[10:21:34.017]                               next
[10:21:34.017]                             if (!grepl(pattern, name)) 
[10:21:34.017]                               next
[10:21:34.017]                             invokeRestart(restart)
[10:21:34.017]                             muffled <- TRUE
[10:21:34.017]                             break
[10:21:34.017]                           }
[10:21:34.017]                         }
[10:21:34.017]                       }
[10:21:34.017]                       invisible(muffled)
[10:21:34.017]                     }
[10:21:34.017]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.017]                   }
[10:21:34.017]                 }
[10:21:34.017]             }
[10:21:34.017]         }))
[10:21:34.017]     }, error = function(ex) {
[10:21:34.017]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.017]                 ...future.rng), started = ...future.startTime, 
[10:21:34.017]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.017]             version = "1.8"), class = "FutureResult")
[10:21:34.017]     }, finally = {
[10:21:34.017]         if (!identical(...future.workdir, getwd())) 
[10:21:34.017]             setwd(...future.workdir)
[10:21:34.017]         {
[10:21:34.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.017]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.017]             }
[10:21:34.017]             base::options(...future.oldOptions)
[10:21:34.017]             if (.Platform$OS.type == "windows") {
[10:21:34.017]                 old_names <- names(...future.oldEnvVars)
[10:21:34.017]                 envs <- base::Sys.getenv()
[10:21:34.017]                 names <- names(envs)
[10:21:34.017]                 common <- intersect(names, old_names)
[10:21:34.017]                 added <- setdiff(names, old_names)
[10:21:34.017]                 removed <- setdiff(old_names, names)
[10:21:34.017]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.017]                   envs[common]]
[10:21:34.017]                 NAMES <- toupper(changed)
[10:21:34.017]                 args <- list()
[10:21:34.017]                 for (kk in seq_along(NAMES)) {
[10:21:34.017]                   name <- changed[[kk]]
[10:21:34.017]                   NAME <- NAMES[[kk]]
[10:21:34.017]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.017]                     next
[10:21:34.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.017]                 }
[10:21:34.017]                 NAMES <- toupper(added)
[10:21:34.017]                 for (kk in seq_along(NAMES)) {
[10:21:34.017]                   name <- added[[kk]]
[10:21:34.017]                   NAME <- NAMES[[kk]]
[10:21:34.017]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.017]                     next
[10:21:34.017]                   args[[name]] <- ""
[10:21:34.017]                 }
[10:21:34.017]                 NAMES <- toupper(removed)
[10:21:34.017]                 for (kk in seq_along(NAMES)) {
[10:21:34.017]                   name <- removed[[kk]]
[10:21:34.017]                   NAME <- NAMES[[kk]]
[10:21:34.017]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.017]                     next
[10:21:34.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.017]                 }
[10:21:34.017]                 if (length(args) > 0) 
[10:21:34.017]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.017]             }
[10:21:34.017]             else {
[10:21:34.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.017]             }
[10:21:34.017]             {
[10:21:34.017]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.017]                   0L) {
[10:21:34.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.017]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.017]                   base::options(opts)
[10:21:34.017]                 }
[10:21:34.017]                 {
[10:21:34.017]                   {
[10:21:34.017]                     NULL
[10:21:34.017]                     RNGkind("Mersenne-Twister")
[10:21:34.017]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:34.017]                       inherits = FALSE)
[10:21:34.017]                   }
[10:21:34.017]                   options(future.plan = NULL)
[10:21:34.017]                   if (is.na(NA_character_)) 
[10:21:34.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.017]                     .init = FALSE)
[10:21:34.017]                 }
[10:21:34.017]             }
[10:21:34.017]         }
[10:21:34.017]     })
[10:21:34.017]     if (TRUE) {
[10:21:34.017]         base::sink(type = "output", split = FALSE)
[10:21:34.017]         if (TRUE) {
[10:21:34.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.017]         }
[10:21:34.017]         else {
[10:21:34.017]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.017]         }
[10:21:34.017]         base::close(...future.stdout)
[10:21:34.017]         ...future.stdout <- NULL
[10:21:34.017]     }
[10:21:34.017]     ...future.result$conditions <- ...future.conditions
[10:21:34.017]     ...future.result$finished <- base::Sys.time()
[10:21:34.017]     ...future.result
[10:21:34.017] }
[10:21:34.019] plan(): Setting new future strategy stack:
[10:21:34.019] List of future strategies:
[10:21:34.019] 1. sequential:
[10:21:34.019]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.019]    - tweaked: FALSE
[10:21:34.019]    - call: NULL
[10:21:34.019] plan(): nbrOfWorkers() = 1
[10:21:34.020] plan(): Setting new future strategy stack:
[10:21:34.020] List of future strategies:
[10:21:34.020] 1. sequential:
[10:21:34.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.020]    - tweaked: FALSE
[10:21:34.020]    - call: plan(strategy)
[10:21:34.020] plan(): nbrOfWorkers() = 1
[10:21:34.020] SequentialFuture started (and completed)
[10:21:34.021] - Launch lazy future ... done
[10:21:34.021] run() for ‘SequentialFuture’ ... done
[10:21:34.021] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:34.021] Searching for globals...
[10:21:34.024] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.024] Searching for globals...
[10:21:34.025] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:21:34.025] Searching for globals ... DONE
[10:21:34.025] Resolving globals: FALSE
[10:21:34.026] The total size of the 1 globals is 356 bytes (356 bytes)
[10:21:34.026] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:21:34.026] - globals: [1] ‘data’
[10:21:34.026] 
[10:21:34.026] getGlobalsAndPackages() ... DONE
[10:21:34.027] run() for ‘Future’ ...
[10:21:34.027] - state: ‘created’
[10:21:34.027] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:34.027] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:34.027] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:34.027]   - Field: ‘label’
[10:21:34.027]   - Field: ‘local’
[10:21:34.027]   - Field: ‘owner’
[10:21:34.028]   - Field: ‘envir’
[10:21:34.028]   - Field: ‘packages’
[10:21:34.028]   - Field: ‘gc’
[10:21:34.028]   - Field: ‘conditions’
[10:21:34.028]   - Field: ‘expr’
[10:21:34.028]   - Field: ‘uuid’
[10:21:34.028]   - Field: ‘seed’
[10:21:34.028]   - Field: ‘version’
[10:21:34.028]   - Field: ‘result’
[10:21:34.028]   - Field: ‘asynchronous’
[10:21:34.028]   - Field: ‘calls’
[10:21:34.028]   - Field: ‘globals’
[10:21:34.029]   - Field: ‘stdout’
[10:21:34.029]   - Field: ‘earlySignal’
[10:21:34.029]   - Field: ‘lazy’
[10:21:34.029]   - Field: ‘state’
[10:21:34.029] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:34.029] - Launch lazy future ...
[10:21:34.029] Packages needed by the future expression (n = 0): <none>
[10:21:34.029] Packages needed by future strategies (n = 0): <none>
[10:21:34.030] {
[10:21:34.030]     {
[10:21:34.030]         {
[10:21:34.030]             ...future.startTime <- base::Sys.time()
[10:21:34.030]             {
[10:21:34.030]                 {
[10:21:34.030]                   {
[10:21:34.030]                     base::local({
[10:21:34.030]                       has_future <- base::requireNamespace("future", 
[10:21:34.030]                         quietly = TRUE)
[10:21:34.030]                       if (has_future) {
[10:21:34.030]                         ns <- base::getNamespace("future")
[10:21:34.030]                         version <- ns[[".package"]][["version"]]
[10:21:34.030]                         if (is.null(version)) 
[10:21:34.030]                           version <- utils::packageVersion("future")
[10:21:34.030]                       }
[10:21:34.030]                       else {
[10:21:34.030]                         version <- NULL
[10:21:34.030]                       }
[10:21:34.030]                       if (!has_future || version < "1.8.0") {
[10:21:34.030]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.030]                           "", base::R.version$version.string), 
[10:21:34.030]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:34.030]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.030]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.030]                             "release", "version")], collapse = " "), 
[10:21:34.030]                           hostname = base::Sys.info()[["nodename"]])
[10:21:34.030]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.030]                           info)
[10:21:34.030]                         info <- base::paste(info, collapse = "; ")
[10:21:34.030]                         if (!has_future) {
[10:21:34.030]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.030]                             info)
[10:21:34.030]                         }
[10:21:34.030]                         else {
[10:21:34.030]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.030]                             info, version)
[10:21:34.030]                         }
[10:21:34.030]                         base::stop(msg)
[10:21:34.030]                       }
[10:21:34.030]                     })
[10:21:34.030]                   }
[10:21:34.030]                   ...future.strategy.old <- future::plan("list")
[10:21:34.030]                   options(future.plan = NULL)
[10:21:34.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.030]                 }
[10:21:34.030]                 ...future.workdir <- getwd()
[10:21:34.030]             }
[10:21:34.030]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.030]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.030]         }
[10:21:34.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.030]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.030]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.030]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.030]             base::names(...future.oldOptions))
[10:21:34.030]     }
[10:21:34.030]     if (FALSE) {
[10:21:34.030]     }
[10:21:34.030]     else {
[10:21:34.030]         if (TRUE) {
[10:21:34.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.030]                 open = "w")
[10:21:34.030]         }
[10:21:34.030]         else {
[10:21:34.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.030]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.030]         }
[10:21:34.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.030]             base::sink(type = "output", split = FALSE)
[10:21:34.030]             base::close(...future.stdout)
[10:21:34.030]         }, add = TRUE)
[10:21:34.030]     }
[10:21:34.030]     ...future.frame <- base::sys.nframe()
[10:21:34.030]     ...future.conditions <- base::list()
[10:21:34.030]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.030]     if (FALSE) {
[10:21:34.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.030]     }
[10:21:34.030]     ...future.result <- base::tryCatch({
[10:21:34.030]         base::withCallingHandlers({
[10:21:34.030]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:21:34.030]                 x < 3)$y))
[10:21:34.030]             future::FutureResult(value = ...future.value$value, 
[10:21:34.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.030]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.030]                     ...future.globalenv.names))
[10:21:34.030]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.030]         }, condition = base::local({
[10:21:34.030]             c <- base::c
[10:21:34.030]             inherits <- base::inherits
[10:21:34.030]             invokeRestart <- base::invokeRestart
[10:21:34.030]             length <- base::length
[10:21:34.030]             list <- base::list
[10:21:34.030]             seq.int <- base::seq.int
[10:21:34.030]             signalCondition <- base::signalCondition
[10:21:34.030]             sys.calls <- base::sys.calls
[10:21:34.030]             `[[` <- base::`[[`
[10:21:34.030]             `+` <- base::`+`
[10:21:34.030]             `<<-` <- base::`<<-`
[10:21:34.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.030]                   3L)]
[10:21:34.030]             }
[10:21:34.030]             function(cond) {
[10:21:34.030]                 is_error <- inherits(cond, "error")
[10:21:34.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.030]                   NULL)
[10:21:34.030]                 if (is_error) {
[10:21:34.030]                   sessionInformation <- function() {
[10:21:34.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.030]                       search = base::search(), system = base::Sys.info())
[10:21:34.030]                   }
[10:21:34.030]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.030]                     cond$call), session = sessionInformation(), 
[10:21:34.030]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.030]                   signalCondition(cond)
[10:21:34.030]                 }
[10:21:34.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.030]                 "immediateCondition"))) {
[10:21:34.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.030]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.030]                   if (TRUE && !signal) {
[10:21:34.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.030]                     {
[10:21:34.030]                       inherits <- base::inherits
[10:21:34.030]                       invokeRestart <- base::invokeRestart
[10:21:34.030]                       is.null <- base::is.null
[10:21:34.030]                       muffled <- FALSE
[10:21:34.030]                       if (inherits(cond, "message")) {
[10:21:34.030]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.030]                         if (muffled) 
[10:21:34.030]                           invokeRestart("muffleMessage")
[10:21:34.030]                       }
[10:21:34.030]                       else if (inherits(cond, "warning")) {
[10:21:34.030]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.030]                         if (muffled) 
[10:21:34.030]                           invokeRestart("muffleWarning")
[10:21:34.030]                       }
[10:21:34.030]                       else if (inherits(cond, "condition")) {
[10:21:34.030]                         if (!is.null(pattern)) {
[10:21:34.030]                           computeRestarts <- base::computeRestarts
[10:21:34.030]                           grepl <- base::grepl
[10:21:34.030]                           restarts <- computeRestarts(cond)
[10:21:34.030]                           for (restart in restarts) {
[10:21:34.030]                             name <- restart$name
[10:21:34.030]                             if (is.null(name)) 
[10:21:34.030]                               next
[10:21:34.030]                             if (!grepl(pattern, name)) 
[10:21:34.030]                               next
[10:21:34.030]                             invokeRestart(restart)
[10:21:34.030]                             muffled <- TRUE
[10:21:34.030]                             break
[10:21:34.030]                           }
[10:21:34.030]                         }
[10:21:34.030]                       }
[10:21:34.030]                       invisible(muffled)
[10:21:34.030]                     }
[10:21:34.030]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.030]                   }
[10:21:34.030]                 }
[10:21:34.030]                 else {
[10:21:34.030]                   if (TRUE) {
[10:21:34.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.030]                     {
[10:21:34.030]                       inherits <- base::inherits
[10:21:34.030]                       invokeRestart <- base::invokeRestart
[10:21:34.030]                       is.null <- base::is.null
[10:21:34.030]                       muffled <- FALSE
[10:21:34.030]                       if (inherits(cond, "message")) {
[10:21:34.030]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.030]                         if (muffled) 
[10:21:34.030]                           invokeRestart("muffleMessage")
[10:21:34.030]                       }
[10:21:34.030]                       else if (inherits(cond, "warning")) {
[10:21:34.030]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.030]                         if (muffled) 
[10:21:34.030]                           invokeRestart("muffleWarning")
[10:21:34.030]                       }
[10:21:34.030]                       else if (inherits(cond, "condition")) {
[10:21:34.030]                         if (!is.null(pattern)) {
[10:21:34.030]                           computeRestarts <- base::computeRestarts
[10:21:34.030]                           grepl <- base::grepl
[10:21:34.030]                           restarts <- computeRestarts(cond)
[10:21:34.030]                           for (restart in restarts) {
[10:21:34.030]                             name <- restart$name
[10:21:34.030]                             if (is.null(name)) 
[10:21:34.030]                               next
[10:21:34.030]                             if (!grepl(pattern, name)) 
[10:21:34.030]                               next
[10:21:34.030]                             invokeRestart(restart)
[10:21:34.030]                             muffled <- TRUE
[10:21:34.030]                             break
[10:21:34.030]                           }
[10:21:34.030]                         }
[10:21:34.030]                       }
[10:21:34.030]                       invisible(muffled)
[10:21:34.030]                     }
[10:21:34.030]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.030]                   }
[10:21:34.030]                 }
[10:21:34.030]             }
[10:21:34.030]         }))
[10:21:34.030]     }, error = function(ex) {
[10:21:34.030]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.030]                 ...future.rng), started = ...future.startTime, 
[10:21:34.030]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.030]             version = "1.8"), class = "FutureResult")
[10:21:34.030]     }, finally = {
[10:21:34.030]         if (!identical(...future.workdir, getwd())) 
[10:21:34.030]             setwd(...future.workdir)
[10:21:34.030]         {
[10:21:34.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.030]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.030]             }
[10:21:34.030]             base::options(...future.oldOptions)
[10:21:34.030]             if (.Platform$OS.type == "windows") {
[10:21:34.030]                 old_names <- names(...future.oldEnvVars)
[10:21:34.030]                 envs <- base::Sys.getenv()
[10:21:34.030]                 names <- names(envs)
[10:21:34.030]                 common <- intersect(names, old_names)
[10:21:34.030]                 added <- setdiff(names, old_names)
[10:21:34.030]                 removed <- setdiff(old_names, names)
[10:21:34.030]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.030]                   envs[common]]
[10:21:34.030]                 NAMES <- toupper(changed)
[10:21:34.030]                 args <- list()
[10:21:34.030]                 for (kk in seq_along(NAMES)) {
[10:21:34.030]                   name <- changed[[kk]]
[10:21:34.030]                   NAME <- NAMES[[kk]]
[10:21:34.030]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.030]                     next
[10:21:34.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.030]                 }
[10:21:34.030]                 NAMES <- toupper(added)
[10:21:34.030]                 for (kk in seq_along(NAMES)) {
[10:21:34.030]                   name <- added[[kk]]
[10:21:34.030]                   NAME <- NAMES[[kk]]
[10:21:34.030]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.030]                     next
[10:21:34.030]                   args[[name]] <- ""
[10:21:34.030]                 }
[10:21:34.030]                 NAMES <- toupper(removed)
[10:21:34.030]                 for (kk in seq_along(NAMES)) {
[10:21:34.030]                   name <- removed[[kk]]
[10:21:34.030]                   NAME <- NAMES[[kk]]
[10:21:34.030]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.030]                     next
[10:21:34.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.030]                 }
[10:21:34.030]                 if (length(args) > 0) 
[10:21:34.030]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.030]             }
[10:21:34.030]             else {
[10:21:34.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.030]             }
[10:21:34.030]             {
[10:21:34.030]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.030]                   0L) {
[10:21:34.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.030]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.030]                   base::options(opts)
[10:21:34.030]                 }
[10:21:34.030]                 {
[10:21:34.030]                   {
[10:21:34.030]                     NULL
[10:21:34.030]                     RNGkind("Mersenne-Twister")
[10:21:34.030]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:34.030]                       inherits = FALSE)
[10:21:34.030]                   }
[10:21:34.030]                   options(future.plan = NULL)
[10:21:34.030]                   if (is.na(NA_character_)) 
[10:21:34.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.030]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.030]                     .init = FALSE)
[10:21:34.030]                 }
[10:21:34.030]             }
[10:21:34.030]         }
[10:21:34.030]     })
[10:21:34.030]     if (TRUE) {
[10:21:34.030]         base::sink(type = "output", split = FALSE)
[10:21:34.030]         if (TRUE) {
[10:21:34.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.030]         }
[10:21:34.030]         else {
[10:21:34.030]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.030]         }
[10:21:34.030]         base::close(...future.stdout)
[10:21:34.030]         ...future.stdout <- NULL
[10:21:34.030]     }
[10:21:34.030]     ...future.result$conditions <- ...future.conditions
[10:21:34.030]     ...future.result$finished <- base::Sys.time()
[10:21:34.030]     ...future.result
[10:21:34.030] }
[10:21:34.031] assign_globals() ...
[10:21:34.031] List of 1
[10:21:34.031]  $ data:'data.frame':	5 obs. of  2 variables:
[10:21:34.031]   ..$ x: int [1:5] 1 2 3 4 5
[10:21:34.031]   ..$ y: int [1:5] 1 2 3 4 5
[10:21:34.031]  - attr(*, "where")=List of 1
[10:21:34.031]   ..$ data:<environment: R_EmptyEnv> 
[10:21:34.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:34.031]  - attr(*, "resolved")= logi FALSE
[10:21:34.031]  - attr(*, "total_size")= num 356
[10:21:34.031]  - attr(*, "already-done")= logi TRUE
[10:21:34.036] - copied ‘data’ to environment
[10:21:34.036] assign_globals() ... done
[10:21:34.036] plan(): Setting new future strategy stack:
[10:21:34.037] List of future strategies:
[10:21:34.037] 1. sequential:
[10:21:34.037]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.037]    - tweaked: FALSE
[10:21:34.037]    - call: NULL
[10:21:34.037] plan(): nbrOfWorkers() = 1
[10:21:34.038] plan(): Setting new future strategy stack:
[10:21:34.038] List of future strategies:
[10:21:34.038] 1. sequential:
[10:21:34.038]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.038]    - tweaked: FALSE
[10:21:34.038]    - call: plan(strategy)
[10:21:34.038] plan(): nbrOfWorkers() = 1
[10:21:34.038] SequentialFuture started (and completed)
[10:21:34.038] - Launch lazy future ... done
[10:21:34.039] run() for ‘SequentialFuture’ ... done
[10:21:34.039] plan(): Setting new future strategy stack:
[10:21:34.039] List of future strategies:
[10:21:34.039] 1. sequential:
[10:21:34.039]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.039]    - tweaked: FALSE
[10:21:34.039]    - call: plan(list(sequential, strategy))
[10:21:34.039] 2. sequential:
[10:21:34.039]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.039]    - tweaked: FALSE
[10:21:34.039]    - call: plan(list(sequential, strategy))
[10:21:34.040] plan(): nbrOfWorkers() = 1
[10:21:34.040] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.040] Searching for globals...
[10:21:34.045] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[10:21:34.045] Searching for globals ... DONE
[10:21:34.045] Resolving globals: FALSE
[10:21:34.045] The total size of the 1 globals is 356 bytes (356 bytes)
[10:21:34.045] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:21:34.046] - globals: [1] ‘data’
[10:21:34.046] - packages: [1] ‘future’
[10:21:34.046] getGlobalsAndPackages() ... DONE
[10:21:34.046] run() for ‘Future’ ...
[10:21:34.046] - state: ‘created’
[10:21:34.046] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:34.047] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:34.047] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:34.047]   - Field: ‘label’
[10:21:34.047]   - Field: ‘local’
[10:21:34.047]   - Field: ‘owner’
[10:21:34.047]   - Field: ‘envir’
[10:21:34.047]   - Field: ‘packages’
[10:21:34.047]   - Field: ‘gc’
[10:21:34.047]   - Field: ‘conditions’
[10:21:34.047]   - Field: ‘expr’
[10:21:34.047]   - Field: ‘uuid’
[10:21:34.048]   - Field: ‘seed’
[10:21:34.048]   - Field: ‘version’
[10:21:34.048]   - Field: ‘result’
[10:21:34.048]   - Field: ‘asynchronous’
[10:21:34.048]   - Field: ‘calls’
[10:21:34.048]   - Field: ‘globals’
[10:21:34.048]   - Field: ‘stdout’
[10:21:34.048]   - Field: ‘earlySignal’
[10:21:34.048]   - Field: ‘lazy’
[10:21:34.048]   - Field: ‘state’
[10:21:34.048] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:34.048] - Launch lazy future ...
[10:21:34.049] Packages needed by the future expression (n = 1): ‘future’
[10:21:34.049] Packages needed by future strategies (n = 1): ‘future’
[10:21:34.050] {
[10:21:34.050]     {
[10:21:34.050]         {
[10:21:34.050]             ...future.startTime <- base::Sys.time()
[10:21:34.050]             {
[10:21:34.050]                 {
[10:21:34.050]                   {
[10:21:34.050]                     {
[10:21:34.050]                       base::local({
[10:21:34.050]                         has_future <- base::requireNamespace("future", 
[10:21:34.050]                           quietly = TRUE)
[10:21:34.050]                         if (has_future) {
[10:21:34.050]                           ns <- base::getNamespace("future")
[10:21:34.050]                           version <- ns[[".package"]][["version"]]
[10:21:34.050]                           if (is.null(version)) 
[10:21:34.050]                             version <- utils::packageVersion("future")
[10:21:34.050]                         }
[10:21:34.050]                         else {
[10:21:34.050]                           version <- NULL
[10:21:34.050]                         }
[10:21:34.050]                         if (!has_future || version < "1.8.0") {
[10:21:34.050]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.050]                             "", base::R.version$version.string), 
[10:21:34.050]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.050]                               "release", "version")], collapse = " "), 
[10:21:34.050]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.050]                             info)
[10:21:34.050]                           info <- base::paste(info, collapse = "; ")
[10:21:34.050]                           if (!has_future) {
[10:21:34.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.050]                               info)
[10:21:34.050]                           }
[10:21:34.050]                           else {
[10:21:34.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.050]                               info, version)
[10:21:34.050]                           }
[10:21:34.050]                           base::stop(msg)
[10:21:34.050]                         }
[10:21:34.050]                       })
[10:21:34.050]                     }
[10:21:34.050]                     base::local({
[10:21:34.050]                       for (pkg in "future") {
[10:21:34.050]                         base::loadNamespace(pkg)
[10:21:34.050]                         base::library(pkg, character.only = TRUE)
[10:21:34.050]                       }
[10:21:34.050]                     })
[10:21:34.050]                   }
[10:21:34.050]                   ...future.strategy.old <- future::plan("list")
[10:21:34.050]                   options(future.plan = NULL)
[10:21:34.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.050]                   future::plan(list(function (..., envir = parent.frame()) 
[10:21:34.050]                   {
[10:21:34.050]                     future <- SequentialFuture(..., envir = envir)
[10:21:34.050]                     if (!future$lazy) 
[10:21:34.050]                       future <- run(future)
[10:21:34.050]                     invisible(future)
[10:21:34.050]                   }), .cleanup = FALSE, .init = FALSE)
[10:21:34.050]                 }
[10:21:34.050]                 ...future.workdir <- getwd()
[10:21:34.050]             }
[10:21:34.050]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.050]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.050]         }
[10:21:34.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.050]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.050]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.050]             base::names(...future.oldOptions))
[10:21:34.050]     }
[10:21:34.050]     if (FALSE) {
[10:21:34.050]     }
[10:21:34.050]     else {
[10:21:34.050]         if (TRUE) {
[10:21:34.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.050]                 open = "w")
[10:21:34.050]         }
[10:21:34.050]         else {
[10:21:34.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.050]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.050]         }
[10:21:34.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.050]             base::sink(type = "output", split = FALSE)
[10:21:34.050]             base::close(...future.stdout)
[10:21:34.050]         }, add = TRUE)
[10:21:34.050]     }
[10:21:34.050]     ...future.frame <- base::sys.nframe()
[10:21:34.050]     ...future.conditions <- base::list()
[10:21:34.050]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.050]     if (FALSE) {
[10:21:34.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.050]     }
[10:21:34.050]     ...future.result <- base::tryCatch({
[10:21:34.050]         base::withCallingHandlers({
[10:21:34.050]             ...future.value <- base::withVisible(base::local({
[10:21:34.050]                 a %<-% subset(data, x < 3)$y
[10:21:34.050]                 a
[10:21:34.050]             }))
[10:21:34.050]             future::FutureResult(value = ...future.value$value, 
[10:21:34.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.050]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.050]                     ...future.globalenv.names))
[10:21:34.050]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.050]         }, condition = base::local({
[10:21:34.050]             c <- base::c
[10:21:34.050]             inherits <- base::inherits
[10:21:34.050]             invokeRestart <- base::invokeRestart
[10:21:34.050]             length <- base::length
[10:21:34.050]             list <- base::list
[10:21:34.050]             seq.int <- base::seq.int
[10:21:34.050]             signalCondition <- base::signalCondition
[10:21:34.050]             sys.calls <- base::sys.calls
[10:21:34.050]             `[[` <- base::`[[`
[10:21:34.050]             `+` <- base::`+`
[10:21:34.050]             `<<-` <- base::`<<-`
[10:21:34.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.050]                   3L)]
[10:21:34.050]             }
[10:21:34.050]             function(cond) {
[10:21:34.050]                 is_error <- inherits(cond, "error")
[10:21:34.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.050]                   NULL)
[10:21:34.050]                 if (is_error) {
[10:21:34.050]                   sessionInformation <- function() {
[10:21:34.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.050]                       search = base::search(), system = base::Sys.info())
[10:21:34.050]                   }
[10:21:34.050]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.050]                     cond$call), session = sessionInformation(), 
[10:21:34.050]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.050]                   signalCondition(cond)
[10:21:34.050]                 }
[10:21:34.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.050]                 "immediateCondition"))) {
[10:21:34.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.050]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.050]                   if (TRUE && !signal) {
[10:21:34.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.050]                     {
[10:21:34.050]                       inherits <- base::inherits
[10:21:34.050]                       invokeRestart <- base::invokeRestart
[10:21:34.050]                       is.null <- base::is.null
[10:21:34.050]                       muffled <- FALSE
[10:21:34.050]                       if (inherits(cond, "message")) {
[10:21:34.050]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.050]                         if (muffled) 
[10:21:34.050]                           invokeRestart("muffleMessage")
[10:21:34.050]                       }
[10:21:34.050]                       else if (inherits(cond, "warning")) {
[10:21:34.050]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.050]                         if (muffled) 
[10:21:34.050]                           invokeRestart("muffleWarning")
[10:21:34.050]                       }
[10:21:34.050]                       else if (inherits(cond, "condition")) {
[10:21:34.050]                         if (!is.null(pattern)) {
[10:21:34.050]                           computeRestarts <- base::computeRestarts
[10:21:34.050]                           grepl <- base::grepl
[10:21:34.050]                           restarts <- computeRestarts(cond)
[10:21:34.050]                           for (restart in restarts) {
[10:21:34.050]                             name <- restart$name
[10:21:34.050]                             if (is.null(name)) 
[10:21:34.050]                               next
[10:21:34.050]                             if (!grepl(pattern, name)) 
[10:21:34.050]                               next
[10:21:34.050]                             invokeRestart(restart)
[10:21:34.050]                             muffled <- TRUE
[10:21:34.050]                             break
[10:21:34.050]                           }
[10:21:34.050]                         }
[10:21:34.050]                       }
[10:21:34.050]                       invisible(muffled)
[10:21:34.050]                     }
[10:21:34.050]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.050]                   }
[10:21:34.050]                 }
[10:21:34.050]                 else {
[10:21:34.050]                   if (TRUE) {
[10:21:34.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.050]                     {
[10:21:34.050]                       inherits <- base::inherits
[10:21:34.050]                       invokeRestart <- base::invokeRestart
[10:21:34.050]                       is.null <- base::is.null
[10:21:34.050]                       muffled <- FALSE
[10:21:34.050]                       if (inherits(cond, "message")) {
[10:21:34.050]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.050]                         if (muffled) 
[10:21:34.050]                           invokeRestart("muffleMessage")
[10:21:34.050]                       }
[10:21:34.050]                       else if (inherits(cond, "warning")) {
[10:21:34.050]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.050]                         if (muffled) 
[10:21:34.050]                           invokeRestart("muffleWarning")
[10:21:34.050]                       }
[10:21:34.050]                       else if (inherits(cond, "condition")) {
[10:21:34.050]                         if (!is.null(pattern)) {
[10:21:34.050]                           computeRestarts <- base::computeRestarts
[10:21:34.050]                           grepl <- base::grepl
[10:21:34.050]                           restarts <- computeRestarts(cond)
[10:21:34.050]                           for (restart in restarts) {
[10:21:34.050]                             name <- restart$name
[10:21:34.050]                             if (is.null(name)) 
[10:21:34.050]                               next
[10:21:34.050]                             if (!grepl(pattern, name)) 
[10:21:34.050]                               next
[10:21:34.050]                             invokeRestart(restart)
[10:21:34.050]                             muffled <- TRUE
[10:21:34.050]                             break
[10:21:34.050]                           }
[10:21:34.050]                         }
[10:21:34.050]                       }
[10:21:34.050]                       invisible(muffled)
[10:21:34.050]                     }
[10:21:34.050]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.050]                   }
[10:21:34.050]                 }
[10:21:34.050]             }
[10:21:34.050]         }))
[10:21:34.050]     }, error = function(ex) {
[10:21:34.050]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.050]                 ...future.rng), started = ...future.startTime, 
[10:21:34.050]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.050]             version = "1.8"), class = "FutureResult")
[10:21:34.050]     }, finally = {
[10:21:34.050]         if (!identical(...future.workdir, getwd())) 
[10:21:34.050]             setwd(...future.workdir)
[10:21:34.050]         {
[10:21:34.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.050]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.050]             }
[10:21:34.050]             base::options(...future.oldOptions)
[10:21:34.050]             if (.Platform$OS.type == "windows") {
[10:21:34.050]                 old_names <- names(...future.oldEnvVars)
[10:21:34.050]                 envs <- base::Sys.getenv()
[10:21:34.050]                 names <- names(envs)
[10:21:34.050]                 common <- intersect(names, old_names)
[10:21:34.050]                 added <- setdiff(names, old_names)
[10:21:34.050]                 removed <- setdiff(old_names, names)
[10:21:34.050]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.050]                   envs[common]]
[10:21:34.050]                 NAMES <- toupper(changed)
[10:21:34.050]                 args <- list()
[10:21:34.050]                 for (kk in seq_along(NAMES)) {
[10:21:34.050]                   name <- changed[[kk]]
[10:21:34.050]                   NAME <- NAMES[[kk]]
[10:21:34.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.050]                     next
[10:21:34.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.050]                 }
[10:21:34.050]                 NAMES <- toupper(added)
[10:21:34.050]                 for (kk in seq_along(NAMES)) {
[10:21:34.050]                   name <- added[[kk]]
[10:21:34.050]                   NAME <- NAMES[[kk]]
[10:21:34.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.050]                     next
[10:21:34.050]                   args[[name]] <- ""
[10:21:34.050]                 }
[10:21:34.050]                 NAMES <- toupper(removed)
[10:21:34.050]                 for (kk in seq_along(NAMES)) {
[10:21:34.050]                   name <- removed[[kk]]
[10:21:34.050]                   NAME <- NAMES[[kk]]
[10:21:34.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.050]                     next
[10:21:34.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.050]                 }
[10:21:34.050]                 if (length(args) > 0) 
[10:21:34.050]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.050]             }
[10:21:34.050]             else {
[10:21:34.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.050]             }
[10:21:34.050]             {
[10:21:34.050]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.050]                   0L) {
[10:21:34.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.050]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.050]                   base::options(opts)
[10:21:34.050]                 }
[10:21:34.050]                 {
[10:21:34.050]                   {
[10:21:34.050]                     NULL
[10:21:34.050]                     RNGkind("Mersenne-Twister")
[10:21:34.050]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:34.050]                       inherits = FALSE)
[10:21:34.050]                   }
[10:21:34.050]                   options(future.plan = NULL)
[10:21:34.050]                   if (is.na(NA_character_)) 
[10:21:34.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.050]                     .init = FALSE)
[10:21:34.050]                 }
[10:21:34.050]             }
[10:21:34.050]         }
[10:21:34.050]     })
[10:21:34.050]     if (TRUE) {
[10:21:34.050]         base::sink(type = "output", split = FALSE)
[10:21:34.050]         if (TRUE) {
[10:21:34.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.050]         }
[10:21:34.050]         else {
[10:21:34.050]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.050]         }
[10:21:34.050]         base::close(...future.stdout)
[10:21:34.050]         ...future.stdout <- NULL
[10:21:34.050]     }
[10:21:34.050]     ...future.result$conditions <- ...future.conditions
[10:21:34.050]     ...future.result$finished <- base::Sys.time()
[10:21:34.050]     ...future.result
[10:21:34.050] }
[10:21:34.052] assign_globals() ...
[10:21:34.052] List of 1
[10:21:34.052]  $ data:'data.frame':	5 obs. of  2 variables:
[10:21:34.052]   ..$ x: int [1:5] 1 2 3 4 5
[10:21:34.052]   ..$ y: int [1:5] 1 2 3 4 5
[10:21:34.052]  - attr(*, "where")=List of 1
[10:21:34.052]   ..$ data:<environment: R_EmptyEnv> 
[10:21:34.052]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:34.052]  - attr(*, "resolved")= logi FALSE
[10:21:34.052]  - attr(*, "total_size")= num 356
[10:21:34.052]  - attr(*, "already-done")= logi TRUE
[10:21:34.055] - copied ‘data’ to environment
[10:21:34.055] assign_globals() ... done
[10:21:34.056] plan(): Setting new future strategy stack:
[10:21:34.056] List of future strategies:
[10:21:34.056] 1. sequential:
[10:21:34.056]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.056]    - tweaked: FALSE
[10:21:34.056]    - call: plan(list(sequential, strategy))
[10:21:34.056] plan(): nbrOfWorkers() = 1
[10:21:34.084] plan(): Setting new future strategy stack:
[10:21:34.084] List of future strategies:
[10:21:34.084] 1. sequential:
[10:21:34.084]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.084]    - tweaked: FALSE
[10:21:34.084]    - call: plan(list(sequential, strategy))
[10:21:34.084] 2. sequential:
[10:21:34.084]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.084]    - tweaked: FALSE
[10:21:34.084]    - call: plan(list(sequential, strategy))
[10:21:34.085] plan(): nbrOfWorkers() = 1
[10:21:34.085] SequentialFuture started (and completed)
[10:21:34.085] signalConditions() ...
[10:21:34.085]  - include = ‘immediateCondition’
[10:21:34.086]  - exclude = 
[10:21:34.086]  - resignal = FALSE
[10:21:34.086]  - Number of conditions: 53
[10:21:34.086] signalConditions() ... done
[10:21:34.086] - Launch lazy future ... done
[10:21:34.086] run() for ‘SequentialFuture’ ... done
[10:21:34.086] signalConditions() ...
[10:21:34.086]  - include = ‘immediateCondition’
[10:21:34.086]  - exclude = 
[10:21:34.086]  - resignal = FALSE
[10:21:34.086]  - Number of conditions: 53
[10:21:34.087] signalConditions() ... done
[10:21:34.087] Future state: ‘finished’
[10:21:34.087] signalConditions() ...
[10:21:34.087]  - include = ‘condition’
[10:21:34.087]  - exclude = ‘immediateCondition’
[10:21:34.087]  - resignal = TRUE
[10:21:34.087]  - Number of conditions: 53
[10:21:34.087]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.057] getGlobalsAndPackages() ...
[10:21:34.087]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.087]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.070] Searching for globals...
[10:21:34.087]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.071] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:21:34.088]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.071] Searching for globals ... DONE
[10:21:34.088]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.071] Resolving globals: FALSE
[10:21:34.088]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.072] The total size of the 1 globals is 356 bytes (356 bytes)
[10:21:34.088]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.073] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:21:34.088]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.073] - globals: [1] ‘data’
[10:21:34.088]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.073] 
[10:21:34.088]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.073] getGlobalsAndPackages() ... DONE
[10:21:34.088]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.073] run() for ‘Future’ ...
[10:21:34.089]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.073] - state: ‘created’
[10:21:34.089]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.073] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:34.089]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.074] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:34.089]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:34.089]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.074]   - Field: ‘label’
[10:21:34.089]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.074]   - Field: ‘local’
[10:21:34.089]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.074]   - Field: ‘owner’
[10:21:34.089]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.074]   - Field: ‘envir’
[10:21:34.089]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.074]   - Field: ‘packages’
[10:21:34.090]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘gc’
[10:21:34.090]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘conditions’
[10:21:34.090]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘expr’
[10:21:34.090]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘uuid’
[10:21:34.090]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘seed’
[10:21:34.090]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘version’
[10:21:34.090]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘result’
[10:21:34.090]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘asynchronous’
[10:21:34.090]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘calls’
[10:21:34.091]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘globals’
[10:21:34.091]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.075]   - Field: ‘stdout’
[10:21:34.091]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.076]   - Field: ‘earlySignal’
[10:21:34.091]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.076]   - Field: ‘lazy’
[10:21:34.091]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.076]   - Field: ‘state’
[10:21:34.091]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:34.091]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.076] - Launch lazy future ...
[10:21:34.091]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.076] Packages needed by the future expression (n = 0): <none>
[10:21:34.091]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.076] Packages needed by future strategies (n = 0): <none>
[10:21:34.092]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.077] {
[10:21:34.077]     {
[10:21:34.077]         {
[10:21:34.077]             ...future.startTime <- base::Sys.time()
[10:21:34.077]             {
[10:21:34.077]                 {
[10:21:34.077]                   {
[10:21:34.077]                     base::local({
[10:21:34.077]                       has_future <- base::requireNamespace("future", 
[10:21:34.077]                         quietly = TRUE)
[10:21:34.077]                       if (has_future) {
[10:21:34.077]                         ns <- base::getNamespace("future")
[10:21:34.077]                         version <- ns[[".package"]][["version"]]
[10:21:34.077]                         if (is.null(version)) 
[10:21:34.077]                           version <- utils::packageVersion("future")
[10:21:34.077]                       }
[10:21:34.077]                       else {
[10:21:34.077]                         version <- NULL
[10:21:34.077]                       }
[10:21:34.077]                       if (!has_future || version < "1.8.0") {
[10:21:34.077]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.077]                           "", base::R.version$version.string), 
[10:21:34.077]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:34.077]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.077]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.077]                             "release", "version")], collapse = " "), 
[10:21:34.077]                           hostname = base::Sys.info()[["nodename"]])
[10:21:34.077]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.077]                           info)
[10:21:34.077]                         info <- base::paste(info, collapse = "; ")
[10:21:34.077]                         if (!has_future) {
[10:21:34.077]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.077]                             info)
[10:21:34.077]                         }
[10:21:34.077]                         else {
[10:21:34.077]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.077]                             info, version)
[10:21:34.077]                         }
[10:21:34.077]                         base::stop(msg)
[10:21:34.077]                       }
[10:21:34.077]                     })
[10:21:34.077]                   }
[10:21:34.077]                   ...future.strategy.old <- future::plan("list")
[10:21:34.077]                   options(future.plan = NULL)
[10:21:34.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.077]                 }
[10:21:34.077]                 ...future.workdir <- getwd()
[10:21:34.077]             }
[10:21:34.077]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.077]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.077]         }
[10:21:34.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.077]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.077]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.077]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.077]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.077]             base::names(...future.oldOptions))
[10:21:34.077]     }
[10:21:34.077]     if (FALSE) {
[10:21:34.077]     }
[10:21:34.077]     else {
[10:21:34.077]         if (TRUE) {
[10:21:34.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.077]                 open = "w")
[10:21:34.077]         }
[10:21:34.077]         else {
[10:21:34.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.077]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.077]         }
[10:21:34.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.077]             base::sink(type = "output", split = FALSE)
[10:21:34.077]             base::close(...future.stdout)
[10:21:34.077]         }, add = TRUE)
[10:21:34.077]     }
[10:21:34.077]     ...future.frame <- base::sys.nframe()
[10:21:34.077]     ...future.conditions <- base::list()
[10:21:34.077]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.077]     if (FALSE) {
[10:21:34.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.077]     }
[10:21:34.077]     ...future.result <- base::tryCatch({
[10:21:34.077]         base::withCallingHandlers({
[10:21:34.077]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:21:34.077]                 x < 3)$y))
[10:21:34.077]             future::FutureResult(value = ...future.value$value, 
[10:21:34.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.077]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.077]                     ...future.globalenv.names))
[10:21:34.077]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.077]         }, condition = base::local({
[10:21:34.077]             c <- base::c
[10:21:34.077]             inherits <- base::inherits
[10:21:34.077]             invokeRestart <- base::invokeRestart
[10:21:34.077]             length <- base::length
[10:21:34.077]             list <- base::list
[10:21:34.077]             seq.int <- base::seq.int
[10:21:34.077]             signalCondition <- base::signalCondition
[10:21:34.077]             sys.calls <- base::sys.calls
[10:21:34.077]             `[[` <- base::`[[`
[10:21:34.077]             `+` <- base::`+`
[10:21:34.077]             `<<-` <- base::`<<-`
[10:21:34.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.077]                   3L)]
[10:21:34.077]             }
[10:21:34.077]             function(cond) {
[10:21:34.077]                 is_error <- inherits(cond, "error")
[10:21:34.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.077]                   NULL)
[10:21:34.077]                 if (is_error) {
[10:21:34.077]                   sessionInformation <- function() {
[10:21:34.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.077]                       search = base::search(), system = base::Sys.info())
[10:21:34.077]                   }
[10:21:34.077]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.077]                     cond$call), session = sessionInformation(), 
[10:21:34.077]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.077]                   signalCondition(cond)
[10:21:34.077]                 }
[10:21:34.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.077]                 "immediateCondition"))) {
[10:21:34.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.077]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.077]                   if (TRUE && !signal) {
[10:21:34.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.077]                     {
[10:21:34.077]                       inherits <- base::inherits
[10:21:34.077]                       invokeRestart <- base::invokeRestart
[10:21:34.077]                       is.null <- base::is.null
[10:21:34.077]                       muffled <- FALSE
[10:21:34.077]                       if (inherits(cond, "message")) {
[10:21:34.077]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.077]                         if (muffled) 
[10:21:34.077]                           invokeRestart("muffleMessage")
[10:21:34.077]                       }
[10:21:34.077]                       else if (inherits(cond, "warning")) {
[10:21:34.077]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.077]                         if (muffled) 
[10:21:34.077]                           invokeRestart("muffleWarning")
[10:21:34.077]                       }
[10:21:34.077]                       else if (inherits(cond, "condition")) {
[10:21:34.077]                         if (!is.null(pattern)) {
[10:21:34.077]                           computeRestarts <- base::computeRestarts
[10:21:34.077]                           grepl <- base::grepl
[10:21:34.077]                           restarts <- computeRestarts(cond)
[10:21:34.077]                           for (restart in restarts) {
[10:21:34.077]                             name <- restart$name
[10:21:34.077]                             if (is.null(name)) 
[10:21:34.077]                               next
[10:21:34.077]                             if (!grepl(pattern, name)) 
[10:21:34.077]                               next
[10:21:34.077]                             invokeRestart(restart)
[10:21:34.077]                             muffled <- TRUE
[10:21:34.077]                             break
[10:21:34.077]                           }
[10:21:34.077]                         }
[10:21:34.077]                       }
[10:21:34.077]                       invisible(muffled)
[10:21:34.077]                     }
[10:21:34.077]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.077]                   }
[10:21:34.077]                 }
[10:21:34.077]                 else {
[10:21:34.077]                   if (TRUE) {
[10:21:34.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.077]                     {
[10:21:34.077]                       inherits <- base::inherits
[10:21:34.077]                       invokeRestart <- base::invokeRestart
[10:21:34.077]                       is.null <- base::is.null
[10:21:34.077]                       muffled <- FALSE
[10:21:34.077]                       if (inherits(cond, "message")) {
[10:21:34.077]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.077]                         if (muffled) 
[10:21:34.077]                           invokeRestart("muffleMessage")
[10:21:34.077]                       }
[10:21:34.077]                       else if (inherits(cond, "warning")) {
[10:21:34.077]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.077]                         if (muffled) 
[10:21:34.077]                           invokeRestart("muffleWarning")
[10:21:34.077]                       }
[10:21:34.077]                       else if (inherits(cond, "condition")) {
[10:21:34.077]                         if (!is.null(pattern)) {
[10:21:34.077]                           computeRestarts <- base::computeRestarts
[10:21:34.077]                           grepl <- base::grepl
[10:21:34.077]                           restarts <- computeRestarts(cond)
[10:21:34.077]                           for (restart in restarts) {
[10:21:34.077]                             name <- restart$name
[10:21:34.077]                             if (is.null(name)) 
[10:21:34.077]                               next
[10:21:34.077]                             if (!grepl(pattern, name)) 
[10:21:34.077]                               next
[10:21:34.077]                             invokeRestart(restart)
[10:21:34.077]                             muffled <- TRUE
[10:21:34.077]                             break
[10:21:34.077]                           }
[10:21:34.077]                         }
[10:21:34.077]                       }
[10:21:34.077]                       invisible(muffled)
[10:21:34.077]                     }
[10:21:34.077]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.077]                   }
[10:21:34.077]                 }
[10:21:34.077]             }
[10:21:34.077]         }))
[10:21:34.077]     }, error = function(ex) {
[10:21:34.077]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.077]                 ...future.rng), started = ...future.startTime, 
[10:21:34.077]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.077]             version = "1.8"), class = "FutureResult")
[10:21:34.077]     }, finally = {
[10:21:34.077]         if (!identical(...future.workdir, getwd())) 
[10:21:34.077]             setwd(...future.workdir)
[10:21:34.077]         {
[10:21:34.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.077]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.077]             }
[10:21:34.077]             base::options(...future.oldOptions)
[10:21:34.077]             if (.Platform$OS.type == "windows") {
[10:21:34.077]                 old_names <- names(...future.oldEnvVars)
[10:21:34.077]                 envs <- base::Sys.getenv()
[10:21:34.077]                 names <- names(envs)
[10:21:34.077]                 common <- intersect(names, old_names)
[10:21:34.077]                 added <- setdiff(names, old_names)
[10:21:34.077]                 removed <- setdiff(old_names, names)
[10:21:34.077]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.077]                   envs[common]]
[10:21:34.077]                 NAMES <- toupper(changed)
[10:21:34.077]                 args <- list()
[10:21:34.077]                 for (kk in seq_along(NAMES)) {
[10:21:34.077]                   name <- changed[[kk]]
[10:21:34.077]                   NAME <- NAMES[[kk]]
[10:21:34.077]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.077]                     next
[10:21:34.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.077]                 }
[10:21:34.077]                 NAMES <- toupper(added)
[10:21:34.077]                 for (kk in seq_along(NAMES)) {
[10:21:34.077]                   name <- added[[kk]]
[10:21:34.077]                   NAME <- NAMES[[kk]]
[10:21:34.077]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.077]                     next
[10:21:34.077]                   args[[name]] <- ""
[10:21:34.077]                 }
[10:21:34.077]                 NAMES <- toupper(removed)
[10:21:34.077]                 for (kk in seq_along(NAMES)) {
[10:21:34.077]                   name <- removed[[kk]]
[10:21:34.077]                   NAME <- NAMES[[kk]]
[10:21:34.077]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.077]                     next
[10:21:34.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.077]                 }
[10:21:34.077]                 if (length(args) > 0) 
[10:21:34.077]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.077]             }
[10:21:34.077]             else {
[10:21:34.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.077]             }
[10:21:34.077]             {
[10:21:34.077]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.077]                   0L) {
[10:21:34.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.077]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.077]                   base::options(opts)
[10:21:34.077]                 }
[10:21:34.077]                 {
[10:21:34.077]                   {
[10:21:34.077]                     NULL
[10:21:34.077]                     RNGkind("Mersenne-Twister")
[10:21:34.077]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:34.077]                       inherits = FALSE)
[10:21:34.077]                   }
[10:21:34.077]                   options(future.plan = NULL)
[10:21:34.077]                   if (is.na(NA_character_)) 
[10:21:34.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.077]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.077]                     .init = FALSE)
[10:21:34.077]                 }
[10:21:34.077]             }
[10:21:34.077]         }
[10:21:34.077]     })
[10:21:34.077]     if (TRUE) {
[10:21:34.077]         base::sink(type = "output", split = FALSE)
[10:21:34.077]         if (TRUE) {
[10:21:34.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.077]         }
[10:21:34.077]         else {
[10:21:34.077]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.077]         }
[10:21:34.077]         base::close(...future.stdout)
[10:21:34.077]         ...future.stdout <- NULL
[10:21:34.077]     }
[10:21:34.077]     ...future.result$conditions <- ...future.conditions
[10:21:34.077]     ...future.result$finished <- base::Sys.time()
[10:21:34.077]     ...future.result
[10:21:34.077] }
[10:21:34.092]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.078] assign_globals() ...
[10:21:34.092]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.078] List of 1
[10:21:34.078]  $ data:'data.frame':	5 obs. of  2 variables:
[10:21:34.078]   ..$ x: int [1:5] 1 2 3 4 5
[10:21:34.078]   ..$ y: int [1:5] 1 2 3 4 5
[10:21:34.078]  - attr(*, "where")=List of 1
[10:21:34.078]   ..$ data:<environment: R_EmptyEnv> 
[10:21:34.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:34.078]  - attr(*, "resolved")= logi FALSE
[10:21:34.078]  - attr(*, "total_size")= num 356
[10:21:34.078]  - attr(*, "already-done")= logi TRUE
[10:21:34.092]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.081] - copied ‘data’ to environment
[10:21:34.092]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.081] assign_globals() ... done
[10:21:34.092]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.082] plan(): Setting new future strategy stack:
[10:21:34.092]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.082] List of future strategies:
[10:21:34.082] 1. sequential:
[10:21:34.082]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.082]    - tweaked: FALSE
[10:21:34.082]    - call: NULL
[10:21:34.093]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.082] plan(): nbrOfWorkers() = 1
[10:21:34.093]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.083] plan(): Setting new future strategy stack:
[10:21:34.093]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.083] List of future strategies:
[10:21:34.083] 1. sequential:
[10:21:34.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.083]    - tweaked: FALSE
[10:21:34.083]    - call: plan(list(sequential, strategy))
[10:21:34.093]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.083] plan(): nbrOfWorkers() = 1
[10:21:34.093]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.084] SequentialFuture started (and completed)
[10:21:34.093]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.084] - Launch lazy future ... done
[10:21:34.093]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.084] run() for ‘SequentialFuture’ ... done
[10:21:34.093] signalConditions() ... done
[10:21:34.094] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.094] Searching for globals...
[10:21:34.095] - globals found: [3] ‘{’, ‘plan’, ‘sequential’
[10:21:34.095] Searching for globals ... DONE
[10:21:34.095] Resolving globals: FALSE
[10:21:34.095] 
[10:21:34.095] - packages: [1] ‘future’
[10:21:34.095] getGlobalsAndPackages() ... DONE
[10:21:34.095] run() for ‘Future’ ...
[10:21:34.096] - state: ‘created’
[10:21:34.096] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:34.097] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:34.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:34.097]   - Field: ‘label’
[10:21:34.097]   - Field: ‘local’
[10:21:34.097]   - Field: ‘owner’
[10:21:34.097]   - Field: ‘envir’
[10:21:34.098]   - Field: ‘packages’
[10:21:34.098]   - Field: ‘gc’
[10:21:34.098]   - Field: ‘conditions’
[10:21:34.098]   - Field: ‘expr’
[10:21:34.098]   - Field: ‘uuid’
[10:21:34.098]   - Field: ‘seed’
[10:21:34.098]   - Field: ‘version’
[10:21:34.098]   - Field: ‘result’
[10:21:34.098]   - Field: ‘asynchronous’
[10:21:34.098]   - Field: ‘calls’
[10:21:34.098]   - Field: ‘globals’
[10:21:34.098]   - Field: ‘stdout’
[10:21:34.099]   - Field: ‘earlySignal’
[10:21:34.099]   - Field: ‘lazy’
[10:21:34.099]   - Field: ‘state’
[10:21:34.099] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:34.099] - Launch lazy future ...
[10:21:34.099] Packages needed by the future expression (n = 1): ‘future’
[10:21:34.099] Packages needed by future strategies (n = 1): ‘future’
[10:21:34.100] {
[10:21:34.100]     {
[10:21:34.100]         {
[10:21:34.100]             ...future.startTime <- base::Sys.time()
[10:21:34.100]             {
[10:21:34.100]                 {
[10:21:34.100]                   {
[10:21:34.100]                     {
[10:21:34.100]                       base::local({
[10:21:34.100]                         has_future <- base::requireNamespace("future", 
[10:21:34.100]                           quietly = TRUE)
[10:21:34.100]                         if (has_future) {
[10:21:34.100]                           ns <- base::getNamespace("future")
[10:21:34.100]                           version <- ns[[".package"]][["version"]]
[10:21:34.100]                           if (is.null(version)) 
[10:21:34.100]                             version <- utils::packageVersion("future")
[10:21:34.100]                         }
[10:21:34.100]                         else {
[10:21:34.100]                           version <- NULL
[10:21:34.100]                         }
[10:21:34.100]                         if (!has_future || version < "1.8.0") {
[10:21:34.100]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.100]                             "", base::R.version$version.string), 
[10:21:34.100]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.100]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.100]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.100]                               "release", "version")], collapse = " "), 
[10:21:34.100]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.100]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.100]                             info)
[10:21:34.100]                           info <- base::paste(info, collapse = "; ")
[10:21:34.100]                           if (!has_future) {
[10:21:34.100]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.100]                               info)
[10:21:34.100]                           }
[10:21:34.100]                           else {
[10:21:34.100]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.100]                               info, version)
[10:21:34.100]                           }
[10:21:34.100]                           base::stop(msg)
[10:21:34.100]                         }
[10:21:34.100]                       })
[10:21:34.100]                     }
[10:21:34.100]                     base::local({
[10:21:34.100]                       for (pkg in "future") {
[10:21:34.100]                         base::loadNamespace(pkg)
[10:21:34.100]                         base::library(pkg, character.only = TRUE)
[10:21:34.100]                       }
[10:21:34.100]                     })
[10:21:34.100]                   }
[10:21:34.100]                   ...future.strategy.old <- future::plan("list")
[10:21:34.100]                   options(future.plan = NULL)
[10:21:34.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.100]                   future::plan(list(function (..., envir = parent.frame()) 
[10:21:34.100]                   {
[10:21:34.100]                     future <- SequentialFuture(..., envir = envir)
[10:21:34.100]                     if (!future$lazy) 
[10:21:34.100]                       future <- run(future)
[10:21:34.100]                     invisible(future)
[10:21:34.100]                   }), .cleanup = FALSE, .init = FALSE)
[10:21:34.100]                 }
[10:21:34.100]                 ...future.workdir <- getwd()
[10:21:34.100]             }
[10:21:34.100]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.100]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.100]         }
[10:21:34.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.100]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.100]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.100]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.100]             base::names(...future.oldOptions))
[10:21:34.100]     }
[10:21:34.100]     if (FALSE) {
[10:21:34.100]     }
[10:21:34.100]     else {
[10:21:34.100]         if (TRUE) {
[10:21:34.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.100]                 open = "w")
[10:21:34.100]         }
[10:21:34.100]         else {
[10:21:34.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.100]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.100]         }
[10:21:34.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.100]             base::sink(type = "output", split = FALSE)
[10:21:34.100]             base::close(...future.stdout)
[10:21:34.100]         }, add = TRUE)
[10:21:34.100]     }
[10:21:34.100]     ...future.frame <- base::sys.nframe()
[10:21:34.100]     ...future.conditions <- base::list()
[10:21:34.100]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.100]     if (FALSE) {
[10:21:34.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.100]     }
[10:21:34.100]     ...future.result <- base::tryCatch({
[10:21:34.100]         base::withCallingHandlers({
[10:21:34.100]             ...future.value <- base::withVisible(base::local({
[10:21:34.100]                 plan(sequential)
[10:21:34.100]             }))
[10:21:34.100]             future::FutureResult(value = ...future.value$value, 
[10:21:34.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.100]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.100]                     ...future.globalenv.names))
[10:21:34.100]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.100]         }, condition = base::local({
[10:21:34.100]             c <- base::c
[10:21:34.100]             inherits <- base::inherits
[10:21:34.100]             invokeRestart <- base::invokeRestart
[10:21:34.100]             length <- base::length
[10:21:34.100]             list <- base::list
[10:21:34.100]             seq.int <- base::seq.int
[10:21:34.100]             signalCondition <- base::signalCondition
[10:21:34.100]             sys.calls <- base::sys.calls
[10:21:34.100]             `[[` <- base::`[[`
[10:21:34.100]             `+` <- base::`+`
[10:21:34.100]             `<<-` <- base::`<<-`
[10:21:34.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.100]                   3L)]
[10:21:34.100]             }
[10:21:34.100]             function(cond) {
[10:21:34.100]                 is_error <- inherits(cond, "error")
[10:21:34.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.100]                   NULL)
[10:21:34.100]                 if (is_error) {
[10:21:34.100]                   sessionInformation <- function() {
[10:21:34.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.100]                       search = base::search(), system = base::Sys.info())
[10:21:34.100]                   }
[10:21:34.100]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.100]                     cond$call), session = sessionInformation(), 
[10:21:34.100]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.100]                   signalCondition(cond)
[10:21:34.100]                 }
[10:21:34.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.100]                 "immediateCondition"))) {
[10:21:34.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.100]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.100]                   if (TRUE && !signal) {
[10:21:34.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.100]                     {
[10:21:34.100]                       inherits <- base::inherits
[10:21:34.100]                       invokeRestart <- base::invokeRestart
[10:21:34.100]                       is.null <- base::is.null
[10:21:34.100]                       muffled <- FALSE
[10:21:34.100]                       if (inherits(cond, "message")) {
[10:21:34.100]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.100]                         if (muffled) 
[10:21:34.100]                           invokeRestart("muffleMessage")
[10:21:34.100]                       }
[10:21:34.100]                       else if (inherits(cond, "warning")) {
[10:21:34.100]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.100]                         if (muffled) 
[10:21:34.100]                           invokeRestart("muffleWarning")
[10:21:34.100]                       }
[10:21:34.100]                       else if (inherits(cond, "condition")) {
[10:21:34.100]                         if (!is.null(pattern)) {
[10:21:34.100]                           computeRestarts <- base::computeRestarts
[10:21:34.100]                           grepl <- base::grepl
[10:21:34.100]                           restarts <- computeRestarts(cond)
[10:21:34.100]                           for (restart in restarts) {
[10:21:34.100]                             name <- restart$name
[10:21:34.100]                             if (is.null(name)) 
[10:21:34.100]                               next
[10:21:34.100]                             if (!grepl(pattern, name)) 
[10:21:34.100]                               next
[10:21:34.100]                             invokeRestart(restart)
[10:21:34.100]                             muffled <- TRUE
[10:21:34.100]                             break
[10:21:34.100]                           }
[10:21:34.100]                         }
[10:21:34.100]                       }
[10:21:34.100]                       invisible(muffled)
[10:21:34.100]                     }
[10:21:34.100]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.100]                   }
[10:21:34.100]                 }
[10:21:34.100]                 else {
[10:21:34.100]                   if (TRUE) {
[10:21:34.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.100]                     {
[10:21:34.100]                       inherits <- base::inherits
[10:21:34.100]                       invokeRestart <- base::invokeRestart
[10:21:34.100]                       is.null <- base::is.null
[10:21:34.100]                       muffled <- FALSE
[10:21:34.100]                       if (inherits(cond, "message")) {
[10:21:34.100]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.100]                         if (muffled) 
[10:21:34.100]                           invokeRestart("muffleMessage")
[10:21:34.100]                       }
[10:21:34.100]                       else if (inherits(cond, "warning")) {
[10:21:34.100]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.100]                         if (muffled) 
[10:21:34.100]                           invokeRestart("muffleWarning")
[10:21:34.100]                       }
[10:21:34.100]                       else if (inherits(cond, "condition")) {
[10:21:34.100]                         if (!is.null(pattern)) {
[10:21:34.100]                           computeRestarts <- base::computeRestarts
[10:21:34.100]                           grepl <- base::grepl
[10:21:34.100]                           restarts <- computeRestarts(cond)
[10:21:34.100]                           for (restart in restarts) {
[10:21:34.100]                             name <- restart$name
[10:21:34.100]                             if (is.null(name)) 
[10:21:34.100]                               next
[10:21:34.100]                             if (!grepl(pattern, name)) 
[10:21:34.100]                               next
[10:21:34.100]                             invokeRestart(restart)
[10:21:34.100]                             muffled <- TRUE
[10:21:34.100]                             break
[10:21:34.100]                           }
[10:21:34.100]                         }
[10:21:34.100]                       }
[10:21:34.100]                       invisible(muffled)
[10:21:34.100]                     }
[10:21:34.100]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.100]                   }
[10:21:34.100]                 }
[10:21:34.100]             }
[10:21:34.100]         }))
[10:21:34.100]     }, error = function(ex) {
[10:21:34.100]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.100]                 ...future.rng), started = ...future.startTime, 
[10:21:34.100]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.100]             version = "1.8"), class = "FutureResult")
[10:21:34.100]     }, finally = {
[10:21:34.100]         if (!identical(...future.workdir, getwd())) 
[10:21:34.100]             setwd(...future.workdir)
[10:21:34.100]         {
[10:21:34.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.100]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.100]             }
[10:21:34.100]             base::options(...future.oldOptions)
[10:21:34.100]             if (.Platform$OS.type == "windows") {
[10:21:34.100]                 old_names <- names(...future.oldEnvVars)
[10:21:34.100]                 envs <- base::Sys.getenv()
[10:21:34.100]                 names <- names(envs)
[10:21:34.100]                 common <- intersect(names, old_names)
[10:21:34.100]                 added <- setdiff(names, old_names)
[10:21:34.100]                 removed <- setdiff(old_names, names)
[10:21:34.100]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.100]                   envs[common]]
[10:21:34.100]                 NAMES <- toupper(changed)
[10:21:34.100]                 args <- list()
[10:21:34.100]                 for (kk in seq_along(NAMES)) {
[10:21:34.100]                   name <- changed[[kk]]
[10:21:34.100]                   NAME <- NAMES[[kk]]
[10:21:34.100]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.100]                     next
[10:21:34.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.100]                 }
[10:21:34.100]                 NAMES <- toupper(added)
[10:21:34.100]                 for (kk in seq_along(NAMES)) {
[10:21:34.100]                   name <- added[[kk]]
[10:21:34.100]                   NAME <- NAMES[[kk]]
[10:21:34.100]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.100]                     next
[10:21:34.100]                   args[[name]] <- ""
[10:21:34.100]                 }
[10:21:34.100]                 NAMES <- toupper(removed)
[10:21:34.100]                 for (kk in seq_along(NAMES)) {
[10:21:34.100]                   name <- removed[[kk]]
[10:21:34.100]                   NAME <- NAMES[[kk]]
[10:21:34.100]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.100]                     next
[10:21:34.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.100]                 }
[10:21:34.100]                 if (length(args) > 0) 
[10:21:34.100]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.100]             }
[10:21:34.100]             else {
[10:21:34.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.100]             }
[10:21:34.100]             {
[10:21:34.100]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.100]                   0L) {
[10:21:34.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.100]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.100]                   base::options(opts)
[10:21:34.100]                 }
[10:21:34.100]                 {
[10:21:34.100]                   {
[10:21:34.100]                     NULL
[10:21:34.100]                     RNGkind("Mersenne-Twister")
[10:21:34.100]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:34.100]                       inherits = FALSE)
[10:21:34.100]                   }
[10:21:34.100]                   options(future.plan = NULL)
[10:21:34.100]                   if (is.na(NA_character_)) 
[10:21:34.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.100]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.100]                     .init = FALSE)
[10:21:34.100]                 }
[10:21:34.100]             }
[10:21:34.100]         }
[10:21:34.100]     })
[10:21:34.100]     if (TRUE) {
[10:21:34.100]         base::sink(type = "output", split = FALSE)
[10:21:34.100]         if (TRUE) {
[10:21:34.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.100]         }
[10:21:34.100]         else {
[10:21:34.100]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.100]         }
[10:21:34.100]         base::close(...future.stdout)
[10:21:34.100]         ...future.stdout <- NULL
[10:21:34.100]     }
[10:21:34.100]     ...future.result$conditions <- ...future.conditions
[10:21:34.100]     ...future.result$finished <- base::Sys.time()
[10:21:34.100]     ...future.result
[10:21:34.100] }
[10:21:34.102] plan(): Setting new future strategy stack:
[10:21:34.102] List of future strategies:
[10:21:34.102] 1. sequential:
[10:21:34.102]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.102]    - tweaked: FALSE
[10:21:34.102]    - call: plan(list(sequential, strategy))
[10:21:34.102] plan(): nbrOfWorkers() = 1
[10:21:34.116] plan(): Setting new future strategy stack:
[10:21:34.116] List of future strategies:
[10:21:34.116] 1. sequential:
[10:21:34.116]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.116]    - tweaked: FALSE
[10:21:34.116]    - call: plan(list(sequential, strategy))
[10:21:34.116] 2. sequential:
[10:21:34.116]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.116]    - tweaked: FALSE
[10:21:34.116]    - call: plan(list(sequential, strategy))
[10:21:34.116] plan(): nbrOfWorkers() = 1
[10:21:34.117] SequentialFuture started (and completed)
[10:21:34.117] signalConditions() ...
[10:21:34.117]  - include = ‘immediateCondition’
[10:21:34.117]  - exclude = 
[10:21:34.117]  - resignal = FALSE
[10:21:34.117]  - Number of conditions: 3
[10:21:34.118] signalConditions() ... done
[10:21:34.118] - Launch lazy future ... done
[10:21:34.118] run() for ‘SequentialFuture’ ... done
[10:21:34.118] signalConditions() ...
[10:21:34.118]  - include = ‘immediateCondition’
[10:21:34.119]  - exclude = 
[10:21:34.119]  - resignal = FALSE
[10:21:34.119]  - Number of conditions: 3
[10:21:34.119] signalConditions() ... done
[10:21:34.119] Future state: ‘finished’
[10:21:34.119] signalConditions() ...
[10:21:34.119]  - include = ‘condition’
[10:21:34.119]  - exclude = ‘immediateCondition’
[10:21:34.119]  - resignal = TRUE
[10:21:34.119]  - Number of conditions: 3
[10:21:34.119]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.103] plan(): Setting new future strategy stack:
[10:21:34.120]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.103] List of future strategies:
[10:21:34.103] 1. sequential:
[10:21:34.103]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.103]    - tweaked: FALSE
[10:21:34.103]    - call: plan(sequential)
[10:21:34.120]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.115] plan(): nbrOfWorkers() = 1
[10:21:34.120] signalConditions() ... done
List of future strategies:
1. sequential:
   - args: function (..., envir = parent.frame(), workers = "<NULL>")
   - tweaked: FALSE
   - call: plan(list(sequential, strategy))
- Strategy: sequential ... DONE
- Strategy: multicore ...
[10:21:34.120] plan(): Setting new future strategy stack:
[10:21:34.121] List of future strategies:
[10:21:34.121] 1. multicore:
[10:21:34.121]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:34.121]    - tweaked: FALSE
[10:21:34.121]    - call: plan(strategy)
[10:21:34.122] plan(): nbrOfWorkers() = 2
[10:21:34.122] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:34.123] Searching for globals...
[10:21:34.123] - globals found: [1] ‘getOption’
[10:21:34.123] Searching for globals ... DONE
[10:21:34.123] Resolving globals: FALSE
[10:21:34.123] 
[10:21:34.124] 
[10:21:34.124] getGlobalsAndPackages() ... DONE
[10:21:34.124] run() for ‘Future’ ...
[10:21:34.124] - state: ‘created’
[10:21:34.124] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:34.126] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:34.126] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:34.126]   - Field: ‘label’
[10:21:34.126]   - Field: ‘local’
[10:21:34.126]   - Field: ‘owner’
[10:21:34.126]   - Field: ‘envir’
[10:21:34.126]   - Field: ‘workers’
[10:21:34.126]   - Field: ‘packages’
[10:21:34.126]   - Field: ‘gc’
[10:21:34.126]   - Field: ‘job’
[10:21:34.126]   - Field: ‘conditions’
[10:21:34.127]   - Field: ‘expr’
[10:21:34.127]   - Field: ‘uuid’
[10:21:34.127]   - Field: ‘seed’
[10:21:34.127]   - Field: ‘version’
[10:21:34.127]   - Field: ‘result’
[10:21:34.127]   - Field: ‘asynchronous’
[10:21:34.127]   - Field: ‘calls’
[10:21:34.127]   - Field: ‘globals’
[10:21:34.127]   - Field: ‘stdout’
[10:21:34.127]   - Field: ‘earlySignal’
[10:21:34.127]   - Field: ‘lazy’
[10:21:34.127]   - Field: ‘state’
[10:21:34.127] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:34.128] - Launch lazy future ...
[10:21:34.128] Packages needed by the future expression (n = 0): <none>
[10:21:34.128] Packages needed by future strategies (n = 0): <none>
[10:21:34.129] {
[10:21:34.129]     {
[10:21:34.129]         {
[10:21:34.129]             ...future.startTime <- base::Sys.time()
[10:21:34.129]             {
[10:21:34.129]                 {
[10:21:34.129]                   {
[10:21:34.129]                     {
[10:21:34.129]                       base::local({
[10:21:34.129]                         has_future <- base::requireNamespace("future", 
[10:21:34.129]                           quietly = TRUE)
[10:21:34.129]                         if (has_future) {
[10:21:34.129]                           ns <- base::getNamespace("future")
[10:21:34.129]                           version <- ns[[".package"]][["version"]]
[10:21:34.129]                           if (is.null(version)) 
[10:21:34.129]                             version <- utils::packageVersion("future")
[10:21:34.129]                         }
[10:21:34.129]                         else {
[10:21:34.129]                           version <- NULL
[10:21:34.129]                         }
[10:21:34.129]                         if (!has_future || version < "1.8.0") {
[10:21:34.129]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.129]                             "", base::R.version$version.string), 
[10:21:34.129]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.129]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.129]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.129]                               "release", "version")], collapse = " "), 
[10:21:34.129]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.129]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.129]                             info)
[10:21:34.129]                           info <- base::paste(info, collapse = "; ")
[10:21:34.129]                           if (!has_future) {
[10:21:34.129]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.129]                               info)
[10:21:34.129]                           }
[10:21:34.129]                           else {
[10:21:34.129]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.129]                               info, version)
[10:21:34.129]                           }
[10:21:34.129]                           base::stop(msg)
[10:21:34.129]                         }
[10:21:34.129]                       })
[10:21:34.129]                     }
[10:21:34.129]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:34.129]                     base::options(mc.cores = 1L)
[10:21:34.129]                   }
[10:21:34.129]                   ...future.strategy.old <- future::plan("list")
[10:21:34.129]                   options(future.plan = NULL)
[10:21:34.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.129]                 }
[10:21:34.129]                 ...future.workdir <- getwd()
[10:21:34.129]             }
[10:21:34.129]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.129]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.129]         }
[10:21:34.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:34.129]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.129]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:34.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.129]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.129]             base::names(...future.oldOptions))
[10:21:34.129]     }
[10:21:34.129]     if (FALSE) {
[10:21:34.129]     }
[10:21:34.129]     else {
[10:21:34.129]         if (TRUE) {
[10:21:34.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.129]                 open = "w")
[10:21:34.129]         }
[10:21:34.129]         else {
[10:21:34.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.129]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.129]         }
[10:21:34.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.129]             base::sink(type = "output", split = FALSE)
[10:21:34.129]             base::close(...future.stdout)
[10:21:34.129]         }, add = TRUE)
[10:21:34.129]     }
[10:21:34.129]     ...future.frame <- base::sys.nframe()
[10:21:34.129]     ...future.conditions <- base::list()
[10:21:34.129]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.129]     if (FALSE) {
[10:21:34.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.129]     }
[10:21:34.129]     ...future.result <- base::tryCatch({
[10:21:34.129]         base::withCallingHandlers({
[10:21:34.129]             ...future.value <- base::withVisible(base::local({
[10:21:34.129]                 withCallingHandlers({
[10:21:34.129]                   getOption("future.globals.onMissing")
[10:21:34.129]                 }, immediateCondition = function(cond) {
[10:21:34.129]                   save_rds <- function (object, pathname, ...) 
[10:21:34.129]                   {
[10:21:34.129]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:34.129]                     if (file_test("-f", pathname_tmp)) {
[10:21:34.129]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.129]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:34.129]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.129]                         fi_tmp[["mtime"]])
[10:21:34.129]                     }
[10:21:34.129]                     tryCatch({
[10:21:34.129]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:34.129]                     }, error = function(ex) {
[10:21:34.129]                       msg <- conditionMessage(ex)
[10:21:34.129]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.129]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:34.129]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.129]                         fi_tmp[["mtime"]], msg)
[10:21:34.129]                       ex$message <- msg
[10:21:34.129]                       stop(ex)
[10:21:34.129]                     })
[10:21:34.129]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:34.129]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:34.129]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:34.129]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.129]                       fi <- file.info(pathname)
[10:21:34.129]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:34.129]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.129]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:34.129]                         fi[["size"]], fi[["mtime"]])
[10:21:34.129]                       stop(msg)
[10:21:34.129]                     }
[10:21:34.129]                     invisible(pathname)
[10:21:34.129]                   }
[10:21:34.129]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:34.129]                     rootPath = tempdir()) 
[10:21:34.129]                   {
[10:21:34.129]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:34.129]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:34.129]                       tmpdir = path, fileext = ".rds")
[10:21:34.129]                     save_rds(obj, file)
[10:21:34.129]                   }
[10:21:34.129]                   saveImmediateCondition(cond, path = "/tmp/RtmpwqU11c/.future/immediateConditions")
[10:21:34.129]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.129]                   {
[10:21:34.129]                     inherits <- base::inherits
[10:21:34.129]                     invokeRestart <- base::invokeRestart
[10:21:34.129]                     is.null <- base::is.null
[10:21:34.129]                     muffled <- FALSE
[10:21:34.129]                     if (inherits(cond, "message")) {
[10:21:34.129]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:34.129]                       if (muffled) 
[10:21:34.129]                         invokeRestart("muffleMessage")
[10:21:34.129]                     }
[10:21:34.129]                     else if (inherits(cond, "warning")) {
[10:21:34.129]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:34.129]                       if (muffled) 
[10:21:34.129]                         invokeRestart("muffleWarning")
[10:21:34.129]                     }
[10:21:34.129]                     else if (inherits(cond, "condition")) {
[10:21:34.129]                       if (!is.null(pattern)) {
[10:21:34.129]                         computeRestarts <- base::computeRestarts
[10:21:34.129]                         grepl <- base::grepl
[10:21:34.129]                         restarts <- computeRestarts(cond)
[10:21:34.129]                         for (restart in restarts) {
[10:21:34.129]                           name <- restart$name
[10:21:34.129]                           if (is.null(name)) 
[10:21:34.129]                             next
[10:21:34.129]                           if (!grepl(pattern, name)) 
[10:21:34.129]                             next
[10:21:34.129]                           invokeRestart(restart)
[10:21:34.129]                           muffled <- TRUE
[10:21:34.129]                           break
[10:21:34.129]                         }
[10:21:34.129]                       }
[10:21:34.129]                     }
[10:21:34.129]                     invisible(muffled)
[10:21:34.129]                   }
[10:21:34.129]                   muffleCondition(cond)
[10:21:34.129]                 })
[10:21:34.129]             }))
[10:21:34.129]             future::FutureResult(value = ...future.value$value, 
[10:21:34.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.129]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.129]                     ...future.globalenv.names))
[10:21:34.129]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.129]         }, condition = base::local({
[10:21:34.129]             c <- base::c
[10:21:34.129]             inherits <- base::inherits
[10:21:34.129]             invokeRestart <- base::invokeRestart
[10:21:34.129]             length <- base::length
[10:21:34.129]             list <- base::list
[10:21:34.129]             seq.int <- base::seq.int
[10:21:34.129]             signalCondition <- base::signalCondition
[10:21:34.129]             sys.calls <- base::sys.calls
[10:21:34.129]             `[[` <- base::`[[`
[10:21:34.129]             `+` <- base::`+`
[10:21:34.129]             `<<-` <- base::`<<-`
[10:21:34.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.129]                   3L)]
[10:21:34.129]             }
[10:21:34.129]             function(cond) {
[10:21:34.129]                 is_error <- inherits(cond, "error")
[10:21:34.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.129]                   NULL)
[10:21:34.129]                 if (is_error) {
[10:21:34.129]                   sessionInformation <- function() {
[10:21:34.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.129]                       search = base::search(), system = base::Sys.info())
[10:21:34.129]                   }
[10:21:34.129]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.129]                     cond$call), session = sessionInformation(), 
[10:21:34.129]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.129]                   signalCondition(cond)
[10:21:34.129]                 }
[10:21:34.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.129]                 "immediateCondition"))) {
[10:21:34.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.129]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.129]                   if (TRUE && !signal) {
[10:21:34.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.129]                     {
[10:21:34.129]                       inherits <- base::inherits
[10:21:34.129]                       invokeRestart <- base::invokeRestart
[10:21:34.129]                       is.null <- base::is.null
[10:21:34.129]                       muffled <- FALSE
[10:21:34.129]                       if (inherits(cond, "message")) {
[10:21:34.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.129]                         if (muffled) 
[10:21:34.129]                           invokeRestart("muffleMessage")
[10:21:34.129]                       }
[10:21:34.129]                       else if (inherits(cond, "warning")) {
[10:21:34.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.129]                         if (muffled) 
[10:21:34.129]                           invokeRestart("muffleWarning")
[10:21:34.129]                       }
[10:21:34.129]                       else if (inherits(cond, "condition")) {
[10:21:34.129]                         if (!is.null(pattern)) {
[10:21:34.129]                           computeRestarts <- base::computeRestarts
[10:21:34.129]                           grepl <- base::grepl
[10:21:34.129]                           restarts <- computeRestarts(cond)
[10:21:34.129]                           for (restart in restarts) {
[10:21:34.129]                             name <- restart$name
[10:21:34.129]                             if (is.null(name)) 
[10:21:34.129]                               next
[10:21:34.129]                             if (!grepl(pattern, name)) 
[10:21:34.129]                               next
[10:21:34.129]                             invokeRestart(restart)
[10:21:34.129]                             muffled <- TRUE
[10:21:34.129]                             break
[10:21:34.129]                           }
[10:21:34.129]                         }
[10:21:34.129]                       }
[10:21:34.129]                       invisible(muffled)
[10:21:34.129]                     }
[10:21:34.129]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.129]                   }
[10:21:34.129]                 }
[10:21:34.129]                 else {
[10:21:34.129]                   if (TRUE) {
[10:21:34.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.129]                     {
[10:21:34.129]                       inherits <- base::inherits
[10:21:34.129]                       invokeRestart <- base::invokeRestart
[10:21:34.129]                       is.null <- base::is.null
[10:21:34.129]                       muffled <- FALSE
[10:21:34.129]                       if (inherits(cond, "message")) {
[10:21:34.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.129]                         if (muffled) 
[10:21:34.129]                           invokeRestart("muffleMessage")
[10:21:34.129]                       }
[10:21:34.129]                       else if (inherits(cond, "warning")) {
[10:21:34.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.129]                         if (muffled) 
[10:21:34.129]                           invokeRestart("muffleWarning")
[10:21:34.129]                       }
[10:21:34.129]                       else if (inherits(cond, "condition")) {
[10:21:34.129]                         if (!is.null(pattern)) {
[10:21:34.129]                           computeRestarts <- base::computeRestarts
[10:21:34.129]                           grepl <- base::grepl
[10:21:34.129]                           restarts <- computeRestarts(cond)
[10:21:34.129]                           for (restart in restarts) {
[10:21:34.129]                             name <- restart$name
[10:21:34.129]                             if (is.null(name)) 
[10:21:34.129]                               next
[10:21:34.129]                             if (!grepl(pattern, name)) 
[10:21:34.129]                               next
[10:21:34.129]                             invokeRestart(restart)
[10:21:34.129]                             muffled <- TRUE
[10:21:34.129]                             break
[10:21:34.129]                           }
[10:21:34.129]                         }
[10:21:34.129]                       }
[10:21:34.129]                       invisible(muffled)
[10:21:34.129]                     }
[10:21:34.129]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.129]                   }
[10:21:34.129]                 }
[10:21:34.129]             }
[10:21:34.129]         }))
[10:21:34.129]     }, error = function(ex) {
[10:21:34.129]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.129]                 ...future.rng), started = ...future.startTime, 
[10:21:34.129]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.129]             version = "1.8"), class = "FutureResult")
[10:21:34.129]     }, finally = {
[10:21:34.129]         if (!identical(...future.workdir, getwd())) 
[10:21:34.129]             setwd(...future.workdir)
[10:21:34.129]         {
[10:21:34.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.129]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.129]             }
[10:21:34.129]             base::options(...future.oldOptions)
[10:21:34.129]             if (.Platform$OS.type == "windows") {
[10:21:34.129]                 old_names <- names(...future.oldEnvVars)
[10:21:34.129]                 envs <- base::Sys.getenv()
[10:21:34.129]                 names <- names(envs)
[10:21:34.129]                 common <- intersect(names, old_names)
[10:21:34.129]                 added <- setdiff(names, old_names)
[10:21:34.129]                 removed <- setdiff(old_names, names)
[10:21:34.129]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.129]                   envs[common]]
[10:21:34.129]                 NAMES <- toupper(changed)
[10:21:34.129]                 args <- list()
[10:21:34.129]                 for (kk in seq_along(NAMES)) {
[10:21:34.129]                   name <- changed[[kk]]
[10:21:34.129]                   NAME <- NAMES[[kk]]
[10:21:34.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.129]                     next
[10:21:34.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.129]                 }
[10:21:34.129]                 NAMES <- toupper(added)
[10:21:34.129]                 for (kk in seq_along(NAMES)) {
[10:21:34.129]                   name <- added[[kk]]
[10:21:34.129]                   NAME <- NAMES[[kk]]
[10:21:34.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.129]                     next
[10:21:34.129]                   args[[name]] <- ""
[10:21:34.129]                 }
[10:21:34.129]                 NAMES <- toupper(removed)
[10:21:34.129]                 for (kk in seq_along(NAMES)) {
[10:21:34.129]                   name <- removed[[kk]]
[10:21:34.129]                   NAME <- NAMES[[kk]]
[10:21:34.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.129]                     next
[10:21:34.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.129]                 }
[10:21:34.129]                 if (length(args) > 0) 
[10:21:34.129]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.129]             }
[10:21:34.129]             else {
[10:21:34.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.129]             }
[10:21:34.129]             {
[10:21:34.129]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.129]                   0L) {
[10:21:34.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.129]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.129]                   base::options(opts)
[10:21:34.129]                 }
[10:21:34.129]                 {
[10:21:34.129]                   {
[10:21:34.129]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:34.129]                     NULL
[10:21:34.129]                   }
[10:21:34.129]                   options(future.plan = NULL)
[10:21:34.129]                   if (is.na(NA_character_)) 
[10:21:34.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.129]                     .init = FALSE)
[10:21:34.129]                 }
[10:21:34.129]             }
[10:21:34.129]         }
[10:21:34.129]     })
[10:21:34.129]     if (TRUE) {
[10:21:34.129]         base::sink(type = "output", split = FALSE)
[10:21:34.129]         if (TRUE) {
[10:21:34.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.129]         }
[10:21:34.129]         else {
[10:21:34.129]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.129]         }
[10:21:34.129]         base::close(...future.stdout)
[10:21:34.129]         ...future.stdout <- NULL
[10:21:34.129]     }
[10:21:34.129]     ...future.result$conditions <- ...future.conditions
[10:21:34.129]     ...future.result$finished <- base::Sys.time()
[10:21:34.129]     ...future.result
[10:21:34.129] }
[10:21:34.131] requestCore(): workers = 2
[10:21:34.134] MulticoreFuture started
[10:21:34.135] - Launch lazy future ... done
[10:21:34.135] plan(): Setting new future strategy stack:
[10:21:34.135] run() for ‘MulticoreFuture’ ... done
[10:21:34.135] List of future strategies:
[10:21:34.135] 1. sequential:
[10:21:34.135]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.135]    - tweaked: FALSE
[10:21:34.135]    - call: NULL
[10:21:34.136] result() for MulticoreFuture ...
[10:21:34.136] plan(): nbrOfWorkers() = 1
[10:21:34.138] plan(): Setting new future strategy stack:
[10:21:34.138] List of future strategies:
[10:21:34.138] 1. multicore:
[10:21:34.138]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:34.138]    - tweaked: FALSE
[10:21:34.138]    - call: plan(strategy)
[10:21:34.141] plan(): nbrOfWorkers() = 2
[10:21:34.146] result() for MulticoreFuture ...
[10:21:34.146] result() for MulticoreFuture ... done
[10:21:34.146] result() for MulticoreFuture ... done
[10:21:34.146] result() for MulticoreFuture ...
[10:21:34.147] result() for MulticoreFuture ... done
[10:21:34.147] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.147] Searching for globals...
[10:21:34.148] - globals found: [1] ‘getOption’
[10:21:34.148] Searching for globals ... DONE
[10:21:34.148] Resolving globals: FALSE
[10:21:34.149] 
[10:21:34.149] 
[10:21:34.149] getGlobalsAndPackages() ... DONE
[10:21:34.149] run() for ‘Future’ ...
[10:21:34.149] - state: ‘created’
[10:21:34.150] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:34.152] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:34.152] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:34.152]   - Field: ‘label’
[10:21:34.152]   - Field: ‘local’
[10:21:34.152]   - Field: ‘owner’
[10:21:34.152]   - Field: ‘envir’
[10:21:34.152]   - Field: ‘workers’
[10:21:34.152]   - Field: ‘packages’
[10:21:34.153]   - Field: ‘gc’
[10:21:34.153]   - Field: ‘job’
[10:21:34.153]   - Field: ‘conditions’
[10:21:34.153]   - Field: ‘expr’
[10:21:34.153]   - Field: ‘uuid’
[10:21:34.153]   - Field: ‘seed’
[10:21:34.153]   - Field: ‘version’
[10:21:34.153]   - Field: ‘result’
[10:21:34.153]   - Field: ‘asynchronous’
[10:21:34.153]   - Field: ‘calls’
[10:21:34.154]   - Field: ‘globals’
[10:21:34.154]   - Field: ‘stdout’
[10:21:34.154]   - Field: ‘earlySignal’
[10:21:34.154]   - Field: ‘lazy’
[10:21:34.154]   - Field: ‘state’
[10:21:34.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:34.154] - Launch lazy future ...
[10:21:34.155] Packages needed by the future expression (n = 0): <none>
[10:21:34.155] Packages needed by future strategies (n = 0): <none>
[10:21:34.155] {
[10:21:34.155]     {
[10:21:34.155]         {
[10:21:34.155]             ...future.startTime <- base::Sys.time()
[10:21:34.155]             {
[10:21:34.155]                 {
[10:21:34.155]                   {
[10:21:34.155]                     {
[10:21:34.155]                       base::local({
[10:21:34.155]                         has_future <- base::requireNamespace("future", 
[10:21:34.155]                           quietly = TRUE)
[10:21:34.155]                         if (has_future) {
[10:21:34.155]                           ns <- base::getNamespace("future")
[10:21:34.155]                           version <- ns[[".package"]][["version"]]
[10:21:34.155]                           if (is.null(version)) 
[10:21:34.155]                             version <- utils::packageVersion("future")
[10:21:34.155]                         }
[10:21:34.155]                         else {
[10:21:34.155]                           version <- NULL
[10:21:34.155]                         }
[10:21:34.155]                         if (!has_future || version < "1.8.0") {
[10:21:34.155]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.155]                             "", base::R.version$version.string), 
[10:21:34.155]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.155]                               "release", "version")], collapse = " "), 
[10:21:34.155]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.155]                             info)
[10:21:34.155]                           info <- base::paste(info, collapse = "; ")
[10:21:34.155]                           if (!has_future) {
[10:21:34.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.155]                               info)
[10:21:34.155]                           }
[10:21:34.155]                           else {
[10:21:34.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.155]                               info, version)
[10:21:34.155]                           }
[10:21:34.155]                           base::stop(msg)
[10:21:34.155]                         }
[10:21:34.155]                       })
[10:21:34.155]                     }
[10:21:34.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:34.155]                     base::options(mc.cores = 1L)
[10:21:34.155]                   }
[10:21:34.155]                   ...future.strategy.old <- future::plan("list")
[10:21:34.155]                   options(future.plan = NULL)
[10:21:34.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.155]                 }
[10:21:34.155]                 ...future.workdir <- getwd()
[10:21:34.155]             }
[10:21:34.155]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.155]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.155]         }
[10:21:34.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.155]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.155]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.155]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.155]             base::names(...future.oldOptions))
[10:21:34.155]     }
[10:21:34.155]     if (FALSE) {
[10:21:34.155]     }
[10:21:34.155]     else {
[10:21:34.155]         if (TRUE) {
[10:21:34.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.155]                 open = "w")
[10:21:34.155]         }
[10:21:34.155]         else {
[10:21:34.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.155]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.155]         }
[10:21:34.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.155]             base::sink(type = "output", split = FALSE)
[10:21:34.155]             base::close(...future.stdout)
[10:21:34.155]         }, add = TRUE)
[10:21:34.155]     }
[10:21:34.155]     ...future.frame <- base::sys.nframe()
[10:21:34.155]     ...future.conditions <- base::list()
[10:21:34.155]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.155]     if (FALSE) {
[10:21:34.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.155]     }
[10:21:34.155]     ...future.result <- base::tryCatch({
[10:21:34.155]         base::withCallingHandlers({
[10:21:34.155]             ...future.value <- base::withVisible(base::local({
[10:21:34.155]                 withCallingHandlers({
[10:21:34.155]                   getOption("future.globals.onMissing")
[10:21:34.155]                 }, immediateCondition = function(cond) {
[10:21:34.155]                   save_rds <- function (object, pathname, ...) 
[10:21:34.155]                   {
[10:21:34.155]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:34.155]                     if (file_test("-f", pathname_tmp)) {
[10:21:34.155]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.155]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:34.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.155]                         fi_tmp[["mtime"]])
[10:21:34.155]                     }
[10:21:34.155]                     tryCatch({
[10:21:34.155]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:34.155]                     }, error = function(ex) {
[10:21:34.155]                       msg <- conditionMessage(ex)
[10:21:34.155]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.155]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:34.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.155]                         fi_tmp[["mtime"]], msg)
[10:21:34.155]                       ex$message <- msg
[10:21:34.155]                       stop(ex)
[10:21:34.155]                     })
[10:21:34.155]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:34.155]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:34.155]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:34.155]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.155]                       fi <- file.info(pathname)
[10:21:34.155]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:34.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.155]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:34.155]                         fi[["size"]], fi[["mtime"]])
[10:21:34.155]                       stop(msg)
[10:21:34.155]                     }
[10:21:34.155]                     invisible(pathname)
[10:21:34.155]                   }
[10:21:34.155]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:34.155]                     rootPath = tempdir()) 
[10:21:34.155]                   {
[10:21:34.155]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:34.155]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:34.155]                       tmpdir = path, fileext = ".rds")
[10:21:34.155]                     save_rds(obj, file)
[10:21:34.155]                   }
[10:21:34.155]                   saveImmediateCondition(cond, path = "/tmp/RtmpwqU11c/.future/immediateConditions")
[10:21:34.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.155]                   {
[10:21:34.155]                     inherits <- base::inherits
[10:21:34.155]                     invokeRestart <- base::invokeRestart
[10:21:34.155]                     is.null <- base::is.null
[10:21:34.155]                     muffled <- FALSE
[10:21:34.155]                     if (inherits(cond, "message")) {
[10:21:34.155]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:34.155]                       if (muffled) 
[10:21:34.155]                         invokeRestart("muffleMessage")
[10:21:34.155]                     }
[10:21:34.155]                     else if (inherits(cond, "warning")) {
[10:21:34.155]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:34.155]                       if (muffled) 
[10:21:34.155]                         invokeRestart("muffleWarning")
[10:21:34.155]                     }
[10:21:34.155]                     else if (inherits(cond, "condition")) {
[10:21:34.155]                       if (!is.null(pattern)) {
[10:21:34.155]                         computeRestarts <- base::computeRestarts
[10:21:34.155]                         grepl <- base::grepl
[10:21:34.155]                         restarts <- computeRestarts(cond)
[10:21:34.155]                         for (restart in restarts) {
[10:21:34.155]                           name <- restart$name
[10:21:34.155]                           if (is.null(name)) 
[10:21:34.155]                             next
[10:21:34.155]                           if (!grepl(pattern, name)) 
[10:21:34.155]                             next
[10:21:34.155]                           invokeRestart(restart)
[10:21:34.155]                           muffled <- TRUE
[10:21:34.155]                           break
[10:21:34.155]                         }
[10:21:34.155]                       }
[10:21:34.155]                     }
[10:21:34.155]                     invisible(muffled)
[10:21:34.155]                   }
[10:21:34.155]                   muffleCondition(cond)
[10:21:34.155]                 })
[10:21:34.155]             }))
[10:21:34.155]             future::FutureResult(value = ...future.value$value, 
[10:21:34.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.155]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.155]                     ...future.globalenv.names))
[10:21:34.155]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.155]         }, condition = base::local({
[10:21:34.155]             c <- base::c
[10:21:34.155]             inherits <- base::inherits
[10:21:34.155]             invokeRestart <- base::invokeRestart
[10:21:34.155]             length <- base::length
[10:21:34.155]             list <- base::list
[10:21:34.155]             seq.int <- base::seq.int
[10:21:34.155]             signalCondition <- base::signalCondition
[10:21:34.155]             sys.calls <- base::sys.calls
[10:21:34.155]             `[[` <- base::`[[`
[10:21:34.155]             `+` <- base::`+`
[10:21:34.155]             `<<-` <- base::`<<-`
[10:21:34.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.155]                   3L)]
[10:21:34.155]             }
[10:21:34.155]             function(cond) {
[10:21:34.155]                 is_error <- inherits(cond, "error")
[10:21:34.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.155]                   NULL)
[10:21:34.155]                 if (is_error) {
[10:21:34.155]                   sessionInformation <- function() {
[10:21:34.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.155]                       search = base::search(), system = base::Sys.info())
[10:21:34.155]                   }
[10:21:34.155]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.155]                     cond$call), session = sessionInformation(), 
[10:21:34.155]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.155]                   signalCondition(cond)
[10:21:34.155]                 }
[10:21:34.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.155]                 "immediateCondition"))) {
[10:21:34.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.155]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.155]                   if (TRUE && !signal) {
[10:21:34.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.155]                     {
[10:21:34.155]                       inherits <- base::inherits
[10:21:34.155]                       invokeRestart <- base::invokeRestart
[10:21:34.155]                       is.null <- base::is.null
[10:21:34.155]                       muffled <- FALSE
[10:21:34.155]                       if (inherits(cond, "message")) {
[10:21:34.155]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.155]                         if (muffled) 
[10:21:34.155]                           invokeRestart("muffleMessage")
[10:21:34.155]                       }
[10:21:34.155]                       else if (inherits(cond, "warning")) {
[10:21:34.155]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.155]                         if (muffled) 
[10:21:34.155]                           invokeRestart("muffleWarning")
[10:21:34.155]                       }
[10:21:34.155]                       else if (inherits(cond, "condition")) {
[10:21:34.155]                         if (!is.null(pattern)) {
[10:21:34.155]                           computeRestarts <- base::computeRestarts
[10:21:34.155]                           grepl <- base::grepl
[10:21:34.155]                           restarts <- computeRestarts(cond)
[10:21:34.155]                           for (restart in restarts) {
[10:21:34.155]                             name <- restart$name
[10:21:34.155]                             if (is.null(name)) 
[10:21:34.155]                               next
[10:21:34.155]                             if (!grepl(pattern, name)) 
[10:21:34.155]                               next
[10:21:34.155]                             invokeRestart(restart)
[10:21:34.155]                             muffled <- TRUE
[10:21:34.155]                             break
[10:21:34.155]                           }
[10:21:34.155]                         }
[10:21:34.155]                       }
[10:21:34.155]                       invisible(muffled)
[10:21:34.155]                     }
[10:21:34.155]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.155]                   }
[10:21:34.155]                 }
[10:21:34.155]                 else {
[10:21:34.155]                   if (TRUE) {
[10:21:34.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.155]                     {
[10:21:34.155]                       inherits <- base::inherits
[10:21:34.155]                       invokeRestart <- base::invokeRestart
[10:21:34.155]                       is.null <- base::is.null
[10:21:34.155]                       muffled <- FALSE
[10:21:34.155]                       if (inherits(cond, "message")) {
[10:21:34.155]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.155]                         if (muffled) 
[10:21:34.155]                           invokeRestart("muffleMessage")
[10:21:34.155]                       }
[10:21:34.155]                       else if (inherits(cond, "warning")) {
[10:21:34.155]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.155]                         if (muffled) 
[10:21:34.155]                           invokeRestart("muffleWarning")
[10:21:34.155]                       }
[10:21:34.155]                       else if (inherits(cond, "condition")) {
[10:21:34.155]                         if (!is.null(pattern)) {
[10:21:34.155]                           computeRestarts <- base::computeRestarts
[10:21:34.155]                           grepl <- base::grepl
[10:21:34.155]                           restarts <- computeRestarts(cond)
[10:21:34.155]                           for (restart in restarts) {
[10:21:34.155]                             name <- restart$name
[10:21:34.155]                             if (is.null(name)) 
[10:21:34.155]                               next
[10:21:34.155]                             if (!grepl(pattern, name)) 
[10:21:34.155]                               next
[10:21:34.155]                             invokeRestart(restart)
[10:21:34.155]                             muffled <- TRUE
[10:21:34.155]                             break
[10:21:34.155]                           }
[10:21:34.155]                         }
[10:21:34.155]                       }
[10:21:34.155]                       invisible(muffled)
[10:21:34.155]                     }
[10:21:34.155]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.155]                   }
[10:21:34.155]                 }
[10:21:34.155]             }
[10:21:34.155]         }))
[10:21:34.155]     }, error = function(ex) {
[10:21:34.155]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.155]                 ...future.rng), started = ...future.startTime, 
[10:21:34.155]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.155]             version = "1.8"), class = "FutureResult")
[10:21:34.155]     }, finally = {
[10:21:34.155]         if (!identical(...future.workdir, getwd())) 
[10:21:34.155]             setwd(...future.workdir)
[10:21:34.155]         {
[10:21:34.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.155]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.155]             }
[10:21:34.155]             base::options(...future.oldOptions)
[10:21:34.155]             if (.Platform$OS.type == "windows") {
[10:21:34.155]                 old_names <- names(...future.oldEnvVars)
[10:21:34.155]                 envs <- base::Sys.getenv()
[10:21:34.155]                 names <- names(envs)
[10:21:34.155]                 common <- intersect(names, old_names)
[10:21:34.155]                 added <- setdiff(names, old_names)
[10:21:34.155]                 removed <- setdiff(old_names, names)
[10:21:34.155]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.155]                   envs[common]]
[10:21:34.155]                 NAMES <- toupper(changed)
[10:21:34.155]                 args <- list()
[10:21:34.155]                 for (kk in seq_along(NAMES)) {
[10:21:34.155]                   name <- changed[[kk]]
[10:21:34.155]                   NAME <- NAMES[[kk]]
[10:21:34.155]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.155]                     next
[10:21:34.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.155]                 }
[10:21:34.155]                 NAMES <- toupper(added)
[10:21:34.155]                 for (kk in seq_along(NAMES)) {
[10:21:34.155]                   name <- added[[kk]]
[10:21:34.155]                   NAME <- NAMES[[kk]]
[10:21:34.155]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.155]                     next
[10:21:34.155]                   args[[name]] <- ""
[10:21:34.155]                 }
[10:21:34.155]                 NAMES <- toupper(removed)
[10:21:34.155]                 for (kk in seq_along(NAMES)) {
[10:21:34.155]                   name <- removed[[kk]]
[10:21:34.155]                   NAME <- NAMES[[kk]]
[10:21:34.155]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.155]                     next
[10:21:34.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.155]                 }
[10:21:34.155]                 if (length(args) > 0) 
[10:21:34.155]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.155]             }
[10:21:34.155]             else {
[10:21:34.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.155]             }
[10:21:34.155]             {
[10:21:34.155]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.155]                   0L) {
[10:21:34.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.155]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.155]                   base::options(opts)
[10:21:34.155]                 }
[10:21:34.155]                 {
[10:21:34.155]                   {
[10:21:34.155]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:34.155]                     NULL
[10:21:34.155]                   }
[10:21:34.155]                   options(future.plan = NULL)
[10:21:34.155]                   if (is.na(NA_character_)) 
[10:21:34.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.155]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.155]                     .init = FALSE)
[10:21:34.155]                 }
[10:21:34.155]             }
[10:21:34.155]         }
[10:21:34.155]     })
[10:21:34.155]     if (TRUE) {
[10:21:34.155]         base::sink(type = "output", split = FALSE)
[10:21:34.155]         if (TRUE) {
[10:21:34.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.155]         }
[10:21:34.155]         else {
[10:21:34.155]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.155]         }
[10:21:34.155]         base::close(...future.stdout)
[10:21:34.155]         ...future.stdout <- NULL
[10:21:34.155]     }
[10:21:34.155]     ...future.result$conditions <- ...future.conditions
[10:21:34.155]     ...future.result$finished <- base::Sys.time()
[10:21:34.155]     ...future.result
[10:21:34.155] }
[10:21:34.158] requestCore(): workers = 2
[10:21:34.160] MulticoreFuture started
[10:21:34.160] - Launch lazy future ... done
[10:21:34.161] run() for ‘MulticoreFuture’ ... done
[10:21:34.161] plan(): Setting new future strategy stack:
[10:21:34.161] result() for MulticoreFuture ...
[10:21:34.161] List of future strategies:
[10:21:34.161] 1. sequential:
[10:21:34.161]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.161]    - tweaked: FALSE
[10:21:34.161]    - call: NULL
[10:21:34.162] plan(): nbrOfWorkers() = 1
[10:21:34.164] plan(): Setting new future strategy stack:
[10:21:34.164] List of future strategies:
[10:21:34.164] 1. multicore:
[10:21:34.164]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:34.164]    - tweaked: FALSE
[10:21:34.164]    - call: plan(strategy)
[10:21:34.167] plan(): nbrOfWorkers() = 2
[10:21:34.173] result() for MulticoreFuture ...
[10:21:34.173] result() for MulticoreFuture ... done
[10:21:34.173] result() for MulticoreFuture ... done
[10:21:34.173] result() for MulticoreFuture ...
[10:21:34.174] result() for MulticoreFuture ... done
[10:21:34.174] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:34.174] Searching for globals...
[10:21:34.179] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.179] Searching for globals...
[10:21:34.181] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:21:34.181] Searching for globals ... DONE
[10:21:34.181] Resolving globals: FALSE
[10:21:34.181] The total size of the 1 globals is 356 bytes (356 bytes)
[10:21:34.182] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:21:34.182] - globals: [1] ‘data’
[10:21:34.182] 
[10:21:34.182] getGlobalsAndPackages() ... DONE
[10:21:34.183] run() for ‘Future’ ...
[10:21:34.183] - state: ‘created’
[10:21:34.183] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:34.185] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:34.185] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:34.185]   - Field: ‘label’
[10:21:34.185]   - Field: ‘local’
[10:21:34.185]   - Field: ‘owner’
[10:21:34.186]   - Field: ‘envir’
[10:21:34.186]   - Field: ‘workers’
[10:21:34.186]   - Field: ‘packages’
[10:21:34.186]   - Field: ‘gc’
[10:21:34.186]   - Field: ‘job’
[10:21:34.186]   - Field: ‘conditions’
[10:21:34.186]   - Field: ‘expr’
[10:21:34.186]   - Field: ‘uuid’
[10:21:34.186]   - Field: ‘seed’
[10:21:34.186]   - Field: ‘version’
[10:21:34.187]   - Field: ‘result’
[10:21:34.187]   - Field: ‘asynchronous’
[10:21:34.187]   - Field: ‘calls’
[10:21:34.187]   - Field: ‘globals’
[10:21:34.187]   - Field: ‘stdout’
[10:21:34.187]   - Field: ‘earlySignal’
[10:21:34.187]   - Field: ‘lazy’
[10:21:34.187]   - Field: ‘state’
[10:21:34.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:34.188] - Launch lazy future ...
[10:21:34.188] Packages needed by the future expression (n = 0): <none>
[10:21:34.188] Packages needed by future strategies (n = 0): <none>
[10:21:34.189] {
[10:21:34.189]     {
[10:21:34.189]         {
[10:21:34.189]             ...future.startTime <- base::Sys.time()
[10:21:34.189]             {
[10:21:34.189]                 {
[10:21:34.189]                   {
[10:21:34.189]                     {
[10:21:34.189]                       base::local({
[10:21:34.189]                         has_future <- base::requireNamespace("future", 
[10:21:34.189]                           quietly = TRUE)
[10:21:34.189]                         if (has_future) {
[10:21:34.189]                           ns <- base::getNamespace("future")
[10:21:34.189]                           version <- ns[[".package"]][["version"]]
[10:21:34.189]                           if (is.null(version)) 
[10:21:34.189]                             version <- utils::packageVersion("future")
[10:21:34.189]                         }
[10:21:34.189]                         else {
[10:21:34.189]                           version <- NULL
[10:21:34.189]                         }
[10:21:34.189]                         if (!has_future || version < "1.8.0") {
[10:21:34.189]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.189]                             "", base::R.version$version.string), 
[10:21:34.189]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.189]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.189]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.189]                               "release", "version")], collapse = " "), 
[10:21:34.189]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.189]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.189]                             info)
[10:21:34.189]                           info <- base::paste(info, collapse = "; ")
[10:21:34.189]                           if (!has_future) {
[10:21:34.189]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.189]                               info)
[10:21:34.189]                           }
[10:21:34.189]                           else {
[10:21:34.189]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.189]                               info, version)
[10:21:34.189]                           }
[10:21:34.189]                           base::stop(msg)
[10:21:34.189]                         }
[10:21:34.189]                       })
[10:21:34.189]                     }
[10:21:34.189]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:34.189]                     base::options(mc.cores = 1L)
[10:21:34.189]                   }
[10:21:34.189]                   ...future.strategy.old <- future::plan("list")
[10:21:34.189]                   options(future.plan = NULL)
[10:21:34.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.189]                 }
[10:21:34.189]                 ...future.workdir <- getwd()
[10:21:34.189]             }
[10:21:34.189]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.189]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.189]         }
[10:21:34.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.189]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.189]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.189]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.189]             base::names(...future.oldOptions))
[10:21:34.189]     }
[10:21:34.189]     if (FALSE) {
[10:21:34.189]     }
[10:21:34.189]     else {
[10:21:34.189]         if (TRUE) {
[10:21:34.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.189]                 open = "w")
[10:21:34.189]         }
[10:21:34.189]         else {
[10:21:34.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.189]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.189]         }
[10:21:34.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.189]             base::sink(type = "output", split = FALSE)
[10:21:34.189]             base::close(...future.stdout)
[10:21:34.189]         }, add = TRUE)
[10:21:34.189]     }
[10:21:34.189]     ...future.frame <- base::sys.nframe()
[10:21:34.189]     ...future.conditions <- base::list()
[10:21:34.189]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.189]     if (FALSE) {
[10:21:34.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.189]     }
[10:21:34.189]     ...future.result <- base::tryCatch({
[10:21:34.189]         base::withCallingHandlers({
[10:21:34.189]             ...future.value <- base::withVisible(base::local({
[10:21:34.189]                 withCallingHandlers({
[10:21:34.189]                   subset(data, x < 3)$y
[10:21:34.189]                 }, immediateCondition = function(cond) {
[10:21:34.189]                   save_rds <- function (object, pathname, ...) 
[10:21:34.189]                   {
[10:21:34.189]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:34.189]                     if (file_test("-f", pathname_tmp)) {
[10:21:34.189]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.189]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:34.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.189]                         fi_tmp[["mtime"]])
[10:21:34.189]                     }
[10:21:34.189]                     tryCatch({
[10:21:34.189]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:34.189]                     }, error = function(ex) {
[10:21:34.189]                       msg <- conditionMessage(ex)
[10:21:34.189]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.189]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:34.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.189]                         fi_tmp[["mtime"]], msg)
[10:21:34.189]                       ex$message <- msg
[10:21:34.189]                       stop(ex)
[10:21:34.189]                     })
[10:21:34.189]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:34.189]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:34.189]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:34.189]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.189]                       fi <- file.info(pathname)
[10:21:34.189]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:34.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.189]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:34.189]                         fi[["size"]], fi[["mtime"]])
[10:21:34.189]                       stop(msg)
[10:21:34.189]                     }
[10:21:34.189]                     invisible(pathname)
[10:21:34.189]                   }
[10:21:34.189]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:34.189]                     rootPath = tempdir()) 
[10:21:34.189]                   {
[10:21:34.189]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:34.189]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:34.189]                       tmpdir = path, fileext = ".rds")
[10:21:34.189]                     save_rds(obj, file)
[10:21:34.189]                   }
[10:21:34.189]                   saveImmediateCondition(cond, path = "/tmp/RtmpwqU11c/.future/immediateConditions")
[10:21:34.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.189]                   {
[10:21:34.189]                     inherits <- base::inherits
[10:21:34.189]                     invokeRestart <- base::invokeRestart
[10:21:34.189]                     is.null <- base::is.null
[10:21:34.189]                     muffled <- FALSE
[10:21:34.189]                     if (inherits(cond, "message")) {
[10:21:34.189]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:34.189]                       if (muffled) 
[10:21:34.189]                         invokeRestart("muffleMessage")
[10:21:34.189]                     }
[10:21:34.189]                     else if (inherits(cond, "warning")) {
[10:21:34.189]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:34.189]                       if (muffled) 
[10:21:34.189]                         invokeRestart("muffleWarning")
[10:21:34.189]                     }
[10:21:34.189]                     else if (inherits(cond, "condition")) {
[10:21:34.189]                       if (!is.null(pattern)) {
[10:21:34.189]                         computeRestarts <- base::computeRestarts
[10:21:34.189]                         grepl <- base::grepl
[10:21:34.189]                         restarts <- computeRestarts(cond)
[10:21:34.189]                         for (restart in restarts) {
[10:21:34.189]                           name <- restart$name
[10:21:34.189]                           if (is.null(name)) 
[10:21:34.189]                             next
[10:21:34.189]                           if (!grepl(pattern, name)) 
[10:21:34.189]                             next
[10:21:34.189]                           invokeRestart(restart)
[10:21:34.189]                           muffled <- TRUE
[10:21:34.189]                           break
[10:21:34.189]                         }
[10:21:34.189]                       }
[10:21:34.189]                     }
[10:21:34.189]                     invisible(muffled)
[10:21:34.189]                   }
[10:21:34.189]                   muffleCondition(cond)
[10:21:34.189]                 })
[10:21:34.189]             }))
[10:21:34.189]             future::FutureResult(value = ...future.value$value, 
[10:21:34.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.189]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.189]                     ...future.globalenv.names))
[10:21:34.189]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.189]         }, condition = base::local({
[10:21:34.189]             c <- base::c
[10:21:34.189]             inherits <- base::inherits
[10:21:34.189]             invokeRestart <- base::invokeRestart
[10:21:34.189]             length <- base::length
[10:21:34.189]             list <- base::list
[10:21:34.189]             seq.int <- base::seq.int
[10:21:34.189]             signalCondition <- base::signalCondition
[10:21:34.189]             sys.calls <- base::sys.calls
[10:21:34.189]             `[[` <- base::`[[`
[10:21:34.189]             `+` <- base::`+`
[10:21:34.189]             `<<-` <- base::`<<-`
[10:21:34.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.189]                   3L)]
[10:21:34.189]             }
[10:21:34.189]             function(cond) {
[10:21:34.189]                 is_error <- inherits(cond, "error")
[10:21:34.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.189]                   NULL)
[10:21:34.189]                 if (is_error) {
[10:21:34.189]                   sessionInformation <- function() {
[10:21:34.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.189]                       search = base::search(), system = base::Sys.info())
[10:21:34.189]                   }
[10:21:34.189]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.189]                     cond$call), session = sessionInformation(), 
[10:21:34.189]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.189]                   signalCondition(cond)
[10:21:34.189]                 }
[10:21:34.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.189]                 "immediateCondition"))) {
[10:21:34.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.189]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.189]                   if (TRUE && !signal) {
[10:21:34.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.189]                     {
[10:21:34.189]                       inherits <- base::inherits
[10:21:34.189]                       invokeRestart <- base::invokeRestart
[10:21:34.189]                       is.null <- base::is.null
[10:21:34.189]                       muffled <- FALSE
[10:21:34.189]                       if (inherits(cond, "message")) {
[10:21:34.189]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.189]                         if (muffled) 
[10:21:34.189]                           invokeRestart("muffleMessage")
[10:21:34.189]                       }
[10:21:34.189]                       else if (inherits(cond, "warning")) {
[10:21:34.189]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.189]                         if (muffled) 
[10:21:34.189]                           invokeRestart("muffleWarning")
[10:21:34.189]                       }
[10:21:34.189]                       else if (inherits(cond, "condition")) {
[10:21:34.189]                         if (!is.null(pattern)) {
[10:21:34.189]                           computeRestarts <- base::computeRestarts
[10:21:34.189]                           grepl <- base::grepl
[10:21:34.189]                           restarts <- computeRestarts(cond)
[10:21:34.189]                           for (restart in restarts) {
[10:21:34.189]                             name <- restart$name
[10:21:34.189]                             if (is.null(name)) 
[10:21:34.189]                               next
[10:21:34.189]                             if (!grepl(pattern, name)) 
[10:21:34.189]                               next
[10:21:34.189]                             invokeRestart(restart)
[10:21:34.189]                             muffled <- TRUE
[10:21:34.189]                             break
[10:21:34.189]                           }
[10:21:34.189]                         }
[10:21:34.189]                       }
[10:21:34.189]                       invisible(muffled)
[10:21:34.189]                     }
[10:21:34.189]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.189]                   }
[10:21:34.189]                 }
[10:21:34.189]                 else {
[10:21:34.189]                   if (TRUE) {
[10:21:34.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.189]                     {
[10:21:34.189]                       inherits <- base::inherits
[10:21:34.189]                       invokeRestart <- base::invokeRestart
[10:21:34.189]                       is.null <- base::is.null
[10:21:34.189]                       muffled <- FALSE
[10:21:34.189]                       if (inherits(cond, "message")) {
[10:21:34.189]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.189]                         if (muffled) 
[10:21:34.189]                           invokeRestart("muffleMessage")
[10:21:34.189]                       }
[10:21:34.189]                       else if (inherits(cond, "warning")) {
[10:21:34.189]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.189]                         if (muffled) 
[10:21:34.189]                           invokeRestart("muffleWarning")
[10:21:34.189]                       }
[10:21:34.189]                       else if (inherits(cond, "condition")) {
[10:21:34.189]                         if (!is.null(pattern)) {
[10:21:34.189]                           computeRestarts <- base::computeRestarts
[10:21:34.189]                           grepl <- base::grepl
[10:21:34.189]                           restarts <- computeRestarts(cond)
[10:21:34.189]                           for (restart in restarts) {
[10:21:34.189]                             name <- restart$name
[10:21:34.189]                             if (is.null(name)) 
[10:21:34.189]                               next
[10:21:34.189]                             if (!grepl(pattern, name)) 
[10:21:34.189]                               next
[10:21:34.189]                             invokeRestart(restart)
[10:21:34.189]                             muffled <- TRUE
[10:21:34.189]                             break
[10:21:34.189]                           }
[10:21:34.189]                         }
[10:21:34.189]                       }
[10:21:34.189]                       invisible(muffled)
[10:21:34.189]                     }
[10:21:34.189]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.189]                   }
[10:21:34.189]                 }
[10:21:34.189]             }
[10:21:34.189]         }))
[10:21:34.189]     }, error = function(ex) {
[10:21:34.189]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.189]                 ...future.rng), started = ...future.startTime, 
[10:21:34.189]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.189]             version = "1.8"), class = "FutureResult")
[10:21:34.189]     }, finally = {
[10:21:34.189]         if (!identical(...future.workdir, getwd())) 
[10:21:34.189]             setwd(...future.workdir)
[10:21:34.189]         {
[10:21:34.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.189]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.189]             }
[10:21:34.189]             base::options(...future.oldOptions)
[10:21:34.189]             if (.Platform$OS.type == "windows") {
[10:21:34.189]                 old_names <- names(...future.oldEnvVars)
[10:21:34.189]                 envs <- base::Sys.getenv()
[10:21:34.189]                 names <- names(envs)
[10:21:34.189]                 common <- intersect(names, old_names)
[10:21:34.189]                 added <- setdiff(names, old_names)
[10:21:34.189]                 removed <- setdiff(old_names, names)
[10:21:34.189]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.189]                   envs[common]]
[10:21:34.189]                 NAMES <- toupper(changed)
[10:21:34.189]                 args <- list()
[10:21:34.189]                 for (kk in seq_along(NAMES)) {
[10:21:34.189]                   name <- changed[[kk]]
[10:21:34.189]                   NAME <- NAMES[[kk]]
[10:21:34.189]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.189]                     next
[10:21:34.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.189]                 }
[10:21:34.189]                 NAMES <- toupper(added)
[10:21:34.189]                 for (kk in seq_along(NAMES)) {
[10:21:34.189]                   name <- added[[kk]]
[10:21:34.189]                   NAME <- NAMES[[kk]]
[10:21:34.189]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.189]                     next
[10:21:34.189]                   args[[name]] <- ""
[10:21:34.189]                 }
[10:21:34.189]                 NAMES <- toupper(removed)
[10:21:34.189]                 for (kk in seq_along(NAMES)) {
[10:21:34.189]                   name <- removed[[kk]]
[10:21:34.189]                   NAME <- NAMES[[kk]]
[10:21:34.189]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.189]                     next
[10:21:34.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.189]                 }
[10:21:34.189]                 if (length(args) > 0) 
[10:21:34.189]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.189]             }
[10:21:34.189]             else {
[10:21:34.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.189]             }
[10:21:34.189]             {
[10:21:34.189]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.189]                   0L) {
[10:21:34.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.189]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.189]                   base::options(opts)
[10:21:34.189]                 }
[10:21:34.189]                 {
[10:21:34.189]                   {
[10:21:34.189]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:34.189]                     NULL
[10:21:34.189]                   }
[10:21:34.189]                   options(future.plan = NULL)
[10:21:34.189]                   if (is.na(NA_character_)) 
[10:21:34.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.189]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.189]                     .init = FALSE)
[10:21:34.189]                 }
[10:21:34.189]             }
[10:21:34.189]         }
[10:21:34.189]     })
[10:21:34.189]     if (TRUE) {
[10:21:34.189]         base::sink(type = "output", split = FALSE)
[10:21:34.189]         if (TRUE) {
[10:21:34.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.189]         }
[10:21:34.189]         else {
[10:21:34.189]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.189]         }
[10:21:34.189]         base::close(...future.stdout)
[10:21:34.189]         ...future.stdout <- NULL
[10:21:34.189]     }
[10:21:34.189]     ...future.result$conditions <- ...future.conditions
[10:21:34.189]     ...future.result$finished <- base::Sys.time()
[10:21:34.189]     ...future.result
[10:21:34.189] }
[10:21:34.191] assign_globals() ...
[10:21:34.191] List of 1
[10:21:34.191]  $ data:'data.frame':	5 obs. of  2 variables:
[10:21:34.191]   ..$ x: int [1:5] 1 2 3 4 5
[10:21:34.191]   ..$ y: int [1:5] 1 2 3 4 5
[10:21:34.191]  - attr(*, "where")=List of 1
[10:21:34.191]   ..$ data:<environment: R_EmptyEnv> 
[10:21:34.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:34.191]  - attr(*, "resolved")= logi FALSE
[10:21:34.191]  - attr(*, "total_size")= num 356
[10:21:34.191]  - attr(*, "already-done")= logi TRUE
[10:21:34.195] - copied ‘data’ to environment
[10:21:34.195] assign_globals() ... done
[10:21:34.195] requestCore(): workers = 2
[10:21:34.197] MulticoreFuture started
[10:21:34.197] - Launch lazy future ... done
[10:21:34.197] run() for ‘MulticoreFuture’ ... done
[10:21:34.198] result() for MulticoreFuture ...
[10:21:34.198] plan(): Setting new future strategy stack:
[10:21:34.198] List of future strategies:
[10:21:34.198] 1. sequential:
[10:21:34.198]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.198]    - tweaked: FALSE
[10:21:34.198]    - call: NULL
[10:21:34.199] plan(): nbrOfWorkers() = 1
[10:21:34.201] plan(): Setting new future strategy stack:
[10:21:34.201] List of future strategies:
[10:21:34.201] 1. multicore:
[10:21:34.201]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:34.201]    - tweaked: FALSE
[10:21:34.201]    - call: plan(strategy)
[10:21:34.204] plan(): nbrOfWorkers() = 2
[10:21:34.205] result() for MulticoreFuture ...
[10:21:34.205] result() for MulticoreFuture ... done
[10:21:34.205] result() for MulticoreFuture ... done
[10:21:34.206] result() for MulticoreFuture ...
[10:21:34.206] result() for MulticoreFuture ... done
[10:21:34.206] plan(): Setting new future strategy stack:
[10:21:34.206] List of future strategies:
[10:21:34.206] 1. sequential:
[10:21:34.206]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.206]    - tweaked: FALSE
[10:21:34.206]    - call: plan(list(sequential, strategy))
[10:21:34.206] 2. multicore:
[10:21:34.206]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:34.206]    - tweaked: FALSE
[10:21:34.206]    - call: plan(list(sequential, strategy))
[10:21:34.207] plan(): nbrOfWorkers() = 1
[10:21:34.207] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.208] Searching for globals...
[10:21:34.211] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[10:21:34.211] Searching for globals ... DONE
[10:21:34.212] Resolving globals: FALSE
[10:21:34.212] The total size of the 1 globals is 356 bytes (356 bytes)
[10:21:34.213] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:21:34.213] - globals: [1] ‘data’
[10:21:34.213] - packages: [1] ‘future’
[10:21:34.213] getGlobalsAndPackages() ... DONE
[10:21:34.213] run() for ‘Future’ ...
[10:21:34.214] - state: ‘created’
[10:21:34.214] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:34.214] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:34.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:34.214]   - Field: ‘label’
[10:21:34.214]   - Field: ‘local’
[10:21:34.215]   - Field: ‘owner’
[10:21:34.215]   - Field: ‘envir’
[10:21:34.215]   - Field: ‘packages’
[10:21:34.215]   - Field: ‘gc’
[10:21:34.215]   - Field: ‘conditions’
[10:21:34.215]   - Field: ‘expr’
[10:21:34.215]   - Field: ‘uuid’
[10:21:34.215]   - Field: ‘seed’
[10:21:34.215]   - Field: ‘version’
[10:21:34.216]   - Field: ‘result’
[10:21:34.216]   - Field: ‘asynchronous’
[10:21:34.216]   - Field: ‘calls’
[10:21:34.216]   - Field: ‘globals’
[10:21:34.216]   - Field: ‘stdout’
[10:21:34.216]   - Field: ‘earlySignal’
[10:21:34.216]   - Field: ‘lazy’
[10:21:34.216]   - Field: ‘state’
[10:21:34.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:34.216] - Launch lazy future ...
[10:21:34.217] Packages needed by the future expression (n = 1): ‘future’
[10:21:34.217] Packages needed by future strategies (n = 1): ‘future’
[10:21:34.217] {
[10:21:34.217]     {
[10:21:34.217]         {
[10:21:34.217]             ...future.startTime <- base::Sys.time()
[10:21:34.217]             {
[10:21:34.217]                 {
[10:21:34.217]                   {
[10:21:34.217]                     {
[10:21:34.217]                       base::local({
[10:21:34.217]                         has_future <- base::requireNamespace("future", 
[10:21:34.217]                           quietly = TRUE)
[10:21:34.217]                         if (has_future) {
[10:21:34.217]                           ns <- base::getNamespace("future")
[10:21:34.217]                           version <- ns[[".package"]][["version"]]
[10:21:34.217]                           if (is.null(version)) 
[10:21:34.217]                             version <- utils::packageVersion("future")
[10:21:34.217]                         }
[10:21:34.217]                         else {
[10:21:34.217]                           version <- NULL
[10:21:34.217]                         }
[10:21:34.217]                         if (!has_future || version < "1.8.0") {
[10:21:34.217]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.217]                             "", base::R.version$version.string), 
[10:21:34.217]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.217]                               "release", "version")], collapse = " "), 
[10:21:34.217]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.217]                             info)
[10:21:34.217]                           info <- base::paste(info, collapse = "; ")
[10:21:34.217]                           if (!has_future) {
[10:21:34.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.217]                               info)
[10:21:34.217]                           }
[10:21:34.217]                           else {
[10:21:34.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.217]                               info, version)
[10:21:34.217]                           }
[10:21:34.217]                           base::stop(msg)
[10:21:34.217]                         }
[10:21:34.217]                       })
[10:21:34.217]                     }
[10:21:34.217]                     base::local({
[10:21:34.217]                       for (pkg in "future") {
[10:21:34.217]                         base::loadNamespace(pkg)
[10:21:34.217]                         base::library(pkg, character.only = TRUE)
[10:21:34.217]                       }
[10:21:34.217]                     })
[10:21:34.217]                   }
[10:21:34.217]                   ...future.strategy.old <- future::plan("list")
[10:21:34.217]                   options(future.plan = NULL)
[10:21:34.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.217]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:21:34.217]                     envir = parent.frame()) 
[10:21:34.217]                   {
[10:21:34.217]                     default_workers <- missing(workers)
[10:21:34.217]                     if (is.function(workers)) 
[10:21:34.217]                       workers <- workers()
[10:21:34.217]                     workers <- structure(as.integer(workers), 
[10:21:34.217]                       class = class(workers))
[10:21:34.217]                     stop_if_not(is.finite(workers), workers >= 
[10:21:34.217]                       1L)
[10:21:34.217]                     if ((workers == 1L && !inherits(workers, 
[10:21:34.217]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:21:34.217]                       if (default_workers) 
[10:21:34.217]                         supportsMulticore(warn = TRUE)
[10:21:34.217]                       return(sequential(..., envir = envir))
[10:21:34.217]                     }
[10:21:34.217]                     oopts <- options(mc.cores = workers)
[10:21:34.217]                     on.exit(options(oopts))
[10:21:34.217]                     future <- MulticoreFuture(..., workers = workers, 
[10:21:34.217]                       envir = envir)
[10:21:34.217]                     if (!future$lazy) 
[10:21:34.217]                       future <- run(future)
[10:21:34.217]                     invisible(future)
[10:21:34.217]                   }), .cleanup = FALSE, .init = FALSE)
[10:21:34.217]                 }
[10:21:34.217]                 ...future.workdir <- getwd()
[10:21:34.217]             }
[10:21:34.217]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.217]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.217]         }
[10:21:34.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.217]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.217]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.217]             base::names(...future.oldOptions))
[10:21:34.217]     }
[10:21:34.217]     if (FALSE) {
[10:21:34.217]     }
[10:21:34.217]     else {
[10:21:34.217]         if (TRUE) {
[10:21:34.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.217]                 open = "w")
[10:21:34.217]         }
[10:21:34.217]         else {
[10:21:34.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.217]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.217]         }
[10:21:34.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.217]             base::sink(type = "output", split = FALSE)
[10:21:34.217]             base::close(...future.stdout)
[10:21:34.217]         }, add = TRUE)
[10:21:34.217]     }
[10:21:34.217]     ...future.frame <- base::sys.nframe()
[10:21:34.217]     ...future.conditions <- base::list()
[10:21:34.217]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.217]     if (FALSE) {
[10:21:34.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.217]     }
[10:21:34.217]     ...future.result <- base::tryCatch({
[10:21:34.217]         base::withCallingHandlers({
[10:21:34.217]             ...future.value <- base::withVisible(base::local({
[10:21:34.217]                 a %<-% subset(data, x < 3)$y
[10:21:34.217]                 a
[10:21:34.217]             }))
[10:21:34.217]             future::FutureResult(value = ...future.value$value, 
[10:21:34.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.217]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.217]                     ...future.globalenv.names))
[10:21:34.217]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.217]         }, condition = base::local({
[10:21:34.217]             c <- base::c
[10:21:34.217]             inherits <- base::inherits
[10:21:34.217]             invokeRestart <- base::invokeRestart
[10:21:34.217]             length <- base::length
[10:21:34.217]             list <- base::list
[10:21:34.217]             seq.int <- base::seq.int
[10:21:34.217]             signalCondition <- base::signalCondition
[10:21:34.217]             sys.calls <- base::sys.calls
[10:21:34.217]             `[[` <- base::`[[`
[10:21:34.217]             `+` <- base::`+`
[10:21:34.217]             `<<-` <- base::`<<-`
[10:21:34.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.217]                   3L)]
[10:21:34.217]             }
[10:21:34.217]             function(cond) {
[10:21:34.217]                 is_error <- inherits(cond, "error")
[10:21:34.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.217]                   NULL)
[10:21:34.217]                 if (is_error) {
[10:21:34.217]                   sessionInformation <- function() {
[10:21:34.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.217]                       search = base::search(), system = base::Sys.info())
[10:21:34.217]                   }
[10:21:34.217]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.217]                     cond$call), session = sessionInformation(), 
[10:21:34.217]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.217]                   signalCondition(cond)
[10:21:34.217]                 }
[10:21:34.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.217]                 "immediateCondition"))) {
[10:21:34.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.217]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.217]                   if (TRUE && !signal) {
[10:21:34.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.217]                     {
[10:21:34.217]                       inherits <- base::inherits
[10:21:34.217]                       invokeRestart <- base::invokeRestart
[10:21:34.217]                       is.null <- base::is.null
[10:21:34.217]                       muffled <- FALSE
[10:21:34.217]                       if (inherits(cond, "message")) {
[10:21:34.217]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.217]                         if (muffled) 
[10:21:34.217]                           invokeRestart("muffleMessage")
[10:21:34.217]                       }
[10:21:34.217]                       else if (inherits(cond, "warning")) {
[10:21:34.217]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.217]                         if (muffled) 
[10:21:34.217]                           invokeRestart("muffleWarning")
[10:21:34.217]                       }
[10:21:34.217]                       else if (inherits(cond, "condition")) {
[10:21:34.217]                         if (!is.null(pattern)) {
[10:21:34.217]                           computeRestarts <- base::computeRestarts
[10:21:34.217]                           grepl <- base::grepl
[10:21:34.217]                           restarts <- computeRestarts(cond)
[10:21:34.217]                           for (restart in restarts) {
[10:21:34.217]                             name <- restart$name
[10:21:34.217]                             if (is.null(name)) 
[10:21:34.217]                               next
[10:21:34.217]                             if (!grepl(pattern, name)) 
[10:21:34.217]                               next
[10:21:34.217]                             invokeRestart(restart)
[10:21:34.217]                             muffled <- TRUE
[10:21:34.217]                             break
[10:21:34.217]                           }
[10:21:34.217]                         }
[10:21:34.217]                       }
[10:21:34.217]                       invisible(muffled)
[10:21:34.217]                     }
[10:21:34.217]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.217]                   }
[10:21:34.217]                 }
[10:21:34.217]                 else {
[10:21:34.217]                   if (TRUE) {
[10:21:34.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.217]                     {
[10:21:34.217]                       inherits <- base::inherits
[10:21:34.217]                       invokeRestart <- base::invokeRestart
[10:21:34.217]                       is.null <- base::is.null
[10:21:34.217]                       muffled <- FALSE
[10:21:34.217]                       if (inherits(cond, "message")) {
[10:21:34.217]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.217]                         if (muffled) 
[10:21:34.217]                           invokeRestart("muffleMessage")
[10:21:34.217]                       }
[10:21:34.217]                       else if (inherits(cond, "warning")) {
[10:21:34.217]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.217]                         if (muffled) 
[10:21:34.217]                           invokeRestart("muffleWarning")
[10:21:34.217]                       }
[10:21:34.217]                       else if (inherits(cond, "condition")) {
[10:21:34.217]                         if (!is.null(pattern)) {
[10:21:34.217]                           computeRestarts <- base::computeRestarts
[10:21:34.217]                           grepl <- base::grepl
[10:21:34.217]                           restarts <- computeRestarts(cond)
[10:21:34.217]                           for (restart in restarts) {
[10:21:34.217]                             name <- restart$name
[10:21:34.217]                             if (is.null(name)) 
[10:21:34.217]                               next
[10:21:34.217]                             if (!grepl(pattern, name)) 
[10:21:34.217]                               next
[10:21:34.217]                             invokeRestart(restart)
[10:21:34.217]                             muffled <- TRUE
[10:21:34.217]                             break
[10:21:34.217]                           }
[10:21:34.217]                         }
[10:21:34.217]                       }
[10:21:34.217]                       invisible(muffled)
[10:21:34.217]                     }
[10:21:34.217]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.217]                   }
[10:21:34.217]                 }
[10:21:34.217]             }
[10:21:34.217]         }))
[10:21:34.217]     }, error = function(ex) {
[10:21:34.217]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.217]                 ...future.rng), started = ...future.startTime, 
[10:21:34.217]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.217]             version = "1.8"), class = "FutureResult")
[10:21:34.217]     }, finally = {
[10:21:34.217]         if (!identical(...future.workdir, getwd())) 
[10:21:34.217]             setwd(...future.workdir)
[10:21:34.217]         {
[10:21:34.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.217]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.217]             }
[10:21:34.217]             base::options(...future.oldOptions)
[10:21:34.217]             if (.Platform$OS.type == "windows") {
[10:21:34.217]                 old_names <- names(...future.oldEnvVars)
[10:21:34.217]                 envs <- base::Sys.getenv()
[10:21:34.217]                 names <- names(envs)
[10:21:34.217]                 common <- intersect(names, old_names)
[10:21:34.217]                 added <- setdiff(names, old_names)
[10:21:34.217]                 removed <- setdiff(old_names, names)
[10:21:34.217]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.217]                   envs[common]]
[10:21:34.217]                 NAMES <- toupper(changed)
[10:21:34.217]                 args <- list()
[10:21:34.217]                 for (kk in seq_along(NAMES)) {
[10:21:34.217]                   name <- changed[[kk]]
[10:21:34.217]                   NAME <- NAMES[[kk]]
[10:21:34.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.217]                     next
[10:21:34.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.217]                 }
[10:21:34.217]                 NAMES <- toupper(added)
[10:21:34.217]                 for (kk in seq_along(NAMES)) {
[10:21:34.217]                   name <- added[[kk]]
[10:21:34.217]                   NAME <- NAMES[[kk]]
[10:21:34.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.217]                     next
[10:21:34.217]                   args[[name]] <- ""
[10:21:34.217]                 }
[10:21:34.217]                 NAMES <- toupper(removed)
[10:21:34.217]                 for (kk in seq_along(NAMES)) {
[10:21:34.217]                   name <- removed[[kk]]
[10:21:34.217]                   NAME <- NAMES[[kk]]
[10:21:34.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.217]                     next
[10:21:34.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.217]                 }
[10:21:34.217]                 if (length(args) > 0) 
[10:21:34.217]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.217]             }
[10:21:34.217]             else {
[10:21:34.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.217]             }
[10:21:34.217]             {
[10:21:34.217]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.217]                   0L) {
[10:21:34.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.217]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.217]                   base::options(opts)
[10:21:34.217]                 }
[10:21:34.217]                 {
[10:21:34.217]                   {
[10:21:34.217]                     NULL
[10:21:34.217]                     RNGkind("Mersenne-Twister")
[10:21:34.217]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:34.217]                       inherits = FALSE)
[10:21:34.217]                   }
[10:21:34.217]                   options(future.plan = NULL)
[10:21:34.217]                   if (is.na(NA_character_)) 
[10:21:34.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.217]                     .init = FALSE)
[10:21:34.217]                 }
[10:21:34.217]             }
[10:21:34.217]         }
[10:21:34.217]     })
[10:21:34.217]     if (TRUE) {
[10:21:34.217]         base::sink(type = "output", split = FALSE)
[10:21:34.217]         if (TRUE) {
[10:21:34.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.217]         }
[10:21:34.217]         else {
[10:21:34.217]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.217]         }
[10:21:34.217]         base::close(...future.stdout)
[10:21:34.217]         ...future.stdout <- NULL
[10:21:34.217]     }
[10:21:34.217]     ...future.result$conditions <- ...future.conditions
[10:21:34.217]     ...future.result$finished <- base::Sys.time()
[10:21:34.217]     ...future.result
[10:21:34.217] }
[10:21:34.220] assign_globals() ...
[10:21:34.220] List of 1
[10:21:34.220]  $ data:'data.frame':	5 obs. of  2 variables:
[10:21:34.220]   ..$ x: int [1:5] 1 2 3 4 5
[10:21:34.220]   ..$ y: int [1:5] 1 2 3 4 5
[10:21:34.220]  - attr(*, "where")=List of 1
[10:21:34.220]   ..$ data:<environment: R_EmptyEnv> 
[10:21:34.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:34.220]  - attr(*, "resolved")= logi FALSE
[10:21:34.220]  - attr(*, "total_size")= num 356
[10:21:34.220]  - attr(*, "already-done")= logi TRUE
[10:21:34.226] - copied ‘data’ to environment
[10:21:34.226] assign_globals() ... done
[10:21:34.227] plan(): Setting new future strategy stack:
[10:21:34.227] List of future strategies:
[10:21:34.227] 1. multicore:
[10:21:34.227]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:34.227]    - tweaked: FALSE
[10:21:34.227]    - call: plan(list(sequential, strategy))
[10:21:34.229] plan(): nbrOfWorkers() = 2
[10:21:34.270] plan(): Setting new future strategy stack:
[10:21:34.270] List of future strategies:
[10:21:34.270] 1. sequential:
[10:21:34.270]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.270]    - tweaked: FALSE
[10:21:34.270]    - call: plan(list(sequential, strategy))
[10:21:34.270] 2. multicore:
[10:21:34.270]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:34.270]    - tweaked: FALSE
[10:21:34.270]    - call: plan(list(sequential, strategy))
[10:21:34.271] plan(): nbrOfWorkers() = 1
[10:21:34.272] SequentialFuture started (and completed)
[10:21:34.272] signalConditions() ...
[10:21:34.272]  - include = ‘immediateCondition’
[10:21:34.272]  - exclude = 
[10:21:34.272]  - resignal = FALSE
[10:21:34.272]  - Number of conditions: 56
[10:21:34.272] signalConditions() ... done
[10:21:34.272] - Launch lazy future ... done
[10:21:34.273] run() for ‘SequentialFuture’ ... done
[10:21:34.273] signalConditions() ...
[10:21:34.273]  - include = ‘immediateCondition’
[10:21:34.273]  - exclude = 
[10:21:34.273]  - resignal = FALSE
[10:21:34.273]  - Number of conditions: 56
[10:21:34.273] signalConditions() ... done
[10:21:34.273] Future state: ‘finished’
[10:21:34.274] signalConditions() ...
[10:21:34.274]  - include = ‘condition’
[10:21:34.274]  - exclude = ‘immediateCondition’
[10:21:34.274]  - resignal = TRUE
[10:21:34.274]  - Number of conditions: 56
[10:21:34.274]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.229] getGlobalsAndPackages() ...
[10:21:34.274]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.274]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.244] Searching for globals...
[10:21:34.275]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.246] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:21:34.275]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.246] Searching for globals ... DONE
[10:21:34.275]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.247] Resolving globals: FALSE
[10:21:34.275]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.247] The total size of the 1 globals is 356 bytes (356 bytes)
[10:21:34.275]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.247] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:21:34.275]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.247] - globals: [1] ‘data’
[10:21:34.275]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.248] 
[10:21:34.276]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.248] getGlobalsAndPackages() ... DONE
[10:21:34.276]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.248] run() for ‘Future’ ...
[10:21:34.276]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.248] - state: ‘created’
[10:21:34.276]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.248] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:34.276]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.250] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:34.276]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.250] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:34.277]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.250]   - Field: ‘label’
[10:21:34.277]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.250]   - Field: ‘local’
[10:21:34.277]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.250]   - Field: ‘owner’
[10:21:34.277]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.250]   - Field: ‘envir’
[10:21:34.277]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.250]   - Field: ‘workers’
[10:21:34.277]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.251]   - Field: ‘packages’
[10:21:34.277]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.251]   - Field: ‘gc’
[10:21:34.278]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.251]   - Field: ‘job’
[10:21:34.278]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.251]   - Field: ‘conditions’
[10:21:34.278]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.251]   - Field: ‘expr’
[10:21:34.278]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.251]   - Field: ‘uuid’
[10:21:34.278]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.251]   - Field: ‘seed’
[10:21:34.278]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.251]   - Field: ‘version’
[10:21:34.278]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.251]   - Field: ‘result’
[10:21:34.279]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.251]   - Field: ‘asynchronous’
[10:21:34.279]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.252]   - Field: ‘calls’
[10:21:34.279]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.252]   - Field: ‘globals’
[10:21:34.279]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.252]   - Field: ‘stdout’
[10:21:34.279]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.252]   - Field: ‘earlySignal’
[10:21:34.279]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.252]   - Field: ‘lazy’
[10:21:34.279]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.252]   - Field: ‘state’
[10:21:34.280]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.252] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:34.280]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.252] - Launch lazy future ...
[10:21:34.280]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.253] Packages needed by the future expression (n = 0): <none>
[10:21:34.280]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.253] Packages needed by future strategies (n = 0): <none>
[10:21:34.280]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.253] {
[10:21:34.253]     {
[10:21:34.253]         {
[10:21:34.253]             ...future.startTime <- base::Sys.time()
[10:21:34.253]             {
[10:21:34.253]                 {
[10:21:34.253]                   {
[10:21:34.253]                     {
[10:21:34.253]                       base::local({
[10:21:34.253]                         has_future <- base::requireNamespace("future", 
[10:21:34.253]                           quietly = TRUE)
[10:21:34.253]                         if (has_future) {
[10:21:34.253]                           ns <- base::getNamespace("future")
[10:21:34.253]                           version <- ns[[".package"]][["version"]]
[10:21:34.253]                           if (is.null(version)) 
[10:21:34.253]                             version <- utils::packageVersion("future")
[10:21:34.253]                         }
[10:21:34.253]                         else {
[10:21:34.253]                           version <- NULL
[10:21:34.253]                         }
[10:21:34.253]                         if (!has_future || version < "1.8.0") {
[10:21:34.253]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.253]                             "", base::R.version$version.string), 
[10:21:34.253]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.253]                               "release", "version")], collapse = " "), 
[10:21:34.253]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.253]                             info)
[10:21:34.253]                           info <- base::paste(info, collapse = "; ")
[10:21:34.253]                           if (!has_future) {
[10:21:34.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.253]                               info)
[10:21:34.253]                           }
[10:21:34.253]                           else {
[10:21:34.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.253]                               info, version)
[10:21:34.253]                           }
[10:21:34.253]                           base::stop(msg)
[10:21:34.253]                         }
[10:21:34.253]                       })
[10:21:34.253]                     }
[10:21:34.253]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:34.253]                     base::options(mc.cores = 1L)
[10:21:34.253]                   }
[10:21:34.253]                   ...future.strategy.old <- future::plan("list")
[10:21:34.253]                   options(future.plan = NULL)
[10:21:34.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.253]                 }
[10:21:34.253]                 ...future.workdir <- getwd()
[10:21:34.253]             }
[10:21:34.253]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.253]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.253]         }
[10:21:34.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.253]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.253]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.253]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.253]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.253]             base::names(...future.oldOptions))
[10:21:34.253]     }
[10:21:34.253]     if (FALSE) {
[10:21:34.253]     }
[10:21:34.253]     else {
[10:21:34.253]         if (TRUE) {
[10:21:34.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.253]                 open = "w")
[10:21:34.253]         }
[10:21:34.253]         else {
[10:21:34.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.253]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.253]         }
[10:21:34.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.253]             base::sink(type = "output", split = FALSE)
[10:21:34.253]             base::close(...future.stdout)
[10:21:34.253]         }, add = TRUE)
[10:21:34.253]     }
[10:21:34.253]     ...future.frame <- base::sys.nframe()
[10:21:34.253]     ...future.conditions <- base::list()
[10:21:34.253]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.253]     if (FALSE) {
[10:21:34.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.253]     }
[10:21:34.253]     ...future.result <- base::tryCatch({
[10:21:34.253]         base::withCallingHandlers({
[10:21:34.253]             ...future.value <- base::withVisible(base::local({
[10:21:34.253]                 withCallingHandlers({
[10:21:34.253]                   subset(data, x < 3)$y
[10:21:34.253]                 }, immediateCondition = function(cond) {
[10:21:34.253]                   save_rds <- function (object, pathname, ...) 
[10:21:34.253]                   {
[10:21:34.253]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:34.253]                     if (file_test("-f", pathname_tmp)) {
[10:21:34.253]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.253]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:34.253]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.253]                         fi_tmp[["mtime"]])
[10:21:34.253]                     }
[10:21:34.253]                     tryCatch({
[10:21:34.253]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:34.253]                     }, error = function(ex) {
[10:21:34.253]                       msg <- conditionMessage(ex)
[10:21:34.253]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.253]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:34.253]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.253]                         fi_tmp[["mtime"]], msg)
[10:21:34.253]                       ex$message <- msg
[10:21:34.253]                       stop(ex)
[10:21:34.253]                     })
[10:21:34.253]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:34.253]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:34.253]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:34.253]                       fi_tmp <- file.info(pathname_tmp)
[10:21:34.253]                       fi <- file.info(pathname)
[10:21:34.253]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:34.253]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:34.253]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:34.253]                         fi[["size"]], fi[["mtime"]])
[10:21:34.253]                       stop(msg)
[10:21:34.253]                     }
[10:21:34.253]                     invisible(pathname)
[10:21:34.253]                   }
[10:21:34.253]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:34.253]                     rootPath = tempdir()) 
[10:21:34.253]                   {
[10:21:34.253]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:34.253]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:34.253]                       tmpdir = path, fileext = ".rds")
[10:21:34.253]                     save_rds(obj, file)
[10:21:34.253]                   }
[10:21:34.253]                   saveImmediateCondition(cond, path = "/tmp/RtmpwqU11c/.future/immediateConditions")
[10:21:34.253]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.253]                   {
[10:21:34.253]                     inherits <- base::inherits
[10:21:34.253]                     invokeRestart <- base::invokeRestart
[10:21:34.253]                     is.null <- base::is.null
[10:21:34.253]                     muffled <- FALSE
[10:21:34.253]                     if (inherits(cond, "message")) {
[10:21:34.253]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:34.253]                       if (muffled) 
[10:21:34.253]                         invokeRestart("muffleMessage")
[10:21:34.253]                     }
[10:21:34.253]                     else if (inherits(cond, "warning")) {
[10:21:34.253]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:34.253]                       if (muffled) 
[10:21:34.253]                         invokeRestart("muffleWarning")
[10:21:34.253]                     }
[10:21:34.253]                     else if (inherits(cond, "condition")) {
[10:21:34.253]                       if (!is.null(pattern)) {
[10:21:34.253]                         computeRestarts <- base::computeRestarts
[10:21:34.253]                         grepl <- base::grepl
[10:21:34.253]                         restarts <- computeRestarts(cond)
[10:21:34.253]                         for (restart in restarts) {
[10:21:34.253]                           name <- restart$name
[10:21:34.253]                           if (is.null(name)) 
[10:21:34.253]                             next
[10:21:34.253]                           if (!grepl(pattern, name)) 
[10:21:34.253]                             next
[10:21:34.253]                           invokeRestart(restart)
[10:21:34.253]                           muffled <- TRUE
[10:21:34.253]                           break
[10:21:34.253]                         }
[10:21:34.253]                       }
[10:21:34.253]                     }
[10:21:34.253]                     invisible(muffled)
[10:21:34.253]                   }
[10:21:34.253]                   muffleCondition(cond)
[10:21:34.253]                 })
[10:21:34.253]             }))
[10:21:34.253]             future::FutureResult(value = ...future.value$value, 
[10:21:34.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.253]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.253]                     ...future.globalenv.names))
[10:21:34.253]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.253]         }, condition = base::local({
[10:21:34.253]             c <- base::c
[10:21:34.253]             inherits <- base::inherits
[10:21:34.253]             invokeRestart <- base::invokeRestart
[10:21:34.253]             length <- base::length
[10:21:34.253]             list <- base::list
[10:21:34.253]             seq.int <- base::seq.int
[10:21:34.253]             signalCondition <- base::signalCondition
[10:21:34.253]             sys.calls <- base::sys.calls
[10:21:34.253]             `[[` <- base::`[[`
[10:21:34.253]             `+` <- base::`+`
[10:21:34.253]             `<<-` <- base::`<<-`
[10:21:34.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.253]                   3L)]
[10:21:34.253]             }
[10:21:34.253]             function(cond) {
[10:21:34.253]                 is_error <- inherits(cond, "error")
[10:21:34.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.253]                   NULL)
[10:21:34.253]                 if (is_error) {
[10:21:34.253]                   sessionInformation <- function() {
[10:21:34.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.253]                       search = base::search(), system = base::Sys.info())
[10:21:34.253]                   }
[10:21:34.253]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.253]                     cond$call), session = sessionInformation(), 
[10:21:34.253]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.253]                   signalCondition(cond)
[10:21:34.253]                 }
[10:21:34.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.253]                 "immediateCondition"))) {
[10:21:34.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.253]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.253]                   if (TRUE && !signal) {
[10:21:34.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.253]                     {
[10:21:34.253]                       inherits <- base::inherits
[10:21:34.253]                       invokeRestart <- base::invokeRestart
[10:21:34.253]                       is.null <- base::is.null
[10:21:34.253]                       muffled <- FALSE
[10:21:34.253]                       if (inherits(cond, "message")) {
[10:21:34.253]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.253]                         if (muffled) 
[10:21:34.253]                           invokeRestart("muffleMessage")
[10:21:34.253]                       }
[10:21:34.253]                       else if (inherits(cond, "warning")) {
[10:21:34.253]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.253]                         if (muffled) 
[10:21:34.253]                           invokeRestart("muffleWarning")
[10:21:34.253]                       }
[10:21:34.253]                       else if (inherits(cond, "condition")) {
[10:21:34.253]                         if (!is.null(pattern)) {
[10:21:34.253]                           computeRestarts <- base::computeRestarts
[10:21:34.253]                           grepl <- base::grepl
[10:21:34.253]                           restarts <- computeRestarts(cond)
[10:21:34.253]                           for (restart in restarts) {
[10:21:34.253]                             name <- restart$name
[10:21:34.253]                             if (is.null(name)) 
[10:21:34.253]                               next
[10:21:34.253]                             if (!grepl(pattern, name)) 
[10:21:34.253]                               next
[10:21:34.253]                             invokeRestart(restart)
[10:21:34.253]                             muffled <- TRUE
[10:21:34.253]                             break
[10:21:34.253]                           }
[10:21:34.253]                         }
[10:21:34.253]                       }
[10:21:34.253]                       invisible(muffled)
[10:21:34.253]                     }
[10:21:34.253]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.253]                   }
[10:21:34.253]                 }
[10:21:34.253]                 else {
[10:21:34.253]                   if (TRUE) {
[10:21:34.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.253]                     {
[10:21:34.253]                       inherits <- base::inherits
[10:21:34.253]                       invokeRestart <- base::invokeRestart
[10:21:34.253]                       is.null <- base::is.null
[10:21:34.253]                       muffled <- FALSE
[10:21:34.253]                       if (inherits(cond, "message")) {
[10:21:34.253]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.253]                         if (muffled) 
[10:21:34.253]                           invokeRestart("muffleMessage")
[10:21:34.253]                       }
[10:21:34.253]                       else if (inherits(cond, "warning")) {
[10:21:34.253]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.253]                         if (muffled) 
[10:21:34.253]                           invokeRestart("muffleWarning")
[10:21:34.253]                       }
[10:21:34.253]                       else if (inherits(cond, "condition")) {
[10:21:34.253]                         if (!is.null(pattern)) {
[10:21:34.253]                           computeRestarts <- base::computeRestarts
[10:21:34.253]                           grepl <- base::grepl
[10:21:34.253]                           restarts <- computeRestarts(cond)
[10:21:34.253]                           for (restart in restarts) {
[10:21:34.253]                             name <- restart$name
[10:21:34.253]                             if (is.null(name)) 
[10:21:34.253]                               next
[10:21:34.253]                             if (!grepl(pattern, name)) 
[10:21:34.253]                               next
[10:21:34.253]                             invokeRestart(restart)
[10:21:34.253]                             muffled <- TRUE
[10:21:34.253]                             break
[10:21:34.253]                           }
[10:21:34.253]                         }
[10:21:34.253]                       }
[10:21:34.253]                       invisible(muffled)
[10:21:34.253]                     }
[10:21:34.253]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.253]                   }
[10:21:34.253]                 }
[10:21:34.253]             }
[10:21:34.253]         }))
[10:21:34.253]     }, error = function(ex) {
[10:21:34.253]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.253]                 ...future.rng), started = ...future.startTime, 
[10:21:34.253]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.253]             version = "1.8"), class = "FutureResult")
[10:21:34.253]     }, finally = {
[10:21:34.253]         if (!identical(...future.workdir, getwd())) 
[10:21:34.253]             setwd(...future.workdir)
[10:21:34.253]         {
[10:21:34.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.253]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.253]             }
[10:21:34.253]             base::options(...future.oldOptions)
[10:21:34.253]             if (.Platform$OS.type == "windows") {
[10:21:34.253]                 old_names <- names(...future.oldEnvVars)
[10:21:34.253]                 envs <- base::Sys.getenv()
[10:21:34.253]                 names <- names(envs)
[10:21:34.253]                 common <- intersect(names, old_names)
[10:21:34.253]                 added <- setdiff(names, old_names)
[10:21:34.253]                 removed <- setdiff(old_names, names)
[10:21:34.253]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.253]                   envs[common]]
[10:21:34.253]                 NAMES <- toupper(changed)
[10:21:34.253]                 args <- list()
[10:21:34.253]                 for (kk in seq_along(NAMES)) {
[10:21:34.253]                   name <- changed[[kk]]
[10:21:34.253]                   NAME <- NAMES[[kk]]
[10:21:34.253]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.253]                     next
[10:21:34.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.253]                 }
[10:21:34.253]                 NAMES <- toupper(added)
[10:21:34.253]                 for (kk in seq_along(NAMES)) {
[10:21:34.253]                   name <- added[[kk]]
[10:21:34.253]                   NAME <- NAMES[[kk]]
[10:21:34.253]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.253]                     next
[10:21:34.253]                   args[[name]] <- ""
[10:21:34.253]                 }
[10:21:34.253]                 NAMES <- toupper(removed)
[10:21:34.253]                 for (kk in seq_along(NAMES)) {
[10:21:34.253]                   name <- removed[[kk]]
[10:21:34.253]                   NAME <- NAMES[[kk]]
[10:21:34.253]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.253]                     next
[10:21:34.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.253]                 }
[10:21:34.253]                 if (length(args) > 0) 
[10:21:34.253]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.253]             }
[10:21:34.253]             else {
[10:21:34.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.253]             }
[10:21:34.253]             {
[10:21:34.253]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.253]                   0L) {
[10:21:34.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.253]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.253]                   base::options(opts)
[10:21:34.253]                 }
[10:21:34.253]                 {
[10:21:34.253]                   {
[10:21:34.253]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:34.253]                     NULL
[10:21:34.253]                   }
[10:21:34.253]                   options(future.plan = NULL)
[10:21:34.253]                   if (is.na(NA_character_)) 
[10:21:34.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.253]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.253]                     .init = FALSE)
[10:21:34.253]                 }
[10:21:34.253]             }
[10:21:34.253]         }
[10:21:34.253]     })
[10:21:34.253]     if (TRUE) {
[10:21:34.253]         base::sink(type = "output", split = FALSE)
[10:21:34.253]         if (TRUE) {
[10:21:34.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.253]         }
[10:21:34.253]         else {
[10:21:34.253]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.253]         }
[10:21:34.253]         base::close(...future.stdout)
[10:21:34.253]         ...future.stdout <- NULL
[10:21:34.253]     }
[10:21:34.253]     ...future.result$conditions <- ...future.conditions
[10:21:34.253]     ...future.result$finished <- base::Sys.time()
[10:21:34.253]     ...future.result
[10:21:34.253] }
[10:21:34.281]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.255] assign_globals() ...
[10:21:34.281]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.255] List of 1
[10:21:34.255]  $ data:'data.frame':	5 obs. of  2 variables:
[10:21:34.255]   ..$ x: int [1:5] 1 2 3 4 5
[10:21:34.255]   ..$ y: int [1:5] 1 2 3 4 5
[10:21:34.255]  - attr(*, "where")=List of 1
[10:21:34.255]   ..$ data:<environment: R_EmptyEnv> 
[10:21:34.255]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:34.255]  - attr(*, "resolved")= logi FALSE
[10:21:34.255]  - attr(*, "total_size")= num 356
[10:21:34.255]  - attr(*, "already-done")= logi TRUE
[10:21:34.281]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.258] - copied ‘data’ to environment
[10:21:34.281]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.258] assign_globals() ... done
[10:21:34.281]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.258] requestCore(): workers = 2
[10:21:34.281]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.260] MulticoreFuture started
[10:21:34.281]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.261] - Launch lazy future ... done
[10:21:34.284]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.261] run() for ‘MulticoreFuture’ ... done
[10:21:34.284]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.262] result() for MulticoreFuture ...
[10:21:34.284]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.269] result() for MulticoreFuture ...
[10:21:34.284]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.269] result() for MulticoreFuture ... done
[10:21:34.284]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.269] result() for MulticoreFuture ... done
[10:21:34.285]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.269] result() for MulticoreFuture ...
[10:21:34.285]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.270] result() for MulticoreFuture ... done
[10:21:34.285] signalConditions() ... done
[10:21:34.285] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.286] Searching for globals...
[10:21:34.287] - globals found: [3] ‘{’, ‘plan’, ‘sequential’
[10:21:34.287] Searching for globals ... DONE
[10:21:34.287] Resolving globals: FALSE
[10:21:34.288] 
[10:21:34.288] - packages: [1] ‘future’
[10:21:34.288] getGlobalsAndPackages() ... DONE
[10:21:34.288] run() for ‘Future’ ...
[10:21:34.288] - state: ‘created’
[10:21:34.288] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:34.289] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:34.289] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:34.289]   - Field: ‘label’
[10:21:34.289]   - Field: ‘local’
[10:21:34.289]   - Field: ‘owner’
[10:21:34.289]   - Field: ‘envir’
[10:21:34.289]   - Field: ‘packages’
[10:21:34.290]   - Field: ‘gc’
[10:21:34.290]   - Field: ‘conditions’
[10:21:34.290]   - Field: ‘expr’
[10:21:34.290]   - Field: ‘uuid’
[10:21:34.290]   - Field: ‘seed’
[10:21:34.290]   - Field: ‘version’
[10:21:34.290]   - Field: ‘result’
[10:21:34.290]   - Field: ‘asynchronous’
[10:21:34.290]   - Field: ‘calls’
[10:21:34.290]   - Field: ‘globals’
[10:21:34.291]   - Field: ‘stdout’
[10:21:34.291]   - Field: ‘earlySignal’
[10:21:34.291]   - Field: ‘lazy’
[10:21:34.291]   - Field: ‘state’
[10:21:34.291] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:34.291] - Launch lazy future ...
[10:21:34.291] Packages needed by the future expression (n = 1): ‘future’
[10:21:34.291] Packages needed by future strategies (n = 1): ‘future’
[10:21:34.292] {
[10:21:34.292]     {
[10:21:34.292]         {
[10:21:34.292]             ...future.startTime <- base::Sys.time()
[10:21:34.292]             {
[10:21:34.292]                 {
[10:21:34.292]                   {
[10:21:34.292]                     {
[10:21:34.292]                       base::local({
[10:21:34.292]                         has_future <- base::requireNamespace("future", 
[10:21:34.292]                           quietly = TRUE)
[10:21:34.292]                         if (has_future) {
[10:21:34.292]                           ns <- base::getNamespace("future")
[10:21:34.292]                           version <- ns[[".package"]][["version"]]
[10:21:34.292]                           if (is.null(version)) 
[10:21:34.292]                             version <- utils::packageVersion("future")
[10:21:34.292]                         }
[10:21:34.292]                         else {
[10:21:34.292]                           version <- NULL
[10:21:34.292]                         }
[10:21:34.292]                         if (!has_future || version < "1.8.0") {
[10:21:34.292]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.292]                             "", base::R.version$version.string), 
[10:21:34.292]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.292]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.292]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.292]                               "release", "version")], collapse = " "), 
[10:21:34.292]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.292]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.292]                             info)
[10:21:34.292]                           info <- base::paste(info, collapse = "; ")
[10:21:34.292]                           if (!has_future) {
[10:21:34.292]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.292]                               info)
[10:21:34.292]                           }
[10:21:34.292]                           else {
[10:21:34.292]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.292]                               info, version)
[10:21:34.292]                           }
[10:21:34.292]                           base::stop(msg)
[10:21:34.292]                         }
[10:21:34.292]                       })
[10:21:34.292]                     }
[10:21:34.292]                     base::local({
[10:21:34.292]                       for (pkg in "future") {
[10:21:34.292]                         base::loadNamespace(pkg)
[10:21:34.292]                         base::library(pkg, character.only = TRUE)
[10:21:34.292]                       }
[10:21:34.292]                     })
[10:21:34.292]                   }
[10:21:34.292]                   ...future.strategy.old <- future::plan("list")
[10:21:34.292]                   options(future.plan = NULL)
[10:21:34.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.292]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[10:21:34.292]                     envir = parent.frame()) 
[10:21:34.292]                   {
[10:21:34.292]                     default_workers <- missing(workers)
[10:21:34.292]                     if (is.function(workers)) 
[10:21:34.292]                       workers <- workers()
[10:21:34.292]                     workers <- structure(as.integer(workers), 
[10:21:34.292]                       class = class(workers))
[10:21:34.292]                     stop_if_not(is.finite(workers), workers >= 
[10:21:34.292]                       1L)
[10:21:34.292]                     if ((workers == 1L && !inherits(workers, 
[10:21:34.292]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:21:34.292]                       if (default_workers) 
[10:21:34.292]                         supportsMulticore(warn = TRUE)
[10:21:34.292]                       return(sequential(..., envir = envir))
[10:21:34.292]                     }
[10:21:34.292]                     oopts <- options(mc.cores = workers)
[10:21:34.292]                     on.exit(options(oopts))
[10:21:34.292]                     future <- MulticoreFuture(..., workers = workers, 
[10:21:34.292]                       envir = envir)
[10:21:34.292]                     if (!future$lazy) 
[10:21:34.292]                       future <- run(future)
[10:21:34.292]                     invisible(future)
[10:21:34.292]                   }), .cleanup = FALSE, .init = FALSE)
[10:21:34.292]                 }
[10:21:34.292]                 ...future.workdir <- getwd()
[10:21:34.292]             }
[10:21:34.292]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.292]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.292]         }
[10:21:34.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.292]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.292]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.292]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.292]             base::names(...future.oldOptions))
[10:21:34.292]     }
[10:21:34.292]     if (FALSE) {
[10:21:34.292]     }
[10:21:34.292]     else {
[10:21:34.292]         if (TRUE) {
[10:21:34.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.292]                 open = "w")
[10:21:34.292]         }
[10:21:34.292]         else {
[10:21:34.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.292]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.292]         }
[10:21:34.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.292]             base::sink(type = "output", split = FALSE)
[10:21:34.292]             base::close(...future.stdout)
[10:21:34.292]         }, add = TRUE)
[10:21:34.292]     }
[10:21:34.292]     ...future.frame <- base::sys.nframe()
[10:21:34.292]     ...future.conditions <- base::list()
[10:21:34.292]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.292]     if (FALSE) {
[10:21:34.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.292]     }
[10:21:34.292]     ...future.result <- base::tryCatch({
[10:21:34.292]         base::withCallingHandlers({
[10:21:34.292]             ...future.value <- base::withVisible(base::local({
[10:21:34.292]                 plan(sequential)
[10:21:34.292]             }))
[10:21:34.292]             future::FutureResult(value = ...future.value$value, 
[10:21:34.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.292]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.292]                     ...future.globalenv.names))
[10:21:34.292]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.292]         }, condition = base::local({
[10:21:34.292]             c <- base::c
[10:21:34.292]             inherits <- base::inherits
[10:21:34.292]             invokeRestart <- base::invokeRestart
[10:21:34.292]             length <- base::length
[10:21:34.292]             list <- base::list
[10:21:34.292]             seq.int <- base::seq.int
[10:21:34.292]             signalCondition <- base::signalCondition
[10:21:34.292]             sys.calls <- base::sys.calls
[10:21:34.292]             `[[` <- base::`[[`
[10:21:34.292]             `+` <- base::`+`
[10:21:34.292]             `<<-` <- base::`<<-`
[10:21:34.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.292]                   3L)]
[10:21:34.292]             }
[10:21:34.292]             function(cond) {
[10:21:34.292]                 is_error <- inherits(cond, "error")
[10:21:34.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.292]                   NULL)
[10:21:34.292]                 if (is_error) {
[10:21:34.292]                   sessionInformation <- function() {
[10:21:34.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.292]                       search = base::search(), system = base::Sys.info())
[10:21:34.292]                   }
[10:21:34.292]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.292]                     cond$call), session = sessionInformation(), 
[10:21:34.292]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.292]                   signalCondition(cond)
[10:21:34.292]                 }
[10:21:34.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.292]                 "immediateCondition"))) {
[10:21:34.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.292]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.292]                   if (TRUE && !signal) {
[10:21:34.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.292]                     {
[10:21:34.292]                       inherits <- base::inherits
[10:21:34.292]                       invokeRestart <- base::invokeRestart
[10:21:34.292]                       is.null <- base::is.null
[10:21:34.292]                       muffled <- FALSE
[10:21:34.292]                       if (inherits(cond, "message")) {
[10:21:34.292]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.292]                         if (muffled) 
[10:21:34.292]                           invokeRestart("muffleMessage")
[10:21:34.292]                       }
[10:21:34.292]                       else if (inherits(cond, "warning")) {
[10:21:34.292]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.292]                         if (muffled) 
[10:21:34.292]                           invokeRestart("muffleWarning")
[10:21:34.292]                       }
[10:21:34.292]                       else if (inherits(cond, "condition")) {
[10:21:34.292]                         if (!is.null(pattern)) {
[10:21:34.292]                           computeRestarts <- base::computeRestarts
[10:21:34.292]                           grepl <- base::grepl
[10:21:34.292]                           restarts <- computeRestarts(cond)
[10:21:34.292]                           for (restart in restarts) {
[10:21:34.292]                             name <- restart$name
[10:21:34.292]                             if (is.null(name)) 
[10:21:34.292]                               next
[10:21:34.292]                             if (!grepl(pattern, name)) 
[10:21:34.292]                               next
[10:21:34.292]                             invokeRestart(restart)
[10:21:34.292]                             muffled <- TRUE
[10:21:34.292]                             break
[10:21:34.292]                           }
[10:21:34.292]                         }
[10:21:34.292]                       }
[10:21:34.292]                       invisible(muffled)
[10:21:34.292]                     }
[10:21:34.292]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.292]                   }
[10:21:34.292]                 }
[10:21:34.292]                 else {
[10:21:34.292]                   if (TRUE) {
[10:21:34.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.292]                     {
[10:21:34.292]                       inherits <- base::inherits
[10:21:34.292]                       invokeRestart <- base::invokeRestart
[10:21:34.292]                       is.null <- base::is.null
[10:21:34.292]                       muffled <- FALSE
[10:21:34.292]                       if (inherits(cond, "message")) {
[10:21:34.292]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.292]                         if (muffled) 
[10:21:34.292]                           invokeRestart("muffleMessage")
[10:21:34.292]                       }
[10:21:34.292]                       else if (inherits(cond, "warning")) {
[10:21:34.292]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.292]                         if (muffled) 
[10:21:34.292]                           invokeRestart("muffleWarning")
[10:21:34.292]                       }
[10:21:34.292]                       else if (inherits(cond, "condition")) {
[10:21:34.292]                         if (!is.null(pattern)) {
[10:21:34.292]                           computeRestarts <- base::computeRestarts
[10:21:34.292]                           grepl <- base::grepl
[10:21:34.292]                           restarts <- computeRestarts(cond)
[10:21:34.292]                           for (restart in restarts) {
[10:21:34.292]                             name <- restart$name
[10:21:34.292]                             if (is.null(name)) 
[10:21:34.292]                               next
[10:21:34.292]                             if (!grepl(pattern, name)) 
[10:21:34.292]                               next
[10:21:34.292]                             invokeRestart(restart)
[10:21:34.292]                             muffled <- TRUE
[10:21:34.292]                             break
[10:21:34.292]                           }
[10:21:34.292]                         }
[10:21:34.292]                       }
[10:21:34.292]                       invisible(muffled)
[10:21:34.292]                     }
[10:21:34.292]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.292]                   }
[10:21:34.292]                 }
[10:21:34.292]             }
[10:21:34.292]         }))
[10:21:34.292]     }, error = function(ex) {
[10:21:34.292]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.292]                 ...future.rng), started = ...future.startTime, 
[10:21:34.292]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.292]             version = "1.8"), class = "FutureResult")
[10:21:34.292]     }, finally = {
[10:21:34.292]         if (!identical(...future.workdir, getwd())) 
[10:21:34.292]             setwd(...future.workdir)
[10:21:34.292]         {
[10:21:34.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.292]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.292]             }
[10:21:34.292]             base::options(...future.oldOptions)
[10:21:34.292]             if (.Platform$OS.type == "windows") {
[10:21:34.292]                 old_names <- names(...future.oldEnvVars)
[10:21:34.292]                 envs <- base::Sys.getenv()
[10:21:34.292]                 names <- names(envs)
[10:21:34.292]                 common <- intersect(names, old_names)
[10:21:34.292]                 added <- setdiff(names, old_names)
[10:21:34.292]                 removed <- setdiff(old_names, names)
[10:21:34.292]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.292]                   envs[common]]
[10:21:34.292]                 NAMES <- toupper(changed)
[10:21:34.292]                 args <- list()
[10:21:34.292]                 for (kk in seq_along(NAMES)) {
[10:21:34.292]                   name <- changed[[kk]]
[10:21:34.292]                   NAME <- NAMES[[kk]]
[10:21:34.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.292]                     next
[10:21:34.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.292]                 }
[10:21:34.292]                 NAMES <- toupper(added)
[10:21:34.292]                 for (kk in seq_along(NAMES)) {
[10:21:34.292]                   name <- added[[kk]]
[10:21:34.292]                   NAME <- NAMES[[kk]]
[10:21:34.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.292]                     next
[10:21:34.292]                   args[[name]] <- ""
[10:21:34.292]                 }
[10:21:34.292]                 NAMES <- toupper(removed)
[10:21:34.292]                 for (kk in seq_along(NAMES)) {
[10:21:34.292]                   name <- removed[[kk]]
[10:21:34.292]                   NAME <- NAMES[[kk]]
[10:21:34.292]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.292]                     next
[10:21:34.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.292]                 }
[10:21:34.292]                 if (length(args) > 0) 
[10:21:34.292]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.292]             }
[10:21:34.292]             else {
[10:21:34.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.292]             }
[10:21:34.292]             {
[10:21:34.292]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.292]                   0L) {
[10:21:34.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.292]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.292]                   base::options(opts)
[10:21:34.292]                 }
[10:21:34.292]                 {
[10:21:34.292]                   {
[10:21:34.292]                     NULL
[10:21:34.292]                     RNGkind("Mersenne-Twister")
[10:21:34.292]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:34.292]                       inherits = FALSE)
[10:21:34.292]                   }
[10:21:34.292]                   options(future.plan = NULL)
[10:21:34.292]                   if (is.na(NA_character_)) 
[10:21:34.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.292]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.292]                     .init = FALSE)
[10:21:34.292]                 }
[10:21:34.292]             }
[10:21:34.292]         }
[10:21:34.292]     })
[10:21:34.292]     if (TRUE) {
[10:21:34.292]         base::sink(type = "output", split = FALSE)
[10:21:34.292]         if (TRUE) {
[10:21:34.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.292]         }
[10:21:34.292]         else {
[10:21:34.292]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.292]         }
[10:21:34.292]         base::close(...future.stdout)
[10:21:34.292]         ...future.stdout <- NULL
[10:21:34.292]     }
[10:21:34.292]     ...future.result$conditions <- ...future.conditions
[10:21:34.292]     ...future.result$finished <- base::Sys.time()
[10:21:34.292]     ...future.result
[10:21:34.292] }
[10:21:34.294] plan(): Setting new future strategy stack:
[10:21:34.294] List of future strategies:
[10:21:34.294] 1. multicore:
[10:21:34.294]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:34.294]    - tweaked: FALSE
[10:21:34.294]    - call: plan(list(sequential, strategy))
[10:21:34.296] plan(): nbrOfWorkers() = 2
[10:21:34.312] plan(): Setting new future strategy stack:
[10:21:34.313] List of future strategies:
[10:21:34.313] 1. sequential:
[10:21:34.313]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.313]    - tweaked: FALSE
[10:21:34.313]    - call: plan(list(sequential, strategy))
[10:21:34.313] 2. multicore:
[10:21:34.313]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:34.313]    - tweaked: FALSE
[10:21:34.313]    - call: plan(list(sequential, strategy))
[10:21:34.313] plan(): nbrOfWorkers() = 1
[10:21:34.313] SequentialFuture started (and completed)
[10:21:34.313] signalConditions() ...
[10:21:34.313]  - include = ‘immediateCondition’
[10:21:34.314]  - exclude = 
[10:21:34.314]  - resignal = FALSE
[10:21:34.314]  - Number of conditions: 3
[10:21:34.314] signalConditions() ... done
[10:21:34.314] - Launch lazy future ... done
[10:21:34.314] run() for ‘SequentialFuture’ ... done
[10:21:34.314] signalConditions() ...
[10:21:34.314]  - include = ‘immediateCondition’
[10:21:34.314]  - exclude = 
[10:21:34.314]  - resignal = FALSE
[10:21:34.314]  - Number of conditions: 3
[10:21:34.315] signalConditions() ... done
[10:21:34.315] Future state: ‘finished’
[10:21:34.315] signalConditions() ...
[10:21:34.315]  - include = ‘condition’
[10:21:34.315]  - exclude = ‘immediateCondition’
[10:21:34.315]  - resignal = TRUE
[10:21:34.315]  - Number of conditions: 3
[10:21:34.315]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.297] plan(): Setting new future strategy stack:
[10:21:34.315]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.297] List of future strategies:
[10:21:34.297] 1. sequential:
[10:21:34.297]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:34.297]    - tweaked: FALSE
[10:21:34.297]    - call: plan(sequential)
[10:21:34.315]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:34.312] plan(): nbrOfWorkers() = 1
[10:21:34.316] signalConditions() ... done
List of future strategies:
1. multicore:
   - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
   - tweaked: FALSE
   - call: plan(list(sequential, strategy))
- Strategy: multicore ... DONE
- Strategy: multisession ...
[10:21:34.316] plan(): Setting new future strategy stack:
[10:21:34.316] List of future strategies:
[10:21:34.316] 1. multisession:
[10:21:34.316]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:34.316]    - tweaked: FALSE
[10:21:34.316]    - call: plan(strategy)
[10:21:34.316] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:34.317] multisession:
[10:21:34.317] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:34.317] - tweaked: FALSE
[10:21:34.317] - call: plan(strategy)
[10:21:34.320] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.320] Not searching for globals
[10:21:34.320] - globals: [0] <none>
[10:21:34.321] getGlobalsAndPackages() ... DONE
[10:21:34.801] Packages needed by the future expression (n = 0): <none>
[10:21:34.801] Packages needed by future strategies (n = 0): <none>
[10:21:34.802] {
[10:21:34.802]     {
[10:21:34.802]         {
[10:21:34.802]             ...future.startTime <- base::Sys.time()
[10:21:34.802]             {
[10:21:34.802]                 {
[10:21:34.802]                   {
[10:21:34.802]                     {
[10:21:34.802]                       base::local({
[10:21:34.802]                         has_future <- base::requireNamespace("future", 
[10:21:34.802]                           quietly = TRUE)
[10:21:34.802]                         if (has_future) {
[10:21:34.802]                           ns <- base::getNamespace("future")
[10:21:34.802]                           version <- ns[[".package"]][["version"]]
[10:21:34.802]                           if (is.null(version)) 
[10:21:34.802]                             version <- utils::packageVersion("future")
[10:21:34.802]                         }
[10:21:34.802]                         else {
[10:21:34.802]                           version <- NULL
[10:21:34.802]                         }
[10:21:34.802]                         if (!has_future || version < "1.8.0") {
[10:21:34.802]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.802]                             "", base::R.version$version.string), 
[10:21:34.802]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.802]                               "release", "version")], collapse = " "), 
[10:21:34.802]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.802]                             info)
[10:21:34.802]                           info <- base::paste(info, collapse = "; ")
[10:21:34.802]                           if (!has_future) {
[10:21:34.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.802]                               info)
[10:21:34.802]                           }
[10:21:34.802]                           else {
[10:21:34.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.802]                               info, version)
[10:21:34.802]                           }
[10:21:34.802]                           base::stop(msg)
[10:21:34.802]                         }
[10:21:34.802]                       })
[10:21:34.802]                     }
[10:21:34.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:34.802]                     base::options(mc.cores = 1L)
[10:21:34.802]                   }
[10:21:34.802]                   ...future.strategy.old <- future::plan("list")
[10:21:34.802]                   options(future.plan = NULL)
[10:21:34.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.802]                 }
[10:21:34.802]                 ...future.workdir <- getwd()
[10:21:34.802]             }
[10:21:34.802]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.802]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.802]         }
[10:21:34.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.802]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.802]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.802]             base::names(...future.oldOptions))
[10:21:34.802]     }
[10:21:34.802]     if (FALSE) {
[10:21:34.802]     }
[10:21:34.802]     else {
[10:21:34.802]         if (TRUE) {
[10:21:34.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.802]                 open = "w")
[10:21:34.802]         }
[10:21:34.802]         else {
[10:21:34.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.802]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.802]         }
[10:21:34.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.802]             base::sink(type = "output", split = FALSE)
[10:21:34.802]             base::close(...future.stdout)
[10:21:34.802]         }, add = TRUE)
[10:21:34.802]     }
[10:21:34.802]     ...future.frame <- base::sys.nframe()
[10:21:34.802]     ...future.conditions <- base::list()
[10:21:34.802]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.802]     if (FALSE) {
[10:21:34.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.802]     }
[10:21:34.802]     ...future.result <- base::tryCatch({
[10:21:34.802]         base::withCallingHandlers({
[10:21:34.802]             ...future.value <- base::withVisible(base::local({
[10:21:34.802]                 ...future.makeSendCondition <- base::local({
[10:21:34.802]                   sendCondition <- NULL
[10:21:34.802]                   function(frame = 1L) {
[10:21:34.802]                     if (is.function(sendCondition)) 
[10:21:34.802]                       return(sendCondition)
[10:21:34.802]                     ns <- getNamespace("parallel")
[10:21:34.802]                     if (exists("sendData", mode = "function", 
[10:21:34.802]                       envir = ns)) {
[10:21:34.802]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:34.802]                         envir = ns)
[10:21:34.802]                       envir <- sys.frame(frame)
[10:21:34.802]                       master <- NULL
[10:21:34.802]                       while (!identical(envir, .GlobalEnv) && 
[10:21:34.802]                         !identical(envir, emptyenv())) {
[10:21:34.802]                         if (exists("master", mode = "list", envir = envir, 
[10:21:34.802]                           inherits = FALSE)) {
[10:21:34.802]                           master <- get("master", mode = "list", 
[10:21:34.802]                             envir = envir, inherits = FALSE)
[10:21:34.802]                           if (inherits(master, c("SOCKnode", 
[10:21:34.802]                             "SOCK0node"))) {
[10:21:34.802]                             sendCondition <<- function(cond) {
[10:21:34.802]                               data <- list(type = "VALUE", value = cond, 
[10:21:34.802]                                 success = TRUE)
[10:21:34.802]                               parallel_sendData(master, data)
[10:21:34.802]                             }
[10:21:34.802]                             return(sendCondition)
[10:21:34.802]                           }
[10:21:34.802]                         }
[10:21:34.802]                         frame <- frame + 1L
[10:21:34.802]                         envir <- sys.frame(frame)
[10:21:34.802]                       }
[10:21:34.802]                     }
[10:21:34.802]                     sendCondition <<- function(cond) NULL
[10:21:34.802]                   }
[10:21:34.802]                 })
[10:21:34.802]                 withCallingHandlers({
[10:21:34.802]                   NA
[10:21:34.802]                 }, immediateCondition = function(cond) {
[10:21:34.802]                   sendCondition <- ...future.makeSendCondition()
[10:21:34.802]                   sendCondition(cond)
[10:21:34.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.802]                   {
[10:21:34.802]                     inherits <- base::inherits
[10:21:34.802]                     invokeRestart <- base::invokeRestart
[10:21:34.802]                     is.null <- base::is.null
[10:21:34.802]                     muffled <- FALSE
[10:21:34.802]                     if (inherits(cond, "message")) {
[10:21:34.802]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:34.802]                       if (muffled) 
[10:21:34.802]                         invokeRestart("muffleMessage")
[10:21:34.802]                     }
[10:21:34.802]                     else if (inherits(cond, "warning")) {
[10:21:34.802]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:34.802]                       if (muffled) 
[10:21:34.802]                         invokeRestart("muffleWarning")
[10:21:34.802]                     }
[10:21:34.802]                     else if (inherits(cond, "condition")) {
[10:21:34.802]                       if (!is.null(pattern)) {
[10:21:34.802]                         computeRestarts <- base::computeRestarts
[10:21:34.802]                         grepl <- base::grepl
[10:21:34.802]                         restarts <- computeRestarts(cond)
[10:21:34.802]                         for (restart in restarts) {
[10:21:34.802]                           name <- restart$name
[10:21:34.802]                           if (is.null(name)) 
[10:21:34.802]                             next
[10:21:34.802]                           if (!grepl(pattern, name)) 
[10:21:34.802]                             next
[10:21:34.802]                           invokeRestart(restart)
[10:21:34.802]                           muffled <- TRUE
[10:21:34.802]                           break
[10:21:34.802]                         }
[10:21:34.802]                       }
[10:21:34.802]                     }
[10:21:34.802]                     invisible(muffled)
[10:21:34.802]                   }
[10:21:34.802]                   muffleCondition(cond)
[10:21:34.802]                 })
[10:21:34.802]             }))
[10:21:34.802]             future::FutureResult(value = ...future.value$value, 
[10:21:34.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.802]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.802]                     ...future.globalenv.names))
[10:21:34.802]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.802]         }, condition = base::local({
[10:21:34.802]             c <- base::c
[10:21:34.802]             inherits <- base::inherits
[10:21:34.802]             invokeRestart <- base::invokeRestart
[10:21:34.802]             length <- base::length
[10:21:34.802]             list <- base::list
[10:21:34.802]             seq.int <- base::seq.int
[10:21:34.802]             signalCondition <- base::signalCondition
[10:21:34.802]             sys.calls <- base::sys.calls
[10:21:34.802]             `[[` <- base::`[[`
[10:21:34.802]             `+` <- base::`+`
[10:21:34.802]             `<<-` <- base::`<<-`
[10:21:34.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.802]                   3L)]
[10:21:34.802]             }
[10:21:34.802]             function(cond) {
[10:21:34.802]                 is_error <- inherits(cond, "error")
[10:21:34.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.802]                   NULL)
[10:21:34.802]                 if (is_error) {
[10:21:34.802]                   sessionInformation <- function() {
[10:21:34.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.802]                       search = base::search(), system = base::Sys.info())
[10:21:34.802]                   }
[10:21:34.802]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.802]                     cond$call), session = sessionInformation(), 
[10:21:34.802]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.802]                   signalCondition(cond)
[10:21:34.802]                 }
[10:21:34.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.802]                 "immediateCondition"))) {
[10:21:34.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.802]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.802]                   if (TRUE && !signal) {
[10:21:34.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.802]                     {
[10:21:34.802]                       inherits <- base::inherits
[10:21:34.802]                       invokeRestart <- base::invokeRestart
[10:21:34.802]                       is.null <- base::is.null
[10:21:34.802]                       muffled <- FALSE
[10:21:34.802]                       if (inherits(cond, "message")) {
[10:21:34.802]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.802]                         if (muffled) 
[10:21:34.802]                           invokeRestart("muffleMessage")
[10:21:34.802]                       }
[10:21:34.802]                       else if (inherits(cond, "warning")) {
[10:21:34.802]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.802]                         if (muffled) 
[10:21:34.802]                           invokeRestart("muffleWarning")
[10:21:34.802]                       }
[10:21:34.802]                       else if (inherits(cond, "condition")) {
[10:21:34.802]                         if (!is.null(pattern)) {
[10:21:34.802]                           computeRestarts <- base::computeRestarts
[10:21:34.802]                           grepl <- base::grepl
[10:21:34.802]                           restarts <- computeRestarts(cond)
[10:21:34.802]                           for (restart in restarts) {
[10:21:34.802]                             name <- restart$name
[10:21:34.802]                             if (is.null(name)) 
[10:21:34.802]                               next
[10:21:34.802]                             if (!grepl(pattern, name)) 
[10:21:34.802]                               next
[10:21:34.802]                             invokeRestart(restart)
[10:21:34.802]                             muffled <- TRUE
[10:21:34.802]                             break
[10:21:34.802]                           }
[10:21:34.802]                         }
[10:21:34.802]                       }
[10:21:34.802]                       invisible(muffled)
[10:21:34.802]                     }
[10:21:34.802]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.802]                   }
[10:21:34.802]                 }
[10:21:34.802]                 else {
[10:21:34.802]                   if (TRUE) {
[10:21:34.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.802]                     {
[10:21:34.802]                       inherits <- base::inherits
[10:21:34.802]                       invokeRestart <- base::invokeRestart
[10:21:34.802]                       is.null <- base::is.null
[10:21:34.802]                       muffled <- FALSE
[10:21:34.802]                       if (inherits(cond, "message")) {
[10:21:34.802]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.802]                         if (muffled) 
[10:21:34.802]                           invokeRestart("muffleMessage")
[10:21:34.802]                       }
[10:21:34.802]                       else if (inherits(cond, "warning")) {
[10:21:34.802]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.802]                         if (muffled) 
[10:21:34.802]                           invokeRestart("muffleWarning")
[10:21:34.802]                       }
[10:21:34.802]                       else if (inherits(cond, "condition")) {
[10:21:34.802]                         if (!is.null(pattern)) {
[10:21:34.802]                           computeRestarts <- base::computeRestarts
[10:21:34.802]                           grepl <- base::grepl
[10:21:34.802]                           restarts <- computeRestarts(cond)
[10:21:34.802]                           for (restart in restarts) {
[10:21:34.802]                             name <- restart$name
[10:21:34.802]                             if (is.null(name)) 
[10:21:34.802]                               next
[10:21:34.802]                             if (!grepl(pattern, name)) 
[10:21:34.802]                               next
[10:21:34.802]                             invokeRestart(restart)
[10:21:34.802]                             muffled <- TRUE
[10:21:34.802]                             break
[10:21:34.802]                           }
[10:21:34.802]                         }
[10:21:34.802]                       }
[10:21:34.802]                       invisible(muffled)
[10:21:34.802]                     }
[10:21:34.802]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.802]                   }
[10:21:34.802]                 }
[10:21:34.802]             }
[10:21:34.802]         }))
[10:21:34.802]     }, error = function(ex) {
[10:21:34.802]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.802]                 ...future.rng), started = ...future.startTime, 
[10:21:34.802]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.802]             version = "1.8"), class = "FutureResult")
[10:21:34.802]     }, finally = {
[10:21:34.802]         if (!identical(...future.workdir, getwd())) 
[10:21:34.802]             setwd(...future.workdir)
[10:21:34.802]         {
[10:21:34.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.802]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.802]             }
[10:21:34.802]             base::options(...future.oldOptions)
[10:21:34.802]             if (.Platform$OS.type == "windows") {
[10:21:34.802]                 old_names <- names(...future.oldEnvVars)
[10:21:34.802]                 envs <- base::Sys.getenv()
[10:21:34.802]                 names <- names(envs)
[10:21:34.802]                 common <- intersect(names, old_names)
[10:21:34.802]                 added <- setdiff(names, old_names)
[10:21:34.802]                 removed <- setdiff(old_names, names)
[10:21:34.802]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.802]                   envs[common]]
[10:21:34.802]                 NAMES <- toupper(changed)
[10:21:34.802]                 args <- list()
[10:21:34.802]                 for (kk in seq_along(NAMES)) {
[10:21:34.802]                   name <- changed[[kk]]
[10:21:34.802]                   NAME <- NAMES[[kk]]
[10:21:34.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.802]                     next
[10:21:34.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.802]                 }
[10:21:34.802]                 NAMES <- toupper(added)
[10:21:34.802]                 for (kk in seq_along(NAMES)) {
[10:21:34.802]                   name <- added[[kk]]
[10:21:34.802]                   NAME <- NAMES[[kk]]
[10:21:34.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.802]                     next
[10:21:34.802]                   args[[name]] <- ""
[10:21:34.802]                 }
[10:21:34.802]                 NAMES <- toupper(removed)
[10:21:34.802]                 for (kk in seq_along(NAMES)) {
[10:21:34.802]                   name <- removed[[kk]]
[10:21:34.802]                   NAME <- NAMES[[kk]]
[10:21:34.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.802]                     next
[10:21:34.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.802]                 }
[10:21:34.802]                 if (length(args) > 0) 
[10:21:34.802]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.802]             }
[10:21:34.802]             else {
[10:21:34.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.802]             }
[10:21:34.802]             {
[10:21:34.802]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.802]                   0L) {
[10:21:34.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.802]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.802]                   base::options(opts)
[10:21:34.802]                 }
[10:21:34.802]                 {
[10:21:34.802]                   {
[10:21:34.802]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:34.802]                     NULL
[10:21:34.802]                   }
[10:21:34.802]                   options(future.plan = NULL)
[10:21:34.802]                   if (is.na(NA_character_)) 
[10:21:34.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.802]                     .init = FALSE)
[10:21:34.802]                 }
[10:21:34.802]             }
[10:21:34.802]         }
[10:21:34.802]     })
[10:21:34.802]     if (TRUE) {
[10:21:34.802]         base::sink(type = "output", split = FALSE)
[10:21:34.802]         if (TRUE) {
[10:21:34.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.802]         }
[10:21:34.802]         else {
[10:21:34.802]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.802]         }
[10:21:34.802]         base::close(...future.stdout)
[10:21:34.802]         ...future.stdout <- NULL
[10:21:34.802]     }
[10:21:34.802]     ...future.result$conditions <- ...future.conditions
[10:21:34.802]     ...future.result$finished <- base::Sys.time()
[10:21:34.802]     ...future.result
[10:21:34.802] }
[10:21:34.854] MultisessionFuture started
[10:21:34.855] result() for ClusterFuture ...
[10:21:34.855] receiveMessageFromWorker() for ClusterFuture ...
[10:21:34.855] - Validating connection of MultisessionFuture
[10:21:34.885] - received message: FutureResult
[10:21:34.886] - Received FutureResult
[10:21:34.886] - Erased future from FutureRegistry
[10:21:34.886] result() for ClusterFuture ...
[10:21:34.886] - result already collected: FutureResult
[10:21:34.886] result() for ClusterFuture ... done
[10:21:34.886] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:34.886] result() for ClusterFuture ... done
[10:21:34.886] result() for ClusterFuture ...
[10:21:34.886] - result already collected: FutureResult
[10:21:34.887] result() for ClusterFuture ... done
[10:21:34.887] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:34.888] plan(): nbrOfWorkers() = 2
[10:21:34.889] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:34.889] Searching for globals...
[10:21:34.889] - globals found: [1] ‘getOption’
[10:21:34.889] Searching for globals ... DONE
[10:21:34.889] Resolving globals: FALSE
[10:21:34.890] 
[10:21:34.890] 
[10:21:34.890] getGlobalsAndPackages() ... DONE
[10:21:34.890] run() for ‘Future’ ...
[10:21:34.890] - state: ‘created’
[10:21:34.890] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:34.904] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:34.904] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:34.905]   - Field: ‘node’
[10:21:34.905]   - Field: ‘label’
[10:21:34.905]   - Field: ‘local’
[10:21:34.905]   - Field: ‘owner’
[10:21:34.905]   - Field: ‘envir’
[10:21:34.905]   - Field: ‘workers’
[10:21:34.905]   - Field: ‘packages’
[10:21:34.905]   - Field: ‘gc’
[10:21:34.905]   - Field: ‘conditions’
[10:21:34.905]   - Field: ‘persistent’
[10:21:34.905]   - Field: ‘expr’
[10:21:34.905]   - Field: ‘uuid’
[10:21:34.906]   - Field: ‘seed’
[10:21:34.906]   - Field: ‘version’
[10:21:34.906]   - Field: ‘result’
[10:21:34.906]   - Field: ‘asynchronous’
[10:21:34.906]   - Field: ‘calls’
[10:21:34.906]   - Field: ‘globals’
[10:21:34.906]   - Field: ‘stdout’
[10:21:34.906]   - Field: ‘earlySignal’
[10:21:34.906]   - Field: ‘lazy’
[10:21:34.906]   - Field: ‘state’
[10:21:34.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:34.906] - Launch lazy future ...
[10:21:34.907] Packages needed by the future expression (n = 0): <none>
[10:21:34.907] Packages needed by future strategies (n = 0): <none>
[10:21:34.907] {
[10:21:34.907]     {
[10:21:34.907]         {
[10:21:34.907]             ...future.startTime <- base::Sys.time()
[10:21:34.907]             {
[10:21:34.907]                 {
[10:21:34.907]                   {
[10:21:34.907]                     {
[10:21:34.907]                       base::local({
[10:21:34.907]                         has_future <- base::requireNamespace("future", 
[10:21:34.907]                           quietly = TRUE)
[10:21:34.907]                         if (has_future) {
[10:21:34.907]                           ns <- base::getNamespace("future")
[10:21:34.907]                           version <- ns[[".package"]][["version"]]
[10:21:34.907]                           if (is.null(version)) 
[10:21:34.907]                             version <- utils::packageVersion("future")
[10:21:34.907]                         }
[10:21:34.907]                         else {
[10:21:34.907]                           version <- NULL
[10:21:34.907]                         }
[10:21:34.907]                         if (!has_future || version < "1.8.0") {
[10:21:34.907]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.907]                             "", base::R.version$version.string), 
[10:21:34.907]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.907]                               "release", "version")], collapse = " "), 
[10:21:34.907]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.907]                             info)
[10:21:34.907]                           info <- base::paste(info, collapse = "; ")
[10:21:34.907]                           if (!has_future) {
[10:21:34.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.907]                               info)
[10:21:34.907]                           }
[10:21:34.907]                           else {
[10:21:34.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.907]                               info, version)
[10:21:34.907]                           }
[10:21:34.907]                           base::stop(msg)
[10:21:34.907]                         }
[10:21:34.907]                       })
[10:21:34.907]                     }
[10:21:34.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:34.907]                     base::options(mc.cores = 1L)
[10:21:34.907]                   }
[10:21:34.907]                   ...future.strategy.old <- future::plan("list")
[10:21:34.907]                   options(future.plan = NULL)
[10:21:34.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.907]                 }
[10:21:34.907]                 ...future.workdir <- getwd()
[10:21:34.907]             }
[10:21:34.907]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.907]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.907]         }
[10:21:34.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:34.907]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.907]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:34.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.907]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.907]             base::names(...future.oldOptions))
[10:21:34.907]     }
[10:21:34.907]     if (FALSE) {
[10:21:34.907]     }
[10:21:34.907]     else {
[10:21:34.907]         if (TRUE) {
[10:21:34.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.907]                 open = "w")
[10:21:34.907]         }
[10:21:34.907]         else {
[10:21:34.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.907]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.907]         }
[10:21:34.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.907]             base::sink(type = "output", split = FALSE)
[10:21:34.907]             base::close(...future.stdout)
[10:21:34.907]         }, add = TRUE)
[10:21:34.907]     }
[10:21:34.907]     ...future.frame <- base::sys.nframe()
[10:21:34.907]     ...future.conditions <- base::list()
[10:21:34.907]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.907]     if (FALSE) {
[10:21:34.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.907]     }
[10:21:34.907]     ...future.result <- base::tryCatch({
[10:21:34.907]         base::withCallingHandlers({
[10:21:34.907]             ...future.value <- base::withVisible(base::local({
[10:21:34.907]                 ...future.makeSendCondition <- base::local({
[10:21:34.907]                   sendCondition <- NULL
[10:21:34.907]                   function(frame = 1L) {
[10:21:34.907]                     if (is.function(sendCondition)) 
[10:21:34.907]                       return(sendCondition)
[10:21:34.907]                     ns <- getNamespace("parallel")
[10:21:34.907]                     if (exists("sendData", mode = "function", 
[10:21:34.907]                       envir = ns)) {
[10:21:34.907]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:34.907]                         envir = ns)
[10:21:34.907]                       envir <- sys.frame(frame)
[10:21:34.907]                       master <- NULL
[10:21:34.907]                       while (!identical(envir, .GlobalEnv) && 
[10:21:34.907]                         !identical(envir, emptyenv())) {
[10:21:34.907]                         if (exists("master", mode = "list", envir = envir, 
[10:21:34.907]                           inherits = FALSE)) {
[10:21:34.907]                           master <- get("master", mode = "list", 
[10:21:34.907]                             envir = envir, inherits = FALSE)
[10:21:34.907]                           if (inherits(master, c("SOCKnode", 
[10:21:34.907]                             "SOCK0node"))) {
[10:21:34.907]                             sendCondition <<- function(cond) {
[10:21:34.907]                               data <- list(type = "VALUE", value = cond, 
[10:21:34.907]                                 success = TRUE)
[10:21:34.907]                               parallel_sendData(master, data)
[10:21:34.907]                             }
[10:21:34.907]                             return(sendCondition)
[10:21:34.907]                           }
[10:21:34.907]                         }
[10:21:34.907]                         frame <- frame + 1L
[10:21:34.907]                         envir <- sys.frame(frame)
[10:21:34.907]                       }
[10:21:34.907]                     }
[10:21:34.907]                     sendCondition <<- function(cond) NULL
[10:21:34.907]                   }
[10:21:34.907]                 })
[10:21:34.907]                 withCallingHandlers({
[10:21:34.907]                   getOption("future.globals.onMissing")
[10:21:34.907]                 }, immediateCondition = function(cond) {
[10:21:34.907]                   sendCondition <- ...future.makeSendCondition()
[10:21:34.907]                   sendCondition(cond)
[10:21:34.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.907]                   {
[10:21:34.907]                     inherits <- base::inherits
[10:21:34.907]                     invokeRestart <- base::invokeRestart
[10:21:34.907]                     is.null <- base::is.null
[10:21:34.907]                     muffled <- FALSE
[10:21:34.907]                     if (inherits(cond, "message")) {
[10:21:34.907]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:34.907]                       if (muffled) 
[10:21:34.907]                         invokeRestart("muffleMessage")
[10:21:34.907]                     }
[10:21:34.907]                     else if (inherits(cond, "warning")) {
[10:21:34.907]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:34.907]                       if (muffled) 
[10:21:34.907]                         invokeRestart("muffleWarning")
[10:21:34.907]                     }
[10:21:34.907]                     else if (inherits(cond, "condition")) {
[10:21:34.907]                       if (!is.null(pattern)) {
[10:21:34.907]                         computeRestarts <- base::computeRestarts
[10:21:34.907]                         grepl <- base::grepl
[10:21:34.907]                         restarts <- computeRestarts(cond)
[10:21:34.907]                         for (restart in restarts) {
[10:21:34.907]                           name <- restart$name
[10:21:34.907]                           if (is.null(name)) 
[10:21:34.907]                             next
[10:21:34.907]                           if (!grepl(pattern, name)) 
[10:21:34.907]                             next
[10:21:34.907]                           invokeRestart(restart)
[10:21:34.907]                           muffled <- TRUE
[10:21:34.907]                           break
[10:21:34.907]                         }
[10:21:34.907]                       }
[10:21:34.907]                     }
[10:21:34.907]                     invisible(muffled)
[10:21:34.907]                   }
[10:21:34.907]                   muffleCondition(cond)
[10:21:34.907]                 })
[10:21:34.907]             }))
[10:21:34.907]             future::FutureResult(value = ...future.value$value, 
[10:21:34.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.907]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.907]                     ...future.globalenv.names))
[10:21:34.907]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.907]         }, condition = base::local({
[10:21:34.907]             c <- base::c
[10:21:34.907]             inherits <- base::inherits
[10:21:34.907]             invokeRestart <- base::invokeRestart
[10:21:34.907]             length <- base::length
[10:21:34.907]             list <- base::list
[10:21:34.907]             seq.int <- base::seq.int
[10:21:34.907]             signalCondition <- base::signalCondition
[10:21:34.907]             sys.calls <- base::sys.calls
[10:21:34.907]             `[[` <- base::`[[`
[10:21:34.907]             `+` <- base::`+`
[10:21:34.907]             `<<-` <- base::`<<-`
[10:21:34.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.907]                   3L)]
[10:21:34.907]             }
[10:21:34.907]             function(cond) {
[10:21:34.907]                 is_error <- inherits(cond, "error")
[10:21:34.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.907]                   NULL)
[10:21:34.907]                 if (is_error) {
[10:21:34.907]                   sessionInformation <- function() {
[10:21:34.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.907]                       search = base::search(), system = base::Sys.info())
[10:21:34.907]                   }
[10:21:34.907]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.907]                     cond$call), session = sessionInformation(), 
[10:21:34.907]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.907]                   signalCondition(cond)
[10:21:34.907]                 }
[10:21:34.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.907]                 "immediateCondition"))) {
[10:21:34.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.907]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.907]                   if (TRUE && !signal) {
[10:21:34.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.907]                     {
[10:21:34.907]                       inherits <- base::inherits
[10:21:34.907]                       invokeRestart <- base::invokeRestart
[10:21:34.907]                       is.null <- base::is.null
[10:21:34.907]                       muffled <- FALSE
[10:21:34.907]                       if (inherits(cond, "message")) {
[10:21:34.907]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.907]                         if (muffled) 
[10:21:34.907]                           invokeRestart("muffleMessage")
[10:21:34.907]                       }
[10:21:34.907]                       else if (inherits(cond, "warning")) {
[10:21:34.907]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.907]                         if (muffled) 
[10:21:34.907]                           invokeRestart("muffleWarning")
[10:21:34.907]                       }
[10:21:34.907]                       else if (inherits(cond, "condition")) {
[10:21:34.907]                         if (!is.null(pattern)) {
[10:21:34.907]                           computeRestarts <- base::computeRestarts
[10:21:34.907]                           grepl <- base::grepl
[10:21:34.907]                           restarts <- computeRestarts(cond)
[10:21:34.907]                           for (restart in restarts) {
[10:21:34.907]                             name <- restart$name
[10:21:34.907]                             if (is.null(name)) 
[10:21:34.907]                               next
[10:21:34.907]                             if (!grepl(pattern, name)) 
[10:21:34.907]                               next
[10:21:34.907]                             invokeRestart(restart)
[10:21:34.907]                             muffled <- TRUE
[10:21:34.907]                             break
[10:21:34.907]                           }
[10:21:34.907]                         }
[10:21:34.907]                       }
[10:21:34.907]                       invisible(muffled)
[10:21:34.907]                     }
[10:21:34.907]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.907]                   }
[10:21:34.907]                 }
[10:21:34.907]                 else {
[10:21:34.907]                   if (TRUE) {
[10:21:34.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.907]                     {
[10:21:34.907]                       inherits <- base::inherits
[10:21:34.907]                       invokeRestart <- base::invokeRestart
[10:21:34.907]                       is.null <- base::is.null
[10:21:34.907]                       muffled <- FALSE
[10:21:34.907]                       if (inherits(cond, "message")) {
[10:21:34.907]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.907]                         if (muffled) 
[10:21:34.907]                           invokeRestart("muffleMessage")
[10:21:34.907]                       }
[10:21:34.907]                       else if (inherits(cond, "warning")) {
[10:21:34.907]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.907]                         if (muffled) 
[10:21:34.907]                           invokeRestart("muffleWarning")
[10:21:34.907]                       }
[10:21:34.907]                       else if (inherits(cond, "condition")) {
[10:21:34.907]                         if (!is.null(pattern)) {
[10:21:34.907]                           computeRestarts <- base::computeRestarts
[10:21:34.907]                           grepl <- base::grepl
[10:21:34.907]                           restarts <- computeRestarts(cond)
[10:21:34.907]                           for (restart in restarts) {
[10:21:34.907]                             name <- restart$name
[10:21:34.907]                             if (is.null(name)) 
[10:21:34.907]                               next
[10:21:34.907]                             if (!grepl(pattern, name)) 
[10:21:34.907]                               next
[10:21:34.907]                             invokeRestart(restart)
[10:21:34.907]                             muffled <- TRUE
[10:21:34.907]                             break
[10:21:34.907]                           }
[10:21:34.907]                         }
[10:21:34.907]                       }
[10:21:34.907]                       invisible(muffled)
[10:21:34.907]                     }
[10:21:34.907]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.907]                   }
[10:21:34.907]                 }
[10:21:34.907]             }
[10:21:34.907]         }))
[10:21:34.907]     }, error = function(ex) {
[10:21:34.907]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.907]                 ...future.rng), started = ...future.startTime, 
[10:21:34.907]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.907]             version = "1.8"), class = "FutureResult")
[10:21:34.907]     }, finally = {
[10:21:34.907]         if (!identical(...future.workdir, getwd())) 
[10:21:34.907]             setwd(...future.workdir)
[10:21:34.907]         {
[10:21:34.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.907]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.907]             }
[10:21:34.907]             base::options(...future.oldOptions)
[10:21:34.907]             if (.Platform$OS.type == "windows") {
[10:21:34.907]                 old_names <- names(...future.oldEnvVars)
[10:21:34.907]                 envs <- base::Sys.getenv()
[10:21:34.907]                 names <- names(envs)
[10:21:34.907]                 common <- intersect(names, old_names)
[10:21:34.907]                 added <- setdiff(names, old_names)
[10:21:34.907]                 removed <- setdiff(old_names, names)
[10:21:34.907]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.907]                   envs[common]]
[10:21:34.907]                 NAMES <- toupper(changed)
[10:21:34.907]                 args <- list()
[10:21:34.907]                 for (kk in seq_along(NAMES)) {
[10:21:34.907]                   name <- changed[[kk]]
[10:21:34.907]                   NAME <- NAMES[[kk]]
[10:21:34.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.907]                     next
[10:21:34.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.907]                 }
[10:21:34.907]                 NAMES <- toupper(added)
[10:21:34.907]                 for (kk in seq_along(NAMES)) {
[10:21:34.907]                   name <- added[[kk]]
[10:21:34.907]                   NAME <- NAMES[[kk]]
[10:21:34.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.907]                     next
[10:21:34.907]                   args[[name]] <- ""
[10:21:34.907]                 }
[10:21:34.907]                 NAMES <- toupper(removed)
[10:21:34.907]                 for (kk in seq_along(NAMES)) {
[10:21:34.907]                   name <- removed[[kk]]
[10:21:34.907]                   NAME <- NAMES[[kk]]
[10:21:34.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.907]                     next
[10:21:34.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.907]                 }
[10:21:34.907]                 if (length(args) > 0) 
[10:21:34.907]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.907]             }
[10:21:34.907]             else {
[10:21:34.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.907]             }
[10:21:34.907]             {
[10:21:34.907]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.907]                   0L) {
[10:21:34.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.907]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.907]                   base::options(opts)
[10:21:34.907]                 }
[10:21:34.907]                 {
[10:21:34.907]                   {
[10:21:34.907]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:34.907]                     NULL
[10:21:34.907]                   }
[10:21:34.907]                   options(future.plan = NULL)
[10:21:34.907]                   if (is.na(NA_character_)) 
[10:21:34.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.907]                     .init = FALSE)
[10:21:34.907]                 }
[10:21:34.907]             }
[10:21:34.907]         }
[10:21:34.907]     })
[10:21:34.907]     if (TRUE) {
[10:21:34.907]         base::sink(type = "output", split = FALSE)
[10:21:34.907]         if (TRUE) {
[10:21:34.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.907]         }
[10:21:34.907]         else {
[10:21:34.907]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.907]         }
[10:21:34.907]         base::close(...future.stdout)
[10:21:34.907]         ...future.stdout <- NULL
[10:21:34.907]     }
[10:21:34.907]     ...future.result$conditions <- ...future.conditions
[10:21:34.907]     ...future.result$finished <- base::Sys.time()
[10:21:34.907]     ...future.result
[10:21:34.907] }
[10:21:34.910] MultisessionFuture started
[10:21:34.910] - Launch lazy future ... done
[10:21:34.910] run() for ‘MultisessionFuture’ ... done
[10:21:34.911] result() for ClusterFuture ...
[10:21:34.911] receiveMessageFromWorker() for ClusterFuture ...
[10:21:34.911] - Validating connection of MultisessionFuture
[10:21:34.952] - received message: FutureResult
[10:21:34.952] - Received FutureResult
[10:21:34.952] - Erased future from FutureRegistry
[10:21:34.952] result() for ClusterFuture ...
[10:21:34.953] - result already collected: FutureResult
[10:21:34.953] result() for ClusterFuture ... done
[10:21:34.953] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:34.953] result() for ClusterFuture ... done
[10:21:34.953] result() for ClusterFuture ...
[10:21:34.953] - result already collected: FutureResult
[10:21:34.953] result() for ClusterFuture ... done
[10:21:34.954] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:34.954] Searching for globals...
[10:21:34.954] - globals found: [1] ‘getOption’
[10:21:34.954] Searching for globals ... DONE
[10:21:34.955] Resolving globals: FALSE
[10:21:34.955] 
[10:21:34.955] 
[10:21:34.955] getGlobalsAndPackages() ... DONE
[10:21:34.955] run() for ‘Future’ ...
[10:21:34.955] - state: ‘created’
[10:21:34.955] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:34.970] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:34.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:34.970]   - Field: ‘node’
[10:21:34.970]   - Field: ‘label’
[10:21:34.970]   - Field: ‘local’
[10:21:34.970]   - Field: ‘owner’
[10:21:34.971]   - Field: ‘envir’
[10:21:34.971]   - Field: ‘workers’
[10:21:34.971]   - Field: ‘packages’
[10:21:34.971]   - Field: ‘gc’
[10:21:34.971]   - Field: ‘conditions’
[10:21:34.971]   - Field: ‘persistent’
[10:21:34.971]   - Field: ‘expr’
[10:21:34.971]   - Field: ‘uuid’
[10:21:34.971]   - Field: ‘seed’
[10:21:34.971]   - Field: ‘version’
[10:21:34.971]   - Field: ‘result’
[10:21:34.972]   - Field: ‘asynchronous’
[10:21:34.972]   - Field: ‘calls’
[10:21:34.972]   - Field: ‘globals’
[10:21:34.972]   - Field: ‘stdout’
[10:21:34.972]   - Field: ‘earlySignal’
[10:21:34.972]   - Field: ‘lazy’
[10:21:34.972]   - Field: ‘state’
[10:21:34.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:34.972] - Launch lazy future ...
[10:21:34.972] Packages needed by the future expression (n = 0): <none>
[10:21:34.973] Packages needed by future strategies (n = 0): <none>
[10:21:34.973] {
[10:21:34.973]     {
[10:21:34.973]         {
[10:21:34.973]             ...future.startTime <- base::Sys.time()
[10:21:34.973]             {
[10:21:34.973]                 {
[10:21:34.973]                   {
[10:21:34.973]                     {
[10:21:34.973]                       base::local({
[10:21:34.973]                         has_future <- base::requireNamespace("future", 
[10:21:34.973]                           quietly = TRUE)
[10:21:34.973]                         if (has_future) {
[10:21:34.973]                           ns <- base::getNamespace("future")
[10:21:34.973]                           version <- ns[[".package"]][["version"]]
[10:21:34.973]                           if (is.null(version)) 
[10:21:34.973]                             version <- utils::packageVersion("future")
[10:21:34.973]                         }
[10:21:34.973]                         else {
[10:21:34.973]                           version <- NULL
[10:21:34.973]                         }
[10:21:34.973]                         if (!has_future || version < "1.8.0") {
[10:21:34.973]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:34.973]                             "", base::R.version$version.string), 
[10:21:34.973]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:34.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:34.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:34.973]                               "release", "version")], collapse = " "), 
[10:21:34.973]                             hostname = base::Sys.info()[["nodename"]])
[10:21:34.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:34.973]                             info)
[10:21:34.973]                           info <- base::paste(info, collapse = "; ")
[10:21:34.973]                           if (!has_future) {
[10:21:34.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:34.973]                               info)
[10:21:34.973]                           }
[10:21:34.973]                           else {
[10:21:34.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:34.973]                               info, version)
[10:21:34.973]                           }
[10:21:34.973]                           base::stop(msg)
[10:21:34.973]                         }
[10:21:34.973]                       })
[10:21:34.973]                     }
[10:21:34.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:34.973]                     base::options(mc.cores = 1L)
[10:21:34.973]                   }
[10:21:34.973]                   ...future.strategy.old <- future::plan("list")
[10:21:34.973]                   options(future.plan = NULL)
[10:21:34.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:34.973]                 }
[10:21:34.973]                 ...future.workdir <- getwd()
[10:21:34.973]             }
[10:21:34.973]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:34.973]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:34.973]         }
[10:21:34.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:34.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:34.973]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:34.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:34.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:34.973]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:34.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:34.973]             base::names(...future.oldOptions))
[10:21:34.973]     }
[10:21:34.973]     if (FALSE) {
[10:21:34.973]     }
[10:21:34.973]     else {
[10:21:34.973]         if (TRUE) {
[10:21:34.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:34.973]                 open = "w")
[10:21:34.973]         }
[10:21:34.973]         else {
[10:21:34.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:34.973]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:34.973]         }
[10:21:34.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:34.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:34.973]             base::sink(type = "output", split = FALSE)
[10:21:34.973]             base::close(...future.stdout)
[10:21:34.973]         }, add = TRUE)
[10:21:34.973]     }
[10:21:34.973]     ...future.frame <- base::sys.nframe()
[10:21:34.973]     ...future.conditions <- base::list()
[10:21:34.973]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:34.973]     if (FALSE) {
[10:21:34.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:34.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:34.973]     }
[10:21:34.973]     ...future.result <- base::tryCatch({
[10:21:34.973]         base::withCallingHandlers({
[10:21:34.973]             ...future.value <- base::withVisible(base::local({
[10:21:34.973]                 ...future.makeSendCondition <- base::local({
[10:21:34.973]                   sendCondition <- NULL
[10:21:34.973]                   function(frame = 1L) {
[10:21:34.973]                     if (is.function(sendCondition)) 
[10:21:34.973]                       return(sendCondition)
[10:21:34.973]                     ns <- getNamespace("parallel")
[10:21:34.973]                     if (exists("sendData", mode = "function", 
[10:21:34.973]                       envir = ns)) {
[10:21:34.973]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:34.973]                         envir = ns)
[10:21:34.973]                       envir <- sys.frame(frame)
[10:21:34.973]                       master <- NULL
[10:21:34.973]                       while (!identical(envir, .GlobalEnv) && 
[10:21:34.973]                         !identical(envir, emptyenv())) {
[10:21:34.973]                         if (exists("master", mode = "list", envir = envir, 
[10:21:34.973]                           inherits = FALSE)) {
[10:21:34.973]                           master <- get("master", mode = "list", 
[10:21:34.973]                             envir = envir, inherits = FALSE)
[10:21:34.973]                           if (inherits(master, c("SOCKnode", 
[10:21:34.973]                             "SOCK0node"))) {
[10:21:34.973]                             sendCondition <<- function(cond) {
[10:21:34.973]                               data <- list(type = "VALUE", value = cond, 
[10:21:34.973]                                 success = TRUE)
[10:21:34.973]                               parallel_sendData(master, data)
[10:21:34.973]                             }
[10:21:34.973]                             return(sendCondition)
[10:21:34.973]                           }
[10:21:34.973]                         }
[10:21:34.973]                         frame <- frame + 1L
[10:21:34.973]                         envir <- sys.frame(frame)
[10:21:34.973]                       }
[10:21:34.973]                     }
[10:21:34.973]                     sendCondition <<- function(cond) NULL
[10:21:34.973]                   }
[10:21:34.973]                 })
[10:21:34.973]                 withCallingHandlers({
[10:21:34.973]                   getOption("future.globals.onMissing")
[10:21:34.973]                 }, immediateCondition = function(cond) {
[10:21:34.973]                   sendCondition <- ...future.makeSendCondition()
[10:21:34.973]                   sendCondition(cond)
[10:21:34.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.973]                   {
[10:21:34.973]                     inherits <- base::inherits
[10:21:34.973]                     invokeRestart <- base::invokeRestart
[10:21:34.973]                     is.null <- base::is.null
[10:21:34.973]                     muffled <- FALSE
[10:21:34.973]                     if (inherits(cond, "message")) {
[10:21:34.973]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:34.973]                       if (muffled) 
[10:21:34.973]                         invokeRestart("muffleMessage")
[10:21:34.973]                     }
[10:21:34.973]                     else if (inherits(cond, "warning")) {
[10:21:34.973]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:34.973]                       if (muffled) 
[10:21:34.973]                         invokeRestart("muffleWarning")
[10:21:34.973]                     }
[10:21:34.973]                     else if (inherits(cond, "condition")) {
[10:21:34.973]                       if (!is.null(pattern)) {
[10:21:34.973]                         computeRestarts <- base::computeRestarts
[10:21:34.973]                         grepl <- base::grepl
[10:21:34.973]                         restarts <- computeRestarts(cond)
[10:21:34.973]                         for (restart in restarts) {
[10:21:34.973]                           name <- restart$name
[10:21:34.973]                           if (is.null(name)) 
[10:21:34.973]                             next
[10:21:34.973]                           if (!grepl(pattern, name)) 
[10:21:34.973]                             next
[10:21:34.973]                           invokeRestart(restart)
[10:21:34.973]                           muffled <- TRUE
[10:21:34.973]                           break
[10:21:34.973]                         }
[10:21:34.973]                       }
[10:21:34.973]                     }
[10:21:34.973]                     invisible(muffled)
[10:21:34.973]                   }
[10:21:34.973]                   muffleCondition(cond)
[10:21:34.973]                 })
[10:21:34.973]             }))
[10:21:34.973]             future::FutureResult(value = ...future.value$value, 
[10:21:34.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.973]                   ...future.rng), globalenv = if (FALSE) 
[10:21:34.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:34.973]                     ...future.globalenv.names))
[10:21:34.973]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:34.973]         }, condition = base::local({
[10:21:34.973]             c <- base::c
[10:21:34.973]             inherits <- base::inherits
[10:21:34.973]             invokeRestart <- base::invokeRestart
[10:21:34.973]             length <- base::length
[10:21:34.973]             list <- base::list
[10:21:34.973]             seq.int <- base::seq.int
[10:21:34.973]             signalCondition <- base::signalCondition
[10:21:34.973]             sys.calls <- base::sys.calls
[10:21:34.973]             `[[` <- base::`[[`
[10:21:34.973]             `+` <- base::`+`
[10:21:34.973]             `<<-` <- base::`<<-`
[10:21:34.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:34.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:34.973]                   3L)]
[10:21:34.973]             }
[10:21:34.973]             function(cond) {
[10:21:34.973]                 is_error <- inherits(cond, "error")
[10:21:34.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:34.973]                   NULL)
[10:21:34.973]                 if (is_error) {
[10:21:34.973]                   sessionInformation <- function() {
[10:21:34.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:34.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:34.973]                       search = base::search(), system = base::Sys.info())
[10:21:34.973]                   }
[10:21:34.973]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:34.973]                     cond$call), session = sessionInformation(), 
[10:21:34.973]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:34.973]                   signalCondition(cond)
[10:21:34.973]                 }
[10:21:34.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:34.973]                 "immediateCondition"))) {
[10:21:34.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:34.973]                   ...future.conditions[[length(...future.conditions) + 
[10:21:34.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:34.973]                   if (TRUE && !signal) {
[10:21:34.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.973]                     {
[10:21:34.973]                       inherits <- base::inherits
[10:21:34.973]                       invokeRestart <- base::invokeRestart
[10:21:34.973]                       is.null <- base::is.null
[10:21:34.973]                       muffled <- FALSE
[10:21:34.973]                       if (inherits(cond, "message")) {
[10:21:34.973]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.973]                         if (muffled) 
[10:21:34.973]                           invokeRestart("muffleMessage")
[10:21:34.973]                       }
[10:21:34.973]                       else if (inherits(cond, "warning")) {
[10:21:34.973]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.973]                         if (muffled) 
[10:21:34.973]                           invokeRestart("muffleWarning")
[10:21:34.973]                       }
[10:21:34.973]                       else if (inherits(cond, "condition")) {
[10:21:34.973]                         if (!is.null(pattern)) {
[10:21:34.973]                           computeRestarts <- base::computeRestarts
[10:21:34.973]                           grepl <- base::grepl
[10:21:34.973]                           restarts <- computeRestarts(cond)
[10:21:34.973]                           for (restart in restarts) {
[10:21:34.973]                             name <- restart$name
[10:21:34.973]                             if (is.null(name)) 
[10:21:34.973]                               next
[10:21:34.973]                             if (!grepl(pattern, name)) 
[10:21:34.973]                               next
[10:21:34.973]                             invokeRestart(restart)
[10:21:34.973]                             muffled <- TRUE
[10:21:34.973]                             break
[10:21:34.973]                           }
[10:21:34.973]                         }
[10:21:34.973]                       }
[10:21:34.973]                       invisible(muffled)
[10:21:34.973]                     }
[10:21:34.973]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.973]                   }
[10:21:34.973]                 }
[10:21:34.973]                 else {
[10:21:34.973]                   if (TRUE) {
[10:21:34.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:34.973]                     {
[10:21:34.973]                       inherits <- base::inherits
[10:21:34.973]                       invokeRestart <- base::invokeRestart
[10:21:34.973]                       is.null <- base::is.null
[10:21:34.973]                       muffled <- FALSE
[10:21:34.973]                       if (inherits(cond, "message")) {
[10:21:34.973]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:34.973]                         if (muffled) 
[10:21:34.973]                           invokeRestart("muffleMessage")
[10:21:34.973]                       }
[10:21:34.973]                       else if (inherits(cond, "warning")) {
[10:21:34.973]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:34.973]                         if (muffled) 
[10:21:34.973]                           invokeRestart("muffleWarning")
[10:21:34.973]                       }
[10:21:34.973]                       else if (inherits(cond, "condition")) {
[10:21:34.973]                         if (!is.null(pattern)) {
[10:21:34.973]                           computeRestarts <- base::computeRestarts
[10:21:34.973]                           grepl <- base::grepl
[10:21:34.973]                           restarts <- computeRestarts(cond)
[10:21:34.973]                           for (restart in restarts) {
[10:21:34.973]                             name <- restart$name
[10:21:34.973]                             if (is.null(name)) 
[10:21:34.973]                               next
[10:21:34.973]                             if (!grepl(pattern, name)) 
[10:21:34.973]                               next
[10:21:34.973]                             invokeRestart(restart)
[10:21:34.973]                             muffled <- TRUE
[10:21:34.973]                             break
[10:21:34.973]                           }
[10:21:34.973]                         }
[10:21:34.973]                       }
[10:21:34.973]                       invisible(muffled)
[10:21:34.973]                     }
[10:21:34.973]                     muffleCondition(cond, pattern = "^muffle")
[10:21:34.973]                   }
[10:21:34.973]                 }
[10:21:34.973]             }
[10:21:34.973]         }))
[10:21:34.973]     }, error = function(ex) {
[10:21:34.973]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:34.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:34.973]                 ...future.rng), started = ...future.startTime, 
[10:21:34.973]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:34.973]             version = "1.8"), class = "FutureResult")
[10:21:34.973]     }, finally = {
[10:21:34.973]         if (!identical(...future.workdir, getwd())) 
[10:21:34.973]             setwd(...future.workdir)
[10:21:34.973]         {
[10:21:34.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:34.973]                 ...future.oldOptions$nwarnings <- NULL
[10:21:34.973]             }
[10:21:34.973]             base::options(...future.oldOptions)
[10:21:34.973]             if (.Platform$OS.type == "windows") {
[10:21:34.973]                 old_names <- names(...future.oldEnvVars)
[10:21:34.973]                 envs <- base::Sys.getenv()
[10:21:34.973]                 names <- names(envs)
[10:21:34.973]                 common <- intersect(names, old_names)
[10:21:34.973]                 added <- setdiff(names, old_names)
[10:21:34.973]                 removed <- setdiff(old_names, names)
[10:21:34.973]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:34.973]                   envs[common]]
[10:21:34.973]                 NAMES <- toupper(changed)
[10:21:34.973]                 args <- list()
[10:21:34.973]                 for (kk in seq_along(NAMES)) {
[10:21:34.973]                   name <- changed[[kk]]
[10:21:34.973]                   NAME <- NAMES[[kk]]
[10:21:34.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.973]                     next
[10:21:34.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.973]                 }
[10:21:34.973]                 NAMES <- toupper(added)
[10:21:34.973]                 for (kk in seq_along(NAMES)) {
[10:21:34.973]                   name <- added[[kk]]
[10:21:34.973]                   NAME <- NAMES[[kk]]
[10:21:34.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.973]                     next
[10:21:34.973]                   args[[name]] <- ""
[10:21:34.973]                 }
[10:21:34.973]                 NAMES <- toupper(removed)
[10:21:34.973]                 for (kk in seq_along(NAMES)) {
[10:21:34.973]                   name <- removed[[kk]]
[10:21:34.973]                   NAME <- NAMES[[kk]]
[10:21:34.973]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:34.973]                     next
[10:21:34.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:34.973]                 }
[10:21:34.973]                 if (length(args) > 0) 
[10:21:34.973]                   base::do.call(base::Sys.setenv, args = args)
[10:21:34.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:34.973]             }
[10:21:34.973]             else {
[10:21:34.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:34.973]             }
[10:21:34.973]             {
[10:21:34.973]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:34.973]                   0L) {
[10:21:34.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:34.973]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:34.973]                   base::options(opts)
[10:21:34.973]                 }
[10:21:34.973]                 {
[10:21:34.973]                   {
[10:21:34.973]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:34.973]                     NULL
[10:21:34.973]                   }
[10:21:34.973]                   options(future.plan = NULL)
[10:21:34.973]                   if (is.na(NA_character_)) 
[10:21:34.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:34.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:34.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:34.973]                     .init = FALSE)
[10:21:34.973]                 }
[10:21:34.973]             }
[10:21:34.973]         }
[10:21:34.973]     })
[10:21:34.973]     if (TRUE) {
[10:21:34.973]         base::sink(type = "output", split = FALSE)
[10:21:34.973]         if (TRUE) {
[10:21:34.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:34.973]         }
[10:21:34.973]         else {
[10:21:34.973]             ...future.result["stdout"] <- base::list(NULL)
[10:21:34.973]         }
[10:21:34.973]         base::close(...future.stdout)
[10:21:34.973]         ...future.stdout <- NULL
[10:21:34.973]     }
[10:21:34.973]     ...future.result$conditions <- ...future.conditions
[10:21:34.973]     ...future.result$finished <- base::Sys.time()
[10:21:34.973]     ...future.result
[10:21:34.973] }
[10:21:34.976] MultisessionFuture started
[10:21:34.976] - Launch lazy future ... done
[10:21:34.976] run() for ‘MultisessionFuture’ ... done
[10:21:34.977] result() for ClusterFuture ...
[10:21:34.977] receiveMessageFromWorker() for ClusterFuture ...
[10:21:34.977] - Validating connection of MultisessionFuture
[10:21:35.018] - received message: FutureResult
[10:21:35.019] - Received FutureResult
[10:21:35.019] - Erased future from FutureRegistry
[10:21:35.019] result() for ClusterFuture ...
[10:21:35.019] - result already collected: FutureResult
[10:21:35.019] result() for ClusterFuture ... done
[10:21:35.019] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:35.020] result() for ClusterFuture ... done
[10:21:35.020] result() for ClusterFuture ...
[10:21:35.020] - result already collected: FutureResult
[10:21:35.020] result() for ClusterFuture ... done
[10:21:35.020] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:35.021] Searching for globals...
[10:21:35.022] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:35.023] Searching for globals...
[10:21:35.024] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:21:35.024] Searching for globals ... DONE
[10:21:35.024] Resolving globals: FALSE
[10:21:35.024] The total size of the 1 globals is 356 bytes (356 bytes)
[10:21:35.025] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:21:35.025] - globals: [1] ‘data’
[10:21:35.025] 
[10:21:35.025] getGlobalsAndPackages() ... DONE
[10:21:35.026] run() for ‘Future’ ...
[10:21:35.026] - state: ‘created’
[10:21:35.026] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:35.041] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:35.041] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:35.041]   - Field: ‘node’
[10:21:35.041]   - Field: ‘label’
[10:21:35.041]   - Field: ‘local’
[10:21:35.041]   - Field: ‘owner’
[10:21:35.041]   - Field: ‘envir’
[10:21:35.041]   - Field: ‘workers’
[10:21:35.041]   - Field: ‘packages’
[10:21:35.041]   - Field: ‘gc’
[10:21:35.042]   - Field: ‘conditions’
[10:21:35.042]   - Field: ‘persistent’
[10:21:35.042]   - Field: ‘expr’
[10:21:35.042]   - Field: ‘uuid’
[10:21:35.042]   - Field: ‘seed’
[10:21:35.042]   - Field: ‘version’
[10:21:35.042]   - Field: ‘result’
[10:21:35.042]   - Field: ‘asynchronous’
[10:21:35.042]   - Field: ‘calls’
[10:21:35.043]   - Field: ‘globals’
[10:21:35.043]   - Field: ‘stdout’
[10:21:35.043]   - Field: ‘earlySignal’
[10:21:35.043]   - Field: ‘lazy’
[10:21:35.043]   - Field: ‘state’
[10:21:35.043] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:35.043] - Launch lazy future ...
[10:21:35.044] Packages needed by the future expression (n = 0): <none>
[10:21:35.044] Packages needed by future strategies (n = 0): <none>
[10:21:35.044] {
[10:21:35.044]     {
[10:21:35.044]         {
[10:21:35.044]             ...future.startTime <- base::Sys.time()
[10:21:35.044]             {
[10:21:35.044]                 {
[10:21:35.044]                   {
[10:21:35.044]                     {
[10:21:35.044]                       base::local({
[10:21:35.044]                         has_future <- base::requireNamespace("future", 
[10:21:35.044]                           quietly = TRUE)
[10:21:35.044]                         if (has_future) {
[10:21:35.044]                           ns <- base::getNamespace("future")
[10:21:35.044]                           version <- ns[[".package"]][["version"]]
[10:21:35.044]                           if (is.null(version)) 
[10:21:35.044]                             version <- utils::packageVersion("future")
[10:21:35.044]                         }
[10:21:35.044]                         else {
[10:21:35.044]                           version <- NULL
[10:21:35.044]                         }
[10:21:35.044]                         if (!has_future || version < "1.8.0") {
[10:21:35.044]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:35.044]                             "", base::R.version$version.string), 
[10:21:35.044]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:35.044]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:35.044]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:35.044]                               "release", "version")], collapse = " "), 
[10:21:35.044]                             hostname = base::Sys.info()[["nodename"]])
[10:21:35.044]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:35.044]                             info)
[10:21:35.044]                           info <- base::paste(info, collapse = "; ")
[10:21:35.044]                           if (!has_future) {
[10:21:35.044]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:35.044]                               info)
[10:21:35.044]                           }
[10:21:35.044]                           else {
[10:21:35.044]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:35.044]                               info, version)
[10:21:35.044]                           }
[10:21:35.044]                           base::stop(msg)
[10:21:35.044]                         }
[10:21:35.044]                       })
[10:21:35.044]                     }
[10:21:35.044]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:35.044]                     base::options(mc.cores = 1L)
[10:21:35.044]                   }
[10:21:35.044]                   ...future.strategy.old <- future::plan("list")
[10:21:35.044]                   options(future.plan = NULL)
[10:21:35.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:35.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:35.044]                 }
[10:21:35.044]                 ...future.workdir <- getwd()
[10:21:35.044]             }
[10:21:35.044]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:35.044]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:35.044]         }
[10:21:35.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:35.044]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:35.044]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:35.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:35.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:35.044]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:35.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:35.044]             base::names(...future.oldOptions))
[10:21:35.044]     }
[10:21:35.044]     if (FALSE) {
[10:21:35.044]     }
[10:21:35.044]     else {
[10:21:35.044]         if (TRUE) {
[10:21:35.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:35.044]                 open = "w")
[10:21:35.044]         }
[10:21:35.044]         else {
[10:21:35.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:35.044]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:35.044]         }
[10:21:35.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:35.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:35.044]             base::sink(type = "output", split = FALSE)
[10:21:35.044]             base::close(...future.stdout)
[10:21:35.044]         }, add = TRUE)
[10:21:35.044]     }
[10:21:35.044]     ...future.frame <- base::sys.nframe()
[10:21:35.044]     ...future.conditions <- base::list()
[10:21:35.044]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:35.044]     if (FALSE) {
[10:21:35.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:35.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:35.044]     }
[10:21:35.044]     ...future.result <- base::tryCatch({
[10:21:35.044]         base::withCallingHandlers({
[10:21:35.044]             ...future.value <- base::withVisible(base::local({
[10:21:35.044]                 ...future.makeSendCondition <- base::local({
[10:21:35.044]                   sendCondition <- NULL
[10:21:35.044]                   function(frame = 1L) {
[10:21:35.044]                     if (is.function(sendCondition)) 
[10:21:35.044]                       return(sendCondition)
[10:21:35.044]                     ns <- getNamespace("parallel")
[10:21:35.044]                     if (exists("sendData", mode = "function", 
[10:21:35.044]                       envir = ns)) {
[10:21:35.044]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:35.044]                         envir = ns)
[10:21:35.044]                       envir <- sys.frame(frame)
[10:21:35.044]                       master <- NULL
[10:21:35.044]                       while (!identical(envir, .GlobalEnv) && 
[10:21:35.044]                         !identical(envir, emptyenv())) {
[10:21:35.044]                         if (exists("master", mode = "list", envir = envir, 
[10:21:35.044]                           inherits = FALSE)) {
[10:21:35.044]                           master <- get("master", mode = "list", 
[10:21:35.044]                             envir = envir, inherits = FALSE)
[10:21:35.044]                           if (inherits(master, c("SOCKnode", 
[10:21:35.044]                             "SOCK0node"))) {
[10:21:35.044]                             sendCondition <<- function(cond) {
[10:21:35.044]                               data <- list(type = "VALUE", value = cond, 
[10:21:35.044]                                 success = TRUE)
[10:21:35.044]                               parallel_sendData(master, data)
[10:21:35.044]                             }
[10:21:35.044]                             return(sendCondition)
[10:21:35.044]                           }
[10:21:35.044]                         }
[10:21:35.044]                         frame <- frame + 1L
[10:21:35.044]                         envir <- sys.frame(frame)
[10:21:35.044]                       }
[10:21:35.044]                     }
[10:21:35.044]                     sendCondition <<- function(cond) NULL
[10:21:35.044]                   }
[10:21:35.044]                 })
[10:21:35.044]                 withCallingHandlers({
[10:21:35.044]                   subset(data, x < 3)$y
[10:21:35.044]                 }, immediateCondition = function(cond) {
[10:21:35.044]                   sendCondition <- ...future.makeSendCondition()
[10:21:35.044]                   sendCondition(cond)
[10:21:35.044]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:35.044]                   {
[10:21:35.044]                     inherits <- base::inherits
[10:21:35.044]                     invokeRestart <- base::invokeRestart
[10:21:35.044]                     is.null <- base::is.null
[10:21:35.044]                     muffled <- FALSE
[10:21:35.044]                     if (inherits(cond, "message")) {
[10:21:35.044]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:35.044]                       if (muffled) 
[10:21:35.044]                         invokeRestart("muffleMessage")
[10:21:35.044]                     }
[10:21:35.044]                     else if (inherits(cond, "warning")) {
[10:21:35.044]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:35.044]                       if (muffled) 
[10:21:35.044]                         invokeRestart("muffleWarning")
[10:21:35.044]                     }
[10:21:35.044]                     else if (inherits(cond, "condition")) {
[10:21:35.044]                       if (!is.null(pattern)) {
[10:21:35.044]                         computeRestarts <- base::computeRestarts
[10:21:35.044]                         grepl <- base::grepl
[10:21:35.044]                         restarts <- computeRestarts(cond)
[10:21:35.044]                         for (restart in restarts) {
[10:21:35.044]                           name <- restart$name
[10:21:35.044]                           if (is.null(name)) 
[10:21:35.044]                             next
[10:21:35.044]                           if (!grepl(pattern, name)) 
[10:21:35.044]                             next
[10:21:35.044]                           invokeRestart(restart)
[10:21:35.044]                           muffled <- TRUE
[10:21:35.044]                           break
[10:21:35.044]                         }
[10:21:35.044]                       }
[10:21:35.044]                     }
[10:21:35.044]                     invisible(muffled)
[10:21:35.044]                   }
[10:21:35.044]                   muffleCondition(cond)
[10:21:35.044]                 })
[10:21:35.044]             }))
[10:21:35.044]             future::FutureResult(value = ...future.value$value, 
[10:21:35.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:35.044]                   ...future.rng), globalenv = if (FALSE) 
[10:21:35.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:35.044]                     ...future.globalenv.names))
[10:21:35.044]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:35.044]         }, condition = base::local({
[10:21:35.044]             c <- base::c
[10:21:35.044]             inherits <- base::inherits
[10:21:35.044]             invokeRestart <- base::invokeRestart
[10:21:35.044]             length <- base::length
[10:21:35.044]             list <- base::list
[10:21:35.044]             seq.int <- base::seq.int
[10:21:35.044]             signalCondition <- base::signalCondition
[10:21:35.044]             sys.calls <- base::sys.calls
[10:21:35.044]             `[[` <- base::`[[`
[10:21:35.044]             `+` <- base::`+`
[10:21:35.044]             `<<-` <- base::`<<-`
[10:21:35.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:35.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:35.044]                   3L)]
[10:21:35.044]             }
[10:21:35.044]             function(cond) {
[10:21:35.044]                 is_error <- inherits(cond, "error")
[10:21:35.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:35.044]                   NULL)
[10:21:35.044]                 if (is_error) {
[10:21:35.044]                   sessionInformation <- function() {
[10:21:35.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:35.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:35.044]                       search = base::search(), system = base::Sys.info())
[10:21:35.044]                   }
[10:21:35.044]                   ...future.conditions[[length(...future.conditions) + 
[10:21:35.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:35.044]                     cond$call), session = sessionInformation(), 
[10:21:35.044]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:35.044]                   signalCondition(cond)
[10:21:35.044]                 }
[10:21:35.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:35.044]                 "immediateCondition"))) {
[10:21:35.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:35.044]                   ...future.conditions[[length(...future.conditions) + 
[10:21:35.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:35.044]                   if (TRUE && !signal) {
[10:21:35.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:35.044]                     {
[10:21:35.044]                       inherits <- base::inherits
[10:21:35.044]                       invokeRestart <- base::invokeRestart
[10:21:35.044]                       is.null <- base::is.null
[10:21:35.044]                       muffled <- FALSE
[10:21:35.044]                       if (inherits(cond, "message")) {
[10:21:35.044]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:35.044]                         if (muffled) 
[10:21:35.044]                           invokeRestart("muffleMessage")
[10:21:35.044]                       }
[10:21:35.044]                       else if (inherits(cond, "warning")) {
[10:21:35.044]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:35.044]                         if (muffled) 
[10:21:35.044]                           invokeRestart("muffleWarning")
[10:21:35.044]                       }
[10:21:35.044]                       else if (inherits(cond, "condition")) {
[10:21:35.044]                         if (!is.null(pattern)) {
[10:21:35.044]                           computeRestarts <- base::computeRestarts
[10:21:35.044]                           grepl <- base::grepl
[10:21:35.044]                           restarts <- computeRestarts(cond)
[10:21:35.044]                           for (restart in restarts) {
[10:21:35.044]                             name <- restart$name
[10:21:35.044]                             if (is.null(name)) 
[10:21:35.044]                               next
[10:21:35.044]                             if (!grepl(pattern, name)) 
[10:21:35.044]                               next
[10:21:35.044]                             invokeRestart(restart)
[10:21:35.044]                             muffled <- TRUE
[10:21:35.044]                             break
[10:21:35.044]                           }
[10:21:35.044]                         }
[10:21:35.044]                       }
[10:21:35.044]                       invisible(muffled)
[10:21:35.044]                     }
[10:21:35.044]                     muffleCondition(cond, pattern = "^muffle")
[10:21:35.044]                   }
[10:21:35.044]                 }
[10:21:35.044]                 else {
[10:21:35.044]                   if (TRUE) {
[10:21:35.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:35.044]                     {
[10:21:35.044]                       inherits <- base::inherits
[10:21:35.044]                       invokeRestart <- base::invokeRestart
[10:21:35.044]                       is.null <- base::is.null
[10:21:35.044]                       muffled <- FALSE
[10:21:35.044]                       if (inherits(cond, "message")) {
[10:21:35.044]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:35.044]                         if (muffled) 
[10:21:35.044]                           invokeRestart("muffleMessage")
[10:21:35.044]                       }
[10:21:35.044]                       else if (inherits(cond, "warning")) {
[10:21:35.044]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:35.044]                         if (muffled) 
[10:21:35.044]                           invokeRestart("muffleWarning")
[10:21:35.044]                       }
[10:21:35.044]                       else if (inherits(cond, "condition")) {
[10:21:35.044]                         if (!is.null(pattern)) {
[10:21:35.044]                           computeRestarts <- base::computeRestarts
[10:21:35.044]                           grepl <- base::grepl
[10:21:35.044]                           restarts <- computeRestarts(cond)
[10:21:35.044]                           for (restart in restarts) {
[10:21:35.044]                             name <- restart$name
[10:21:35.044]                             if (is.null(name)) 
[10:21:35.044]                               next
[10:21:35.044]                             if (!grepl(pattern, name)) 
[10:21:35.044]                               next
[10:21:35.044]                             invokeRestart(restart)
[10:21:35.044]                             muffled <- TRUE
[10:21:35.044]                             break
[10:21:35.044]                           }
[10:21:35.044]                         }
[10:21:35.044]                       }
[10:21:35.044]                       invisible(muffled)
[10:21:35.044]                     }
[10:21:35.044]                     muffleCondition(cond, pattern = "^muffle")
[10:21:35.044]                   }
[10:21:35.044]                 }
[10:21:35.044]             }
[10:21:35.044]         }))
[10:21:35.044]     }, error = function(ex) {
[10:21:35.044]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:35.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:35.044]                 ...future.rng), started = ...future.startTime, 
[10:21:35.044]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:35.044]             version = "1.8"), class = "FutureResult")
[10:21:35.044]     }, finally = {
[10:21:35.044]         if (!identical(...future.workdir, getwd())) 
[10:21:35.044]             setwd(...future.workdir)
[10:21:35.044]         {
[10:21:35.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:35.044]                 ...future.oldOptions$nwarnings <- NULL
[10:21:35.044]             }
[10:21:35.044]             base::options(...future.oldOptions)
[10:21:35.044]             if (.Platform$OS.type == "windows") {
[10:21:35.044]                 old_names <- names(...future.oldEnvVars)
[10:21:35.044]                 envs <- base::Sys.getenv()
[10:21:35.044]                 names <- names(envs)
[10:21:35.044]                 common <- intersect(names, old_names)
[10:21:35.044]                 added <- setdiff(names, old_names)
[10:21:35.044]                 removed <- setdiff(old_names, names)
[10:21:35.044]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:35.044]                   envs[common]]
[10:21:35.044]                 NAMES <- toupper(changed)
[10:21:35.044]                 args <- list()
[10:21:35.044]                 for (kk in seq_along(NAMES)) {
[10:21:35.044]                   name <- changed[[kk]]
[10:21:35.044]                   NAME <- NAMES[[kk]]
[10:21:35.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.044]                     next
[10:21:35.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:35.044]                 }
[10:21:35.044]                 NAMES <- toupper(added)
[10:21:35.044]                 for (kk in seq_along(NAMES)) {
[10:21:35.044]                   name <- added[[kk]]
[10:21:35.044]                   NAME <- NAMES[[kk]]
[10:21:35.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.044]                     next
[10:21:35.044]                   args[[name]] <- ""
[10:21:35.044]                 }
[10:21:35.044]                 NAMES <- toupper(removed)
[10:21:35.044]                 for (kk in seq_along(NAMES)) {
[10:21:35.044]                   name <- removed[[kk]]
[10:21:35.044]                   NAME <- NAMES[[kk]]
[10:21:35.044]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.044]                     next
[10:21:35.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:35.044]                 }
[10:21:35.044]                 if (length(args) > 0) 
[10:21:35.044]                   base::do.call(base::Sys.setenv, args = args)
[10:21:35.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:35.044]             }
[10:21:35.044]             else {
[10:21:35.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:35.044]             }
[10:21:35.044]             {
[10:21:35.044]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:35.044]                   0L) {
[10:21:35.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:35.044]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:35.044]                   base::options(opts)
[10:21:35.044]                 }
[10:21:35.044]                 {
[10:21:35.044]                   {
[10:21:35.044]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:35.044]                     NULL
[10:21:35.044]                   }
[10:21:35.044]                   options(future.plan = NULL)
[10:21:35.044]                   if (is.na(NA_character_)) 
[10:21:35.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:35.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:35.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:35.044]                     .init = FALSE)
[10:21:35.044]                 }
[10:21:35.044]             }
[10:21:35.044]         }
[10:21:35.044]     })
[10:21:35.044]     if (TRUE) {
[10:21:35.044]         base::sink(type = "output", split = FALSE)
[10:21:35.044]         if (TRUE) {
[10:21:35.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:35.044]         }
[10:21:35.044]         else {
[10:21:35.044]             ...future.result["stdout"] <- base::list(NULL)
[10:21:35.044]         }
[10:21:35.044]         base::close(...future.stdout)
[10:21:35.044]         ...future.stdout <- NULL
[10:21:35.044]     }
[10:21:35.044]     ...future.result$conditions <- ...future.conditions
[10:21:35.044]     ...future.result$finished <- base::Sys.time()
[10:21:35.044]     ...future.result
[10:21:35.044] }
[10:21:35.047] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[10:21:35.047] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[10:21:35.048] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[10:21:35.048] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[10:21:35.048] MultisessionFuture started
[10:21:35.049] - Launch lazy future ... done
[10:21:35.049] run() for ‘MultisessionFuture’ ... done
[10:21:35.049] result() for ClusterFuture ...
[10:21:35.049] receiveMessageFromWorker() for ClusterFuture ...
[10:21:35.049] - Validating connection of MultisessionFuture
[10:21:35.091] - received message: FutureResult
[10:21:35.091] - Received FutureResult
[10:21:35.091] - Erased future from FutureRegistry
[10:21:35.092] result() for ClusterFuture ...
[10:21:35.092] - result already collected: FutureResult
[10:21:35.092] result() for ClusterFuture ... done
[10:21:35.092] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:35.092] result() for ClusterFuture ... done
[10:21:35.092] result() for ClusterFuture ...
[10:21:35.092] - result already collected: FutureResult
[10:21:35.092] result() for ClusterFuture ... done
[10:21:35.093] plan(): Setting new future strategy stack:
[10:21:35.093] List of future strategies:
[10:21:35.093] 1. sequential:
[10:21:35.093]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:35.093]    - tweaked: FALSE
[10:21:35.093]    - call: plan(list(sequential, strategy))
[10:21:35.093] 2. multisession:
[10:21:35.093]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:35.093]    - tweaked: FALSE
[10:21:35.093]    - call: plan(list(sequential, strategy))
[10:21:35.094] plan(): nbrOfWorkers() = 1
[10:21:35.094] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:35.095] Searching for globals...
[10:21:35.101] - globals found: [8] ‘{’, ‘<-’, ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’, ‘%<-%’
[10:21:35.101] Searching for globals ... DONE
[10:21:35.101] Resolving globals: FALSE
[10:21:35.102] The total size of the 1 globals is 356 bytes (356 bytes)
[10:21:35.103] The total size of the 1 globals exported for future expression (‘{; a %<-% subset(data, x < 3)$y; a; }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:21:35.103] - globals: [1] ‘data’
[10:21:35.103] - packages: [1] ‘future’
[10:21:35.104] getGlobalsAndPackages() ... DONE
[10:21:35.104] run() for ‘Future’ ...
[10:21:35.104] - state: ‘created’
[10:21:35.105] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:35.105] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:35.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:35.106]   - Field: ‘label’
[10:21:35.106]   - Field: ‘local’
[10:21:35.106]   - Field: ‘owner’
[10:21:35.106]   - Field: ‘envir’
[10:21:35.106]   - Field: ‘packages’
[10:21:35.107]   - Field: ‘gc’
[10:21:35.107]   - Field: ‘conditions’
[10:21:35.107]   - Field: ‘expr’
[10:21:35.107]   - Field: ‘uuid’
[10:21:35.107]   - Field: ‘seed’
[10:21:35.107]   - Field: ‘version’
[10:21:35.108]   - Field: ‘result’
[10:21:35.108]   - Field: ‘asynchronous’
[10:21:35.108]   - Field: ‘calls’
[10:21:35.108]   - Field: ‘globals’
[10:21:35.108]   - Field: ‘stdout’
[10:21:35.109]   - Field: ‘earlySignal’
[10:21:35.109]   - Field: ‘lazy’
[10:21:35.109]   - Field: ‘state’
[10:21:35.109] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:35.109] - Launch lazy future ...
[10:21:35.110] Packages needed by the future expression (n = 1): ‘future’
[10:21:35.110] Packages needed by future strategies (n = 1): ‘future’
[10:21:35.111] {
[10:21:35.111]     {
[10:21:35.111]         {
[10:21:35.111]             ...future.startTime <- base::Sys.time()
[10:21:35.111]             {
[10:21:35.111]                 {
[10:21:35.111]                   {
[10:21:35.111]                     {
[10:21:35.111]                       base::local({
[10:21:35.111]                         has_future <- base::requireNamespace("future", 
[10:21:35.111]                           quietly = TRUE)
[10:21:35.111]                         if (has_future) {
[10:21:35.111]                           ns <- base::getNamespace("future")
[10:21:35.111]                           version <- ns[[".package"]][["version"]]
[10:21:35.111]                           if (is.null(version)) 
[10:21:35.111]                             version <- utils::packageVersion("future")
[10:21:35.111]                         }
[10:21:35.111]                         else {
[10:21:35.111]                           version <- NULL
[10:21:35.111]                         }
[10:21:35.111]                         if (!has_future || version < "1.8.0") {
[10:21:35.111]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:35.111]                             "", base::R.version$version.string), 
[10:21:35.111]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:35.111]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:35.111]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:35.111]                               "release", "version")], collapse = " "), 
[10:21:35.111]                             hostname = base::Sys.info()[["nodename"]])
[10:21:35.111]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:35.111]                             info)
[10:21:35.111]                           info <- base::paste(info, collapse = "; ")
[10:21:35.111]                           if (!has_future) {
[10:21:35.111]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:35.111]                               info)
[10:21:35.111]                           }
[10:21:35.111]                           else {
[10:21:35.111]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:35.111]                               info, version)
[10:21:35.111]                           }
[10:21:35.111]                           base::stop(msg)
[10:21:35.111]                         }
[10:21:35.111]                       })
[10:21:35.111]                     }
[10:21:35.111]                     base::local({
[10:21:35.111]                       for (pkg in "future") {
[10:21:35.111]                         base::loadNamespace(pkg)
[10:21:35.111]                         base::library(pkg, character.only = TRUE)
[10:21:35.111]                       }
[10:21:35.111]                     })
[10:21:35.111]                   }
[10:21:35.111]                   ...future.strategy.old <- future::plan("list")
[10:21:35.111]                   options(future.plan = NULL)
[10:21:35.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:35.111]                   future::plan(list(function (..., workers = availableCores(), 
[10:21:35.111]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:21:35.111]                     envir = parent.frame()) 
[10:21:35.111]                   {
[10:21:35.111]                     if (is.function(workers)) 
[10:21:35.111]                       workers <- workers()
[10:21:35.111]                     workers <- structure(as.integer(workers), 
[10:21:35.111]                       class = class(workers))
[10:21:35.111]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:21:35.111]                       workers >= 1)
[10:21:35.111]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:21:35.111]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:21:35.111]                     }
[10:21:35.111]                     future <- MultisessionFuture(..., workers = workers, 
[10:21:35.111]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:21:35.111]                       envir = envir)
[10:21:35.111]                     if (!future$lazy) 
[10:21:35.111]                       future <- run(future)
[10:21:35.111]                     invisible(future)
[10:21:35.111]                   }), .cleanup = FALSE, .init = FALSE)
[10:21:35.111]                 }
[10:21:35.111]                 ...future.workdir <- getwd()
[10:21:35.111]             }
[10:21:35.111]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:35.111]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:35.111]         }
[10:21:35.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:35.111]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:35.111]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:35.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:35.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:35.111]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:35.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:35.111]             base::names(...future.oldOptions))
[10:21:35.111]     }
[10:21:35.111]     if (FALSE) {
[10:21:35.111]     }
[10:21:35.111]     else {
[10:21:35.111]         if (TRUE) {
[10:21:35.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:35.111]                 open = "w")
[10:21:35.111]         }
[10:21:35.111]         else {
[10:21:35.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:35.111]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:35.111]         }
[10:21:35.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:35.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:35.111]             base::sink(type = "output", split = FALSE)
[10:21:35.111]             base::close(...future.stdout)
[10:21:35.111]         }, add = TRUE)
[10:21:35.111]     }
[10:21:35.111]     ...future.frame <- base::sys.nframe()
[10:21:35.111]     ...future.conditions <- base::list()
[10:21:35.111]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:35.111]     if (FALSE) {
[10:21:35.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:35.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:35.111]     }
[10:21:35.111]     ...future.result <- base::tryCatch({
[10:21:35.111]         base::withCallingHandlers({
[10:21:35.111]             ...future.value <- base::withVisible(base::local({
[10:21:35.111]                 a %<-% subset(data, x < 3)$y
[10:21:35.111]                 a
[10:21:35.111]             }))
[10:21:35.111]             future::FutureResult(value = ...future.value$value, 
[10:21:35.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:35.111]                   ...future.rng), globalenv = if (FALSE) 
[10:21:35.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:35.111]                     ...future.globalenv.names))
[10:21:35.111]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:35.111]         }, condition = base::local({
[10:21:35.111]             c <- base::c
[10:21:35.111]             inherits <- base::inherits
[10:21:35.111]             invokeRestart <- base::invokeRestart
[10:21:35.111]             length <- base::length
[10:21:35.111]             list <- base::list
[10:21:35.111]             seq.int <- base::seq.int
[10:21:35.111]             signalCondition <- base::signalCondition
[10:21:35.111]             sys.calls <- base::sys.calls
[10:21:35.111]             `[[` <- base::`[[`
[10:21:35.111]             `+` <- base::`+`
[10:21:35.111]             `<<-` <- base::`<<-`
[10:21:35.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:35.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:35.111]                   3L)]
[10:21:35.111]             }
[10:21:35.111]             function(cond) {
[10:21:35.111]                 is_error <- inherits(cond, "error")
[10:21:35.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:35.111]                   NULL)
[10:21:35.111]                 if (is_error) {
[10:21:35.111]                   sessionInformation <- function() {
[10:21:35.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:35.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:35.111]                       search = base::search(), system = base::Sys.info())
[10:21:35.111]                   }
[10:21:35.111]                   ...future.conditions[[length(...future.conditions) + 
[10:21:35.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:35.111]                     cond$call), session = sessionInformation(), 
[10:21:35.111]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:35.111]                   signalCondition(cond)
[10:21:35.111]                 }
[10:21:35.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:35.111]                 "immediateCondition"))) {
[10:21:35.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:35.111]                   ...future.conditions[[length(...future.conditions) + 
[10:21:35.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:35.111]                   if (TRUE && !signal) {
[10:21:35.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:35.111]                     {
[10:21:35.111]                       inherits <- base::inherits
[10:21:35.111]                       invokeRestart <- base::invokeRestart
[10:21:35.111]                       is.null <- base::is.null
[10:21:35.111]                       muffled <- FALSE
[10:21:35.111]                       if (inherits(cond, "message")) {
[10:21:35.111]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:35.111]                         if (muffled) 
[10:21:35.111]                           invokeRestart("muffleMessage")
[10:21:35.111]                       }
[10:21:35.111]                       else if (inherits(cond, "warning")) {
[10:21:35.111]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:35.111]                         if (muffled) 
[10:21:35.111]                           invokeRestart("muffleWarning")
[10:21:35.111]                       }
[10:21:35.111]                       else if (inherits(cond, "condition")) {
[10:21:35.111]                         if (!is.null(pattern)) {
[10:21:35.111]                           computeRestarts <- base::computeRestarts
[10:21:35.111]                           grepl <- base::grepl
[10:21:35.111]                           restarts <- computeRestarts(cond)
[10:21:35.111]                           for (restart in restarts) {
[10:21:35.111]                             name <- restart$name
[10:21:35.111]                             if (is.null(name)) 
[10:21:35.111]                               next
[10:21:35.111]                             if (!grepl(pattern, name)) 
[10:21:35.111]                               next
[10:21:35.111]                             invokeRestart(restart)
[10:21:35.111]                             muffled <- TRUE
[10:21:35.111]                             break
[10:21:35.111]                           }
[10:21:35.111]                         }
[10:21:35.111]                       }
[10:21:35.111]                       invisible(muffled)
[10:21:35.111]                     }
[10:21:35.111]                     muffleCondition(cond, pattern = "^muffle")
[10:21:35.111]                   }
[10:21:35.111]                 }
[10:21:35.111]                 else {
[10:21:35.111]                   if (TRUE) {
[10:21:35.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:35.111]                     {
[10:21:35.111]                       inherits <- base::inherits
[10:21:35.111]                       invokeRestart <- base::invokeRestart
[10:21:35.111]                       is.null <- base::is.null
[10:21:35.111]                       muffled <- FALSE
[10:21:35.111]                       if (inherits(cond, "message")) {
[10:21:35.111]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:35.111]                         if (muffled) 
[10:21:35.111]                           invokeRestart("muffleMessage")
[10:21:35.111]                       }
[10:21:35.111]                       else if (inherits(cond, "warning")) {
[10:21:35.111]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:35.111]                         if (muffled) 
[10:21:35.111]                           invokeRestart("muffleWarning")
[10:21:35.111]                       }
[10:21:35.111]                       else if (inherits(cond, "condition")) {
[10:21:35.111]                         if (!is.null(pattern)) {
[10:21:35.111]                           computeRestarts <- base::computeRestarts
[10:21:35.111]                           grepl <- base::grepl
[10:21:35.111]                           restarts <- computeRestarts(cond)
[10:21:35.111]                           for (restart in restarts) {
[10:21:35.111]                             name <- restart$name
[10:21:35.111]                             if (is.null(name)) 
[10:21:35.111]                               next
[10:21:35.111]                             if (!grepl(pattern, name)) 
[10:21:35.111]                               next
[10:21:35.111]                             invokeRestart(restart)
[10:21:35.111]                             muffled <- TRUE
[10:21:35.111]                             break
[10:21:35.111]                           }
[10:21:35.111]                         }
[10:21:35.111]                       }
[10:21:35.111]                       invisible(muffled)
[10:21:35.111]                     }
[10:21:35.111]                     muffleCondition(cond, pattern = "^muffle")
[10:21:35.111]                   }
[10:21:35.111]                 }
[10:21:35.111]             }
[10:21:35.111]         }))
[10:21:35.111]     }, error = function(ex) {
[10:21:35.111]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:35.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:35.111]                 ...future.rng), started = ...future.startTime, 
[10:21:35.111]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:35.111]             version = "1.8"), class = "FutureResult")
[10:21:35.111]     }, finally = {
[10:21:35.111]         if (!identical(...future.workdir, getwd())) 
[10:21:35.111]             setwd(...future.workdir)
[10:21:35.111]         {
[10:21:35.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:35.111]                 ...future.oldOptions$nwarnings <- NULL
[10:21:35.111]             }
[10:21:35.111]             base::options(...future.oldOptions)
[10:21:35.111]             if (.Platform$OS.type == "windows") {
[10:21:35.111]                 old_names <- names(...future.oldEnvVars)
[10:21:35.111]                 envs <- base::Sys.getenv()
[10:21:35.111]                 names <- names(envs)
[10:21:35.111]                 common <- intersect(names, old_names)
[10:21:35.111]                 added <- setdiff(names, old_names)
[10:21:35.111]                 removed <- setdiff(old_names, names)
[10:21:35.111]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:35.111]                   envs[common]]
[10:21:35.111]                 NAMES <- toupper(changed)
[10:21:35.111]                 args <- list()
[10:21:35.111]                 for (kk in seq_along(NAMES)) {
[10:21:35.111]                   name <- changed[[kk]]
[10:21:35.111]                   NAME <- NAMES[[kk]]
[10:21:35.111]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.111]                     next
[10:21:35.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:35.111]                 }
[10:21:35.111]                 NAMES <- toupper(added)
[10:21:35.111]                 for (kk in seq_along(NAMES)) {
[10:21:35.111]                   name <- added[[kk]]
[10:21:35.111]                   NAME <- NAMES[[kk]]
[10:21:35.111]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.111]                     next
[10:21:35.111]                   args[[name]] <- ""
[10:21:35.111]                 }
[10:21:35.111]                 NAMES <- toupper(removed)
[10:21:35.111]                 for (kk in seq_along(NAMES)) {
[10:21:35.111]                   name <- removed[[kk]]
[10:21:35.111]                   NAME <- NAMES[[kk]]
[10:21:35.111]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.111]                     next
[10:21:35.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:35.111]                 }
[10:21:35.111]                 if (length(args) > 0) 
[10:21:35.111]                   base::do.call(base::Sys.setenv, args = args)
[10:21:35.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:35.111]             }
[10:21:35.111]             else {
[10:21:35.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:35.111]             }
[10:21:35.111]             {
[10:21:35.111]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:35.111]                   0L) {
[10:21:35.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:35.111]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:35.111]                   base::options(opts)
[10:21:35.111]                 }
[10:21:35.111]                 {
[10:21:35.111]                   {
[10:21:35.111]                     NULL
[10:21:35.111]                     RNGkind("Mersenne-Twister")
[10:21:35.111]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:35.111]                       inherits = FALSE)
[10:21:35.111]                   }
[10:21:35.111]                   options(future.plan = NULL)
[10:21:35.111]                   if (is.na(NA_character_)) 
[10:21:35.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:35.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:35.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:35.111]                     .init = FALSE)
[10:21:35.111]                 }
[10:21:35.111]             }
[10:21:35.111]         }
[10:21:35.111]     })
[10:21:35.111]     if (TRUE) {
[10:21:35.111]         base::sink(type = "output", split = FALSE)
[10:21:35.111]         if (TRUE) {
[10:21:35.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:35.111]         }
[10:21:35.111]         else {
[10:21:35.111]             ...future.result["stdout"] <- base::list(NULL)
[10:21:35.111]         }
[10:21:35.111]         base::close(...future.stdout)
[10:21:35.111]         ...future.stdout <- NULL
[10:21:35.111]     }
[10:21:35.111]     ...future.result$conditions <- ...future.conditions
[10:21:35.111]     ...future.result$finished <- base::Sys.time()
[10:21:35.111]     ...future.result
[10:21:35.111] }
[10:21:35.113] assign_globals() ...
[10:21:35.113] List of 1
[10:21:35.113]  $ data:'data.frame':	5 obs. of  2 variables:
[10:21:35.113]   ..$ x: int [1:5] 1 2 3 4 5
[10:21:35.113]   ..$ y: int [1:5] 1 2 3 4 5
[10:21:35.113]  - attr(*, "where")=List of 1
[10:21:35.113]   ..$ data:<environment: R_EmptyEnv> 
[10:21:35.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:35.113]  - attr(*, "resolved")= logi FALSE
[10:21:35.113]  - attr(*, "total_size")= num 356
[10:21:35.113]  - attr(*, "already-done")= logi TRUE
[10:21:35.117] - copied ‘data’ to environment
[10:21:35.118] assign_globals() ... done
[10:21:35.118] plan(): Setting new future strategy stack:
[10:21:35.118] List of future strategies:
[10:21:35.118] 1. multisession:
[10:21:35.118]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:35.118]    - tweaked: FALSE
[10:21:35.118]    - call: plan(list(sequential, strategy))
[10:21:35.120] plan(): nbrOfWorkers() = 2
[10:21:35.530] plan(): Setting new future strategy stack:
[10:21:35.530] List of future strategies:
[10:21:35.530] 1. sequential:
[10:21:35.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:35.530]    - tweaked: FALSE
[10:21:35.530]    - call: plan(list(sequential, strategy))
[10:21:35.530] 2. multisession:
[10:21:35.530]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:35.530]    - tweaked: FALSE
[10:21:35.530]    - call: plan(list(sequential, strategy))
[10:21:35.531] plan(): nbrOfWorkers() = 1
[10:21:35.531] SequentialFuture started (and completed)
[10:21:35.531] signalConditions() ...
[10:21:35.531]  - include = ‘immediateCondition’
[10:21:35.531]  - exclude = 
[10:21:35.531]  - resignal = FALSE
[10:21:35.531]  - Number of conditions: 64
[10:21:35.532] signalConditions() ... done
[10:21:35.532] - Launch lazy future ... done
[10:21:35.532] run() for ‘SequentialFuture’ ... done
[10:21:35.532] signalConditions() ...
[10:21:35.532]  - include = ‘immediateCondition’
[10:21:35.532]  - exclude = 
[10:21:35.532]  - resignal = FALSE
[10:21:35.532]  - Number of conditions: 64
[10:21:35.532] signalConditions() ... done
[10:21:35.532] Future state: ‘finished’
[10:21:35.533] signalConditions() ...
[10:21:35.533]  - include = ‘condition’
[10:21:35.533]  - exclude = ‘immediateCondition’
[10:21:35.533]  - resignal = TRUE
[10:21:35.533]  - Number of conditions: 64
[10:21:35.533]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.121] getGlobalsAndPackages() ...
[10:21:35.533]  - Condition #2: ‘deprecatedWarning’, ‘warning’, ‘condition’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:35.533]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.138] Searching for globals...
[10:21:35.533]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.140] - globals found: [5] ‘$’, ‘subset’, ‘data’, ‘<’, ‘x’
[10:21:35.534]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.140] Searching for globals ... DONE
[10:21:35.534]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.140] Resolving globals: FALSE
[10:21:35.534]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.140] The total size of the 1 globals is 356 bytes (356 bytes)
[10:21:35.534]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.141] The total size of the 1 globals exported for future expression (‘subset(data, x < 3)$y’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:21:35.534]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.141] - globals: [1] ‘data’
[10:21:35.534]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.141] 
[10:21:35.534]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.141] getGlobalsAndPackages() ... DONE
[10:21:35.534]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.141] run() for ‘Future’ ...
[10:21:35.535]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.141] - state: ‘created’
[10:21:35.535]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.141] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:35.535]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.399] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:35.535]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:35.535]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.400]   - Field: ‘node’
[10:21:35.535]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.400]   - Field: ‘label’
[10:21:35.535]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.400]   - Field: ‘local’
[10:21:35.535]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.400]   - Field: ‘owner’
[10:21:35.535]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.400]   - Field: ‘envir’
[10:21:35.536]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.400]   - Field: ‘workers’
[10:21:35.536]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.400]   - Field: ‘packages’
[10:21:35.536]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.400]   - Field: ‘gc’
[10:21:35.536]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.401]   - Field: ‘conditions’
[10:21:35.536]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.401]   - Field: ‘persistent’
[10:21:35.536]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.401]   - Field: ‘expr’
[10:21:35.536]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.401]   - Field: ‘uuid’
[10:21:35.536]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.401]   - Field: ‘seed’
[10:21:35.537]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.401]   - Field: ‘version’
[10:21:35.537]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.401]   - Field: ‘result’
[10:21:35.537]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.401]   - Field: ‘asynchronous’
[10:21:35.537]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.401]   - Field: ‘calls’
[10:21:35.537]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.402]   - Field: ‘globals’
[10:21:35.537]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.402]   - Field: ‘stdout’
[10:21:35.537]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.402]   - Field: ‘earlySignal’
[10:21:35.537]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.402]   - Field: ‘lazy’
[10:21:35.538]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.402]   - Field: ‘state’
[10:21:35.538]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:35.538]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.402] - Launch lazy future ...
[10:21:35.538]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.402] Packages needed by the future expression (n = 0): <none>
[10:21:35.538]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.403] Packages needed by future strategies (n = 0): <none>
[10:21:35.538]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.403] {
[10:21:35.403]     {
[10:21:35.403]         {
[10:21:35.403]             ...future.startTime <- base::Sys.time()
[10:21:35.403]             {
[10:21:35.403]                 {
[10:21:35.403]                   {
[10:21:35.403]                     {
[10:21:35.403]                       base::local({
[10:21:35.403]                         has_future <- base::requireNamespace("future", 
[10:21:35.403]                           quietly = TRUE)
[10:21:35.403]                         if (has_future) {
[10:21:35.403]                           ns <- base::getNamespace("future")
[10:21:35.403]                           version <- ns[[".package"]][["version"]]
[10:21:35.403]                           if (is.null(version)) 
[10:21:35.403]                             version <- utils::packageVersion("future")
[10:21:35.403]                         }
[10:21:35.403]                         else {
[10:21:35.403]                           version <- NULL
[10:21:35.403]                         }
[10:21:35.403]                         if (!has_future || version < "1.8.0") {
[10:21:35.403]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:35.403]                             "", base::R.version$version.string), 
[10:21:35.403]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:35.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:35.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:35.403]                               "release", "version")], collapse = " "), 
[10:21:35.403]                             hostname = base::Sys.info()[["nodename"]])
[10:21:35.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:35.403]                             info)
[10:21:35.403]                           info <- base::paste(info, collapse = "; ")
[10:21:35.403]                           if (!has_future) {
[10:21:35.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:35.403]                               info)
[10:21:35.403]                           }
[10:21:35.403]                           else {
[10:21:35.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:35.403]                               info, version)
[10:21:35.403]                           }
[10:21:35.403]                           base::stop(msg)
[10:21:35.403]                         }
[10:21:35.403]                       })
[10:21:35.403]                     }
[10:21:35.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:35.403]                     base::options(mc.cores = 1L)
[10:21:35.403]                   }
[10:21:35.403]                   ...future.strategy.old <- future::plan("list")
[10:21:35.403]                   options(future.plan = NULL)
[10:21:35.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:35.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:35.403]                 }
[10:21:35.403]                 ...future.workdir <- getwd()
[10:21:35.403]             }
[10:21:35.403]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:35.403]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:35.403]         }
[10:21:35.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:35.403]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:35.403]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:35.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:35.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:35.403]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:35.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:35.403]             base::names(...future.oldOptions))
[10:21:35.403]     }
[10:21:35.403]     if (FALSE) {
[10:21:35.403]     }
[10:21:35.403]     else {
[10:21:35.403]         if (TRUE) {
[10:21:35.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:35.403]                 open = "w")
[10:21:35.403]         }
[10:21:35.403]         else {
[10:21:35.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:35.403]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:35.403]         }
[10:21:35.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:35.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:35.403]             base::sink(type = "output", split = FALSE)
[10:21:35.403]             base::close(...future.stdout)
[10:21:35.403]         }, add = TRUE)
[10:21:35.403]     }
[10:21:35.403]     ...future.frame <- base::sys.nframe()
[10:21:35.403]     ...future.conditions <- base::list()
[10:21:35.403]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:35.403]     if (FALSE) {
[10:21:35.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:35.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:35.403]     }
[10:21:35.403]     ...future.result <- base::tryCatch({
[10:21:35.403]         base::withCallingHandlers({
[10:21:35.403]             ...future.value <- base::withVisible(base::local({
[10:21:35.403]                 ...future.makeSendCondition <- base::local({
[10:21:35.403]                   sendCondition <- NULL
[10:21:35.403]                   function(frame = 1L) {
[10:21:35.403]                     if (is.function(sendCondition)) 
[10:21:35.403]                       return(sendCondition)
[10:21:35.403]                     ns <- getNamespace("parallel")
[10:21:35.403]                     if (exists("sendData", mode = "function", 
[10:21:35.403]                       envir = ns)) {
[10:21:35.403]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:35.403]                         envir = ns)
[10:21:35.403]                       envir <- sys.frame(frame)
[10:21:35.403]                       master <- NULL
[10:21:35.403]                       while (!identical(envir, .GlobalEnv) && 
[10:21:35.403]                         !identical(envir, emptyenv())) {
[10:21:35.403]                         if (exists("master", mode = "list", envir = envir, 
[10:21:35.403]                           inherits = FALSE)) {
[10:21:35.403]                           master <- get("master", mode = "list", 
[10:21:35.403]                             envir = envir, inherits = FALSE)
[10:21:35.403]                           if (inherits(master, c("SOCKnode", 
[10:21:35.403]                             "SOCK0node"))) {
[10:21:35.403]                             sendCondition <<- function(cond) {
[10:21:35.403]                               data <- list(type = "VALUE", value = cond, 
[10:21:35.403]                                 success = TRUE)
[10:21:35.403]                               parallel_sendData(master, data)
[10:21:35.403]                             }
[10:21:35.403]                             return(sendCondition)
[10:21:35.403]                           }
[10:21:35.403]                         }
[10:21:35.403]                         frame <- frame + 1L
[10:21:35.403]                         envir <- sys.frame(frame)
[10:21:35.403]                       }
[10:21:35.403]                     }
[10:21:35.403]                     sendCondition <<- function(cond) NULL
[10:21:35.403]                   }
[10:21:35.403]                 })
[10:21:35.403]                 withCallingHandlers({
[10:21:35.403]                   subset(data, x < 3)$y
[10:21:35.403]                 }, immediateCondition = function(cond) {
[10:21:35.403]                   sendCondition <- ...future.makeSendCondition()
[10:21:35.403]                   sendCondition(cond)
[10:21:35.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:35.403]                   {
[10:21:35.403]                     inherits <- base::inherits
[10:21:35.403]                     invokeRestart <- base::invokeRestart
[10:21:35.403]                     is.null <- base::is.null
[10:21:35.403]                     muffled <- FALSE
[10:21:35.403]                     if (inherits(cond, "message")) {
[10:21:35.403]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:35.403]                       if (muffled) 
[10:21:35.403]                         invokeRestart("muffleMessage")
[10:21:35.403]                     }
[10:21:35.403]                     else if (inherits(cond, "warning")) {
[10:21:35.403]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:35.403]                       if (muffled) 
[10:21:35.403]                         invokeRestart("muffleWarning")
[10:21:35.403]                     }
[10:21:35.403]                     else if (inherits(cond, "condition")) {
[10:21:35.403]                       if (!is.null(pattern)) {
[10:21:35.403]                         computeRestarts <- base::computeRestarts
[10:21:35.403]                         grepl <- base::grepl
[10:21:35.403]                         restarts <- computeRestarts(cond)
[10:21:35.403]                         for (restart in restarts) {
[10:21:35.403]                           name <- restart$name
[10:21:35.403]                           if (is.null(name)) 
[10:21:35.403]                             next
[10:21:35.403]                           if (!grepl(pattern, name)) 
[10:21:35.403]                             next
[10:21:35.403]                           invokeRestart(restart)
[10:21:35.403]                           muffled <- TRUE
[10:21:35.403]                           break
[10:21:35.403]                         }
[10:21:35.403]                       }
[10:21:35.403]                     }
[10:21:35.403]                     invisible(muffled)
[10:21:35.403]                   }
[10:21:35.403]                   muffleCondition(cond)
[10:21:35.403]                 })
[10:21:35.403]             }))
[10:21:35.403]             future::FutureResult(value = ...future.value$value, 
[10:21:35.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:35.403]                   ...future.rng), globalenv = if (FALSE) 
[10:21:35.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:35.403]                     ...future.globalenv.names))
[10:21:35.403]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:35.403]         }, condition = base::local({
[10:21:35.403]             c <- base::c
[10:21:35.403]             inherits <- base::inherits
[10:21:35.403]             invokeRestart <- base::invokeRestart
[10:21:35.403]             length <- base::length
[10:21:35.403]             list <- base::list
[10:21:35.403]             seq.int <- base::seq.int
[10:21:35.403]             signalCondition <- base::signalCondition
[10:21:35.403]             sys.calls <- base::sys.calls
[10:21:35.403]             `[[` <- base::`[[`
[10:21:35.403]             `+` <- base::`+`
[10:21:35.403]             `<<-` <- base::`<<-`
[10:21:35.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:35.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:35.403]                   3L)]
[10:21:35.403]             }
[10:21:35.403]             function(cond) {
[10:21:35.403]                 is_error <- inherits(cond, "error")
[10:21:35.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:35.403]                   NULL)
[10:21:35.403]                 if (is_error) {
[10:21:35.403]                   sessionInformation <- function() {
[10:21:35.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:35.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:35.403]                       search = base::search(), system = base::Sys.info())
[10:21:35.403]                   }
[10:21:35.403]                   ...future.conditions[[length(...future.conditions) + 
[10:21:35.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:35.403]                     cond$call), session = sessionInformation(), 
[10:21:35.403]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:35.403]                   signalCondition(cond)
[10:21:35.403]                 }
[10:21:35.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:35.403]                 "immediateCondition"))) {
[10:21:35.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:35.403]                   ...future.conditions[[length(...future.conditions) + 
[10:21:35.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:35.403]                   if (TRUE && !signal) {
[10:21:35.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:35.403]                     {
[10:21:35.403]                       inherits <- base::inherits
[10:21:35.403]                       invokeRestart <- base::invokeRestart
[10:21:35.403]                       is.null <- base::is.null
[10:21:35.403]                       muffled <- FALSE
[10:21:35.403]                       if (inherits(cond, "message")) {
[10:21:35.403]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:35.403]                         if (muffled) 
[10:21:35.403]                           invokeRestart("muffleMessage")
[10:21:35.403]                       }
[10:21:35.403]                       else if (inherits(cond, "warning")) {
[10:21:35.403]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:35.403]                         if (muffled) 
[10:21:35.403]                           invokeRestart("muffleWarning")
[10:21:35.403]                       }
[10:21:35.403]                       else if (inherits(cond, "condition")) {
[10:21:35.403]                         if (!is.null(pattern)) {
[10:21:35.403]                           computeRestarts <- base::computeRestarts
[10:21:35.403]                           grepl <- base::grepl
[10:21:35.403]                           restarts <- computeRestarts(cond)
[10:21:35.403]                           for (restart in restarts) {
[10:21:35.403]                             name <- restart$name
[10:21:35.403]                             if (is.null(name)) 
[10:21:35.403]                               next
[10:21:35.403]                             if (!grepl(pattern, name)) 
[10:21:35.403]                               next
[10:21:35.403]                             invokeRestart(restart)
[10:21:35.403]                             muffled <- TRUE
[10:21:35.403]                             break
[10:21:35.403]                           }
[10:21:35.403]                         }
[10:21:35.403]                       }
[10:21:35.403]                       invisible(muffled)
[10:21:35.403]                     }
[10:21:35.403]                     muffleCondition(cond, pattern = "^muffle")
[10:21:35.403]                   }
[10:21:35.403]                 }
[10:21:35.403]                 else {
[10:21:35.403]                   if (TRUE) {
[10:21:35.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:35.403]                     {
[10:21:35.403]                       inherits <- base::inherits
[10:21:35.403]                       invokeRestart <- base::invokeRestart
[10:21:35.403]                       is.null <- base::is.null
[10:21:35.403]                       muffled <- FALSE
[10:21:35.403]                       if (inherits(cond, "message")) {
[10:21:35.403]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:35.403]                         if (muffled) 
[10:21:35.403]                           invokeRestart("muffleMessage")
[10:21:35.403]                       }
[10:21:35.403]                       else if (inherits(cond, "warning")) {
[10:21:35.403]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:35.403]                         if (muffled) 
[10:21:35.403]                           invokeRestart("muffleWarning")
[10:21:35.403]                       }
[10:21:35.403]                       else if (inherits(cond, "condition")) {
[10:21:35.403]                         if (!is.null(pattern)) {
[10:21:35.403]                           computeRestarts <- base::computeRestarts
[10:21:35.403]                           grepl <- base::grepl
[10:21:35.403]                           restarts <- computeRestarts(cond)
[10:21:35.403]                           for (restart in restarts) {
[10:21:35.403]                             name <- restart$name
[10:21:35.403]                             if (is.null(name)) 
[10:21:35.403]                               next
[10:21:35.403]                             if (!grepl(pattern, name)) 
[10:21:35.403]                               next
[10:21:35.403]                             invokeRestart(restart)
[10:21:35.403]                             muffled <- TRUE
[10:21:35.403]                             break
[10:21:35.403]                           }
[10:21:35.403]                         }
[10:21:35.403]                       }
[10:21:35.403]                       invisible(muffled)
[10:21:35.403]                     }
[10:21:35.403]                     muffleCondition(cond, pattern = "^muffle")
[10:21:35.403]                   }
[10:21:35.403]                 }
[10:21:35.403]             }
[10:21:35.403]         }))
[10:21:35.403]     }, error = function(ex) {
[10:21:35.403]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:35.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:35.403]                 ...future.rng), started = ...future.startTime, 
[10:21:35.403]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:35.403]             version = "1.8"), class = "FutureResult")
[10:21:35.403]     }, finally = {
[10:21:35.403]         if (!identical(...future.workdir, getwd())) 
[10:21:35.403]             setwd(...future.workdir)
[10:21:35.403]         {
[10:21:35.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:35.403]                 ...future.oldOptions$nwarnings <- NULL
[10:21:35.403]             }
[10:21:35.403]             base::options(...future.oldOptions)
[10:21:35.403]             if (.Platform$OS.type == "windows") {
[10:21:35.403]                 old_names <- names(...future.oldEnvVars)
[10:21:35.403]                 envs <- base::Sys.getenv()
[10:21:35.403]                 names <- names(envs)
[10:21:35.403]                 common <- intersect(names, old_names)
[10:21:35.403]                 added <- setdiff(names, old_names)
[10:21:35.403]                 removed <- setdiff(old_names, names)
[10:21:35.403]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:35.403]                   envs[common]]
[10:21:35.403]                 NAMES <- toupper(changed)
[10:21:35.403]                 args <- list()
[10:21:35.403]                 for (kk in seq_along(NAMES)) {
[10:21:35.403]                   name <- changed[[kk]]
[10:21:35.403]                   NAME <- NAMES[[kk]]
[10:21:35.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.403]                     next
[10:21:35.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:35.403]                 }
[10:21:35.403]                 NAMES <- toupper(added)
[10:21:35.403]                 for (kk in seq_along(NAMES)) {
[10:21:35.403]                   name <- added[[kk]]
[10:21:35.403]                   NAME <- NAMES[[kk]]
[10:21:35.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.403]                     next
[10:21:35.403]                   args[[name]] <- ""
[10:21:35.403]                 }
[10:21:35.403]                 NAMES <- toupper(removed)
[10:21:35.403]                 for (kk in seq_along(NAMES)) {
[10:21:35.403]                   name <- removed[[kk]]
[10:21:35.403]                   NAME <- NAMES[[kk]]
[10:21:35.403]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.403]                     next
[10:21:35.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:35.403]                 }
[10:21:35.403]                 if (length(args) > 0) 
[10:21:35.403]                   base::do.call(base::Sys.setenv, args = args)
[10:21:35.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:35.403]             }
[10:21:35.403]             else {
[10:21:35.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:35.403]             }
[10:21:35.403]             {
[10:21:35.403]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:35.403]                   0L) {
[10:21:35.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:35.403]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:35.403]                   base::options(opts)
[10:21:35.403]                 }
[10:21:35.403]                 {
[10:21:35.403]                   {
[10:21:35.403]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:35.403]                     NULL
[10:21:35.403]                   }
[10:21:35.403]                   options(future.plan = NULL)
[10:21:35.403]                   if (is.na(NA_character_)) 
[10:21:35.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:35.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:35.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:35.403]                     .init = FALSE)
[10:21:35.403]                 }
[10:21:35.403]             }
[10:21:35.403]         }
[10:21:35.403]     })
[10:21:35.403]     if (TRUE) {
[10:21:35.403]         base::sink(type = "output", split = FALSE)
[10:21:35.403]         if (TRUE) {
[10:21:35.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:35.403]         }
[10:21:35.403]         else {
[10:21:35.403]             ...future.result["stdout"] <- base::list(NULL)
[10:21:35.403]         }
[10:21:35.403]         base::close(...future.stdout)
[10:21:35.403]         ...future.stdout <- NULL
[10:21:35.403]     }
[10:21:35.403]     ...future.result$conditions <- ...future.conditions
[10:21:35.403]     ...future.result$finished <- base::Sys.time()
[10:21:35.403]     ...future.result
[10:21:35.403] }
[10:21:35.538]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.454] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[10:21:35.539]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.454] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[10:21:35.539]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.455] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[10:21:35.539]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.455] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[10:21:35.539]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.455] MultisessionFuture started
[10:21:35.539]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.456] - Launch lazy future ... done
[10:21:35.539]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.456] run() for ‘MultisessionFuture’ ... done
[10:21:35.539]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.456] result() for ClusterFuture ...
[10:21:35.539]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.456] receiveMessageFromWorker() for ClusterFuture ...
[10:21:35.540]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.456] - Validating connection of MultisessionFuture
[10:21:35.540]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.528] - received message: FutureResult
[10:21:35.540]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.528] - Received FutureResult
[10:21:35.540]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.528] - Erased future from FutureRegistry
[10:21:35.540]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.529] result() for ClusterFuture ...
[10:21:35.540]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.529] - result already collected: FutureResult
[10:21:35.540]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.529] result() for ClusterFuture ... done
[10:21:35.540]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.529] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:35.541]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.529] result() for ClusterFuture ... done
[10:21:35.541]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.529] result() for ClusterFuture ...
[10:21:35.541]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.529] - result already collected: FutureResult
[10:21:35.541]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.529] result() for ClusterFuture ... done
[10:21:35.541] signalConditions() ... done
[10:21:35.541] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ignore’
[10:21:35.542] Searching for globals...
[10:21:35.542] - globals found: [3] ‘{’, ‘plan’, ‘sequential’
[10:21:35.543] Searching for globals ... DONE
[10:21:35.543] Resolving globals: FALSE
[10:21:35.543] 
[10:21:35.543] - packages: [1] ‘future’
[10:21:35.543] getGlobalsAndPackages() ... DONE
[10:21:35.543] run() for ‘Future’ ...
[10:21:35.544] - state: ‘created’
[10:21:35.544] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:35.544] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:35.544] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:35.544]   - Field: ‘label’
[10:21:35.544]   - Field: ‘local’
[10:21:35.544]   - Field: ‘owner’
[10:21:35.544]   - Field: ‘envir’
[10:21:35.544]   - Field: ‘packages’
[10:21:35.545]   - Field: ‘gc’
[10:21:35.545]   - Field: ‘conditions’
[10:21:35.545]   - Field: ‘expr’
[10:21:35.545]   - Field: ‘uuid’
[10:21:35.545]   - Field: ‘seed’
[10:21:35.545]   - Field: ‘version’
[10:21:35.545]   - Field: ‘result’
[10:21:35.545]   - Field: ‘asynchronous’
[10:21:35.545]   - Field: ‘calls’
[10:21:35.545]   - Field: ‘globals’
[10:21:35.545]   - Field: ‘stdout’
[10:21:35.546]   - Field: ‘earlySignal’
[10:21:35.546]   - Field: ‘lazy’
[10:21:35.546]   - Field: ‘state’
[10:21:35.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:35.546] - Launch lazy future ...
[10:21:35.546] Packages needed by the future expression (n = 1): ‘future’
[10:21:35.546] Packages needed by future strategies (n = 1): ‘future’
[10:21:35.547] {
[10:21:35.547]     {
[10:21:35.547]         {
[10:21:35.547]             ...future.startTime <- base::Sys.time()
[10:21:35.547]             {
[10:21:35.547]                 {
[10:21:35.547]                   {
[10:21:35.547]                     {
[10:21:35.547]                       base::local({
[10:21:35.547]                         has_future <- base::requireNamespace("future", 
[10:21:35.547]                           quietly = TRUE)
[10:21:35.547]                         if (has_future) {
[10:21:35.547]                           ns <- base::getNamespace("future")
[10:21:35.547]                           version <- ns[[".package"]][["version"]]
[10:21:35.547]                           if (is.null(version)) 
[10:21:35.547]                             version <- utils::packageVersion("future")
[10:21:35.547]                         }
[10:21:35.547]                         else {
[10:21:35.547]                           version <- NULL
[10:21:35.547]                         }
[10:21:35.547]                         if (!has_future || version < "1.8.0") {
[10:21:35.547]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:35.547]                             "", base::R.version$version.string), 
[10:21:35.547]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:35.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:35.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:35.547]                               "release", "version")], collapse = " "), 
[10:21:35.547]                             hostname = base::Sys.info()[["nodename"]])
[10:21:35.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:35.547]                             info)
[10:21:35.547]                           info <- base::paste(info, collapse = "; ")
[10:21:35.547]                           if (!has_future) {
[10:21:35.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:35.547]                               info)
[10:21:35.547]                           }
[10:21:35.547]                           else {
[10:21:35.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:35.547]                               info, version)
[10:21:35.547]                           }
[10:21:35.547]                           base::stop(msg)
[10:21:35.547]                         }
[10:21:35.547]                       })
[10:21:35.547]                     }
[10:21:35.547]                     base::local({
[10:21:35.547]                       for (pkg in "future") {
[10:21:35.547]                         base::loadNamespace(pkg)
[10:21:35.547]                         base::library(pkg, character.only = TRUE)
[10:21:35.547]                       }
[10:21:35.547]                     })
[10:21:35.547]                   }
[10:21:35.547]                   ...future.strategy.old <- future::plan("list")
[10:21:35.547]                   options(future.plan = NULL)
[10:21:35.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:35.547]                   future::plan(list(function (..., workers = availableCores(), 
[10:21:35.547]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:21:35.547]                     envir = parent.frame()) 
[10:21:35.547]                   {
[10:21:35.547]                     if (is.function(workers)) 
[10:21:35.547]                       workers <- workers()
[10:21:35.547]                     workers <- structure(as.integer(workers), 
[10:21:35.547]                       class = class(workers))
[10:21:35.547]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:21:35.547]                       workers >= 1)
[10:21:35.547]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:21:35.547]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:21:35.547]                     }
[10:21:35.547]                     future <- MultisessionFuture(..., workers = workers, 
[10:21:35.547]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:21:35.547]                       envir = envir)
[10:21:35.547]                     if (!future$lazy) 
[10:21:35.547]                       future <- run(future)
[10:21:35.547]                     invisible(future)
[10:21:35.547]                   }), .cleanup = FALSE, .init = FALSE)
[10:21:35.547]                 }
[10:21:35.547]                 ...future.workdir <- getwd()
[10:21:35.547]             }
[10:21:35.547]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:35.547]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:35.547]         }
[10:21:35.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = "ignore", 
[10:21:35.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:35.547]             future.globals.onMissing = "ignore", future.globals.onReference = NULL, 
[10:21:35.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:35.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:35.547]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:35.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:35.547]             base::names(...future.oldOptions))
[10:21:35.547]     }
[10:21:35.547]     if (FALSE) {
[10:21:35.547]     }
[10:21:35.547]     else {
[10:21:35.547]         if (TRUE) {
[10:21:35.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:35.547]                 open = "w")
[10:21:35.547]         }
[10:21:35.547]         else {
[10:21:35.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:35.547]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:35.547]         }
[10:21:35.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:35.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:35.547]             base::sink(type = "output", split = FALSE)
[10:21:35.547]             base::close(...future.stdout)
[10:21:35.547]         }, add = TRUE)
[10:21:35.547]     }
[10:21:35.547]     ...future.frame <- base::sys.nframe()
[10:21:35.547]     ...future.conditions <- base::list()
[10:21:35.547]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:35.547]     if (FALSE) {
[10:21:35.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:35.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:35.547]     }
[10:21:35.547]     ...future.result <- base::tryCatch({
[10:21:35.547]         base::withCallingHandlers({
[10:21:35.547]             ...future.value <- base::withVisible(base::local({
[10:21:35.547]                 plan(sequential)
[10:21:35.547]             }))
[10:21:35.547]             future::FutureResult(value = ...future.value$value, 
[10:21:35.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:35.547]                   ...future.rng), globalenv = if (FALSE) 
[10:21:35.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:35.547]                     ...future.globalenv.names))
[10:21:35.547]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:35.547]         }, condition = base::local({
[10:21:35.547]             c <- base::c
[10:21:35.547]             inherits <- base::inherits
[10:21:35.547]             invokeRestart <- base::invokeRestart
[10:21:35.547]             length <- base::length
[10:21:35.547]             list <- base::list
[10:21:35.547]             seq.int <- base::seq.int
[10:21:35.547]             signalCondition <- base::signalCondition
[10:21:35.547]             sys.calls <- base::sys.calls
[10:21:35.547]             `[[` <- base::`[[`
[10:21:35.547]             `+` <- base::`+`
[10:21:35.547]             `<<-` <- base::`<<-`
[10:21:35.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:35.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:35.547]                   3L)]
[10:21:35.547]             }
[10:21:35.547]             function(cond) {
[10:21:35.547]                 is_error <- inherits(cond, "error")
[10:21:35.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:35.547]                   NULL)
[10:21:35.547]                 if (is_error) {
[10:21:35.547]                   sessionInformation <- function() {
[10:21:35.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:35.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:35.547]                       search = base::search(), system = base::Sys.info())
[10:21:35.547]                   }
[10:21:35.547]                   ...future.conditions[[length(...future.conditions) + 
[10:21:35.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:35.547]                     cond$call), session = sessionInformation(), 
[10:21:35.547]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:35.547]                   signalCondition(cond)
[10:21:35.547]                 }
[10:21:35.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:35.547]                 "immediateCondition"))) {
[10:21:35.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:35.547]                   ...future.conditions[[length(...future.conditions) + 
[10:21:35.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:35.547]                   if (TRUE && !signal) {
[10:21:35.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:35.547]                     {
[10:21:35.547]                       inherits <- base::inherits
[10:21:35.547]                       invokeRestart <- base::invokeRestart
[10:21:35.547]                       is.null <- base::is.null
[10:21:35.547]                       muffled <- FALSE
[10:21:35.547]                       if (inherits(cond, "message")) {
[10:21:35.547]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:35.547]                         if (muffled) 
[10:21:35.547]                           invokeRestart("muffleMessage")
[10:21:35.547]                       }
[10:21:35.547]                       else if (inherits(cond, "warning")) {
[10:21:35.547]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:35.547]                         if (muffled) 
[10:21:35.547]                           invokeRestart("muffleWarning")
[10:21:35.547]                       }
[10:21:35.547]                       else if (inherits(cond, "condition")) {
[10:21:35.547]                         if (!is.null(pattern)) {
[10:21:35.547]                           computeRestarts <- base::computeRestarts
[10:21:35.547]                           grepl <- base::grepl
[10:21:35.547]                           restarts <- computeRestarts(cond)
[10:21:35.547]                           for (restart in restarts) {
[10:21:35.547]                             name <- restart$name
[10:21:35.547]                             if (is.null(name)) 
[10:21:35.547]                               next
[10:21:35.547]                             if (!grepl(pattern, name)) 
[10:21:35.547]                               next
[10:21:35.547]                             invokeRestart(restart)
[10:21:35.547]                             muffled <- TRUE
[10:21:35.547]                             break
[10:21:35.547]                           }
[10:21:35.547]                         }
[10:21:35.547]                       }
[10:21:35.547]                       invisible(muffled)
[10:21:35.547]                     }
[10:21:35.547]                     muffleCondition(cond, pattern = "^muffle")
[10:21:35.547]                   }
[10:21:35.547]                 }
[10:21:35.547]                 else {
[10:21:35.547]                   if (TRUE) {
[10:21:35.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:35.547]                     {
[10:21:35.547]                       inherits <- base::inherits
[10:21:35.547]                       invokeRestart <- base::invokeRestart
[10:21:35.547]                       is.null <- base::is.null
[10:21:35.547]                       muffled <- FALSE
[10:21:35.547]                       if (inherits(cond, "message")) {
[10:21:35.547]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:35.547]                         if (muffled) 
[10:21:35.547]                           invokeRestart("muffleMessage")
[10:21:35.547]                       }
[10:21:35.547]                       else if (inherits(cond, "warning")) {
[10:21:35.547]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:35.547]                         if (muffled) 
[10:21:35.547]                           invokeRestart("muffleWarning")
[10:21:35.547]                       }
[10:21:35.547]                       else if (inherits(cond, "condition")) {
[10:21:35.547]                         if (!is.null(pattern)) {
[10:21:35.547]                           computeRestarts <- base::computeRestarts
[10:21:35.547]                           grepl <- base::grepl
[10:21:35.547]                           restarts <- computeRestarts(cond)
[10:21:35.547]                           for (restart in restarts) {
[10:21:35.547]                             name <- restart$name
[10:21:35.547]                             if (is.null(name)) 
[10:21:35.547]                               next
[10:21:35.547]                             if (!grepl(pattern, name)) 
[10:21:35.547]                               next
[10:21:35.547]                             invokeRestart(restart)
[10:21:35.547]                             muffled <- TRUE
[10:21:35.547]                             break
[10:21:35.547]                           }
[10:21:35.547]                         }
[10:21:35.547]                       }
[10:21:35.547]                       invisible(muffled)
[10:21:35.547]                     }
[10:21:35.547]                     muffleCondition(cond, pattern = "^muffle")
[10:21:35.547]                   }
[10:21:35.547]                 }
[10:21:35.547]             }
[10:21:35.547]         }))
[10:21:35.547]     }, error = function(ex) {
[10:21:35.547]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:35.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:35.547]                 ...future.rng), started = ...future.startTime, 
[10:21:35.547]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:35.547]             version = "1.8"), class = "FutureResult")
[10:21:35.547]     }, finally = {
[10:21:35.547]         if (!identical(...future.workdir, getwd())) 
[10:21:35.547]             setwd(...future.workdir)
[10:21:35.547]         {
[10:21:35.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:35.547]                 ...future.oldOptions$nwarnings <- NULL
[10:21:35.547]             }
[10:21:35.547]             base::options(...future.oldOptions)
[10:21:35.547]             if (.Platform$OS.type == "windows") {
[10:21:35.547]                 old_names <- names(...future.oldEnvVars)
[10:21:35.547]                 envs <- base::Sys.getenv()
[10:21:35.547]                 names <- names(envs)
[10:21:35.547]                 common <- intersect(names, old_names)
[10:21:35.547]                 added <- setdiff(names, old_names)
[10:21:35.547]                 removed <- setdiff(old_names, names)
[10:21:35.547]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:35.547]                   envs[common]]
[10:21:35.547]                 NAMES <- toupper(changed)
[10:21:35.547]                 args <- list()
[10:21:35.547]                 for (kk in seq_along(NAMES)) {
[10:21:35.547]                   name <- changed[[kk]]
[10:21:35.547]                   NAME <- NAMES[[kk]]
[10:21:35.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.547]                     next
[10:21:35.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:35.547]                 }
[10:21:35.547]                 NAMES <- toupper(added)
[10:21:35.547]                 for (kk in seq_along(NAMES)) {
[10:21:35.547]                   name <- added[[kk]]
[10:21:35.547]                   NAME <- NAMES[[kk]]
[10:21:35.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.547]                     next
[10:21:35.547]                   args[[name]] <- ""
[10:21:35.547]                 }
[10:21:35.547]                 NAMES <- toupper(removed)
[10:21:35.547]                 for (kk in seq_along(NAMES)) {
[10:21:35.547]                   name <- removed[[kk]]
[10:21:35.547]                   NAME <- NAMES[[kk]]
[10:21:35.547]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:35.547]                     next
[10:21:35.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:35.547]                 }
[10:21:35.547]                 if (length(args) > 0) 
[10:21:35.547]                   base::do.call(base::Sys.setenv, args = args)
[10:21:35.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:35.547]             }
[10:21:35.547]             else {
[10:21:35.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:35.547]             }
[10:21:35.547]             {
[10:21:35.547]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:35.547]                   0L) {
[10:21:35.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:35.547]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:35.547]                   base::options(opts)
[10:21:35.547]                 }
[10:21:35.547]                 {
[10:21:35.547]                   {
[10:21:35.547]                     NULL
[10:21:35.547]                     RNGkind("Mersenne-Twister")
[10:21:35.547]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:35.547]                       inherits = FALSE)
[10:21:35.547]                   }
[10:21:35.547]                   options(future.plan = NULL)
[10:21:35.547]                   if (is.na(NA_character_)) 
[10:21:35.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:35.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:35.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:35.547]                     .init = FALSE)
[10:21:35.547]                 }
[10:21:35.547]             }
[10:21:35.547]         }
[10:21:35.547]     })
[10:21:35.547]     if (TRUE) {
[10:21:35.547]         base::sink(type = "output", split = FALSE)
[10:21:35.547]         if (TRUE) {
[10:21:35.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:35.547]         }
[10:21:35.547]         else {
[10:21:35.547]             ...future.result["stdout"] <- base::list(NULL)
[10:21:35.547]         }
[10:21:35.547]         base::close(...future.stdout)
[10:21:35.547]         ...future.stdout <- NULL
[10:21:35.547]     }
[10:21:35.547]     ...future.result$conditions <- ...future.conditions
[10:21:35.547]     ...future.result$finished <- base::Sys.time()
[10:21:35.547]     ...future.result
[10:21:35.547] }
[10:21:35.549] plan(): Setting new future strategy stack:
[10:21:35.549] List of future strategies:
[10:21:35.549] 1. multisession:
[10:21:35.549]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:35.549]    - tweaked: FALSE
[10:21:35.549]    - call: plan(list(sequential, strategy))
[10:21:35.551] plan(): nbrOfWorkers() = 2
[10:21:35.566] plan(): Setting new future strategy stack:
[10:21:35.566] List of future strategies:
[10:21:35.566] 1. sequential:
[10:21:35.566]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:35.566]    - tweaked: FALSE
[10:21:35.566]    - call: plan(list(sequential, strategy))
[10:21:35.566] 2. multisession:
[10:21:35.566]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:35.566]    - tweaked: FALSE
[10:21:35.566]    - call: plan(list(sequential, strategy))
[10:21:35.567] plan(): nbrOfWorkers() = 1
[10:21:35.567] SequentialFuture started (and completed)
[10:21:35.567] signalConditions() ...
[10:21:35.567]  - include = ‘immediateCondition’
[10:21:35.568]  - exclude = 
[10:21:35.568]  - resignal = FALSE
[10:21:35.568]  - Number of conditions: 3
[10:21:35.568] signalConditions() ... done
[10:21:35.568] - Launch lazy future ... done
[10:21:35.568] run() for ‘SequentialFuture’ ... done
[10:21:35.569] signalConditions() ...
[10:21:35.569]  - include = ‘immediateCondition’
[10:21:35.569]  - exclude = 
[10:21:35.569]  - resignal = FALSE
[10:21:35.569]  - Number of conditions: 3
[10:21:35.569] signalConditions() ... done
[10:21:35.569] Future state: ‘finished’
[10:21:35.570] signalConditions() ...
[10:21:35.570]  - include = ‘condition’
[10:21:35.570]  - exclude = ‘immediateCondition’
[10:21:35.570]  - resignal = TRUE
[10:21:35.570]  - Number of conditions: 3
[10:21:35.570]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.551] plan(): Setting new future strategy stack:
[10:21:35.570]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.551] List of future strategies:
[10:21:35.551] 1. sequential:
[10:21:35.551]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:35.551]    - tweaked: FALSE
[10:21:35.551]    - call: plan(sequential)
[10:21:35.571]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:35.565] plan(): nbrOfWorkers() = 1
[10:21:35.571] signalConditions() ... done
List of future strategies:
1. multisession:
   - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
   - tweaked: FALSE
   - call: plan(list(sequential, strategy))
- Strategy: multisession ... DONE
> 
> 
> message("*** Globals w/ non-standard evaluation (NSE) ... DONE")
*** Globals w/ non-standard evaluation (NSE) ... DONE
> 
> source("incl/end.R")
[10:21:35.572] plan(): Setting new future strategy stack:
[10:21:35.572] List of future strategies:
[10:21:35.572] 1. FutureStrategy:
[10:21:35.572]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:35.572]    - tweaked: FALSE
[10:21:35.572]    - call: future::plan(oplan)
[10:21:35.573] plan(): nbrOfWorkers() = 1
> 
