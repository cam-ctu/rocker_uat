
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:28:26.909] plan(): Setting new future strategy stack:
[08:28:26.910] List of future strategies:
[08:28:26.910] 1. sequential:
[08:28:26.910]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:26.910]    - tweaked: FALSE
[08:28:26.910]    - call: future::plan("sequential")
[08:28:26.925] plan(): nbrOfWorkers() = 1
> library("listenv")
> plan(multicore)
[08:28:26.943] plan(): Setting new future strategy stack:
[08:28:26.943] List of future strategies:
[08:28:26.943] 1. multicore:
[08:28:26.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:26.943]    - tweaked: FALSE
[08:28:26.943]    - call: plan(multicore)
[08:28:26.956] plan(): nbrOfWorkers() = 2
> 
> message("*** multicore() ...")
*** multicore() ...
> 
> for (cores in 1:min(2L, availableCores("multicore"))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   if (!supportsMulticore()) {
+     message(sprintf("Multicore futures are not supporting on '%s'. Falling back to use synchronous sequential futures", .Platform$OS.type))
+   }
+ 
+   nworkers <- nbrOfWorkers()
+   message("Number of workers: ", nworkers)
+   stopifnot(nworkers == cores)
+   
+   for (globals in c(FALSE, TRUE)) {
+ 
+     message(sprintf("*** multicore(..., globals = %s) without globals", globals))
+   
+     f <- multicore({
+       42L
+     }, globals = globals)
+     stopifnot(inherits(f, "MulticoreFuture") || ((cores ==1 || !supportsMulticore()) && inherits(f, "SequentialFuture")))
+   
+     print(resolved(f))
+     y <- value(f)
+     print(y)
+     stopifnot(y == 42L)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals", globals))
+     ## A global variable
+     a <- 0
+     f <- multicore({
+       b <- 3
+       c <- 2
+       a * b * c
+     }, globals = globals)
+     print(f)
+   
+   
+     ## A multicore future is evaluated in a separated
+     ## forked process.  Changing the value of a global
+     ## variable should not affect the result of the
+     ## future.
+     a <- 7  ## Make sure globals are frozen
+     v <- value(f)
+     print(v)
+     stopifnot(v == 0)
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) with globals and blocking", globals))
+     x <- listenv()
+     for (ii in 1:4) {
+       message(sprintf(" - Creating multicore future #%d ...", ii))
+       x[[ii]] <- multicore({ ii }, globals = globals)
+     }
+     message(sprintf(" - Resolving %d multicore futures", length(x)))
+     v <- sapply(x, FUN = value)
+     stopifnot(all(v == 1:4))
+   
+   
+     message(sprintf("*** multicore(..., globals = %s) and errors", globals))
+     f <- multicore({
+       stop("Whoops!")
+       1
+     }, globals = globals)
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "simpleError"))
+   
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+   
+     ## Error is repeated
+     res <- try(value(f), silent = TRUE)
+     print(res)
+     stopifnot(inherits(res, "try-error"))
+ 
+     ## Custom error class
+     f <- multicore({
+       stop(structure(list(message = "boom"),
+                      class = c("MyError", "error", "condition")))
+     })
+     print(f)
+     v <- value(f, signal = FALSE)
+     print(v)
+     stopifnot(inherits(v, "error"), inherits(v, "MyError"))
+   
+     ## Make sure error is signaled
+     res <- tryCatch(value(f), error = identity)
+     stopifnot(inherits(res, "error"))
+   
+     ## Issue #200: Custom condition class attributes are lost 
+     stopifnot(inherits(res, "MyError"))    
+   } # for (globals ...)
+ 
+ 
+   message("*** multicore(..., workers = 1L) ...")
+ 
+   a <- 2
+   b <- 3
+   yTruth <- a * b
+ 
+   f <- multicore({ a * b }, globals = TRUE, workers = 1L)
+   rm(list = c("a", "b"))
+ 
+   v <- value(f)
+   print(v)
+   stopifnot(v == yTruth)
+ 
+   message("*** multicore(..., workers = 1L) ... DONE")
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Number of workers: 1
*** multicore(..., globals = FALSE) without globals
[08:28:27.009] getGlobalsAndPackages() ...
[08:28:27.009] Not searching for globals
[08:28:27.010] - globals: [0] <none>
[08:28:27.010] getGlobalsAndPackages() ... DONE
[08:28:27.011] Packages needed by the future expression (n = 0): <none>
[08:28:27.011] Packages needed by future strategies (n = 0): <none>
[08:28:27.011] {
[08:28:27.011]     {
[08:28:27.011]         {
[08:28:27.011]             ...future.startTime <- base::Sys.time()
[08:28:27.011]             {
[08:28:27.011]                 {
[08:28:27.011]                   {
[08:28:27.011]                     base::local({
[08:28:27.011]                       has_future <- base::requireNamespace("future", 
[08:28:27.011]                         quietly = TRUE)
[08:28:27.011]                       if (has_future) {
[08:28:27.011]                         ns <- base::getNamespace("future")
[08:28:27.011]                         version <- ns[[".package"]][["version"]]
[08:28:27.011]                         if (is.null(version)) 
[08:28:27.011]                           version <- utils::packageVersion("future")
[08:28:27.011]                       }
[08:28:27.011]                       else {
[08:28:27.011]                         version <- NULL
[08:28:27.011]                       }
[08:28:27.011]                       if (!has_future || version < "1.8.0") {
[08:28:27.011]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.011]                           "", base::R.version$version.string), 
[08:28:27.011]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.011]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.011]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.011]                             "release", "version")], collapse = " "), 
[08:28:27.011]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.011]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.011]                           info)
[08:28:27.011]                         info <- base::paste(info, collapse = "; ")
[08:28:27.011]                         if (!has_future) {
[08:28:27.011]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.011]                             info)
[08:28:27.011]                         }
[08:28:27.011]                         else {
[08:28:27.011]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.011]                             info, version)
[08:28:27.011]                         }
[08:28:27.011]                         base::stop(msg)
[08:28:27.011]                       }
[08:28:27.011]                     })
[08:28:27.011]                   }
[08:28:27.011]                   ...future.strategy.old <- future::plan("list")
[08:28:27.011]                   options(future.plan = NULL)
[08:28:27.011]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.011]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.011]                 }
[08:28:27.011]                 ...future.workdir <- getwd()
[08:28:27.011]             }
[08:28:27.011]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.011]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.011]         }
[08:28:27.011]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.011]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.011]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.011]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.011]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.011]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.011]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.011]             base::names(...future.oldOptions))
[08:28:27.011]     }
[08:28:27.011]     if (FALSE) {
[08:28:27.011]     }
[08:28:27.011]     else {
[08:28:27.011]         if (TRUE) {
[08:28:27.011]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.011]                 open = "w")
[08:28:27.011]         }
[08:28:27.011]         else {
[08:28:27.011]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.011]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.011]         }
[08:28:27.011]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.011]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.011]             base::sink(type = "output", split = FALSE)
[08:28:27.011]             base::close(...future.stdout)
[08:28:27.011]         }, add = TRUE)
[08:28:27.011]     }
[08:28:27.011]     ...future.frame <- base::sys.nframe()
[08:28:27.011]     ...future.conditions <- base::list()
[08:28:27.011]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.011]     if (FALSE) {
[08:28:27.011]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.011]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.011]     }
[08:28:27.011]     ...future.result <- base::tryCatch({
[08:28:27.011]         base::withCallingHandlers({
[08:28:27.011]             ...future.value <- base::withVisible(base::local({
[08:28:27.011]                 42L
[08:28:27.011]             }))
[08:28:27.011]             future::FutureResult(value = ...future.value$value, 
[08:28:27.011]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.011]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.011]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.011]                     ...future.globalenv.names))
[08:28:27.011]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.011]         }, condition = base::local({
[08:28:27.011]             c <- base::c
[08:28:27.011]             inherits <- base::inherits
[08:28:27.011]             invokeRestart <- base::invokeRestart
[08:28:27.011]             length <- base::length
[08:28:27.011]             list <- base::list
[08:28:27.011]             seq.int <- base::seq.int
[08:28:27.011]             signalCondition <- base::signalCondition
[08:28:27.011]             sys.calls <- base::sys.calls
[08:28:27.011]             `[[` <- base::`[[`
[08:28:27.011]             `+` <- base::`+`
[08:28:27.011]             `<<-` <- base::`<<-`
[08:28:27.011]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.011]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.011]                   3L)]
[08:28:27.011]             }
[08:28:27.011]             function(cond) {
[08:28:27.011]                 is_error <- inherits(cond, "error")
[08:28:27.011]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.011]                   NULL)
[08:28:27.011]                 if (is_error) {
[08:28:27.011]                   sessionInformation <- function() {
[08:28:27.011]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.011]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.011]                       search = base::search(), system = base::Sys.info())
[08:28:27.011]                   }
[08:28:27.011]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.011]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.011]                     cond$call), session = sessionInformation(), 
[08:28:27.011]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.011]                   signalCondition(cond)
[08:28:27.011]                 }
[08:28:27.011]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.011]                 "immediateCondition"))) {
[08:28:27.011]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.011]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.011]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.011]                   if (TRUE && !signal) {
[08:28:27.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.011]                     {
[08:28:27.011]                       inherits <- base::inherits
[08:28:27.011]                       invokeRestart <- base::invokeRestart
[08:28:27.011]                       is.null <- base::is.null
[08:28:27.011]                       muffled <- FALSE
[08:28:27.011]                       if (inherits(cond, "message")) {
[08:28:27.011]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.011]                         if (muffled) 
[08:28:27.011]                           invokeRestart("muffleMessage")
[08:28:27.011]                       }
[08:28:27.011]                       else if (inherits(cond, "warning")) {
[08:28:27.011]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.011]                         if (muffled) 
[08:28:27.011]                           invokeRestart("muffleWarning")
[08:28:27.011]                       }
[08:28:27.011]                       else if (inherits(cond, "condition")) {
[08:28:27.011]                         if (!is.null(pattern)) {
[08:28:27.011]                           computeRestarts <- base::computeRestarts
[08:28:27.011]                           grepl <- base::grepl
[08:28:27.011]                           restarts <- computeRestarts(cond)
[08:28:27.011]                           for (restart in restarts) {
[08:28:27.011]                             name <- restart$name
[08:28:27.011]                             if (is.null(name)) 
[08:28:27.011]                               next
[08:28:27.011]                             if (!grepl(pattern, name)) 
[08:28:27.011]                               next
[08:28:27.011]                             invokeRestart(restart)
[08:28:27.011]                             muffled <- TRUE
[08:28:27.011]                             break
[08:28:27.011]                           }
[08:28:27.011]                         }
[08:28:27.011]                       }
[08:28:27.011]                       invisible(muffled)
[08:28:27.011]                     }
[08:28:27.011]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.011]                   }
[08:28:27.011]                 }
[08:28:27.011]                 else {
[08:28:27.011]                   if (TRUE) {
[08:28:27.011]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.011]                     {
[08:28:27.011]                       inherits <- base::inherits
[08:28:27.011]                       invokeRestart <- base::invokeRestart
[08:28:27.011]                       is.null <- base::is.null
[08:28:27.011]                       muffled <- FALSE
[08:28:27.011]                       if (inherits(cond, "message")) {
[08:28:27.011]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.011]                         if (muffled) 
[08:28:27.011]                           invokeRestart("muffleMessage")
[08:28:27.011]                       }
[08:28:27.011]                       else if (inherits(cond, "warning")) {
[08:28:27.011]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.011]                         if (muffled) 
[08:28:27.011]                           invokeRestart("muffleWarning")
[08:28:27.011]                       }
[08:28:27.011]                       else if (inherits(cond, "condition")) {
[08:28:27.011]                         if (!is.null(pattern)) {
[08:28:27.011]                           computeRestarts <- base::computeRestarts
[08:28:27.011]                           grepl <- base::grepl
[08:28:27.011]                           restarts <- computeRestarts(cond)
[08:28:27.011]                           for (restart in restarts) {
[08:28:27.011]                             name <- restart$name
[08:28:27.011]                             if (is.null(name)) 
[08:28:27.011]                               next
[08:28:27.011]                             if (!grepl(pattern, name)) 
[08:28:27.011]                               next
[08:28:27.011]                             invokeRestart(restart)
[08:28:27.011]                             muffled <- TRUE
[08:28:27.011]                             break
[08:28:27.011]                           }
[08:28:27.011]                         }
[08:28:27.011]                       }
[08:28:27.011]                       invisible(muffled)
[08:28:27.011]                     }
[08:28:27.011]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.011]                   }
[08:28:27.011]                 }
[08:28:27.011]             }
[08:28:27.011]         }))
[08:28:27.011]     }, error = function(ex) {
[08:28:27.011]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.011]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.011]                 ...future.rng), started = ...future.startTime, 
[08:28:27.011]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.011]             version = "1.8"), class = "FutureResult")
[08:28:27.011]     }, finally = {
[08:28:27.011]         if (!identical(...future.workdir, getwd())) 
[08:28:27.011]             setwd(...future.workdir)
[08:28:27.011]         {
[08:28:27.011]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.011]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.011]             }
[08:28:27.011]             base::options(...future.oldOptions)
[08:28:27.011]             if (.Platform$OS.type == "windows") {
[08:28:27.011]                 old_names <- names(...future.oldEnvVars)
[08:28:27.011]                 envs <- base::Sys.getenv()
[08:28:27.011]                 names <- names(envs)
[08:28:27.011]                 common <- intersect(names, old_names)
[08:28:27.011]                 added <- setdiff(names, old_names)
[08:28:27.011]                 removed <- setdiff(old_names, names)
[08:28:27.011]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.011]                   envs[common]]
[08:28:27.011]                 NAMES <- toupper(changed)
[08:28:27.011]                 args <- list()
[08:28:27.011]                 for (kk in seq_along(NAMES)) {
[08:28:27.011]                   name <- changed[[kk]]
[08:28:27.011]                   NAME <- NAMES[[kk]]
[08:28:27.011]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.011]                     next
[08:28:27.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.011]                 }
[08:28:27.011]                 NAMES <- toupper(added)
[08:28:27.011]                 for (kk in seq_along(NAMES)) {
[08:28:27.011]                   name <- added[[kk]]
[08:28:27.011]                   NAME <- NAMES[[kk]]
[08:28:27.011]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.011]                     next
[08:28:27.011]                   args[[name]] <- ""
[08:28:27.011]                 }
[08:28:27.011]                 NAMES <- toupper(removed)
[08:28:27.011]                 for (kk in seq_along(NAMES)) {
[08:28:27.011]                   name <- removed[[kk]]
[08:28:27.011]                   NAME <- NAMES[[kk]]
[08:28:27.011]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.011]                     next
[08:28:27.011]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.011]                 }
[08:28:27.011]                 if (length(args) > 0) 
[08:28:27.011]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.011]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.011]             }
[08:28:27.011]             else {
[08:28:27.011]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.011]             }
[08:28:27.011]             {
[08:28:27.011]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.011]                   0L) {
[08:28:27.011]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.011]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.011]                   base::options(opts)
[08:28:27.011]                 }
[08:28:27.011]                 {
[08:28:27.011]                   {
[08:28:27.011]                     NULL
[08:28:27.011]                     RNGkind("Mersenne-Twister")
[08:28:27.011]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.011]                       inherits = FALSE)
[08:28:27.011]                   }
[08:28:27.011]                   options(future.plan = NULL)
[08:28:27.011]                   if (is.na(NA_character_)) 
[08:28:27.011]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.011]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.011]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.011]                     .init = FALSE)
[08:28:27.011]                 }
[08:28:27.011]             }
[08:28:27.011]         }
[08:28:27.011]     })
[08:28:27.011]     if (TRUE) {
[08:28:27.011]         base::sink(type = "output", split = FALSE)
[08:28:27.011]         if (TRUE) {
[08:28:27.011]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.011]         }
[08:28:27.011]         else {
[08:28:27.011]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.011]         }
[08:28:27.011]         base::close(...future.stdout)
[08:28:27.011]         ...future.stdout <- NULL
[08:28:27.011]     }
[08:28:27.011]     ...future.result$conditions <- ...future.conditions
[08:28:27.011]     ...future.result$finished <- base::Sys.time()
[08:28:27.011]     ...future.result
[08:28:27.011] }
[08:28:27.014] plan(): Setting new future strategy stack:
[08:28:27.014] List of future strategies:
[08:28:27.014] 1. sequential:
[08:28:27.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.014]    - tweaked: FALSE
[08:28:27.014]    - call: NULL
[08:28:27.014] plan(): nbrOfWorkers() = 1
[08:28:27.015] plan(): Setting new future strategy stack:
[08:28:27.015] List of future strategies:
[08:28:27.015] 1. multicore:
[08:28:27.015]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.015]    - tweaked: FALSE
[08:28:27.015]    - call: plan(multicore)
[08:28:27.017] plan(): nbrOfWorkers() = 1
[08:28:27.017] SequentialFuture started (and completed)
[08:28:27.018] resolved() for ‘SequentialFuture’ ...
[08:28:27.018] - state: ‘finished’
[08:28:27.018] - run: TRUE
[08:28:27.018] - result: ‘FutureResult’
[08:28:27.018] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = FALSE) with globals
[08:28:27.020] getGlobalsAndPackages() ...
[08:28:27.020] Not searching for globals
[08:28:27.020] - globals: [0] <none>
[08:28:27.020] getGlobalsAndPackages() ... DONE
[08:28:27.020] Packages needed by the future expression (n = 0): <none>
[08:28:27.021] Packages needed by future strategies (n = 0): <none>
[08:28:27.021] {
[08:28:27.021]     {
[08:28:27.021]         {
[08:28:27.021]             ...future.startTime <- base::Sys.time()
[08:28:27.021]             {
[08:28:27.021]                 {
[08:28:27.021]                   {
[08:28:27.021]                     base::local({
[08:28:27.021]                       has_future <- base::requireNamespace("future", 
[08:28:27.021]                         quietly = TRUE)
[08:28:27.021]                       if (has_future) {
[08:28:27.021]                         ns <- base::getNamespace("future")
[08:28:27.021]                         version <- ns[[".package"]][["version"]]
[08:28:27.021]                         if (is.null(version)) 
[08:28:27.021]                           version <- utils::packageVersion("future")
[08:28:27.021]                       }
[08:28:27.021]                       else {
[08:28:27.021]                         version <- NULL
[08:28:27.021]                       }
[08:28:27.021]                       if (!has_future || version < "1.8.0") {
[08:28:27.021]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.021]                           "", base::R.version$version.string), 
[08:28:27.021]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.021]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.021]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.021]                             "release", "version")], collapse = " "), 
[08:28:27.021]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.021]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.021]                           info)
[08:28:27.021]                         info <- base::paste(info, collapse = "; ")
[08:28:27.021]                         if (!has_future) {
[08:28:27.021]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.021]                             info)
[08:28:27.021]                         }
[08:28:27.021]                         else {
[08:28:27.021]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.021]                             info, version)
[08:28:27.021]                         }
[08:28:27.021]                         base::stop(msg)
[08:28:27.021]                       }
[08:28:27.021]                     })
[08:28:27.021]                   }
[08:28:27.021]                   ...future.strategy.old <- future::plan("list")
[08:28:27.021]                   options(future.plan = NULL)
[08:28:27.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.021]                 }
[08:28:27.021]                 ...future.workdir <- getwd()
[08:28:27.021]             }
[08:28:27.021]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.021]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.021]         }
[08:28:27.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.021]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.021]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.021]             base::names(...future.oldOptions))
[08:28:27.021]     }
[08:28:27.021]     if (FALSE) {
[08:28:27.021]     }
[08:28:27.021]     else {
[08:28:27.021]         if (TRUE) {
[08:28:27.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.021]                 open = "w")
[08:28:27.021]         }
[08:28:27.021]         else {
[08:28:27.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.021]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.021]         }
[08:28:27.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.021]             base::sink(type = "output", split = FALSE)
[08:28:27.021]             base::close(...future.stdout)
[08:28:27.021]         }, add = TRUE)
[08:28:27.021]     }
[08:28:27.021]     ...future.frame <- base::sys.nframe()
[08:28:27.021]     ...future.conditions <- base::list()
[08:28:27.021]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.021]     if (FALSE) {
[08:28:27.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.021]     }
[08:28:27.021]     ...future.result <- base::tryCatch({
[08:28:27.021]         base::withCallingHandlers({
[08:28:27.021]             ...future.value <- base::withVisible(base::local({
[08:28:27.021]                 b <- 3
[08:28:27.021]                 c <- 2
[08:28:27.021]                 a * b * c
[08:28:27.021]             }))
[08:28:27.021]             future::FutureResult(value = ...future.value$value, 
[08:28:27.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.021]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.021]                     ...future.globalenv.names))
[08:28:27.021]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.021]         }, condition = base::local({
[08:28:27.021]             c <- base::c
[08:28:27.021]             inherits <- base::inherits
[08:28:27.021]             invokeRestart <- base::invokeRestart
[08:28:27.021]             length <- base::length
[08:28:27.021]             list <- base::list
[08:28:27.021]             seq.int <- base::seq.int
[08:28:27.021]             signalCondition <- base::signalCondition
[08:28:27.021]             sys.calls <- base::sys.calls
[08:28:27.021]             `[[` <- base::`[[`
[08:28:27.021]             `+` <- base::`+`
[08:28:27.021]             `<<-` <- base::`<<-`
[08:28:27.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.021]                   3L)]
[08:28:27.021]             }
[08:28:27.021]             function(cond) {
[08:28:27.021]                 is_error <- inherits(cond, "error")
[08:28:27.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.021]                   NULL)
[08:28:27.021]                 if (is_error) {
[08:28:27.021]                   sessionInformation <- function() {
[08:28:27.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.021]                       search = base::search(), system = base::Sys.info())
[08:28:27.021]                   }
[08:28:27.021]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.021]                     cond$call), session = sessionInformation(), 
[08:28:27.021]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.021]                   signalCondition(cond)
[08:28:27.021]                 }
[08:28:27.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.021]                 "immediateCondition"))) {
[08:28:27.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.021]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.021]                   if (TRUE && !signal) {
[08:28:27.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.021]                     {
[08:28:27.021]                       inherits <- base::inherits
[08:28:27.021]                       invokeRestart <- base::invokeRestart
[08:28:27.021]                       is.null <- base::is.null
[08:28:27.021]                       muffled <- FALSE
[08:28:27.021]                       if (inherits(cond, "message")) {
[08:28:27.021]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.021]                         if (muffled) 
[08:28:27.021]                           invokeRestart("muffleMessage")
[08:28:27.021]                       }
[08:28:27.021]                       else if (inherits(cond, "warning")) {
[08:28:27.021]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.021]                         if (muffled) 
[08:28:27.021]                           invokeRestart("muffleWarning")
[08:28:27.021]                       }
[08:28:27.021]                       else if (inherits(cond, "condition")) {
[08:28:27.021]                         if (!is.null(pattern)) {
[08:28:27.021]                           computeRestarts <- base::computeRestarts
[08:28:27.021]                           grepl <- base::grepl
[08:28:27.021]                           restarts <- computeRestarts(cond)
[08:28:27.021]                           for (restart in restarts) {
[08:28:27.021]                             name <- restart$name
[08:28:27.021]                             if (is.null(name)) 
[08:28:27.021]                               next
[08:28:27.021]                             if (!grepl(pattern, name)) 
[08:28:27.021]                               next
[08:28:27.021]                             invokeRestart(restart)
[08:28:27.021]                             muffled <- TRUE
[08:28:27.021]                             break
[08:28:27.021]                           }
[08:28:27.021]                         }
[08:28:27.021]                       }
[08:28:27.021]                       invisible(muffled)
[08:28:27.021]                     }
[08:28:27.021]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.021]                   }
[08:28:27.021]                 }
[08:28:27.021]                 else {
[08:28:27.021]                   if (TRUE) {
[08:28:27.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.021]                     {
[08:28:27.021]                       inherits <- base::inherits
[08:28:27.021]                       invokeRestart <- base::invokeRestart
[08:28:27.021]                       is.null <- base::is.null
[08:28:27.021]                       muffled <- FALSE
[08:28:27.021]                       if (inherits(cond, "message")) {
[08:28:27.021]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.021]                         if (muffled) 
[08:28:27.021]                           invokeRestart("muffleMessage")
[08:28:27.021]                       }
[08:28:27.021]                       else if (inherits(cond, "warning")) {
[08:28:27.021]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.021]                         if (muffled) 
[08:28:27.021]                           invokeRestart("muffleWarning")
[08:28:27.021]                       }
[08:28:27.021]                       else if (inherits(cond, "condition")) {
[08:28:27.021]                         if (!is.null(pattern)) {
[08:28:27.021]                           computeRestarts <- base::computeRestarts
[08:28:27.021]                           grepl <- base::grepl
[08:28:27.021]                           restarts <- computeRestarts(cond)
[08:28:27.021]                           for (restart in restarts) {
[08:28:27.021]                             name <- restart$name
[08:28:27.021]                             if (is.null(name)) 
[08:28:27.021]                               next
[08:28:27.021]                             if (!grepl(pattern, name)) 
[08:28:27.021]                               next
[08:28:27.021]                             invokeRestart(restart)
[08:28:27.021]                             muffled <- TRUE
[08:28:27.021]                             break
[08:28:27.021]                           }
[08:28:27.021]                         }
[08:28:27.021]                       }
[08:28:27.021]                       invisible(muffled)
[08:28:27.021]                     }
[08:28:27.021]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.021]                   }
[08:28:27.021]                 }
[08:28:27.021]             }
[08:28:27.021]         }))
[08:28:27.021]     }, error = function(ex) {
[08:28:27.021]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.021]                 ...future.rng), started = ...future.startTime, 
[08:28:27.021]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.021]             version = "1.8"), class = "FutureResult")
[08:28:27.021]     }, finally = {
[08:28:27.021]         if (!identical(...future.workdir, getwd())) 
[08:28:27.021]             setwd(...future.workdir)
[08:28:27.021]         {
[08:28:27.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.021]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.021]             }
[08:28:27.021]             base::options(...future.oldOptions)
[08:28:27.021]             if (.Platform$OS.type == "windows") {
[08:28:27.021]                 old_names <- names(...future.oldEnvVars)
[08:28:27.021]                 envs <- base::Sys.getenv()
[08:28:27.021]                 names <- names(envs)
[08:28:27.021]                 common <- intersect(names, old_names)
[08:28:27.021]                 added <- setdiff(names, old_names)
[08:28:27.021]                 removed <- setdiff(old_names, names)
[08:28:27.021]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.021]                   envs[common]]
[08:28:27.021]                 NAMES <- toupper(changed)
[08:28:27.021]                 args <- list()
[08:28:27.021]                 for (kk in seq_along(NAMES)) {
[08:28:27.021]                   name <- changed[[kk]]
[08:28:27.021]                   NAME <- NAMES[[kk]]
[08:28:27.021]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.021]                     next
[08:28:27.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.021]                 }
[08:28:27.021]                 NAMES <- toupper(added)
[08:28:27.021]                 for (kk in seq_along(NAMES)) {
[08:28:27.021]                   name <- added[[kk]]
[08:28:27.021]                   NAME <- NAMES[[kk]]
[08:28:27.021]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.021]                     next
[08:28:27.021]                   args[[name]] <- ""
[08:28:27.021]                 }
[08:28:27.021]                 NAMES <- toupper(removed)
[08:28:27.021]                 for (kk in seq_along(NAMES)) {
[08:28:27.021]                   name <- removed[[kk]]
[08:28:27.021]                   NAME <- NAMES[[kk]]
[08:28:27.021]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.021]                     next
[08:28:27.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.021]                 }
[08:28:27.021]                 if (length(args) > 0) 
[08:28:27.021]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.021]             }
[08:28:27.021]             else {
[08:28:27.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.021]             }
[08:28:27.021]             {
[08:28:27.021]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.021]                   0L) {
[08:28:27.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.021]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.021]                   base::options(opts)
[08:28:27.021]                 }
[08:28:27.021]                 {
[08:28:27.021]                   {
[08:28:27.021]                     NULL
[08:28:27.021]                     RNGkind("Mersenne-Twister")
[08:28:27.021]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.021]                       inherits = FALSE)
[08:28:27.021]                   }
[08:28:27.021]                   options(future.plan = NULL)
[08:28:27.021]                   if (is.na(NA_character_)) 
[08:28:27.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.021]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.021]                     .init = FALSE)
[08:28:27.021]                 }
[08:28:27.021]             }
[08:28:27.021]         }
[08:28:27.021]     })
[08:28:27.021]     if (TRUE) {
[08:28:27.021]         base::sink(type = "output", split = FALSE)
[08:28:27.021]         if (TRUE) {
[08:28:27.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.021]         }
[08:28:27.021]         else {
[08:28:27.021]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.021]         }
[08:28:27.021]         base::close(...future.stdout)
[08:28:27.021]         ...future.stdout <- NULL
[08:28:27.021]     }
[08:28:27.021]     ...future.result$conditions <- ...future.conditions
[08:28:27.021]     ...future.result$finished <- base::Sys.time()
[08:28:27.021]     ...future.result
[08:28:27.021] }
[08:28:27.023] plan(): Setting new future strategy stack:
[08:28:27.023] List of future strategies:
[08:28:27.023] 1. sequential:
[08:28:27.023]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.023]    - tweaked: FALSE
[08:28:27.023]    - call: NULL
[08:28:27.023] plan(): nbrOfWorkers() = 1
[08:28:27.024] plan(): Setting new future strategy stack:
[08:28:27.024] List of future strategies:
[08:28:27.024] 1. multicore:
[08:28:27.024]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.024]    - tweaked: FALSE
[08:28:27.024]    - call: plan(multicore)
[08:28:27.026] plan(): nbrOfWorkers() = 1
[08:28:27.026] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[08:28:27.028] getGlobalsAndPackages() ...
[08:28:27.028] Not searching for globals
[08:28:27.028] - globals: [0] <none>
[08:28:27.028] getGlobalsAndPackages() ... DONE
[08:28:27.029] Packages needed by the future expression (n = 0): <none>
[08:28:27.029] Packages needed by future strategies (n = 0): <none>
[08:28:27.029] {
[08:28:27.029]     {
[08:28:27.029]         {
[08:28:27.029]             ...future.startTime <- base::Sys.time()
[08:28:27.029]             {
[08:28:27.029]                 {
[08:28:27.029]                   {
[08:28:27.029]                     base::local({
[08:28:27.029]                       has_future <- base::requireNamespace("future", 
[08:28:27.029]                         quietly = TRUE)
[08:28:27.029]                       if (has_future) {
[08:28:27.029]                         ns <- base::getNamespace("future")
[08:28:27.029]                         version <- ns[[".package"]][["version"]]
[08:28:27.029]                         if (is.null(version)) 
[08:28:27.029]                           version <- utils::packageVersion("future")
[08:28:27.029]                       }
[08:28:27.029]                       else {
[08:28:27.029]                         version <- NULL
[08:28:27.029]                       }
[08:28:27.029]                       if (!has_future || version < "1.8.0") {
[08:28:27.029]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.029]                           "", base::R.version$version.string), 
[08:28:27.029]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.029]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.029]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.029]                             "release", "version")], collapse = " "), 
[08:28:27.029]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.029]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.029]                           info)
[08:28:27.029]                         info <- base::paste(info, collapse = "; ")
[08:28:27.029]                         if (!has_future) {
[08:28:27.029]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.029]                             info)
[08:28:27.029]                         }
[08:28:27.029]                         else {
[08:28:27.029]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.029]                             info, version)
[08:28:27.029]                         }
[08:28:27.029]                         base::stop(msg)
[08:28:27.029]                       }
[08:28:27.029]                     })
[08:28:27.029]                   }
[08:28:27.029]                   ...future.strategy.old <- future::plan("list")
[08:28:27.029]                   options(future.plan = NULL)
[08:28:27.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.029]                 }
[08:28:27.029]                 ...future.workdir <- getwd()
[08:28:27.029]             }
[08:28:27.029]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.029]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.029]         }
[08:28:27.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.029]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.029]             base::names(...future.oldOptions))
[08:28:27.029]     }
[08:28:27.029]     if (FALSE) {
[08:28:27.029]     }
[08:28:27.029]     else {
[08:28:27.029]         if (TRUE) {
[08:28:27.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.029]                 open = "w")
[08:28:27.029]         }
[08:28:27.029]         else {
[08:28:27.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.029]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.029]         }
[08:28:27.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.029]             base::sink(type = "output", split = FALSE)
[08:28:27.029]             base::close(...future.stdout)
[08:28:27.029]         }, add = TRUE)
[08:28:27.029]     }
[08:28:27.029]     ...future.frame <- base::sys.nframe()
[08:28:27.029]     ...future.conditions <- base::list()
[08:28:27.029]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.029]     if (FALSE) {
[08:28:27.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.029]     }
[08:28:27.029]     ...future.result <- base::tryCatch({
[08:28:27.029]         base::withCallingHandlers({
[08:28:27.029]             ...future.value <- base::withVisible(base::local({
[08:28:27.029]                 ii
[08:28:27.029]             }))
[08:28:27.029]             future::FutureResult(value = ...future.value$value, 
[08:28:27.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.029]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.029]                     ...future.globalenv.names))
[08:28:27.029]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.029]         }, condition = base::local({
[08:28:27.029]             c <- base::c
[08:28:27.029]             inherits <- base::inherits
[08:28:27.029]             invokeRestart <- base::invokeRestart
[08:28:27.029]             length <- base::length
[08:28:27.029]             list <- base::list
[08:28:27.029]             seq.int <- base::seq.int
[08:28:27.029]             signalCondition <- base::signalCondition
[08:28:27.029]             sys.calls <- base::sys.calls
[08:28:27.029]             `[[` <- base::`[[`
[08:28:27.029]             `+` <- base::`+`
[08:28:27.029]             `<<-` <- base::`<<-`
[08:28:27.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.029]                   3L)]
[08:28:27.029]             }
[08:28:27.029]             function(cond) {
[08:28:27.029]                 is_error <- inherits(cond, "error")
[08:28:27.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.029]                   NULL)
[08:28:27.029]                 if (is_error) {
[08:28:27.029]                   sessionInformation <- function() {
[08:28:27.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.029]                       search = base::search(), system = base::Sys.info())
[08:28:27.029]                   }
[08:28:27.029]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.029]                     cond$call), session = sessionInformation(), 
[08:28:27.029]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.029]                   signalCondition(cond)
[08:28:27.029]                 }
[08:28:27.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.029]                 "immediateCondition"))) {
[08:28:27.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.029]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.029]                   if (TRUE && !signal) {
[08:28:27.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.029]                     {
[08:28:27.029]                       inherits <- base::inherits
[08:28:27.029]                       invokeRestart <- base::invokeRestart
[08:28:27.029]                       is.null <- base::is.null
[08:28:27.029]                       muffled <- FALSE
[08:28:27.029]                       if (inherits(cond, "message")) {
[08:28:27.029]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.029]                         if (muffled) 
[08:28:27.029]                           invokeRestart("muffleMessage")
[08:28:27.029]                       }
[08:28:27.029]                       else if (inherits(cond, "warning")) {
[08:28:27.029]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.029]                         if (muffled) 
[08:28:27.029]                           invokeRestart("muffleWarning")
[08:28:27.029]                       }
[08:28:27.029]                       else if (inherits(cond, "condition")) {
[08:28:27.029]                         if (!is.null(pattern)) {
[08:28:27.029]                           computeRestarts <- base::computeRestarts
[08:28:27.029]                           grepl <- base::grepl
[08:28:27.029]                           restarts <- computeRestarts(cond)
[08:28:27.029]                           for (restart in restarts) {
[08:28:27.029]                             name <- restart$name
[08:28:27.029]                             if (is.null(name)) 
[08:28:27.029]                               next
[08:28:27.029]                             if (!grepl(pattern, name)) 
[08:28:27.029]                               next
[08:28:27.029]                             invokeRestart(restart)
[08:28:27.029]                             muffled <- TRUE
[08:28:27.029]                             break
[08:28:27.029]                           }
[08:28:27.029]                         }
[08:28:27.029]                       }
[08:28:27.029]                       invisible(muffled)
[08:28:27.029]                     }
[08:28:27.029]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.029]                   }
[08:28:27.029]                 }
[08:28:27.029]                 else {
[08:28:27.029]                   if (TRUE) {
[08:28:27.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.029]                     {
[08:28:27.029]                       inherits <- base::inherits
[08:28:27.029]                       invokeRestart <- base::invokeRestart
[08:28:27.029]                       is.null <- base::is.null
[08:28:27.029]                       muffled <- FALSE
[08:28:27.029]                       if (inherits(cond, "message")) {
[08:28:27.029]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.029]                         if (muffled) 
[08:28:27.029]                           invokeRestart("muffleMessage")
[08:28:27.029]                       }
[08:28:27.029]                       else if (inherits(cond, "warning")) {
[08:28:27.029]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.029]                         if (muffled) 
[08:28:27.029]                           invokeRestart("muffleWarning")
[08:28:27.029]                       }
[08:28:27.029]                       else if (inherits(cond, "condition")) {
[08:28:27.029]                         if (!is.null(pattern)) {
[08:28:27.029]                           computeRestarts <- base::computeRestarts
[08:28:27.029]                           grepl <- base::grepl
[08:28:27.029]                           restarts <- computeRestarts(cond)
[08:28:27.029]                           for (restart in restarts) {
[08:28:27.029]                             name <- restart$name
[08:28:27.029]                             if (is.null(name)) 
[08:28:27.029]                               next
[08:28:27.029]                             if (!grepl(pattern, name)) 
[08:28:27.029]                               next
[08:28:27.029]                             invokeRestart(restart)
[08:28:27.029]                             muffled <- TRUE
[08:28:27.029]                             break
[08:28:27.029]                           }
[08:28:27.029]                         }
[08:28:27.029]                       }
[08:28:27.029]                       invisible(muffled)
[08:28:27.029]                     }
[08:28:27.029]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.029]                   }
[08:28:27.029]                 }
[08:28:27.029]             }
[08:28:27.029]         }))
[08:28:27.029]     }, error = function(ex) {
[08:28:27.029]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.029]                 ...future.rng), started = ...future.startTime, 
[08:28:27.029]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.029]             version = "1.8"), class = "FutureResult")
[08:28:27.029]     }, finally = {
[08:28:27.029]         if (!identical(...future.workdir, getwd())) 
[08:28:27.029]             setwd(...future.workdir)
[08:28:27.029]         {
[08:28:27.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.029]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.029]             }
[08:28:27.029]             base::options(...future.oldOptions)
[08:28:27.029]             if (.Platform$OS.type == "windows") {
[08:28:27.029]                 old_names <- names(...future.oldEnvVars)
[08:28:27.029]                 envs <- base::Sys.getenv()
[08:28:27.029]                 names <- names(envs)
[08:28:27.029]                 common <- intersect(names, old_names)
[08:28:27.029]                 added <- setdiff(names, old_names)
[08:28:27.029]                 removed <- setdiff(old_names, names)
[08:28:27.029]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.029]                   envs[common]]
[08:28:27.029]                 NAMES <- toupper(changed)
[08:28:27.029]                 args <- list()
[08:28:27.029]                 for (kk in seq_along(NAMES)) {
[08:28:27.029]                   name <- changed[[kk]]
[08:28:27.029]                   NAME <- NAMES[[kk]]
[08:28:27.029]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.029]                     next
[08:28:27.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.029]                 }
[08:28:27.029]                 NAMES <- toupper(added)
[08:28:27.029]                 for (kk in seq_along(NAMES)) {
[08:28:27.029]                   name <- added[[kk]]
[08:28:27.029]                   NAME <- NAMES[[kk]]
[08:28:27.029]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.029]                     next
[08:28:27.029]                   args[[name]] <- ""
[08:28:27.029]                 }
[08:28:27.029]                 NAMES <- toupper(removed)
[08:28:27.029]                 for (kk in seq_along(NAMES)) {
[08:28:27.029]                   name <- removed[[kk]]
[08:28:27.029]                   NAME <- NAMES[[kk]]
[08:28:27.029]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.029]                     next
[08:28:27.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.029]                 }
[08:28:27.029]                 if (length(args) > 0) 
[08:28:27.029]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.029]             }
[08:28:27.029]             else {
[08:28:27.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.029]             }
[08:28:27.029]             {
[08:28:27.029]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.029]                   0L) {
[08:28:27.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.029]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.029]                   base::options(opts)
[08:28:27.029]                 }
[08:28:27.029]                 {
[08:28:27.029]                   {
[08:28:27.029]                     NULL
[08:28:27.029]                     RNGkind("Mersenne-Twister")
[08:28:27.029]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.029]                       inherits = FALSE)
[08:28:27.029]                   }
[08:28:27.029]                   options(future.plan = NULL)
[08:28:27.029]                   if (is.na(NA_character_)) 
[08:28:27.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.029]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.029]                     .init = FALSE)
[08:28:27.029]                 }
[08:28:27.029]             }
[08:28:27.029]         }
[08:28:27.029]     })
[08:28:27.029]     if (TRUE) {
[08:28:27.029]         base::sink(type = "output", split = FALSE)
[08:28:27.029]         if (TRUE) {
[08:28:27.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.029]         }
[08:28:27.029]         else {
[08:28:27.029]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.029]         }
[08:28:27.029]         base::close(...future.stdout)
[08:28:27.029]         ...future.stdout <- NULL
[08:28:27.029]     }
[08:28:27.029]     ...future.result$conditions <- ...future.conditions
[08:28:27.029]     ...future.result$finished <- base::Sys.time()
[08:28:27.029]     ...future.result
[08:28:27.029] }
[08:28:27.031] plan(): Setting new future strategy stack:
[08:28:27.031] List of future strategies:
[08:28:27.031] 1. sequential:
[08:28:27.031]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.031]    - tweaked: FALSE
[08:28:27.031]    - call: NULL
[08:28:27.032] plan(): nbrOfWorkers() = 1
[08:28:27.032] plan(): Setting new future strategy stack:
[08:28:27.032] List of future strategies:
[08:28:27.032] 1. multicore:
[08:28:27.032]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.032]    - tweaked: FALSE
[08:28:27.032]    - call: plan(multicore)
[08:28:27.034] plan(): nbrOfWorkers() = 1
[08:28:27.034] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[08:28:27.038] getGlobalsAndPackages() ...
[08:28:27.038] Not searching for globals
[08:28:27.038] - globals: [0] <none>
[08:28:27.038] getGlobalsAndPackages() ... DONE
[08:28:27.038] Packages needed by the future expression (n = 0): <none>
[08:28:27.039] Packages needed by future strategies (n = 0): <none>
[08:28:27.039] {
[08:28:27.039]     {
[08:28:27.039]         {
[08:28:27.039]             ...future.startTime <- base::Sys.time()
[08:28:27.039]             {
[08:28:27.039]                 {
[08:28:27.039]                   {
[08:28:27.039]                     base::local({
[08:28:27.039]                       has_future <- base::requireNamespace("future", 
[08:28:27.039]                         quietly = TRUE)
[08:28:27.039]                       if (has_future) {
[08:28:27.039]                         ns <- base::getNamespace("future")
[08:28:27.039]                         version <- ns[[".package"]][["version"]]
[08:28:27.039]                         if (is.null(version)) 
[08:28:27.039]                           version <- utils::packageVersion("future")
[08:28:27.039]                       }
[08:28:27.039]                       else {
[08:28:27.039]                         version <- NULL
[08:28:27.039]                       }
[08:28:27.039]                       if (!has_future || version < "1.8.0") {
[08:28:27.039]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.039]                           "", base::R.version$version.string), 
[08:28:27.039]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.039]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.039]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.039]                             "release", "version")], collapse = " "), 
[08:28:27.039]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.039]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.039]                           info)
[08:28:27.039]                         info <- base::paste(info, collapse = "; ")
[08:28:27.039]                         if (!has_future) {
[08:28:27.039]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.039]                             info)
[08:28:27.039]                         }
[08:28:27.039]                         else {
[08:28:27.039]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.039]                             info, version)
[08:28:27.039]                         }
[08:28:27.039]                         base::stop(msg)
[08:28:27.039]                       }
[08:28:27.039]                     })
[08:28:27.039]                   }
[08:28:27.039]                   ...future.strategy.old <- future::plan("list")
[08:28:27.039]                   options(future.plan = NULL)
[08:28:27.039]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.039]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.039]                 }
[08:28:27.039]                 ...future.workdir <- getwd()
[08:28:27.039]             }
[08:28:27.039]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.039]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.039]         }
[08:28:27.039]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.039]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.039]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.039]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.039]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.039]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.039]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.039]             base::names(...future.oldOptions))
[08:28:27.039]     }
[08:28:27.039]     if (FALSE) {
[08:28:27.039]     }
[08:28:27.039]     else {
[08:28:27.039]         if (TRUE) {
[08:28:27.039]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.039]                 open = "w")
[08:28:27.039]         }
[08:28:27.039]         else {
[08:28:27.039]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.039]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.039]         }
[08:28:27.039]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.039]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.039]             base::sink(type = "output", split = FALSE)
[08:28:27.039]             base::close(...future.stdout)
[08:28:27.039]         }, add = TRUE)
[08:28:27.039]     }
[08:28:27.039]     ...future.frame <- base::sys.nframe()
[08:28:27.039]     ...future.conditions <- base::list()
[08:28:27.039]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.039]     if (FALSE) {
[08:28:27.039]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.039]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.039]     }
[08:28:27.039]     ...future.result <- base::tryCatch({
[08:28:27.039]         base::withCallingHandlers({
[08:28:27.039]             ...future.value <- base::withVisible(base::local({
[08:28:27.039]                 ii
[08:28:27.039]             }))
[08:28:27.039]             future::FutureResult(value = ...future.value$value, 
[08:28:27.039]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.039]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.039]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.039]                     ...future.globalenv.names))
[08:28:27.039]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.039]         }, condition = base::local({
[08:28:27.039]             c <- base::c
[08:28:27.039]             inherits <- base::inherits
[08:28:27.039]             invokeRestart <- base::invokeRestart
[08:28:27.039]             length <- base::length
[08:28:27.039]             list <- base::list
[08:28:27.039]             seq.int <- base::seq.int
[08:28:27.039]             signalCondition <- base::signalCondition
[08:28:27.039]             sys.calls <- base::sys.calls
[08:28:27.039]             `[[` <- base::`[[`
[08:28:27.039]             `+` <- base::`+`
[08:28:27.039]             `<<-` <- base::`<<-`
[08:28:27.039]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.039]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.039]                   3L)]
[08:28:27.039]             }
[08:28:27.039]             function(cond) {
[08:28:27.039]                 is_error <- inherits(cond, "error")
[08:28:27.039]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.039]                   NULL)
[08:28:27.039]                 if (is_error) {
[08:28:27.039]                   sessionInformation <- function() {
[08:28:27.039]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.039]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.039]                       search = base::search(), system = base::Sys.info())
[08:28:27.039]                   }
[08:28:27.039]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.039]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.039]                     cond$call), session = sessionInformation(), 
[08:28:27.039]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.039]                   signalCondition(cond)
[08:28:27.039]                 }
[08:28:27.039]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.039]                 "immediateCondition"))) {
[08:28:27.039]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.039]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.039]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.039]                   if (TRUE && !signal) {
[08:28:27.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.039]                     {
[08:28:27.039]                       inherits <- base::inherits
[08:28:27.039]                       invokeRestart <- base::invokeRestart
[08:28:27.039]                       is.null <- base::is.null
[08:28:27.039]                       muffled <- FALSE
[08:28:27.039]                       if (inherits(cond, "message")) {
[08:28:27.039]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.039]                         if (muffled) 
[08:28:27.039]                           invokeRestart("muffleMessage")
[08:28:27.039]                       }
[08:28:27.039]                       else if (inherits(cond, "warning")) {
[08:28:27.039]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.039]                         if (muffled) 
[08:28:27.039]                           invokeRestart("muffleWarning")
[08:28:27.039]                       }
[08:28:27.039]                       else if (inherits(cond, "condition")) {
[08:28:27.039]                         if (!is.null(pattern)) {
[08:28:27.039]                           computeRestarts <- base::computeRestarts
[08:28:27.039]                           grepl <- base::grepl
[08:28:27.039]                           restarts <- computeRestarts(cond)
[08:28:27.039]                           for (restart in restarts) {
[08:28:27.039]                             name <- restart$name
[08:28:27.039]                             if (is.null(name)) 
[08:28:27.039]                               next
[08:28:27.039]                             if (!grepl(pattern, name)) 
[08:28:27.039]                               next
[08:28:27.039]                             invokeRestart(restart)
[08:28:27.039]                             muffled <- TRUE
[08:28:27.039]                             break
[08:28:27.039]                           }
[08:28:27.039]                         }
[08:28:27.039]                       }
[08:28:27.039]                       invisible(muffled)
[08:28:27.039]                     }
[08:28:27.039]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.039]                   }
[08:28:27.039]                 }
[08:28:27.039]                 else {
[08:28:27.039]                   if (TRUE) {
[08:28:27.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.039]                     {
[08:28:27.039]                       inherits <- base::inherits
[08:28:27.039]                       invokeRestart <- base::invokeRestart
[08:28:27.039]                       is.null <- base::is.null
[08:28:27.039]                       muffled <- FALSE
[08:28:27.039]                       if (inherits(cond, "message")) {
[08:28:27.039]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.039]                         if (muffled) 
[08:28:27.039]                           invokeRestart("muffleMessage")
[08:28:27.039]                       }
[08:28:27.039]                       else if (inherits(cond, "warning")) {
[08:28:27.039]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.039]                         if (muffled) 
[08:28:27.039]                           invokeRestart("muffleWarning")
[08:28:27.039]                       }
[08:28:27.039]                       else if (inherits(cond, "condition")) {
[08:28:27.039]                         if (!is.null(pattern)) {
[08:28:27.039]                           computeRestarts <- base::computeRestarts
[08:28:27.039]                           grepl <- base::grepl
[08:28:27.039]                           restarts <- computeRestarts(cond)
[08:28:27.039]                           for (restart in restarts) {
[08:28:27.039]                             name <- restart$name
[08:28:27.039]                             if (is.null(name)) 
[08:28:27.039]                               next
[08:28:27.039]                             if (!grepl(pattern, name)) 
[08:28:27.039]                               next
[08:28:27.039]                             invokeRestart(restart)
[08:28:27.039]                             muffled <- TRUE
[08:28:27.039]                             break
[08:28:27.039]                           }
[08:28:27.039]                         }
[08:28:27.039]                       }
[08:28:27.039]                       invisible(muffled)
[08:28:27.039]                     }
[08:28:27.039]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.039]                   }
[08:28:27.039]                 }
[08:28:27.039]             }
[08:28:27.039]         }))
[08:28:27.039]     }, error = function(ex) {
[08:28:27.039]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.039]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.039]                 ...future.rng), started = ...future.startTime, 
[08:28:27.039]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.039]             version = "1.8"), class = "FutureResult")
[08:28:27.039]     }, finally = {
[08:28:27.039]         if (!identical(...future.workdir, getwd())) 
[08:28:27.039]             setwd(...future.workdir)
[08:28:27.039]         {
[08:28:27.039]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.039]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.039]             }
[08:28:27.039]             base::options(...future.oldOptions)
[08:28:27.039]             if (.Platform$OS.type == "windows") {
[08:28:27.039]                 old_names <- names(...future.oldEnvVars)
[08:28:27.039]                 envs <- base::Sys.getenv()
[08:28:27.039]                 names <- names(envs)
[08:28:27.039]                 common <- intersect(names, old_names)
[08:28:27.039]                 added <- setdiff(names, old_names)
[08:28:27.039]                 removed <- setdiff(old_names, names)
[08:28:27.039]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.039]                   envs[common]]
[08:28:27.039]                 NAMES <- toupper(changed)
[08:28:27.039]                 args <- list()
[08:28:27.039]                 for (kk in seq_along(NAMES)) {
[08:28:27.039]                   name <- changed[[kk]]
[08:28:27.039]                   NAME <- NAMES[[kk]]
[08:28:27.039]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.039]                     next
[08:28:27.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.039]                 }
[08:28:27.039]                 NAMES <- toupper(added)
[08:28:27.039]                 for (kk in seq_along(NAMES)) {
[08:28:27.039]                   name <- added[[kk]]
[08:28:27.039]                   NAME <- NAMES[[kk]]
[08:28:27.039]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.039]                     next
[08:28:27.039]                   args[[name]] <- ""
[08:28:27.039]                 }
[08:28:27.039]                 NAMES <- toupper(removed)
[08:28:27.039]                 for (kk in seq_along(NAMES)) {
[08:28:27.039]                   name <- removed[[kk]]
[08:28:27.039]                   NAME <- NAMES[[kk]]
[08:28:27.039]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.039]                     next
[08:28:27.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.039]                 }
[08:28:27.039]                 if (length(args) > 0) 
[08:28:27.039]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.039]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.039]             }
[08:28:27.039]             else {
[08:28:27.039]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.039]             }
[08:28:27.039]             {
[08:28:27.039]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.039]                   0L) {
[08:28:27.039]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.039]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.039]                   base::options(opts)
[08:28:27.039]                 }
[08:28:27.039]                 {
[08:28:27.039]                   {
[08:28:27.039]                     NULL
[08:28:27.039]                     RNGkind("Mersenne-Twister")
[08:28:27.039]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.039]                       inherits = FALSE)
[08:28:27.039]                   }
[08:28:27.039]                   options(future.plan = NULL)
[08:28:27.039]                   if (is.na(NA_character_)) 
[08:28:27.039]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.039]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.039]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.039]                     .init = FALSE)
[08:28:27.039]                 }
[08:28:27.039]             }
[08:28:27.039]         }
[08:28:27.039]     })
[08:28:27.039]     if (TRUE) {
[08:28:27.039]         base::sink(type = "output", split = FALSE)
[08:28:27.039]         if (TRUE) {
[08:28:27.039]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.039]         }
[08:28:27.039]         else {
[08:28:27.039]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.039]         }
[08:28:27.039]         base::close(...future.stdout)
[08:28:27.039]         ...future.stdout <- NULL
[08:28:27.039]     }
[08:28:27.039]     ...future.result$conditions <- ...future.conditions
[08:28:27.039]     ...future.result$finished <- base::Sys.time()
[08:28:27.039]     ...future.result
[08:28:27.039] }
[08:28:27.041] plan(): Setting new future strategy stack:
[08:28:27.041] List of future strategies:
[08:28:27.041] 1. sequential:
[08:28:27.041]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.041]    - tweaked: FALSE
[08:28:27.041]    - call: NULL
[08:28:27.041] plan(): nbrOfWorkers() = 1
[08:28:27.042] plan(): Setting new future strategy stack:
[08:28:27.042] List of future strategies:
[08:28:27.042] 1. multicore:
[08:28:27.042]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.042]    - tweaked: FALSE
[08:28:27.042]    - call: plan(multicore)
[08:28:27.044] plan(): nbrOfWorkers() = 1
[08:28:27.044] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[08:28:27.045] getGlobalsAndPackages() ...
[08:28:27.045] Not searching for globals
[08:28:27.046] - globals: [0] <none>
[08:28:27.046] getGlobalsAndPackages() ... DONE
[08:28:27.046] Packages needed by the future expression (n = 0): <none>
[08:28:27.046] Packages needed by future strategies (n = 0): <none>
[08:28:27.046] {
[08:28:27.046]     {
[08:28:27.046]         {
[08:28:27.046]             ...future.startTime <- base::Sys.time()
[08:28:27.046]             {
[08:28:27.046]                 {
[08:28:27.046]                   {
[08:28:27.046]                     base::local({
[08:28:27.046]                       has_future <- base::requireNamespace("future", 
[08:28:27.046]                         quietly = TRUE)
[08:28:27.046]                       if (has_future) {
[08:28:27.046]                         ns <- base::getNamespace("future")
[08:28:27.046]                         version <- ns[[".package"]][["version"]]
[08:28:27.046]                         if (is.null(version)) 
[08:28:27.046]                           version <- utils::packageVersion("future")
[08:28:27.046]                       }
[08:28:27.046]                       else {
[08:28:27.046]                         version <- NULL
[08:28:27.046]                       }
[08:28:27.046]                       if (!has_future || version < "1.8.0") {
[08:28:27.046]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.046]                           "", base::R.version$version.string), 
[08:28:27.046]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.046]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.046]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.046]                             "release", "version")], collapse = " "), 
[08:28:27.046]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.046]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.046]                           info)
[08:28:27.046]                         info <- base::paste(info, collapse = "; ")
[08:28:27.046]                         if (!has_future) {
[08:28:27.046]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.046]                             info)
[08:28:27.046]                         }
[08:28:27.046]                         else {
[08:28:27.046]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.046]                             info, version)
[08:28:27.046]                         }
[08:28:27.046]                         base::stop(msg)
[08:28:27.046]                       }
[08:28:27.046]                     })
[08:28:27.046]                   }
[08:28:27.046]                   ...future.strategy.old <- future::plan("list")
[08:28:27.046]                   options(future.plan = NULL)
[08:28:27.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.046]                 }
[08:28:27.046]                 ...future.workdir <- getwd()
[08:28:27.046]             }
[08:28:27.046]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.046]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.046]         }
[08:28:27.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.046]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.046]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.046]             base::names(...future.oldOptions))
[08:28:27.046]     }
[08:28:27.046]     if (FALSE) {
[08:28:27.046]     }
[08:28:27.046]     else {
[08:28:27.046]         if (TRUE) {
[08:28:27.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.046]                 open = "w")
[08:28:27.046]         }
[08:28:27.046]         else {
[08:28:27.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.046]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.046]         }
[08:28:27.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.046]             base::sink(type = "output", split = FALSE)
[08:28:27.046]             base::close(...future.stdout)
[08:28:27.046]         }, add = TRUE)
[08:28:27.046]     }
[08:28:27.046]     ...future.frame <- base::sys.nframe()
[08:28:27.046]     ...future.conditions <- base::list()
[08:28:27.046]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.046]     if (FALSE) {
[08:28:27.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.046]     }
[08:28:27.046]     ...future.result <- base::tryCatch({
[08:28:27.046]         base::withCallingHandlers({
[08:28:27.046]             ...future.value <- base::withVisible(base::local({
[08:28:27.046]                 ii
[08:28:27.046]             }))
[08:28:27.046]             future::FutureResult(value = ...future.value$value, 
[08:28:27.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.046]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.046]                     ...future.globalenv.names))
[08:28:27.046]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.046]         }, condition = base::local({
[08:28:27.046]             c <- base::c
[08:28:27.046]             inherits <- base::inherits
[08:28:27.046]             invokeRestart <- base::invokeRestart
[08:28:27.046]             length <- base::length
[08:28:27.046]             list <- base::list
[08:28:27.046]             seq.int <- base::seq.int
[08:28:27.046]             signalCondition <- base::signalCondition
[08:28:27.046]             sys.calls <- base::sys.calls
[08:28:27.046]             `[[` <- base::`[[`
[08:28:27.046]             `+` <- base::`+`
[08:28:27.046]             `<<-` <- base::`<<-`
[08:28:27.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.046]                   3L)]
[08:28:27.046]             }
[08:28:27.046]             function(cond) {
[08:28:27.046]                 is_error <- inherits(cond, "error")
[08:28:27.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.046]                   NULL)
[08:28:27.046]                 if (is_error) {
[08:28:27.046]                   sessionInformation <- function() {
[08:28:27.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.046]                       search = base::search(), system = base::Sys.info())
[08:28:27.046]                   }
[08:28:27.046]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.046]                     cond$call), session = sessionInformation(), 
[08:28:27.046]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.046]                   signalCondition(cond)
[08:28:27.046]                 }
[08:28:27.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.046]                 "immediateCondition"))) {
[08:28:27.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.046]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.046]                   if (TRUE && !signal) {
[08:28:27.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.046]                     {
[08:28:27.046]                       inherits <- base::inherits
[08:28:27.046]                       invokeRestart <- base::invokeRestart
[08:28:27.046]                       is.null <- base::is.null
[08:28:27.046]                       muffled <- FALSE
[08:28:27.046]                       if (inherits(cond, "message")) {
[08:28:27.046]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.046]                         if (muffled) 
[08:28:27.046]                           invokeRestart("muffleMessage")
[08:28:27.046]                       }
[08:28:27.046]                       else if (inherits(cond, "warning")) {
[08:28:27.046]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.046]                         if (muffled) 
[08:28:27.046]                           invokeRestart("muffleWarning")
[08:28:27.046]                       }
[08:28:27.046]                       else if (inherits(cond, "condition")) {
[08:28:27.046]                         if (!is.null(pattern)) {
[08:28:27.046]                           computeRestarts <- base::computeRestarts
[08:28:27.046]                           grepl <- base::grepl
[08:28:27.046]                           restarts <- computeRestarts(cond)
[08:28:27.046]                           for (restart in restarts) {
[08:28:27.046]                             name <- restart$name
[08:28:27.046]                             if (is.null(name)) 
[08:28:27.046]                               next
[08:28:27.046]                             if (!grepl(pattern, name)) 
[08:28:27.046]                               next
[08:28:27.046]                             invokeRestart(restart)
[08:28:27.046]                             muffled <- TRUE
[08:28:27.046]                             break
[08:28:27.046]                           }
[08:28:27.046]                         }
[08:28:27.046]                       }
[08:28:27.046]                       invisible(muffled)
[08:28:27.046]                     }
[08:28:27.046]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.046]                   }
[08:28:27.046]                 }
[08:28:27.046]                 else {
[08:28:27.046]                   if (TRUE) {
[08:28:27.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.046]                     {
[08:28:27.046]                       inherits <- base::inherits
[08:28:27.046]                       invokeRestart <- base::invokeRestart
[08:28:27.046]                       is.null <- base::is.null
[08:28:27.046]                       muffled <- FALSE
[08:28:27.046]                       if (inherits(cond, "message")) {
[08:28:27.046]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.046]                         if (muffled) 
[08:28:27.046]                           invokeRestart("muffleMessage")
[08:28:27.046]                       }
[08:28:27.046]                       else if (inherits(cond, "warning")) {
[08:28:27.046]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.046]                         if (muffled) 
[08:28:27.046]                           invokeRestart("muffleWarning")
[08:28:27.046]                       }
[08:28:27.046]                       else if (inherits(cond, "condition")) {
[08:28:27.046]                         if (!is.null(pattern)) {
[08:28:27.046]                           computeRestarts <- base::computeRestarts
[08:28:27.046]                           grepl <- base::grepl
[08:28:27.046]                           restarts <- computeRestarts(cond)
[08:28:27.046]                           for (restart in restarts) {
[08:28:27.046]                             name <- restart$name
[08:28:27.046]                             if (is.null(name)) 
[08:28:27.046]                               next
[08:28:27.046]                             if (!grepl(pattern, name)) 
[08:28:27.046]                               next
[08:28:27.046]                             invokeRestart(restart)
[08:28:27.046]                             muffled <- TRUE
[08:28:27.046]                             break
[08:28:27.046]                           }
[08:28:27.046]                         }
[08:28:27.046]                       }
[08:28:27.046]                       invisible(muffled)
[08:28:27.046]                     }
[08:28:27.046]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.046]                   }
[08:28:27.046]                 }
[08:28:27.046]             }
[08:28:27.046]         }))
[08:28:27.046]     }, error = function(ex) {
[08:28:27.046]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.046]                 ...future.rng), started = ...future.startTime, 
[08:28:27.046]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.046]             version = "1.8"), class = "FutureResult")
[08:28:27.046]     }, finally = {
[08:28:27.046]         if (!identical(...future.workdir, getwd())) 
[08:28:27.046]             setwd(...future.workdir)
[08:28:27.046]         {
[08:28:27.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.046]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.046]             }
[08:28:27.046]             base::options(...future.oldOptions)
[08:28:27.046]             if (.Platform$OS.type == "windows") {
[08:28:27.046]                 old_names <- names(...future.oldEnvVars)
[08:28:27.046]                 envs <- base::Sys.getenv()
[08:28:27.046]                 names <- names(envs)
[08:28:27.046]                 common <- intersect(names, old_names)
[08:28:27.046]                 added <- setdiff(names, old_names)
[08:28:27.046]                 removed <- setdiff(old_names, names)
[08:28:27.046]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.046]                   envs[common]]
[08:28:27.046]                 NAMES <- toupper(changed)
[08:28:27.046]                 args <- list()
[08:28:27.046]                 for (kk in seq_along(NAMES)) {
[08:28:27.046]                   name <- changed[[kk]]
[08:28:27.046]                   NAME <- NAMES[[kk]]
[08:28:27.046]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.046]                     next
[08:28:27.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.046]                 }
[08:28:27.046]                 NAMES <- toupper(added)
[08:28:27.046]                 for (kk in seq_along(NAMES)) {
[08:28:27.046]                   name <- added[[kk]]
[08:28:27.046]                   NAME <- NAMES[[kk]]
[08:28:27.046]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.046]                     next
[08:28:27.046]                   args[[name]] <- ""
[08:28:27.046]                 }
[08:28:27.046]                 NAMES <- toupper(removed)
[08:28:27.046]                 for (kk in seq_along(NAMES)) {
[08:28:27.046]                   name <- removed[[kk]]
[08:28:27.046]                   NAME <- NAMES[[kk]]
[08:28:27.046]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.046]                     next
[08:28:27.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.046]                 }
[08:28:27.046]                 if (length(args) > 0) 
[08:28:27.046]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.046]             }
[08:28:27.046]             else {
[08:28:27.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.046]             }
[08:28:27.046]             {
[08:28:27.046]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.046]                   0L) {
[08:28:27.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.046]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.046]                   base::options(opts)
[08:28:27.046]                 }
[08:28:27.046]                 {
[08:28:27.046]                   {
[08:28:27.046]                     NULL
[08:28:27.046]                     RNGkind("Mersenne-Twister")
[08:28:27.046]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.046]                       inherits = FALSE)
[08:28:27.046]                   }
[08:28:27.046]                   options(future.plan = NULL)
[08:28:27.046]                   if (is.na(NA_character_)) 
[08:28:27.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.046]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.046]                     .init = FALSE)
[08:28:27.046]                 }
[08:28:27.046]             }
[08:28:27.046]         }
[08:28:27.046]     })
[08:28:27.046]     if (TRUE) {
[08:28:27.046]         base::sink(type = "output", split = FALSE)
[08:28:27.046]         if (TRUE) {
[08:28:27.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.046]         }
[08:28:27.046]         else {
[08:28:27.046]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.046]         }
[08:28:27.046]         base::close(...future.stdout)
[08:28:27.046]         ...future.stdout <- NULL
[08:28:27.046]     }
[08:28:27.046]     ...future.result$conditions <- ...future.conditions
[08:28:27.046]     ...future.result$finished <- base::Sys.time()
[08:28:27.046]     ...future.result
[08:28:27.046] }
[08:28:27.048] plan(): Setting new future strategy stack:
[08:28:27.048] List of future strategies:
[08:28:27.048] 1. sequential:
[08:28:27.048]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.048]    - tweaked: FALSE
[08:28:27.048]    - call: NULL
[08:28:27.049] plan(): nbrOfWorkers() = 1
[08:28:27.049] plan(): Setting new future strategy stack:
[08:28:27.049] List of future strategies:
[08:28:27.049] 1. multicore:
[08:28:27.049]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.049]    - tweaked: FALSE
[08:28:27.049]    - call: plan(multicore)
[08:28:27.051] plan(): nbrOfWorkers() = 1
[08:28:27.051] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[08:28:27.053] getGlobalsAndPackages() ...
[08:28:27.053] Not searching for globals
[08:28:27.053] - globals: [0] <none>
[08:28:27.053] getGlobalsAndPackages() ... DONE
[08:28:27.053] Packages needed by the future expression (n = 0): <none>
[08:28:27.053] Packages needed by future strategies (n = 0): <none>
[08:28:27.054] {
[08:28:27.054]     {
[08:28:27.054]         {
[08:28:27.054]             ...future.startTime <- base::Sys.time()
[08:28:27.054]             {
[08:28:27.054]                 {
[08:28:27.054]                   {
[08:28:27.054]                     base::local({
[08:28:27.054]                       has_future <- base::requireNamespace("future", 
[08:28:27.054]                         quietly = TRUE)
[08:28:27.054]                       if (has_future) {
[08:28:27.054]                         ns <- base::getNamespace("future")
[08:28:27.054]                         version <- ns[[".package"]][["version"]]
[08:28:27.054]                         if (is.null(version)) 
[08:28:27.054]                           version <- utils::packageVersion("future")
[08:28:27.054]                       }
[08:28:27.054]                       else {
[08:28:27.054]                         version <- NULL
[08:28:27.054]                       }
[08:28:27.054]                       if (!has_future || version < "1.8.0") {
[08:28:27.054]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.054]                           "", base::R.version$version.string), 
[08:28:27.054]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.054]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.054]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.054]                             "release", "version")], collapse = " "), 
[08:28:27.054]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.054]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.054]                           info)
[08:28:27.054]                         info <- base::paste(info, collapse = "; ")
[08:28:27.054]                         if (!has_future) {
[08:28:27.054]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.054]                             info)
[08:28:27.054]                         }
[08:28:27.054]                         else {
[08:28:27.054]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.054]                             info, version)
[08:28:27.054]                         }
[08:28:27.054]                         base::stop(msg)
[08:28:27.054]                       }
[08:28:27.054]                     })
[08:28:27.054]                   }
[08:28:27.054]                   ...future.strategy.old <- future::plan("list")
[08:28:27.054]                   options(future.plan = NULL)
[08:28:27.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.054]                 }
[08:28:27.054]                 ...future.workdir <- getwd()
[08:28:27.054]             }
[08:28:27.054]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.054]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.054]         }
[08:28:27.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.054]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.054]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.054]             base::names(...future.oldOptions))
[08:28:27.054]     }
[08:28:27.054]     if (FALSE) {
[08:28:27.054]     }
[08:28:27.054]     else {
[08:28:27.054]         if (TRUE) {
[08:28:27.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.054]                 open = "w")
[08:28:27.054]         }
[08:28:27.054]         else {
[08:28:27.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.054]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.054]         }
[08:28:27.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.054]             base::sink(type = "output", split = FALSE)
[08:28:27.054]             base::close(...future.stdout)
[08:28:27.054]         }, add = TRUE)
[08:28:27.054]     }
[08:28:27.054]     ...future.frame <- base::sys.nframe()
[08:28:27.054]     ...future.conditions <- base::list()
[08:28:27.054]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.054]     if (FALSE) {
[08:28:27.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.054]     }
[08:28:27.054]     ...future.result <- base::tryCatch({
[08:28:27.054]         base::withCallingHandlers({
[08:28:27.054]             ...future.value <- base::withVisible(base::local({
[08:28:27.054]                 ii
[08:28:27.054]             }))
[08:28:27.054]             future::FutureResult(value = ...future.value$value, 
[08:28:27.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.054]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.054]                     ...future.globalenv.names))
[08:28:27.054]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.054]         }, condition = base::local({
[08:28:27.054]             c <- base::c
[08:28:27.054]             inherits <- base::inherits
[08:28:27.054]             invokeRestart <- base::invokeRestart
[08:28:27.054]             length <- base::length
[08:28:27.054]             list <- base::list
[08:28:27.054]             seq.int <- base::seq.int
[08:28:27.054]             signalCondition <- base::signalCondition
[08:28:27.054]             sys.calls <- base::sys.calls
[08:28:27.054]             `[[` <- base::`[[`
[08:28:27.054]             `+` <- base::`+`
[08:28:27.054]             `<<-` <- base::`<<-`
[08:28:27.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.054]                   3L)]
[08:28:27.054]             }
[08:28:27.054]             function(cond) {
[08:28:27.054]                 is_error <- inherits(cond, "error")
[08:28:27.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.054]                   NULL)
[08:28:27.054]                 if (is_error) {
[08:28:27.054]                   sessionInformation <- function() {
[08:28:27.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.054]                       search = base::search(), system = base::Sys.info())
[08:28:27.054]                   }
[08:28:27.054]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.054]                     cond$call), session = sessionInformation(), 
[08:28:27.054]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.054]                   signalCondition(cond)
[08:28:27.054]                 }
[08:28:27.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.054]                 "immediateCondition"))) {
[08:28:27.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.054]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.054]                   if (TRUE && !signal) {
[08:28:27.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.054]                     {
[08:28:27.054]                       inherits <- base::inherits
[08:28:27.054]                       invokeRestart <- base::invokeRestart
[08:28:27.054]                       is.null <- base::is.null
[08:28:27.054]                       muffled <- FALSE
[08:28:27.054]                       if (inherits(cond, "message")) {
[08:28:27.054]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.054]                         if (muffled) 
[08:28:27.054]                           invokeRestart("muffleMessage")
[08:28:27.054]                       }
[08:28:27.054]                       else if (inherits(cond, "warning")) {
[08:28:27.054]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.054]                         if (muffled) 
[08:28:27.054]                           invokeRestart("muffleWarning")
[08:28:27.054]                       }
[08:28:27.054]                       else if (inherits(cond, "condition")) {
[08:28:27.054]                         if (!is.null(pattern)) {
[08:28:27.054]                           computeRestarts <- base::computeRestarts
[08:28:27.054]                           grepl <- base::grepl
[08:28:27.054]                           restarts <- computeRestarts(cond)
[08:28:27.054]                           for (restart in restarts) {
[08:28:27.054]                             name <- restart$name
[08:28:27.054]                             if (is.null(name)) 
[08:28:27.054]                               next
[08:28:27.054]                             if (!grepl(pattern, name)) 
[08:28:27.054]                               next
[08:28:27.054]                             invokeRestart(restart)
[08:28:27.054]                             muffled <- TRUE
[08:28:27.054]                             break
[08:28:27.054]                           }
[08:28:27.054]                         }
[08:28:27.054]                       }
[08:28:27.054]                       invisible(muffled)
[08:28:27.054]                     }
[08:28:27.054]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.054]                   }
[08:28:27.054]                 }
[08:28:27.054]                 else {
[08:28:27.054]                   if (TRUE) {
[08:28:27.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.054]                     {
[08:28:27.054]                       inherits <- base::inherits
[08:28:27.054]                       invokeRestart <- base::invokeRestart
[08:28:27.054]                       is.null <- base::is.null
[08:28:27.054]                       muffled <- FALSE
[08:28:27.054]                       if (inherits(cond, "message")) {
[08:28:27.054]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.054]                         if (muffled) 
[08:28:27.054]                           invokeRestart("muffleMessage")
[08:28:27.054]                       }
[08:28:27.054]                       else if (inherits(cond, "warning")) {
[08:28:27.054]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.054]                         if (muffled) 
[08:28:27.054]                           invokeRestart("muffleWarning")
[08:28:27.054]                       }
[08:28:27.054]                       else if (inherits(cond, "condition")) {
[08:28:27.054]                         if (!is.null(pattern)) {
[08:28:27.054]                           computeRestarts <- base::computeRestarts
[08:28:27.054]                           grepl <- base::grepl
[08:28:27.054]                           restarts <- computeRestarts(cond)
[08:28:27.054]                           for (restart in restarts) {
[08:28:27.054]                             name <- restart$name
[08:28:27.054]                             if (is.null(name)) 
[08:28:27.054]                               next
[08:28:27.054]                             if (!grepl(pattern, name)) 
[08:28:27.054]                               next
[08:28:27.054]                             invokeRestart(restart)
[08:28:27.054]                             muffled <- TRUE
[08:28:27.054]                             break
[08:28:27.054]                           }
[08:28:27.054]                         }
[08:28:27.054]                       }
[08:28:27.054]                       invisible(muffled)
[08:28:27.054]                     }
[08:28:27.054]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.054]                   }
[08:28:27.054]                 }
[08:28:27.054]             }
[08:28:27.054]         }))
[08:28:27.054]     }, error = function(ex) {
[08:28:27.054]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.054]                 ...future.rng), started = ...future.startTime, 
[08:28:27.054]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.054]             version = "1.8"), class = "FutureResult")
[08:28:27.054]     }, finally = {
[08:28:27.054]         if (!identical(...future.workdir, getwd())) 
[08:28:27.054]             setwd(...future.workdir)
[08:28:27.054]         {
[08:28:27.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.054]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.054]             }
[08:28:27.054]             base::options(...future.oldOptions)
[08:28:27.054]             if (.Platform$OS.type == "windows") {
[08:28:27.054]                 old_names <- names(...future.oldEnvVars)
[08:28:27.054]                 envs <- base::Sys.getenv()
[08:28:27.054]                 names <- names(envs)
[08:28:27.054]                 common <- intersect(names, old_names)
[08:28:27.054]                 added <- setdiff(names, old_names)
[08:28:27.054]                 removed <- setdiff(old_names, names)
[08:28:27.054]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.054]                   envs[common]]
[08:28:27.054]                 NAMES <- toupper(changed)
[08:28:27.054]                 args <- list()
[08:28:27.054]                 for (kk in seq_along(NAMES)) {
[08:28:27.054]                   name <- changed[[kk]]
[08:28:27.054]                   NAME <- NAMES[[kk]]
[08:28:27.054]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.054]                     next
[08:28:27.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.054]                 }
[08:28:27.054]                 NAMES <- toupper(added)
[08:28:27.054]                 for (kk in seq_along(NAMES)) {
[08:28:27.054]                   name <- added[[kk]]
[08:28:27.054]                   NAME <- NAMES[[kk]]
[08:28:27.054]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.054]                     next
[08:28:27.054]                   args[[name]] <- ""
[08:28:27.054]                 }
[08:28:27.054]                 NAMES <- toupper(removed)
[08:28:27.054]                 for (kk in seq_along(NAMES)) {
[08:28:27.054]                   name <- removed[[kk]]
[08:28:27.054]                   NAME <- NAMES[[kk]]
[08:28:27.054]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.054]                     next
[08:28:27.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.054]                 }
[08:28:27.054]                 if (length(args) > 0) 
[08:28:27.054]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.054]             }
[08:28:27.054]             else {
[08:28:27.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.054]             }
[08:28:27.054]             {
[08:28:27.054]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.054]                   0L) {
[08:28:27.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.054]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.054]                   base::options(opts)
[08:28:27.054]                 }
[08:28:27.054]                 {
[08:28:27.054]                   {
[08:28:27.054]                     NULL
[08:28:27.054]                     RNGkind("Mersenne-Twister")
[08:28:27.054]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.054]                       inherits = FALSE)
[08:28:27.054]                   }
[08:28:27.054]                   options(future.plan = NULL)
[08:28:27.054]                   if (is.na(NA_character_)) 
[08:28:27.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.054]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.054]                     .init = FALSE)
[08:28:27.054]                 }
[08:28:27.054]             }
[08:28:27.054]         }
[08:28:27.054]     })
[08:28:27.054]     if (TRUE) {
[08:28:27.054]         base::sink(type = "output", split = FALSE)
[08:28:27.054]         if (TRUE) {
[08:28:27.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.054]         }
[08:28:27.054]         else {
[08:28:27.054]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.054]         }
[08:28:27.054]         base::close(...future.stdout)
[08:28:27.054]         ...future.stdout <- NULL
[08:28:27.054]     }
[08:28:27.054]     ...future.result$conditions <- ...future.conditions
[08:28:27.054]     ...future.result$finished <- base::Sys.time()
[08:28:27.054]     ...future.result
[08:28:27.054] }
[08:28:27.056] plan(): Setting new future strategy stack:
[08:28:27.056] List of future strategies:
[08:28:27.056] 1. sequential:
[08:28:27.056]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.056]    - tweaked: FALSE
[08:28:27.056]    - call: NULL
[08:28:27.056] plan(): nbrOfWorkers() = 1
[08:28:27.057] plan(): Setting new future strategy stack:
[08:28:27.057] List of future strategies:
[08:28:27.057] 1. multicore:
[08:28:27.057]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.057]    - tweaked: FALSE
[08:28:27.057]    - call: plan(multicore)
[08:28:27.058] plan(): nbrOfWorkers() = 1
[08:28:27.059] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = FALSE) and errors
[08:28:27.061] getGlobalsAndPackages() ...
[08:28:27.061] Not searching for globals
[08:28:27.061] - globals: [0] <none>
[08:28:27.061] getGlobalsAndPackages() ... DONE
[08:28:27.061] Packages needed by the future expression (n = 0): <none>
[08:28:27.061] Packages needed by future strategies (n = 0): <none>
[08:28:27.062] {
[08:28:27.062]     {
[08:28:27.062]         {
[08:28:27.062]             ...future.startTime <- base::Sys.time()
[08:28:27.062]             {
[08:28:27.062]                 {
[08:28:27.062]                   {
[08:28:27.062]                     base::local({
[08:28:27.062]                       has_future <- base::requireNamespace("future", 
[08:28:27.062]                         quietly = TRUE)
[08:28:27.062]                       if (has_future) {
[08:28:27.062]                         ns <- base::getNamespace("future")
[08:28:27.062]                         version <- ns[[".package"]][["version"]]
[08:28:27.062]                         if (is.null(version)) 
[08:28:27.062]                           version <- utils::packageVersion("future")
[08:28:27.062]                       }
[08:28:27.062]                       else {
[08:28:27.062]                         version <- NULL
[08:28:27.062]                       }
[08:28:27.062]                       if (!has_future || version < "1.8.0") {
[08:28:27.062]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.062]                           "", base::R.version$version.string), 
[08:28:27.062]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.062]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.062]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.062]                             "release", "version")], collapse = " "), 
[08:28:27.062]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.062]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.062]                           info)
[08:28:27.062]                         info <- base::paste(info, collapse = "; ")
[08:28:27.062]                         if (!has_future) {
[08:28:27.062]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.062]                             info)
[08:28:27.062]                         }
[08:28:27.062]                         else {
[08:28:27.062]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.062]                             info, version)
[08:28:27.062]                         }
[08:28:27.062]                         base::stop(msg)
[08:28:27.062]                       }
[08:28:27.062]                     })
[08:28:27.062]                   }
[08:28:27.062]                   ...future.strategy.old <- future::plan("list")
[08:28:27.062]                   options(future.plan = NULL)
[08:28:27.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.062]                 }
[08:28:27.062]                 ...future.workdir <- getwd()
[08:28:27.062]             }
[08:28:27.062]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.062]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.062]         }
[08:28:27.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.062]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.062]             base::names(...future.oldOptions))
[08:28:27.062]     }
[08:28:27.062]     if (FALSE) {
[08:28:27.062]     }
[08:28:27.062]     else {
[08:28:27.062]         if (TRUE) {
[08:28:27.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.062]                 open = "w")
[08:28:27.062]         }
[08:28:27.062]         else {
[08:28:27.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.062]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.062]         }
[08:28:27.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.062]             base::sink(type = "output", split = FALSE)
[08:28:27.062]             base::close(...future.stdout)
[08:28:27.062]         }, add = TRUE)
[08:28:27.062]     }
[08:28:27.062]     ...future.frame <- base::sys.nframe()
[08:28:27.062]     ...future.conditions <- base::list()
[08:28:27.062]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.062]     if (FALSE) {
[08:28:27.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.062]     }
[08:28:27.062]     ...future.result <- base::tryCatch({
[08:28:27.062]         base::withCallingHandlers({
[08:28:27.062]             ...future.value <- base::withVisible(base::local({
[08:28:27.062]                 stop("Whoops!")
[08:28:27.062]                 1
[08:28:27.062]             }))
[08:28:27.062]             future::FutureResult(value = ...future.value$value, 
[08:28:27.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.062]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.062]                     ...future.globalenv.names))
[08:28:27.062]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.062]         }, condition = base::local({
[08:28:27.062]             c <- base::c
[08:28:27.062]             inherits <- base::inherits
[08:28:27.062]             invokeRestart <- base::invokeRestart
[08:28:27.062]             length <- base::length
[08:28:27.062]             list <- base::list
[08:28:27.062]             seq.int <- base::seq.int
[08:28:27.062]             signalCondition <- base::signalCondition
[08:28:27.062]             sys.calls <- base::sys.calls
[08:28:27.062]             `[[` <- base::`[[`
[08:28:27.062]             `+` <- base::`+`
[08:28:27.062]             `<<-` <- base::`<<-`
[08:28:27.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.062]                   3L)]
[08:28:27.062]             }
[08:28:27.062]             function(cond) {
[08:28:27.062]                 is_error <- inherits(cond, "error")
[08:28:27.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.062]                   NULL)
[08:28:27.062]                 if (is_error) {
[08:28:27.062]                   sessionInformation <- function() {
[08:28:27.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.062]                       search = base::search(), system = base::Sys.info())
[08:28:27.062]                   }
[08:28:27.062]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.062]                     cond$call), session = sessionInformation(), 
[08:28:27.062]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.062]                   signalCondition(cond)
[08:28:27.062]                 }
[08:28:27.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.062]                 "immediateCondition"))) {
[08:28:27.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.062]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.062]                   if (TRUE && !signal) {
[08:28:27.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.062]                     {
[08:28:27.062]                       inherits <- base::inherits
[08:28:27.062]                       invokeRestart <- base::invokeRestart
[08:28:27.062]                       is.null <- base::is.null
[08:28:27.062]                       muffled <- FALSE
[08:28:27.062]                       if (inherits(cond, "message")) {
[08:28:27.062]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.062]                         if (muffled) 
[08:28:27.062]                           invokeRestart("muffleMessage")
[08:28:27.062]                       }
[08:28:27.062]                       else if (inherits(cond, "warning")) {
[08:28:27.062]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.062]                         if (muffled) 
[08:28:27.062]                           invokeRestart("muffleWarning")
[08:28:27.062]                       }
[08:28:27.062]                       else if (inherits(cond, "condition")) {
[08:28:27.062]                         if (!is.null(pattern)) {
[08:28:27.062]                           computeRestarts <- base::computeRestarts
[08:28:27.062]                           grepl <- base::grepl
[08:28:27.062]                           restarts <- computeRestarts(cond)
[08:28:27.062]                           for (restart in restarts) {
[08:28:27.062]                             name <- restart$name
[08:28:27.062]                             if (is.null(name)) 
[08:28:27.062]                               next
[08:28:27.062]                             if (!grepl(pattern, name)) 
[08:28:27.062]                               next
[08:28:27.062]                             invokeRestart(restart)
[08:28:27.062]                             muffled <- TRUE
[08:28:27.062]                             break
[08:28:27.062]                           }
[08:28:27.062]                         }
[08:28:27.062]                       }
[08:28:27.062]                       invisible(muffled)
[08:28:27.062]                     }
[08:28:27.062]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.062]                   }
[08:28:27.062]                 }
[08:28:27.062]                 else {
[08:28:27.062]                   if (TRUE) {
[08:28:27.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.062]                     {
[08:28:27.062]                       inherits <- base::inherits
[08:28:27.062]                       invokeRestart <- base::invokeRestart
[08:28:27.062]                       is.null <- base::is.null
[08:28:27.062]                       muffled <- FALSE
[08:28:27.062]                       if (inherits(cond, "message")) {
[08:28:27.062]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.062]                         if (muffled) 
[08:28:27.062]                           invokeRestart("muffleMessage")
[08:28:27.062]                       }
[08:28:27.062]                       else if (inherits(cond, "warning")) {
[08:28:27.062]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.062]                         if (muffled) 
[08:28:27.062]                           invokeRestart("muffleWarning")
[08:28:27.062]                       }
[08:28:27.062]                       else if (inherits(cond, "condition")) {
[08:28:27.062]                         if (!is.null(pattern)) {
[08:28:27.062]                           computeRestarts <- base::computeRestarts
[08:28:27.062]                           grepl <- base::grepl
[08:28:27.062]                           restarts <- computeRestarts(cond)
[08:28:27.062]                           for (restart in restarts) {
[08:28:27.062]                             name <- restart$name
[08:28:27.062]                             if (is.null(name)) 
[08:28:27.062]                               next
[08:28:27.062]                             if (!grepl(pattern, name)) 
[08:28:27.062]                               next
[08:28:27.062]                             invokeRestart(restart)
[08:28:27.062]                             muffled <- TRUE
[08:28:27.062]                             break
[08:28:27.062]                           }
[08:28:27.062]                         }
[08:28:27.062]                       }
[08:28:27.062]                       invisible(muffled)
[08:28:27.062]                     }
[08:28:27.062]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.062]                   }
[08:28:27.062]                 }
[08:28:27.062]             }
[08:28:27.062]         }))
[08:28:27.062]     }, error = function(ex) {
[08:28:27.062]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.062]                 ...future.rng), started = ...future.startTime, 
[08:28:27.062]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.062]             version = "1.8"), class = "FutureResult")
[08:28:27.062]     }, finally = {
[08:28:27.062]         if (!identical(...future.workdir, getwd())) 
[08:28:27.062]             setwd(...future.workdir)
[08:28:27.062]         {
[08:28:27.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.062]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.062]             }
[08:28:27.062]             base::options(...future.oldOptions)
[08:28:27.062]             if (.Platform$OS.type == "windows") {
[08:28:27.062]                 old_names <- names(...future.oldEnvVars)
[08:28:27.062]                 envs <- base::Sys.getenv()
[08:28:27.062]                 names <- names(envs)
[08:28:27.062]                 common <- intersect(names, old_names)
[08:28:27.062]                 added <- setdiff(names, old_names)
[08:28:27.062]                 removed <- setdiff(old_names, names)
[08:28:27.062]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.062]                   envs[common]]
[08:28:27.062]                 NAMES <- toupper(changed)
[08:28:27.062]                 args <- list()
[08:28:27.062]                 for (kk in seq_along(NAMES)) {
[08:28:27.062]                   name <- changed[[kk]]
[08:28:27.062]                   NAME <- NAMES[[kk]]
[08:28:27.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.062]                     next
[08:28:27.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.062]                 }
[08:28:27.062]                 NAMES <- toupper(added)
[08:28:27.062]                 for (kk in seq_along(NAMES)) {
[08:28:27.062]                   name <- added[[kk]]
[08:28:27.062]                   NAME <- NAMES[[kk]]
[08:28:27.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.062]                     next
[08:28:27.062]                   args[[name]] <- ""
[08:28:27.062]                 }
[08:28:27.062]                 NAMES <- toupper(removed)
[08:28:27.062]                 for (kk in seq_along(NAMES)) {
[08:28:27.062]                   name <- removed[[kk]]
[08:28:27.062]                   NAME <- NAMES[[kk]]
[08:28:27.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.062]                     next
[08:28:27.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.062]                 }
[08:28:27.062]                 if (length(args) > 0) 
[08:28:27.062]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.062]             }
[08:28:27.062]             else {
[08:28:27.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.062]             }
[08:28:27.062]             {
[08:28:27.062]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.062]                   0L) {
[08:28:27.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.062]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.062]                   base::options(opts)
[08:28:27.062]                 }
[08:28:27.062]                 {
[08:28:27.062]                   {
[08:28:27.062]                     NULL
[08:28:27.062]                     RNGkind("Mersenne-Twister")
[08:28:27.062]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.062]                       inherits = FALSE)
[08:28:27.062]                   }
[08:28:27.062]                   options(future.plan = NULL)
[08:28:27.062]                   if (is.na(NA_character_)) 
[08:28:27.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.062]                     .init = FALSE)
[08:28:27.062]                 }
[08:28:27.062]             }
[08:28:27.062]         }
[08:28:27.062]     })
[08:28:27.062]     if (TRUE) {
[08:28:27.062]         base::sink(type = "output", split = FALSE)
[08:28:27.062]         if (TRUE) {
[08:28:27.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.062]         }
[08:28:27.062]         else {
[08:28:27.062]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.062]         }
[08:28:27.062]         base::close(...future.stdout)
[08:28:27.062]         ...future.stdout <- NULL
[08:28:27.062]     }
[08:28:27.062]     ...future.result$conditions <- ...future.conditions
[08:28:27.062]     ...future.result$finished <- base::Sys.time()
[08:28:27.062]     ...future.result
[08:28:27.062] }
[08:28:27.064] plan(): Setting new future strategy stack:
[08:28:27.064] List of future strategies:
[08:28:27.064] 1. sequential:
[08:28:27.064]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.064]    - tweaked: FALSE
[08:28:27.064]    - call: NULL
[08:28:27.064] plan(): nbrOfWorkers() = 1
[08:28:27.065] plan(): Setting new future strategy stack:
[08:28:27.065] List of future strategies:
[08:28:27.065] 1. multicore:
[08:28:27.065]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.065]    - tweaked: FALSE
[08:28:27.065]    - call: plan(multicore)
[08:28:27.067] plan(): nbrOfWorkers() = 1
[08:28:27.067] SequentialFuture started (and completed)
[08:28:27.067] signalConditions() ...
[08:28:27.067]  - include = ‘immediateCondition’
[08:28:27.067]  - exclude = 
[08:28:27.067]  - resignal = FALSE
[08:28:27.067]  - Number of conditions: 1
[08:28:27.067] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 27 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:27.068] signalConditions() ...
[08:28:27.068]  - include = ‘immediateCondition’
[08:28:27.068]  - exclude = 
[08:28:27.068]  - resignal = FALSE
[08:28:27.068]  - Number of conditions: 1
[08:28:27.068] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[08:28:27.069] signalConditions() ...
[08:28:27.069]  - include = ‘immediateCondition’
[08:28:27.069]  - exclude = 
[08:28:27.069]  - resignal = FALSE
[08:28:27.069]  - Number of conditions: 1
[08:28:27.069] signalConditions() ... done
[08:28:27.069] Future state: ‘finished’
[08:28:27.069] signalConditions() ...
[08:28:27.069]  - include = ‘condition’
[08:28:27.069]  - exclude = ‘immediateCondition’
[08:28:27.070]  - resignal = TRUE
[08:28:27.070]  - Number of conditions: 1
[08:28:27.070]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:27.070] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[08:28:27.070] signalConditions() ...
[08:28:27.070]  - include = ‘immediateCondition’
[08:28:27.070]  - exclude = 
[08:28:27.070]  - resignal = FALSE
[08:28:27.070]  - Number of conditions: 1
[08:28:27.071] signalConditions() ... done
[08:28:27.071] Future state: ‘finished’
[08:28:27.071] signalConditions() ...
[08:28:27.071]  - include = ‘condition’
[08:28:27.071]  - exclude = ‘immediateCondition’
[08:28:27.071]  - resignal = TRUE
[08:28:27.071]  - Number of conditions: 1
[08:28:27.071]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:27.071] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[08:28:27.073] getGlobalsAndPackages() ...
[08:28:27.073] Searching for globals...
[08:28:27.081] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[08:28:27.082] Searching for globals ... DONE
[08:28:27.082] Resolving globals: FALSE
[08:28:27.082] 
[08:28:27.082] 
[08:28:27.082] getGlobalsAndPackages() ... DONE
[08:28:27.083] Packages needed by the future expression (n = 0): <none>
[08:28:27.083] Packages needed by future strategies (n = 0): <none>
[08:28:27.083] {
[08:28:27.083]     {
[08:28:27.083]         {
[08:28:27.083]             ...future.startTime <- base::Sys.time()
[08:28:27.083]             {
[08:28:27.083]                 {
[08:28:27.083]                   {
[08:28:27.083]                     base::local({
[08:28:27.083]                       has_future <- base::requireNamespace("future", 
[08:28:27.083]                         quietly = TRUE)
[08:28:27.083]                       if (has_future) {
[08:28:27.083]                         ns <- base::getNamespace("future")
[08:28:27.083]                         version <- ns[[".package"]][["version"]]
[08:28:27.083]                         if (is.null(version)) 
[08:28:27.083]                           version <- utils::packageVersion("future")
[08:28:27.083]                       }
[08:28:27.083]                       else {
[08:28:27.083]                         version <- NULL
[08:28:27.083]                       }
[08:28:27.083]                       if (!has_future || version < "1.8.0") {
[08:28:27.083]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.083]                           "", base::R.version$version.string), 
[08:28:27.083]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.083]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.083]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.083]                             "release", "version")], collapse = " "), 
[08:28:27.083]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.083]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.083]                           info)
[08:28:27.083]                         info <- base::paste(info, collapse = "; ")
[08:28:27.083]                         if (!has_future) {
[08:28:27.083]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.083]                             info)
[08:28:27.083]                         }
[08:28:27.083]                         else {
[08:28:27.083]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.083]                             info, version)
[08:28:27.083]                         }
[08:28:27.083]                         base::stop(msg)
[08:28:27.083]                       }
[08:28:27.083]                     })
[08:28:27.083]                   }
[08:28:27.083]                   ...future.strategy.old <- future::plan("list")
[08:28:27.083]                   options(future.plan = NULL)
[08:28:27.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.083]                 }
[08:28:27.083]                 ...future.workdir <- getwd()
[08:28:27.083]             }
[08:28:27.083]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.083]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.083]         }
[08:28:27.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.083]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.083]             base::names(...future.oldOptions))
[08:28:27.083]     }
[08:28:27.083]     if (FALSE) {
[08:28:27.083]     }
[08:28:27.083]     else {
[08:28:27.083]         if (TRUE) {
[08:28:27.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.083]                 open = "w")
[08:28:27.083]         }
[08:28:27.083]         else {
[08:28:27.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.083]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.083]         }
[08:28:27.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.083]             base::sink(type = "output", split = FALSE)
[08:28:27.083]             base::close(...future.stdout)
[08:28:27.083]         }, add = TRUE)
[08:28:27.083]     }
[08:28:27.083]     ...future.frame <- base::sys.nframe()
[08:28:27.083]     ...future.conditions <- base::list()
[08:28:27.083]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.083]     if (FALSE) {
[08:28:27.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.083]     }
[08:28:27.083]     ...future.result <- base::tryCatch({
[08:28:27.083]         base::withCallingHandlers({
[08:28:27.083]             ...future.value <- base::withVisible(base::local({
[08:28:27.083]                 stop(structure(list(message = "boom"), class = c("MyError", 
[08:28:27.083]                   "error", "condition")))
[08:28:27.083]             }))
[08:28:27.083]             future::FutureResult(value = ...future.value$value, 
[08:28:27.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.083]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.083]                     ...future.globalenv.names))
[08:28:27.083]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.083]         }, condition = base::local({
[08:28:27.083]             c <- base::c
[08:28:27.083]             inherits <- base::inherits
[08:28:27.083]             invokeRestart <- base::invokeRestart
[08:28:27.083]             length <- base::length
[08:28:27.083]             list <- base::list
[08:28:27.083]             seq.int <- base::seq.int
[08:28:27.083]             signalCondition <- base::signalCondition
[08:28:27.083]             sys.calls <- base::sys.calls
[08:28:27.083]             `[[` <- base::`[[`
[08:28:27.083]             `+` <- base::`+`
[08:28:27.083]             `<<-` <- base::`<<-`
[08:28:27.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.083]                   3L)]
[08:28:27.083]             }
[08:28:27.083]             function(cond) {
[08:28:27.083]                 is_error <- inherits(cond, "error")
[08:28:27.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.083]                   NULL)
[08:28:27.083]                 if (is_error) {
[08:28:27.083]                   sessionInformation <- function() {
[08:28:27.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.083]                       search = base::search(), system = base::Sys.info())
[08:28:27.083]                   }
[08:28:27.083]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.083]                     cond$call), session = sessionInformation(), 
[08:28:27.083]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.083]                   signalCondition(cond)
[08:28:27.083]                 }
[08:28:27.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.083]                 "immediateCondition"))) {
[08:28:27.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.083]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.083]                   if (TRUE && !signal) {
[08:28:27.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.083]                     {
[08:28:27.083]                       inherits <- base::inherits
[08:28:27.083]                       invokeRestart <- base::invokeRestart
[08:28:27.083]                       is.null <- base::is.null
[08:28:27.083]                       muffled <- FALSE
[08:28:27.083]                       if (inherits(cond, "message")) {
[08:28:27.083]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.083]                         if (muffled) 
[08:28:27.083]                           invokeRestart("muffleMessage")
[08:28:27.083]                       }
[08:28:27.083]                       else if (inherits(cond, "warning")) {
[08:28:27.083]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.083]                         if (muffled) 
[08:28:27.083]                           invokeRestart("muffleWarning")
[08:28:27.083]                       }
[08:28:27.083]                       else if (inherits(cond, "condition")) {
[08:28:27.083]                         if (!is.null(pattern)) {
[08:28:27.083]                           computeRestarts <- base::computeRestarts
[08:28:27.083]                           grepl <- base::grepl
[08:28:27.083]                           restarts <- computeRestarts(cond)
[08:28:27.083]                           for (restart in restarts) {
[08:28:27.083]                             name <- restart$name
[08:28:27.083]                             if (is.null(name)) 
[08:28:27.083]                               next
[08:28:27.083]                             if (!grepl(pattern, name)) 
[08:28:27.083]                               next
[08:28:27.083]                             invokeRestart(restart)
[08:28:27.083]                             muffled <- TRUE
[08:28:27.083]                             break
[08:28:27.083]                           }
[08:28:27.083]                         }
[08:28:27.083]                       }
[08:28:27.083]                       invisible(muffled)
[08:28:27.083]                     }
[08:28:27.083]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.083]                   }
[08:28:27.083]                 }
[08:28:27.083]                 else {
[08:28:27.083]                   if (TRUE) {
[08:28:27.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.083]                     {
[08:28:27.083]                       inherits <- base::inherits
[08:28:27.083]                       invokeRestart <- base::invokeRestart
[08:28:27.083]                       is.null <- base::is.null
[08:28:27.083]                       muffled <- FALSE
[08:28:27.083]                       if (inherits(cond, "message")) {
[08:28:27.083]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.083]                         if (muffled) 
[08:28:27.083]                           invokeRestart("muffleMessage")
[08:28:27.083]                       }
[08:28:27.083]                       else if (inherits(cond, "warning")) {
[08:28:27.083]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.083]                         if (muffled) 
[08:28:27.083]                           invokeRestart("muffleWarning")
[08:28:27.083]                       }
[08:28:27.083]                       else if (inherits(cond, "condition")) {
[08:28:27.083]                         if (!is.null(pattern)) {
[08:28:27.083]                           computeRestarts <- base::computeRestarts
[08:28:27.083]                           grepl <- base::grepl
[08:28:27.083]                           restarts <- computeRestarts(cond)
[08:28:27.083]                           for (restart in restarts) {
[08:28:27.083]                             name <- restart$name
[08:28:27.083]                             if (is.null(name)) 
[08:28:27.083]                               next
[08:28:27.083]                             if (!grepl(pattern, name)) 
[08:28:27.083]                               next
[08:28:27.083]                             invokeRestart(restart)
[08:28:27.083]                             muffled <- TRUE
[08:28:27.083]                             break
[08:28:27.083]                           }
[08:28:27.083]                         }
[08:28:27.083]                       }
[08:28:27.083]                       invisible(muffled)
[08:28:27.083]                     }
[08:28:27.083]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.083]                   }
[08:28:27.083]                 }
[08:28:27.083]             }
[08:28:27.083]         }))
[08:28:27.083]     }, error = function(ex) {
[08:28:27.083]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.083]                 ...future.rng), started = ...future.startTime, 
[08:28:27.083]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.083]             version = "1.8"), class = "FutureResult")
[08:28:27.083]     }, finally = {
[08:28:27.083]         if (!identical(...future.workdir, getwd())) 
[08:28:27.083]             setwd(...future.workdir)
[08:28:27.083]         {
[08:28:27.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.083]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.083]             }
[08:28:27.083]             base::options(...future.oldOptions)
[08:28:27.083]             if (.Platform$OS.type == "windows") {
[08:28:27.083]                 old_names <- names(...future.oldEnvVars)
[08:28:27.083]                 envs <- base::Sys.getenv()
[08:28:27.083]                 names <- names(envs)
[08:28:27.083]                 common <- intersect(names, old_names)
[08:28:27.083]                 added <- setdiff(names, old_names)
[08:28:27.083]                 removed <- setdiff(old_names, names)
[08:28:27.083]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.083]                   envs[common]]
[08:28:27.083]                 NAMES <- toupper(changed)
[08:28:27.083]                 args <- list()
[08:28:27.083]                 for (kk in seq_along(NAMES)) {
[08:28:27.083]                   name <- changed[[kk]]
[08:28:27.083]                   NAME <- NAMES[[kk]]
[08:28:27.083]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.083]                     next
[08:28:27.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.083]                 }
[08:28:27.083]                 NAMES <- toupper(added)
[08:28:27.083]                 for (kk in seq_along(NAMES)) {
[08:28:27.083]                   name <- added[[kk]]
[08:28:27.083]                   NAME <- NAMES[[kk]]
[08:28:27.083]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.083]                     next
[08:28:27.083]                   args[[name]] <- ""
[08:28:27.083]                 }
[08:28:27.083]                 NAMES <- toupper(removed)
[08:28:27.083]                 for (kk in seq_along(NAMES)) {
[08:28:27.083]                   name <- removed[[kk]]
[08:28:27.083]                   NAME <- NAMES[[kk]]
[08:28:27.083]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.083]                     next
[08:28:27.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.083]                 }
[08:28:27.083]                 if (length(args) > 0) 
[08:28:27.083]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.083]             }
[08:28:27.083]             else {
[08:28:27.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.083]             }
[08:28:27.083]             {
[08:28:27.083]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.083]                   0L) {
[08:28:27.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.083]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.083]                   base::options(opts)
[08:28:27.083]                 }
[08:28:27.083]                 {
[08:28:27.083]                   {
[08:28:27.083]                     NULL
[08:28:27.083]                     RNGkind("Mersenne-Twister")
[08:28:27.083]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.083]                       inherits = FALSE)
[08:28:27.083]                   }
[08:28:27.083]                   options(future.plan = NULL)
[08:28:27.083]                   if (is.na(NA_character_)) 
[08:28:27.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.083]                     .init = FALSE)
[08:28:27.083]                 }
[08:28:27.083]             }
[08:28:27.083]         }
[08:28:27.083]     })
[08:28:27.083]     if (TRUE) {
[08:28:27.083]         base::sink(type = "output", split = FALSE)
[08:28:27.083]         if (TRUE) {
[08:28:27.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.083]         }
[08:28:27.083]         else {
[08:28:27.083]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.083]         }
[08:28:27.083]         base::close(...future.stdout)
[08:28:27.083]         ...future.stdout <- NULL
[08:28:27.083]     }
[08:28:27.083]     ...future.result$conditions <- ...future.conditions
[08:28:27.083]     ...future.result$finished <- base::Sys.time()
[08:28:27.083]     ...future.result
[08:28:27.083] }
[08:28:27.085] plan(): Setting new future strategy stack:
[08:28:27.085] List of future strategies:
[08:28:27.085] 1. sequential:
[08:28:27.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.085]    - tweaked: FALSE
[08:28:27.085]    - call: NULL
[08:28:27.086] plan(): nbrOfWorkers() = 1
[08:28:27.087] plan(): Setting new future strategy stack:
[08:28:27.087] List of future strategies:
[08:28:27.087] 1. multicore:
[08:28:27.087]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.087]    - tweaked: FALSE
[08:28:27.087]    - call: plan(multicore)
[08:28:27.088] plan(): nbrOfWorkers() = 1
[08:28:27.088] SequentialFuture started (and completed)
[08:28:27.089] signalConditions() ...
[08:28:27.089]  - include = ‘immediateCondition’
[08:28:27.089]  - exclude = 
[08:28:27.089]  - resignal = FALSE
[08:28:27.089]  - Number of conditions: 1
[08:28:27.089] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 27 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:27.089] signalConditions() ...
[08:28:27.090]  - include = ‘immediateCondition’
[08:28:27.090]  - exclude = 
[08:28:27.090]  - resignal = FALSE
[08:28:27.090]  - Number of conditions: 1
[08:28:27.090] signalConditions() ... done
<MyError: boom>
[08:28:27.090] signalConditions() ...
[08:28:27.090]  - include = ‘immediateCondition’
[08:28:27.090]  - exclude = 
[08:28:27.090]  - resignal = FALSE
[08:28:27.090]  - Number of conditions: 1
[08:28:27.090] signalConditions() ... done
[08:28:27.091] Future state: ‘finished’
[08:28:27.091] signalConditions() ...
[08:28:27.091]  - include = ‘condition’
[08:28:27.091]  - exclude = ‘immediateCondition’
[08:28:27.091]  - resignal = TRUE
[08:28:27.091]  - Number of conditions: 1
[08:28:27.091]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[08:28:27.091] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[08:28:27.093] getGlobalsAndPackages() ...
[08:28:27.093] Searching for globals...
[08:28:27.093] - globals found: [1] ‘{’
[08:28:27.093] Searching for globals ... DONE
[08:28:27.094] Resolving globals: FALSE
[08:28:27.094] 
[08:28:27.094] 
[08:28:27.094] getGlobalsAndPackages() ... DONE
[08:28:27.094] Packages needed by the future expression (n = 0): <none>
[08:28:27.094] Packages needed by future strategies (n = 0): <none>
[08:28:27.095] {
[08:28:27.095]     {
[08:28:27.095]         {
[08:28:27.095]             ...future.startTime <- base::Sys.time()
[08:28:27.095]             {
[08:28:27.095]                 {
[08:28:27.095]                   {
[08:28:27.095]                     base::local({
[08:28:27.095]                       has_future <- base::requireNamespace("future", 
[08:28:27.095]                         quietly = TRUE)
[08:28:27.095]                       if (has_future) {
[08:28:27.095]                         ns <- base::getNamespace("future")
[08:28:27.095]                         version <- ns[[".package"]][["version"]]
[08:28:27.095]                         if (is.null(version)) 
[08:28:27.095]                           version <- utils::packageVersion("future")
[08:28:27.095]                       }
[08:28:27.095]                       else {
[08:28:27.095]                         version <- NULL
[08:28:27.095]                       }
[08:28:27.095]                       if (!has_future || version < "1.8.0") {
[08:28:27.095]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.095]                           "", base::R.version$version.string), 
[08:28:27.095]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.095]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.095]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.095]                             "release", "version")], collapse = " "), 
[08:28:27.095]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.095]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.095]                           info)
[08:28:27.095]                         info <- base::paste(info, collapse = "; ")
[08:28:27.095]                         if (!has_future) {
[08:28:27.095]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.095]                             info)
[08:28:27.095]                         }
[08:28:27.095]                         else {
[08:28:27.095]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.095]                             info, version)
[08:28:27.095]                         }
[08:28:27.095]                         base::stop(msg)
[08:28:27.095]                       }
[08:28:27.095]                     })
[08:28:27.095]                   }
[08:28:27.095]                   ...future.strategy.old <- future::plan("list")
[08:28:27.095]                   options(future.plan = NULL)
[08:28:27.095]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.095]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.095]                 }
[08:28:27.095]                 ...future.workdir <- getwd()
[08:28:27.095]             }
[08:28:27.095]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.095]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.095]         }
[08:28:27.095]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.095]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.095]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.095]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.095]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.095]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.095]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.095]             base::names(...future.oldOptions))
[08:28:27.095]     }
[08:28:27.095]     if (FALSE) {
[08:28:27.095]     }
[08:28:27.095]     else {
[08:28:27.095]         if (TRUE) {
[08:28:27.095]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.095]                 open = "w")
[08:28:27.095]         }
[08:28:27.095]         else {
[08:28:27.095]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.095]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.095]         }
[08:28:27.095]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.095]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.095]             base::sink(type = "output", split = FALSE)
[08:28:27.095]             base::close(...future.stdout)
[08:28:27.095]         }, add = TRUE)
[08:28:27.095]     }
[08:28:27.095]     ...future.frame <- base::sys.nframe()
[08:28:27.095]     ...future.conditions <- base::list()
[08:28:27.095]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.095]     if (FALSE) {
[08:28:27.095]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.095]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.095]     }
[08:28:27.095]     ...future.result <- base::tryCatch({
[08:28:27.095]         base::withCallingHandlers({
[08:28:27.095]             ...future.value <- base::withVisible(base::local({
[08:28:27.095]                 42L
[08:28:27.095]             }))
[08:28:27.095]             future::FutureResult(value = ...future.value$value, 
[08:28:27.095]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.095]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.095]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.095]                     ...future.globalenv.names))
[08:28:27.095]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.095]         }, condition = base::local({
[08:28:27.095]             c <- base::c
[08:28:27.095]             inherits <- base::inherits
[08:28:27.095]             invokeRestart <- base::invokeRestart
[08:28:27.095]             length <- base::length
[08:28:27.095]             list <- base::list
[08:28:27.095]             seq.int <- base::seq.int
[08:28:27.095]             signalCondition <- base::signalCondition
[08:28:27.095]             sys.calls <- base::sys.calls
[08:28:27.095]             `[[` <- base::`[[`
[08:28:27.095]             `+` <- base::`+`
[08:28:27.095]             `<<-` <- base::`<<-`
[08:28:27.095]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.095]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.095]                   3L)]
[08:28:27.095]             }
[08:28:27.095]             function(cond) {
[08:28:27.095]                 is_error <- inherits(cond, "error")
[08:28:27.095]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.095]                   NULL)
[08:28:27.095]                 if (is_error) {
[08:28:27.095]                   sessionInformation <- function() {
[08:28:27.095]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.095]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.095]                       search = base::search(), system = base::Sys.info())
[08:28:27.095]                   }
[08:28:27.095]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.095]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.095]                     cond$call), session = sessionInformation(), 
[08:28:27.095]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.095]                   signalCondition(cond)
[08:28:27.095]                 }
[08:28:27.095]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.095]                 "immediateCondition"))) {
[08:28:27.095]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.095]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.095]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.095]                   if (TRUE && !signal) {
[08:28:27.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.095]                     {
[08:28:27.095]                       inherits <- base::inherits
[08:28:27.095]                       invokeRestart <- base::invokeRestart
[08:28:27.095]                       is.null <- base::is.null
[08:28:27.095]                       muffled <- FALSE
[08:28:27.095]                       if (inherits(cond, "message")) {
[08:28:27.095]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.095]                         if (muffled) 
[08:28:27.095]                           invokeRestart("muffleMessage")
[08:28:27.095]                       }
[08:28:27.095]                       else if (inherits(cond, "warning")) {
[08:28:27.095]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.095]                         if (muffled) 
[08:28:27.095]                           invokeRestart("muffleWarning")
[08:28:27.095]                       }
[08:28:27.095]                       else if (inherits(cond, "condition")) {
[08:28:27.095]                         if (!is.null(pattern)) {
[08:28:27.095]                           computeRestarts <- base::computeRestarts
[08:28:27.095]                           grepl <- base::grepl
[08:28:27.095]                           restarts <- computeRestarts(cond)
[08:28:27.095]                           for (restart in restarts) {
[08:28:27.095]                             name <- restart$name
[08:28:27.095]                             if (is.null(name)) 
[08:28:27.095]                               next
[08:28:27.095]                             if (!grepl(pattern, name)) 
[08:28:27.095]                               next
[08:28:27.095]                             invokeRestart(restart)
[08:28:27.095]                             muffled <- TRUE
[08:28:27.095]                             break
[08:28:27.095]                           }
[08:28:27.095]                         }
[08:28:27.095]                       }
[08:28:27.095]                       invisible(muffled)
[08:28:27.095]                     }
[08:28:27.095]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.095]                   }
[08:28:27.095]                 }
[08:28:27.095]                 else {
[08:28:27.095]                   if (TRUE) {
[08:28:27.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.095]                     {
[08:28:27.095]                       inherits <- base::inherits
[08:28:27.095]                       invokeRestart <- base::invokeRestart
[08:28:27.095]                       is.null <- base::is.null
[08:28:27.095]                       muffled <- FALSE
[08:28:27.095]                       if (inherits(cond, "message")) {
[08:28:27.095]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.095]                         if (muffled) 
[08:28:27.095]                           invokeRestart("muffleMessage")
[08:28:27.095]                       }
[08:28:27.095]                       else if (inherits(cond, "warning")) {
[08:28:27.095]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.095]                         if (muffled) 
[08:28:27.095]                           invokeRestart("muffleWarning")
[08:28:27.095]                       }
[08:28:27.095]                       else if (inherits(cond, "condition")) {
[08:28:27.095]                         if (!is.null(pattern)) {
[08:28:27.095]                           computeRestarts <- base::computeRestarts
[08:28:27.095]                           grepl <- base::grepl
[08:28:27.095]                           restarts <- computeRestarts(cond)
[08:28:27.095]                           for (restart in restarts) {
[08:28:27.095]                             name <- restart$name
[08:28:27.095]                             if (is.null(name)) 
[08:28:27.095]                               next
[08:28:27.095]                             if (!grepl(pattern, name)) 
[08:28:27.095]                               next
[08:28:27.095]                             invokeRestart(restart)
[08:28:27.095]                             muffled <- TRUE
[08:28:27.095]                             break
[08:28:27.095]                           }
[08:28:27.095]                         }
[08:28:27.095]                       }
[08:28:27.095]                       invisible(muffled)
[08:28:27.095]                     }
[08:28:27.095]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.095]                   }
[08:28:27.095]                 }
[08:28:27.095]             }
[08:28:27.095]         }))
[08:28:27.095]     }, error = function(ex) {
[08:28:27.095]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.095]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.095]                 ...future.rng), started = ...future.startTime, 
[08:28:27.095]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.095]             version = "1.8"), class = "FutureResult")
[08:28:27.095]     }, finally = {
[08:28:27.095]         if (!identical(...future.workdir, getwd())) 
[08:28:27.095]             setwd(...future.workdir)
[08:28:27.095]         {
[08:28:27.095]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.095]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.095]             }
[08:28:27.095]             base::options(...future.oldOptions)
[08:28:27.095]             if (.Platform$OS.type == "windows") {
[08:28:27.095]                 old_names <- names(...future.oldEnvVars)
[08:28:27.095]                 envs <- base::Sys.getenv()
[08:28:27.095]                 names <- names(envs)
[08:28:27.095]                 common <- intersect(names, old_names)
[08:28:27.095]                 added <- setdiff(names, old_names)
[08:28:27.095]                 removed <- setdiff(old_names, names)
[08:28:27.095]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.095]                   envs[common]]
[08:28:27.095]                 NAMES <- toupper(changed)
[08:28:27.095]                 args <- list()
[08:28:27.095]                 for (kk in seq_along(NAMES)) {
[08:28:27.095]                   name <- changed[[kk]]
[08:28:27.095]                   NAME <- NAMES[[kk]]
[08:28:27.095]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.095]                     next
[08:28:27.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.095]                 }
[08:28:27.095]                 NAMES <- toupper(added)
[08:28:27.095]                 for (kk in seq_along(NAMES)) {
[08:28:27.095]                   name <- added[[kk]]
[08:28:27.095]                   NAME <- NAMES[[kk]]
[08:28:27.095]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.095]                     next
[08:28:27.095]                   args[[name]] <- ""
[08:28:27.095]                 }
[08:28:27.095]                 NAMES <- toupper(removed)
[08:28:27.095]                 for (kk in seq_along(NAMES)) {
[08:28:27.095]                   name <- removed[[kk]]
[08:28:27.095]                   NAME <- NAMES[[kk]]
[08:28:27.095]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.095]                     next
[08:28:27.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.095]                 }
[08:28:27.095]                 if (length(args) > 0) 
[08:28:27.095]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.095]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.095]             }
[08:28:27.095]             else {
[08:28:27.095]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.095]             }
[08:28:27.095]             {
[08:28:27.095]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.095]                   0L) {
[08:28:27.095]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.095]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.095]                   base::options(opts)
[08:28:27.095]                 }
[08:28:27.095]                 {
[08:28:27.095]                   {
[08:28:27.095]                     NULL
[08:28:27.095]                     RNGkind("Mersenne-Twister")
[08:28:27.095]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.095]                       inherits = FALSE)
[08:28:27.095]                   }
[08:28:27.095]                   options(future.plan = NULL)
[08:28:27.095]                   if (is.na(NA_character_)) 
[08:28:27.095]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.095]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.095]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.095]                     .init = FALSE)
[08:28:27.095]                 }
[08:28:27.095]             }
[08:28:27.095]         }
[08:28:27.095]     })
[08:28:27.095]     if (TRUE) {
[08:28:27.095]         base::sink(type = "output", split = FALSE)
[08:28:27.095]         if (TRUE) {
[08:28:27.095]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.095]         }
[08:28:27.095]         else {
[08:28:27.095]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.095]         }
[08:28:27.095]         base::close(...future.stdout)
[08:28:27.095]         ...future.stdout <- NULL
[08:28:27.095]     }
[08:28:27.095]     ...future.result$conditions <- ...future.conditions
[08:28:27.095]     ...future.result$finished <- base::Sys.time()
[08:28:27.095]     ...future.result
[08:28:27.095] }
[08:28:27.097] plan(): Setting new future strategy stack:
[08:28:27.097] List of future strategies:
[08:28:27.097] 1. sequential:
[08:28:27.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.097]    - tweaked: FALSE
[08:28:27.097]    - call: NULL
[08:28:27.097] plan(): nbrOfWorkers() = 1
[08:28:27.098] plan(): Setting new future strategy stack:
[08:28:27.098] List of future strategies:
[08:28:27.098] 1. multicore:
[08:28:27.098]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.098]    - tweaked: FALSE
[08:28:27.098]    - call: plan(multicore)
[08:28:27.099] plan(): nbrOfWorkers() = 1
[08:28:27.100] SequentialFuture started (and completed)
[08:28:27.100] resolved() for ‘SequentialFuture’ ...
[08:28:27.100] - state: ‘finished’
[08:28:27.100] - run: TRUE
[08:28:27.100] - result: ‘FutureResult’
[08:28:27.100] resolved() for ‘SequentialFuture’ ... done
[1] TRUE
[1] 42
*** multicore(..., globals = TRUE) with globals
[08:28:27.102] getGlobalsAndPackages() ...
[08:28:27.102] Searching for globals...
[08:28:27.104] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[08:28:27.104] Searching for globals ... DONE
[08:28:27.104] Resolving globals: FALSE
[08:28:27.104] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:27.105] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:28:27.105] - globals: [1] ‘a’
[08:28:27.105] 
[08:28:27.105] getGlobalsAndPackages() ... DONE
[08:28:27.105] Packages needed by the future expression (n = 0): <none>
[08:28:27.105] Packages needed by future strategies (n = 0): <none>
[08:28:27.106] {
[08:28:27.106]     {
[08:28:27.106]         {
[08:28:27.106]             ...future.startTime <- base::Sys.time()
[08:28:27.106]             {
[08:28:27.106]                 {
[08:28:27.106]                   {
[08:28:27.106]                     base::local({
[08:28:27.106]                       has_future <- base::requireNamespace("future", 
[08:28:27.106]                         quietly = TRUE)
[08:28:27.106]                       if (has_future) {
[08:28:27.106]                         ns <- base::getNamespace("future")
[08:28:27.106]                         version <- ns[[".package"]][["version"]]
[08:28:27.106]                         if (is.null(version)) 
[08:28:27.106]                           version <- utils::packageVersion("future")
[08:28:27.106]                       }
[08:28:27.106]                       else {
[08:28:27.106]                         version <- NULL
[08:28:27.106]                       }
[08:28:27.106]                       if (!has_future || version < "1.8.0") {
[08:28:27.106]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.106]                           "", base::R.version$version.string), 
[08:28:27.106]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.106]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.106]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.106]                             "release", "version")], collapse = " "), 
[08:28:27.106]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.106]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.106]                           info)
[08:28:27.106]                         info <- base::paste(info, collapse = "; ")
[08:28:27.106]                         if (!has_future) {
[08:28:27.106]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.106]                             info)
[08:28:27.106]                         }
[08:28:27.106]                         else {
[08:28:27.106]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.106]                             info, version)
[08:28:27.106]                         }
[08:28:27.106]                         base::stop(msg)
[08:28:27.106]                       }
[08:28:27.106]                     })
[08:28:27.106]                   }
[08:28:27.106]                   ...future.strategy.old <- future::plan("list")
[08:28:27.106]                   options(future.plan = NULL)
[08:28:27.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.106]                 }
[08:28:27.106]                 ...future.workdir <- getwd()
[08:28:27.106]             }
[08:28:27.106]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.106]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.106]         }
[08:28:27.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.106]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.106]             base::names(...future.oldOptions))
[08:28:27.106]     }
[08:28:27.106]     if (FALSE) {
[08:28:27.106]     }
[08:28:27.106]     else {
[08:28:27.106]         if (TRUE) {
[08:28:27.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.106]                 open = "w")
[08:28:27.106]         }
[08:28:27.106]         else {
[08:28:27.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.106]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.106]         }
[08:28:27.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.106]             base::sink(type = "output", split = FALSE)
[08:28:27.106]             base::close(...future.stdout)
[08:28:27.106]         }, add = TRUE)
[08:28:27.106]     }
[08:28:27.106]     ...future.frame <- base::sys.nframe()
[08:28:27.106]     ...future.conditions <- base::list()
[08:28:27.106]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.106]     if (FALSE) {
[08:28:27.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.106]     }
[08:28:27.106]     ...future.result <- base::tryCatch({
[08:28:27.106]         base::withCallingHandlers({
[08:28:27.106]             ...future.value <- base::withVisible(base::local({
[08:28:27.106]                 b <- 3
[08:28:27.106]                 c <- 2
[08:28:27.106]                 a * b * c
[08:28:27.106]             }))
[08:28:27.106]             future::FutureResult(value = ...future.value$value, 
[08:28:27.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.106]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.106]                     ...future.globalenv.names))
[08:28:27.106]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.106]         }, condition = base::local({
[08:28:27.106]             c <- base::c
[08:28:27.106]             inherits <- base::inherits
[08:28:27.106]             invokeRestart <- base::invokeRestart
[08:28:27.106]             length <- base::length
[08:28:27.106]             list <- base::list
[08:28:27.106]             seq.int <- base::seq.int
[08:28:27.106]             signalCondition <- base::signalCondition
[08:28:27.106]             sys.calls <- base::sys.calls
[08:28:27.106]             `[[` <- base::`[[`
[08:28:27.106]             `+` <- base::`+`
[08:28:27.106]             `<<-` <- base::`<<-`
[08:28:27.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.106]                   3L)]
[08:28:27.106]             }
[08:28:27.106]             function(cond) {
[08:28:27.106]                 is_error <- inherits(cond, "error")
[08:28:27.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.106]                   NULL)
[08:28:27.106]                 if (is_error) {
[08:28:27.106]                   sessionInformation <- function() {
[08:28:27.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.106]                       search = base::search(), system = base::Sys.info())
[08:28:27.106]                   }
[08:28:27.106]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.106]                     cond$call), session = sessionInformation(), 
[08:28:27.106]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.106]                   signalCondition(cond)
[08:28:27.106]                 }
[08:28:27.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.106]                 "immediateCondition"))) {
[08:28:27.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.106]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.106]                   if (TRUE && !signal) {
[08:28:27.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.106]                     {
[08:28:27.106]                       inherits <- base::inherits
[08:28:27.106]                       invokeRestart <- base::invokeRestart
[08:28:27.106]                       is.null <- base::is.null
[08:28:27.106]                       muffled <- FALSE
[08:28:27.106]                       if (inherits(cond, "message")) {
[08:28:27.106]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.106]                         if (muffled) 
[08:28:27.106]                           invokeRestart("muffleMessage")
[08:28:27.106]                       }
[08:28:27.106]                       else if (inherits(cond, "warning")) {
[08:28:27.106]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.106]                         if (muffled) 
[08:28:27.106]                           invokeRestart("muffleWarning")
[08:28:27.106]                       }
[08:28:27.106]                       else if (inherits(cond, "condition")) {
[08:28:27.106]                         if (!is.null(pattern)) {
[08:28:27.106]                           computeRestarts <- base::computeRestarts
[08:28:27.106]                           grepl <- base::grepl
[08:28:27.106]                           restarts <- computeRestarts(cond)
[08:28:27.106]                           for (restart in restarts) {
[08:28:27.106]                             name <- restart$name
[08:28:27.106]                             if (is.null(name)) 
[08:28:27.106]                               next
[08:28:27.106]                             if (!grepl(pattern, name)) 
[08:28:27.106]                               next
[08:28:27.106]                             invokeRestart(restart)
[08:28:27.106]                             muffled <- TRUE
[08:28:27.106]                             break
[08:28:27.106]                           }
[08:28:27.106]                         }
[08:28:27.106]                       }
[08:28:27.106]                       invisible(muffled)
[08:28:27.106]                     }
[08:28:27.106]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.106]                   }
[08:28:27.106]                 }
[08:28:27.106]                 else {
[08:28:27.106]                   if (TRUE) {
[08:28:27.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.106]                     {
[08:28:27.106]                       inherits <- base::inherits
[08:28:27.106]                       invokeRestart <- base::invokeRestart
[08:28:27.106]                       is.null <- base::is.null
[08:28:27.106]                       muffled <- FALSE
[08:28:27.106]                       if (inherits(cond, "message")) {
[08:28:27.106]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.106]                         if (muffled) 
[08:28:27.106]                           invokeRestart("muffleMessage")
[08:28:27.106]                       }
[08:28:27.106]                       else if (inherits(cond, "warning")) {
[08:28:27.106]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.106]                         if (muffled) 
[08:28:27.106]                           invokeRestart("muffleWarning")
[08:28:27.106]                       }
[08:28:27.106]                       else if (inherits(cond, "condition")) {
[08:28:27.106]                         if (!is.null(pattern)) {
[08:28:27.106]                           computeRestarts <- base::computeRestarts
[08:28:27.106]                           grepl <- base::grepl
[08:28:27.106]                           restarts <- computeRestarts(cond)
[08:28:27.106]                           for (restart in restarts) {
[08:28:27.106]                             name <- restart$name
[08:28:27.106]                             if (is.null(name)) 
[08:28:27.106]                               next
[08:28:27.106]                             if (!grepl(pattern, name)) 
[08:28:27.106]                               next
[08:28:27.106]                             invokeRestart(restart)
[08:28:27.106]                             muffled <- TRUE
[08:28:27.106]                             break
[08:28:27.106]                           }
[08:28:27.106]                         }
[08:28:27.106]                       }
[08:28:27.106]                       invisible(muffled)
[08:28:27.106]                     }
[08:28:27.106]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.106]                   }
[08:28:27.106]                 }
[08:28:27.106]             }
[08:28:27.106]         }))
[08:28:27.106]     }, error = function(ex) {
[08:28:27.106]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.106]                 ...future.rng), started = ...future.startTime, 
[08:28:27.106]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.106]             version = "1.8"), class = "FutureResult")
[08:28:27.106]     }, finally = {
[08:28:27.106]         if (!identical(...future.workdir, getwd())) 
[08:28:27.106]             setwd(...future.workdir)
[08:28:27.106]         {
[08:28:27.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.106]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.106]             }
[08:28:27.106]             base::options(...future.oldOptions)
[08:28:27.106]             if (.Platform$OS.type == "windows") {
[08:28:27.106]                 old_names <- names(...future.oldEnvVars)
[08:28:27.106]                 envs <- base::Sys.getenv()
[08:28:27.106]                 names <- names(envs)
[08:28:27.106]                 common <- intersect(names, old_names)
[08:28:27.106]                 added <- setdiff(names, old_names)
[08:28:27.106]                 removed <- setdiff(old_names, names)
[08:28:27.106]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.106]                   envs[common]]
[08:28:27.106]                 NAMES <- toupper(changed)
[08:28:27.106]                 args <- list()
[08:28:27.106]                 for (kk in seq_along(NAMES)) {
[08:28:27.106]                   name <- changed[[kk]]
[08:28:27.106]                   NAME <- NAMES[[kk]]
[08:28:27.106]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.106]                     next
[08:28:27.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.106]                 }
[08:28:27.106]                 NAMES <- toupper(added)
[08:28:27.106]                 for (kk in seq_along(NAMES)) {
[08:28:27.106]                   name <- added[[kk]]
[08:28:27.106]                   NAME <- NAMES[[kk]]
[08:28:27.106]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.106]                     next
[08:28:27.106]                   args[[name]] <- ""
[08:28:27.106]                 }
[08:28:27.106]                 NAMES <- toupper(removed)
[08:28:27.106]                 for (kk in seq_along(NAMES)) {
[08:28:27.106]                   name <- removed[[kk]]
[08:28:27.106]                   NAME <- NAMES[[kk]]
[08:28:27.106]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.106]                     next
[08:28:27.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.106]                 }
[08:28:27.106]                 if (length(args) > 0) 
[08:28:27.106]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.106]             }
[08:28:27.106]             else {
[08:28:27.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.106]             }
[08:28:27.106]             {
[08:28:27.106]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.106]                   0L) {
[08:28:27.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.106]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.106]                   base::options(opts)
[08:28:27.106]                 }
[08:28:27.106]                 {
[08:28:27.106]                   {
[08:28:27.106]                     NULL
[08:28:27.106]                     RNGkind("Mersenne-Twister")
[08:28:27.106]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.106]                       inherits = FALSE)
[08:28:27.106]                   }
[08:28:27.106]                   options(future.plan = NULL)
[08:28:27.106]                   if (is.na(NA_character_)) 
[08:28:27.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.106]                     .init = FALSE)
[08:28:27.106]                 }
[08:28:27.106]             }
[08:28:27.106]         }
[08:28:27.106]     })
[08:28:27.106]     if (TRUE) {
[08:28:27.106]         base::sink(type = "output", split = FALSE)
[08:28:27.106]         if (TRUE) {
[08:28:27.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.106]         }
[08:28:27.106]         else {
[08:28:27.106]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.106]         }
[08:28:27.106]         base::close(...future.stdout)
[08:28:27.106]         ...future.stdout <- NULL
[08:28:27.106]     }
[08:28:27.106]     ...future.result$conditions <- ...future.conditions
[08:28:27.106]     ...future.result$finished <- base::Sys.time()
[08:28:27.106]     ...future.result
[08:28:27.106] }
[08:28:27.108] assign_globals() ...
[08:28:27.108] List of 1
[08:28:27.108]  $ a: num 0
[08:28:27.108]  - attr(*, "where")=List of 1
[08:28:27.108]   ..$ a:<environment: R_EmptyEnv> 
[08:28:27.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.108]  - attr(*, "resolved")= logi FALSE
[08:28:27.108]  - attr(*, "total_size")= num 39
[08:28:27.112] - copied ‘a’ to environment
[08:28:27.112] assign_globals() ... done
[08:28:27.112] plan(): Setting new future strategy stack:
[08:28:27.112] List of future strategies:
[08:28:27.112] 1. sequential:
[08:28:27.112]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.112]    - tweaked: FALSE
[08:28:27.112]    - call: NULL
[08:28:27.113] plan(): nbrOfWorkers() = 1
[08:28:27.113] plan(): Setting new future strategy stack:
[08:28:27.113] List of future strategies:
[08:28:27.113] 1. multicore:
[08:28:27.113]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.113]    - tweaked: FALSE
[08:28:27.113]    - call: plan(multicore)
[08:28:27.117] plan(): nbrOfWorkers() = 1
[08:28:27.117] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: 1 objects totaling 39 bytes (numeric ‘a’ of 39 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[08:28:27.120] getGlobalsAndPackages() ...
[08:28:27.120] Searching for globals...
[08:28:27.120] - globals found: [2] ‘{’, ‘ii’
[08:28:27.121] Searching for globals ... DONE
[08:28:27.121] Resolving globals: FALSE
[08:28:27.121] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:27.121] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:27.121] - globals: [1] ‘ii’
[08:28:27.122] 
[08:28:27.122] getGlobalsAndPackages() ... DONE
[08:28:27.122] Packages needed by the future expression (n = 0): <none>
[08:28:27.122] Packages needed by future strategies (n = 0): <none>
[08:28:27.122] {
[08:28:27.122]     {
[08:28:27.122]         {
[08:28:27.122]             ...future.startTime <- base::Sys.time()
[08:28:27.122]             {
[08:28:27.122]                 {
[08:28:27.122]                   {
[08:28:27.122]                     base::local({
[08:28:27.122]                       has_future <- base::requireNamespace("future", 
[08:28:27.122]                         quietly = TRUE)
[08:28:27.122]                       if (has_future) {
[08:28:27.122]                         ns <- base::getNamespace("future")
[08:28:27.122]                         version <- ns[[".package"]][["version"]]
[08:28:27.122]                         if (is.null(version)) 
[08:28:27.122]                           version <- utils::packageVersion("future")
[08:28:27.122]                       }
[08:28:27.122]                       else {
[08:28:27.122]                         version <- NULL
[08:28:27.122]                       }
[08:28:27.122]                       if (!has_future || version < "1.8.0") {
[08:28:27.122]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.122]                           "", base::R.version$version.string), 
[08:28:27.122]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.122]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.122]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.122]                             "release", "version")], collapse = " "), 
[08:28:27.122]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.122]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.122]                           info)
[08:28:27.122]                         info <- base::paste(info, collapse = "; ")
[08:28:27.122]                         if (!has_future) {
[08:28:27.122]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.122]                             info)
[08:28:27.122]                         }
[08:28:27.122]                         else {
[08:28:27.122]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.122]                             info, version)
[08:28:27.122]                         }
[08:28:27.122]                         base::stop(msg)
[08:28:27.122]                       }
[08:28:27.122]                     })
[08:28:27.122]                   }
[08:28:27.122]                   ...future.strategy.old <- future::plan("list")
[08:28:27.122]                   options(future.plan = NULL)
[08:28:27.122]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.122]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.122]                 }
[08:28:27.122]                 ...future.workdir <- getwd()
[08:28:27.122]             }
[08:28:27.122]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.122]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.122]         }
[08:28:27.122]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.122]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.122]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.122]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.122]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.122]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.122]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.122]             base::names(...future.oldOptions))
[08:28:27.122]     }
[08:28:27.122]     if (FALSE) {
[08:28:27.122]     }
[08:28:27.122]     else {
[08:28:27.122]         if (TRUE) {
[08:28:27.122]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.122]                 open = "w")
[08:28:27.122]         }
[08:28:27.122]         else {
[08:28:27.122]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.122]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.122]         }
[08:28:27.122]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.122]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.122]             base::sink(type = "output", split = FALSE)
[08:28:27.122]             base::close(...future.stdout)
[08:28:27.122]         }, add = TRUE)
[08:28:27.122]     }
[08:28:27.122]     ...future.frame <- base::sys.nframe()
[08:28:27.122]     ...future.conditions <- base::list()
[08:28:27.122]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.122]     if (FALSE) {
[08:28:27.122]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.122]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.122]     }
[08:28:27.122]     ...future.result <- base::tryCatch({
[08:28:27.122]         base::withCallingHandlers({
[08:28:27.122]             ...future.value <- base::withVisible(base::local({
[08:28:27.122]                 ii
[08:28:27.122]             }))
[08:28:27.122]             future::FutureResult(value = ...future.value$value, 
[08:28:27.122]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.122]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.122]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.122]                     ...future.globalenv.names))
[08:28:27.122]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.122]         }, condition = base::local({
[08:28:27.122]             c <- base::c
[08:28:27.122]             inherits <- base::inherits
[08:28:27.122]             invokeRestart <- base::invokeRestart
[08:28:27.122]             length <- base::length
[08:28:27.122]             list <- base::list
[08:28:27.122]             seq.int <- base::seq.int
[08:28:27.122]             signalCondition <- base::signalCondition
[08:28:27.122]             sys.calls <- base::sys.calls
[08:28:27.122]             `[[` <- base::`[[`
[08:28:27.122]             `+` <- base::`+`
[08:28:27.122]             `<<-` <- base::`<<-`
[08:28:27.122]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.122]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.122]                   3L)]
[08:28:27.122]             }
[08:28:27.122]             function(cond) {
[08:28:27.122]                 is_error <- inherits(cond, "error")
[08:28:27.122]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.122]                   NULL)
[08:28:27.122]                 if (is_error) {
[08:28:27.122]                   sessionInformation <- function() {
[08:28:27.122]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.122]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.122]                       search = base::search(), system = base::Sys.info())
[08:28:27.122]                   }
[08:28:27.122]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.122]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.122]                     cond$call), session = sessionInformation(), 
[08:28:27.122]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.122]                   signalCondition(cond)
[08:28:27.122]                 }
[08:28:27.122]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.122]                 "immediateCondition"))) {
[08:28:27.122]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.122]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.122]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.122]                   if (TRUE && !signal) {
[08:28:27.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.122]                     {
[08:28:27.122]                       inherits <- base::inherits
[08:28:27.122]                       invokeRestart <- base::invokeRestart
[08:28:27.122]                       is.null <- base::is.null
[08:28:27.122]                       muffled <- FALSE
[08:28:27.122]                       if (inherits(cond, "message")) {
[08:28:27.122]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.122]                         if (muffled) 
[08:28:27.122]                           invokeRestart("muffleMessage")
[08:28:27.122]                       }
[08:28:27.122]                       else if (inherits(cond, "warning")) {
[08:28:27.122]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.122]                         if (muffled) 
[08:28:27.122]                           invokeRestart("muffleWarning")
[08:28:27.122]                       }
[08:28:27.122]                       else if (inherits(cond, "condition")) {
[08:28:27.122]                         if (!is.null(pattern)) {
[08:28:27.122]                           computeRestarts <- base::computeRestarts
[08:28:27.122]                           grepl <- base::grepl
[08:28:27.122]                           restarts <- computeRestarts(cond)
[08:28:27.122]                           for (restart in restarts) {
[08:28:27.122]                             name <- restart$name
[08:28:27.122]                             if (is.null(name)) 
[08:28:27.122]                               next
[08:28:27.122]                             if (!grepl(pattern, name)) 
[08:28:27.122]                               next
[08:28:27.122]                             invokeRestart(restart)
[08:28:27.122]                             muffled <- TRUE
[08:28:27.122]                             break
[08:28:27.122]                           }
[08:28:27.122]                         }
[08:28:27.122]                       }
[08:28:27.122]                       invisible(muffled)
[08:28:27.122]                     }
[08:28:27.122]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.122]                   }
[08:28:27.122]                 }
[08:28:27.122]                 else {
[08:28:27.122]                   if (TRUE) {
[08:28:27.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.122]                     {
[08:28:27.122]                       inherits <- base::inherits
[08:28:27.122]                       invokeRestart <- base::invokeRestart
[08:28:27.122]                       is.null <- base::is.null
[08:28:27.122]                       muffled <- FALSE
[08:28:27.122]                       if (inherits(cond, "message")) {
[08:28:27.122]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.122]                         if (muffled) 
[08:28:27.122]                           invokeRestart("muffleMessage")
[08:28:27.122]                       }
[08:28:27.122]                       else if (inherits(cond, "warning")) {
[08:28:27.122]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.122]                         if (muffled) 
[08:28:27.122]                           invokeRestart("muffleWarning")
[08:28:27.122]                       }
[08:28:27.122]                       else if (inherits(cond, "condition")) {
[08:28:27.122]                         if (!is.null(pattern)) {
[08:28:27.122]                           computeRestarts <- base::computeRestarts
[08:28:27.122]                           grepl <- base::grepl
[08:28:27.122]                           restarts <- computeRestarts(cond)
[08:28:27.122]                           for (restart in restarts) {
[08:28:27.122]                             name <- restart$name
[08:28:27.122]                             if (is.null(name)) 
[08:28:27.122]                               next
[08:28:27.122]                             if (!grepl(pattern, name)) 
[08:28:27.122]                               next
[08:28:27.122]                             invokeRestart(restart)
[08:28:27.122]                             muffled <- TRUE
[08:28:27.122]                             break
[08:28:27.122]                           }
[08:28:27.122]                         }
[08:28:27.122]                       }
[08:28:27.122]                       invisible(muffled)
[08:28:27.122]                     }
[08:28:27.122]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.122]                   }
[08:28:27.122]                 }
[08:28:27.122]             }
[08:28:27.122]         }))
[08:28:27.122]     }, error = function(ex) {
[08:28:27.122]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.122]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.122]                 ...future.rng), started = ...future.startTime, 
[08:28:27.122]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.122]             version = "1.8"), class = "FutureResult")
[08:28:27.122]     }, finally = {
[08:28:27.122]         if (!identical(...future.workdir, getwd())) 
[08:28:27.122]             setwd(...future.workdir)
[08:28:27.122]         {
[08:28:27.122]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.122]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.122]             }
[08:28:27.122]             base::options(...future.oldOptions)
[08:28:27.122]             if (.Platform$OS.type == "windows") {
[08:28:27.122]                 old_names <- names(...future.oldEnvVars)
[08:28:27.122]                 envs <- base::Sys.getenv()
[08:28:27.122]                 names <- names(envs)
[08:28:27.122]                 common <- intersect(names, old_names)
[08:28:27.122]                 added <- setdiff(names, old_names)
[08:28:27.122]                 removed <- setdiff(old_names, names)
[08:28:27.122]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.122]                   envs[common]]
[08:28:27.122]                 NAMES <- toupper(changed)
[08:28:27.122]                 args <- list()
[08:28:27.122]                 for (kk in seq_along(NAMES)) {
[08:28:27.122]                   name <- changed[[kk]]
[08:28:27.122]                   NAME <- NAMES[[kk]]
[08:28:27.122]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.122]                     next
[08:28:27.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.122]                 }
[08:28:27.122]                 NAMES <- toupper(added)
[08:28:27.122]                 for (kk in seq_along(NAMES)) {
[08:28:27.122]                   name <- added[[kk]]
[08:28:27.122]                   NAME <- NAMES[[kk]]
[08:28:27.122]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.122]                     next
[08:28:27.122]                   args[[name]] <- ""
[08:28:27.122]                 }
[08:28:27.122]                 NAMES <- toupper(removed)
[08:28:27.122]                 for (kk in seq_along(NAMES)) {
[08:28:27.122]                   name <- removed[[kk]]
[08:28:27.122]                   NAME <- NAMES[[kk]]
[08:28:27.122]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.122]                     next
[08:28:27.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.122]                 }
[08:28:27.122]                 if (length(args) > 0) 
[08:28:27.122]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.122]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.122]             }
[08:28:27.122]             else {
[08:28:27.122]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.122]             }
[08:28:27.122]             {
[08:28:27.122]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.122]                   0L) {
[08:28:27.122]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.122]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.122]                   base::options(opts)
[08:28:27.122]                 }
[08:28:27.122]                 {
[08:28:27.122]                   {
[08:28:27.122]                     NULL
[08:28:27.122]                     RNGkind("Mersenne-Twister")
[08:28:27.122]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.122]                       inherits = FALSE)
[08:28:27.122]                   }
[08:28:27.122]                   options(future.plan = NULL)
[08:28:27.122]                   if (is.na(NA_character_)) 
[08:28:27.122]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.122]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.122]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.122]                     .init = FALSE)
[08:28:27.122]                 }
[08:28:27.122]             }
[08:28:27.122]         }
[08:28:27.122]     })
[08:28:27.122]     if (TRUE) {
[08:28:27.122]         base::sink(type = "output", split = FALSE)
[08:28:27.122]         if (TRUE) {
[08:28:27.122]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.122]         }
[08:28:27.122]         else {
[08:28:27.122]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.122]         }
[08:28:27.122]         base::close(...future.stdout)
[08:28:27.122]         ...future.stdout <- NULL
[08:28:27.122]     }
[08:28:27.122]     ...future.result$conditions <- ...future.conditions
[08:28:27.122]     ...future.result$finished <- base::Sys.time()
[08:28:27.122]     ...future.result
[08:28:27.122] }
[08:28:27.124] assign_globals() ...
[08:28:27.124] List of 1
[08:28:27.124]  $ ii: int 1
[08:28:27.124]  - attr(*, "where")=List of 1
[08:28:27.124]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:27.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.124]  - attr(*, "resolved")= logi FALSE
[08:28:27.124]  - attr(*, "total_size")= num 35
[08:28:27.126] - copied ‘ii’ to environment
[08:28:27.126] assign_globals() ... done
[08:28:27.127] plan(): Setting new future strategy stack:
[08:28:27.127] List of future strategies:
[08:28:27.127] 1. sequential:
[08:28:27.127]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.127]    - tweaked: FALSE
[08:28:27.127]    - call: NULL
[08:28:27.127] plan(): nbrOfWorkers() = 1
[08:28:27.128] plan(): Setting new future strategy stack:
[08:28:27.128] List of future strategies:
[08:28:27.128] 1. multicore:
[08:28:27.128]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.128]    - tweaked: FALSE
[08:28:27.128]    - call: plan(multicore)
[08:28:27.129] plan(): nbrOfWorkers() = 1
[08:28:27.130] SequentialFuture started (and completed)
 - Creating multicore future #2 ...
[08:28:27.131] getGlobalsAndPackages() ...
[08:28:27.131] Searching for globals...
[08:28:27.132] - globals found: [2] ‘{’, ‘ii’
[08:28:27.132] Searching for globals ... DONE
[08:28:27.132] Resolving globals: FALSE
[08:28:27.132] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:27.133] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:27.133] - globals: [1] ‘ii’
[08:28:27.133] 
[08:28:27.133] getGlobalsAndPackages() ... DONE
[08:28:27.133] Packages needed by the future expression (n = 0): <none>
[08:28:27.133] Packages needed by future strategies (n = 0): <none>
[08:28:27.134] {
[08:28:27.134]     {
[08:28:27.134]         {
[08:28:27.134]             ...future.startTime <- base::Sys.time()
[08:28:27.134]             {
[08:28:27.134]                 {
[08:28:27.134]                   {
[08:28:27.134]                     base::local({
[08:28:27.134]                       has_future <- base::requireNamespace("future", 
[08:28:27.134]                         quietly = TRUE)
[08:28:27.134]                       if (has_future) {
[08:28:27.134]                         ns <- base::getNamespace("future")
[08:28:27.134]                         version <- ns[[".package"]][["version"]]
[08:28:27.134]                         if (is.null(version)) 
[08:28:27.134]                           version <- utils::packageVersion("future")
[08:28:27.134]                       }
[08:28:27.134]                       else {
[08:28:27.134]                         version <- NULL
[08:28:27.134]                       }
[08:28:27.134]                       if (!has_future || version < "1.8.0") {
[08:28:27.134]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.134]                           "", base::R.version$version.string), 
[08:28:27.134]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.134]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.134]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.134]                             "release", "version")], collapse = " "), 
[08:28:27.134]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.134]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.134]                           info)
[08:28:27.134]                         info <- base::paste(info, collapse = "; ")
[08:28:27.134]                         if (!has_future) {
[08:28:27.134]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.134]                             info)
[08:28:27.134]                         }
[08:28:27.134]                         else {
[08:28:27.134]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.134]                             info, version)
[08:28:27.134]                         }
[08:28:27.134]                         base::stop(msg)
[08:28:27.134]                       }
[08:28:27.134]                     })
[08:28:27.134]                   }
[08:28:27.134]                   ...future.strategy.old <- future::plan("list")
[08:28:27.134]                   options(future.plan = NULL)
[08:28:27.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.134]                 }
[08:28:27.134]                 ...future.workdir <- getwd()
[08:28:27.134]             }
[08:28:27.134]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.134]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.134]         }
[08:28:27.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.134]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.134]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.134]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.134]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.134]             base::names(...future.oldOptions))
[08:28:27.134]     }
[08:28:27.134]     if (FALSE) {
[08:28:27.134]     }
[08:28:27.134]     else {
[08:28:27.134]         if (TRUE) {
[08:28:27.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.134]                 open = "w")
[08:28:27.134]         }
[08:28:27.134]         else {
[08:28:27.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.134]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.134]         }
[08:28:27.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.134]             base::sink(type = "output", split = FALSE)
[08:28:27.134]             base::close(...future.stdout)
[08:28:27.134]         }, add = TRUE)
[08:28:27.134]     }
[08:28:27.134]     ...future.frame <- base::sys.nframe()
[08:28:27.134]     ...future.conditions <- base::list()
[08:28:27.134]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.134]     if (FALSE) {
[08:28:27.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.134]     }
[08:28:27.134]     ...future.result <- base::tryCatch({
[08:28:27.134]         base::withCallingHandlers({
[08:28:27.134]             ...future.value <- base::withVisible(base::local({
[08:28:27.134]                 ii
[08:28:27.134]             }))
[08:28:27.134]             future::FutureResult(value = ...future.value$value, 
[08:28:27.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.134]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.134]                     ...future.globalenv.names))
[08:28:27.134]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.134]         }, condition = base::local({
[08:28:27.134]             c <- base::c
[08:28:27.134]             inherits <- base::inherits
[08:28:27.134]             invokeRestart <- base::invokeRestart
[08:28:27.134]             length <- base::length
[08:28:27.134]             list <- base::list
[08:28:27.134]             seq.int <- base::seq.int
[08:28:27.134]             signalCondition <- base::signalCondition
[08:28:27.134]             sys.calls <- base::sys.calls
[08:28:27.134]             `[[` <- base::`[[`
[08:28:27.134]             `+` <- base::`+`
[08:28:27.134]             `<<-` <- base::`<<-`
[08:28:27.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.134]                   3L)]
[08:28:27.134]             }
[08:28:27.134]             function(cond) {
[08:28:27.134]                 is_error <- inherits(cond, "error")
[08:28:27.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.134]                   NULL)
[08:28:27.134]                 if (is_error) {
[08:28:27.134]                   sessionInformation <- function() {
[08:28:27.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.134]                       search = base::search(), system = base::Sys.info())
[08:28:27.134]                   }
[08:28:27.134]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.134]                     cond$call), session = sessionInformation(), 
[08:28:27.134]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.134]                   signalCondition(cond)
[08:28:27.134]                 }
[08:28:27.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.134]                 "immediateCondition"))) {
[08:28:27.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.134]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.134]                   if (TRUE && !signal) {
[08:28:27.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.134]                     {
[08:28:27.134]                       inherits <- base::inherits
[08:28:27.134]                       invokeRestart <- base::invokeRestart
[08:28:27.134]                       is.null <- base::is.null
[08:28:27.134]                       muffled <- FALSE
[08:28:27.134]                       if (inherits(cond, "message")) {
[08:28:27.134]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.134]                         if (muffled) 
[08:28:27.134]                           invokeRestart("muffleMessage")
[08:28:27.134]                       }
[08:28:27.134]                       else if (inherits(cond, "warning")) {
[08:28:27.134]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.134]                         if (muffled) 
[08:28:27.134]                           invokeRestart("muffleWarning")
[08:28:27.134]                       }
[08:28:27.134]                       else if (inherits(cond, "condition")) {
[08:28:27.134]                         if (!is.null(pattern)) {
[08:28:27.134]                           computeRestarts <- base::computeRestarts
[08:28:27.134]                           grepl <- base::grepl
[08:28:27.134]                           restarts <- computeRestarts(cond)
[08:28:27.134]                           for (restart in restarts) {
[08:28:27.134]                             name <- restart$name
[08:28:27.134]                             if (is.null(name)) 
[08:28:27.134]                               next
[08:28:27.134]                             if (!grepl(pattern, name)) 
[08:28:27.134]                               next
[08:28:27.134]                             invokeRestart(restart)
[08:28:27.134]                             muffled <- TRUE
[08:28:27.134]                             break
[08:28:27.134]                           }
[08:28:27.134]                         }
[08:28:27.134]                       }
[08:28:27.134]                       invisible(muffled)
[08:28:27.134]                     }
[08:28:27.134]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.134]                   }
[08:28:27.134]                 }
[08:28:27.134]                 else {
[08:28:27.134]                   if (TRUE) {
[08:28:27.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.134]                     {
[08:28:27.134]                       inherits <- base::inherits
[08:28:27.134]                       invokeRestart <- base::invokeRestart
[08:28:27.134]                       is.null <- base::is.null
[08:28:27.134]                       muffled <- FALSE
[08:28:27.134]                       if (inherits(cond, "message")) {
[08:28:27.134]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.134]                         if (muffled) 
[08:28:27.134]                           invokeRestart("muffleMessage")
[08:28:27.134]                       }
[08:28:27.134]                       else if (inherits(cond, "warning")) {
[08:28:27.134]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.134]                         if (muffled) 
[08:28:27.134]                           invokeRestart("muffleWarning")
[08:28:27.134]                       }
[08:28:27.134]                       else if (inherits(cond, "condition")) {
[08:28:27.134]                         if (!is.null(pattern)) {
[08:28:27.134]                           computeRestarts <- base::computeRestarts
[08:28:27.134]                           grepl <- base::grepl
[08:28:27.134]                           restarts <- computeRestarts(cond)
[08:28:27.134]                           for (restart in restarts) {
[08:28:27.134]                             name <- restart$name
[08:28:27.134]                             if (is.null(name)) 
[08:28:27.134]                               next
[08:28:27.134]                             if (!grepl(pattern, name)) 
[08:28:27.134]                               next
[08:28:27.134]                             invokeRestart(restart)
[08:28:27.134]                             muffled <- TRUE
[08:28:27.134]                             break
[08:28:27.134]                           }
[08:28:27.134]                         }
[08:28:27.134]                       }
[08:28:27.134]                       invisible(muffled)
[08:28:27.134]                     }
[08:28:27.134]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.134]                   }
[08:28:27.134]                 }
[08:28:27.134]             }
[08:28:27.134]         }))
[08:28:27.134]     }, error = function(ex) {
[08:28:27.134]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.134]                 ...future.rng), started = ...future.startTime, 
[08:28:27.134]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.134]             version = "1.8"), class = "FutureResult")
[08:28:27.134]     }, finally = {
[08:28:27.134]         if (!identical(...future.workdir, getwd())) 
[08:28:27.134]             setwd(...future.workdir)
[08:28:27.134]         {
[08:28:27.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.134]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.134]             }
[08:28:27.134]             base::options(...future.oldOptions)
[08:28:27.134]             if (.Platform$OS.type == "windows") {
[08:28:27.134]                 old_names <- names(...future.oldEnvVars)
[08:28:27.134]                 envs <- base::Sys.getenv()
[08:28:27.134]                 names <- names(envs)
[08:28:27.134]                 common <- intersect(names, old_names)
[08:28:27.134]                 added <- setdiff(names, old_names)
[08:28:27.134]                 removed <- setdiff(old_names, names)
[08:28:27.134]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.134]                   envs[common]]
[08:28:27.134]                 NAMES <- toupper(changed)
[08:28:27.134]                 args <- list()
[08:28:27.134]                 for (kk in seq_along(NAMES)) {
[08:28:27.134]                   name <- changed[[kk]]
[08:28:27.134]                   NAME <- NAMES[[kk]]
[08:28:27.134]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.134]                     next
[08:28:27.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.134]                 }
[08:28:27.134]                 NAMES <- toupper(added)
[08:28:27.134]                 for (kk in seq_along(NAMES)) {
[08:28:27.134]                   name <- added[[kk]]
[08:28:27.134]                   NAME <- NAMES[[kk]]
[08:28:27.134]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.134]                     next
[08:28:27.134]                   args[[name]] <- ""
[08:28:27.134]                 }
[08:28:27.134]                 NAMES <- toupper(removed)
[08:28:27.134]                 for (kk in seq_along(NAMES)) {
[08:28:27.134]                   name <- removed[[kk]]
[08:28:27.134]                   NAME <- NAMES[[kk]]
[08:28:27.134]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.134]                     next
[08:28:27.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.134]                 }
[08:28:27.134]                 if (length(args) > 0) 
[08:28:27.134]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.134]             }
[08:28:27.134]             else {
[08:28:27.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.134]             }
[08:28:27.134]             {
[08:28:27.134]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.134]                   0L) {
[08:28:27.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.134]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.134]                   base::options(opts)
[08:28:27.134]                 }
[08:28:27.134]                 {
[08:28:27.134]                   {
[08:28:27.134]                     NULL
[08:28:27.134]                     RNGkind("Mersenne-Twister")
[08:28:27.134]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.134]                       inherits = FALSE)
[08:28:27.134]                   }
[08:28:27.134]                   options(future.plan = NULL)
[08:28:27.134]                   if (is.na(NA_character_)) 
[08:28:27.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.134]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.134]                     .init = FALSE)
[08:28:27.134]                 }
[08:28:27.134]             }
[08:28:27.134]         }
[08:28:27.134]     })
[08:28:27.134]     if (TRUE) {
[08:28:27.134]         base::sink(type = "output", split = FALSE)
[08:28:27.134]         if (TRUE) {
[08:28:27.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.134]         }
[08:28:27.134]         else {
[08:28:27.134]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.134]         }
[08:28:27.134]         base::close(...future.stdout)
[08:28:27.134]         ...future.stdout <- NULL
[08:28:27.134]     }
[08:28:27.134]     ...future.result$conditions <- ...future.conditions
[08:28:27.134]     ...future.result$finished <- base::Sys.time()
[08:28:27.134]     ...future.result
[08:28:27.134] }
[08:28:27.136] assign_globals() ...
[08:28:27.136] List of 1
[08:28:27.136]  $ ii: int 2
[08:28:27.136]  - attr(*, "where")=List of 1
[08:28:27.136]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:27.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.136]  - attr(*, "resolved")= logi FALSE
[08:28:27.136]  - attr(*, "total_size")= num 35
[08:28:27.138] - copied ‘ii’ to environment
[08:28:27.138] assign_globals() ... done
[08:28:27.138] plan(): Setting new future strategy stack:
[08:28:27.138] List of future strategies:
[08:28:27.138] 1. sequential:
[08:28:27.138]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.138]    - tweaked: FALSE
[08:28:27.138]    - call: NULL
[08:28:27.139] plan(): nbrOfWorkers() = 1
[08:28:27.139] plan(): Setting new future strategy stack:
[08:28:27.139] List of future strategies:
[08:28:27.139] 1. multicore:
[08:28:27.139]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.139]    - tweaked: FALSE
[08:28:27.139]    - call: plan(multicore)
[08:28:27.141] plan(): nbrOfWorkers() = 1
[08:28:27.141] SequentialFuture started (and completed)
 - Creating multicore future #3 ...
[08:28:27.143] getGlobalsAndPackages() ...
[08:28:27.143] Searching for globals...
[08:28:27.143] - globals found: [2] ‘{’, ‘ii’
[08:28:27.143] Searching for globals ... DONE
[08:28:27.144] Resolving globals: FALSE
[08:28:27.144] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:27.144] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:27.144] - globals: [1] ‘ii’
[08:28:27.144] 
[08:28:27.144] getGlobalsAndPackages() ... DONE
[08:28:27.145] Packages needed by the future expression (n = 0): <none>
[08:28:27.145] Packages needed by future strategies (n = 0): <none>
[08:28:27.145] {
[08:28:27.145]     {
[08:28:27.145]         {
[08:28:27.145]             ...future.startTime <- base::Sys.time()
[08:28:27.145]             {
[08:28:27.145]                 {
[08:28:27.145]                   {
[08:28:27.145]                     base::local({
[08:28:27.145]                       has_future <- base::requireNamespace("future", 
[08:28:27.145]                         quietly = TRUE)
[08:28:27.145]                       if (has_future) {
[08:28:27.145]                         ns <- base::getNamespace("future")
[08:28:27.145]                         version <- ns[[".package"]][["version"]]
[08:28:27.145]                         if (is.null(version)) 
[08:28:27.145]                           version <- utils::packageVersion("future")
[08:28:27.145]                       }
[08:28:27.145]                       else {
[08:28:27.145]                         version <- NULL
[08:28:27.145]                       }
[08:28:27.145]                       if (!has_future || version < "1.8.0") {
[08:28:27.145]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.145]                           "", base::R.version$version.string), 
[08:28:27.145]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.145]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.145]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.145]                             "release", "version")], collapse = " "), 
[08:28:27.145]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.145]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.145]                           info)
[08:28:27.145]                         info <- base::paste(info, collapse = "; ")
[08:28:27.145]                         if (!has_future) {
[08:28:27.145]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.145]                             info)
[08:28:27.145]                         }
[08:28:27.145]                         else {
[08:28:27.145]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.145]                             info, version)
[08:28:27.145]                         }
[08:28:27.145]                         base::stop(msg)
[08:28:27.145]                       }
[08:28:27.145]                     })
[08:28:27.145]                   }
[08:28:27.145]                   ...future.strategy.old <- future::plan("list")
[08:28:27.145]                   options(future.plan = NULL)
[08:28:27.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.145]                 }
[08:28:27.145]                 ...future.workdir <- getwd()
[08:28:27.145]             }
[08:28:27.145]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.145]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.145]         }
[08:28:27.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.145]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.145]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.145]             base::names(...future.oldOptions))
[08:28:27.145]     }
[08:28:27.145]     if (FALSE) {
[08:28:27.145]     }
[08:28:27.145]     else {
[08:28:27.145]         if (TRUE) {
[08:28:27.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.145]                 open = "w")
[08:28:27.145]         }
[08:28:27.145]         else {
[08:28:27.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.145]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.145]         }
[08:28:27.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.145]             base::sink(type = "output", split = FALSE)
[08:28:27.145]             base::close(...future.stdout)
[08:28:27.145]         }, add = TRUE)
[08:28:27.145]     }
[08:28:27.145]     ...future.frame <- base::sys.nframe()
[08:28:27.145]     ...future.conditions <- base::list()
[08:28:27.145]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.145]     if (FALSE) {
[08:28:27.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.145]     }
[08:28:27.145]     ...future.result <- base::tryCatch({
[08:28:27.145]         base::withCallingHandlers({
[08:28:27.145]             ...future.value <- base::withVisible(base::local({
[08:28:27.145]                 ii
[08:28:27.145]             }))
[08:28:27.145]             future::FutureResult(value = ...future.value$value, 
[08:28:27.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.145]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.145]                     ...future.globalenv.names))
[08:28:27.145]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.145]         }, condition = base::local({
[08:28:27.145]             c <- base::c
[08:28:27.145]             inherits <- base::inherits
[08:28:27.145]             invokeRestart <- base::invokeRestart
[08:28:27.145]             length <- base::length
[08:28:27.145]             list <- base::list
[08:28:27.145]             seq.int <- base::seq.int
[08:28:27.145]             signalCondition <- base::signalCondition
[08:28:27.145]             sys.calls <- base::sys.calls
[08:28:27.145]             `[[` <- base::`[[`
[08:28:27.145]             `+` <- base::`+`
[08:28:27.145]             `<<-` <- base::`<<-`
[08:28:27.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.145]                   3L)]
[08:28:27.145]             }
[08:28:27.145]             function(cond) {
[08:28:27.145]                 is_error <- inherits(cond, "error")
[08:28:27.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.145]                   NULL)
[08:28:27.145]                 if (is_error) {
[08:28:27.145]                   sessionInformation <- function() {
[08:28:27.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.145]                       search = base::search(), system = base::Sys.info())
[08:28:27.145]                   }
[08:28:27.145]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.145]                     cond$call), session = sessionInformation(), 
[08:28:27.145]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.145]                   signalCondition(cond)
[08:28:27.145]                 }
[08:28:27.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.145]                 "immediateCondition"))) {
[08:28:27.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.145]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.145]                   if (TRUE && !signal) {
[08:28:27.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.145]                     {
[08:28:27.145]                       inherits <- base::inherits
[08:28:27.145]                       invokeRestart <- base::invokeRestart
[08:28:27.145]                       is.null <- base::is.null
[08:28:27.145]                       muffled <- FALSE
[08:28:27.145]                       if (inherits(cond, "message")) {
[08:28:27.145]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.145]                         if (muffled) 
[08:28:27.145]                           invokeRestart("muffleMessage")
[08:28:27.145]                       }
[08:28:27.145]                       else if (inherits(cond, "warning")) {
[08:28:27.145]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.145]                         if (muffled) 
[08:28:27.145]                           invokeRestart("muffleWarning")
[08:28:27.145]                       }
[08:28:27.145]                       else if (inherits(cond, "condition")) {
[08:28:27.145]                         if (!is.null(pattern)) {
[08:28:27.145]                           computeRestarts <- base::computeRestarts
[08:28:27.145]                           grepl <- base::grepl
[08:28:27.145]                           restarts <- computeRestarts(cond)
[08:28:27.145]                           for (restart in restarts) {
[08:28:27.145]                             name <- restart$name
[08:28:27.145]                             if (is.null(name)) 
[08:28:27.145]                               next
[08:28:27.145]                             if (!grepl(pattern, name)) 
[08:28:27.145]                               next
[08:28:27.145]                             invokeRestart(restart)
[08:28:27.145]                             muffled <- TRUE
[08:28:27.145]                             break
[08:28:27.145]                           }
[08:28:27.145]                         }
[08:28:27.145]                       }
[08:28:27.145]                       invisible(muffled)
[08:28:27.145]                     }
[08:28:27.145]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.145]                   }
[08:28:27.145]                 }
[08:28:27.145]                 else {
[08:28:27.145]                   if (TRUE) {
[08:28:27.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.145]                     {
[08:28:27.145]                       inherits <- base::inherits
[08:28:27.145]                       invokeRestart <- base::invokeRestart
[08:28:27.145]                       is.null <- base::is.null
[08:28:27.145]                       muffled <- FALSE
[08:28:27.145]                       if (inherits(cond, "message")) {
[08:28:27.145]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.145]                         if (muffled) 
[08:28:27.145]                           invokeRestart("muffleMessage")
[08:28:27.145]                       }
[08:28:27.145]                       else if (inherits(cond, "warning")) {
[08:28:27.145]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.145]                         if (muffled) 
[08:28:27.145]                           invokeRestart("muffleWarning")
[08:28:27.145]                       }
[08:28:27.145]                       else if (inherits(cond, "condition")) {
[08:28:27.145]                         if (!is.null(pattern)) {
[08:28:27.145]                           computeRestarts <- base::computeRestarts
[08:28:27.145]                           grepl <- base::grepl
[08:28:27.145]                           restarts <- computeRestarts(cond)
[08:28:27.145]                           for (restart in restarts) {
[08:28:27.145]                             name <- restart$name
[08:28:27.145]                             if (is.null(name)) 
[08:28:27.145]                               next
[08:28:27.145]                             if (!grepl(pattern, name)) 
[08:28:27.145]                               next
[08:28:27.145]                             invokeRestart(restart)
[08:28:27.145]                             muffled <- TRUE
[08:28:27.145]                             break
[08:28:27.145]                           }
[08:28:27.145]                         }
[08:28:27.145]                       }
[08:28:27.145]                       invisible(muffled)
[08:28:27.145]                     }
[08:28:27.145]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.145]                   }
[08:28:27.145]                 }
[08:28:27.145]             }
[08:28:27.145]         }))
[08:28:27.145]     }, error = function(ex) {
[08:28:27.145]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.145]                 ...future.rng), started = ...future.startTime, 
[08:28:27.145]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.145]             version = "1.8"), class = "FutureResult")
[08:28:27.145]     }, finally = {
[08:28:27.145]         if (!identical(...future.workdir, getwd())) 
[08:28:27.145]             setwd(...future.workdir)
[08:28:27.145]         {
[08:28:27.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.145]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.145]             }
[08:28:27.145]             base::options(...future.oldOptions)
[08:28:27.145]             if (.Platform$OS.type == "windows") {
[08:28:27.145]                 old_names <- names(...future.oldEnvVars)
[08:28:27.145]                 envs <- base::Sys.getenv()
[08:28:27.145]                 names <- names(envs)
[08:28:27.145]                 common <- intersect(names, old_names)
[08:28:27.145]                 added <- setdiff(names, old_names)
[08:28:27.145]                 removed <- setdiff(old_names, names)
[08:28:27.145]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.145]                   envs[common]]
[08:28:27.145]                 NAMES <- toupper(changed)
[08:28:27.145]                 args <- list()
[08:28:27.145]                 for (kk in seq_along(NAMES)) {
[08:28:27.145]                   name <- changed[[kk]]
[08:28:27.145]                   NAME <- NAMES[[kk]]
[08:28:27.145]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.145]                     next
[08:28:27.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.145]                 }
[08:28:27.145]                 NAMES <- toupper(added)
[08:28:27.145]                 for (kk in seq_along(NAMES)) {
[08:28:27.145]                   name <- added[[kk]]
[08:28:27.145]                   NAME <- NAMES[[kk]]
[08:28:27.145]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.145]                     next
[08:28:27.145]                   args[[name]] <- ""
[08:28:27.145]                 }
[08:28:27.145]                 NAMES <- toupper(removed)
[08:28:27.145]                 for (kk in seq_along(NAMES)) {
[08:28:27.145]                   name <- removed[[kk]]
[08:28:27.145]                   NAME <- NAMES[[kk]]
[08:28:27.145]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.145]                     next
[08:28:27.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.145]                 }
[08:28:27.145]                 if (length(args) > 0) 
[08:28:27.145]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.145]             }
[08:28:27.145]             else {
[08:28:27.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.145]             }
[08:28:27.145]             {
[08:28:27.145]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.145]                   0L) {
[08:28:27.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.145]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.145]                   base::options(opts)
[08:28:27.145]                 }
[08:28:27.145]                 {
[08:28:27.145]                   {
[08:28:27.145]                     NULL
[08:28:27.145]                     RNGkind("Mersenne-Twister")
[08:28:27.145]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.145]                       inherits = FALSE)
[08:28:27.145]                   }
[08:28:27.145]                   options(future.plan = NULL)
[08:28:27.145]                   if (is.na(NA_character_)) 
[08:28:27.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.145]                     .init = FALSE)
[08:28:27.145]                 }
[08:28:27.145]             }
[08:28:27.145]         }
[08:28:27.145]     })
[08:28:27.145]     if (TRUE) {
[08:28:27.145]         base::sink(type = "output", split = FALSE)
[08:28:27.145]         if (TRUE) {
[08:28:27.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.145]         }
[08:28:27.145]         else {
[08:28:27.145]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.145]         }
[08:28:27.145]         base::close(...future.stdout)
[08:28:27.145]         ...future.stdout <- NULL
[08:28:27.145]     }
[08:28:27.145]     ...future.result$conditions <- ...future.conditions
[08:28:27.145]     ...future.result$finished <- base::Sys.time()
[08:28:27.145]     ...future.result
[08:28:27.145] }
[08:28:27.147] assign_globals() ...
[08:28:27.147] List of 1
[08:28:27.147]  $ ii: int 3
[08:28:27.147]  - attr(*, "where")=List of 1
[08:28:27.147]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:27.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.147]  - attr(*, "resolved")= logi FALSE
[08:28:27.147]  - attr(*, "total_size")= num 35
[08:28:27.151] - copied ‘ii’ to environment
[08:28:27.151] assign_globals() ... done
[08:28:27.152] plan(): Setting new future strategy stack:
[08:28:27.152] List of future strategies:
[08:28:27.152] 1. sequential:
[08:28:27.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.152]    - tweaked: FALSE
[08:28:27.152]    - call: NULL
[08:28:27.152] plan(): nbrOfWorkers() = 1
[08:28:27.153] plan(): Setting new future strategy stack:
[08:28:27.153] List of future strategies:
[08:28:27.153] 1. multicore:
[08:28:27.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.153]    - tweaked: FALSE
[08:28:27.153]    - call: plan(multicore)
[08:28:27.154] plan(): nbrOfWorkers() = 1
[08:28:27.155] SequentialFuture started (and completed)
 - Creating multicore future #4 ...
[08:28:27.156] getGlobalsAndPackages() ...
[08:28:27.156] Searching for globals...
[08:28:27.157] - globals found: [2] ‘{’, ‘ii’
[08:28:27.157] Searching for globals ... DONE
[08:28:27.157] Resolving globals: FALSE
[08:28:27.157] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:27.158] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:27.158] - globals: [1] ‘ii’
[08:28:27.158] 
[08:28:27.158] getGlobalsAndPackages() ... DONE
[08:28:27.158] Packages needed by the future expression (n = 0): <none>
[08:28:27.158] Packages needed by future strategies (n = 0): <none>
[08:28:27.159] {
[08:28:27.159]     {
[08:28:27.159]         {
[08:28:27.159]             ...future.startTime <- base::Sys.time()
[08:28:27.159]             {
[08:28:27.159]                 {
[08:28:27.159]                   {
[08:28:27.159]                     base::local({
[08:28:27.159]                       has_future <- base::requireNamespace("future", 
[08:28:27.159]                         quietly = TRUE)
[08:28:27.159]                       if (has_future) {
[08:28:27.159]                         ns <- base::getNamespace("future")
[08:28:27.159]                         version <- ns[[".package"]][["version"]]
[08:28:27.159]                         if (is.null(version)) 
[08:28:27.159]                           version <- utils::packageVersion("future")
[08:28:27.159]                       }
[08:28:27.159]                       else {
[08:28:27.159]                         version <- NULL
[08:28:27.159]                       }
[08:28:27.159]                       if (!has_future || version < "1.8.0") {
[08:28:27.159]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.159]                           "", base::R.version$version.string), 
[08:28:27.159]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.159]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.159]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.159]                             "release", "version")], collapse = " "), 
[08:28:27.159]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.159]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.159]                           info)
[08:28:27.159]                         info <- base::paste(info, collapse = "; ")
[08:28:27.159]                         if (!has_future) {
[08:28:27.159]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.159]                             info)
[08:28:27.159]                         }
[08:28:27.159]                         else {
[08:28:27.159]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.159]                             info, version)
[08:28:27.159]                         }
[08:28:27.159]                         base::stop(msg)
[08:28:27.159]                       }
[08:28:27.159]                     })
[08:28:27.159]                   }
[08:28:27.159]                   ...future.strategy.old <- future::plan("list")
[08:28:27.159]                   options(future.plan = NULL)
[08:28:27.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.159]                 }
[08:28:27.159]                 ...future.workdir <- getwd()
[08:28:27.159]             }
[08:28:27.159]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.159]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.159]         }
[08:28:27.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.159]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.159]             base::names(...future.oldOptions))
[08:28:27.159]     }
[08:28:27.159]     if (FALSE) {
[08:28:27.159]     }
[08:28:27.159]     else {
[08:28:27.159]         if (TRUE) {
[08:28:27.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.159]                 open = "w")
[08:28:27.159]         }
[08:28:27.159]         else {
[08:28:27.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.159]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.159]         }
[08:28:27.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.159]             base::sink(type = "output", split = FALSE)
[08:28:27.159]             base::close(...future.stdout)
[08:28:27.159]         }, add = TRUE)
[08:28:27.159]     }
[08:28:27.159]     ...future.frame <- base::sys.nframe()
[08:28:27.159]     ...future.conditions <- base::list()
[08:28:27.159]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.159]     if (FALSE) {
[08:28:27.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.159]     }
[08:28:27.159]     ...future.result <- base::tryCatch({
[08:28:27.159]         base::withCallingHandlers({
[08:28:27.159]             ...future.value <- base::withVisible(base::local({
[08:28:27.159]                 ii
[08:28:27.159]             }))
[08:28:27.159]             future::FutureResult(value = ...future.value$value, 
[08:28:27.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.159]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.159]                     ...future.globalenv.names))
[08:28:27.159]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.159]         }, condition = base::local({
[08:28:27.159]             c <- base::c
[08:28:27.159]             inherits <- base::inherits
[08:28:27.159]             invokeRestart <- base::invokeRestart
[08:28:27.159]             length <- base::length
[08:28:27.159]             list <- base::list
[08:28:27.159]             seq.int <- base::seq.int
[08:28:27.159]             signalCondition <- base::signalCondition
[08:28:27.159]             sys.calls <- base::sys.calls
[08:28:27.159]             `[[` <- base::`[[`
[08:28:27.159]             `+` <- base::`+`
[08:28:27.159]             `<<-` <- base::`<<-`
[08:28:27.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.159]                   3L)]
[08:28:27.159]             }
[08:28:27.159]             function(cond) {
[08:28:27.159]                 is_error <- inherits(cond, "error")
[08:28:27.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.159]                   NULL)
[08:28:27.159]                 if (is_error) {
[08:28:27.159]                   sessionInformation <- function() {
[08:28:27.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.159]                       search = base::search(), system = base::Sys.info())
[08:28:27.159]                   }
[08:28:27.159]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.159]                     cond$call), session = sessionInformation(), 
[08:28:27.159]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.159]                   signalCondition(cond)
[08:28:27.159]                 }
[08:28:27.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.159]                 "immediateCondition"))) {
[08:28:27.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.159]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.159]                   if (TRUE && !signal) {
[08:28:27.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.159]                     {
[08:28:27.159]                       inherits <- base::inherits
[08:28:27.159]                       invokeRestart <- base::invokeRestart
[08:28:27.159]                       is.null <- base::is.null
[08:28:27.159]                       muffled <- FALSE
[08:28:27.159]                       if (inherits(cond, "message")) {
[08:28:27.159]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.159]                         if (muffled) 
[08:28:27.159]                           invokeRestart("muffleMessage")
[08:28:27.159]                       }
[08:28:27.159]                       else if (inherits(cond, "warning")) {
[08:28:27.159]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.159]                         if (muffled) 
[08:28:27.159]                           invokeRestart("muffleWarning")
[08:28:27.159]                       }
[08:28:27.159]                       else if (inherits(cond, "condition")) {
[08:28:27.159]                         if (!is.null(pattern)) {
[08:28:27.159]                           computeRestarts <- base::computeRestarts
[08:28:27.159]                           grepl <- base::grepl
[08:28:27.159]                           restarts <- computeRestarts(cond)
[08:28:27.159]                           for (restart in restarts) {
[08:28:27.159]                             name <- restart$name
[08:28:27.159]                             if (is.null(name)) 
[08:28:27.159]                               next
[08:28:27.159]                             if (!grepl(pattern, name)) 
[08:28:27.159]                               next
[08:28:27.159]                             invokeRestart(restart)
[08:28:27.159]                             muffled <- TRUE
[08:28:27.159]                             break
[08:28:27.159]                           }
[08:28:27.159]                         }
[08:28:27.159]                       }
[08:28:27.159]                       invisible(muffled)
[08:28:27.159]                     }
[08:28:27.159]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.159]                   }
[08:28:27.159]                 }
[08:28:27.159]                 else {
[08:28:27.159]                   if (TRUE) {
[08:28:27.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.159]                     {
[08:28:27.159]                       inherits <- base::inherits
[08:28:27.159]                       invokeRestart <- base::invokeRestart
[08:28:27.159]                       is.null <- base::is.null
[08:28:27.159]                       muffled <- FALSE
[08:28:27.159]                       if (inherits(cond, "message")) {
[08:28:27.159]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.159]                         if (muffled) 
[08:28:27.159]                           invokeRestart("muffleMessage")
[08:28:27.159]                       }
[08:28:27.159]                       else if (inherits(cond, "warning")) {
[08:28:27.159]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.159]                         if (muffled) 
[08:28:27.159]                           invokeRestart("muffleWarning")
[08:28:27.159]                       }
[08:28:27.159]                       else if (inherits(cond, "condition")) {
[08:28:27.159]                         if (!is.null(pattern)) {
[08:28:27.159]                           computeRestarts <- base::computeRestarts
[08:28:27.159]                           grepl <- base::grepl
[08:28:27.159]                           restarts <- computeRestarts(cond)
[08:28:27.159]                           for (restart in restarts) {
[08:28:27.159]                             name <- restart$name
[08:28:27.159]                             if (is.null(name)) 
[08:28:27.159]                               next
[08:28:27.159]                             if (!grepl(pattern, name)) 
[08:28:27.159]                               next
[08:28:27.159]                             invokeRestart(restart)
[08:28:27.159]                             muffled <- TRUE
[08:28:27.159]                             break
[08:28:27.159]                           }
[08:28:27.159]                         }
[08:28:27.159]                       }
[08:28:27.159]                       invisible(muffled)
[08:28:27.159]                     }
[08:28:27.159]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.159]                   }
[08:28:27.159]                 }
[08:28:27.159]             }
[08:28:27.159]         }))
[08:28:27.159]     }, error = function(ex) {
[08:28:27.159]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.159]                 ...future.rng), started = ...future.startTime, 
[08:28:27.159]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.159]             version = "1.8"), class = "FutureResult")
[08:28:27.159]     }, finally = {
[08:28:27.159]         if (!identical(...future.workdir, getwd())) 
[08:28:27.159]             setwd(...future.workdir)
[08:28:27.159]         {
[08:28:27.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.159]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.159]             }
[08:28:27.159]             base::options(...future.oldOptions)
[08:28:27.159]             if (.Platform$OS.type == "windows") {
[08:28:27.159]                 old_names <- names(...future.oldEnvVars)
[08:28:27.159]                 envs <- base::Sys.getenv()
[08:28:27.159]                 names <- names(envs)
[08:28:27.159]                 common <- intersect(names, old_names)
[08:28:27.159]                 added <- setdiff(names, old_names)
[08:28:27.159]                 removed <- setdiff(old_names, names)
[08:28:27.159]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.159]                   envs[common]]
[08:28:27.159]                 NAMES <- toupper(changed)
[08:28:27.159]                 args <- list()
[08:28:27.159]                 for (kk in seq_along(NAMES)) {
[08:28:27.159]                   name <- changed[[kk]]
[08:28:27.159]                   NAME <- NAMES[[kk]]
[08:28:27.159]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.159]                     next
[08:28:27.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.159]                 }
[08:28:27.159]                 NAMES <- toupper(added)
[08:28:27.159]                 for (kk in seq_along(NAMES)) {
[08:28:27.159]                   name <- added[[kk]]
[08:28:27.159]                   NAME <- NAMES[[kk]]
[08:28:27.159]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.159]                     next
[08:28:27.159]                   args[[name]] <- ""
[08:28:27.159]                 }
[08:28:27.159]                 NAMES <- toupper(removed)
[08:28:27.159]                 for (kk in seq_along(NAMES)) {
[08:28:27.159]                   name <- removed[[kk]]
[08:28:27.159]                   NAME <- NAMES[[kk]]
[08:28:27.159]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.159]                     next
[08:28:27.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.159]                 }
[08:28:27.159]                 if (length(args) > 0) 
[08:28:27.159]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.159]             }
[08:28:27.159]             else {
[08:28:27.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.159]             }
[08:28:27.159]             {
[08:28:27.159]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.159]                   0L) {
[08:28:27.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.159]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.159]                   base::options(opts)
[08:28:27.159]                 }
[08:28:27.159]                 {
[08:28:27.159]                   {
[08:28:27.159]                     NULL
[08:28:27.159]                     RNGkind("Mersenne-Twister")
[08:28:27.159]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.159]                       inherits = FALSE)
[08:28:27.159]                   }
[08:28:27.159]                   options(future.plan = NULL)
[08:28:27.159]                   if (is.na(NA_character_)) 
[08:28:27.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.159]                     .init = FALSE)
[08:28:27.159]                 }
[08:28:27.159]             }
[08:28:27.159]         }
[08:28:27.159]     })
[08:28:27.159]     if (TRUE) {
[08:28:27.159]         base::sink(type = "output", split = FALSE)
[08:28:27.159]         if (TRUE) {
[08:28:27.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.159]         }
[08:28:27.159]         else {
[08:28:27.159]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.159]         }
[08:28:27.159]         base::close(...future.stdout)
[08:28:27.159]         ...future.stdout <- NULL
[08:28:27.159]     }
[08:28:27.159]     ...future.result$conditions <- ...future.conditions
[08:28:27.159]     ...future.result$finished <- base::Sys.time()
[08:28:27.159]     ...future.result
[08:28:27.159] }
[08:28:27.160] assign_globals() ...
[08:28:27.161] List of 1
[08:28:27.161]  $ ii: int 4
[08:28:27.161]  - attr(*, "where")=List of 1
[08:28:27.161]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:27.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.161]  - attr(*, "resolved")= logi FALSE
[08:28:27.161]  - attr(*, "total_size")= num 35
[08:28:27.163] - copied ‘ii’ to environment
[08:28:27.163] assign_globals() ... done
[08:28:27.163] plan(): Setting new future strategy stack:
[08:28:27.163] List of future strategies:
[08:28:27.163] 1. sequential:
[08:28:27.163]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.163]    - tweaked: FALSE
[08:28:27.163]    - call: NULL
[08:28:27.164] plan(): nbrOfWorkers() = 1
[08:28:27.164] plan(): Setting new future strategy stack:
[08:28:27.164] List of future strategies:
[08:28:27.164] 1. multicore:
[08:28:27.164]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.164]    - tweaked: FALSE
[08:28:27.164]    - call: plan(multicore)
[08:28:27.166] plan(): nbrOfWorkers() = 1
[08:28:27.166] SequentialFuture started (and completed)
 - Resolving 4 multicore futures
*** multicore(..., globals = TRUE) and errors
[08:28:27.168] getGlobalsAndPackages() ...
[08:28:27.168] Searching for globals...
[08:28:27.169] - globals found: [2] ‘{’, ‘stop’
[08:28:27.169] Searching for globals ... DONE
[08:28:27.169] Resolving globals: FALSE
[08:28:27.170] 
[08:28:27.170] 
[08:28:27.170] getGlobalsAndPackages() ... DONE
[08:28:27.170] Packages needed by the future expression (n = 0): <none>
[08:28:27.170] Packages needed by future strategies (n = 0): <none>
[08:28:27.171] {
[08:28:27.171]     {
[08:28:27.171]         {
[08:28:27.171]             ...future.startTime <- base::Sys.time()
[08:28:27.171]             {
[08:28:27.171]                 {
[08:28:27.171]                   {
[08:28:27.171]                     base::local({
[08:28:27.171]                       has_future <- base::requireNamespace("future", 
[08:28:27.171]                         quietly = TRUE)
[08:28:27.171]                       if (has_future) {
[08:28:27.171]                         ns <- base::getNamespace("future")
[08:28:27.171]                         version <- ns[[".package"]][["version"]]
[08:28:27.171]                         if (is.null(version)) 
[08:28:27.171]                           version <- utils::packageVersion("future")
[08:28:27.171]                       }
[08:28:27.171]                       else {
[08:28:27.171]                         version <- NULL
[08:28:27.171]                       }
[08:28:27.171]                       if (!has_future || version < "1.8.0") {
[08:28:27.171]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.171]                           "", base::R.version$version.string), 
[08:28:27.171]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.171]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.171]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.171]                             "release", "version")], collapse = " "), 
[08:28:27.171]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.171]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.171]                           info)
[08:28:27.171]                         info <- base::paste(info, collapse = "; ")
[08:28:27.171]                         if (!has_future) {
[08:28:27.171]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.171]                             info)
[08:28:27.171]                         }
[08:28:27.171]                         else {
[08:28:27.171]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.171]                             info, version)
[08:28:27.171]                         }
[08:28:27.171]                         base::stop(msg)
[08:28:27.171]                       }
[08:28:27.171]                     })
[08:28:27.171]                   }
[08:28:27.171]                   ...future.strategy.old <- future::plan("list")
[08:28:27.171]                   options(future.plan = NULL)
[08:28:27.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.171]                 }
[08:28:27.171]                 ...future.workdir <- getwd()
[08:28:27.171]             }
[08:28:27.171]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.171]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.171]         }
[08:28:27.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.171]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.171]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.171]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.171]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.171]             base::names(...future.oldOptions))
[08:28:27.171]     }
[08:28:27.171]     if (FALSE) {
[08:28:27.171]     }
[08:28:27.171]     else {
[08:28:27.171]         if (TRUE) {
[08:28:27.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.171]                 open = "w")
[08:28:27.171]         }
[08:28:27.171]         else {
[08:28:27.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.171]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.171]         }
[08:28:27.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.171]             base::sink(type = "output", split = FALSE)
[08:28:27.171]             base::close(...future.stdout)
[08:28:27.171]         }, add = TRUE)
[08:28:27.171]     }
[08:28:27.171]     ...future.frame <- base::sys.nframe()
[08:28:27.171]     ...future.conditions <- base::list()
[08:28:27.171]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.171]     if (FALSE) {
[08:28:27.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.171]     }
[08:28:27.171]     ...future.result <- base::tryCatch({
[08:28:27.171]         base::withCallingHandlers({
[08:28:27.171]             ...future.value <- base::withVisible(base::local({
[08:28:27.171]                 stop("Whoops!")
[08:28:27.171]                 1
[08:28:27.171]             }))
[08:28:27.171]             future::FutureResult(value = ...future.value$value, 
[08:28:27.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.171]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.171]                     ...future.globalenv.names))
[08:28:27.171]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.171]         }, condition = base::local({
[08:28:27.171]             c <- base::c
[08:28:27.171]             inherits <- base::inherits
[08:28:27.171]             invokeRestart <- base::invokeRestart
[08:28:27.171]             length <- base::length
[08:28:27.171]             list <- base::list
[08:28:27.171]             seq.int <- base::seq.int
[08:28:27.171]             signalCondition <- base::signalCondition
[08:28:27.171]             sys.calls <- base::sys.calls
[08:28:27.171]             `[[` <- base::`[[`
[08:28:27.171]             `+` <- base::`+`
[08:28:27.171]             `<<-` <- base::`<<-`
[08:28:27.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.171]                   3L)]
[08:28:27.171]             }
[08:28:27.171]             function(cond) {
[08:28:27.171]                 is_error <- inherits(cond, "error")
[08:28:27.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.171]                   NULL)
[08:28:27.171]                 if (is_error) {
[08:28:27.171]                   sessionInformation <- function() {
[08:28:27.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.171]                       search = base::search(), system = base::Sys.info())
[08:28:27.171]                   }
[08:28:27.171]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.171]                     cond$call), session = sessionInformation(), 
[08:28:27.171]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.171]                   signalCondition(cond)
[08:28:27.171]                 }
[08:28:27.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.171]                 "immediateCondition"))) {
[08:28:27.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.171]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.171]                   if (TRUE && !signal) {
[08:28:27.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.171]                     {
[08:28:27.171]                       inherits <- base::inherits
[08:28:27.171]                       invokeRestart <- base::invokeRestart
[08:28:27.171]                       is.null <- base::is.null
[08:28:27.171]                       muffled <- FALSE
[08:28:27.171]                       if (inherits(cond, "message")) {
[08:28:27.171]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.171]                         if (muffled) 
[08:28:27.171]                           invokeRestart("muffleMessage")
[08:28:27.171]                       }
[08:28:27.171]                       else if (inherits(cond, "warning")) {
[08:28:27.171]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.171]                         if (muffled) 
[08:28:27.171]                           invokeRestart("muffleWarning")
[08:28:27.171]                       }
[08:28:27.171]                       else if (inherits(cond, "condition")) {
[08:28:27.171]                         if (!is.null(pattern)) {
[08:28:27.171]                           computeRestarts <- base::computeRestarts
[08:28:27.171]                           grepl <- base::grepl
[08:28:27.171]                           restarts <- computeRestarts(cond)
[08:28:27.171]                           for (restart in restarts) {
[08:28:27.171]                             name <- restart$name
[08:28:27.171]                             if (is.null(name)) 
[08:28:27.171]                               next
[08:28:27.171]                             if (!grepl(pattern, name)) 
[08:28:27.171]                               next
[08:28:27.171]                             invokeRestart(restart)
[08:28:27.171]                             muffled <- TRUE
[08:28:27.171]                             break
[08:28:27.171]                           }
[08:28:27.171]                         }
[08:28:27.171]                       }
[08:28:27.171]                       invisible(muffled)
[08:28:27.171]                     }
[08:28:27.171]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.171]                   }
[08:28:27.171]                 }
[08:28:27.171]                 else {
[08:28:27.171]                   if (TRUE) {
[08:28:27.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.171]                     {
[08:28:27.171]                       inherits <- base::inherits
[08:28:27.171]                       invokeRestart <- base::invokeRestart
[08:28:27.171]                       is.null <- base::is.null
[08:28:27.171]                       muffled <- FALSE
[08:28:27.171]                       if (inherits(cond, "message")) {
[08:28:27.171]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.171]                         if (muffled) 
[08:28:27.171]                           invokeRestart("muffleMessage")
[08:28:27.171]                       }
[08:28:27.171]                       else if (inherits(cond, "warning")) {
[08:28:27.171]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.171]                         if (muffled) 
[08:28:27.171]                           invokeRestart("muffleWarning")
[08:28:27.171]                       }
[08:28:27.171]                       else if (inherits(cond, "condition")) {
[08:28:27.171]                         if (!is.null(pattern)) {
[08:28:27.171]                           computeRestarts <- base::computeRestarts
[08:28:27.171]                           grepl <- base::grepl
[08:28:27.171]                           restarts <- computeRestarts(cond)
[08:28:27.171]                           for (restart in restarts) {
[08:28:27.171]                             name <- restart$name
[08:28:27.171]                             if (is.null(name)) 
[08:28:27.171]                               next
[08:28:27.171]                             if (!grepl(pattern, name)) 
[08:28:27.171]                               next
[08:28:27.171]                             invokeRestart(restart)
[08:28:27.171]                             muffled <- TRUE
[08:28:27.171]                             break
[08:28:27.171]                           }
[08:28:27.171]                         }
[08:28:27.171]                       }
[08:28:27.171]                       invisible(muffled)
[08:28:27.171]                     }
[08:28:27.171]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.171]                   }
[08:28:27.171]                 }
[08:28:27.171]             }
[08:28:27.171]         }))
[08:28:27.171]     }, error = function(ex) {
[08:28:27.171]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.171]                 ...future.rng), started = ...future.startTime, 
[08:28:27.171]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.171]             version = "1.8"), class = "FutureResult")
[08:28:27.171]     }, finally = {
[08:28:27.171]         if (!identical(...future.workdir, getwd())) 
[08:28:27.171]             setwd(...future.workdir)
[08:28:27.171]         {
[08:28:27.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.171]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.171]             }
[08:28:27.171]             base::options(...future.oldOptions)
[08:28:27.171]             if (.Platform$OS.type == "windows") {
[08:28:27.171]                 old_names <- names(...future.oldEnvVars)
[08:28:27.171]                 envs <- base::Sys.getenv()
[08:28:27.171]                 names <- names(envs)
[08:28:27.171]                 common <- intersect(names, old_names)
[08:28:27.171]                 added <- setdiff(names, old_names)
[08:28:27.171]                 removed <- setdiff(old_names, names)
[08:28:27.171]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.171]                   envs[common]]
[08:28:27.171]                 NAMES <- toupper(changed)
[08:28:27.171]                 args <- list()
[08:28:27.171]                 for (kk in seq_along(NAMES)) {
[08:28:27.171]                   name <- changed[[kk]]
[08:28:27.171]                   NAME <- NAMES[[kk]]
[08:28:27.171]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.171]                     next
[08:28:27.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.171]                 }
[08:28:27.171]                 NAMES <- toupper(added)
[08:28:27.171]                 for (kk in seq_along(NAMES)) {
[08:28:27.171]                   name <- added[[kk]]
[08:28:27.171]                   NAME <- NAMES[[kk]]
[08:28:27.171]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.171]                     next
[08:28:27.171]                   args[[name]] <- ""
[08:28:27.171]                 }
[08:28:27.171]                 NAMES <- toupper(removed)
[08:28:27.171]                 for (kk in seq_along(NAMES)) {
[08:28:27.171]                   name <- removed[[kk]]
[08:28:27.171]                   NAME <- NAMES[[kk]]
[08:28:27.171]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.171]                     next
[08:28:27.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.171]                 }
[08:28:27.171]                 if (length(args) > 0) 
[08:28:27.171]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.171]             }
[08:28:27.171]             else {
[08:28:27.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.171]             }
[08:28:27.171]             {
[08:28:27.171]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.171]                   0L) {
[08:28:27.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.171]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.171]                   base::options(opts)
[08:28:27.171]                 }
[08:28:27.171]                 {
[08:28:27.171]                   {
[08:28:27.171]                     NULL
[08:28:27.171]                     RNGkind("Mersenne-Twister")
[08:28:27.171]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.171]                       inherits = FALSE)
[08:28:27.171]                   }
[08:28:27.171]                   options(future.plan = NULL)
[08:28:27.171]                   if (is.na(NA_character_)) 
[08:28:27.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.171]                     .init = FALSE)
[08:28:27.171]                 }
[08:28:27.171]             }
[08:28:27.171]         }
[08:28:27.171]     })
[08:28:27.171]     if (TRUE) {
[08:28:27.171]         base::sink(type = "output", split = FALSE)
[08:28:27.171]         if (TRUE) {
[08:28:27.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.171]         }
[08:28:27.171]         else {
[08:28:27.171]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.171]         }
[08:28:27.171]         base::close(...future.stdout)
[08:28:27.171]         ...future.stdout <- NULL
[08:28:27.171]     }
[08:28:27.171]     ...future.result$conditions <- ...future.conditions
[08:28:27.171]     ...future.result$finished <- base::Sys.time()
[08:28:27.171]     ...future.result
[08:28:27.171] }
[08:28:27.172] plan(): Setting new future strategy stack:
[08:28:27.173] List of future strategies:
[08:28:27.173] 1. sequential:
[08:28:27.173]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.173]    - tweaked: FALSE
[08:28:27.173]    - call: NULL
[08:28:27.173] plan(): nbrOfWorkers() = 1
[08:28:27.174] plan(): Setting new future strategy stack:
[08:28:27.174] List of future strategies:
[08:28:27.174] 1. multicore:
[08:28:27.174]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.174]    - tweaked: FALSE
[08:28:27.174]    - call: plan(multicore)
[08:28:27.176] plan(): nbrOfWorkers() = 1
[08:28:27.176] SequentialFuture started (and completed)
[08:28:27.176] signalConditions() ...
[08:28:27.176]  - include = ‘immediateCondition’
[08:28:27.176]  - exclude = 
[08:28:27.176]  - resignal = FALSE
[08:28:27.176]  - Number of conditions: 1
[08:28:27.176] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 27 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:27.177] signalConditions() ...
[08:28:27.177]  - include = ‘immediateCondition’
[08:28:27.177]  - exclude = 
[08:28:27.177]  - resignal = FALSE
[08:28:27.177]  - Number of conditions: 1
[08:28:27.177] signalConditions() ... done
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[08:28:27.177] signalConditions() ...
[08:28:27.177]  - include = ‘immediateCondition’
[08:28:27.178]  - exclude = 
[08:28:27.178]  - resignal = FALSE
[08:28:27.178]  - Number of conditions: 1
[08:28:27.178] signalConditions() ... done
[08:28:27.178] Future state: ‘finished’
[08:28:27.178] signalConditions() ...
[08:28:27.178]  - include = ‘condition’
[08:28:27.178]  - exclude = ‘immediateCondition’
[08:28:27.178]  - resignal = TRUE
[08:28:27.178]  - Number of conditions: 1
[08:28:27.178]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:27.179] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[08:28:27.179] signalConditions() ...
[08:28:27.179]  - include = ‘immediateCondition’
[08:28:27.179]  - exclude = 
[08:28:27.179]  - resignal = FALSE
[08:28:27.179]  - Number of conditions: 1
[08:28:27.179] signalConditions() ... done
[08:28:27.179] Future state: ‘finished’
[08:28:27.180] signalConditions() ...
[08:28:27.180]  - include = ‘condition’
[08:28:27.180]  - exclude = ‘immediateCondition’
[08:28:27.180]  - resignal = TRUE
[08:28:27.180]  - Number of conditions: 1
[08:28:27.180]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:27.180] signalConditions() ... done
[1] "Error in eval(quote({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    stop("Whoops!")    1}), new.env()): Whoops!>
[08:28:27.183] getGlobalsAndPackages() ...
[08:28:27.184] Searching for globals...
[08:28:27.185] - globals found: [5] ‘{’, ‘stop’, ‘structure’, ‘list’, ‘c’
[08:28:27.185] Searching for globals ... DONE
[08:28:27.185] Resolving globals: FALSE
[08:28:27.185] 
[08:28:27.185] 
[08:28:27.185] getGlobalsAndPackages() ... DONE
[08:28:27.186] Packages needed by the future expression (n = 0): <none>
[08:28:27.186] Packages needed by future strategies (n = 0): <none>
[08:28:27.186] {
[08:28:27.186]     {
[08:28:27.186]         {
[08:28:27.186]             ...future.startTime <- base::Sys.time()
[08:28:27.186]             {
[08:28:27.186]                 {
[08:28:27.186]                   {
[08:28:27.186]                     base::local({
[08:28:27.186]                       has_future <- base::requireNamespace("future", 
[08:28:27.186]                         quietly = TRUE)
[08:28:27.186]                       if (has_future) {
[08:28:27.186]                         ns <- base::getNamespace("future")
[08:28:27.186]                         version <- ns[[".package"]][["version"]]
[08:28:27.186]                         if (is.null(version)) 
[08:28:27.186]                           version <- utils::packageVersion("future")
[08:28:27.186]                       }
[08:28:27.186]                       else {
[08:28:27.186]                         version <- NULL
[08:28:27.186]                       }
[08:28:27.186]                       if (!has_future || version < "1.8.0") {
[08:28:27.186]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.186]                           "", base::R.version$version.string), 
[08:28:27.186]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.186]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.186]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.186]                             "release", "version")], collapse = " "), 
[08:28:27.186]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.186]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.186]                           info)
[08:28:27.186]                         info <- base::paste(info, collapse = "; ")
[08:28:27.186]                         if (!has_future) {
[08:28:27.186]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.186]                             info)
[08:28:27.186]                         }
[08:28:27.186]                         else {
[08:28:27.186]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.186]                             info, version)
[08:28:27.186]                         }
[08:28:27.186]                         base::stop(msg)
[08:28:27.186]                       }
[08:28:27.186]                     })
[08:28:27.186]                   }
[08:28:27.186]                   ...future.strategy.old <- future::plan("list")
[08:28:27.186]                   options(future.plan = NULL)
[08:28:27.186]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.186]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.186]                 }
[08:28:27.186]                 ...future.workdir <- getwd()
[08:28:27.186]             }
[08:28:27.186]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.186]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.186]         }
[08:28:27.186]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.186]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.186]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.186]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.186]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.186]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.186]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.186]             base::names(...future.oldOptions))
[08:28:27.186]     }
[08:28:27.186]     if (FALSE) {
[08:28:27.186]     }
[08:28:27.186]     else {
[08:28:27.186]         if (TRUE) {
[08:28:27.186]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.186]                 open = "w")
[08:28:27.186]         }
[08:28:27.186]         else {
[08:28:27.186]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.186]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.186]         }
[08:28:27.186]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.186]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.186]             base::sink(type = "output", split = FALSE)
[08:28:27.186]             base::close(...future.stdout)
[08:28:27.186]         }, add = TRUE)
[08:28:27.186]     }
[08:28:27.186]     ...future.frame <- base::sys.nframe()
[08:28:27.186]     ...future.conditions <- base::list()
[08:28:27.186]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.186]     if (FALSE) {
[08:28:27.186]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.186]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.186]     }
[08:28:27.186]     ...future.result <- base::tryCatch({
[08:28:27.186]         base::withCallingHandlers({
[08:28:27.186]             ...future.value <- base::withVisible(base::local({
[08:28:27.186]                 stop(structure(list(message = "boom"), class = c("MyError", 
[08:28:27.186]                   "error", "condition")))
[08:28:27.186]             }))
[08:28:27.186]             future::FutureResult(value = ...future.value$value, 
[08:28:27.186]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.186]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.186]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.186]                     ...future.globalenv.names))
[08:28:27.186]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.186]         }, condition = base::local({
[08:28:27.186]             c <- base::c
[08:28:27.186]             inherits <- base::inherits
[08:28:27.186]             invokeRestart <- base::invokeRestart
[08:28:27.186]             length <- base::length
[08:28:27.186]             list <- base::list
[08:28:27.186]             seq.int <- base::seq.int
[08:28:27.186]             signalCondition <- base::signalCondition
[08:28:27.186]             sys.calls <- base::sys.calls
[08:28:27.186]             `[[` <- base::`[[`
[08:28:27.186]             `+` <- base::`+`
[08:28:27.186]             `<<-` <- base::`<<-`
[08:28:27.186]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.186]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.186]                   3L)]
[08:28:27.186]             }
[08:28:27.186]             function(cond) {
[08:28:27.186]                 is_error <- inherits(cond, "error")
[08:28:27.186]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.186]                   NULL)
[08:28:27.186]                 if (is_error) {
[08:28:27.186]                   sessionInformation <- function() {
[08:28:27.186]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.186]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.186]                       search = base::search(), system = base::Sys.info())
[08:28:27.186]                   }
[08:28:27.186]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.186]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.186]                     cond$call), session = sessionInformation(), 
[08:28:27.186]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.186]                   signalCondition(cond)
[08:28:27.186]                 }
[08:28:27.186]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.186]                 "immediateCondition"))) {
[08:28:27.186]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.186]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.186]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.186]                   if (TRUE && !signal) {
[08:28:27.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.186]                     {
[08:28:27.186]                       inherits <- base::inherits
[08:28:27.186]                       invokeRestart <- base::invokeRestart
[08:28:27.186]                       is.null <- base::is.null
[08:28:27.186]                       muffled <- FALSE
[08:28:27.186]                       if (inherits(cond, "message")) {
[08:28:27.186]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.186]                         if (muffled) 
[08:28:27.186]                           invokeRestart("muffleMessage")
[08:28:27.186]                       }
[08:28:27.186]                       else if (inherits(cond, "warning")) {
[08:28:27.186]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.186]                         if (muffled) 
[08:28:27.186]                           invokeRestart("muffleWarning")
[08:28:27.186]                       }
[08:28:27.186]                       else if (inherits(cond, "condition")) {
[08:28:27.186]                         if (!is.null(pattern)) {
[08:28:27.186]                           computeRestarts <- base::computeRestarts
[08:28:27.186]                           grepl <- base::grepl
[08:28:27.186]                           restarts <- computeRestarts(cond)
[08:28:27.186]                           for (restart in restarts) {
[08:28:27.186]                             name <- restart$name
[08:28:27.186]                             if (is.null(name)) 
[08:28:27.186]                               next
[08:28:27.186]                             if (!grepl(pattern, name)) 
[08:28:27.186]                               next
[08:28:27.186]                             invokeRestart(restart)
[08:28:27.186]                             muffled <- TRUE
[08:28:27.186]                             break
[08:28:27.186]                           }
[08:28:27.186]                         }
[08:28:27.186]                       }
[08:28:27.186]                       invisible(muffled)
[08:28:27.186]                     }
[08:28:27.186]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.186]                   }
[08:28:27.186]                 }
[08:28:27.186]                 else {
[08:28:27.186]                   if (TRUE) {
[08:28:27.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.186]                     {
[08:28:27.186]                       inherits <- base::inherits
[08:28:27.186]                       invokeRestart <- base::invokeRestart
[08:28:27.186]                       is.null <- base::is.null
[08:28:27.186]                       muffled <- FALSE
[08:28:27.186]                       if (inherits(cond, "message")) {
[08:28:27.186]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.186]                         if (muffled) 
[08:28:27.186]                           invokeRestart("muffleMessage")
[08:28:27.186]                       }
[08:28:27.186]                       else if (inherits(cond, "warning")) {
[08:28:27.186]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.186]                         if (muffled) 
[08:28:27.186]                           invokeRestart("muffleWarning")
[08:28:27.186]                       }
[08:28:27.186]                       else if (inherits(cond, "condition")) {
[08:28:27.186]                         if (!is.null(pattern)) {
[08:28:27.186]                           computeRestarts <- base::computeRestarts
[08:28:27.186]                           grepl <- base::grepl
[08:28:27.186]                           restarts <- computeRestarts(cond)
[08:28:27.186]                           for (restart in restarts) {
[08:28:27.186]                             name <- restart$name
[08:28:27.186]                             if (is.null(name)) 
[08:28:27.186]                               next
[08:28:27.186]                             if (!grepl(pattern, name)) 
[08:28:27.186]                               next
[08:28:27.186]                             invokeRestart(restart)
[08:28:27.186]                             muffled <- TRUE
[08:28:27.186]                             break
[08:28:27.186]                           }
[08:28:27.186]                         }
[08:28:27.186]                       }
[08:28:27.186]                       invisible(muffled)
[08:28:27.186]                     }
[08:28:27.186]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.186]                   }
[08:28:27.186]                 }
[08:28:27.186]             }
[08:28:27.186]         }))
[08:28:27.186]     }, error = function(ex) {
[08:28:27.186]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.186]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.186]                 ...future.rng), started = ...future.startTime, 
[08:28:27.186]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.186]             version = "1.8"), class = "FutureResult")
[08:28:27.186]     }, finally = {
[08:28:27.186]         if (!identical(...future.workdir, getwd())) 
[08:28:27.186]             setwd(...future.workdir)
[08:28:27.186]         {
[08:28:27.186]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.186]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.186]             }
[08:28:27.186]             base::options(...future.oldOptions)
[08:28:27.186]             if (.Platform$OS.type == "windows") {
[08:28:27.186]                 old_names <- names(...future.oldEnvVars)
[08:28:27.186]                 envs <- base::Sys.getenv()
[08:28:27.186]                 names <- names(envs)
[08:28:27.186]                 common <- intersect(names, old_names)
[08:28:27.186]                 added <- setdiff(names, old_names)
[08:28:27.186]                 removed <- setdiff(old_names, names)
[08:28:27.186]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.186]                   envs[common]]
[08:28:27.186]                 NAMES <- toupper(changed)
[08:28:27.186]                 args <- list()
[08:28:27.186]                 for (kk in seq_along(NAMES)) {
[08:28:27.186]                   name <- changed[[kk]]
[08:28:27.186]                   NAME <- NAMES[[kk]]
[08:28:27.186]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.186]                     next
[08:28:27.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.186]                 }
[08:28:27.186]                 NAMES <- toupper(added)
[08:28:27.186]                 for (kk in seq_along(NAMES)) {
[08:28:27.186]                   name <- added[[kk]]
[08:28:27.186]                   NAME <- NAMES[[kk]]
[08:28:27.186]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.186]                     next
[08:28:27.186]                   args[[name]] <- ""
[08:28:27.186]                 }
[08:28:27.186]                 NAMES <- toupper(removed)
[08:28:27.186]                 for (kk in seq_along(NAMES)) {
[08:28:27.186]                   name <- removed[[kk]]
[08:28:27.186]                   NAME <- NAMES[[kk]]
[08:28:27.186]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.186]                     next
[08:28:27.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.186]                 }
[08:28:27.186]                 if (length(args) > 0) 
[08:28:27.186]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.186]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.186]             }
[08:28:27.186]             else {
[08:28:27.186]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.186]             }
[08:28:27.186]             {
[08:28:27.186]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.186]                   0L) {
[08:28:27.186]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.186]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.186]                   base::options(opts)
[08:28:27.186]                 }
[08:28:27.186]                 {
[08:28:27.186]                   {
[08:28:27.186]                     NULL
[08:28:27.186]                     RNGkind("Mersenne-Twister")
[08:28:27.186]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.186]                       inherits = FALSE)
[08:28:27.186]                   }
[08:28:27.186]                   options(future.plan = NULL)
[08:28:27.186]                   if (is.na(NA_character_)) 
[08:28:27.186]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.186]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.186]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.186]                     .init = FALSE)
[08:28:27.186]                 }
[08:28:27.186]             }
[08:28:27.186]         }
[08:28:27.186]     })
[08:28:27.186]     if (TRUE) {
[08:28:27.186]         base::sink(type = "output", split = FALSE)
[08:28:27.186]         if (TRUE) {
[08:28:27.186]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.186]         }
[08:28:27.186]         else {
[08:28:27.186]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.186]         }
[08:28:27.186]         base::close(...future.stdout)
[08:28:27.186]         ...future.stdout <- NULL
[08:28:27.186]     }
[08:28:27.186]     ...future.result$conditions <- ...future.conditions
[08:28:27.186]     ...future.result$finished <- base::Sys.time()
[08:28:27.186]     ...future.result
[08:28:27.186] }
[08:28:27.188] plan(): Setting new future strategy stack:
[08:28:27.188] List of future strategies:
[08:28:27.188] 1. sequential:
[08:28:27.188]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.188]    - tweaked: FALSE
[08:28:27.188]    - call: NULL
[08:28:27.189] plan(): nbrOfWorkers() = 1
[08:28:27.189] plan(): Setting new future strategy stack:
[08:28:27.190] List of future strategies:
[08:28:27.190] 1. multicore:
[08:28:27.190]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.190]    - tweaked: FALSE
[08:28:27.190]    - call: plan(multicore)
[08:28:27.191] plan(): nbrOfWorkers() = 1
[08:28:27.191] SequentialFuture started (and completed)
[08:28:27.191] signalConditions() ...
[08:28:27.191]  - include = ‘immediateCondition’
[08:28:27.192]  - exclude = 
[08:28:27.192]  - resignal = FALSE
[08:28:27.192]  - Number of conditions: 1
[08:28:27.192] signalConditions() ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 27 bytes of class ‘NULL’
Conditions captured: [n=1] ‘MyError’
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:27.192] signalConditions() ...
[08:28:27.192]  - include = ‘immediateCondition’
[08:28:27.192]  - exclude = 
[08:28:27.193]  - resignal = FALSE
[08:28:27.193]  - Number of conditions: 1
[08:28:27.193] signalConditions() ... done
<MyError: boom>
[08:28:27.193] signalConditions() ...
[08:28:27.193]  - include = ‘immediateCondition’
[08:28:27.193]  - exclude = 
[08:28:27.193]  - resignal = FALSE
[08:28:27.193]  - Number of conditions: 1
[08:28:27.193] signalConditions() ... done
[08:28:27.193] Future state: ‘finished’
[08:28:27.193] signalConditions() ...
[08:28:27.194]  - include = ‘condition’
[08:28:27.194]  - exclude = ‘immediateCondition’
[08:28:27.194]  - resignal = TRUE
[08:28:27.194]  - Number of conditions: 1
[08:28:27.194]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[08:28:27.194] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[08:28:27.194] getGlobalsAndPackages() ...
[08:28:27.194] Searching for globals...
[08:28:27.195] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[08:28:27.195] Searching for globals ... DONE
[08:28:27.195] Resolving globals: FALSE
[08:28:27.196] The total size of the 2 globals is 78 bytes (78 bytes)
[08:28:27.196] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 78 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘b’ (39 bytes of class ‘numeric’)
[08:28:27.196] - globals: [2] ‘a’, ‘b’
[08:28:27.196] 
[08:28:27.196] getGlobalsAndPackages() ... DONE
[08:28:27.197] Packages needed by the future expression (n = 0): <none>
[08:28:27.197] Packages needed by future strategies (n = 0): <none>
[08:28:27.197] {
[08:28:27.197]     {
[08:28:27.197]         {
[08:28:27.197]             ...future.startTime <- base::Sys.time()
[08:28:27.197]             {
[08:28:27.197]                 {
[08:28:27.197]                   {
[08:28:27.197]                     base::local({
[08:28:27.197]                       has_future <- base::requireNamespace("future", 
[08:28:27.197]                         quietly = TRUE)
[08:28:27.197]                       if (has_future) {
[08:28:27.197]                         ns <- base::getNamespace("future")
[08:28:27.197]                         version <- ns[[".package"]][["version"]]
[08:28:27.197]                         if (is.null(version)) 
[08:28:27.197]                           version <- utils::packageVersion("future")
[08:28:27.197]                       }
[08:28:27.197]                       else {
[08:28:27.197]                         version <- NULL
[08:28:27.197]                       }
[08:28:27.197]                       if (!has_future || version < "1.8.0") {
[08:28:27.197]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.197]                           "", base::R.version$version.string), 
[08:28:27.197]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.197]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.197]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.197]                             "release", "version")], collapse = " "), 
[08:28:27.197]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.197]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.197]                           info)
[08:28:27.197]                         info <- base::paste(info, collapse = "; ")
[08:28:27.197]                         if (!has_future) {
[08:28:27.197]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.197]                             info)
[08:28:27.197]                         }
[08:28:27.197]                         else {
[08:28:27.197]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.197]                             info, version)
[08:28:27.197]                         }
[08:28:27.197]                         base::stop(msg)
[08:28:27.197]                       }
[08:28:27.197]                     })
[08:28:27.197]                   }
[08:28:27.197]                   ...future.strategy.old <- future::plan("list")
[08:28:27.197]                   options(future.plan = NULL)
[08:28:27.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.197]                 }
[08:28:27.197]                 ...future.workdir <- getwd()
[08:28:27.197]             }
[08:28:27.197]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.197]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.197]         }
[08:28:27.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.197]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.197]             base::names(...future.oldOptions))
[08:28:27.197]     }
[08:28:27.197]     if (FALSE) {
[08:28:27.197]     }
[08:28:27.197]     else {
[08:28:27.197]         if (TRUE) {
[08:28:27.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.197]                 open = "w")
[08:28:27.197]         }
[08:28:27.197]         else {
[08:28:27.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.197]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.197]         }
[08:28:27.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.197]             base::sink(type = "output", split = FALSE)
[08:28:27.197]             base::close(...future.stdout)
[08:28:27.197]         }, add = TRUE)
[08:28:27.197]     }
[08:28:27.197]     ...future.frame <- base::sys.nframe()
[08:28:27.197]     ...future.conditions <- base::list()
[08:28:27.197]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.197]     if (FALSE) {
[08:28:27.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.197]     }
[08:28:27.197]     ...future.result <- base::tryCatch({
[08:28:27.197]         base::withCallingHandlers({
[08:28:27.197]             ...future.value <- base::withVisible(base::local({
[08:28:27.197]                 a * b
[08:28:27.197]             }))
[08:28:27.197]             future::FutureResult(value = ...future.value$value, 
[08:28:27.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.197]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.197]                     ...future.globalenv.names))
[08:28:27.197]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.197]         }, condition = base::local({
[08:28:27.197]             c <- base::c
[08:28:27.197]             inherits <- base::inherits
[08:28:27.197]             invokeRestart <- base::invokeRestart
[08:28:27.197]             length <- base::length
[08:28:27.197]             list <- base::list
[08:28:27.197]             seq.int <- base::seq.int
[08:28:27.197]             signalCondition <- base::signalCondition
[08:28:27.197]             sys.calls <- base::sys.calls
[08:28:27.197]             `[[` <- base::`[[`
[08:28:27.197]             `+` <- base::`+`
[08:28:27.197]             `<<-` <- base::`<<-`
[08:28:27.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.197]                   3L)]
[08:28:27.197]             }
[08:28:27.197]             function(cond) {
[08:28:27.197]                 is_error <- inherits(cond, "error")
[08:28:27.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.197]                   NULL)
[08:28:27.197]                 if (is_error) {
[08:28:27.197]                   sessionInformation <- function() {
[08:28:27.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.197]                       search = base::search(), system = base::Sys.info())
[08:28:27.197]                   }
[08:28:27.197]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.197]                     cond$call), session = sessionInformation(), 
[08:28:27.197]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.197]                   signalCondition(cond)
[08:28:27.197]                 }
[08:28:27.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.197]                 "immediateCondition"))) {
[08:28:27.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.197]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.197]                   if (TRUE && !signal) {
[08:28:27.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.197]                     {
[08:28:27.197]                       inherits <- base::inherits
[08:28:27.197]                       invokeRestart <- base::invokeRestart
[08:28:27.197]                       is.null <- base::is.null
[08:28:27.197]                       muffled <- FALSE
[08:28:27.197]                       if (inherits(cond, "message")) {
[08:28:27.197]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.197]                         if (muffled) 
[08:28:27.197]                           invokeRestart("muffleMessage")
[08:28:27.197]                       }
[08:28:27.197]                       else if (inherits(cond, "warning")) {
[08:28:27.197]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.197]                         if (muffled) 
[08:28:27.197]                           invokeRestart("muffleWarning")
[08:28:27.197]                       }
[08:28:27.197]                       else if (inherits(cond, "condition")) {
[08:28:27.197]                         if (!is.null(pattern)) {
[08:28:27.197]                           computeRestarts <- base::computeRestarts
[08:28:27.197]                           grepl <- base::grepl
[08:28:27.197]                           restarts <- computeRestarts(cond)
[08:28:27.197]                           for (restart in restarts) {
[08:28:27.197]                             name <- restart$name
[08:28:27.197]                             if (is.null(name)) 
[08:28:27.197]                               next
[08:28:27.197]                             if (!grepl(pattern, name)) 
[08:28:27.197]                               next
[08:28:27.197]                             invokeRestart(restart)
[08:28:27.197]                             muffled <- TRUE
[08:28:27.197]                             break
[08:28:27.197]                           }
[08:28:27.197]                         }
[08:28:27.197]                       }
[08:28:27.197]                       invisible(muffled)
[08:28:27.197]                     }
[08:28:27.197]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.197]                   }
[08:28:27.197]                 }
[08:28:27.197]                 else {
[08:28:27.197]                   if (TRUE) {
[08:28:27.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.197]                     {
[08:28:27.197]                       inherits <- base::inherits
[08:28:27.197]                       invokeRestart <- base::invokeRestart
[08:28:27.197]                       is.null <- base::is.null
[08:28:27.197]                       muffled <- FALSE
[08:28:27.197]                       if (inherits(cond, "message")) {
[08:28:27.197]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.197]                         if (muffled) 
[08:28:27.197]                           invokeRestart("muffleMessage")
[08:28:27.197]                       }
[08:28:27.197]                       else if (inherits(cond, "warning")) {
[08:28:27.197]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.197]                         if (muffled) 
[08:28:27.197]                           invokeRestart("muffleWarning")
[08:28:27.197]                       }
[08:28:27.197]                       else if (inherits(cond, "condition")) {
[08:28:27.197]                         if (!is.null(pattern)) {
[08:28:27.197]                           computeRestarts <- base::computeRestarts
[08:28:27.197]                           grepl <- base::grepl
[08:28:27.197]                           restarts <- computeRestarts(cond)
[08:28:27.197]                           for (restart in restarts) {
[08:28:27.197]                             name <- restart$name
[08:28:27.197]                             if (is.null(name)) 
[08:28:27.197]                               next
[08:28:27.197]                             if (!grepl(pattern, name)) 
[08:28:27.197]                               next
[08:28:27.197]                             invokeRestart(restart)
[08:28:27.197]                             muffled <- TRUE
[08:28:27.197]                             break
[08:28:27.197]                           }
[08:28:27.197]                         }
[08:28:27.197]                       }
[08:28:27.197]                       invisible(muffled)
[08:28:27.197]                     }
[08:28:27.197]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.197]                   }
[08:28:27.197]                 }
[08:28:27.197]             }
[08:28:27.197]         }))
[08:28:27.197]     }, error = function(ex) {
[08:28:27.197]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.197]                 ...future.rng), started = ...future.startTime, 
[08:28:27.197]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.197]             version = "1.8"), class = "FutureResult")
[08:28:27.197]     }, finally = {
[08:28:27.197]         if (!identical(...future.workdir, getwd())) 
[08:28:27.197]             setwd(...future.workdir)
[08:28:27.197]         {
[08:28:27.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.197]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.197]             }
[08:28:27.197]             base::options(...future.oldOptions)
[08:28:27.197]             if (.Platform$OS.type == "windows") {
[08:28:27.197]                 old_names <- names(...future.oldEnvVars)
[08:28:27.197]                 envs <- base::Sys.getenv()
[08:28:27.197]                 names <- names(envs)
[08:28:27.197]                 common <- intersect(names, old_names)
[08:28:27.197]                 added <- setdiff(names, old_names)
[08:28:27.197]                 removed <- setdiff(old_names, names)
[08:28:27.197]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.197]                   envs[common]]
[08:28:27.197]                 NAMES <- toupper(changed)
[08:28:27.197]                 args <- list()
[08:28:27.197]                 for (kk in seq_along(NAMES)) {
[08:28:27.197]                   name <- changed[[kk]]
[08:28:27.197]                   NAME <- NAMES[[kk]]
[08:28:27.197]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.197]                     next
[08:28:27.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.197]                 }
[08:28:27.197]                 NAMES <- toupper(added)
[08:28:27.197]                 for (kk in seq_along(NAMES)) {
[08:28:27.197]                   name <- added[[kk]]
[08:28:27.197]                   NAME <- NAMES[[kk]]
[08:28:27.197]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.197]                     next
[08:28:27.197]                   args[[name]] <- ""
[08:28:27.197]                 }
[08:28:27.197]                 NAMES <- toupper(removed)
[08:28:27.197]                 for (kk in seq_along(NAMES)) {
[08:28:27.197]                   name <- removed[[kk]]
[08:28:27.197]                   NAME <- NAMES[[kk]]
[08:28:27.197]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.197]                     next
[08:28:27.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.197]                 }
[08:28:27.197]                 if (length(args) > 0) 
[08:28:27.197]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.197]             }
[08:28:27.197]             else {
[08:28:27.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.197]             }
[08:28:27.197]             {
[08:28:27.197]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.197]                   0L) {
[08:28:27.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.197]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.197]                   base::options(opts)
[08:28:27.197]                 }
[08:28:27.197]                 {
[08:28:27.197]                   {
[08:28:27.197]                     NULL
[08:28:27.197]                     RNGkind("Mersenne-Twister")
[08:28:27.197]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.197]                       inherits = FALSE)
[08:28:27.197]                   }
[08:28:27.197]                   options(future.plan = NULL)
[08:28:27.197]                   if (is.na(NA_character_)) 
[08:28:27.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.197]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.197]                     .init = FALSE)
[08:28:27.197]                 }
[08:28:27.197]             }
[08:28:27.197]         }
[08:28:27.197]     })
[08:28:27.197]     if (TRUE) {
[08:28:27.197]         base::sink(type = "output", split = FALSE)
[08:28:27.197]         if (TRUE) {
[08:28:27.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.197]         }
[08:28:27.197]         else {
[08:28:27.197]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.197]         }
[08:28:27.197]         base::close(...future.stdout)
[08:28:27.197]         ...future.stdout <- NULL
[08:28:27.197]     }
[08:28:27.197]     ...future.result$conditions <- ...future.conditions
[08:28:27.197]     ...future.result$finished <- base::Sys.time()
[08:28:27.197]     ...future.result
[08:28:27.197] }
[08:28:27.199] assign_globals() ...
[08:28:27.199] List of 2
[08:28:27.199]  $ a: num 2
[08:28:27.199]  $ b: num 3
[08:28:27.199]  - attr(*, "where")=List of 2
[08:28:27.199]   ..$ a:<environment: R_EmptyEnv> 
[08:28:27.199]   ..$ b:<environment: R_EmptyEnv> 
[08:28:27.199]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.199]  - attr(*, "resolved")= logi FALSE
[08:28:27.199]  - attr(*, "total_size")= num 78
[08:28:27.202] - copied ‘a’ to environment
[08:28:27.202] - copied ‘b’ to environment
[08:28:27.202] assign_globals() ... done
[08:28:27.202] plan(): Setting new future strategy stack:
[08:28:27.202] List of future strategies:
[08:28:27.202] 1. sequential:
[08:28:27.202]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.202]    - tweaked: FALSE
[08:28:27.202]    - call: NULL
[08:28:27.203] plan(): nbrOfWorkers() = 1
[08:28:27.203] plan(): Setting new future strategy stack:
[08:28:27.203] List of future strategies:
[08:28:27.203] 1. multicore:
[08:28:27.203]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.203]    - tweaked: FALSE
[08:28:27.203]    - call: plan(multicore)
[08:28:27.205] plan(): nbrOfWorkers() = 1
[08:28:27.205] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Number of workers: 2
*** multicore(..., globals = FALSE) without globals
[08:28:27.208] getGlobalsAndPackages() ...
[08:28:27.208] Not searching for globals
[08:28:27.208] - globals: [0] <none>
[08:28:27.208] getGlobalsAndPackages() ... DONE
[08:28:27.209] Packages needed by the future expression (n = 0): <none>
[08:28:27.210] Packages needed by future strategies (n = 0): <none>
[08:28:27.210] {
[08:28:27.210]     {
[08:28:27.210]         {
[08:28:27.210]             ...future.startTime <- base::Sys.time()
[08:28:27.210]             {
[08:28:27.210]                 {
[08:28:27.210]                   {
[08:28:27.210]                     {
[08:28:27.210]                       base::local({
[08:28:27.210]                         has_future <- base::requireNamespace("future", 
[08:28:27.210]                           quietly = TRUE)
[08:28:27.210]                         if (has_future) {
[08:28:27.210]                           ns <- base::getNamespace("future")
[08:28:27.210]                           version <- ns[[".package"]][["version"]]
[08:28:27.210]                           if (is.null(version)) 
[08:28:27.210]                             version <- utils::packageVersion("future")
[08:28:27.210]                         }
[08:28:27.210]                         else {
[08:28:27.210]                           version <- NULL
[08:28:27.210]                         }
[08:28:27.210]                         if (!has_future || version < "1.8.0") {
[08:28:27.210]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.210]                             "", base::R.version$version.string), 
[08:28:27.210]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.210]                               "release", "version")], collapse = " "), 
[08:28:27.210]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.210]                             info)
[08:28:27.210]                           info <- base::paste(info, collapse = "; ")
[08:28:27.210]                           if (!has_future) {
[08:28:27.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.210]                               info)
[08:28:27.210]                           }
[08:28:27.210]                           else {
[08:28:27.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.210]                               info, version)
[08:28:27.210]                           }
[08:28:27.210]                           base::stop(msg)
[08:28:27.210]                         }
[08:28:27.210]                       })
[08:28:27.210]                     }
[08:28:27.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.210]                     base::options(mc.cores = 1L)
[08:28:27.210]                   }
[08:28:27.210]                   ...future.strategy.old <- future::plan("list")
[08:28:27.210]                   options(future.plan = NULL)
[08:28:27.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.210]                 }
[08:28:27.210]                 ...future.workdir <- getwd()
[08:28:27.210]             }
[08:28:27.210]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.210]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.210]         }
[08:28:27.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.210]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.210]             base::names(...future.oldOptions))
[08:28:27.210]     }
[08:28:27.210]     if (FALSE) {
[08:28:27.210]     }
[08:28:27.210]     else {
[08:28:27.210]         if (TRUE) {
[08:28:27.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.210]                 open = "w")
[08:28:27.210]         }
[08:28:27.210]         else {
[08:28:27.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.210]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.210]         }
[08:28:27.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.210]             base::sink(type = "output", split = FALSE)
[08:28:27.210]             base::close(...future.stdout)
[08:28:27.210]         }, add = TRUE)
[08:28:27.210]     }
[08:28:27.210]     ...future.frame <- base::sys.nframe()
[08:28:27.210]     ...future.conditions <- base::list()
[08:28:27.210]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.210]     if (FALSE) {
[08:28:27.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.210]     }
[08:28:27.210]     ...future.result <- base::tryCatch({
[08:28:27.210]         base::withCallingHandlers({
[08:28:27.210]             ...future.value <- base::withVisible(base::local({
[08:28:27.210]                 withCallingHandlers({
[08:28:27.210]                   {
[08:28:27.210]                     42L
[08:28:27.210]                   }
[08:28:27.210]                 }, immediateCondition = function(cond) {
[08:28:27.210]                   save_rds <- function (object, pathname, ...) 
[08:28:27.210]                   {
[08:28:27.210]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.210]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.210]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.210]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.210]                         fi_tmp[["mtime"]])
[08:28:27.210]                     }
[08:28:27.210]                     tryCatch({
[08:28:27.210]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.210]                     }, error = function(ex) {
[08:28:27.210]                       msg <- conditionMessage(ex)
[08:28:27.210]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.210]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.210]                         fi_tmp[["mtime"]], msg)
[08:28:27.210]                       ex$message <- msg
[08:28:27.210]                       stop(ex)
[08:28:27.210]                     })
[08:28:27.210]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.210]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.210]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.210]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.210]                       fi <- file.info(pathname)
[08:28:27.210]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.210]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.210]                         fi[["size"]], fi[["mtime"]])
[08:28:27.210]                       stop(msg)
[08:28:27.210]                     }
[08:28:27.210]                     invisible(pathname)
[08:28:27.210]                   }
[08:28:27.210]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.210]                     rootPath = tempdir()) 
[08:28:27.210]                   {
[08:28:27.210]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.210]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.210]                       tmpdir = path, fileext = ".rds")
[08:28:27.210]                     save_rds(obj, file)
[08:28:27.210]                   }
[08:28:27.210]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.210]                   {
[08:28:27.210]                     inherits <- base::inherits
[08:28:27.210]                     invokeRestart <- base::invokeRestart
[08:28:27.210]                     is.null <- base::is.null
[08:28:27.210]                     muffled <- FALSE
[08:28:27.210]                     if (inherits(cond, "message")) {
[08:28:27.210]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.210]                       if (muffled) 
[08:28:27.210]                         invokeRestart("muffleMessage")
[08:28:27.210]                     }
[08:28:27.210]                     else if (inherits(cond, "warning")) {
[08:28:27.210]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.210]                       if (muffled) 
[08:28:27.210]                         invokeRestart("muffleWarning")
[08:28:27.210]                     }
[08:28:27.210]                     else if (inherits(cond, "condition")) {
[08:28:27.210]                       if (!is.null(pattern)) {
[08:28:27.210]                         computeRestarts <- base::computeRestarts
[08:28:27.210]                         grepl <- base::grepl
[08:28:27.210]                         restarts <- computeRestarts(cond)
[08:28:27.210]                         for (restart in restarts) {
[08:28:27.210]                           name <- restart$name
[08:28:27.210]                           if (is.null(name)) 
[08:28:27.210]                             next
[08:28:27.210]                           if (!grepl(pattern, name)) 
[08:28:27.210]                             next
[08:28:27.210]                           invokeRestart(restart)
[08:28:27.210]                           muffled <- TRUE
[08:28:27.210]                           break
[08:28:27.210]                         }
[08:28:27.210]                       }
[08:28:27.210]                     }
[08:28:27.210]                     invisible(muffled)
[08:28:27.210]                   }
[08:28:27.210]                   muffleCondition(cond)
[08:28:27.210]                 })
[08:28:27.210]             }))
[08:28:27.210]             future::FutureResult(value = ...future.value$value, 
[08:28:27.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.210]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.210]                     ...future.globalenv.names))
[08:28:27.210]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.210]         }, condition = base::local({
[08:28:27.210]             c <- base::c
[08:28:27.210]             inherits <- base::inherits
[08:28:27.210]             invokeRestart <- base::invokeRestart
[08:28:27.210]             length <- base::length
[08:28:27.210]             list <- base::list
[08:28:27.210]             seq.int <- base::seq.int
[08:28:27.210]             signalCondition <- base::signalCondition
[08:28:27.210]             sys.calls <- base::sys.calls
[08:28:27.210]             `[[` <- base::`[[`
[08:28:27.210]             `+` <- base::`+`
[08:28:27.210]             `<<-` <- base::`<<-`
[08:28:27.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.210]                   3L)]
[08:28:27.210]             }
[08:28:27.210]             function(cond) {
[08:28:27.210]                 is_error <- inherits(cond, "error")
[08:28:27.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.210]                   NULL)
[08:28:27.210]                 if (is_error) {
[08:28:27.210]                   sessionInformation <- function() {
[08:28:27.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.210]                       search = base::search(), system = base::Sys.info())
[08:28:27.210]                   }
[08:28:27.210]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.210]                     cond$call), session = sessionInformation(), 
[08:28:27.210]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.210]                   signalCondition(cond)
[08:28:27.210]                 }
[08:28:27.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.210]                 "immediateCondition"))) {
[08:28:27.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.210]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.210]                   if (TRUE && !signal) {
[08:28:27.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.210]                     {
[08:28:27.210]                       inherits <- base::inherits
[08:28:27.210]                       invokeRestart <- base::invokeRestart
[08:28:27.210]                       is.null <- base::is.null
[08:28:27.210]                       muffled <- FALSE
[08:28:27.210]                       if (inherits(cond, "message")) {
[08:28:27.210]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.210]                         if (muffled) 
[08:28:27.210]                           invokeRestart("muffleMessage")
[08:28:27.210]                       }
[08:28:27.210]                       else if (inherits(cond, "warning")) {
[08:28:27.210]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.210]                         if (muffled) 
[08:28:27.210]                           invokeRestart("muffleWarning")
[08:28:27.210]                       }
[08:28:27.210]                       else if (inherits(cond, "condition")) {
[08:28:27.210]                         if (!is.null(pattern)) {
[08:28:27.210]                           computeRestarts <- base::computeRestarts
[08:28:27.210]                           grepl <- base::grepl
[08:28:27.210]                           restarts <- computeRestarts(cond)
[08:28:27.210]                           for (restart in restarts) {
[08:28:27.210]                             name <- restart$name
[08:28:27.210]                             if (is.null(name)) 
[08:28:27.210]                               next
[08:28:27.210]                             if (!grepl(pattern, name)) 
[08:28:27.210]                               next
[08:28:27.210]                             invokeRestart(restart)
[08:28:27.210]                             muffled <- TRUE
[08:28:27.210]                             break
[08:28:27.210]                           }
[08:28:27.210]                         }
[08:28:27.210]                       }
[08:28:27.210]                       invisible(muffled)
[08:28:27.210]                     }
[08:28:27.210]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.210]                   }
[08:28:27.210]                 }
[08:28:27.210]                 else {
[08:28:27.210]                   if (TRUE) {
[08:28:27.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.210]                     {
[08:28:27.210]                       inherits <- base::inherits
[08:28:27.210]                       invokeRestart <- base::invokeRestart
[08:28:27.210]                       is.null <- base::is.null
[08:28:27.210]                       muffled <- FALSE
[08:28:27.210]                       if (inherits(cond, "message")) {
[08:28:27.210]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.210]                         if (muffled) 
[08:28:27.210]                           invokeRestart("muffleMessage")
[08:28:27.210]                       }
[08:28:27.210]                       else if (inherits(cond, "warning")) {
[08:28:27.210]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.210]                         if (muffled) 
[08:28:27.210]                           invokeRestart("muffleWarning")
[08:28:27.210]                       }
[08:28:27.210]                       else if (inherits(cond, "condition")) {
[08:28:27.210]                         if (!is.null(pattern)) {
[08:28:27.210]                           computeRestarts <- base::computeRestarts
[08:28:27.210]                           grepl <- base::grepl
[08:28:27.210]                           restarts <- computeRestarts(cond)
[08:28:27.210]                           for (restart in restarts) {
[08:28:27.210]                             name <- restart$name
[08:28:27.210]                             if (is.null(name)) 
[08:28:27.210]                               next
[08:28:27.210]                             if (!grepl(pattern, name)) 
[08:28:27.210]                               next
[08:28:27.210]                             invokeRestart(restart)
[08:28:27.210]                             muffled <- TRUE
[08:28:27.210]                             break
[08:28:27.210]                           }
[08:28:27.210]                         }
[08:28:27.210]                       }
[08:28:27.210]                       invisible(muffled)
[08:28:27.210]                     }
[08:28:27.210]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.210]                   }
[08:28:27.210]                 }
[08:28:27.210]             }
[08:28:27.210]         }))
[08:28:27.210]     }, error = function(ex) {
[08:28:27.210]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.210]                 ...future.rng), started = ...future.startTime, 
[08:28:27.210]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.210]             version = "1.8"), class = "FutureResult")
[08:28:27.210]     }, finally = {
[08:28:27.210]         if (!identical(...future.workdir, getwd())) 
[08:28:27.210]             setwd(...future.workdir)
[08:28:27.210]         {
[08:28:27.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.210]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.210]             }
[08:28:27.210]             base::options(...future.oldOptions)
[08:28:27.210]             if (.Platform$OS.type == "windows") {
[08:28:27.210]                 old_names <- names(...future.oldEnvVars)
[08:28:27.210]                 envs <- base::Sys.getenv()
[08:28:27.210]                 names <- names(envs)
[08:28:27.210]                 common <- intersect(names, old_names)
[08:28:27.210]                 added <- setdiff(names, old_names)
[08:28:27.210]                 removed <- setdiff(old_names, names)
[08:28:27.210]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.210]                   envs[common]]
[08:28:27.210]                 NAMES <- toupper(changed)
[08:28:27.210]                 args <- list()
[08:28:27.210]                 for (kk in seq_along(NAMES)) {
[08:28:27.210]                   name <- changed[[kk]]
[08:28:27.210]                   NAME <- NAMES[[kk]]
[08:28:27.210]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.210]                     next
[08:28:27.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.210]                 }
[08:28:27.210]                 NAMES <- toupper(added)
[08:28:27.210]                 for (kk in seq_along(NAMES)) {
[08:28:27.210]                   name <- added[[kk]]
[08:28:27.210]                   NAME <- NAMES[[kk]]
[08:28:27.210]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.210]                     next
[08:28:27.210]                   args[[name]] <- ""
[08:28:27.210]                 }
[08:28:27.210]                 NAMES <- toupper(removed)
[08:28:27.210]                 for (kk in seq_along(NAMES)) {
[08:28:27.210]                   name <- removed[[kk]]
[08:28:27.210]                   NAME <- NAMES[[kk]]
[08:28:27.210]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.210]                     next
[08:28:27.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.210]                 }
[08:28:27.210]                 if (length(args) > 0) 
[08:28:27.210]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.210]             }
[08:28:27.210]             else {
[08:28:27.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.210]             }
[08:28:27.210]             {
[08:28:27.210]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.210]                   0L) {
[08:28:27.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.210]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.210]                   base::options(opts)
[08:28:27.210]                 }
[08:28:27.210]                 {
[08:28:27.210]                   {
[08:28:27.210]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.210]                     NULL
[08:28:27.210]                   }
[08:28:27.210]                   options(future.plan = NULL)
[08:28:27.210]                   if (is.na(NA_character_)) 
[08:28:27.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.210]                     .init = FALSE)
[08:28:27.210]                 }
[08:28:27.210]             }
[08:28:27.210]         }
[08:28:27.210]     })
[08:28:27.210]     if (TRUE) {
[08:28:27.210]         base::sink(type = "output", split = FALSE)
[08:28:27.210]         if (TRUE) {
[08:28:27.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.210]         }
[08:28:27.210]         else {
[08:28:27.210]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.210]         }
[08:28:27.210]         base::close(...future.stdout)
[08:28:27.210]         ...future.stdout <- NULL
[08:28:27.210]     }
[08:28:27.210]     ...future.result$conditions <- ...future.conditions
[08:28:27.210]     ...future.result$finished <- base::Sys.time()
[08:28:27.210]     ...future.result
[08:28:27.210] }
[08:28:27.212] requestCore(): workers = 2
[08:28:27.215] MulticoreFuture started
[08:28:27.216] plan(): Setting new future strategy stack:
[08:28:27.216] List of future strategies:
[08:28:27.216] 1. sequential:
[08:28:27.216]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.216]    - tweaked: FALSE
[08:28:27.216]    - call: NULL
[08:28:27.217] plan(): nbrOfWorkers() = 1
[08:28:27.219] plan(): Setting new future strategy stack:
[08:28:27.219] List of future strategies:
[08:28:27.219] 1. multicore:
[08:28:27.219]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.219]    - tweaked: FALSE
[08:28:27.219]    - call: plan(multicore)
[08:28:27.228] plan(): nbrOfWorkers() = 2
[1] FALSE
[08:28:27.229] result() for MulticoreFuture ...
[08:28:27.237] result() for MulticoreFuture ...
[08:28:27.237] result() for MulticoreFuture ... done
[08:28:27.237] result() for MulticoreFuture ... done
[08:28:27.237] result() for MulticoreFuture ...
[08:28:27.237] result() for MulticoreFuture ... done
[1] 42
*** multicore(..., globals = FALSE) with globals
[08:28:27.239] getGlobalsAndPackages() ...
[08:28:27.239] Not searching for globals
[08:28:27.239] - globals: [0] <none>
[08:28:27.239] getGlobalsAndPackages() ... DONE
[08:28:27.240] Packages needed by the future expression (n = 0): <none>
[08:28:27.240] Packages needed by future strategies (n = 0): <none>
[08:28:27.241] {
[08:28:27.241]     {
[08:28:27.241]         {
[08:28:27.241]             ...future.startTime <- base::Sys.time()
[08:28:27.241]             {
[08:28:27.241]                 {
[08:28:27.241]                   {
[08:28:27.241]                     {
[08:28:27.241]                       base::local({
[08:28:27.241]                         has_future <- base::requireNamespace("future", 
[08:28:27.241]                           quietly = TRUE)
[08:28:27.241]                         if (has_future) {
[08:28:27.241]                           ns <- base::getNamespace("future")
[08:28:27.241]                           version <- ns[[".package"]][["version"]]
[08:28:27.241]                           if (is.null(version)) 
[08:28:27.241]                             version <- utils::packageVersion("future")
[08:28:27.241]                         }
[08:28:27.241]                         else {
[08:28:27.241]                           version <- NULL
[08:28:27.241]                         }
[08:28:27.241]                         if (!has_future || version < "1.8.0") {
[08:28:27.241]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.241]                             "", base::R.version$version.string), 
[08:28:27.241]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.241]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.241]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.241]                               "release", "version")], collapse = " "), 
[08:28:27.241]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.241]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.241]                             info)
[08:28:27.241]                           info <- base::paste(info, collapse = "; ")
[08:28:27.241]                           if (!has_future) {
[08:28:27.241]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.241]                               info)
[08:28:27.241]                           }
[08:28:27.241]                           else {
[08:28:27.241]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.241]                               info, version)
[08:28:27.241]                           }
[08:28:27.241]                           base::stop(msg)
[08:28:27.241]                         }
[08:28:27.241]                       })
[08:28:27.241]                     }
[08:28:27.241]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.241]                     base::options(mc.cores = 1L)
[08:28:27.241]                   }
[08:28:27.241]                   ...future.strategy.old <- future::plan("list")
[08:28:27.241]                   options(future.plan = NULL)
[08:28:27.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.241]                 }
[08:28:27.241]                 ...future.workdir <- getwd()
[08:28:27.241]             }
[08:28:27.241]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.241]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.241]         }
[08:28:27.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.241]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.241]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.241]             base::names(...future.oldOptions))
[08:28:27.241]     }
[08:28:27.241]     if (FALSE) {
[08:28:27.241]     }
[08:28:27.241]     else {
[08:28:27.241]         if (TRUE) {
[08:28:27.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.241]                 open = "w")
[08:28:27.241]         }
[08:28:27.241]         else {
[08:28:27.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.241]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.241]         }
[08:28:27.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.241]             base::sink(type = "output", split = FALSE)
[08:28:27.241]             base::close(...future.stdout)
[08:28:27.241]         }, add = TRUE)
[08:28:27.241]     }
[08:28:27.241]     ...future.frame <- base::sys.nframe()
[08:28:27.241]     ...future.conditions <- base::list()
[08:28:27.241]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.241]     if (FALSE) {
[08:28:27.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.241]     }
[08:28:27.241]     ...future.result <- base::tryCatch({
[08:28:27.241]         base::withCallingHandlers({
[08:28:27.241]             ...future.value <- base::withVisible(base::local({
[08:28:27.241]                 withCallingHandlers({
[08:28:27.241]                   {
[08:28:27.241]                     b <- 3
[08:28:27.241]                     c <- 2
[08:28:27.241]                     a * b * c
[08:28:27.241]                   }
[08:28:27.241]                 }, immediateCondition = function(cond) {
[08:28:27.241]                   save_rds <- function (object, pathname, ...) 
[08:28:27.241]                   {
[08:28:27.241]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.241]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.241]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.241]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.241]                         fi_tmp[["mtime"]])
[08:28:27.241]                     }
[08:28:27.241]                     tryCatch({
[08:28:27.241]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.241]                     }, error = function(ex) {
[08:28:27.241]                       msg <- conditionMessage(ex)
[08:28:27.241]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.241]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.241]                         fi_tmp[["mtime"]], msg)
[08:28:27.241]                       ex$message <- msg
[08:28:27.241]                       stop(ex)
[08:28:27.241]                     })
[08:28:27.241]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.241]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.241]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.241]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.241]                       fi <- file.info(pathname)
[08:28:27.241]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.241]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.241]                         fi[["size"]], fi[["mtime"]])
[08:28:27.241]                       stop(msg)
[08:28:27.241]                     }
[08:28:27.241]                     invisible(pathname)
[08:28:27.241]                   }
[08:28:27.241]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.241]                     rootPath = tempdir()) 
[08:28:27.241]                   {
[08:28:27.241]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.241]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.241]                       tmpdir = path, fileext = ".rds")
[08:28:27.241]                     save_rds(obj, file)
[08:28:27.241]                   }
[08:28:27.241]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.241]                   {
[08:28:27.241]                     inherits <- base::inherits
[08:28:27.241]                     invokeRestart <- base::invokeRestart
[08:28:27.241]                     is.null <- base::is.null
[08:28:27.241]                     muffled <- FALSE
[08:28:27.241]                     if (inherits(cond, "message")) {
[08:28:27.241]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.241]                       if (muffled) 
[08:28:27.241]                         invokeRestart("muffleMessage")
[08:28:27.241]                     }
[08:28:27.241]                     else if (inherits(cond, "warning")) {
[08:28:27.241]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.241]                       if (muffled) 
[08:28:27.241]                         invokeRestart("muffleWarning")
[08:28:27.241]                     }
[08:28:27.241]                     else if (inherits(cond, "condition")) {
[08:28:27.241]                       if (!is.null(pattern)) {
[08:28:27.241]                         computeRestarts <- base::computeRestarts
[08:28:27.241]                         grepl <- base::grepl
[08:28:27.241]                         restarts <- computeRestarts(cond)
[08:28:27.241]                         for (restart in restarts) {
[08:28:27.241]                           name <- restart$name
[08:28:27.241]                           if (is.null(name)) 
[08:28:27.241]                             next
[08:28:27.241]                           if (!grepl(pattern, name)) 
[08:28:27.241]                             next
[08:28:27.241]                           invokeRestart(restart)
[08:28:27.241]                           muffled <- TRUE
[08:28:27.241]                           break
[08:28:27.241]                         }
[08:28:27.241]                       }
[08:28:27.241]                     }
[08:28:27.241]                     invisible(muffled)
[08:28:27.241]                   }
[08:28:27.241]                   muffleCondition(cond)
[08:28:27.241]                 })
[08:28:27.241]             }))
[08:28:27.241]             future::FutureResult(value = ...future.value$value, 
[08:28:27.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.241]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.241]                     ...future.globalenv.names))
[08:28:27.241]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.241]         }, condition = base::local({
[08:28:27.241]             c <- base::c
[08:28:27.241]             inherits <- base::inherits
[08:28:27.241]             invokeRestart <- base::invokeRestart
[08:28:27.241]             length <- base::length
[08:28:27.241]             list <- base::list
[08:28:27.241]             seq.int <- base::seq.int
[08:28:27.241]             signalCondition <- base::signalCondition
[08:28:27.241]             sys.calls <- base::sys.calls
[08:28:27.241]             `[[` <- base::`[[`
[08:28:27.241]             `+` <- base::`+`
[08:28:27.241]             `<<-` <- base::`<<-`
[08:28:27.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.241]                   3L)]
[08:28:27.241]             }
[08:28:27.241]             function(cond) {
[08:28:27.241]                 is_error <- inherits(cond, "error")
[08:28:27.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.241]                   NULL)
[08:28:27.241]                 if (is_error) {
[08:28:27.241]                   sessionInformation <- function() {
[08:28:27.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.241]                       search = base::search(), system = base::Sys.info())
[08:28:27.241]                   }
[08:28:27.241]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.241]                     cond$call), session = sessionInformation(), 
[08:28:27.241]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.241]                   signalCondition(cond)
[08:28:27.241]                 }
[08:28:27.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.241]                 "immediateCondition"))) {
[08:28:27.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.241]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.241]                   if (TRUE && !signal) {
[08:28:27.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.241]                     {
[08:28:27.241]                       inherits <- base::inherits
[08:28:27.241]                       invokeRestart <- base::invokeRestart
[08:28:27.241]                       is.null <- base::is.null
[08:28:27.241]                       muffled <- FALSE
[08:28:27.241]                       if (inherits(cond, "message")) {
[08:28:27.241]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.241]                         if (muffled) 
[08:28:27.241]                           invokeRestart("muffleMessage")
[08:28:27.241]                       }
[08:28:27.241]                       else if (inherits(cond, "warning")) {
[08:28:27.241]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.241]                         if (muffled) 
[08:28:27.241]                           invokeRestart("muffleWarning")
[08:28:27.241]                       }
[08:28:27.241]                       else if (inherits(cond, "condition")) {
[08:28:27.241]                         if (!is.null(pattern)) {
[08:28:27.241]                           computeRestarts <- base::computeRestarts
[08:28:27.241]                           grepl <- base::grepl
[08:28:27.241]                           restarts <- computeRestarts(cond)
[08:28:27.241]                           for (restart in restarts) {
[08:28:27.241]                             name <- restart$name
[08:28:27.241]                             if (is.null(name)) 
[08:28:27.241]                               next
[08:28:27.241]                             if (!grepl(pattern, name)) 
[08:28:27.241]                               next
[08:28:27.241]                             invokeRestart(restart)
[08:28:27.241]                             muffled <- TRUE
[08:28:27.241]                             break
[08:28:27.241]                           }
[08:28:27.241]                         }
[08:28:27.241]                       }
[08:28:27.241]                       invisible(muffled)
[08:28:27.241]                     }
[08:28:27.241]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.241]                   }
[08:28:27.241]                 }
[08:28:27.241]                 else {
[08:28:27.241]                   if (TRUE) {
[08:28:27.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.241]                     {
[08:28:27.241]                       inherits <- base::inherits
[08:28:27.241]                       invokeRestart <- base::invokeRestart
[08:28:27.241]                       is.null <- base::is.null
[08:28:27.241]                       muffled <- FALSE
[08:28:27.241]                       if (inherits(cond, "message")) {
[08:28:27.241]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.241]                         if (muffled) 
[08:28:27.241]                           invokeRestart("muffleMessage")
[08:28:27.241]                       }
[08:28:27.241]                       else if (inherits(cond, "warning")) {
[08:28:27.241]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.241]                         if (muffled) 
[08:28:27.241]                           invokeRestart("muffleWarning")
[08:28:27.241]                       }
[08:28:27.241]                       else if (inherits(cond, "condition")) {
[08:28:27.241]                         if (!is.null(pattern)) {
[08:28:27.241]                           computeRestarts <- base::computeRestarts
[08:28:27.241]                           grepl <- base::grepl
[08:28:27.241]                           restarts <- computeRestarts(cond)
[08:28:27.241]                           for (restart in restarts) {
[08:28:27.241]                             name <- restart$name
[08:28:27.241]                             if (is.null(name)) 
[08:28:27.241]                               next
[08:28:27.241]                             if (!grepl(pattern, name)) 
[08:28:27.241]                               next
[08:28:27.241]                             invokeRestart(restart)
[08:28:27.241]                             muffled <- TRUE
[08:28:27.241]                             break
[08:28:27.241]                           }
[08:28:27.241]                         }
[08:28:27.241]                       }
[08:28:27.241]                       invisible(muffled)
[08:28:27.241]                     }
[08:28:27.241]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.241]                   }
[08:28:27.241]                 }
[08:28:27.241]             }
[08:28:27.241]         }))
[08:28:27.241]     }, error = function(ex) {
[08:28:27.241]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.241]                 ...future.rng), started = ...future.startTime, 
[08:28:27.241]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.241]             version = "1.8"), class = "FutureResult")
[08:28:27.241]     }, finally = {
[08:28:27.241]         if (!identical(...future.workdir, getwd())) 
[08:28:27.241]             setwd(...future.workdir)
[08:28:27.241]         {
[08:28:27.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.241]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.241]             }
[08:28:27.241]             base::options(...future.oldOptions)
[08:28:27.241]             if (.Platform$OS.type == "windows") {
[08:28:27.241]                 old_names <- names(...future.oldEnvVars)
[08:28:27.241]                 envs <- base::Sys.getenv()
[08:28:27.241]                 names <- names(envs)
[08:28:27.241]                 common <- intersect(names, old_names)
[08:28:27.241]                 added <- setdiff(names, old_names)
[08:28:27.241]                 removed <- setdiff(old_names, names)
[08:28:27.241]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.241]                   envs[common]]
[08:28:27.241]                 NAMES <- toupper(changed)
[08:28:27.241]                 args <- list()
[08:28:27.241]                 for (kk in seq_along(NAMES)) {
[08:28:27.241]                   name <- changed[[kk]]
[08:28:27.241]                   NAME <- NAMES[[kk]]
[08:28:27.241]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.241]                     next
[08:28:27.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.241]                 }
[08:28:27.241]                 NAMES <- toupper(added)
[08:28:27.241]                 for (kk in seq_along(NAMES)) {
[08:28:27.241]                   name <- added[[kk]]
[08:28:27.241]                   NAME <- NAMES[[kk]]
[08:28:27.241]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.241]                     next
[08:28:27.241]                   args[[name]] <- ""
[08:28:27.241]                 }
[08:28:27.241]                 NAMES <- toupper(removed)
[08:28:27.241]                 for (kk in seq_along(NAMES)) {
[08:28:27.241]                   name <- removed[[kk]]
[08:28:27.241]                   NAME <- NAMES[[kk]]
[08:28:27.241]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.241]                     next
[08:28:27.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.241]                 }
[08:28:27.241]                 if (length(args) > 0) 
[08:28:27.241]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.241]             }
[08:28:27.241]             else {
[08:28:27.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.241]             }
[08:28:27.241]             {
[08:28:27.241]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.241]                   0L) {
[08:28:27.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.241]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.241]                   base::options(opts)
[08:28:27.241]                 }
[08:28:27.241]                 {
[08:28:27.241]                   {
[08:28:27.241]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.241]                     NULL
[08:28:27.241]                   }
[08:28:27.241]                   options(future.plan = NULL)
[08:28:27.241]                   if (is.na(NA_character_)) 
[08:28:27.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.241]                     .init = FALSE)
[08:28:27.241]                 }
[08:28:27.241]             }
[08:28:27.241]         }
[08:28:27.241]     })
[08:28:27.241]     if (TRUE) {
[08:28:27.241]         base::sink(type = "output", split = FALSE)
[08:28:27.241]         if (TRUE) {
[08:28:27.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.241]         }
[08:28:27.241]         else {
[08:28:27.241]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.241]         }
[08:28:27.241]         base::close(...future.stdout)
[08:28:27.241]         ...future.stdout <- NULL
[08:28:27.241]     }
[08:28:27.241]     ...future.result$conditions <- ...future.conditions
[08:28:27.241]     ...future.result$finished <- base::Sys.time()
[08:28:27.241]     ...future.result
[08:28:27.241] }
[08:28:27.243] requestCore(): workers = 2
[08:28:27.245] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:28:27.246] plan(): Setting new future strategy stack:
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:28:27.246] List of future strategies:
[08:28:27.246] 1. sequential:
[08:28:27.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.246]    - tweaked: FALSE
[08:28:27.246]    - call: NULL
[08:28:27.247] plan(): nbrOfWorkers() = 1
[08:28:27.249] plan(): Setting new future strategy stack:
[08:28:27.249] List of future strategies:
[08:28:27.249] 1. multicore:
[08:28:27.249]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.249]    - tweaked: FALSE
[08:28:27.249]    - call: plan(multicore)
[08:28:27.253] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:27.253] result() for MulticoreFuture ...
[08:28:27.254] result() for MulticoreFuture ...
[08:28:27.255] result() for MulticoreFuture ... done
[08:28:27.255] result() for MulticoreFuture ... done
[08:28:27.255] result() for MulticoreFuture ...
[08:28:27.255] result() for MulticoreFuture ... done
[1] 0
*** multicore(..., globals = FALSE) with globals and blocking
 - Creating multicore future #1 ...
[08:28:27.257] getGlobalsAndPackages() ...
[08:28:27.258] Not searching for globals
[08:28:27.258] - globals: [0] <none>
[08:28:27.258] getGlobalsAndPackages() ... DONE
[08:28:27.258] Packages needed by the future expression (n = 0): <none>
[08:28:27.259] Packages needed by future strategies (n = 0): <none>
[08:28:27.259] {
[08:28:27.259]     {
[08:28:27.259]         {
[08:28:27.259]             ...future.startTime <- base::Sys.time()
[08:28:27.259]             {
[08:28:27.259]                 {
[08:28:27.259]                   {
[08:28:27.259]                     {
[08:28:27.259]                       base::local({
[08:28:27.259]                         has_future <- base::requireNamespace("future", 
[08:28:27.259]                           quietly = TRUE)
[08:28:27.259]                         if (has_future) {
[08:28:27.259]                           ns <- base::getNamespace("future")
[08:28:27.259]                           version <- ns[[".package"]][["version"]]
[08:28:27.259]                           if (is.null(version)) 
[08:28:27.259]                             version <- utils::packageVersion("future")
[08:28:27.259]                         }
[08:28:27.259]                         else {
[08:28:27.259]                           version <- NULL
[08:28:27.259]                         }
[08:28:27.259]                         if (!has_future || version < "1.8.0") {
[08:28:27.259]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.259]                             "", base::R.version$version.string), 
[08:28:27.259]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.259]                               "release", "version")], collapse = " "), 
[08:28:27.259]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.259]                             info)
[08:28:27.259]                           info <- base::paste(info, collapse = "; ")
[08:28:27.259]                           if (!has_future) {
[08:28:27.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.259]                               info)
[08:28:27.259]                           }
[08:28:27.259]                           else {
[08:28:27.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.259]                               info, version)
[08:28:27.259]                           }
[08:28:27.259]                           base::stop(msg)
[08:28:27.259]                         }
[08:28:27.259]                       })
[08:28:27.259]                     }
[08:28:27.259]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.259]                     base::options(mc.cores = 1L)
[08:28:27.259]                   }
[08:28:27.259]                   ...future.strategy.old <- future::plan("list")
[08:28:27.259]                   options(future.plan = NULL)
[08:28:27.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.259]                 }
[08:28:27.259]                 ...future.workdir <- getwd()
[08:28:27.259]             }
[08:28:27.259]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.259]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.259]         }
[08:28:27.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.259]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.259]             base::names(...future.oldOptions))
[08:28:27.259]     }
[08:28:27.259]     if (FALSE) {
[08:28:27.259]     }
[08:28:27.259]     else {
[08:28:27.259]         if (TRUE) {
[08:28:27.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.259]                 open = "w")
[08:28:27.259]         }
[08:28:27.259]         else {
[08:28:27.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.259]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.259]         }
[08:28:27.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.259]             base::sink(type = "output", split = FALSE)
[08:28:27.259]             base::close(...future.stdout)
[08:28:27.259]         }, add = TRUE)
[08:28:27.259]     }
[08:28:27.259]     ...future.frame <- base::sys.nframe()
[08:28:27.259]     ...future.conditions <- base::list()
[08:28:27.259]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.259]     if (FALSE) {
[08:28:27.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.259]     }
[08:28:27.259]     ...future.result <- base::tryCatch({
[08:28:27.259]         base::withCallingHandlers({
[08:28:27.259]             ...future.value <- base::withVisible(base::local({
[08:28:27.259]                 withCallingHandlers({
[08:28:27.259]                   {
[08:28:27.259]                     ii
[08:28:27.259]                   }
[08:28:27.259]                 }, immediateCondition = function(cond) {
[08:28:27.259]                   save_rds <- function (object, pathname, ...) 
[08:28:27.259]                   {
[08:28:27.259]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.259]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.259]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.259]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.259]                         fi_tmp[["mtime"]])
[08:28:27.259]                     }
[08:28:27.259]                     tryCatch({
[08:28:27.259]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.259]                     }, error = function(ex) {
[08:28:27.259]                       msg <- conditionMessage(ex)
[08:28:27.259]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.259]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.259]                         fi_tmp[["mtime"]], msg)
[08:28:27.259]                       ex$message <- msg
[08:28:27.259]                       stop(ex)
[08:28:27.259]                     })
[08:28:27.259]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.259]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.259]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.259]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.259]                       fi <- file.info(pathname)
[08:28:27.259]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.259]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.259]                         fi[["size"]], fi[["mtime"]])
[08:28:27.259]                       stop(msg)
[08:28:27.259]                     }
[08:28:27.259]                     invisible(pathname)
[08:28:27.259]                   }
[08:28:27.259]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.259]                     rootPath = tempdir()) 
[08:28:27.259]                   {
[08:28:27.259]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.259]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.259]                       tmpdir = path, fileext = ".rds")
[08:28:27.259]                     save_rds(obj, file)
[08:28:27.259]                   }
[08:28:27.259]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.259]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.259]                   {
[08:28:27.259]                     inherits <- base::inherits
[08:28:27.259]                     invokeRestart <- base::invokeRestart
[08:28:27.259]                     is.null <- base::is.null
[08:28:27.259]                     muffled <- FALSE
[08:28:27.259]                     if (inherits(cond, "message")) {
[08:28:27.259]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.259]                       if (muffled) 
[08:28:27.259]                         invokeRestart("muffleMessage")
[08:28:27.259]                     }
[08:28:27.259]                     else if (inherits(cond, "warning")) {
[08:28:27.259]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.259]                       if (muffled) 
[08:28:27.259]                         invokeRestart("muffleWarning")
[08:28:27.259]                     }
[08:28:27.259]                     else if (inherits(cond, "condition")) {
[08:28:27.259]                       if (!is.null(pattern)) {
[08:28:27.259]                         computeRestarts <- base::computeRestarts
[08:28:27.259]                         grepl <- base::grepl
[08:28:27.259]                         restarts <- computeRestarts(cond)
[08:28:27.259]                         for (restart in restarts) {
[08:28:27.259]                           name <- restart$name
[08:28:27.259]                           if (is.null(name)) 
[08:28:27.259]                             next
[08:28:27.259]                           if (!grepl(pattern, name)) 
[08:28:27.259]                             next
[08:28:27.259]                           invokeRestart(restart)
[08:28:27.259]                           muffled <- TRUE
[08:28:27.259]                           break
[08:28:27.259]                         }
[08:28:27.259]                       }
[08:28:27.259]                     }
[08:28:27.259]                     invisible(muffled)
[08:28:27.259]                   }
[08:28:27.259]                   muffleCondition(cond)
[08:28:27.259]                 })
[08:28:27.259]             }))
[08:28:27.259]             future::FutureResult(value = ...future.value$value, 
[08:28:27.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.259]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.259]                     ...future.globalenv.names))
[08:28:27.259]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.259]         }, condition = base::local({
[08:28:27.259]             c <- base::c
[08:28:27.259]             inherits <- base::inherits
[08:28:27.259]             invokeRestart <- base::invokeRestart
[08:28:27.259]             length <- base::length
[08:28:27.259]             list <- base::list
[08:28:27.259]             seq.int <- base::seq.int
[08:28:27.259]             signalCondition <- base::signalCondition
[08:28:27.259]             sys.calls <- base::sys.calls
[08:28:27.259]             `[[` <- base::`[[`
[08:28:27.259]             `+` <- base::`+`
[08:28:27.259]             `<<-` <- base::`<<-`
[08:28:27.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.259]                   3L)]
[08:28:27.259]             }
[08:28:27.259]             function(cond) {
[08:28:27.259]                 is_error <- inherits(cond, "error")
[08:28:27.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.259]                   NULL)
[08:28:27.259]                 if (is_error) {
[08:28:27.259]                   sessionInformation <- function() {
[08:28:27.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.259]                       search = base::search(), system = base::Sys.info())
[08:28:27.259]                   }
[08:28:27.259]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.259]                     cond$call), session = sessionInformation(), 
[08:28:27.259]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.259]                   signalCondition(cond)
[08:28:27.259]                 }
[08:28:27.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.259]                 "immediateCondition"))) {
[08:28:27.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.259]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.259]                   if (TRUE && !signal) {
[08:28:27.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.259]                     {
[08:28:27.259]                       inherits <- base::inherits
[08:28:27.259]                       invokeRestart <- base::invokeRestart
[08:28:27.259]                       is.null <- base::is.null
[08:28:27.259]                       muffled <- FALSE
[08:28:27.259]                       if (inherits(cond, "message")) {
[08:28:27.259]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.259]                         if (muffled) 
[08:28:27.259]                           invokeRestart("muffleMessage")
[08:28:27.259]                       }
[08:28:27.259]                       else if (inherits(cond, "warning")) {
[08:28:27.259]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.259]                         if (muffled) 
[08:28:27.259]                           invokeRestart("muffleWarning")
[08:28:27.259]                       }
[08:28:27.259]                       else if (inherits(cond, "condition")) {
[08:28:27.259]                         if (!is.null(pattern)) {
[08:28:27.259]                           computeRestarts <- base::computeRestarts
[08:28:27.259]                           grepl <- base::grepl
[08:28:27.259]                           restarts <- computeRestarts(cond)
[08:28:27.259]                           for (restart in restarts) {
[08:28:27.259]                             name <- restart$name
[08:28:27.259]                             if (is.null(name)) 
[08:28:27.259]                               next
[08:28:27.259]                             if (!grepl(pattern, name)) 
[08:28:27.259]                               next
[08:28:27.259]                             invokeRestart(restart)
[08:28:27.259]                             muffled <- TRUE
[08:28:27.259]                             break
[08:28:27.259]                           }
[08:28:27.259]                         }
[08:28:27.259]                       }
[08:28:27.259]                       invisible(muffled)
[08:28:27.259]                     }
[08:28:27.259]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.259]                   }
[08:28:27.259]                 }
[08:28:27.259]                 else {
[08:28:27.259]                   if (TRUE) {
[08:28:27.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.259]                     {
[08:28:27.259]                       inherits <- base::inherits
[08:28:27.259]                       invokeRestart <- base::invokeRestart
[08:28:27.259]                       is.null <- base::is.null
[08:28:27.259]                       muffled <- FALSE
[08:28:27.259]                       if (inherits(cond, "message")) {
[08:28:27.259]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.259]                         if (muffled) 
[08:28:27.259]                           invokeRestart("muffleMessage")
[08:28:27.259]                       }
[08:28:27.259]                       else if (inherits(cond, "warning")) {
[08:28:27.259]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.259]                         if (muffled) 
[08:28:27.259]                           invokeRestart("muffleWarning")
[08:28:27.259]                       }
[08:28:27.259]                       else if (inherits(cond, "condition")) {
[08:28:27.259]                         if (!is.null(pattern)) {
[08:28:27.259]                           computeRestarts <- base::computeRestarts
[08:28:27.259]                           grepl <- base::grepl
[08:28:27.259]                           restarts <- computeRestarts(cond)
[08:28:27.259]                           for (restart in restarts) {
[08:28:27.259]                             name <- restart$name
[08:28:27.259]                             if (is.null(name)) 
[08:28:27.259]                               next
[08:28:27.259]                             if (!grepl(pattern, name)) 
[08:28:27.259]                               next
[08:28:27.259]                             invokeRestart(restart)
[08:28:27.259]                             muffled <- TRUE
[08:28:27.259]                             break
[08:28:27.259]                           }
[08:28:27.259]                         }
[08:28:27.259]                       }
[08:28:27.259]                       invisible(muffled)
[08:28:27.259]                     }
[08:28:27.259]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.259]                   }
[08:28:27.259]                 }
[08:28:27.259]             }
[08:28:27.259]         }))
[08:28:27.259]     }, error = function(ex) {
[08:28:27.259]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.259]                 ...future.rng), started = ...future.startTime, 
[08:28:27.259]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.259]             version = "1.8"), class = "FutureResult")
[08:28:27.259]     }, finally = {
[08:28:27.259]         if (!identical(...future.workdir, getwd())) 
[08:28:27.259]             setwd(...future.workdir)
[08:28:27.259]         {
[08:28:27.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.259]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.259]             }
[08:28:27.259]             base::options(...future.oldOptions)
[08:28:27.259]             if (.Platform$OS.type == "windows") {
[08:28:27.259]                 old_names <- names(...future.oldEnvVars)
[08:28:27.259]                 envs <- base::Sys.getenv()
[08:28:27.259]                 names <- names(envs)
[08:28:27.259]                 common <- intersect(names, old_names)
[08:28:27.259]                 added <- setdiff(names, old_names)
[08:28:27.259]                 removed <- setdiff(old_names, names)
[08:28:27.259]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.259]                   envs[common]]
[08:28:27.259]                 NAMES <- toupper(changed)
[08:28:27.259]                 args <- list()
[08:28:27.259]                 for (kk in seq_along(NAMES)) {
[08:28:27.259]                   name <- changed[[kk]]
[08:28:27.259]                   NAME <- NAMES[[kk]]
[08:28:27.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.259]                     next
[08:28:27.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.259]                 }
[08:28:27.259]                 NAMES <- toupper(added)
[08:28:27.259]                 for (kk in seq_along(NAMES)) {
[08:28:27.259]                   name <- added[[kk]]
[08:28:27.259]                   NAME <- NAMES[[kk]]
[08:28:27.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.259]                     next
[08:28:27.259]                   args[[name]] <- ""
[08:28:27.259]                 }
[08:28:27.259]                 NAMES <- toupper(removed)
[08:28:27.259]                 for (kk in seq_along(NAMES)) {
[08:28:27.259]                   name <- removed[[kk]]
[08:28:27.259]                   NAME <- NAMES[[kk]]
[08:28:27.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.259]                     next
[08:28:27.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.259]                 }
[08:28:27.259]                 if (length(args) > 0) 
[08:28:27.259]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.259]             }
[08:28:27.259]             else {
[08:28:27.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.259]             }
[08:28:27.259]             {
[08:28:27.259]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.259]                   0L) {
[08:28:27.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.259]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.259]                   base::options(opts)
[08:28:27.259]                 }
[08:28:27.259]                 {
[08:28:27.259]                   {
[08:28:27.259]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.259]                     NULL
[08:28:27.259]                   }
[08:28:27.259]                   options(future.plan = NULL)
[08:28:27.259]                   if (is.na(NA_character_)) 
[08:28:27.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.259]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.259]                     .init = FALSE)
[08:28:27.259]                 }
[08:28:27.259]             }
[08:28:27.259]         }
[08:28:27.259]     })
[08:28:27.259]     if (TRUE) {
[08:28:27.259]         base::sink(type = "output", split = FALSE)
[08:28:27.259]         if (TRUE) {
[08:28:27.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.259]         }
[08:28:27.259]         else {
[08:28:27.259]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.259]         }
[08:28:27.259]         base::close(...future.stdout)
[08:28:27.259]         ...future.stdout <- NULL
[08:28:27.259]     }
[08:28:27.259]     ...future.result$conditions <- ...future.conditions
[08:28:27.259]     ...future.result$finished <- base::Sys.time()
[08:28:27.259]     ...future.result
[08:28:27.259] }
[08:28:27.262] requestCore(): workers = 2
[08:28:27.264] MulticoreFuture started
 - Creating multicore future #2 ...
[08:28:27.265] plan(): Setting new future strategy stack:
[08:28:27.265] List of future strategies:
[08:28:27.265] 1. sequential:
[08:28:27.265]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.265]    - tweaked: FALSE
[08:28:27.265]    - call: NULL
[08:28:27.266] plan(): nbrOfWorkers() = 1
[08:28:27.268] plan(): Setting new future strategy stack:
[08:28:27.268] getGlobalsAndPackages() ...
[08:28:27.269] Not searching for globals
[08:28:27.268] List of future strategies:
[08:28:27.268] 1. multicore:
[08:28:27.268]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.268]    - tweaked: FALSE
[08:28:27.268]    - call: plan(multicore)
[08:28:27.269] - globals: [0] <none>
[08:28:27.269] getGlobalsAndPackages() ... DONE
[08:28:27.270] Packages needed by the future expression (n = 0): <none>
[08:28:27.270] Packages needed by future strategies (n = 0): <none>
[08:28:27.271] plan(): nbrOfWorkers() = 2
[08:28:27.271] {
[08:28:27.271]     {
[08:28:27.271]         {
[08:28:27.271]             ...future.startTime <- base::Sys.time()
[08:28:27.271]             {
[08:28:27.271]                 {
[08:28:27.271]                   {
[08:28:27.271]                     {
[08:28:27.271]                       base::local({
[08:28:27.271]                         has_future <- base::requireNamespace("future", 
[08:28:27.271]                           quietly = TRUE)
[08:28:27.271]                         if (has_future) {
[08:28:27.271]                           ns <- base::getNamespace("future")
[08:28:27.271]                           version <- ns[[".package"]][["version"]]
[08:28:27.271]                           if (is.null(version)) 
[08:28:27.271]                             version <- utils::packageVersion("future")
[08:28:27.271]                         }
[08:28:27.271]                         else {
[08:28:27.271]                           version <- NULL
[08:28:27.271]                         }
[08:28:27.271]                         if (!has_future || version < "1.8.0") {
[08:28:27.271]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.271]                             "", base::R.version$version.string), 
[08:28:27.271]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.271]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.271]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.271]                               "release", "version")], collapse = " "), 
[08:28:27.271]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.271]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.271]                             info)
[08:28:27.271]                           info <- base::paste(info, collapse = "; ")
[08:28:27.271]                           if (!has_future) {
[08:28:27.271]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.271]                               info)
[08:28:27.271]                           }
[08:28:27.271]                           else {
[08:28:27.271]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.271]                               info, version)
[08:28:27.271]                           }
[08:28:27.271]                           base::stop(msg)
[08:28:27.271]                         }
[08:28:27.271]                       })
[08:28:27.271]                     }
[08:28:27.271]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.271]                     base::options(mc.cores = 1L)
[08:28:27.271]                   }
[08:28:27.271]                   ...future.strategy.old <- future::plan("list")
[08:28:27.271]                   options(future.plan = NULL)
[08:28:27.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.271]                 }
[08:28:27.271]                 ...future.workdir <- getwd()
[08:28:27.271]             }
[08:28:27.271]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.271]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.271]         }
[08:28:27.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.271]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.271]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.271]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.271]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.271]             base::names(...future.oldOptions))
[08:28:27.271]     }
[08:28:27.271]     if (FALSE) {
[08:28:27.271]     }
[08:28:27.271]     else {
[08:28:27.271]         if (TRUE) {
[08:28:27.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.271]                 open = "w")
[08:28:27.271]         }
[08:28:27.271]         else {
[08:28:27.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.271]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.271]         }
[08:28:27.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.271]             base::sink(type = "output", split = FALSE)
[08:28:27.271]             base::close(...future.stdout)
[08:28:27.271]         }, add = TRUE)
[08:28:27.271]     }
[08:28:27.271]     ...future.frame <- base::sys.nframe()
[08:28:27.271]     ...future.conditions <- base::list()
[08:28:27.271]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.271]     if (FALSE) {
[08:28:27.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.271]     }
[08:28:27.271]     ...future.result <- base::tryCatch({
[08:28:27.271]         base::withCallingHandlers({
[08:28:27.271]             ...future.value <- base::withVisible(base::local({
[08:28:27.271]                 withCallingHandlers({
[08:28:27.271]                   {
[08:28:27.271]                     ii
[08:28:27.271]                   }
[08:28:27.271]                 }, immediateCondition = function(cond) {
[08:28:27.271]                   save_rds <- function (object, pathname, ...) 
[08:28:27.271]                   {
[08:28:27.271]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.271]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.271]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.271]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.271]                         fi_tmp[["mtime"]])
[08:28:27.271]                     }
[08:28:27.271]                     tryCatch({
[08:28:27.271]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.271]                     }, error = function(ex) {
[08:28:27.271]                       msg <- conditionMessage(ex)
[08:28:27.271]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.271]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.271]                         fi_tmp[["mtime"]], msg)
[08:28:27.271]                       ex$message <- msg
[08:28:27.271]                       stop(ex)
[08:28:27.271]                     })
[08:28:27.271]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.271]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.271]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.271]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.271]                       fi <- file.info(pathname)
[08:28:27.271]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.271]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.271]                         fi[["size"]], fi[["mtime"]])
[08:28:27.271]                       stop(msg)
[08:28:27.271]                     }
[08:28:27.271]                     invisible(pathname)
[08:28:27.271]                   }
[08:28:27.271]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.271]                     rootPath = tempdir()) 
[08:28:27.271]                   {
[08:28:27.271]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.271]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.271]                       tmpdir = path, fileext = ".rds")
[08:28:27.271]                     save_rds(obj, file)
[08:28:27.271]                   }
[08:28:27.271]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.271]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.271]                   {
[08:28:27.271]                     inherits <- base::inherits
[08:28:27.271]                     invokeRestart <- base::invokeRestart
[08:28:27.271]                     is.null <- base::is.null
[08:28:27.271]                     muffled <- FALSE
[08:28:27.271]                     if (inherits(cond, "message")) {
[08:28:27.271]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.271]                       if (muffled) 
[08:28:27.271]                         invokeRestart("muffleMessage")
[08:28:27.271]                     }
[08:28:27.271]                     else if (inherits(cond, "warning")) {
[08:28:27.271]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.271]                       if (muffled) 
[08:28:27.271]                         invokeRestart("muffleWarning")
[08:28:27.271]                     }
[08:28:27.271]                     else if (inherits(cond, "condition")) {
[08:28:27.271]                       if (!is.null(pattern)) {
[08:28:27.271]                         computeRestarts <- base::computeRestarts
[08:28:27.271]                         grepl <- base::grepl
[08:28:27.271]                         restarts <- computeRestarts(cond)
[08:28:27.271]                         for (restart in restarts) {
[08:28:27.271]                           name <- restart$name
[08:28:27.271]                           if (is.null(name)) 
[08:28:27.271]                             next
[08:28:27.271]                           if (!grepl(pattern, name)) 
[08:28:27.271]                             next
[08:28:27.271]                           invokeRestart(restart)
[08:28:27.271]                           muffled <- TRUE
[08:28:27.271]                           break
[08:28:27.271]                         }
[08:28:27.271]                       }
[08:28:27.271]                     }
[08:28:27.271]                     invisible(muffled)
[08:28:27.271]                   }
[08:28:27.271]                   muffleCondition(cond)
[08:28:27.271]                 })
[08:28:27.271]             }))
[08:28:27.271]             future::FutureResult(value = ...future.value$value, 
[08:28:27.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.271]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.271]                     ...future.globalenv.names))
[08:28:27.271]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.271]         }, condition = base::local({
[08:28:27.271]             c <- base::c
[08:28:27.271]             inherits <- base::inherits
[08:28:27.271]             invokeRestart <- base::invokeRestart
[08:28:27.271]             length <- base::length
[08:28:27.271]             list <- base::list
[08:28:27.271]             seq.int <- base::seq.int
[08:28:27.271]             signalCondition <- base::signalCondition
[08:28:27.271]             sys.calls <- base::sys.calls
[08:28:27.271]             `[[` <- base::`[[`
[08:28:27.271]             `+` <- base::`+`
[08:28:27.271]             `<<-` <- base::`<<-`
[08:28:27.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.271]                   3L)]
[08:28:27.271]             }
[08:28:27.271]             function(cond) {
[08:28:27.271]                 is_error <- inherits(cond, "error")
[08:28:27.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.271]                   NULL)
[08:28:27.271]                 if (is_error) {
[08:28:27.271]                   sessionInformation <- function() {
[08:28:27.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.271]                       search = base::search(), system = base::Sys.info())
[08:28:27.271]                   }
[08:28:27.271]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.271]                     cond$call), session = sessionInformation(), 
[08:28:27.271]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.271]                   signalCondition(cond)
[08:28:27.271]                 }
[08:28:27.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.271]                 "immediateCondition"))) {
[08:28:27.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.271]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.271]                   if (TRUE && !signal) {
[08:28:27.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.271]                     {
[08:28:27.271]                       inherits <- base::inherits
[08:28:27.271]                       invokeRestart <- base::invokeRestart
[08:28:27.271]                       is.null <- base::is.null
[08:28:27.271]                       muffled <- FALSE
[08:28:27.271]                       if (inherits(cond, "message")) {
[08:28:27.271]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.271]                         if (muffled) 
[08:28:27.271]                           invokeRestart("muffleMessage")
[08:28:27.271]                       }
[08:28:27.271]                       else if (inherits(cond, "warning")) {
[08:28:27.271]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.271]                         if (muffled) 
[08:28:27.271]                           invokeRestart("muffleWarning")
[08:28:27.271]                       }
[08:28:27.271]                       else if (inherits(cond, "condition")) {
[08:28:27.271]                         if (!is.null(pattern)) {
[08:28:27.271]                           computeRestarts <- base::computeRestarts
[08:28:27.271]                           grepl <- base::grepl
[08:28:27.271]                           restarts <- computeRestarts(cond)
[08:28:27.271]                           for (restart in restarts) {
[08:28:27.271]                             name <- restart$name
[08:28:27.271]                             if (is.null(name)) 
[08:28:27.271]                               next
[08:28:27.271]                             if (!grepl(pattern, name)) 
[08:28:27.271]                               next
[08:28:27.271]                             invokeRestart(restart)
[08:28:27.271]                             muffled <- TRUE
[08:28:27.271]                             break
[08:28:27.271]                           }
[08:28:27.271]                         }
[08:28:27.271]                       }
[08:28:27.271]                       invisible(muffled)
[08:28:27.271]                     }
[08:28:27.271]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.271]                   }
[08:28:27.271]                 }
[08:28:27.271]                 else {
[08:28:27.271]                   if (TRUE) {
[08:28:27.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.271]                     {
[08:28:27.271]                       inherits <- base::inherits
[08:28:27.271]                       invokeRestart <- base::invokeRestart
[08:28:27.271]                       is.null <- base::is.null
[08:28:27.271]                       muffled <- FALSE
[08:28:27.271]                       if (inherits(cond, "message")) {
[08:28:27.271]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.271]                         if (muffled) 
[08:28:27.271]                           invokeRestart("muffleMessage")
[08:28:27.271]                       }
[08:28:27.271]                       else if (inherits(cond, "warning")) {
[08:28:27.271]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.271]                         if (muffled) 
[08:28:27.271]                           invokeRestart("muffleWarning")
[08:28:27.271]                       }
[08:28:27.271]                       else if (inherits(cond, "condition")) {
[08:28:27.271]                         if (!is.null(pattern)) {
[08:28:27.271]                           computeRestarts <- base::computeRestarts
[08:28:27.271]                           grepl <- base::grepl
[08:28:27.271]                           restarts <- computeRestarts(cond)
[08:28:27.271]                           for (restart in restarts) {
[08:28:27.271]                             name <- restart$name
[08:28:27.271]                             if (is.null(name)) 
[08:28:27.271]                               next
[08:28:27.271]                             if (!grepl(pattern, name)) 
[08:28:27.271]                               next
[08:28:27.271]                             invokeRestart(restart)
[08:28:27.271]                             muffled <- TRUE
[08:28:27.271]                             break
[08:28:27.271]                           }
[08:28:27.271]                         }
[08:28:27.271]                       }
[08:28:27.271]                       invisible(muffled)
[08:28:27.271]                     }
[08:28:27.271]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.271]                   }
[08:28:27.271]                 }
[08:28:27.271]             }
[08:28:27.271]         }))
[08:28:27.271]     }, error = function(ex) {
[08:28:27.271]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.271]                 ...future.rng), started = ...future.startTime, 
[08:28:27.271]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.271]             version = "1.8"), class = "FutureResult")
[08:28:27.271]     }, finally = {
[08:28:27.271]         if (!identical(...future.workdir, getwd())) 
[08:28:27.271]             setwd(...future.workdir)
[08:28:27.271]         {
[08:28:27.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.271]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.271]             }
[08:28:27.271]             base::options(...future.oldOptions)
[08:28:27.271]             if (.Platform$OS.type == "windows") {
[08:28:27.271]                 old_names <- names(...future.oldEnvVars)
[08:28:27.271]                 envs <- base::Sys.getenv()
[08:28:27.271]                 names <- names(envs)
[08:28:27.271]                 common <- intersect(names, old_names)
[08:28:27.271]                 added <- setdiff(names, old_names)
[08:28:27.271]                 removed <- setdiff(old_names, names)
[08:28:27.271]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.271]                   envs[common]]
[08:28:27.271]                 NAMES <- toupper(changed)
[08:28:27.271]                 args <- list()
[08:28:27.271]                 for (kk in seq_along(NAMES)) {
[08:28:27.271]                   name <- changed[[kk]]
[08:28:27.271]                   NAME <- NAMES[[kk]]
[08:28:27.271]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.271]                     next
[08:28:27.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.271]                 }
[08:28:27.271]                 NAMES <- toupper(added)
[08:28:27.271]                 for (kk in seq_along(NAMES)) {
[08:28:27.271]                   name <- added[[kk]]
[08:28:27.271]                   NAME <- NAMES[[kk]]
[08:28:27.271]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.271]                     next
[08:28:27.271]                   args[[name]] <- ""
[08:28:27.271]                 }
[08:28:27.271]                 NAMES <- toupper(removed)
[08:28:27.271]                 for (kk in seq_along(NAMES)) {
[08:28:27.271]                   name <- removed[[kk]]
[08:28:27.271]                   NAME <- NAMES[[kk]]
[08:28:27.271]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.271]                     next
[08:28:27.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.271]                 }
[08:28:27.271]                 if (length(args) > 0) 
[08:28:27.271]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.271]             }
[08:28:27.271]             else {
[08:28:27.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.271]             }
[08:28:27.271]             {
[08:28:27.271]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.271]                   0L) {
[08:28:27.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.271]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.271]                   base::options(opts)
[08:28:27.271]                 }
[08:28:27.271]                 {
[08:28:27.271]                   {
[08:28:27.271]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.271]                     NULL
[08:28:27.271]                   }
[08:28:27.271]                   options(future.plan = NULL)
[08:28:27.271]                   if (is.na(NA_character_)) 
[08:28:27.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.271]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.271]                     .init = FALSE)
[08:28:27.271]                 }
[08:28:27.271]             }
[08:28:27.271]         }
[08:28:27.271]     })
[08:28:27.271]     if (TRUE) {
[08:28:27.271]         base::sink(type = "output", split = FALSE)
[08:28:27.271]         if (TRUE) {
[08:28:27.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.271]         }
[08:28:27.271]         else {
[08:28:27.271]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.271]         }
[08:28:27.271]         base::close(...future.stdout)
[08:28:27.271]         ...future.stdout <- NULL
[08:28:27.271]     }
[08:28:27.271]     ...future.result$conditions <- ...future.conditions
[08:28:27.271]     ...future.result$finished <- base::Sys.time()
[08:28:27.271]     ...future.result
[08:28:27.271] }
[08:28:27.275] requestCore(): workers = 2
[08:28:27.277] MulticoreFuture started
 - Creating multicore future #3 ...
[08:28:27.278] plan(): Setting new future strategy stack:
[08:28:27.279] List of future strategies:
[08:28:27.279] 1. sequential:
[08:28:27.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.279]    - tweaked: FALSE
[08:28:27.279]    - call: NULL
[08:28:27.280] plan(): nbrOfWorkers() = 1
[08:28:27.281] plan(): Setting new future strategy stack:
[08:28:27.282] List of future strategies:
[08:28:27.282] 1. multicore:
[08:28:27.282]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.282]    - tweaked: FALSE
[08:28:27.282]    - call: plan(multicore)
[08:28:27.282] getGlobalsAndPackages() ...
[08:28:27.282] Not searching for globals
[08:28:27.283] - globals: [0] <none>
[08:28:27.283] getGlobalsAndPackages() ... DONE
[08:28:27.284] Packages needed by the future expression (n = 0): <none>
[08:28:27.284] Packages needed by future strategies (n = 0): <none>
[08:28:27.284] plan(): nbrOfWorkers() = 2
[08:28:27.285] {
[08:28:27.285]     {
[08:28:27.285]         {
[08:28:27.285]             ...future.startTime <- base::Sys.time()
[08:28:27.285]             {
[08:28:27.285]                 {
[08:28:27.285]                   {
[08:28:27.285]                     {
[08:28:27.285]                       base::local({
[08:28:27.285]                         has_future <- base::requireNamespace("future", 
[08:28:27.285]                           quietly = TRUE)
[08:28:27.285]                         if (has_future) {
[08:28:27.285]                           ns <- base::getNamespace("future")
[08:28:27.285]                           version <- ns[[".package"]][["version"]]
[08:28:27.285]                           if (is.null(version)) 
[08:28:27.285]                             version <- utils::packageVersion("future")
[08:28:27.285]                         }
[08:28:27.285]                         else {
[08:28:27.285]                           version <- NULL
[08:28:27.285]                         }
[08:28:27.285]                         if (!has_future || version < "1.8.0") {
[08:28:27.285]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.285]                             "", base::R.version$version.string), 
[08:28:27.285]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.285]                               "release", "version")], collapse = " "), 
[08:28:27.285]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.285]                             info)
[08:28:27.285]                           info <- base::paste(info, collapse = "; ")
[08:28:27.285]                           if (!has_future) {
[08:28:27.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.285]                               info)
[08:28:27.285]                           }
[08:28:27.285]                           else {
[08:28:27.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.285]                               info, version)
[08:28:27.285]                           }
[08:28:27.285]                           base::stop(msg)
[08:28:27.285]                         }
[08:28:27.285]                       })
[08:28:27.285]                     }
[08:28:27.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.285]                     base::options(mc.cores = 1L)
[08:28:27.285]                   }
[08:28:27.285]                   ...future.strategy.old <- future::plan("list")
[08:28:27.285]                   options(future.plan = NULL)
[08:28:27.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.285]                 }
[08:28:27.285]                 ...future.workdir <- getwd()
[08:28:27.285]             }
[08:28:27.285]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.285]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.285]         }
[08:28:27.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.285]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.285]             base::names(...future.oldOptions))
[08:28:27.285]     }
[08:28:27.285]     if (FALSE) {
[08:28:27.285]     }
[08:28:27.285]     else {
[08:28:27.285]         if (TRUE) {
[08:28:27.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.285]                 open = "w")
[08:28:27.285]         }
[08:28:27.285]         else {
[08:28:27.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.285]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.285]         }
[08:28:27.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.285]             base::sink(type = "output", split = FALSE)
[08:28:27.285]             base::close(...future.stdout)
[08:28:27.285]         }, add = TRUE)
[08:28:27.285]     }
[08:28:27.285]     ...future.frame <- base::sys.nframe()
[08:28:27.285]     ...future.conditions <- base::list()
[08:28:27.285]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.285]     if (FALSE) {
[08:28:27.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.285]     }
[08:28:27.285]     ...future.result <- base::tryCatch({
[08:28:27.285]         base::withCallingHandlers({
[08:28:27.285]             ...future.value <- base::withVisible(base::local({
[08:28:27.285]                 withCallingHandlers({
[08:28:27.285]                   {
[08:28:27.285]                     ii
[08:28:27.285]                   }
[08:28:27.285]                 }, immediateCondition = function(cond) {
[08:28:27.285]                   save_rds <- function (object, pathname, ...) 
[08:28:27.285]                   {
[08:28:27.285]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.285]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.285]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.285]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.285]                         fi_tmp[["mtime"]])
[08:28:27.285]                     }
[08:28:27.285]                     tryCatch({
[08:28:27.285]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.285]                     }, error = function(ex) {
[08:28:27.285]                       msg <- conditionMessage(ex)
[08:28:27.285]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.285]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.285]                         fi_tmp[["mtime"]], msg)
[08:28:27.285]                       ex$message <- msg
[08:28:27.285]                       stop(ex)
[08:28:27.285]                     })
[08:28:27.285]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.285]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.285]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.285]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.285]                       fi <- file.info(pathname)
[08:28:27.285]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.285]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.285]                         fi[["size"]], fi[["mtime"]])
[08:28:27.285]                       stop(msg)
[08:28:27.285]                     }
[08:28:27.285]                     invisible(pathname)
[08:28:27.285]                   }
[08:28:27.285]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.285]                     rootPath = tempdir()) 
[08:28:27.285]                   {
[08:28:27.285]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.285]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.285]                       tmpdir = path, fileext = ".rds")
[08:28:27.285]                     save_rds(obj, file)
[08:28:27.285]                   }
[08:28:27.285]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.285]                   {
[08:28:27.285]                     inherits <- base::inherits
[08:28:27.285]                     invokeRestart <- base::invokeRestart
[08:28:27.285]                     is.null <- base::is.null
[08:28:27.285]                     muffled <- FALSE
[08:28:27.285]                     if (inherits(cond, "message")) {
[08:28:27.285]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.285]                       if (muffled) 
[08:28:27.285]                         invokeRestart("muffleMessage")
[08:28:27.285]                     }
[08:28:27.285]                     else if (inherits(cond, "warning")) {
[08:28:27.285]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.285]                       if (muffled) 
[08:28:27.285]                         invokeRestart("muffleWarning")
[08:28:27.285]                     }
[08:28:27.285]                     else if (inherits(cond, "condition")) {
[08:28:27.285]                       if (!is.null(pattern)) {
[08:28:27.285]                         computeRestarts <- base::computeRestarts
[08:28:27.285]                         grepl <- base::grepl
[08:28:27.285]                         restarts <- computeRestarts(cond)
[08:28:27.285]                         for (restart in restarts) {
[08:28:27.285]                           name <- restart$name
[08:28:27.285]                           if (is.null(name)) 
[08:28:27.285]                             next
[08:28:27.285]                           if (!grepl(pattern, name)) 
[08:28:27.285]                             next
[08:28:27.285]                           invokeRestart(restart)
[08:28:27.285]                           muffled <- TRUE
[08:28:27.285]                           break
[08:28:27.285]                         }
[08:28:27.285]                       }
[08:28:27.285]                     }
[08:28:27.285]                     invisible(muffled)
[08:28:27.285]                   }
[08:28:27.285]                   muffleCondition(cond)
[08:28:27.285]                 })
[08:28:27.285]             }))
[08:28:27.285]             future::FutureResult(value = ...future.value$value, 
[08:28:27.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.285]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.285]                     ...future.globalenv.names))
[08:28:27.285]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.285]         }, condition = base::local({
[08:28:27.285]             c <- base::c
[08:28:27.285]             inherits <- base::inherits
[08:28:27.285]             invokeRestart <- base::invokeRestart
[08:28:27.285]             length <- base::length
[08:28:27.285]             list <- base::list
[08:28:27.285]             seq.int <- base::seq.int
[08:28:27.285]             signalCondition <- base::signalCondition
[08:28:27.285]             sys.calls <- base::sys.calls
[08:28:27.285]             `[[` <- base::`[[`
[08:28:27.285]             `+` <- base::`+`
[08:28:27.285]             `<<-` <- base::`<<-`
[08:28:27.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.285]                   3L)]
[08:28:27.285]             }
[08:28:27.285]             function(cond) {
[08:28:27.285]                 is_error <- inherits(cond, "error")
[08:28:27.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.285]                   NULL)
[08:28:27.285]                 if (is_error) {
[08:28:27.285]                   sessionInformation <- function() {
[08:28:27.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.285]                       search = base::search(), system = base::Sys.info())
[08:28:27.285]                   }
[08:28:27.285]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.285]                     cond$call), session = sessionInformation(), 
[08:28:27.285]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.285]                   signalCondition(cond)
[08:28:27.285]                 }
[08:28:27.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.285]                 "immediateCondition"))) {
[08:28:27.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.285]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.285]                   if (TRUE && !signal) {
[08:28:27.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.285]                     {
[08:28:27.285]                       inherits <- base::inherits
[08:28:27.285]                       invokeRestart <- base::invokeRestart
[08:28:27.285]                       is.null <- base::is.null
[08:28:27.285]                       muffled <- FALSE
[08:28:27.285]                       if (inherits(cond, "message")) {
[08:28:27.285]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.285]                         if (muffled) 
[08:28:27.285]                           invokeRestart("muffleMessage")
[08:28:27.285]                       }
[08:28:27.285]                       else if (inherits(cond, "warning")) {
[08:28:27.285]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.285]                         if (muffled) 
[08:28:27.285]                           invokeRestart("muffleWarning")
[08:28:27.285]                       }
[08:28:27.285]                       else if (inherits(cond, "condition")) {
[08:28:27.285]                         if (!is.null(pattern)) {
[08:28:27.285]                           computeRestarts <- base::computeRestarts
[08:28:27.285]                           grepl <- base::grepl
[08:28:27.285]                           restarts <- computeRestarts(cond)
[08:28:27.285]                           for (restart in restarts) {
[08:28:27.285]                             name <- restart$name
[08:28:27.285]                             if (is.null(name)) 
[08:28:27.285]                               next
[08:28:27.285]                             if (!grepl(pattern, name)) 
[08:28:27.285]                               next
[08:28:27.285]                             invokeRestart(restart)
[08:28:27.285]                             muffled <- TRUE
[08:28:27.285]                             break
[08:28:27.285]                           }
[08:28:27.285]                         }
[08:28:27.285]                       }
[08:28:27.285]                       invisible(muffled)
[08:28:27.285]                     }
[08:28:27.285]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.285]                   }
[08:28:27.285]                 }
[08:28:27.285]                 else {
[08:28:27.285]                   if (TRUE) {
[08:28:27.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.285]                     {
[08:28:27.285]                       inherits <- base::inherits
[08:28:27.285]                       invokeRestart <- base::invokeRestart
[08:28:27.285]                       is.null <- base::is.null
[08:28:27.285]                       muffled <- FALSE
[08:28:27.285]                       if (inherits(cond, "message")) {
[08:28:27.285]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.285]                         if (muffled) 
[08:28:27.285]                           invokeRestart("muffleMessage")
[08:28:27.285]                       }
[08:28:27.285]                       else if (inherits(cond, "warning")) {
[08:28:27.285]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.285]                         if (muffled) 
[08:28:27.285]                           invokeRestart("muffleWarning")
[08:28:27.285]                       }
[08:28:27.285]                       else if (inherits(cond, "condition")) {
[08:28:27.285]                         if (!is.null(pattern)) {
[08:28:27.285]                           computeRestarts <- base::computeRestarts
[08:28:27.285]                           grepl <- base::grepl
[08:28:27.285]                           restarts <- computeRestarts(cond)
[08:28:27.285]                           for (restart in restarts) {
[08:28:27.285]                             name <- restart$name
[08:28:27.285]                             if (is.null(name)) 
[08:28:27.285]                               next
[08:28:27.285]                             if (!grepl(pattern, name)) 
[08:28:27.285]                               next
[08:28:27.285]                             invokeRestart(restart)
[08:28:27.285]                             muffled <- TRUE
[08:28:27.285]                             break
[08:28:27.285]                           }
[08:28:27.285]                         }
[08:28:27.285]                       }
[08:28:27.285]                       invisible(muffled)
[08:28:27.285]                     }
[08:28:27.285]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.285]                   }
[08:28:27.285]                 }
[08:28:27.285]             }
[08:28:27.285]         }))
[08:28:27.285]     }, error = function(ex) {
[08:28:27.285]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.285]                 ...future.rng), started = ...future.startTime, 
[08:28:27.285]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.285]             version = "1.8"), class = "FutureResult")
[08:28:27.285]     }, finally = {
[08:28:27.285]         if (!identical(...future.workdir, getwd())) 
[08:28:27.285]             setwd(...future.workdir)
[08:28:27.285]         {
[08:28:27.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.285]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.285]             }
[08:28:27.285]             base::options(...future.oldOptions)
[08:28:27.285]             if (.Platform$OS.type == "windows") {
[08:28:27.285]                 old_names <- names(...future.oldEnvVars)
[08:28:27.285]                 envs <- base::Sys.getenv()
[08:28:27.285]                 names <- names(envs)
[08:28:27.285]                 common <- intersect(names, old_names)
[08:28:27.285]                 added <- setdiff(names, old_names)
[08:28:27.285]                 removed <- setdiff(old_names, names)
[08:28:27.285]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.285]                   envs[common]]
[08:28:27.285]                 NAMES <- toupper(changed)
[08:28:27.285]                 args <- list()
[08:28:27.285]                 for (kk in seq_along(NAMES)) {
[08:28:27.285]                   name <- changed[[kk]]
[08:28:27.285]                   NAME <- NAMES[[kk]]
[08:28:27.285]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.285]                     next
[08:28:27.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.285]                 }
[08:28:27.285]                 NAMES <- toupper(added)
[08:28:27.285]                 for (kk in seq_along(NAMES)) {
[08:28:27.285]                   name <- added[[kk]]
[08:28:27.285]                   NAME <- NAMES[[kk]]
[08:28:27.285]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.285]                     next
[08:28:27.285]                   args[[name]] <- ""
[08:28:27.285]                 }
[08:28:27.285]                 NAMES <- toupper(removed)
[08:28:27.285]                 for (kk in seq_along(NAMES)) {
[08:28:27.285]                   name <- removed[[kk]]
[08:28:27.285]                   NAME <- NAMES[[kk]]
[08:28:27.285]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.285]                     next
[08:28:27.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.285]                 }
[08:28:27.285]                 if (length(args) > 0) 
[08:28:27.285]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.285]             }
[08:28:27.285]             else {
[08:28:27.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.285]             }
[08:28:27.285]             {
[08:28:27.285]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.285]                   0L) {
[08:28:27.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.285]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.285]                   base::options(opts)
[08:28:27.285]                 }
[08:28:27.285]                 {
[08:28:27.285]                   {
[08:28:27.285]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.285]                     NULL
[08:28:27.285]                   }
[08:28:27.285]                   options(future.plan = NULL)
[08:28:27.285]                   if (is.na(NA_character_)) 
[08:28:27.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.285]                     .init = FALSE)
[08:28:27.285]                 }
[08:28:27.285]             }
[08:28:27.285]         }
[08:28:27.285]     })
[08:28:27.285]     if (TRUE) {
[08:28:27.285]         base::sink(type = "output", split = FALSE)
[08:28:27.285]         if (TRUE) {
[08:28:27.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.285]         }
[08:28:27.285]         else {
[08:28:27.285]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.285]         }
[08:28:27.285]         base::close(...future.stdout)
[08:28:27.285]         ...future.stdout <- NULL
[08:28:27.285]     }
[08:28:27.285]     ...future.result$conditions <- ...future.conditions
[08:28:27.285]     ...future.result$finished <- base::Sys.time()
[08:28:27.285]     ...future.result
[08:28:27.285] }
[08:28:27.289] requestCore(): workers = 2
[08:28:27.289] Poll #1 (0): usedCores() = 2, workers = 2
[08:28:27.300] result() for MulticoreFuture ...
[08:28:27.301] result() for MulticoreFuture ...
[08:28:27.302] result() for MulticoreFuture ... done
[08:28:27.302] result() for MulticoreFuture ... done
[08:28:27.302] result() for MulticoreFuture ...
[08:28:27.302] result() for MulticoreFuture ... done
[08:28:27.305] MulticoreFuture started
 - Creating multicore future #4 ...
[08:28:27.306] plan(): Setting new future strategy stack:
[08:28:27.306] List of future strategies:
[08:28:27.306] 1. sequential:
[08:28:27.306]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.306]    - tweaked: FALSE
[08:28:27.306]    - call: NULL
[08:28:27.307] plan(): nbrOfWorkers() = 1
[08:28:27.309] plan(): Setting new future strategy stack:
[08:28:27.309] List of future strategies:
[08:28:27.309] 1. multicore:
[08:28:27.309]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.309]    - tweaked: FALSE
[08:28:27.309]    - call: plan(multicore)
[08:28:27.310] getGlobalsAndPackages() ...
[08:28:27.310] Not searching for globals
[08:28:27.310] - globals: [0] <none>
[08:28:27.311] getGlobalsAndPackages() ... DONE
[08:28:27.312] Packages needed by the future expression (n = 0): <none>
[08:28:27.312] plan(): nbrOfWorkers() = 2
[08:28:27.312] Packages needed by future strategies (n = 0): <none>
[08:28:27.313] {
[08:28:27.313]     {
[08:28:27.313]         {
[08:28:27.313]             ...future.startTime <- base::Sys.time()
[08:28:27.313]             {
[08:28:27.313]                 {
[08:28:27.313]                   {
[08:28:27.313]                     {
[08:28:27.313]                       base::local({
[08:28:27.313]                         has_future <- base::requireNamespace("future", 
[08:28:27.313]                           quietly = TRUE)
[08:28:27.313]                         if (has_future) {
[08:28:27.313]                           ns <- base::getNamespace("future")
[08:28:27.313]                           version <- ns[[".package"]][["version"]]
[08:28:27.313]                           if (is.null(version)) 
[08:28:27.313]                             version <- utils::packageVersion("future")
[08:28:27.313]                         }
[08:28:27.313]                         else {
[08:28:27.313]                           version <- NULL
[08:28:27.313]                         }
[08:28:27.313]                         if (!has_future || version < "1.8.0") {
[08:28:27.313]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.313]                             "", base::R.version$version.string), 
[08:28:27.313]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.313]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.313]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.313]                               "release", "version")], collapse = " "), 
[08:28:27.313]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.313]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.313]                             info)
[08:28:27.313]                           info <- base::paste(info, collapse = "; ")
[08:28:27.313]                           if (!has_future) {
[08:28:27.313]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.313]                               info)
[08:28:27.313]                           }
[08:28:27.313]                           else {
[08:28:27.313]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.313]                               info, version)
[08:28:27.313]                           }
[08:28:27.313]                           base::stop(msg)
[08:28:27.313]                         }
[08:28:27.313]                       })
[08:28:27.313]                     }
[08:28:27.313]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.313]                     base::options(mc.cores = 1L)
[08:28:27.313]                   }
[08:28:27.313]                   ...future.strategy.old <- future::plan("list")
[08:28:27.313]                   options(future.plan = NULL)
[08:28:27.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.313]                 }
[08:28:27.313]                 ...future.workdir <- getwd()
[08:28:27.313]             }
[08:28:27.313]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.313]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.313]         }
[08:28:27.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.313]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.313]             base::names(...future.oldOptions))
[08:28:27.313]     }
[08:28:27.313]     if (FALSE) {
[08:28:27.313]     }
[08:28:27.313]     else {
[08:28:27.313]         if (TRUE) {
[08:28:27.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.313]                 open = "w")
[08:28:27.313]         }
[08:28:27.313]         else {
[08:28:27.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.313]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.313]         }
[08:28:27.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.313]             base::sink(type = "output", split = FALSE)
[08:28:27.313]             base::close(...future.stdout)
[08:28:27.313]         }, add = TRUE)
[08:28:27.313]     }
[08:28:27.313]     ...future.frame <- base::sys.nframe()
[08:28:27.313]     ...future.conditions <- base::list()
[08:28:27.313]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.313]     if (FALSE) {
[08:28:27.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.313]     }
[08:28:27.313]     ...future.result <- base::tryCatch({
[08:28:27.313]         base::withCallingHandlers({
[08:28:27.313]             ...future.value <- base::withVisible(base::local({
[08:28:27.313]                 withCallingHandlers({
[08:28:27.313]                   {
[08:28:27.313]                     ii
[08:28:27.313]                   }
[08:28:27.313]                 }, immediateCondition = function(cond) {
[08:28:27.313]                   save_rds <- function (object, pathname, ...) 
[08:28:27.313]                   {
[08:28:27.313]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.313]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.313]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.313]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.313]                         fi_tmp[["mtime"]])
[08:28:27.313]                     }
[08:28:27.313]                     tryCatch({
[08:28:27.313]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.313]                     }, error = function(ex) {
[08:28:27.313]                       msg <- conditionMessage(ex)
[08:28:27.313]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.313]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.313]                         fi_tmp[["mtime"]], msg)
[08:28:27.313]                       ex$message <- msg
[08:28:27.313]                       stop(ex)
[08:28:27.313]                     })
[08:28:27.313]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.313]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.313]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.313]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.313]                       fi <- file.info(pathname)
[08:28:27.313]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.313]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.313]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.313]                         fi[["size"]], fi[["mtime"]])
[08:28:27.313]                       stop(msg)
[08:28:27.313]                     }
[08:28:27.313]                     invisible(pathname)
[08:28:27.313]                   }
[08:28:27.313]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.313]                     rootPath = tempdir()) 
[08:28:27.313]                   {
[08:28:27.313]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.313]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.313]                       tmpdir = path, fileext = ".rds")
[08:28:27.313]                     save_rds(obj, file)
[08:28:27.313]                   }
[08:28:27.313]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.313]                   {
[08:28:27.313]                     inherits <- base::inherits
[08:28:27.313]                     invokeRestart <- base::invokeRestart
[08:28:27.313]                     is.null <- base::is.null
[08:28:27.313]                     muffled <- FALSE
[08:28:27.313]                     if (inherits(cond, "message")) {
[08:28:27.313]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.313]                       if (muffled) 
[08:28:27.313]                         invokeRestart("muffleMessage")
[08:28:27.313]                     }
[08:28:27.313]                     else if (inherits(cond, "warning")) {
[08:28:27.313]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.313]                       if (muffled) 
[08:28:27.313]                         invokeRestart("muffleWarning")
[08:28:27.313]                     }
[08:28:27.313]                     else if (inherits(cond, "condition")) {
[08:28:27.313]                       if (!is.null(pattern)) {
[08:28:27.313]                         computeRestarts <- base::computeRestarts
[08:28:27.313]                         grepl <- base::grepl
[08:28:27.313]                         restarts <- computeRestarts(cond)
[08:28:27.313]                         for (restart in restarts) {
[08:28:27.313]                           name <- restart$name
[08:28:27.313]                           if (is.null(name)) 
[08:28:27.313]                             next
[08:28:27.313]                           if (!grepl(pattern, name)) 
[08:28:27.313]                             next
[08:28:27.313]                           invokeRestart(restart)
[08:28:27.313]                           muffled <- TRUE
[08:28:27.313]                           break
[08:28:27.313]                         }
[08:28:27.313]                       }
[08:28:27.313]                     }
[08:28:27.313]                     invisible(muffled)
[08:28:27.313]                   }
[08:28:27.313]                   muffleCondition(cond)
[08:28:27.313]                 })
[08:28:27.313]             }))
[08:28:27.313]             future::FutureResult(value = ...future.value$value, 
[08:28:27.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.313]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.313]                     ...future.globalenv.names))
[08:28:27.313]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.313]         }, condition = base::local({
[08:28:27.313]             c <- base::c
[08:28:27.313]             inherits <- base::inherits
[08:28:27.313]             invokeRestart <- base::invokeRestart
[08:28:27.313]             length <- base::length
[08:28:27.313]             list <- base::list
[08:28:27.313]             seq.int <- base::seq.int
[08:28:27.313]             signalCondition <- base::signalCondition
[08:28:27.313]             sys.calls <- base::sys.calls
[08:28:27.313]             `[[` <- base::`[[`
[08:28:27.313]             `+` <- base::`+`
[08:28:27.313]             `<<-` <- base::`<<-`
[08:28:27.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.313]                   3L)]
[08:28:27.313]             }
[08:28:27.313]             function(cond) {
[08:28:27.313]                 is_error <- inherits(cond, "error")
[08:28:27.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.313]                   NULL)
[08:28:27.313]                 if (is_error) {
[08:28:27.313]                   sessionInformation <- function() {
[08:28:27.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.313]                       search = base::search(), system = base::Sys.info())
[08:28:27.313]                   }
[08:28:27.313]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.313]                     cond$call), session = sessionInformation(), 
[08:28:27.313]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.313]                   signalCondition(cond)
[08:28:27.313]                 }
[08:28:27.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.313]                 "immediateCondition"))) {
[08:28:27.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.313]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.313]                   if (TRUE && !signal) {
[08:28:27.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.313]                     {
[08:28:27.313]                       inherits <- base::inherits
[08:28:27.313]                       invokeRestart <- base::invokeRestart
[08:28:27.313]                       is.null <- base::is.null
[08:28:27.313]                       muffled <- FALSE
[08:28:27.313]                       if (inherits(cond, "message")) {
[08:28:27.313]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.313]                         if (muffled) 
[08:28:27.313]                           invokeRestart("muffleMessage")
[08:28:27.313]                       }
[08:28:27.313]                       else if (inherits(cond, "warning")) {
[08:28:27.313]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.313]                         if (muffled) 
[08:28:27.313]                           invokeRestart("muffleWarning")
[08:28:27.313]                       }
[08:28:27.313]                       else if (inherits(cond, "condition")) {
[08:28:27.313]                         if (!is.null(pattern)) {
[08:28:27.313]                           computeRestarts <- base::computeRestarts
[08:28:27.313]                           grepl <- base::grepl
[08:28:27.313]                           restarts <- computeRestarts(cond)
[08:28:27.313]                           for (restart in restarts) {
[08:28:27.313]                             name <- restart$name
[08:28:27.313]                             if (is.null(name)) 
[08:28:27.313]                               next
[08:28:27.313]                             if (!grepl(pattern, name)) 
[08:28:27.313]                               next
[08:28:27.313]                             invokeRestart(restart)
[08:28:27.313]                             muffled <- TRUE
[08:28:27.313]                             break
[08:28:27.313]                           }
[08:28:27.313]                         }
[08:28:27.313]                       }
[08:28:27.313]                       invisible(muffled)
[08:28:27.313]                     }
[08:28:27.313]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.313]                   }
[08:28:27.313]                 }
[08:28:27.313]                 else {
[08:28:27.313]                   if (TRUE) {
[08:28:27.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.313]                     {
[08:28:27.313]                       inherits <- base::inherits
[08:28:27.313]                       invokeRestart <- base::invokeRestart
[08:28:27.313]                       is.null <- base::is.null
[08:28:27.313]                       muffled <- FALSE
[08:28:27.313]                       if (inherits(cond, "message")) {
[08:28:27.313]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.313]                         if (muffled) 
[08:28:27.313]                           invokeRestart("muffleMessage")
[08:28:27.313]                       }
[08:28:27.313]                       else if (inherits(cond, "warning")) {
[08:28:27.313]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.313]                         if (muffled) 
[08:28:27.313]                           invokeRestart("muffleWarning")
[08:28:27.313]                       }
[08:28:27.313]                       else if (inherits(cond, "condition")) {
[08:28:27.313]                         if (!is.null(pattern)) {
[08:28:27.313]                           computeRestarts <- base::computeRestarts
[08:28:27.313]                           grepl <- base::grepl
[08:28:27.313]                           restarts <- computeRestarts(cond)
[08:28:27.313]                           for (restart in restarts) {
[08:28:27.313]                             name <- restart$name
[08:28:27.313]                             if (is.null(name)) 
[08:28:27.313]                               next
[08:28:27.313]                             if (!grepl(pattern, name)) 
[08:28:27.313]                               next
[08:28:27.313]                             invokeRestart(restart)
[08:28:27.313]                             muffled <- TRUE
[08:28:27.313]                             break
[08:28:27.313]                           }
[08:28:27.313]                         }
[08:28:27.313]                       }
[08:28:27.313]                       invisible(muffled)
[08:28:27.313]                     }
[08:28:27.313]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.313]                   }
[08:28:27.313]                 }
[08:28:27.313]             }
[08:28:27.313]         }))
[08:28:27.313]     }, error = function(ex) {
[08:28:27.313]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.313]                 ...future.rng), started = ...future.startTime, 
[08:28:27.313]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.313]             version = "1.8"), class = "FutureResult")
[08:28:27.313]     }, finally = {
[08:28:27.313]         if (!identical(...future.workdir, getwd())) 
[08:28:27.313]             setwd(...future.workdir)
[08:28:27.313]         {
[08:28:27.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.313]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.313]             }
[08:28:27.313]             base::options(...future.oldOptions)
[08:28:27.313]             if (.Platform$OS.type == "windows") {
[08:28:27.313]                 old_names <- names(...future.oldEnvVars)
[08:28:27.313]                 envs <- base::Sys.getenv()
[08:28:27.313]                 names <- names(envs)
[08:28:27.313]                 common <- intersect(names, old_names)
[08:28:27.313]                 added <- setdiff(names, old_names)
[08:28:27.313]                 removed <- setdiff(old_names, names)
[08:28:27.313]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.313]                   envs[common]]
[08:28:27.313]                 NAMES <- toupper(changed)
[08:28:27.313]                 args <- list()
[08:28:27.313]                 for (kk in seq_along(NAMES)) {
[08:28:27.313]                   name <- changed[[kk]]
[08:28:27.313]                   NAME <- NAMES[[kk]]
[08:28:27.313]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.313]                     next
[08:28:27.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.313]                 }
[08:28:27.313]                 NAMES <- toupper(added)
[08:28:27.313]                 for (kk in seq_along(NAMES)) {
[08:28:27.313]                   name <- added[[kk]]
[08:28:27.313]                   NAME <- NAMES[[kk]]
[08:28:27.313]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.313]                     next
[08:28:27.313]                   args[[name]] <- ""
[08:28:27.313]                 }
[08:28:27.313]                 NAMES <- toupper(removed)
[08:28:27.313]                 for (kk in seq_along(NAMES)) {
[08:28:27.313]                   name <- removed[[kk]]
[08:28:27.313]                   NAME <- NAMES[[kk]]
[08:28:27.313]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.313]                     next
[08:28:27.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.313]                 }
[08:28:27.313]                 if (length(args) > 0) 
[08:28:27.313]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.313]             }
[08:28:27.313]             else {
[08:28:27.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.313]             }
[08:28:27.313]             {
[08:28:27.313]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.313]                   0L) {
[08:28:27.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.313]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.313]                   base::options(opts)
[08:28:27.313]                 }
[08:28:27.313]                 {
[08:28:27.313]                   {
[08:28:27.313]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.313]                     NULL
[08:28:27.313]                   }
[08:28:27.313]                   options(future.plan = NULL)
[08:28:27.313]                   if (is.na(NA_character_)) 
[08:28:27.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.313]                     .init = FALSE)
[08:28:27.313]                 }
[08:28:27.313]             }
[08:28:27.313]         }
[08:28:27.313]     })
[08:28:27.313]     if (TRUE) {
[08:28:27.313]         base::sink(type = "output", split = FALSE)
[08:28:27.313]         if (TRUE) {
[08:28:27.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.313]         }
[08:28:27.313]         else {
[08:28:27.313]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.313]         }
[08:28:27.313]         base::close(...future.stdout)
[08:28:27.313]         ...future.stdout <- NULL
[08:28:27.313]     }
[08:28:27.313]     ...future.result$conditions <- ...future.conditions
[08:28:27.313]     ...future.result$finished <- base::Sys.time()
[08:28:27.313]     ...future.result
[08:28:27.313] }
[08:28:27.316] requestCore(): workers = 2
[08:28:27.317] Poll #1 (0): usedCores() = 2, workers = 2
[08:28:27.348] result() for MulticoreFuture ...
[08:28:27.349] result() for MulticoreFuture ...
[08:28:27.349] result() for MulticoreFuture ... done
[08:28:27.349] result() for MulticoreFuture ... done
[08:28:27.350] result() for MulticoreFuture ...
[08:28:27.350] result() for MulticoreFuture ... done
[08:28:27.352] MulticoreFuture started
 - Resolving 4 multicore futures
[08:28:27.353] result() for MulticoreFuture ...
[08:28:27.353] result() for MulticoreFuture ... done
[08:28:27.353] plan(): Setting new future strategy stack:
[08:28:27.354] result() for MulticoreFuture ...
[08:28:27.354] result() for MulticoreFuture ... done
[08:28:27.354] result() for MulticoreFuture ...
[08:28:27.354] result() for MulticoreFuture ... done
[08:28:27.355] result() for MulticoreFuture ...
[08:28:27.355] result() for MulticoreFuture ... done
[08:28:27.354] List of future strategies:
[08:28:27.354] 1. sequential:
[08:28:27.354]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.354]    - tweaked: FALSE
[08:28:27.354]    - call: NULL
[08:28:27.355] result() for MulticoreFuture ...
[08:28:27.355] plan(): nbrOfWorkers() = 1
[08:28:27.357] result() for MulticoreFuture ...
[08:28:27.357] result() for MulticoreFuture ... done
[08:28:27.357] result() for MulticoreFuture ... done
[08:28:27.357] result() for MulticoreFuture ...
[08:28:27.358] result() for MulticoreFuture ... done
[08:28:27.358] plan(): Setting new future strategy stack:
[08:28:27.358] result() for MulticoreFuture ...
[08:28:27.358] List of future strategies:
[08:28:27.358] 1. multicore:
[08:28:27.358]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.358]    - tweaked: FALSE
[08:28:27.358]    - call: plan(multicore)
[08:28:27.361] plan(): nbrOfWorkers() = 2
[08:28:27.362] result() for MulticoreFuture ...
[08:28:27.362] result() for MulticoreFuture ... done
[08:28:27.362] result() for MulticoreFuture ... done
[08:28:27.362] result() for MulticoreFuture ...
[08:28:27.363] result() for MulticoreFuture ... done
*** multicore(..., globals = FALSE) and errors
[08:28:27.366] getGlobalsAndPackages() ...
[08:28:27.366] Not searching for globals
[08:28:27.366] - globals: [0] <none>
[08:28:27.366] getGlobalsAndPackages() ... DONE
[08:28:27.367] Packages needed by the future expression (n = 0): <none>
[08:28:27.367] Packages needed by future strategies (n = 0): <none>
[08:28:27.367] {
[08:28:27.367]     {
[08:28:27.367]         {
[08:28:27.367]             ...future.startTime <- base::Sys.time()
[08:28:27.367]             {
[08:28:27.367]                 {
[08:28:27.367]                   {
[08:28:27.367]                     {
[08:28:27.367]                       base::local({
[08:28:27.367]                         has_future <- base::requireNamespace("future", 
[08:28:27.367]                           quietly = TRUE)
[08:28:27.367]                         if (has_future) {
[08:28:27.367]                           ns <- base::getNamespace("future")
[08:28:27.367]                           version <- ns[[".package"]][["version"]]
[08:28:27.367]                           if (is.null(version)) 
[08:28:27.367]                             version <- utils::packageVersion("future")
[08:28:27.367]                         }
[08:28:27.367]                         else {
[08:28:27.367]                           version <- NULL
[08:28:27.367]                         }
[08:28:27.367]                         if (!has_future || version < "1.8.0") {
[08:28:27.367]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.367]                             "", base::R.version$version.string), 
[08:28:27.367]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.367]                               "release", "version")], collapse = " "), 
[08:28:27.367]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.367]                             info)
[08:28:27.367]                           info <- base::paste(info, collapse = "; ")
[08:28:27.367]                           if (!has_future) {
[08:28:27.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.367]                               info)
[08:28:27.367]                           }
[08:28:27.367]                           else {
[08:28:27.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.367]                               info, version)
[08:28:27.367]                           }
[08:28:27.367]                           base::stop(msg)
[08:28:27.367]                         }
[08:28:27.367]                       })
[08:28:27.367]                     }
[08:28:27.367]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.367]                     base::options(mc.cores = 1L)
[08:28:27.367]                   }
[08:28:27.367]                   ...future.strategy.old <- future::plan("list")
[08:28:27.367]                   options(future.plan = NULL)
[08:28:27.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.367]                 }
[08:28:27.367]                 ...future.workdir <- getwd()
[08:28:27.367]             }
[08:28:27.367]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.367]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.367]         }
[08:28:27.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.367]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.367]             base::names(...future.oldOptions))
[08:28:27.367]     }
[08:28:27.367]     if (FALSE) {
[08:28:27.367]     }
[08:28:27.367]     else {
[08:28:27.367]         if (TRUE) {
[08:28:27.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.367]                 open = "w")
[08:28:27.367]         }
[08:28:27.367]         else {
[08:28:27.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.367]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.367]         }
[08:28:27.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.367]             base::sink(type = "output", split = FALSE)
[08:28:27.367]             base::close(...future.stdout)
[08:28:27.367]         }, add = TRUE)
[08:28:27.367]     }
[08:28:27.367]     ...future.frame <- base::sys.nframe()
[08:28:27.367]     ...future.conditions <- base::list()
[08:28:27.367]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.367]     if (FALSE) {
[08:28:27.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.367]     }
[08:28:27.367]     ...future.result <- base::tryCatch({
[08:28:27.367]         base::withCallingHandlers({
[08:28:27.367]             ...future.value <- base::withVisible(base::local({
[08:28:27.367]                 withCallingHandlers({
[08:28:27.367]                   {
[08:28:27.367]                     stop("Whoops!")
[08:28:27.367]                     1
[08:28:27.367]                   }
[08:28:27.367]                 }, immediateCondition = function(cond) {
[08:28:27.367]                   save_rds <- function (object, pathname, ...) 
[08:28:27.367]                   {
[08:28:27.367]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.367]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.367]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.367]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.367]                         fi_tmp[["mtime"]])
[08:28:27.367]                     }
[08:28:27.367]                     tryCatch({
[08:28:27.367]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.367]                     }, error = function(ex) {
[08:28:27.367]                       msg <- conditionMessage(ex)
[08:28:27.367]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.367]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.367]                         fi_tmp[["mtime"]], msg)
[08:28:27.367]                       ex$message <- msg
[08:28:27.367]                       stop(ex)
[08:28:27.367]                     })
[08:28:27.367]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.367]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.367]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.367]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.367]                       fi <- file.info(pathname)
[08:28:27.367]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.367]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.367]                         fi[["size"]], fi[["mtime"]])
[08:28:27.367]                       stop(msg)
[08:28:27.367]                     }
[08:28:27.367]                     invisible(pathname)
[08:28:27.367]                   }
[08:28:27.367]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.367]                     rootPath = tempdir()) 
[08:28:27.367]                   {
[08:28:27.367]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.367]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.367]                       tmpdir = path, fileext = ".rds")
[08:28:27.367]                     save_rds(obj, file)
[08:28:27.367]                   }
[08:28:27.367]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.367]                   {
[08:28:27.367]                     inherits <- base::inherits
[08:28:27.367]                     invokeRestart <- base::invokeRestart
[08:28:27.367]                     is.null <- base::is.null
[08:28:27.367]                     muffled <- FALSE
[08:28:27.367]                     if (inherits(cond, "message")) {
[08:28:27.367]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.367]                       if (muffled) 
[08:28:27.367]                         invokeRestart("muffleMessage")
[08:28:27.367]                     }
[08:28:27.367]                     else if (inherits(cond, "warning")) {
[08:28:27.367]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.367]                       if (muffled) 
[08:28:27.367]                         invokeRestart("muffleWarning")
[08:28:27.367]                     }
[08:28:27.367]                     else if (inherits(cond, "condition")) {
[08:28:27.367]                       if (!is.null(pattern)) {
[08:28:27.367]                         computeRestarts <- base::computeRestarts
[08:28:27.367]                         grepl <- base::grepl
[08:28:27.367]                         restarts <- computeRestarts(cond)
[08:28:27.367]                         for (restart in restarts) {
[08:28:27.367]                           name <- restart$name
[08:28:27.367]                           if (is.null(name)) 
[08:28:27.367]                             next
[08:28:27.367]                           if (!grepl(pattern, name)) 
[08:28:27.367]                             next
[08:28:27.367]                           invokeRestart(restart)
[08:28:27.367]                           muffled <- TRUE
[08:28:27.367]                           break
[08:28:27.367]                         }
[08:28:27.367]                       }
[08:28:27.367]                     }
[08:28:27.367]                     invisible(muffled)
[08:28:27.367]                   }
[08:28:27.367]                   muffleCondition(cond)
[08:28:27.367]                 })
[08:28:27.367]             }))
[08:28:27.367]             future::FutureResult(value = ...future.value$value, 
[08:28:27.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.367]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.367]                     ...future.globalenv.names))
[08:28:27.367]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.367]         }, condition = base::local({
[08:28:27.367]             c <- base::c
[08:28:27.367]             inherits <- base::inherits
[08:28:27.367]             invokeRestart <- base::invokeRestart
[08:28:27.367]             length <- base::length
[08:28:27.367]             list <- base::list
[08:28:27.367]             seq.int <- base::seq.int
[08:28:27.367]             signalCondition <- base::signalCondition
[08:28:27.367]             sys.calls <- base::sys.calls
[08:28:27.367]             `[[` <- base::`[[`
[08:28:27.367]             `+` <- base::`+`
[08:28:27.367]             `<<-` <- base::`<<-`
[08:28:27.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.367]                   3L)]
[08:28:27.367]             }
[08:28:27.367]             function(cond) {
[08:28:27.367]                 is_error <- inherits(cond, "error")
[08:28:27.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.367]                   NULL)
[08:28:27.367]                 if (is_error) {
[08:28:27.367]                   sessionInformation <- function() {
[08:28:27.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.367]                       search = base::search(), system = base::Sys.info())
[08:28:27.367]                   }
[08:28:27.367]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.367]                     cond$call), session = sessionInformation(), 
[08:28:27.367]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.367]                   signalCondition(cond)
[08:28:27.367]                 }
[08:28:27.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.367]                 "immediateCondition"))) {
[08:28:27.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.367]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.367]                   if (TRUE && !signal) {
[08:28:27.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.367]                     {
[08:28:27.367]                       inherits <- base::inherits
[08:28:27.367]                       invokeRestart <- base::invokeRestart
[08:28:27.367]                       is.null <- base::is.null
[08:28:27.367]                       muffled <- FALSE
[08:28:27.367]                       if (inherits(cond, "message")) {
[08:28:27.367]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.367]                         if (muffled) 
[08:28:27.367]                           invokeRestart("muffleMessage")
[08:28:27.367]                       }
[08:28:27.367]                       else if (inherits(cond, "warning")) {
[08:28:27.367]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.367]                         if (muffled) 
[08:28:27.367]                           invokeRestart("muffleWarning")
[08:28:27.367]                       }
[08:28:27.367]                       else if (inherits(cond, "condition")) {
[08:28:27.367]                         if (!is.null(pattern)) {
[08:28:27.367]                           computeRestarts <- base::computeRestarts
[08:28:27.367]                           grepl <- base::grepl
[08:28:27.367]                           restarts <- computeRestarts(cond)
[08:28:27.367]                           for (restart in restarts) {
[08:28:27.367]                             name <- restart$name
[08:28:27.367]                             if (is.null(name)) 
[08:28:27.367]                               next
[08:28:27.367]                             if (!grepl(pattern, name)) 
[08:28:27.367]                               next
[08:28:27.367]                             invokeRestart(restart)
[08:28:27.367]                             muffled <- TRUE
[08:28:27.367]                             break
[08:28:27.367]                           }
[08:28:27.367]                         }
[08:28:27.367]                       }
[08:28:27.367]                       invisible(muffled)
[08:28:27.367]                     }
[08:28:27.367]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.367]                   }
[08:28:27.367]                 }
[08:28:27.367]                 else {
[08:28:27.367]                   if (TRUE) {
[08:28:27.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.367]                     {
[08:28:27.367]                       inherits <- base::inherits
[08:28:27.367]                       invokeRestart <- base::invokeRestart
[08:28:27.367]                       is.null <- base::is.null
[08:28:27.367]                       muffled <- FALSE
[08:28:27.367]                       if (inherits(cond, "message")) {
[08:28:27.367]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.367]                         if (muffled) 
[08:28:27.367]                           invokeRestart("muffleMessage")
[08:28:27.367]                       }
[08:28:27.367]                       else if (inherits(cond, "warning")) {
[08:28:27.367]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.367]                         if (muffled) 
[08:28:27.367]                           invokeRestart("muffleWarning")
[08:28:27.367]                       }
[08:28:27.367]                       else if (inherits(cond, "condition")) {
[08:28:27.367]                         if (!is.null(pattern)) {
[08:28:27.367]                           computeRestarts <- base::computeRestarts
[08:28:27.367]                           grepl <- base::grepl
[08:28:27.367]                           restarts <- computeRestarts(cond)
[08:28:27.367]                           for (restart in restarts) {
[08:28:27.367]                             name <- restart$name
[08:28:27.367]                             if (is.null(name)) 
[08:28:27.367]                               next
[08:28:27.367]                             if (!grepl(pattern, name)) 
[08:28:27.367]                               next
[08:28:27.367]                             invokeRestart(restart)
[08:28:27.367]                             muffled <- TRUE
[08:28:27.367]                             break
[08:28:27.367]                           }
[08:28:27.367]                         }
[08:28:27.367]                       }
[08:28:27.367]                       invisible(muffled)
[08:28:27.367]                     }
[08:28:27.367]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.367]                   }
[08:28:27.367]                 }
[08:28:27.367]             }
[08:28:27.367]         }))
[08:28:27.367]     }, error = function(ex) {
[08:28:27.367]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.367]                 ...future.rng), started = ...future.startTime, 
[08:28:27.367]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.367]             version = "1.8"), class = "FutureResult")
[08:28:27.367]     }, finally = {
[08:28:27.367]         if (!identical(...future.workdir, getwd())) 
[08:28:27.367]             setwd(...future.workdir)
[08:28:27.367]         {
[08:28:27.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.367]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.367]             }
[08:28:27.367]             base::options(...future.oldOptions)
[08:28:27.367]             if (.Platform$OS.type == "windows") {
[08:28:27.367]                 old_names <- names(...future.oldEnvVars)
[08:28:27.367]                 envs <- base::Sys.getenv()
[08:28:27.367]                 names <- names(envs)
[08:28:27.367]                 common <- intersect(names, old_names)
[08:28:27.367]                 added <- setdiff(names, old_names)
[08:28:27.367]                 removed <- setdiff(old_names, names)
[08:28:27.367]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.367]                   envs[common]]
[08:28:27.367]                 NAMES <- toupper(changed)
[08:28:27.367]                 args <- list()
[08:28:27.367]                 for (kk in seq_along(NAMES)) {
[08:28:27.367]                   name <- changed[[kk]]
[08:28:27.367]                   NAME <- NAMES[[kk]]
[08:28:27.367]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.367]                     next
[08:28:27.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.367]                 }
[08:28:27.367]                 NAMES <- toupper(added)
[08:28:27.367]                 for (kk in seq_along(NAMES)) {
[08:28:27.367]                   name <- added[[kk]]
[08:28:27.367]                   NAME <- NAMES[[kk]]
[08:28:27.367]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.367]                     next
[08:28:27.367]                   args[[name]] <- ""
[08:28:27.367]                 }
[08:28:27.367]                 NAMES <- toupper(removed)
[08:28:27.367]                 for (kk in seq_along(NAMES)) {
[08:28:27.367]                   name <- removed[[kk]]
[08:28:27.367]                   NAME <- NAMES[[kk]]
[08:28:27.367]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.367]                     next
[08:28:27.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.367]                 }
[08:28:27.367]                 if (length(args) > 0) 
[08:28:27.367]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.367]             }
[08:28:27.367]             else {
[08:28:27.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.367]             }
[08:28:27.367]             {
[08:28:27.367]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.367]                   0L) {
[08:28:27.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.367]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.367]                   base::options(opts)
[08:28:27.367]                 }
[08:28:27.367]                 {
[08:28:27.367]                   {
[08:28:27.367]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.367]                     NULL
[08:28:27.367]                   }
[08:28:27.367]                   options(future.plan = NULL)
[08:28:27.367]                   if (is.na(NA_character_)) 
[08:28:27.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.367]                     .init = FALSE)
[08:28:27.367]                 }
[08:28:27.367]             }
[08:28:27.367]         }
[08:28:27.367]     })
[08:28:27.367]     if (TRUE) {
[08:28:27.367]         base::sink(type = "output", split = FALSE)
[08:28:27.367]         if (TRUE) {
[08:28:27.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.367]         }
[08:28:27.367]         else {
[08:28:27.367]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.367]         }
[08:28:27.367]         base::close(...future.stdout)
[08:28:27.367]         ...future.stdout <- NULL
[08:28:27.367]     }
[08:28:27.367]     ...future.result$conditions <- ...future.conditions
[08:28:27.367]     ...future.result$finished <- base::Sys.time()
[08:28:27.367]     ...future.result
[08:28:27.367] }
[08:28:27.370] requestCore(): workers = 2
[08:28:27.372] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:28:27.373] plan(): Setting new future strategy stack:
[08:28:27.373] List of future strategies:
[08:28:27.373] 1. sequential:
[08:28:27.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.373]    - tweaked: FALSE
[08:28:27.373]    - call: NULL
[08:28:27.375] plan(): nbrOfWorkers() = 1
[08:28:27.376] plan(): Setting new future strategy stack:
[08:28:27.377] List of future strategies:
[08:28:27.377] 1. multicore:
[08:28:27.377]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.377]    - tweaked: FALSE
[08:28:27.377]    - call: plan(multicore)
[08:28:27.380] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:27.383] result() for MulticoreFuture ...
[08:28:27.386] result() for MulticoreFuture ...
[08:28:27.386] result() for MulticoreFuture ... done
[08:28:27.386] signalConditions() ...
[08:28:27.386]  - include = ‘immediateCondition’
[08:28:27.386]  - exclude = 
[08:28:27.386]  - resignal = FALSE
[08:28:27.386]  - Number of conditions: 1
[08:28:27.387] signalConditions() ... done
[08:28:27.387] result() for MulticoreFuture ... done
[08:28:27.387] result() for MulticoreFuture ...
[08:28:27.387] result() for MulticoreFuture ... done
[08:28:27.387] signalConditions() ...
[08:28:27.387]  - include = ‘immediateCondition’
[08:28:27.387]  - exclude = 
[08:28:27.387]  - resignal = FALSE
[08:28:27.387]  - Number of conditions: 1
[08:28:27.388] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[08:28:27.388] result() for MulticoreFuture ...
[08:28:27.389] result() for MulticoreFuture ... done
[08:28:27.389] result() for MulticoreFuture ...
[08:28:27.389] result() for MulticoreFuture ... done
[08:28:27.389] signalConditions() ...
[08:28:27.389]  - include = ‘immediateCondition’
[08:28:27.389]  - exclude = 
[08:28:27.389]  - resignal = FALSE
[08:28:27.389]  - Number of conditions: 1
[08:28:27.389] signalConditions() ... done
[08:28:27.390] Future state: ‘finished’
[08:28:27.390] result() for MulticoreFuture ...
[08:28:27.390] result() for MulticoreFuture ... done
[08:28:27.390] signalConditions() ...
[08:28:27.390]  - include = ‘condition’
[08:28:27.390]  - exclude = ‘immediateCondition’
[08:28:27.390]  - resignal = TRUE
[08:28:27.390]  - Number of conditions: 1
[08:28:27.390]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:27.391] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[08:28:27.391] result() for MulticoreFuture ...
[08:28:27.392] result() for MulticoreFuture ... done
[08:28:27.392] result() for MulticoreFuture ...
[08:28:27.392] result() for MulticoreFuture ... done
[08:28:27.392] signalConditions() ...
[08:28:27.392]  - include = ‘immediateCondition’
[08:28:27.392]  - exclude = 
[08:28:27.392]  - resignal = FALSE
[08:28:27.392]  - Number of conditions: 1
[08:28:27.392] signalConditions() ... done
[08:28:27.393] Future state: ‘finished’
[08:28:27.393] result() for MulticoreFuture ...
[08:28:27.393] result() for MulticoreFuture ... done
[08:28:27.393] signalConditions() ...
[08:28:27.393]  - include = ‘condition’
[08:28:27.393]  - exclude = ‘immediateCondition’
[08:28:27.393]  - resignal = TRUE
[08:28:27.393]  - Number of conditions: 1
[08:28:27.393]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:27.394] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[08:28:27.396] getGlobalsAndPackages() ...
[08:28:27.396] 
[08:28:27.396] - globals: [0] <none>
[08:28:27.397] getGlobalsAndPackages() ... DONE
[08:28:27.397] Packages needed by the future expression (n = 0): <none>
[08:28:27.397] Packages needed by future strategies (n = 0): <none>
[08:28:27.398] {
[08:28:27.398]     {
[08:28:27.398]         {
[08:28:27.398]             ...future.startTime <- base::Sys.time()
[08:28:27.398]             {
[08:28:27.398]                 {
[08:28:27.398]                   {
[08:28:27.398]                     {
[08:28:27.398]                       base::local({
[08:28:27.398]                         has_future <- base::requireNamespace("future", 
[08:28:27.398]                           quietly = TRUE)
[08:28:27.398]                         if (has_future) {
[08:28:27.398]                           ns <- base::getNamespace("future")
[08:28:27.398]                           version <- ns[[".package"]][["version"]]
[08:28:27.398]                           if (is.null(version)) 
[08:28:27.398]                             version <- utils::packageVersion("future")
[08:28:27.398]                         }
[08:28:27.398]                         else {
[08:28:27.398]                           version <- NULL
[08:28:27.398]                         }
[08:28:27.398]                         if (!has_future || version < "1.8.0") {
[08:28:27.398]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.398]                             "", base::R.version$version.string), 
[08:28:27.398]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.398]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.398]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.398]                               "release", "version")], collapse = " "), 
[08:28:27.398]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.398]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.398]                             info)
[08:28:27.398]                           info <- base::paste(info, collapse = "; ")
[08:28:27.398]                           if (!has_future) {
[08:28:27.398]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.398]                               info)
[08:28:27.398]                           }
[08:28:27.398]                           else {
[08:28:27.398]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.398]                               info, version)
[08:28:27.398]                           }
[08:28:27.398]                           base::stop(msg)
[08:28:27.398]                         }
[08:28:27.398]                       })
[08:28:27.398]                     }
[08:28:27.398]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.398]                     base::options(mc.cores = 1L)
[08:28:27.398]                   }
[08:28:27.398]                   ...future.strategy.old <- future::plan("list")
[08:28:27.398]                   options(future.plan = NULL)
[08:28:27.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.398]                 }
[08:28:27.398]                 ...future.workdir <- getwd()
[08:28:27.398]             }
[08:28:27.398]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.398]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.398]         }
[08:28:27.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.398]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.398]             base::names(...future.oldOptions))
[08:28:27.398]     }
[08:28:27.398]     if (FALSE) {
[08:28:27.398]     }
[08:28:27.398]     else {
[08:28:27.398]         if (TRUE) {
[08:28:27.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.398]                 open = "w")
[08:28:27.398]         }
[08:28:27.398]         else {
[08:28:27.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.398]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.398]         }
[08:28:27.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.398]             base::sink(type = "output", split = FALSE)
[08:28:27.398]             base::close(...future.stdout)
[08:28:27.398]         }, add = TRUE)
[08:28:27.398]     }
[08:28:27.398]     ...future.frame <- base::sys.nframe()
[08:28:27.398]     ...future.conditions <- base::list()
[08:28:27.398]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.398]     if (FALSE) {
[08:28:27.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.398]     }
[08:28:27.398]     ...future.result <- base::tryCatch({
[08:28:27.398]         base::withCallingHandlers({
[08:28:27.398]             ...future.value <- base::withVisible(base::local({
[08:28:27.398]                 withCallingHandlers({
[08:28:27.398]                   {
[08:28:27.398]                     stop(structure(list(message = "boom"), class = c("MyError", 
[08:28:27.398]                       "error", "condition")))
[08:28:27.398]                   }
[08:28:27.398]                 }, immediateCondition = function(cond) {
[08:28:27.398]                   save_rds <- function (object, pathname, ...) 
[08:28:27.398]                   {
[08:28:27.398]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.398]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.398]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.398]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.398]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.398]                         fi_tmp[["mtime"]])
[08:28:27.398]                     }
[08:28:27.398]                     tryCatch({
[08:28:27.398]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.398]                     }, error = function(ex) {
[08:28:27.398]                       msg <- conditionMessage(ex)
[08:28:27.398]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.398]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.398]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.398]                         fi_tmp[["mtime"]], msg)
[08:28:27.398]                       ex$message <- msg
[08:28:27.398]                       stop(ex)
[08:28:27.398]                     })
[08:28:27.398]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.398]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.398]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.398]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.398]                       fi <- file.info(pathname)
[08:28:27.398]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.398]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.398]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.398]                         fi[["size"]], fi[["mtime"]])
[08:28:27.398]                       stop(msg)
[08:28:27.398]                     }
[08:28:27.398]                     invisible(pathname)
[08:28:27.398]                   }
[08:28:27.398]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.398]                     rootPath = tempdir()) 
[08:28:27.398]                   {
[08:28:27.398]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.398]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.398]                       tmpdir = path, fileext = ".rds")
[08:28:27.398]                     save_rds(obj, file)
[08:28:27.398]                   }
[08:28:27.398]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.398]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.398]                   {
[08:28:27.398]                     inherits <- base::inherits
[08:28:27.398]                     invokeRestart <- base::invokeRestart
[08:28:27.398]                     is.null <- base::is.null
[08:28:27.398]                     muffled <- FALSE
[08:28:27.398]                     if (inherits(cond, "message")) {
[08:28:27.398]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.398]                       if (muffled) 
[08:28:27.398]                         invokeRestart("muffleMessage")
[08:28:27.398]                     }
[08:28:27.398]                     else if (inherits(cond, "warning")) {
[08:28:27.398]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.398]                       if (muffled) 
[08:28:27.398]                         invokeRestart("muffleWarning")
[08:28:27.398]                     }
[08:28:27.398]                     else if (inherits(cond, "condition")) {
[08:28:27.398]                       if (!is.null(pattern)) {
[08:28:27.398]                         computeRestarts <- base::computeRestarts
[08:28:27.398]                         grepl <- base::grepl
[08:28:27.398]                         restarts <- computeRestarts(cond)
[08:28:27.398]                         for (restart in restarts) {
[08:28:27.398]                           name <- restart$name
[08:28:27.398]                           if (is.null(name)) 
[08:28:27.398]                             next
[08:28:27.398]                           if (!grepl(pattern, name)) 
[08:28:27.398]                             next
[08:28:27.398]                           invokeRestart(restart)
[08:28:27.398]                           muffled <- TRUE
[08:28:27.398]                           break
[08:28:27.398]                         }
[08:28:27.398]                       }
[08:28:27.398]                     }
[08:28:27.398]                     invisible(muffled)
[08:28:27.398]                   }
[08:28:27.398]                   muffleCondition(cond)
[08:28:27.398]                 })
[08:28:27.398]             }))
[08:28:27.398]             future::FutureResult(value = ...future.value$value, 
[08:28:27.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.398]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.398]                     ...future.globalenv.names))
[08:28:27.398]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.398]         }, condition = base::local({
[08:28:27.398]             c <- base::c
[08:28:27.398]             inherits <- base::inherits
[08:28:27.398]             invokeRestart <- base::invokeRestart
[08:28:27.398]             length <- base::length
[08:28:27.398]             list <- base::list
[08:28:27.398]             seq.int <- base::seq.int
[08:28:27.398]             signalCondition <- base::signalCondition
[08:28:27.398]             sys.calls <- base::sys.calls
[08:28:27.398]             `[[` <- base::`[[`
[08:28:27.398]             `+` <- base::`+`
[08:28:27.398]             `<<-` <- base::`<<-`
[08:28:27.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.398]                   3L)]
[08:28:27.398]             }
[08:28:27.398]             function(cond) {
[08:28:27.398]                 is_error <- inherits(cond, "error")
[08:28:27.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.398]                   NULL)
[08:28:27.398]                 if (is_error) {
[08:28:27.398]                   sessionInformation <- function() {
[08:28:27.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.398]                       search = base::search(), system = base::Sys.info())
[08:28:27.398]                   }
[08:28:27.398]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.398]                     cond$call), session = sessionInformation(), 
[08:28:27.398]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.398]                   signalCondition(cond)
[08:28:27.398]                 }
[08:28:27.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.398]                 "immediateCondition"))) {
[08:28:27.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.398]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.398]                   if (TRUE && !signal) {
[08:28:27.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.398]                     {
[08:28:27.398]                       inherits <- base::inherits
[08:28:27.398]                       invokeRestart <- base::invokeRestart
[08:28:27.398]                       is.null <- base::is.null
[08:28:27.398]                       muffled <- FALSE
[08:28:27.398]                       if (inherits(cond, "message")) {
[08:28:27.398]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.398]                         if (muffled) 
[08:28:27.398]                           invokeRestart("muffleMessage")
[08:28:27.398]                       }
[08:28:27.398]                       else if (inherits(cond, "warning")) {
[08:28:27.398]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.398]                         if (muffled) 
[08:28:27.398]                           invokeRestart("muffleWarning")
[08:28:27.398]                       }
[08:28:27.398]                       else if (inherits(cond, "condition")) {
[08:28:27.398]                         if (!is.null(pattern)) {
[08:28:27.398]                           computeRestarts <- base::computeRestarts
[08:28:27.398]                           grepl <- base::grepl
[08:28:27.398]                           restarts <- computeRestarts(cond)
[08:28:27.398]                           for (restart in restarts) {
[08:28:27.398]                             name <- restart$name
[08:28:27.398]                             if (is.null(name)) 
[08:28:27.398]                               next
[08:28:27.398]                             if (!grepl(pattern, name)) 
[08:28:27.398]                               next
[08:28:27.398]                             invokeRestart(restart)
[08:28:27.398]                             muffled <- TRUE
[08:28:27.398]                             break
[08:28:27.398]                           }
[08:28:27.398]                         }
[08:28:27.398]                       }
[08:28:27.398]                       invisible(muffled)
[08:28:27.398]                     }
[08:28:27.398]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.398]                   }
[08:28:27.398]                 }
[08:28:27.398]                 else {
[08:28:27.398]                   if (TRUE) {
[08:28:27.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.398]                     {
[08:28:27.398]                       inherits <- base::inherits
[08:28:27.398]                       invokeRestart <- base::invokeRestart
[08:28:27.398]                       is.null <- base::is.null
[08:28:27.398]                       muffled <- FALSE
[08:28:27.398]                       if (inherits(cond, "message")) {
[08:28:27.398]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.398]                         if (muffled) 
[08:28:27.398]                           invokeRestart("muffleMessage")
[08:28:27.398]                       }
[08:28:27.398]                       else if (inherits(cond, "warning")) {
[08:28:27.398]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.398]                         if (muffled) 
[08:28:27.398]                           invokeRestart("muffleWarning")
[08:28:27.398]                       }
[08:28:27.398]                       else if (inherits(cond, "condition")) {
[08:28:27.398]                         if (!is.null(pattern)) {
[08:28:27.398]                           computeRestarts <- base::computeRestarts
[08:28:27.398]                           grepl <- base::grepl
[08:28:27.398]                           restarts <- computeRestarts(cond)
[08:28:27.398]                           for (restart in restarts) {
[08:28:27.398]                             name <- restart$name
[08:28:27.398]                             if (is.null(name)) 
[08:28:27.398]                               next
[08:28:27.398]                             if (!grepl(pattern, name)) 
[08:28:27.398]                               next
[08:28:27.398]                             invokeRestart(restart)
[08:28:27.398]                             muffled <- TRUE
[08:28:27.398]                             break
[08:28:27.398]                           }
[08:28:27.398]                         }
[08:28:27.398]                       }
[08:28:27.398]                       invisible(muffled)
[08:28:27.398]                     }
[08:28:27.398]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.398]                   }
[08:28:27.398]                 }
[08:28:27.398]             }
[08:28:27.398]         }))
[08:28:27.398]     }, error = function(ex) {
[08:28:27.398]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.398]                 ...future.rng), started = ...future.startTime, 
[08:28:27.398]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.398]             version = "1.8"), class = "FutureResult")
[08:28:27.398]     }, finally = {
[08:28:27.398]         if (!identical(...future.workdir, getwd())) 
[08:28:27.398]             setwd(...future.workdir)
[08:28:27.398]         {
[08:28:27.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.398]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.398]             }
[08:28:27.398]             base::options(...future.oldOptions)
[08:28:27.398]             if (.Platform$OS.type == "windows") {
[08:28:27.398]                 old_names <- names(...future.oldEnvVars)
[08:28:27.398]                 envs <- base::Sys.getenv()
[08:28:27.398]                 names <- names(envs)
[08:28:27.398]                 common <- intersect(names, old_names)
[08:28:27.398]                 added <- setdiff(names, old_names)
[08:28:27.398]                 removed <- setdiff(old_names, names)
[08:28:27.398]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.398]                   envs[common]]
[08:28:27.398]                 NAMES <- toupper(changed)
[08:28:27.398]                 args <- list()
[08:28:27.398]                 for (kk in seq_along(NAMES)) {
[08:28:27.398]                   name <- changed[[kk]]
[08:28:27.398]                   NAME <- NAMES[[kk]]
[08:28:27.398]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.398]                     next
[08:28:27.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.398]                 }
[08:28:27.398]                 NAMES <- toupper(added)
[08:28:27.398]                 for (kk in seq_along(NAMES)) {
[08:28:27.398]                   name <- added[[kk]]
[08:28:27.398]                   NAME <- NAMES[[kk]]
[08:28:27.398]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.398]                     next
[08:28:27.398]                   args[[name]] <- ""
[08:28:27.398]                 }
[08:28:27.398]                 NAMES <- toupper(removed)
[08:28:27.398]                 for (kk in seq_along(NAMES)) {
[08:28:27.398]                   name <- removed[[kk]]
[08:28:27.398]                   NAME <- NAMES[[kk]]
[08:28:27.398]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.398]                     next
[08:28:27.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.398]                 }
[08:28:27.398]                 if (length(args) > 0) 
[08:28:27.398]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.398]             }
[08:28:27.398]             else {
[08:28:27.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.398]             }
[08:28:27.398]             {
[08:28:27.398]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.398]                   0L) {
[08:28:27.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.398]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.398]                   base::options(opts)
[08:28:27.398]                 }
[08:28:27.398]                 {
[08:28:27.398]                   {
[08:28:27.398]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.398]                     NULL
[08:28:27.398]                   }
[08:28:27.398]                   options(future.plan = NULL)
[08:28:27.398]                   if (is.na(NA_character_)) 
[08:28:27.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.398]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.398]                     .init = FALSE)
[08:28:27.398]                 }
[08:28:27.398]             }
[08:28:27.398]         }
[08:28:27.398]     })
[08:28:27.398]     if (TRUE) {
[08:28:27.398]         base::sink(type = "output", split = FALSE)
[08:28:27.398]         if (TRUE) {
[08:28:27.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.398]         }
[08:28:27.398]         else {
[08:28:27.398]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.398]         }
[08:28:27.398]         base::close(...future.stdout)
[08:28:27.398]         ...future.stdout <- NULL
[08:28:27.398]     }
[08:28:27.398]     ...future.result$conditions <- ...future.conditions
[08:28:27.398]     ...future.result$finished <- base::Sys.time()
[08:28:27.398]     ...future.result
[08:28:27.398] }
[08:28:27.401] requestCore(): workers = 2
[08:28:27.406] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:28:27.407] plan(): Setting new future strategy stack:
[08:28:27.407] List of future strategies:
[08:28:27.407] 1. sequential:
[08:28:27.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.407]    - tweaked: FALSE
[08:28:27.407]    - call: NULL
[08:28:27.408] plan(): nbrOfWorkers() = 1
[08:28:27.411] plan(): Setting new future strategy stack:
[08:28:27.411] List of future strategies:
[08:28:27.411] 1. multicore:
[08:28:27.411]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.411]    - tweaked: FALSE
[08:28:27.411]    - call: plan(multicore)
[08:28:27.414] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:27.417] result() for MulticoreFuture ...
[08:28:27.420] result() for MulticoreFuture ...
[08:28:27.420] result() for MulticoreFuture ... done
[08:28:27.420] signalConditions() ...
[08:28:27.420]  - include = ‘immediateCondition’
[08:28:27.421]  - exclude = 
[08:28:27.421]  - resignal = FALSE
[08:28:27.421]  - Number of conditions: 1
[08:28:27.421] signalConditions() ... done
[08:28:27.421] result() for MulticoreFuture ... done
[08:28:27.421] result() for MulticoreFuture ...
[08:28:27.421] result() for MulticoreFuture ... done
[08:28:27.421] signalConditions() ...
[08:28:27.422]  - include = ‘immediateCondition’
[08:28:27.422]  - exclude = 
[08:28:27.422]  - resignal = FALSE
[08:28:27.422]  - Number of conditions: 1
[08:28:27.422] signalConditions() ... done
<MyError: boom>
[08:28:27.422] result() for MulticoreFuture ...
[08:28:27.422] result() for MulticoreFuture ... done
[08:28:27.423] result() for MulticoreFuture ...
[08:28:27.423] result() for MulticoreFuture ... done
[08:28:27.423] signalConditions() ...
[08:28:27.423]  - include = ‘immediateCondition’
[08:28:27.423]  - exclude = 
[08:28:27.423]  - resignal = FALSE
[08:28:27.423]  - Number of conditions: 1
[08:28:27.423] signalConditions() ... done
[08:28:27.424] Future state: ‘finished’
[08:28:27.424] result() for MulticoreFuture ...
[08:28:27.424] result() for MulticoreFuture ... done
[08:28:27.424] signalConditions() ...
[08:28:27.424]  - include = ‘condition’
[08:28:27.424]  - exclude = ‘immediateCondition’
[08:28:27.424]  - resignal = TRUE
[08:28:27.424]  - Number of conditions: 1
[08:28:27.424]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[08:28:27.425] signalConditions() ... done
*** multicore(..., globals = TRUE) without globals
[08:28:27.427] getGlobalsAndPackages() ...
[08:28:27.427] Searching for globals...
[08:28:27.428] - globals found: [1] ‘{’
[08:28:27.428] Searching for globals ... DONE
[08:28:27.428] Resolving globals: FALSE
[08:28:27.428] 
[08:28:27.429] 
[08:28:27.429] getGlobalsAndPackages() ... DONE
[08:28:27.429] Packages needed by the future expression (n = 0): <none>
[08:28:27.429] Packages needed by future strategies (n = 0): <none>
[08:28:27.430] {
[08:28:27.430]     {
[08:28:27.430]         {
[08:28:27.430]             ...future.startTime <- base::Sys.time()
[08:28:27.430]             {
[08:28:27.430]                 {
[08:28:27.430]                   {
[08:28:27.430]                     {
[08:28:27.430]                       base::local({
[08:28:27.430]                         has_future <- base::requireNamespace("future", 
[08:28:27.430]                           quietly = TRUE)
[08:28:27.430]                         if (has_future) {
[08:28:27.430]                           ns <- base::getNamespace("future")
[08:28:27.430]                           version <- ns[[".package"]][["version"]]
[08:28:27.430]                           if (is.null(version)) 
[08:28:27.430]                             version <- utils::packageVersion("future")
[08:28:27.430]                         }
[08:28:27.430]                         else {
[08:28:27.430]                           version <- NULL
[08:28:27.430]                         }
[08:28:27.430]                         if (!has_future || version < "1.8.0") {
[08:28:27.430]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.430]                             "", base::R.version$version.string), 
[08:28:27.430]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.430]                               "release", "version")], collapse = " "), 
[08:28:27.430]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.430]                             info)
[08:28:27.430]                           info <- base::paste(info, collapse = "; ")
[08:28:27.430]                           if (!has_future) {
[08:28:27.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.430]                               info)
[08:28:27.430]                           }
[08:28:27.430]                           else {
[08:28:27.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.430]                               info, version)
[08:28:27.430]                           }
[08:28:27.430]                           base::stop(msg)
[08:28:27.430]                         }
[08:28:27.430]                       })
[08:28:27.430]                     }
[08:28:27.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.430]                     base::options(mc.cores = 1L)
[08:28:27.430]                   }
[08:28:27.430]                   ...future.strategy.old <- future::plan("list")
[08:28:27.430]                   options(future.plan = NULL)
[08:28:27.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.430]                 }
[08:28:27.430]                 ...future.workdir <- getwd()
[08:28:27.430]             }
[08:28:27.430]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.430]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.430]         }
[08:28:27.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.430]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.430]             base::names(...future.oldOptions))
[08:28:27.430]     }
[08:28:27.430]     if (FALSE) {
[08:28:27.430]     }
[08:28:27.430]     else {
[08:28:27.430]         if (TRUE) {
[08:28:27.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.430]                 open = "w")
[08:28:27.430]         }
[08:28:27.430]         else {
[08:28:27.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.430]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.430]         }
[08:28:27.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.430]             base::sink(type = "output", split = FALSE)
[08:28:27.430]             base::close(...future.stdout)
[08:28:27.430]         }, add = TRUE)
[08:28:27.430]     }
[08:28:27.430]     ...future.frame <- base::sys.nframe()
[08:28:27.430]     ...future.conditions <- base::list()
[08:28:27.430]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.430]     if (FALSE) {
[08:28:27.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.430]     }
[08:28:27.430]     ...future.result <- base::tryCatch({
[08:28:27.430]         base::withCallingHandlers({
[08:28:27.430]             ...future.value <- base::withVisible(base::local({
[08:28:27.430]                 withCallingHandlers({
[08:28:27.430]                   {
[08:28:27.430]                     42L
[08:28:27.430]                   }
[08:28:27.430]                 }, immediateCondition = function(cond) {
[08:28:27.430]                   save_rds <- function (object, pathname, ...) 
[08:28:27.430]                   {
[08:28:27.430]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.430]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.430]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.430]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.430]                         fi_tmp[["mtime"]])
[08:28:27.430]                     }
[08:28:27.430]                     tryCatch({
[08:28:27.430]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.430]                     }, error = function(ex) {
[08:28:27.430]                       msg <- conditionMessage(ex)
[08:28:27.430]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.430]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.430]                         fi_tmp[["mtime"]], msg)
[08:28:27.430]                       ex$message <- msg
[08:28:27.430]                       stop(ex)
[08:28:27.430]                     })
[08:28:27.430]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.430]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.430]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.430]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.430]                       fi <- file.info(pathname)
[08:28:27.430]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.430]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.430]                         fi[["size"]], fi[["mtime"]])
[08:28:27.430]                       stop(msg)
[08:28:27.430]                     }
[08:28:27.430]                     invisible(pathname)
[08:28:27.430]                   }
[08:28:27.430]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.430]                     rootPath = tempdir()) 
[08:28:27.430]                   {
[08:28:27.430]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.430]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.430]                       tmpdir = path, fileext = ".rds")
[08:28:27.430]                     save_rds(obj, file)
[08:28:27.430]                   }
[08:28:27.430]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.430]                   {
[08:28:27.430]                     inherits <- base::inherits
[08:28:27.430]                     invokeRestart <- base::invokeRestart
[08:28:27.430]                     is.null <- base::is.null
[08:28:27.430]                     muffled <- FALSE
[08:28:27.430]                     if (inherits(cond, "message")) {
[08:28:27.430]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.430]                       if (muffled) 
[08:28:27.430]                         invokeRestart("muffleMessage")
[08:28:27.430]                     }
[08:28:27.430]                     else if (inherits(cond, "warning")) {
[08:28:27.430]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.430]                       if (muffled) 
[08:28:27.430]                         invokeRestart("muffleWarning")
[08:28:27.430]                     }
[08:28:27.430]                     else if (inherits(cond, "condition")) {
[08:28:27.430]                       if (!is.null(pattern)) {
[08:28:27.430]                         computeRestarts <- base::computeRestarts
[08:28:27.430]                         grepl <- base::grepl
[08:28:27.430]                         restarts <- computeRestarts(cond)
[08:28:27.430]                         for (restart in restarts) {
[08:28:27.430]                           name <- restart$name
[08:28:27.430]                           if (is.null(name)) 
[08:28:27.430]                             next
[08:28:27.430]                           if (!grepl(pattern, name)) 
[08:28:27.430]                             next
[08:28:27.430]                           invokeRestart(restart)
[08:28:27.430]                           muffled <- TRUE
[08:28:27.430]                           break
[08:28:27.430]                         }
[08:28:27.430]                       }
[08:28:27.430]                     }
[08:28:27.430]                     invisible(muffled)
[08:28:27.430]                   }
[08:28:27.430]                   muffleCondition(cond)
[08:28:27.430]                 })
[08:28:27.430]             }))
[08:28:27.430]             future::FutureResult(value = ...future.value$value, 
[08:28:27.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.430]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.430]                     ...future.globalenv.names))
[08:28:27.430]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.430]         }, condition = base::local({
[08:28:27.430]             c <- base::c
[08:28:27.430]             inherits <- base::inherits
[08:28:27.430]             invokeRestart <- base::invokeRestart
[08:28:27.430]             length <- base::length
[08:28:27.430]             list <- base::list
[08:28:27.430]             seq.int <- base::seq.int
[08:28:27.430]             signalCondition <- base::signalCondition
[08:28:27.430]             sys.calls <- base::sys.calls
[08:28:27.430]             `[[` <- base::`[[`
[08:28:27.430]             `+` <- base::`+`
[08:28:27.430]             `<<-` <- base::`<<-`
[08:28:27.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.430]                   3L)]
[08:28:27.430]             }
[08:28:27.430]             function(cond) {
[08:28:27.430]                 is_error <- inherits(cond, "error")
[08:28:27.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.430]                   NULL)
[08:28:27.430]                 if (is_error) {
[08:28:27.430]                   sessionInformation <- function() {
[08:28:27.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.430]                       search = base::search(), system = base::Sys.info())
[08:28:27.430]                   }
[08:28:27.430]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.430]                     cond$call), session = sessionInformation(), 
[08:28:27.430]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.430]                   signalCondition(cond)
[08:28:27.430]                 }
[08:28:27.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.430]                 "immediateCondition"))) {
[08:28:27.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.430]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.430]                   if (TRUE && !signal) {
[08:28:27.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.430]                     {
[08:28:27.430]                       inherits <- base::inherits
[08:28:27.430]                       invokeRestart <- base::invokeRestart
[08:28:27.430]                       is.null <- base::is.null
[08:28:27.430]                       muffled <- FALSE
[08:28:27.430]                       if (inherits(cond, "message")) {
[08:28:27.430]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.430]                         if (muffled) 
[08:28:27.430]                           invokeRestart("muffleMessage")
[08:28:27.430]                       }
[08:28:27.430]                       else if (inherits(cond, "warning")) {
[08:28:27.430]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.430]                         if (muffled) 
[08:28:27.430]                           invokeRestart("muffleWarning")
[08:28:27.430]                       }
[08:28:27.430]                       else if (inherits(cond, "condition")) {
[08:28:27.430]                         if (!is.null(pattern)) {
[08:28:27.430]                           computeRestarts <- base::computeRestarts
[08:28:27.430]                           grepl <- base::grepl
[08:28:27.430]                           restarts <- computeRestarts(cond)
[08:28:27.430]                           for (restart in restarts) {
[08:28:27.430]                             name <- restart$name
[08:28:27.430]                             if (is.null(name)) 
[08:28:27.430]                               next
[08:28:27.430]                             if (!grepl(pattern, name)) 
[08:28:27.430]                               next
[08:28:27.430]                             invokeRestart(restart)
[08:28:27.430]                             muffled <- TRUE
[08:28:27.430]                             break
[08:28:27.430]                           }
[08:28:27.430]                         }
[08:28:27.430]                       }
[08:28:27.430]                       invisible(muffled)
[08:28:27.430]                     }
[08:28:27.430]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.430]                   }
[08:28:27.430]                 }
[08:28:27.430]                 else {
[08:28:27.430]                   if (TRUE) {
[08:28:27.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.430]                     {
[08:28:27.430]                       inherits <- base::inherits
[08:28:27.430]                       invokeRestart <- base::invokeRestart
[08:28:27.430]                       is.null <- base::is.null
[08:28:27.430]                       muffled <- FALSE
[08:28:27.430]                       if (inherits(cond, "message")) {
[08:28:27.430]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.430]                         if (muffled) 
[08:28:27.430]                           invokeRestart("muffleMessage")
[08:28:27.430]                       }
[08:28:27.430]                       else if (inherits(cond, "warning")) {
[08:28:27.430]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.430]                         if (muffled) 
[08:28:27.430]                           invokeRestart("muffleWarning")
[08:28:27.430]                       }
[08:28:27.430]                       else if (inherits(cond, "condition")) {
[08:28:27.430]                         if (!is.null(pattern)) {
[08:28:27.430]                           computeRestarts <- base::computeRestarts
[08:28:27.430]                           grepl <- base::grepl
[08:28:27.430]                           restarts <- computeRestarts(cond)
[08:28:27.430]                           for (restart in restarts) {
[08:28:27.430]                             name <- restart$name
[08:28:27.430]                             if (is.null(name)) 
[08:28:27.430]                               next
[08:28:27.430]                             if (!grepl(pattern, name)) 
[08:28:27.430]                               next
[08:28:27.430]                             invokeRestart(restart)
[08:28:27.430]                             muffled <- TRUE
[08:28:27.430]                             break
[08:28:27.430]                           }
[08:28:27.430]                         }
[08:28:27.430]                       }
[08:28:27.430]                       invisible(muffled)
[08:28:27.430]                     }
[08:28:27.430]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.430]                   }
[08:28:27.430]                 }
[08:28:27.430]             }
[08:28:27.430]         }))
[08:28:27.430]     }, error = function(ex) {
[08:28:27.430]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.430]                 ...future.rng), started = ...future.startTime, 
[08:28:27.430]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.430]             version = "1.8"), class = "FutureResult")
[08:28:27.430]     }, finally = {
[08:28:27.430]         if (!identical(...future.workdir, getwd())) 
[08:28:27.430]             setwd(...future.workdir)
[08:28:27.430]         {
[08:28:27.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.430]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.430]             }
[08:28:27.430]             base::options(...future.oldOptions)
[08:28:27.430]             if (.Platform$OS.type == "windows") {
[08:28:27.430]                 old_names <- names(...future.oldEnvVars)
[08:28:27.430]                 envs <- base::Sys.getenv()
[08:28:27.430]                 names <- names(envs)
[08:28:27.430]                 common <- intersect(names, old_names)
[08:28:27.430]                 added <- setdiff(names, old_names)
[08:28:27.430]                 removed <- setdiff(old_names, names)
[08:28:27.430]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.430]                   envs[common]]
[08:28:27.430]                 NAMES <- toupper(changed)
[08:28:27.430]                 args <- list()
[08:28:27.430]                 for (kk in seq_along(NAMES)) {
[08:28:27.430]                   name <- changed[[kk]]
[08:28:27.430]                   NAME <- NAMES[[kk]]
[08:28:27.430]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.430]                     next
[08:28:27.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.430]                 }
[08:28:27.430]                 NAMES <- toupper(added)
[08:28:27.430]                 for (kk in seq_along(NAMES)) {
[08:28:27.430]                   name <- added[[kk]]
[08:28:27.430]                   NAME <- NAMES[[kk]]
[08:28:27.430]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.430]                     next
[08:28:27.430]                   args[[name]] <- ""
[08:28:27.430]                 }
[08:28:27.430]                 NAMES <- toupper(removed)
[08:28:27.430]                 for (kk in seq_along(NAMES)) {
[08:28:27.430]                   name <- removed[[kk]]
[08:28:27.430]                   NAME <- NAMES[[kk]]
[08:28:27.430]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.430]                     next
[08:28:27.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.430]                 }
[08:28:27.430]                 if (length(args) > 0) 
[08:28:27.430]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.430]             }
[08:28:27.430]             else {
[08:28:27.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.430]             }
[08:28:27.430]             {
[08:28:27.430]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.430]                   0L) {
[08:28:27.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.430]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.430]                   base::options(opts)
[08:28:27.430]                 }
[08:28:27.430]                 {
[08:28:27.430]                   {
[08:28:27.430]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.430]                     NULL
[08:28:27.430]                   }
[08:28:27.430]                   options(future.plan = NULL)
[08:28:27.430]                   if (is.na(NA_character_)) 
[08:28:27.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.430]                     .init = FALSE)
[08:28:27.430]                 }
[08:28:27.430]             }
[08:28:27.430]         }
[08:28:27.430]     })
[08:28:27.430]     if (TRUE) {
[08:28:27.430]         base::sink(type = "output", split = FALSE)
[08:28:27.430]         if (TRUE) {
[08:28:27.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.430]         }
[08:28:27.430]         else {
[08:28:27.430]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.430]         }
[08:28:27.430]         base::close(...future.stdout)
[08:28:27.430]         ...future.stdout <- NULL
[08:28:27.430]     }
[08:28:27.430]     ...future.result$conditions <- ...future.conditions
[08:28:27.430]     ...future.result$finished <- base::Sys.time()
[08:28:27.430]     ...future.result
[08:28:27.430] }
[08:28:27.433] requestCore(): workers = 2
[08:28:27.435] MulticoreFuture started
[08:28:27.436] plan(): Setting new future strategy stack:
[08:28:27.436] List of future strategies:
[08:28:27.436] 1. sequential:
[08:28:27.436]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.436]    - tweaked: FALSE
[08:28:27.436]    - call: NULL
[08:28:27.437] plan(): nbrOfWorkers() = 1
[08:28:27.439] plan(): Setting new future strategy stack:
[08:28:27.439] List of future strategies:
[08:28:27.439] 1. multicore:
[08:28:27.439]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.439]    - tweaked: FALSE
[08:28:27.439]    - call: plan(multicore)
[08:28:27.443] plan(): nbrOfWorkers() = 2
[1] TRUE
[08:28:27.443] result() for MulticoreFuture ...
[08:28:27.444] result() for MulticoreFuture ...
[08:28:27.445] result() for MulticoreFuture ... done
[08:28:27.445] result() for MulticoreFuture ... done
[08:28:27.445] result() for MulticoreFuture ...
[08:28:27.445] result() for MulticoreFuture ... done
[1] 42
*** multicore(..., globals = TRUE) with globals
[08:28:27.447] getGlobalsAndPackages() ...
[08:28:27.447] Searching for globals...
[08:28:27.450] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘a’
[08:28:27.450] Searching for globals ... DONE
[08:28:27.450] Resolving globals: FALSE
[08:28:27.451] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:27.451] The total size of the 1 globals exported for future expression (‘{; b <- 3; c <- 2; a * b * c; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:28:27.451] - globals: [1] ‘a’
[08:28:27.451] 
[08:28:27.452] getGlobalsAndPackages() ... DONE
[08:28:27.452] Packages needed by the future expression (n = 0): <none>
[08:28:27.452] Packages needed by future strategies (n = 0): <none>
[08:28:27.453] {
[08:28:27.453]     {
[08:28:27.453]         {
[08:28:27.453]             ...future.startTime <- base::Sys.time()
[08:28:27.453]             {
[08:28:27.453]                 {
[08:28:27.453]                   {
[08:28:27.453]                     {
[08:28:27.453]                       base::local({
[08:28:27.453]                         has_future <- base::requireNamespace("future", 
[08:28:27.453]                           quietly = TRUE)
[08:28:27.453]                         if (has_future) {
[08:28:27.453]                           ns <- base::getNamespace("future")
[08:28:27.453]                           version <- ns[[".package"]][["version"]]
[08:28:27.453]                           if (is.null(version)) 
[08:28:27.453]                             version <- utils::packageVersion("future")
[08:28:27.453]                         }
[08:28:27.453]                         else {
[08:28:27.453]                           version <- NULL
[08:28:27.453]                         }
[08:28:27.453]                         if (!has_future || version < "1.8.0") {
[08:28:27.453]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.453]                             "", base::R.version$version.string), 
[08:28:27.453]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.453]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.453]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.453]                               "release", "version")], collapse = " "), 
[08:28:27.453]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.453]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.453]                             info)
[08:28:27.453]                           info <- base::paste(info, collapse = "; ")
[08:28:27.453]                           if (!has_future) {
[08:28:27.453]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.453]                               info)
[08:28:27.453]                           }
[08:28:27.453]                           else {
[08:28:27.453]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.453]                               info, version)
[08:28:27.453]                           }
[08:28:27.453]                           base::stop(msg)
[08:28:27.453]                         }
[08:28:27.453]                       })
[08:28:27.453]                     }
[08:28:27.453]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.453]                     base::options(mc.cores = 1L)
[08:28:27.453]                   }
[08:28:27.453]                   ...future.strategy.old <- future::plan("list")
[08:28:27.453]                   options(future.plan = NULL)
[08:28:27.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.453]                 }
[08:28:27.453]                 ...future.workdir <- getwd()
[08:28:27.453]             }
[08:28:27.453]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.453]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.453]         }
[08:28:27.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.453]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.453]             base::names(...future.oldOptions))
[08:28:27.453]     }
[08:28:27.453]     if (FALSE) {
[08:28:27.453]     }
[08:28:27.453]     else {
[08:28:27.453]         if (TRUE) {
[08:28:27.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.453]                 open = "w")
[08:28:27.453]         }
[08:28:27.453]         else {
[08:28:27.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.453]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.453]         }
[08:28:27.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.453]             base::sink(type = "output", split = FALSE)
[08:28:27.453]             base::close(...future.stdout)
[08:28:27.453]         }, add = TRUE)
[08:28:27.453]     }
[08:28:27.453]     ...future.frame <- base::sys.nframe()
[08:28:27.453]     ...future.conditions <- base::list()
[08:28:27.453]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.453]     if (FALSE) {
[08:28:27.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.453]     }
[08:28:27.453]     ...future.result <- base::tryCatch({
[08:28:27.453]         base::withCallingHandlers({
[08:28:27.453]             ...future.value <- base::withVisible(base::local({
[08:28:27.453]                 withCallingHandlers({
[08:28:27.453]                   {
[08:28:27.453]                     b <- 3
[08:28:27.453]                     c <- 2
[08:28:27.453]                     a * b * c
[08:28:27.453]                   }
[08:28:27.453]                 }, immediateCondition = function(cond) {
[08:28:27.453]                   save_rds <- function (object, pathname, ...) 
[08:28:27.453]                   {
[08:28:27.453]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.453]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.453]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.453]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.453]                         fi_tmp[["mtime"]])
[08:28:27.453]                     }
[08:28:27.453]                     tryCatch({
[08:28:27.453]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.453]                     }, error = function(ex) {
[08:28:27.453]                       msg <- conditionMessage(ex)
[08:28:27.453]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.453]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.453]                         fi_tmp[["mtime"]], msg)
[08:28:27.453]                       ex$message <- msg
[08:28:27.453]                       stop(ex)
[08:28:27.453]                     })
[08:28:27.453]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.453]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.453]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.453]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.453]                       fi <- file.info(pathname)
[08:28:27.453]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.453]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.453]                         fi[["size"]], fi[["mtime"]])
[08:28:27.453]                       stop(msg)
[08:28:27.453]                     }
[08:28:27.453]                     invisible(pathname)
[08:28:27.453]                   }
[08:28:27.453]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.453]                     rootPath = tempdir()) 
[08:28:27.453]                   {
[08:28:27.453]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.453]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.453]                       tmpdir = path, fileext = ".rds")
[08:28:27.453]                     save_rds(obj, file)
[08:28:27.453]                   }
[08:28:27.453]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.453]                   {
[08:28:27.453]                     inherits <- base::inherits
[08:28:27.453]                     invokeRestart <- base::invokeRestart
[08:28:27.453]                     is.null <- base::is.null
[08:28:27.453]                     muffled <- FALSE
[08:28:27.453]                     if (inherits(cond, "message")) {
[08:28:27.453]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.453]                       if (muffled) 
[08:28:27.453]                         invokeRestart("muffleMessage")
[08:28:27.453]                     }
[08:28:27.453]                     else if (inherits(cond, "warning")) {
[08:28:27.453]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.453]                       if (muffled) 
[08:28:27.453]                         invokeRestart("muffleWarning")
[08:28:27.453]                     }
[08:28:27.453]                     else if (inherits(cond, "condition")) {
[08:28:27.453]                       if (!is.null(pattern)) {
[08:28:27.453]                         computeRestarts <- base::computeRestarts
[08:28:27.453]                         grepl <- base::grepl
[08:28:27.453]                         restarts <- computeRestarts(cond)
[08:28:27.453]                         for (restart in restarts) {
[08:28:27.453]                           name <- restart$name
[08:28:27.453]                           if (is.null(name)) 
[08:28:27.453]                             next
[08:28:27.453]                           if (!grepl(pattern, name)) 
[08:28:27.453]                             next
[08:28:27.453]                           invokeRestart(restart)
[08:28:27.453]                           muffled <- TRUE
[08:28:27.453]                           break
[08:28:27.453]                         }
[08:28:27.453]                       }
[08:28:27.453]                     }
[08:28:27.453]                     invisible(muffled)
[08:28:27.453]                   }
[08:28:27.453]                   muffleCondition(cond)
[08:28:27.453]                 })
[08:28:27.453]             }))
[08:28:27.453]             future::FutureResult(value = ...future.value$value, 
[08:28:27.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.453]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.453]                     ...future.globalenv.names))
[08:28:27.453]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.453]         }, condition = base::local({
[08:28:27.453]             c <- base::c
[08:28:27.453]             inherits <- base::inherits
[08:28:27.453]             invokeRestart <- base::invokeRestart
[08:28:27.453]             length <- base::length
[08:28:27.453]             list <- base::list
[08:28:27.453]             seq.int <- base::seq.int
[08:28:27.453]             signalCondition <- base::signalCondition
[08:28:27.453]             sys.calls <- base::sys.calls
[08:28:27.453]             `[[` <- base::`[[`
[08:28:27.453]             `+` <- base::`+`
[08:28:27.453]             `<<-` <- base::`<<-`
[08:28:27.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.453]                   3L)]
[08:28:27.453]             }
[08:28:27.453]             function(cond) {
[08:28:27.453]                 is_error <- inherits(cond, "error")
[08:28:27.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.453]                   NULL)
[08:28:27.453]                 if (is_error) {
[08:28:27.453]                   sessionInformation <- function() {
[08:28:27.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.453]                       search = base::search(), system = base::Sys.info())
[08:28:27.453]                   }
[08:28:27.453]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.453]                     cond$call), session = sessionInformation(), 
[08:28:27.453]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.453]                   signalCondition(cond)
[08:28:27.453]                 }
[08:28:27.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.453]                 "immediateCondition"))) {
[08:28:27.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.453]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.453]                   if (TRUE && !signal) {
[08:28:27.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.453]                     {
[08:28:27.453]                       inherits <- base::inherits
[08:28:27.453]                       invokeRestart <- base::invokeRestart
[08:28:27.453]                       is.null <- base::is.null
[08:28:27.453]                       muffled <- FALSE
[08:28:27.453]                       if (inherits(cond, "message")) {
[08:28:27.453]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.453]                         if (muffled) 
[08:28:27.453]                           invokeRestart("muffleMessage")
[08:28:27.453]                       }
[08:28:27.453]                       else if (inherits(cond, "warning")) {
[08:28:27.453]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.453]                         if (muffled) 
[08:28:27.453]                           invokeRestart("muffleWarning")
[08:28:27.453]                       }
[08:28:27.453]                       else if (inherits(cond, "condition")) {
[08:28:27.453]                         if (!is.null(pattern)) {
[08:28:27.453]                           computeRestarts <- base::computeRestarts
[08:28:27.453]                           grepl <- base::grepl
[08:28:27.453]                           restarts <- computeRestarts(cond)
[08:28:27.453]                           for (restart in restarts) {
[08:28:27.453]                             name <- restart$name
[08:28:27.453]                             if (is.null(name)) 
[08:28:27.453]                               next
[08:28:27.453]                             if (!grepl(pattern, name)) 
[08:28:27.453]                               next
[08:28:27.453]                             invokeRestart(restart)
[08:28:27.453]                             muffled <- TRUE
[08:28:27.453]                             break
[08:28:27.453]                           }
[08:28:27.453]                         }
[08:28:27.453]                       }
[08:28:27.453]                       invisible(muffled)
[08:28:27.453]                     }
[08:28:27.453]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.453]                   }
[08:28:27.453]                 }
[08:28:27.453]                 else {
[08:28:27.453]                   if (TRUE) {
[08:28:27.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.453]                     {
[08:28:27.453]                       inherits <- base::inherits
[08:28:27.453]                       invokeRestart <- base::invokeRestart
[08:28:27.453]                       is.null <- base::is.null
[08:28:27.453]                       muffled <- FALSE
[08:28:27.453]                       if (inherits(cond, "message")) {
[08:28:27.453]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.453]                         if (muffled) 
[08:28:27.453]                           invokeRestart("muffleMessage")
[08:28:27.453]                       }
[08:28:27.453]                       else if (inherits(cond, "warning")) {
[08:28:27.453]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.453]                         if (muffled) 
[08:28:27.453]                           invokeRestart("muffleWarning")
[08:28:27.453]                       }
[08:28:27.453]                       else if (inherits(cond, "condition")) {
[08:28:27.453]                         if (!is.null(pattern)) {
[08:28:27.453]                           computeRestarts <- base::computeRestarts
[08:28:27.453]                           grepl <- base::grepl
[08:28:27.453]                           restarts <- computeRestarts(cond)
[08:28:27.453]                           for (restart in restarts) {
[08:28:27.453]                             name <- restart$name
[08:28:27.453]                             if (is.null(name)) 
[08:28:27.453]                               next
[08:28:27.453]                             if (!grepl(pattern, name)) 
[08:28:27.453]                               next
[08:28:27.453]                             invokeRestart(restart)
[08:28:27.453]                             muffled <- TRUE
[08:28:27.453]                             break
[08:28:27.453]                           }
[08:28:27.453]                         }
[08:28:27.453]                       }
[08:28:27.453]                       invisible(muffled)
[08:28:27.453]                     }
[08:28:27.453]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.453]                   }
[08:28:27.453]                 }
[08:28:27.453]             }
[08:28:27.453]         }))
[08:28:27.453]     }, error = function(ex) {
[08:28:27.453]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.453]                 ...future.rng), started = ...future.startTime, 
[08:28:27.453]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.453]             version = "1.8"), class = "FutureResult")
[08:28:27.453]     }, finally = {
[08:28:27.453]         if (!identical(...future.workdir, getwd())) 
[08:28:27.453]             setwd(...future.workdir)
[08:28:27.453]         {
[08:28:27.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.453]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.453]             }
[08:28:27.453]             base::options(...future.oldOptions)
[08:28:27.453]             if (.Platform$OS.type == "windows") {
[08:28:27.453]                 old_names <- names(...future.oldEnvVars)
[08:28:27.453]                 envs <- base::Sys.getenv()
[08:28:27.453]                 names <- names(envs)
[08:28:27.453]                 common <- intersect(names, old_names)
[08:28:27.453]                 added <- setdiff(names, old_names)
[08:28:27.453]                 removed <- setdiff(old_names, names)
[08:28:27.453]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.453]                   envs[common]]
[08:28:27.453]                 NAMES <- toupper(changed)
[08:28:27.453]                 args <- list()
[08:28:27.453]                 for (kk in seq_along(NAMES)) {
[08:28:27.453]                   name <- changed[[kk]]
[08:28:27.453]                   NAME <- NAMES[[kk]]
[08:28:27.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.453]                     next
[08:28:27.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.453]                 }
[08:28:27.453]                 NAMES <- toupper(added)
[08:28:27.453]                 for (kk in seq_along(NAMES)) {
[08:28:27.453]                   name <- added[[kk]]
[08:28:27.453]                   NAME <- NAMES[[kk]]
[08:28:27.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.453]                     next
[08:28:27.453]                   args[[name]] <- ""
[08:28:27.453]                 }
[08:28:27.453]                 NAMES <- toupper(removed)
[08:28:27.453]                 for (kk in seq_along(NAMES)) {
[08:28:27.453]                   name <- removed[[kk]]
[08:28:27.453]                   NAME <- NAMES[[kk]]
[08:28:27.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.453]                     next
[08:28:27.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.453]                 }
[08:28:27.453]                 if (length(args) > 0) 
[08:28:27.453]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.453]             }
[08:28:27.453]             else {
[08:28:27.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.453]             }
[08:28:27.453]             {
[08:28:27.453]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.453]                   0L) {
[08:28:27.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.453]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.453]                   base::options(opts)
[08:28:27.453]                 }
[08:28:27.453]                 {
[08:28:27.453]                   {
[08:28:27.453]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.453]                     NULL
[08:28:27.453]                   }
[08:28:27.453]                   options(future.plan = NULL)
[08:28:27.453]                   if (is.na(NA_character_)) 
[08:28:27.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.453]                     .init = FALSE)
[08:28:27.453]                 }
[08:28:27.453]             }
[08:28:27.453]         }
[08:28:27.453]     })
[08:28:27.453]     if (TRUE) {
[08:28:27.453]         base::sink(type = "output", split = FALSE)
[08:28:27.453]         if (TRUE) {
[08:28:27.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.453]         }
[08:28:27.453]         else {
[08:28:27.453]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.453]         }
[08:28:27.453]         base::close(...future.stdout)
[08:28:27.453]         ...future.stdout <- NULL
[08:28:27.453]     }
[08:28:27.453]     ...future.result$conditions <- ...future.conditions
[08:28:27.453]     ...future.result$finished <- base::Sys.time()
[08:28:27.453]     ...future.result
[08:28:27.453] }
[08:28:27.456] assign_globals() ...
[08:28:27.456] List of 1
[08:28:27.456]  $ a: num 0
[08:28:27.456]  - attr(*, "where")=List of 1
[08:28:27.456]   ..$ a:<environment: R_EmptyEnv> 
[08:28:27.456]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.456]  - attr(*, "resolved")= logi FALSE
[08:28:27.456]  - attr(*, "total_size")= num 39
[08:28:27.459] - copied ‘a’ to environment
[08:28:27.459] assign_globals() ... done
[08:28:27.459] requestCore(): workers = 2
[08:28:27.461] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    b <- 3
    c <- 2
    a * b * c
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:28:27.462] plan(): Setting new future strategy stack:
Globals: 1 objects totaling 39 bytes (numeric ‘a’ of 39 bytes)
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:28:27.462] List of future strategies:
[08:28:27.462] 1. sequential:
[08:28:27.462]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.462]    - tweaked: FALSE
[08:28:27.462]    - call: NULL
[08:28:27.463] plan(): nbrOfWorkers() = 1
[08:28:27.465] plan(): Setting new future strategy stack:
[08:28:27.465] List of future strategies:
[08:28:27.465] 1. multicore:
[08:28:27.465]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.465]    - tweaked: FALSE
[08:28:27.465]    - call: plan(multicore)
[08:28:27.468] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:27.469] result() for MulticoreFuture ...
[08:28:27.470] result() for MulticoreFuture ...
[08:28:27.470] result() for MulticoreFuture ... done
[08:28:27.470] result() for MulticoreFuture ... done
[08:28:27.471] result() for MulticoreFuture ...
[08:28:27.471] result() for MulticoreFuture ... done
[1] 0
*** multicore(..., globals = TRUE) with globals and blocking
 - Creating multicore future #1 ...
[08:28:27.473] getGlobalsAndPackages() ...
[08:28:27.473] Searching for globals...
[08:28:27.478] - globals found: [2] ‘{’, ‘ii’
[08:28:27.478] Searching for globals ... DONE
[08:28:27.478] Resolving globals: FALSE
[08:28:27.479] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:27.479] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:27.479] - globals: [1] ‘ii’
[08:28:27.479] 
[08:28:27.479] getGlobalsAndPackages() ... DONE
[08:28:27.480] Packages needed by the future expression (n = 0): <none>
[08:28:27.480] Packages needed by future strategies (n = 0): <none>
[08:28:27.481] {
[08:28:27.481]     {
[08:28:27.481]         {
[08:28:27.481]             ...future.startTime <- base::Sys.time()
[08:28:27.481]             {
[08:28:27.481]                 {
[08:28:27.481]                   {
[08:28:27.481]                     {
[08:28:27.481]                       base::local({
[08:28:27.481]                         has_future <- base::requireNamespace("future", 
[08:28:27.481]                           quietly = TRUE)
[08:28:27.481]                         if (has_future) {
[08:28:27.481]                           ns <- base::getNamespace("future")
[08:28:27.481]                           version <- ns[[".package"]][["version"]]
[08:28:27.481]                           if (is.null(version)) 
[08:28:27.481]                             version <- utils::packageVersion("future")
[08:28:27.481]                         }
[08:28:27.481]                         else {
[08:28:27.481]                           version <- NULL
[08:28:27.481]                         }
[08:28:27.481]                         if (!has_future || version < "1.8.0") {
[08:28:27.481]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.481]                             "", base::R.version$version.string), 
[08:28:27.481]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.481]                               "release", "version")], collapse = " "), 
[08:28:27.481]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.481]                             info)
[08:28:27.481]                           info <- base::paste(info, collapse = "; ")
[08:28:27.481]                           if (!has_future) {
[08:28:27.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.481]                               info)
[08:28:27.481]                           }
[08:28:27.481]                           else {
[08:28:27.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.481]                               info, version)
[08:28:27.481]                           }
[08:28:27.481]                           base::stop(msg)
[08:28:27.481]                         }
[08:28:27.481]                       })
[08:28:27.481]                     }
[08:28:27.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.481]                     base::options(mc.cores = 1L)
[08:28:27.481]                   }
[08:28:27.481]                   ...future.strategy.old <- future::plan("list")
[08:28:27.481]                   options(future.plan = NULL)
[08:28:27.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.481]                 }
[08:28:27.481]                 ...future.workdir <- getwd()
[08:28:27.481]             }
[08:28:27.481]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.481]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.481]         }
[08:28:27.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.481]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.481]             base::names(...future.oldOptions))
[08:28:27.481]     }
[08:28:27.481]     if (FALSE) {
[08:28:27.481]     }
[08:28:27.481]     else {
[08:28:27.481]         if (TRUE) {
[08:28:27.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.481]                 open = "w")
[08:28:27.481]         }
[08:28:27.481]         else {
[08:28:27.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.481]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.481]         }
[08:28:27.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.481]             base::sink(type = "output", split = FALSE)
[08:28:27.481]             base::close(...future.stdout)
[08:28:27.481]         }, add = TRUE)
[08:28:27.481]     }
[08:28:27.481]     ...future.frame <- base::sys.nframe()
[08:28:27.481]     ...future.conditions <- base::list()
[08:28:27.481]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.481]     if (FALSE) {
[08:28:27.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.481]     }
[08:28:27.481]     ...future.result <- base::tryCatch({
[08:28:27.481]         base::withCallingHandlers({
[08:28:27.481]             ...future.value <- base::withVisible(base::local({
[08:28:27.481]                 withCallingHandlers({
[08:28:27.481]                   {
[08:28:27.481]                     ii
[08:28:27.481]                   }
[08:28:27.481]                 }, immediateCondition = function(cond) {
[08:28:27.481]                   save_rds <- function (object, pathname, ...) 
[08:28:27.481]                   {
[08:28:27.481]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.481]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.481]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.481]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.481]                         fi_tmp[["mtime"]])
[08:28:27.481]                     }
[08:28:27.481]                     tryCatch({
[08:28:27.481]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.481]                     }, error = function(ex) {
[08:28:27.481]                       msg <- conditionMessage(ex)
[08:28:27.481]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.481]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.481]                         fi_tmp[["mtime"]], msg)
[08:28:27.481]                       ex$message <- msg
[08:28:27.481]                       stop(ex)
[08:28:27.481]                     })
[08:28:27.481]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.481]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.481]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.481]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.481]                       fi <- file.info(pathname)
[08:28:27.481]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.481]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.481]                         fi[["size"]], fi[["mtime"]])
[08:28:27.481]                       stop(msg)
[08:28:27.481]                     }
[08:28:27.481]                     invisible(pathname)
[08:28:27.481]                   }
[08:28:27.481]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.481]                     rootPath = tempdir()) 
[08:28:27.481]                   {
[08:28:27.481]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.481]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.481]                       tmpdir = path, fileext = ".rds")
[08:28:27.481]                     save_rds(obj, file)
[08:28:27.481]                   }
[08:28:27.481]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.481]                   {
[08:28:27.481]                     inherits <- base::inherits
[08:28:27.481]                     invokeRestart <- base::invokeRestart
[08:28:27.481]                     is.null <- base::is.null
[08:28:27.481]                     muffled <- FALSE
[08:28:27.481]                     if (inherits(cond, "message")) {
[08:28:27.481]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.481]                       if (muffled) 
[08:28:27.481]                         invokeRestart("muffleMessage")
[08:28:27.481]                     }
[08:28:27.481]                     else if (inherits(cond, "warning")) {
[08:28:27.481]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.481]                       if (muffled) 
[08:28:27.481]                         invokeRestart("muffleWarning")
[08:28:27.481]                     }
[08:28:27.481]                     else if (inherits(cond, "condition")) {
[08:28:27.481]                       if (!is.null(pattern)) {
[08:28:27.481]                         computeRestarts <- base::computeRestarts
[08:28:27.481]                         grepl <- base::grepl
[08:28:27.481]                         restarts <- computeRestarts(cond)
[08:28:27.481]                         for (restart in restarts) {
[08:28:27.481]                           name <- restart$name
[08:28:27.481]                           if (is.null(name)) 
[08:28:27.481]                             next
[08:28:27.481]                           if (!grepl(pattern, name)) 
[08:28:27.481]                             next
[08:28:27.481]                           invokeRestart(restart)
[08:28:27.481]                           muffled <- TRUE
[08:28:27.481]                           break
[08:28:27.481]                         }
[08:28:27.481]                       }
[08:28:27.481]                     }
[08:28:27.481]                     invisible(muffled)
[08:28:27.481]                   }
[08:28:27.481]                   muffleCondition(cond)
[08:28:27.481]                 })
[08:28:27.481]             }))
[08:28:27.481]             future::FutureResult(value = ...future.value$value, 
[08:28:27.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.481]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.481]                     ...future.globalenv.names))
[08:28:27.481]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.481]         }, condition = base::local({
[08:28:27.481]             c <- base::c
[08:28:27.481]             inherits <- base::inherits
[08:28:27.481]             invokeRestart <- base::invokeRestart
[08:28:27.481]             length <- base::length
[08:28:27.481]             list <- base::list
[08:28:27.481]             seq.int <- base::seq.int
[08:28:27.481]             signalCondition <- base::signalCondition
[08:28:27.481]             sys.calls <- base::sys.calls
[08:28:27.481]             `[[` <- base::`[[`
[08:28:27.481]             `+` <- base::`+`
[08:28:27.481]             `<<-` <- base::`<<-`
[08:28:27.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.481]                   3L)]
[08:28:27.481]             }
[08:28:27.481]             function(cond) {
[08:28:27.481]                 is_error <- inherits(cond, "error")
[08:28:27.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.481]                   NULL)
[08:28:27.481]                 if (is_error) {
[08:28:27.481]                   sessionInformation <- function() {
[08:28:27.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.481]                       search = base::search(), system = base::Sys.info())
[08:28:27.481]                   }
[08:28:27.481]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.481]                     cond$call), session = sessionInformation(), 
[08:28:27.481]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.481]                   signalCondition(cond)
[08:28:27.481]                 }
[08:28:27.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.481]                 "immediateCondition"))) {
[08:28:27.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.481]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.481]                   if (TRUE && !signal) {
[08:28:27.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.481]                     {
[08:28:27.481]                       inherits <- base::inherits
[08:28:27.481]                       invokeRestart <- base::invokeRestart
[08:28:27.481]                       is.null <- base::is.null
[08:28:27.481]                       muffled <- FALSE
[08:28:27.481]                       if (inherits(cond, "message")) {
[08:28:27.481]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.481]                         if (muffled) 
[08:28:27.481]                           invokeRestart("muffleMessage")
[08:28:27.481]                       }
[08:28:27.481]                       else if (inherits(cond, "warning")) {
[08:28:27.481]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.481]                         if (muffled) 
[08:28:27.481]                           invokeRestart("muffleWarning")
[08:28:27.481]                       }
[08:28:27.481]                       else if (inherits(cond, "condition")) {
[08:28:27.481]                         if (!is.null(pattern)) {
[08:28:27.481]                           computeRestarts <- base::computeRestarts
[08:28:27.481]                           grepl <- base::grepl
[08:28:27.481]                           restarts <- computeRestarts(cond)
[08:28:27.481]                           for (restart in restarts) {
[08:28:27.481]                             name <- restart$name
[08:28:27.481]                             if (is.null(name)) 
[08:28:27.481]                               next
[08:28:27.481]                             if (!grepl(pattern, name)) 
[08:28:27.481]                               next
[08:28:27.481]                             invokeRestart(restart)
[08:28:27.481]                             muffled <- TRUE
[08:28:27.481]                             break
[08:28:27.481]                           }
[08:28:27.481]                         }
[08:28:27.481]                       }
[08:28:27.481]                       invisible(muffled)
[08:28:27.481]                     }
[08:28:27.481]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.481]                   }
[08:28:27.481]                 }
[08:28:27.481]                 else {
[08:28:27.481]                   if (TRUE) {
[08:28:27.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.481]                     {
[08:28:27.481]                       inherits <- base::inherits
[08:28:27.481]                       invokeRestart <- base::invokeRestart
[08:28:27.481]                       is.null <- base::is.null
[08:28:27.481]                       muffled <- FALSE
[08:28:27.481]                       if (inherits(cond, "message")) {
[08:28:27.481]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.481]                         if (muffled) 
[08:28:27.481]                           invokeRestart("muffleMessage")
[08:28:27.481]                       }
[08:28:27.481]                       else if (inherits(cond, "warning")) {
[08:28:27.481]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.481]                         if (muffled) 
[08:28:27.481]                           invokeRestart("muffleWarning")
[08:28:27.481]                       }
[08:28:27.481]                       else if (inherits(cond, "condition")) {
[08:28:27.481]                         if (!is.null(pattern)) {
[08:28:27.481]                           computeRestarts <- base::computeRestarts
[08:28:27.481]                           grepl <- base::grepl
[08:28:27.481]                           restarts <- computeRestarts(cond)
[08:28:27.481]                           for (restart in restarts) {
[08:28:27.481]                             name <- restart$name
[08:28:27.481]                             if (is.null(name)) 
[08:28:27.481]                               next
[08:28:27.481]                             if (!grepl(pattern, name)) 
[08:28:27.481]                               next
[08:28:27.481]                             invokeRestart(restart)
[08:28:27.481]                             muffled <- TRUE
[08:28:27.481]                             break
[08:28:27.481]                           }
[08:28:27.481]                         }
[08:28:27.481]                       }
[08:28:27.481]                       invisible(muffled)
[08:28:27.481]                     }
[08:28:27.481]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.481]                   }
[08:28:27.481]                 }
[08:28:27.481]             }
[08:28:27.481]         }))
[08:28:27.481]     }, error = function(ex) {
[08:28:27.481]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.481]                 ...future.rng), started = ...future.startTime, 
[08:28:27.481]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.481]             version = "1.8"), class = "FutureResult")
[08:28:27.481]     }, finally = {
[08:28:27.481]         if (!identical(...future.workdir, getwd())) 
[08:28:27.481]             setwd(...future.workdir)
[08:28:27.481]         {
[08:28:27.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.481]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.481]             }
[08:28:27.481]             base::options(...future.oldOptions)
[08:28:27.481]             if (.Platform$OS.type == "windows") {
[08:28:27.481]                 old_names <- names(...future.oldEnvVars)
[08:28:27.481]                 envs <- base::Sys.getenv()
[08:28:27.481]                 names <- names(envs)
[08:28:27.481]                 common <- intersect(names, old_names)
[08:28:27.481]                 added <- setdiff(names, old_names)
[08:28:27.481]                 removed <- setdiff(old_names, names)
[08:28:27.481]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.481]                   envs[common]]
[08:28:27.481]                 NAMES <- toupper(changed)
[08:28:27.481]                 args <- list()
[08:28:27.481]                 for (kk in seq_along(NAMES)) {
[08:28:27.481]                   name <- changed[[kk]]
[08:28:27.481]                   NAME <- NAMES[[kk]]
[08:28:27.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.481]                     next
[08:28:27.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.481]                 }
[08:28:27.481]                 NAMES <- toupper(added)
[08:28:27.481]                 for (kk in seq_along(NAMES)) {
[08:28:27.481]                   name <- added[[kk]]
[08:28:27.481]                   NAME <- NAMES[[kk]]
[08:28:27.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.481]                     next
[08:28:27.481]                   args[[name]] <- ""
[08:28:27.481]                 }
[08:28:27.481]                 NAMES <- toupper(removed)
[08:28:27.481]                 for (kk in seq_along(NAMES)) {
[08:28:27.481]                   name <- removed[[kk]]
[08:28:27.481]                   NAME <- NAMES[[kk]]
[08:28:27.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.481]                     next
[08:28:27.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.481]                 }
[08:28:27.481]                 if (length(args) > 0) 
[08:28:27.481]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.481]             }
[08:28:27.481]             else {
[08:28:27.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.481]             }
[08:28:27.481]             {
[08:28:27.481]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.481]                   0L) {
[08:28:27.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.481]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.481]                   base::options(opts)
[08:28:27.481]                 }
[08:28:27.481]                 {
[08:28:27.481]                   {
[08:28:27.481]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.481]                     NULL
[08:28:27.481]                   }
[08:28:27.481]                   options(future.plan = NULL)
[08:28:27.481]                   if (is.na(NA_character_)) 
[08:28:27.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.481]                     .init = FALSE)
[08:28:27.481]                 }
[08:28:27.481]             }
[08:28:27.481]         }
[08:28:27.481]     })
[08:28:27.481]     if (TRUE) {
[08:28:27.481]         base::sink(type = "output", split = FALSE)
[08:28:27.481]         if (TRUE) {
[08:28:27.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.481]         }
[08:28:27.481]         else {
[08:28:27.481]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.481]         }
[08:28:27.481]         base::close(...future.stdout)
[08:28:27.481]         ...future.stdout <- NULL
[08:28:27.481]     }
[08:28:27.481]     ...future.result$conditions <- ...future.conditions
[08:28:27.481]     ...future.result$finished <- base::Sys.time()
[08:28:27.481]     ...future.result
[08:28:27.481] }
[08:28:27.483] assign_globals() ...
[08:28:27.483] List of 1
[08:28:27.483]  $ ii: int 1
[08:28:27.483]  - attr(*, "where")=List of 1
[08:28:27.483]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:27.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.483]  - attr(*, "resolved")= logi FALSE
[08:28:27.483]  - attr(*, "total_size")= num 35
[08:28:27.486] - copied ‘ii’ to environment
[08:28:27.486] assign_globals() ... done
[08:28:27.486] requestCore(): workers = 2
[08:28:27.488] MulticoreFuture started
 - Creating multicore future #2 ...
[08:28:27.489] plan(): Setting new future strategy stack:
[08:28:27.490] List of future strategies:
[08:28:27.490] 1. sequential:
[08:28:27.490]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.490]    - tweaked: FALSE
[08:28:27.490]    - call: NULL
[08:28:27.491] plan(): nbrOfWorkers() = 1
[08:28:27.492] getGlobalsAndPackages() ...
[08:28:27.492] Searching for globals...
[08:28:27.493] plan(): Setting new future strategy stack:
[08:28:27.493] List of future strategies:
[08:28:27.493] 1. multicore:
[08:28:27.493]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.493]    - tweaked: FALSE
[08:28:27.493]    - call: plan(multicore)
[08:28:27.494] - globals found: [2] ‘{’, ‘ii’
[08:28:27.494] Searching for globals ... DONE
[08:28:27.494] Resolving globals: FALSE
[08:28:27.495] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:27.495] plan(): nbrOfWorkers() = 2
[08:28:27.496] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:27.496] - globals: [1] ‘ii’
[08:28:27.496] 
[08:28:27.496] getGlobalsAndPackages() ... DONE
[08:28:27.497] Packages needed by the future expression (n = 0): <none>
[08:28:27.497] Packages needed by future strategies (n = 0): <none>
[08:28:27.498] {
[08:28:27.498]     {
[08:28:27.498]         {
[08:28:27.498]             ...future.startTime <- base::Sys.time()
[08:28:27.498]             {
[08:28:27.498]                 {
[08:28:27.498]                   {
[08:28:27.498]                     {
[08:28:27.498]                       base::local({
[08:28:27.498]                         has_future <- base::requireNamespace("future", 
[08:28:27.498]                           quietly = TRUE)
[08:28:27.498]                         if (has_future) {
[08:28:27.498]                           ns <- base::getNamespace("future")
[08:28:27.498]                           version <- ns[[".package"]][["version"]]
[08:28:27.498]                           if (is.null(version)) 
[08:28:27.498]                             version <- utils::packageVersion("future")
[08:28:27.498]                         }
[08:28:27.498]                         else {
[08:28:27.498]                           version <- NULL
[08:28:27.498]                         }
[08:28:27.498]                         if (!has_future || version < "1.8.0") {
[08:28:27.498]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.498]                             "", base::R.version$version.string), 
[08:28:27.498]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.498]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.498]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.498]                               "release", "version")], collapse = " "), 
[08:28:27.498]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.498]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.498]                             info)
[08:28:27.498]                           info <- base::paste(info, collapse = "; ")
[08:28:27.498]                           if (!has_future) {
[08:28:27.498]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.498]                               info)
[08:28:27.498]                           }
[08:28:27.498]                           else {
[08:28:27.498]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.498]                               info, version)
[08:28:27.498]                           }
[08:28:27.498]                           base::stop(msg)
[08:28:27.498]                         }
[08:28:27.498]                       })
[08:28:27.498]                     }
[08:28:27.498]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.498]                     base::options(mc.cores = 1L)
[08:28:27.498]                   }
[08:28:27.498]                   ...future.strategy.old <- future::plan("list")
[08:28:27.498]                   options(future.plan = NULL)
[08:28:27.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.498]                 }
[08:28:27.498]                 ...future.workdir <- getwd()
[08:28:27.498]             }
[08:28:27.498]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.498]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.498]         }
[08:28:27.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.498]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.498]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.498]             base::names(...future.oldOptions))
[08:28:27.498]     }
[08:28:27.498]     if (FALSE) {
[08:28:27.498]     }
[08:28:27.498]     else {
[08:28:27.498]         if (TRUE) {
[08:28:27.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.498]                 open = "w")
[08:28:27.498]         }
[08:28:27.498]         else {
[08:28:27.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.498]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.498]         }
[08:28:27.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.498]             base::sink(type = "output", split = FALSE)
[08:28:27.498]             base::close(...future.stdout)
[08:28:27.498]         }, add = TRUE)
[08:28:27.498]     }
[08:28:27.498]     ...future.frame <- base::sys.nframe()
[08:28:27.498]     ...future.conditions <- base::list()
[08:28:27.498]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.498]     if (FALSE) {
[08:28:27.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.498]     }
[08:28:27.498]     ...future.result <- base::tryCatch({
[08:28:27.498]         base::withCallingHandlers({
[08:28:27.498]             ...future.value <- base::withVisible(base::local({
[08:28:27.498]                 withCallingHandlers({
[08:28:27.498]                   {
[08:28:27.498]                     ii
[08:28:27.498]                   }
[08:28:27.498]                 }, immediateCondition = function(cond) {
[08:28:27.498]                   save_rds <- function (object, pathname, ...) 
[08:28:27.498]                   {
[08:28:27.498]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.498]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.498]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.498]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.498]                         fi_tmp[["mtime"]])
[08:28:27.498]                     }
[08:28:27.498]                     tryCatch({
[08:28:27.498]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.498]                     }, error = function(ex) {
[08:28:27.498]                       msg <- conditionMessage(ex)
[08:28:27.498]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.498]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.498]                         fi_tmp[["mtime"]], msg)
[08:28:27.498]                       ex$message <- msg
[08:28:27.498]                       stop(ex)
[08:28:27.498]                     })
[08:28:27.498]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.498]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.498]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.498]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.498]                       fi <- file.info(pathname)
[08:28:27.498]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.498]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.498]                         fi[["size"]], fi[["mtime"]])
[08:28:27.498]                       stop(msg)
[08:28:27.498]                     }
[08:28:27.498]                     invisible(pathname)
[08:28:27.498]                   }
[08:28:27.498]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.498]                     rootPath = tempdir()) 
[08:28:27.498]                   {
[08:28:27.498]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.498]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.498]                       tmpdir = path, fileext = ".rds")
[08:28:27.498]                     save_rds(obj, file)
[08:28:27.498]                   }
[08:28:27.498]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.498]                   {
[08:28:27.498]                     inherits <- base::inherits
[08:28:27.498]                     invokeRestart <- base::invokeRestart
[08:28:27.498]                     is.null <- base::is.null
[08:28:27.498]                     muffled <- FALSE
[08:28:27.498]                     if (inherits(cond, "message")) {
[08:28:27.498]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.498]                       if (muffled) 
[08:28:27.498]                         invokeRestart("muffleMessage")
[08:28:27.498]                     }
[08:28:27.498]                     else if (inherits(cond, "warning")) {
[08:28:27.498]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.498]                       if (muffled) 
[08:28:27.498]                         invokeRestart("muffleWarning")
[08:28:27.498]                     }
[08:28:27.498]                     else if (inherits(cond, "condition")) {
[08:28:27.498]                       if (!is.null(pattern)) {
[08:28:27.498]                         computeRestarts <- base::computeRestarts
[08:28:27.498]                         grepl <- base::grepl
[08:28:27.498]                         restarts <- computeRestarts(cond)
[08:28:27.498]                         for (restart in restarts) {
[08:28:27.498]                           name <- restart$name
[08:28:27.498]                           if (is.null(name)) 
[08:28:27.498]                             next
[08:28:27.498]                           if (!grepl(pattern, name)) 
[08:28:27.498]                             next
[08:28:27.498]                           invokeRestart(restart)
[08:28:27.498]                           muffled <- TRUE
[08:28:27.498]                           break
[08:28:27.498]                         }
[08:28:27.498]                       }
[08:28:27.498]                     }
[08:28:27.498]                     invisible(muffled)
[08:28:27.498]                   }
[08:28:27.498]                   muffleCondition(cond)
[08:28:27.498]                 })
[08:28:27.498]             }))
[08:28:27.498]             future::FutureResult(value = ...future.value$value, 
[08:28:27.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.498]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.498]                     ...future.globalenv.names))
[08:28:27.498]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.498]         }, condition = base::local({
[08:28:27.498]             c <- base::c
[08:28:27.498]             inherits <- base::inherits
[08:28:27.498]             invokeRestart <- base::invokeRestart
[08:28:27.498]             length <- base::length
[08:28:27.498]             list <- base::list
[08:28:27.498]             seq.int <- base::seq.int
[08:28:27.498]             signalCondition <- base::signalCondition
[08:28:27.498]             sys.calls <- base::sys.calls
[08:28:27.498]             `[[` <- base::`[[`
[08:28:27.498]             `+` <- base::`+`
[08:28:27.498]             `<<-` <- base::`<<-`
[08:28:27.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.498]                   3L)]
[08:28:27.498]             }
[08:28:27.498]             function(cond) {
[08:28:27.498]                 is_error <- inherits(cond, "error")
[08:28:27.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.498]                   NULL)
[08:28:27.498]                 if (is_error) {
[08:28:27.498]                   sessionInformation <- function() {
[08:28:27.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.498]                       search = base::search(), system = base::Sys.info())
[08:28:27.498]                   }
[08:28:27.498]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.498]                     cond$call), session = sessionInformation(), 
[08:28:27.498]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.498]                   signalCondition(cond)
[08:28:27.498]                 }
[08:28:27.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.498]                 "immediateCondition"))) {
[08:28:27.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.498]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.498]                   if (TRUE && !signal) {
[08:28:27.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.498]                     {
[08:28:27.498]                       inherits <- base::inherits
[08:28:27.498]                       invokeRestart <- base::invokeRestart
[08:28:27.498]                       is.null <- base::is.null
[08:28:27.498]                       muffled <- FALSE
[08:28:27.498]                       if (inherits(cond, "message")) {
[08:28:27.498]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.498]                         if (muffled) 
[08:28:27.498]                           invokeRestart("muffleMessage")
[08:28:27.498]                       }
[08:28:27.498]                       else if (inherits(cond, "warning")) {
[08:28:27.498]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.498]                         if (muffled) 
[08:28:27.498]                           invokeRestart("muffleWarning")
[08:28:27.498]                       }
[08:28:27.498]                       else if (inherits(cond, "condition")) {
[08:28:27.498]                         if (!is.null(pattern)) {
[08:28:27.498]                           computeRestarts <- base::computeRestarts
[08:28:27.498]                           grepl <- base::grepl
[08:28:27.498]                           restarts <- computeRestarts(cond)
[08:28:27.498]                           for (restart in restarts) {
[08:28:27.498]                             name <- restart$name
[08:28:27.498]                             if (is.null(name)) 
[08:28:27.498]                               next
[08:28:27.498]                             if (!grepl(pattern, name)) 
[08:28:27.498]                               next
[08:28:27.498]                             invokeRestart(restart)
[08:28:27.498]                             muffled <- TRUE
[08:28:27.498]                             break
[08:28:27.498]                           }
[08:28:27.498]                         }
[08:28:27.498]                       }
[08:28:27.498]                       invisible(muffled)
[08:28:27.498]                     }
[08:28:27.498]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.498]                   }
[08:28:27.498]                 }
[08:28:27.498]                 else {
[08:28:27.498]                   if (TRUE) {
[08:28:27.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.498]                     {
[08:28:27.498]                       inherits <- base::inherits
[08:28:27.498]                       invokeRestart <- base::invokeRestart
[08:28:27.498]                       is.null <- base::is.null
[08:28:27.498]                       muffled <- FALSE
[08:28:27.498]                       if (inherits(cond, "message")) {
[08:28:27.498]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.498]                         if (muffled) 
[08:28:27.498]                           invokeRestart("muffleMessage")
[08:28:27.498]                       }
[08:28:27.498]                       else if (inherits(cond, "warning")) {
[08:28:27.498]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.498]                         if (muffled) 
[08:28:27.498]                           invokeRestart("muffleWarning")
[08:28:27.498]                       }
[08:28:27.498]                       else if (inherits(cond, "condition")) {
[08:28:27.498]                         if (!is.null(pattern)) {
[08:28:27.498]                           computeRestarts <- base::computeRestarts
[08:28:27.498]                           grepl <- base::grepl
[08:28:27.498]                           restarts <- computeRestarts(cond)
[08:28:27.498]                           for (restart in restarts) {
[08:28:27.498]                             name <- restart$name
[08:28:27.498]                             if (is.null(name)) 
[08:28:27.498]                               next
[08:28:27.498]                             if (!grepl(pattern, name)) 
[08:28:27.498]                               next
[08:28:27.498]                             invokeRestart(restart)
[08:28:27.498]                             muffled <- TRUE
[08:28:27.498]                             break
[08:28:27.498]                           }
[08:28:27.498]                         }
[08:28:27.498]                       }
[08:28:27.498]                       invisible(muffled)
[08:28:27.498]                     }
[08:28:27.498]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.498]                   }
[08:28:27.498]                 }
[08:28:27.498]             }
[08:28:27.498]         }))
[08:28:27.498]     }, error = function(ex) {
[08:28:27.498]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.498]                 ...future.rng), started = ...future.startTime, 
[08:28:27.498]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.498]             version = "1.8"), class = "FutureResult")
[08:28:27.498]     }, finally = {
[08:28:27.498]         if (!identical(...future.workdir, getwd())) 
[08:28:27.498]             setwd(...future.workdir)
[08:28:27.498]         {
[08:28:27.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.498]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.498]             }
[08:28:27.498]             base::options(...future.oldOptions)
[08:28:27.498]             if (.Platform$OS.type == "windows") {
[08:28:27.498]                 old_names <- names(...future.oldEnvVars)
[08:28:27.498]                 envs <- base::Sys.getenv()
[08:28:27.498]                 names <- names(envs)
[08:28:27.498]                 common <- intersect(names, old_names)
[08:28:27.498]                 added <- setdiff(names, old_names)
[08:28:27.498]                 removed <- setdiff(old_names, names)
[08:28:27.498]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.498]                   envs[common]]
[08:28:27.498]                 NAMES <- toupper(changed)
[08:28:27.498]                 args <- list()
[08:28:27.498]                 for (kk in seq_along(NAMES)) {
[08:28:27.498]                   name <- changed[[kk]]
[08:28:27.498]                   NAME <- NAMES[[kk]]
[08:28:27.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.498]                     next
[08:28:27.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.498]                 }
[08:28:27.498]                 NAMES <- toupper(added)
[08:28:27.498]                 for (kk in seq_along(NAMES)) {
[08:28:27.498]                   name <- added[[kk]]
[08:28:27.498]                   NAME <- NAMES[[kk]]
[08:28:27.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.498]                     next
[08:28:27.498]                   args[[name]] <- ""
[08:28:27.498]                 }
[08:28:27.498]                 NAMES <- toupper(removed)
[08:28:27.498]                 for (kk in seq_along(NAMES)) {
[08:28:27.498]                   name <- removed[[kk]]
[08:28:27.498]                   NAME <- NAMES[[kk]]
[08:28:27.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.498]                     next
[08:28:27.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.498]                 }
[08:28:27.498]                 if (length(args) > 0) 
[08:28:27.498]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.498]             }
[08:28:27.498]             else {
[08:28:27.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.498]             }
[08:28:27.498]             {
[08:28:27.498]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.498]                   0L) {
[08:28:27.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.498]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.498]                   base::options(opts)
[08:28:27.498]                 }
[08:28:27.498]                 {
[08:28:27.498]                   {
[08:28:27.498]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.498]                     NULL
[08:28:27.498]                   }
[08:28:27.498]                   options(future.plan = NULL)
[08:28:27.498]                   if (is.na(NA_character_)) 
[08:28:27.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.498]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.498]                     .init = FALSE)
[08:28:27.498]                 }
[08:28:27.498]             }
[08:28:27.498]         }
[08:28:27.498]     })
[08:28:27.498]     if (TRUE) {
[08:28:27.498]         base::sink(type = "output", split = FALSE)
[08:28:27.498]         if (TRUE) {
[08:28:27.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.498]         }
[08:28:27.498]         else {
[08:28:27.498]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.498]         }
[08:28:27.498]         base::close(...future.stdout)
[08:28:27.498]         ...future.stdout <- NULL
[08:28:27.498]     }
[08:28:27.498]     ...future.result$conditions <- ...future.conditions
[08:28:27.498]     ...future.result$finished <- base::Sys.time()
[08:28:27.498]     ...future.result
[08:28:27.498] }
[08:28:27.501] assign_globals() ...
[08:28:27.501] List of 1
[08:28:27.501]  $ ii: int 2
[08:28:27.501]  - attr(*, "where")=List of 1
[08:28:27.501]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:27.501]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.501]  - attr(*, "resolved")= logi FALSE
[08:28:27.501]  - attr(*, "total_size")= num 35
[08:28:27.505] - copied ‘ii’ to environment
[08:28:27.505] assign_globals() ... done
[08:28:27.505] requestCore(): workers = 2
[08:28:27.508] MulticoreFuture started
 - Creating multicore future #3 ...
[08:28:27.509] plan(): Setting new future strategy stack:
[08:28:27.509] List of future strategies:
[08:28:27.509] 1. sequential:
[08:28:27.509]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.509]    - tweaked: FALSE
[08:28:27.509]    - call: NULL
[08:28:27.510] plan(): nbrOfWorkers() = 1
[08:28:27.512] getGlobalsAndPackages() ...
[08:28:27.512] Searching for globals...
[08:28:27.512] plan(): Setting new future strategy stack:
[08:28:27.513] List of future strategies:
[08:28:27.513] 1. multicore:
[08:28:27.513]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.513]    - tweaked: FALSE
[08:28:27.513]    - call: plan(multicore)
[08:28:27.514] - globals found: [2] ‘{’, ‘ii’
[08:28:27.514] Searching for globals ... DONE
[08:28:27.514] Resolving globals: FALSE
[08:28:27.515] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:27.515] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:27.515] - globals: [1] ‘ii’
[08:28:27.515] plan(): nbrOfWorkers() = 2
[08:28:27.515] 
[08:28:27.516] getGlobalsAndPackages() ... DONE
[08:28:27.516] Packages needed by the future expression (n = 0): <none>
[08:28:27.517] Packages needed by future strategies (n = 0): <none>
[08:28:27.517] {
[08:28:27.517]     {
[08:28:27.517]         {
[08:28:27.517]             ...future.startTime <- base::Sys.time()
[08:28:27.517]             {
[08:28:27.517]                 {
[08:28:27.517]                   {
[08:28:27.517]                     {
[08:28:27.517]                       base::local({
[08:28:27.517]                         has_future <- base::requireNamespace("future", 
[08:28:27.517]                           quietly = TRUE)
[08:28:27.517]                         if (has_future) {
[08:28:27.517]                           ns <- base::getNamespace("future")
[08:28:27.517]                           version <- ns[[".package"]][["version"]]
[08:28:27.517]                           if (is.null(version)) 
[08:28:27.517]                             version <- utils::packageVersion("future")
[08:28:27.517]                         }
[08:28:27.517]                         else {
[08:28:27.517]                           version <- NULL
[08:28:27.517]                         }
[08:28:27.517]                         if (!has_future || version < "1.8.0") {
[08:28:27.517]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.517]                             "", base::R.version$version.string), 
[08:28:27.517]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.517]                               "release", "version")], collapse = " "), 
[08:28:27.517]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.517]                             info)
[08:28:27.517]                           info <- base::paste(info, collapse = "; ")
[08:28:27.517]                           if (!has_future) {
[08:28:27.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.517]                               info)
[08:28:27.517]                           }
[08:28:27.517]                           else {
[08:28:27.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.517]                               info, version)
[08:28:27.517]                           }
[08:28:27.517]                           base::stop(msg)
[08:28:27.517]                         }
[08:28:27.517]                       })
[08:28:27.517]                     }
[08:28:27.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.517]                     base::options(mc.cores = 1L)
[08:28:27.517]                   }
[08:28:27.517]                   ...future.strategy.old <- future::plan("list")
[08:28:27.517]                   options(future.plan = NULL)
[08:28:27.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.517]                 }
[08:28:27.517]                 ...future.workdir <- getwd()
[08:28:27.517]             }
[08:28:27.517]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.517]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.517]         }
[08:28:27.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.517]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.517]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.517]             base::names(...future.oldOptions))
[08:28:27.517]     }
[08:28:27.517]     if (FALSE) {
[08:28:27.517]     }
[08:28:27.517]     else {
[08:28:27.517]         if (TRUE) {
[08:28:27.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.517]                 open = "w")
[08:28:27.517]         }
[08:28:27.517]         else {
[08:28:27.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.517]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.517]         }
[08:28:27.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.517]             base::sink(type = "output", split = FALSE)
[08:28:27.517]             base::close(...future.stdout)
[08:28:27.517]         }, add = TRUE)
[08:28:27.517]     }
[08:28:27.517]     ...future.frame <- base::sys.nframe()
[08:28:27.517]     ...future.conditions <- base::list()
[08:28:27.517]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.517]     if (FALSE) {
[08:28:27.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.517]     }
[08:28:27.517]     ...future.result <- base::tryCatch({
[08:28:27.517]         base::withCallingHandlers({
[08:28:27.517]             ...future.value <- base::withVisible(base::local({
[08:28:27.517]                 withCallingHandlers({
[08:28:27.517]                   {
[08:28:27.517]                     ii
[08:28:27.517]                   }
[08:28:27.517]                 }, immediateCondition = function(cond) {
[08:28:27.517]                   save_rds <- function (object, pathname, ...) 
[08:28:27.517]                   {
[08:28:27.517]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.517]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.517]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.517]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.517]                         fi_tmp[["mtime"]])
[08:28:27.517]                     }
[08:28:27.517]                     tryCatch({
[08:28:27.517]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.517]                     }, error = function(ex) {
[08:28:27.517]                       msg <- conditionMessage(ex)
[08:28:27.517]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.517]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.517]                         fi_tmp[["mtime"]], msg)
[08:28:27.517]                       ex$message <- msg
[08:28:27.517]                       stop(ex)
[08:28:27.517]                     })
[08:28:27.517]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.517]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.517]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.517]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.517]                       fi <- file.info(pathname)
[08:28:27.517]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.517]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.517]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.517]                         fi[["size"]], fi[["mtime"]])
[08:28:27.517]                       stop(msg)
[08:28:27.517]                     }
[08:28:27.517]                     invisible(pathname)
[08:28:27.517]                   }
[08:28:27.517]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.517]                     rootPath = tempdir()) 
[08:28:27.517]                   {
[08:28:27.517]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.517]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.517]                       tmpdir = path, fileext = ".rds")
[08:28:27.517]                     save_rds(obj, file)
[08:28:27.517]                   }
[08:28:27.517]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.517]                   {
[08:28:27.517]                     inherits <- base::inherits
[08:28:27.517]                     invokeRestart <- base::invokeRestart
[08:28:27.517]                     is.null <- base::is.null
[08:28:27.517]                     muffled <- FALSE
[08:28:27.517]                     if (inherits(cond, "message")) {
[08:28:27.517]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.517]                       if (muffled) 
[08:28:27.517]                         invokeRestart("muffleMessage")
[08:28:27.517]                     }
[08:28:27.517]                     else if (inherits(cond, "warning")) {
[08:28:27.517]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.517]                       if (muffled) 
[08:28:27.517]                         invokeRestart("muffleWarning")
[08:28:27.517]                     }
[08:28:27.517]                     else if (inherits(cond, "condition")) {
[08:28:27.517]                       if (!is.null(pattern)) {
[08:28:27.517]                         computeRestarts <- base::computeRestarts
[08:28:27.517]                         grepl <- base::grepl
[08:28:27.517]                         restarts <- computeRestarts(cond)
[08:28:27.517]                         for (restart in restarts) {
[08:28:27.517]                           name <- restart$name
[08:28:27.517]                           if (is.null(name)) 
[08:28:27.517]                             next
[08:28:27.517]                           if (!grepl(pattern, name)) 
[08:28:27.517]                             next
[08:28:27.517]                           invokeRestart(restart)
[08:28:27.517]                           muffled <- TRUE
[08:28:27.517]                           break
[08:28:27.517]                         }
[08:28:27.517]                       }
[08:28:27.517]                     }
[08:28:27.517]                     invisible(muffled)
[08:28:27.517]                   }
[08:28:27.517]                   muffleCondition(cond)
[08:28:27.517]                 })
[08:28:27.517]             }))
[08:28:27.517]             future::FutureResult(value = ...future.value$value, 
[08:28:27.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.517]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.517]                     ...future.globalenv.names))
[08:28:27.517]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.517]         }, condition = base::local({
[08:28:27.517]             c <- base::c
[08:28:27.517]             inherits <- base::inherits
[08:28:27.517]             invokeRestart <- base::invokeRestart
[08:28:27.517]             length <- base::length
[08:28:27.517]             list <- base::list
[08:28:27.517]             seq.int <- base::seq.int
[08:28:27.517]             signalCondition <- base::signalCondition
[08:28:27.517]             sys.calls <- base::sys.calls
[08:28:27.517]             `[[` <- base::`[[`
[08:28:27.517]             `+` <- base::`+`
[08:28:27.517]             `<<-` <- base::`<<-`
[08:28:27.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.517]                   3L)]
[08:28:27.517]             }
[08:28:27.517]             function(cond) {
[08:28:27.517]                 is_error <- inherits(cond, "error")
[08:28:27.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.517]                   NULL)
[08:28:27.517]                 if (is_error) {
[08:28:27.517]                   sessionInformation <- function() {
[08:28:27.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.517]                       search = base::search(), system = base::Sys.info())
[08:28:27.517]                   }
[08:28:27.517]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.517]                     cond$call), session = sessionInformation(), 
[08:28:27.517]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.517]                   signalCondition(cond)
[08:28:27.517]                 }
[08:28:27.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.517]                 "immediateCondition"))) {
[08:28:27.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.517]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.517]                   if (TRUE && !signal) {
[08:28:27.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.517]                     {
[08:28:27.517]                       inherits <- base::inherits
[08:28:27.517]                       invokeRestart <- base::invokeRestart
[08:28:27.517]                       is.null <- base::is.null
[08:28:27.517]                       muffled <- FALSE
[08:28:27.517]                       if (inherits(cond, "message")) {
[08:28:27.517]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.517]                         if (muffled) 
[08:28:27.517]                           invokeRestart("muffleMessage")
[08:28:27.517]                       }
[08:28:27.517]                       else if (inherits(cond, "warning")) {
[08:28:27.517]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.517]                         if (muffled) 
[08:28:27.517]                           invokeRestart("muffleWarning")
[08:28:27.517]                       }
[08:28:27.517]                       else if (inherits(cond, "condition")) {
[08:28:27.517]                         if (!is.null(pattern)) {
[08:28:27.517]                           computeRestarts <- base::computeRestarts
[08:28:27.517]                           grepl <- base::grepl
[08:28:27.517]                           restarts <- computeRestarts(cond)
[08:28:27.517]                           for (restart in restarts) {
[08:28:27.517]                             name <- restart$name
[08:28:27.517]                             if (is.null(name)) 
[08:28:27.517]                               next
[08:28:27.517]                             if (!grepl(pattern, name)) 
[08:28:27.517]                               next
[08:28:27.517]                             invokeRestart(restart)
[08:28:27.517]                             muffled <- TRUE
[08:28:27.517]                             break
[08:28:27.517]                           }
[08:28:27.517]                         }
[08:28:27.517]                       }
[08:28:27.517]                       invisible(muffled)
[08:28:27.517]                     }
[08:28:27.517]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.517]                   }
[08:28:27.517]                 }
[08:28:27.517]                 else {
[08:28:27.517]                   if (TRUE) {
[08:28:27.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.517]                     {
[08:28:27.517]                       inherits <- base::inherits
[08:28:27.517]                       invokeRestart <- base::invokeRestart
[08:28:27.517]                       is.null <- base::is.null
[08:28:27.517]                       muffled <- FALSE
[08:28:27.517]                       if (inherits(cond, "message")) {
[08:28:27.517]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.517]                         if (muffled) 
[08:28:27.517]                           invokeRestart("muffleMessage")
[08:28:27.517]                       }
[08:28:27.517]                       else if (inherits(cond, "warning")) {
[08:28:27.517]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.517]                         if (muffled) 
[08:28:27.517]                           invokeRestart("muffleWarning")
[08:28:27.517]                       }
[08:28:27.517]                       else if (inherits(cond, "condition")) {
[08:28:27.517]                         if (!is.null(pattern)) {
[08:28:27.517]                           computeRestarts <- base::computeRestarts
[08:28:27.517]                           grepl <- base::grepl
[08:28:27.517]                           restarts <- computeRestarts(cond)
[08:28:27.517]                           for (restart in restarts) {
[08:28:27.517]                             name <- restart$name
[08:28:27.517]                             if (is.null(name)) 
[08:28:27.517]                               next
[08:28:27.517]                             if (!grepl(pattern, name)) 
[08:28:27.517]                               next
[08:28:27.517]                             invokeRestart(restart)
[08:28:27.517]                             muffled <- TRUE
[08:28:27.517]                             break
[08:28:27.517]                           }
[08:28:27.517]                         }
[08:28:27.517]                       }
[08:28:27.517]                       invisible(muffled)
[08:28:27.517]                     }
[08:28:27.517]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.517]                   }
[08:28:27.517]                 }
[08:28:27.517]             }
[08:28:27.517]         }))
[08:28:27.517]     }, error = function(ex) {
[08:28:27.517]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.517]                 ...future.rng), started = ...future.startTime, 
[08:28:27.517]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.517]             version = "1.8"), class = "FutureResult")
[08:28:27.517]     }, finally = {
[08:28:27.517]         if (!identical(...future.workdir, getwd())) 
[08:28:27.517]             setwd(...future.workdir)
[08:28:27.517]         {
[08:28:27.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.517]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.517]             }
[08:28:27.517]             base::options(...future.oldOptions)
[08:28:27.517]             if (.Platform$OS.type == "windows") {
[08:28:27.517]                 old_names <- names(...future.oldEnvVars)
[08:28:27.517]                 envs <- base::Sys.getenv()
[08:28:27.517]                 names <- names(envs)
[08:28:27.517]                 common <- intersect(names, old_names)
[08:28:27.517]                 added <- setdiff(names, old_names)
[08:28:27.517]                 removed <- setdiff(old_names, names)
[08:28:27.517]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.517]                   envs[common]]
[08:28:27.517]                 NAMES <- toupper(changed)
[08:28:27.517]                 args <- list()
[08:28:27.517]                 for (kk in seq_along(NAMES)) {
[08:28:27.517]                   name <- changed[[kk]]
[08:28:27.517]                   NAME <- NAMES[[kk]]
[08:28:27.517]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.517]                     next
[08:28:27.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.517]                 }
[08:28:27.517]                 NAMES <- toupper(added)
[08:28:27.517]                 for (kk in seq_along(NAMES)) {
[08:28:27.517]                   name <- added[[kk]]
[08:28:27.517]                   NAME <- NAMES[[kk]]
[08:28:27.517]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.517]                     next
[08:28:27.517]                   args[[name]] <- ""
[08:28:27.517]                 }
[08:28:27.517]                 NAMES <- toupper(removed)
[08:28:27.517]                 for (kk in seq_along(NAMES)) {
[08:28:27.517]                   name <- removed[[kk]]
[08:28:27.517]                   NAME <- NAMES[[kk]]
[08:28:27.517]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.517]                     next
[08:28:27.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.517]                 }
[08:28:27.517]                 if (length(args) > 0) 
[08:28:27.517]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.517]             }
[08:28:27.517]             else {
[08:28:27.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.517]             }
[08:28:27.517]             {
[08:28:27.517]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.517]                   0L) {
[08:28:27.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.517]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.517]                   base::options(opts)
[08:28:27.517]                 }
[08:28:27.517]                 {
[08:28:27.517]                   {
[08:28:27.517]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.517]                     NULL
[08:28:27.517]                   }
[08:28:27.517]                   options(future.plan = NULL)
[08:28:27.517]                   if (is.na(NA_character_)) 
[08:28:27.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.517]                     .init = FALSE)
[08:28:27.517]                 }
[08:28:27.517]             }
[08:28:27.517]         }
[08:28:27.517]     })
[08:28:27.517]     if (TRUE) {
[08:28:27.517]         base::sink(type = "output", split = FALSE)
[08:28:27.517]         if (TRUE) {
[08:28:27.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.517]         }
[08:28:27.517]         else {
[08:28:27.517]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.517]         }
[08:28:27.517]         base::close(...future.stdout)
[08:28:27.517]         ...future.stdout <- NULL
[08:28:27.517]     }
[08:28:27.517]     ...future.result$conditions <- ...future.conditions
[08:28:27.517]     ...future.result$finished <- base::Sys.time()
[08:28:27.517]     ...future.result
[08:28:27.517] }
[08:28:27.521] assign_globals() ...
[08:28:27.521] List of 1
[08:28:27.521]  $ ii: int 3
[08:28:27.521]  - attr(*, "where")=List of 1
[08:28:27.521]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:27.521]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.521]  - attr(*, "resolved")= logi FALSE
[08:28:27.521]  - attr(*, "total_size")= num 35
[08:28:27.524] - copied ‘ii’ to environment
[08:28:27.524] assign_globals() ... done
[08:28:27.525] requestCore(): workers = 2
[08:28:27.525] Poll #1 (0): usedCores() = 2, workers = 2
[08:28:27.536] result() for MulticoreFuture ...
[08:28:27.537] result() for MulticoreFuture ...
[08:28:27.537] result() for MulticoreFuture ... done
[08:28:27.537] result() for MulticoreFuture ... done
[08:28:27.537] result() for MulticoreFuture ...
[08:28:27.537] result() for MulticoreFuture ... done
[08:28:27.540] MulticoreFuture started
 - Creating multicore future #4 ...
[08:28:27.541] plan(): Setting new future strategy stack:
[08:28:27.541] List of future strategies:
[08:28:27.541] 1. sequential:
[08:28:27.541]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.541]    - tweaked: FALSE
[08:28:27.541]    - call: NULL
[08:28:27.549] plan(): nbrOfWorkers() = 1
[08:28:27.551] getGlobalsAndPackages() ...
[08:28:27.551] Searching for globals...
[08:28:27.552] plan(): Setting new future strategy stack:
[08:28:27.552] List of future strategies:
[08:28:27.552] 1. multicore:
[08:28:27.552]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.552]    - tweaked: FALSE
[08:28:27.552]    - call: plan(multicore)
[08:28:27.553] - globals found: [2] ‘{’, ‘ii’
[08:28:27.554] Searching for globals ... DONE
[08:28:27.554] Resolving globals: FALSE
[08:28:27.555] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:27.556] The total size of the 1 globals exported for future expression (‘{; ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:27.556] - globals: [1] ‘ii’
[08:28:27.556] plan(): nbrOfWorkers() = 2
[08:28:27.556] 
[08:28:27.557] getGlobalsAndPackages() ... DONE
[08:28:27.558] Packages needed by the future expression (n = 0): <none>
[08:28:27.558] Packages needed by future strategies (n = 0): <none>
[08:28:27.559] {
[08:28:27.559]     {
[08:28:27.559]         {
[08:28:27.559]             ...future.startTime <- base::Sys.time()
[08:28:27.559]             {
[08:28:27.559]                 {
[08:28:27.559]                   {
[08:28:27.559]                     {
[08:28:27.559]                       base::local({
[08:28:27.559]                         has_future <- base::requireNamespace("future", 
[08:28:27.559]                           quietly = TRUE)
[08:28:27.559]                         if (has_future) {
[08:28:27.559]                           ns <- base::getNamespace("future")
[08:28:27.559]                           version <- ns[[".package"]][["version"]]
[08:28:27.559]                           if (is.null(version)) 
[08:28:27.559]                             version <- utils::packageVersion("future")
[08:28:27.559]                         }
[08:28:27.559]                         else {
[08:28:27.559]                           version <- NULL
[08:28:27.559]                         }
[08:28:27.559]                         if (!has_future || version < "1.8.0") {
[08:28:27.559]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.559]                             "", base::R.version$version.string), 
[08:28:27.559]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.559]                               "release", "version")], collapse = " "), 
[08:28:27.559]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.559]                             info)
[08:28:27.559]                           info <- base::paste(info, collapse = "; ")
[08:28:27.559]                           if (!has_future) {
[08:28:27.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.559]                               info)
[08:28:27.559]                           }
[08:28:27.559]                           else {
[08:28:27.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.559]                               info, version)
[08:28:27.559]                           }
[08:28:27.559]                           base::stop(msg)
[08:28:27.559]                         }
[08:28:27.559]                       })
[08:28:27.559]                     }
[08:28:27.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.559]                     base::options(mc.cores = 1L)
[08:28:27.559]                   }
[08:28:27.559]                   ...future.strategy.old <- future::plan("list")
[08:28:27.559]                   options(future.plan = NULL)
[08:28:27.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.559]                 }
[08:28:27.559]                 ...future.workdir <- getwd()
[08:28:27.559]             }
[08:28:27.559]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.559]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.559]         }
[08:28:27.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.559]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.559]             base::names(...future.oldOptions))
[08:28:27.559]     }
[08:28:27.559]     if (FALSE) {
[08:28:27.559]     }
[08:28:27.559]     else {
[08:28:27.559]         if (TRUE) {
[08:28:27.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.559]                 open = "w")
[08:28:27.559]         }
[08:28:27.559]         else {
[08:28:27.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.559]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.559]         }
[08:28:27.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.559]             base::sink(type = "output", split = FALSE)
[08:28:27.559]             base::close(...future.stdout)
[08:28:27.559]         }, add = TRUE)
[08:28:27.559]     }
[08:28:27.559]     ...future.frame <- base::sys.nframe()
[08:28:27.559]     ...future.conditions <- base::list()
[08:28:27.559]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.559]     if (FALSE) {
[08:28:27.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.559]     }
[08:28:27.559]     ...future.result <- base::tryCatch({
[08:28:27.559]         base::withCallingHandlers({
[08:28:27.559]             ...future.value <- base::withVisible(base::local({
[08:28:27.559]                 withCallingHandlers({
[08:28:27.559]                   {
[08:28:27.559]                     ii
[08:28:27.559]                   }
[08:28:27.559]                 }, immediateCondition = function(cond) {
[08:28:27.559]                   save_rds <- function (object, pathname, ...) 
[08:28:27.559]                   {
[08:28:27.559]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.559]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.559]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.559]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.559]                         fi_tmp[["mtime"]])
[08:28:27.559]                     }
[08:28:27.559]                     tryCatch({
[08:28:27.559]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.559]                     }, error = function(ex) {
[08:28:27.559]                       msg <- conditionMessage(ex)
[08:28:27.559]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.559]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.559]                         fi_tmp[["mtime"]], msg)
[08:28:27.559]                       ex$message <- msg
[08:28:27.559]                       stop(ex)
[08:28:27.559]                     })
[08:28:27.559]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.559]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.559]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.559]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.559]                       fi <- file.info(pathname)
[08:28:27.559]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.559]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.559]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.559]                         fi[["size"]], fi[["mtime"]])
[08:28:27.559]                       stop(msg)
[08:28:27.559]                     }
[08:28:27.559]                     invisible(pathname)
[08:28:27.559]                   }
[08:28:27.559]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.559]                     rootPath = tempdir()) 
[08:28:27.559]                   {
[08:28:27.559]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.559]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.559]                       tmpdir = path, fileext = ".rds")
[08:28:27.559]                     save_rds(obj, file)
[08:28:27.559]                   }
[08:28:27.559]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.559]                   {
[08:28:27.559]                     inherits <- base::inherits
[08:28:27.559]                     invokeRestart <- base::invokeRestart
[08:28:27.559]                     is.null <- base::is.null
[08:28:27.559]                     muffled <- FALSE
[08:28:27.559]                     if (inherits(cond, "message")) {
[08:28:27.559]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.559]                       if (muffled) 
[08:28:27.559]                         invokeRestart("muffleMessage")
[08:28:27.559]                     }
[08:28:27.559]                     else if (inherits(cond, "warning")) {
[08:28:27.559]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.559]                       if (muffled) 
[08:28:27.559]                         invokeRestart("muffleWarning")
[08:28:27.559]                     }
[08:28:27.559]                     else if (inherits(cond, "condition")) {
[08:28:27.559]                       if (!is.null(pattern)) {
[08:28:27.559]                         computeRestarts <- base::computeRestarts
[08:28:27.559]                         grepl <- base::grepl
[08:28:27.559]                         restarts <- computeRestarts(cond)
[08:28:27.559]                         for (restart in restarts) {
[08:28:27.559]                           name <- restart$name
[08:28:27.559]                           if (is.null(name)) 
[08:28:27.559]                             next
[08:28:27.559]                           if (!grepl(pattern, name)) 
[08:28:27.559]                             next
[08:28:27.559]                           invokeRestart(restart)
[08:28:27.559]                           muffled <- TRUE
[08:28:27.559]                           break
[08:28:27.559]                         }
[08:28:27.559]                       }
[08:28:27.559]                     }
[08:28:27.559]                     invisible(muffled)
[08:28:27.559]                   }
[08:28:27.559]                   muffleCondition(cond)
[08:28:27.559]                 })
[08:28:27.559]             }))
[08:28:27.559]             future::FutureResult(value = ...future.value$value, 
[08:28:27.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.559]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.559]                     ...future.globalenv.names))
[08:28:27.559]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.559]         }, condition = base::local({
[08:28:27.559]             c <- base::c
[08:28:27.559]             inherits <- base::inherits
[08:28:27.559]             invokeRestart <- base::invokeRestart
[08:28:27.559]             length <- base::length
[08:28:27.559]             list <- base::list
[08:28:27.559]             seq.int <- base::seq.int
[08:28:27.559]             signalCondition <- base::signalCondition
[08:28:27.559]             sys.calls <- base::sys.calls
[08:28:27.559]             `[[` <- base::`[[`
[08:28:27.559]             `+` <- base::`+`
[08:28:27.559]             `<<-` <- base::`<<-`
[08:28:27.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.559]                   3L)]
[08:28:27.559]             }
[08:28:27.559]             function(cond) {
[08:28:27.559]                 is_error <- inherits(cond, "error")
[08:28:27.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.559]                   NULL)
[08:28:27.559]                 if (is_error) {
[08:28:27.559]                   sessionInformation <- function() {
[08:28:27.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.559]                       search = base::search(), system = base::Sys.info())
[08:28:27.559]                   }
[08:28:27.559]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.559]                     cond$call), session = sessionInformation(), 
[08:28:27.559]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.559]                   signalCondition(cond)
[08:28:27.559]                 }
[08:28:27.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.559]                 "immediateCondition"))) {
[08:28:27.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.559]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.559]                   if (TRUE && !signal) {
[08:28:27.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.559]                     {
[08:28:27.559]                       inherits <- base::inherits
[08:28:27.559]                       invokeRestart <- base::invokeRestart
[08:28:27.559]                       is.null <- base::is.null
[08:28:27.559]                       muffled <- FALSE
[08:28:27.559]                       if (inherits(cond, "message")) {
[08:28:27.559]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.559]                         if (muffled) 
[08:28:27.559]                           invokeRestart("muffleMessage")
[08:28:27.559]                       }
[08:28:27.559]                       else if (inherits(cond, "warning")) {
[08:28:27.559]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.559]                         if (muffled) 
[08:28:27.559]                           invokeRestart("muffleWarning")
[08:28:27.559]                       }
[08:28:27.559]                       else if (inherits(cond, "condition")) {
[08:28:27.559]                         if (!is.null(pattern)) {
[08:28:27.559]                           computeRestarts <- base::computeRestarts
[08:28:27.559]                           grepl <- base::grepl
[08:28:27.559]                           restarts <- computeRestarts(cond)
[08:28:27.559]                           for (restart in restarts) {
[08:28:27.559]                             name <- restart$name
[08:28:27.559]                             if (is.null(name)) 
[08:28:27.559]                               next
[08:28:27.559]                             if (!grepl(pattern, name)) 
[08:28:27.559]                               next
[08:28:27.559]                             invokeRestart(restart)
[08:28:27.559]                             muffled <- TRUE
[08:28:27.559]                             break
[08:28:27.559]                           }
[08:28:27.559]                         }
[08:28:27.559]                       }
[08:28:27.559]                       invisible(muffled)
[08:28:27.559]                     }
[08:28:27.559]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.559]                   }
[08:28:27.559]                 }
[08:28:27.559]                 else {
[08:28:27.559]                   if (TRUE) {
[08:28:27.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.559]                     {
[08:28:27.559]                       inherits <- base::inherits
[08:28:27.559]                       invokeRestart <- base::invokeRestart
[08:28:27.559]                       is.null <- base::is.null
[08:28:27.559]                       muffled <- FALSE
[08:28:27.559]                       if (inherits(cond, "message")) {
[08:28:27.559]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.559]                         if (muffled) 
[08:28:27.559]                           invokeRestart("muffleMessage")
[08:28:27.559]                       }
[08:28:27.559]                       else if (inherits(cond, "warning")) {
[08:28:27.559]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.559]                         if (muffled) 
[08:28:27.559]                           invokeRestart("muffleWarning")
[08:28:27.559]                       }
[08:28:27.559]                       else if (inherits(cond, "condition")) {
[08:28:27.559]                         if (!is.null(pattern)) {
[08:28:27.559]                           computeRestarts <- base::computeRestarts
[08:28:27.559]                           grepl <- base::grepl
[08:28:27.559]                           restarts <- computeRestarts(cond)
[08:28:27.559]                           for (restart in restarts) {
[08:28:27.559]                             name <- restart$name
[08:28:27.559]                             if (is.null(name)) 
[08:28:27.559]                               next
[08:28:27.559]                             if (!grepl(pattern, name)) 
[08:28:27.559]                               next
[08:28:27.559]                             invokeRestart(restart)
[08:28:27.559]                             muffled <- TRUE
[08:28:27.559]                             break
[08:28:27.559]                           }
[08:28:27.559]                         }
[08:28:27.559]                       }
[08:28:27.559]                       invisible(muffled)
[08:28:27.559]                     }
[08:28:27.559]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.559]                   }
[08:28:27.559]                 }
[08:28:27.559]             }
[08:28:27.559]         }))
[08:28:27.559]     }, error = function(ex) {
[08:28:27.559]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.559]                 ...future.rng), started = ...future.startTime, 
[08:28:27.559]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.559]             version = "1.8"), class = "FutureResult")
[08:28:27.559]     }, finally = {
[08:28:27.559]         if (!identical(...future.workdir, getwd())) 
[08:28:27.559]             setwd(...future.workdir)
[08:28:27.559]         {
[08:28:27.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.559]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.559]             }
[08:28:27.559]             base::options(...future.oldOptions)
[08:28:27.559]             if (.Platform$OS.type == "windows") {
[08:28:27.559]                 old_names <- names(...future.oldEnvVars)
[08:28:27.559]                 envs <- base::Sys.getenv()
[08:28:27.559]                 names <- names(envs)
[08:28:27.559]                 common <- intersect(names, old_names)
[08:28:27.559]                 added <- setdiff(names, old_names)
[08:28:27.559]                 removed <- setdiff(old_names, names)
[08:28:27.559]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.559]                   envs[common]]
[08:28:27.559]                 NAMES <- toupper(changed)
[08:28:27.559]                 args <- list()
[08:28:27.559]                 for (kk in seq_along(NAMES)) {
[08:28:27.559]                   name <- changed[[kk]]
[08:28:27.559]                   NAME <- NAMES[[kk]]
[08:28:27.559]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.559]                     next
[08:28:27.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.559]                 }
[08:28:27.559]                 NAMES <- toupper(added)
[08:28:27.559]                 for (kk in seq_along(NAMES)) {
[08:28:27.559]                   name <- added[[kk]]
[08:28:27.559]                   NAME <- NAMES[[kk]]
[08:28:27.559]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.559]                     next
[08:28:27.559]                   args[[name]] <- ""
[08:28:27.559]                 }
[08:28:27.559]                 NAMES <- toupper(removed)
[08:28:27.559]                 for (kk in seq_along(NAMES)) {
[08:28:27.559]                   name <- removed[[kk]]
[08:28:27.559]                   NAME <- NAMES[[kk]]
[08:28:27.559]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.559]                     next
[08:28:27.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.559]                 }
[08:28:27.559]                 if (length(args) > 0) 
[08:28:27.559]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.559]             }
[08:28:27.559]             else {
[08:28:27.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.559]             }
[08:28:27.559]             {
[08:28:27.559]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.559]                   0L) {
[08:28:27.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.559]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.559]                   base::options(opts)
[08:28:27.559]                 }
[08:28:27.559]                 {
[08:28:27.559]                   {
[08:28:27.559]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.559]                     NULL
[08:28:27.559]                   }
[08:28:27.559]                   options(future.plan = NULL)
[08:28:27.559]                   if (is.na(NA_character_)) 
[08:28:27.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.559]                     .init = FALSE)
[08:28:27.559]                 }
[08:28:27.559]             }
[08:28:27.559]         }
[08:28:27.559]     })
[08:28:27.559]     if (TRUE) {
[08:28:27.559]         base::sink(type = "output", split = FALSE)
[08:28:27.559]         if (TRUE) {
[08:28:27.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.559]         }
[08:28:27.559]         else {
[08:28:27.559]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.559]         }
[08:28:27.559]         base::close(...future.stdout)
[08:28:27.559]         ...future.stdout <- NULL
[08:28:27.559]     }
[08:28:27.559]     ...future.result$conditions <- ...future.conditions
[08:28:27.559]     ...future.result$finished <- base::Sys.time()
[08:28:27.559]     ...future.result
[08:28:27.559] }
[08:28:27.562] assign_globals() ...
[08:28:27.562] List of 1
[08:28:27.562]  $ ii: int 4
[08:28:27.562]  - attr(*, "where")=List of 1
[08:28:27.562]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:27.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.562]  - attr(*, "resolved")= logi FALSE
[08:28:27.562]  - attr(*, "total_size")= num 35
[08:28:27.566] - copied ‘ii’ to environment
[08:28:27.567] assign_globals() ... done
[08:28:27.567] requestCore(): workers = 2
[08:28:27.567] Poll #1 (0): usedCores() = 2, workers = 2
[08:28:27.578] result() for MulticoreFuture ...
[08:28:27.579] result() for MulticoreFuture ...
[08:28:27.579] result() for MulticoreFuture ... done
[08:28:27.579] result() for MulticoreFuture ... done
[08:28:27.579] result() for MulticoreFuture ...
[08:28:27.579] result() for MulticoreFuture ... done
[08:28:27.582] MulticoreFuture started
 - Resolving 4 multicore futures
[08:28:27.583] result() for MulticoreFuture ...
[08:28:27.583] plan(): Setting new future strategy stack:
[08:28:27.583] result() for MulticoreFuture ... done
[08:28:27.584] result() for MulticoreFuture ...
[08:28:27.584] result() for MulticoreFuture ... done
[08:28:27.584] result() for MulticoreFuture ...
[08:28:27.584] result() for MulticoreFuture ... done
[08:28:27.584] result() for MulticoreFuture ...
[08:28:27.583] List of future strategies:
[08:28:27.583] 1. sequential:
[08:28:27.583]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.583]    - tweaked: FALSE
[08:28:27.583]    - call: NULL
[08:28:27.585] result() for MulticoreFuture ... done
[08:28:27.585] result() for MulticoreFuture ...
[08:28:27.585] plan(): nbrOfWorkers() = 1
[08:28:27.587] result() for MulticoreFuture ...
[08:28:27.587] result() for MulticoreFuture ... done
[08:28:27.587] result() for MulticoreFuture ... done
[08:28:27.587] result() for MulticoreFuture ...
[08:28:27.587] result() for MulticoreFuture ... done
[08:28:27.588] result() for MulticoreFuture ...
[08:28:27.588] plan(): Setting new future strategy stack:
[08:28:27.588] List of future strategies:
[08:28:27.588] 1. multicore:
[08:28:27.588]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.588]    - tweaked: FALSE
[08:28:27.588]    - call: plan(multicore)
[08:28:27.591] plan(): nbrOfWorkers() = 2
[08:28:27.592] result() for MulticoreFuture ...
[08:28:27.592] result() for MulticoreFuture ... done
[08:28:27.592] result() for MulticoreFuture ... done
[08:28:27.593] result() for MulticoreFuture ...
[08:28:27.593] result() for MulticoreFuture ... done
*** multicore(..., globals = TRUE) and errors
[08:28:27.596] getGlobalsAndPackages() ...
[08:28:27.596] Searching for globals...
[08:28:27.597] - globals found: [2] ‘{’, ‘stop’
[08:28:27.597] Searching for globals ... DONE
[08:28:27.598] Resolving globals: FALSE
[08:28:27.598] 
[08:28:27.598] 
[08:28:27.598] getGlobalsAndPackages() ... DONE
[08:28:27.599] Packages needed by the future expression (n = 0): <none>
[08:28:27.599] Packages needed by future strategies (n = 0): <none>
[08:28:27.600] {
[08:28:27.600]     {
[08:28:27.600]         {
[08:28:27.600]             ...future.startTime <- base::Sys.time()
[08:28:27.600]             {
[08:28:27.600]                 {
[08:28:27.600]                   {
[08:28:27.600]                     {
[08:28:27.600]                       base::local({
[08:28:27.600]                         has_future <- base::requireNamespace("future", 
[08:28:27.600]                           quietly = TRUE)
[08:28:27.600]                         if (has_future) {
[08:28:27.600]                           ns <- base::getNamespace("future")
[08:28:27.600]                           version <- ns[[".package"]][["version"]]
[08:28:27.600]                           if (is.null(version)) 
[08:28:27.600]                             version <- utils::packageVersion("future")
[08:28:27.600]                         }
[08:28:27.600]                         else {
[08:28:27.600]                           version <- NULL
[08:28:27.600]                         }
[08:28:27.600]                         if (!has_future || version < "1.8.0") {
[08:28:27.600]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.600]                             "", base::R.version$version.string), 
[08:28:27.600]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.600]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.600]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.600]                               "release", "version")], collapse = " "), 
[08:28:27.600]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.600]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.600]                             info)
[08:28:27.600]                           info <- base::paste(info, collapse = "; ")
[08:28:27.600]                           if (!has_future) {
[08:28:27.600]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.600]                               info)
[08:28:27.600]                           }
[08:28:27.600]                           else {
[08:28:27.600]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.600]                               info, version)
[08:28:27.600]                           }
[08:28:27.600]                           base::stop(msg)
[08:28:27.600]                         }
[08:28:27.600]                       })
[08:28:27.600]                     }
[08:28:27.600]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.600]                     base::options(mc.cores = 1L)
[08:28:27.600]                   }
[08:28:27.600]                   ...future.strategy.old <- future::plan("list")
[08:28:27.600]                   options(future.plan = NULL)
[08:28:27.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.600]                 }
[08:28:27.600]                 ...future.workdir <- getwd()
[08:28:27.600]             }
[08:28:27.600]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.600]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.600]         }
[08:28:27.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.600]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.600]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.600]             base::names(...future.oldOptions))
[08:28:27.600]     }
[08:28:27.600]     if (FALSE) {
[08:28:27.600]     }
[08:28:27.600]     else {
[08:28:27.600]         if (TRUE) {
[08:28:27.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.600]                 open = "w")
[08:28:27.600]         }
[08:28:27.600]         else {
[08:28:27.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.600]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.600]         }
[08:28:27.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.600]             base::sink(type = "output", split = FALSE)
[08:28:27.600]             base::close(...future.stdout)
[08:28:27.600]         }, add = TRUE)
[08:28:27.600]     }
[08:28:27.600]     ...future.frame <- base::sys.nframe()
[08:28:27.600]     ...future.conditions <- base::list()
[08:28:27.600]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.600]     if (FALSE) {
[08:28:27.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.600]     }
[08:28:27.600]     ...future.result <- base::tryCatch({
[08:28:27.600]         base::withCallingHandlers({
[08:28:27.600]             ...future.value <- base::withVisible(base::local({
[08:28:27.600]                 withCallingHandlers({
[08:28:27.600]                   {
[08:28:27.600]                     stop("Whoops!")
[08:28:27.600]                     1
[08:28:27.600]                   }
[08:28:27.600]                 }, immediateCondition = function(cond) {
[08:28:27.600]                   save_rds <- function (object, pathname, ...) 
[08:28:27.600]                   {
[08:28:27.600]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.600]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.600]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.600]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.600]                         fi_tmp[["mtime"]])
[08:28:27.600]                     }
[08:28:27.600]                     tryCatch({
[08:28:27.600]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.600]                     }, error = function(ex) {
[08:28:27.600]                       msg <- conditionMessage(ex)
[08:28:27.600]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.600]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.600]                         fi_tmp[["mtime"]], msg)
[08:28:27.600]                       ex$message <- msg
[08:28:27.600]                       stop(ex)
[08:28:27.600]                     })
[08:28:27.600]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.600]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.600]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.600]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.600]                       fi <- file.info(pathname)
[08:28:27.600]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.600]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.600]                         fi[["size"]], fi[["mtime"]])
[08:28:27.600]                       stop(msg)
[08:28:27.600]                     }
[08:28:27.600]                     invisible(pathname)
[08:28:27.600]                   }
[08:28:27.600]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.600]                     rootPath = tempdir()) 
[08:28:27.600]                   {
[08:28:27.600]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.600]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.600]                       tmpdir = path, fileext = ".rds")
[08:28:27.600]                     save_rds(obj, file)
[08:28:27.600]                   }
[08:28:27.600]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.600]                   {
[08:28:27.600]                     inherits <- base::inherits
[08:28:27.600]                     invokeRestart <- base::invokeRestart
[08:28:27.600]                     is.null <- base::is.null
[08:28:27.600]                     muffled <- FALSE
[08:28:27.600]                     if (inherits(cond, "message")) {
[08:28:27.600]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.600]                       if (muffled) 
[08:28:27.600]                         invokeRestart("muffleMessage")
[08:28:27.600]                     }
[08:28:27.600]                     else if (inherits(cond, "warning")) {
[08:28:27.600]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.600]                       if (muffled) 
[08:28:27.600]                         invokeRestart("muffleWarning")
[08:28:27.600]                     }
[08:28:27.600]                     else if (inherits(cond, "condition")) {
[08:28:27.600]                       if (!is.null(pattern)) {
[08:28:27.600]                         computeRestarts <- base::computeRestarts
[08:28:27.600]                         grepl <- base::grepl
[08:28:27.600]                         restarts <- computeRestarts(cond)
[08:28:27.600]                         for (restart in restarts) {
[08:28:27.600]                           name <- restart$name
[08:28:27.600]                           if (is.null(name)) 
[08:28:27.600]                             next
[08:28:27.600]                           if (!grepl(pattern, name)) 
[08:28:27.600]                             next
[08:28:27.600]                           invokeRestart(restart)
[08:28:27.600]                           muffled <- TRUE
[08:28:27.600]                           break
[08:28:27.600]                         }
[08:28:27.600]                       }
[08:28:27.600]                     }
[08:28:27.600]                     invisible(muffled)
[08:28:27.600]                   }
[08:28:27.600]                   muffleCondition(cond)
[08:28:27.600]                 })
[08:28:27.600]             }))
[08:28:27.600]             future::FutureResult(value = ...future.value$value, 
[08:28:27.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.600]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.600]                     ...future.globalenv.names))
[08:28:27.600]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.600]         }, condition = base::local({
[08:28:27.600]             c <- base::c
[08:28:27.600]             inherits <- base::inherits
[08:28:27.600]             invokeRestart <- base::invokeRestart
[08:28:27.600]             length <- base::length
[08:28:27.600]             list <- base::list
[08:28:27.600]             seq.int <- base::seq.int
[08:28:27.600]             signalCondition <- base::signalCondition
[08:28:27.600]             sys.calls <- base::sys.calls
[08:28:27.600]             `[[` <- base::`[[`
[08:28:27.600]             `+` <- base::`+`
[08:28:27.600]             `<<-` <- base::`<<-`
[08:28:27.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.600]                   3L)]
[08:28:27.600]             }
[08:28:27.600]             function(cond) {
[08:28:27.600]                 is_error <- inherits(cond, "error")
[08:28:27.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.600]                   NULL)
[08:28:27.600]                 if (is_error) {
[08:28:27.600]                   sessionInformation <- function() {
[08:28:27.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.600]                       search = base::search(), system = base::Sys.info())
[08:28:27.600]                   }
[08:28:27.600]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.600]                     cond$call), session = sessionInformation(), 
[08:28:27.600]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.600]                   signalCondition(cond)
[08:28:27.600]                 }
[08:28:27.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.600]                 "immediateCondition"))) {
[08:28:27.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.600]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.600]                   if (TRUE && !signal) {
[08:28:27.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.600]                     {
[08:28:27.600]                       inherits <- base::inherits
[08:28:27.600]                       invokeRestart <- base::invokeRestart
[08:28:27.600]                       is.null <- base::is.null
[08:28:27.600]                       muffled <- FALSE
[08:28:27.600]                       if (inherits(cond, "message")) {
[08:28:27.600]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.600]                         if (muffled) 
[08:28:27.600]                           invokeRestart("muffleMessage")
[08:28:27.600]                       }
[08:28:27.600]                       else if (inherits(cond, "warning")) {
[08:28:27.600]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.600]                         if (muffled) 
[08:28:27.600]                           invokeRestart("muffleWarning")
[08:28:27.600]                       }
[08:28:27.600]                       else if (inherits(cond, "condition")) {
[08:28:27.600]                         if (!is.null(pattern)) {
[08:28:27.600]                           computeRestarts <- base::computeRestarts
[08:28:27.600]                           grepl <- base::grepl
[08:28:27.600]                           restarts <- computeRestarts(cond)
[08:28:27.600]                           for (restart in restarts) {
[08:28:27.600]                             name <- restart$name
[08:28:27.600]                             if (is.null(name)) 
[08:28:27.600]                               next
[08:28:27.600]                             if (!grepl(pattern, name)) 
[08:28:27.600]                               next
[08:28:27.600]                             invokeRestart(restart)
[08:28:27.600]                             muffled <- TRUE
[08:28:27.600]                             break
[08:28:27.600]                           }
[08:28:27.600]                         }
[08:28:27.600]                       }
[08:28:27.600]                       invisible(muffled)
[08:28:27.600]                     }
[08:28:27.600]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.600]                   }
[08:28:27.600]                 }
[08:28:27.600]                 else {
[08:28:27.600]                   if (TRUE) {
[08:28:27.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.600]                     {
[08:28:27.600]                       inherits <- base::inherits
[08:28:27.600]                       invokeRestart <- base::invokeRestart
[08:28:27.600]                       is.null <- base::is.null
[08:28:27.600]                       muffled <- FALSE
[08:28:27.600]                       if (inherits(cond, "message")) {
[08:28:27.600]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.600]                         if (muffled) 
[08:28:27.600]                           invokeRestart("muffleMessage")
[08:28:27.600]                       }
[08:28:27.600]                       else if (inherits(cond, "warning")) {
[08:28:27.600]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.600]                         if (muffled) 
[08:28:27.600]                           invokeRestart("muffleWarning")
[08:28:27.600]                       }
[08:28:27.600]                       else if (inherits(cond, "condition")) {
[08:28:27.600]                         if (!is.null(pattern)) {
[08:28:27.600]                           computeRestarts <- base::computeRestarts
[08:28:27.600]                           grepl <- base::grepl
[08:28:27.600]                           restarts <- computeRestarts(cond)
[08:28:27.600]                           for (restart in restarts) {
[08:28:27.600]                             name <- restart$name
[08:28:27.600]                             if (is.null(name)) 
[08:28:27.600]                               next
[08:28:27.600]                             if (!grepl(pattern, name)) 
[08:28:27.600]                               next
[08:28:27.600]                             invokeRestart(restart)
[08:28:27.600]                             muffled <- TRUE
[08:28:27.600]                             break
[08:28:27.600]                           }
[08:28:27.600]                         }
[08:28:27.600]                       }
[08:28:27.600]                       invisible(muffled)
[08:28:27.600]                     }
[08:28:27.600]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.600]                   }
[08:28:27.600]                 }
[08:28:27.600]             }
[08:28:27.600]         }))
[08:28:27.600]     }, error = function(ex) {
[08:28:27.600]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.600]                 ...future.rng), started = ...future.startTime, 
[08:28:27.600]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.600]             version = "1.8"), class = "FutureResult")
[08:28:27.600]     }, finally = {
[08:28:27.600]         if (!identical(...future.workdir, getwd())) 
[08:28:27.600]             setwd(...future.workdir)
[08:28:27.600]         {
[08:28:27.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.600]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.600]             }
[08:28:27.600]             base::options(...future.oldOptions)
[08:28:27.600]             if (.Platform$OS.type == "windows") {
[08:28:27.600]                 old_names <- names(...future.oldEnvVars)
[08:28:27.600]                 envs <- base::Sys.getenv()
[08:28:27.600]                 names <- names(envs)
[08:28:27.600]                 common <- intersect(names, old_names)
[08:28:27.600]                 added <- setdiff(names, old_names)
[08:28:27.600]                 removed <- setdiff(old_names, names)
[08:28:27.600]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.600]                   envs[common]]
[08:28:27.600]                 NAMES <- toupper(changed)
[08:28:27.600]                 args <- list()
[08:28:27.600]                 for (kk in seq_along(NAMES)) {
[08:28:27.600]                   name <- changed[[kk]]
[08:28:27.600]                   NAME <- NAMES[[kk]]
[08:28:27.600]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.600]                     next
[08:28:27.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.600]                 }
[08:28:27.600]                 NAMES <- toupper(added)
[08:28:27.600]                 for (kk in seq_along(NAMES)) {
[08:28:27.600]                   name <- added[[kk]]
[08:28:27.600]                   NAME <- NAMES[[kk]]
[08:28:27.600]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.600]                     next
[08:28:27.600]                   args[[name]] <- ""
[08:28:27.600]                 }
[08:28:27.600]                 NAMES <- toupper(removed)
[08:28:27.600]                 for (kk in seq_along(NAMES)) {
[08:28:27.600]                   name <- removed[[kk]]
[08:28:27.600]                   NAME <- NAMES[[kk]]
[08:28:27.600]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.600]                     next
[08:28:27.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.600]                 }
[08:28:27.600]                 if (length(args) > 0) 
[08:28:27.600]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.600]             }
[08:28:27.600]             else {
[08:28:27.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.600]             }
[08:28:27.600]             {
[08:28:27.600]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.600]                   0L) {
[08:28:27.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.600]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.600]                   base::options(opts)
[08:28:27.600]                 }
[08:28:27.600]                 {
[08:28:27.600]                   {
[08:28:27.600]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.600]                     NULL
[08:28:27.600]                   }
[08:28:27.600]                   options(future.plan = NULL)
[08:28:27.600]                   if (is.na(NA_character_)) 
[08:28:27.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.600]                     .init = FALSE)
[08:28:27.600]                 }
[08:28:27.600]             }
[08:28:27.600]         }
[08:28:27.600]     })
[08:28:27.600]     if (TRUE) {
[08:28:27.600]         base::sink(type = "output", split = FALSE)
[08:28:27.600]         if (TRUE) {
[08:28:27.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.600]         }
[08:28:27.600]         else {
[08:28:27.600]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.600]         }
[08:28:27.600]         base::close(...future.stdout)
[08:28:27.600]         ...future.stdout <- NULL
[08:28:27.600]     }
[08:28:27.600]     ...future.result$conditions <- ...future.conditions
[08:28:27.600]     ...future.result$finished <- base::Sys.time()
[08:28:27.600]     ...future.result
[08:28:27.600] }
[08:28:27.602] requestCore(): workers = 2
[08:28:27.604] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop("Whoops!")
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:28:27.605] plan(): Setting new future strategy stack:
[08:28:27.606] List of future strategies:
[08:28:27.606] 1. sequential:
[08:28:27.606]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.606]    - tweaked: FALSE
[08:28:27.606]    - call: NULL
[08:28:27.607] plan(): nbrOfWorkers() = 1
[08:28:27.609] plan(): Setting new future strategy stack:
[08:28:27.609] List of future strategies:
[08:28:27.609] 1. multicore:
[08:28:27.609]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.609]    - tweaked: FALSE
[08:28:27.609]    - call: plan(multicore)
[08:28:27.612] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:27.615] result() for MulticoreFuture ...
[08:28:27.617] result() for MulticoreFuture ...
[08:28:27.618] result() for MulticoreFuture ... done
[08:28:27.618] signalConditions() ...
[08:28:27.618]  - include = ‘immediateCondition’
[08:28:27.618]  - exclude = 
[08:28:27.618]  - resignal = FALSE
[08:28:27.618]  - Number of conditions: 1
[08:28:27.618] signalConditions() ... done
[08:28:27.618] result() for MulticoreFuture ... done
[08:28:27.619] result() for MulticoreFuture ...
[08:28:27.619] result() for MulticoreFuture ... done
[08:28:27.619] signalConditions() ...
[08:28:27.619]  - include = ‘immediateCondition’
[08:28:27.619]  - exclude = 
[08:28:27.619]  - resignal = FALSE
[08:28:27.619]  - Number of conditions: 1
[08:28:27.619] signalConditions() ... done
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[08:28:27.620] result() for MulticoreFuture ...
[08:28:27.620] result() for MulticoreFuture ... done
[08:28:27.620] result() for MulticoreFuture ...
[08:28:27.620] result() for MulticoreFuture ... done
[08:28:27.621] signalConditions() ...
[08:28:27.621]  - include = ‘immediateCondition’
[08:28:27.621]  - exclude = 
[08:28:27.621]  - resignal = FALSE
[08:28:27.621]  - Number of conditions: 1
[08:28:27.621] signalConditions() ... done
[08:28:27.621] Future state: ‘finished’
[08:28:27.621] result() for MulticoreFuture ...
[08:28:27.621] result() for MulticoreFuture ... done
[08:28:27.622] signalConditions() ...
[08:28:27.622]  - include = ‘condition’
[08:28:27.622]  - exclude = ‘immediateCondition’
[08:28:27.622]  - resignal = TRUE
[08:28:27.622]  - Number of conditions: 1
[08:28:27.622]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:27.622] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[08:28:27.626] result() for MulticoreFuture ...
[08:28:27.626] result() for MulticoreFuture ... done
[08:28:27.626] result() for MulticoreFuture ...
[08:28:27.626] result() for MulticoreFuture ... done
[08:28:27.626] signalConditions() ...
[08:28:27.627]  - include = ‘immediateCondition’
[08:28:27.627]  - exclude = 
[08:28:27.627]  - resignal = FALSE
[08:28:27.627]  - Number of conditions: 1
[08:28:27.627] signalConditions() ... done
[08:28:27.627] Future state: ‘finished’
[08:28:27.627] result() for MulticoreFuture ...
[08:28:27.628] result() for MulticoreFuture ... done
[08:28:27.628] signalConditions() ...
[08:28:27.628]  - include = ‘condition’
[08:28:27.628]  - exclude = ‘immediateCondition’
[08:28:27.628]  - resignal = TRUE
[08:28:27.628]  - Number of conditions: 1
[08:28:27.628]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:27.628] signalConditions() ... done
[1] "Error in withCallingHandlers({ : Whoops!\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        stop("Whoops!")        1    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): Whoops!>
[08:28:27.631] getGlobalsAndPackages() ...
[08:28:27.631] 
[08:28:27.631] - globals: [0] <none>
[08:28:27.631] getGlobalsAndPackages() ... DONE
[08:28:27.632] Packages needed by the future expression (n = 0): <none>
[08:28:27.632] Packages needed by future strategies (n = 0): <none>
[08:28:27.633] {
[08:28:27.633]     {
[08:28:27.633]         {
[08:28:27.633]             ...future.startTime <- base::Sys.time()
[08:28:27.633]             {
[08:28:27.633]                 {
[08:28:27.633]                   {
[08:28:27.633]                     {
[08:28:27.633]                       base::local({
[08:28:27.633]                         has_future <- base::requireNamespace("future", 
[08:28:27.633]                           quietly = TRUE)
[08:28:27.633]                         if (has_future) {
[08:28:27.633]                           ns <- base::getNamespace("future")
[08:28:27.633]                           version <- ns[[".package"]][["version"]]
[08:28:27.633]                           if (is.null(version)) 
[08:28:27.633]                             version <- utils::packageVersion("future")
[08:28:27.633]                         }
[08:28:27.633]                         else {
[08:28:27.633]                           version <- NULL
[08:28:27.633]                         }
[08:28:27.633]                         if (!has_future || version < "1.8.0") {
[08:28:27.633]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.633]                             "", base::R.version$version.string), 
[08:28:27.633]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:27.633]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.633]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.633]                               "release", "version")], collapse = " "), 
[08:28:27.633]                             hostname = base::Sys.info()[["nodename"]])
[08:28:27.633]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.633]                             info)
[08:28:27.633]                           info <- base::paste(info, collapse = "; ")
[08:28:27.633]                           if (!has_future) {
[08:28:27.633]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.633]                               info)
[08:28:27.633]                           }
[08:28:27.633]                           else {
[08:28:27.633]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.633]                               info, version)
[08:28:27.633]                           }
[08:28:27.633]                           base::stop(msg)
[08:28:27.633]                         }
[08:28:27.633]                       })
[08:28:27.633]                     }
[08:28:27.633]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:27.633]                     base::options(mc.cores = 1L)
[08:28:27.633]                   }
[08:28:27.633]                   ...future.strategy.old <- future::plan("list")
[08:28:27.633]                   options(future.plan = NULL)
[08:28:27.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.633]                 }
[08:28:27.633]                 ...future.workdir <- getwd()
[08:28:27.633]             }
[08:28:27.633]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.633]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.633]         }
[08:28:27.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.633]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.633]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.633]             base::names(...future.oldOptions))
[08:28:27.633]     }
[08:28:27.633]     if (FALSE) {
[08:28:27.633]     }
[08:28:27.633]     else {
[08:28:27.633]         if (TRUE) {
[08:28:27.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.633]                 open = "w")
[08:28:27.633]         }
[08:28:27.633]         else {
[08:28:27.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.633]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.633]         }
[08:28:27.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.633]             base::sink(type = "output", split = FALSE)
[08:28:27.633]             base::close(...future.stdout)
[08:28:27.633]         }, add = TRUE)
[08:28:27.633]     }
[08:28:27.633]     ...future.frame <- base::sys.nframe()
[08:28:27.633]     ...future.conditions <- base::list()
[08:28:27.633]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.633]     if (FALSE) {
[08:28:27.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.633]     }
[08:28:27.633]     ...future.result <- base::tryCatch({
[08:28:27.633]         base::withCallingHandlers({
[08:28:27.633]             ...future.value <- base::withVisible(base::local({
[08:28:27.633]                 withCallingHandlers({
[08:28:27.633]                   {
[08:28:27.633]                     stop(structure(list(message = "boom"), class = c("MyError", 
[08:28:27.633]                       "error", "condition")))
[08:28:27.633]                   }
[08:28:27.633]                 }, immediateCondition = function(cond) {
[08:28:27.633]                   save_rds <- function (object, pathname, ...) 
[08:28:27.633]                   {
[08:28:27.633]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:27.633]                     if (file_test("-f", pathname_tmp)) {
[08:28:27.633]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.633]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:27.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.633]                         fi_tmp[["mtime"]])
[08:28:27.633]                     }
[08:28:27.633]                     tryCatch({
[08:28:27.633]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:27.633]                     }, error = function(ex) {
[08:28:27.633]                       msg <- conditionMessage(ex)
[08:28:27.633]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.633]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:27.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.633]                         fi_tmp[["mtime"]], msg)
[08:28:27.633]                       ex$message <- msg
[08:28:27.633]                       stop(ex)
[08:28:27.633]                     })
[08:28:27.633]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:27.633]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:27.633]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:27.633]                       fi_tmp <- file.info(pathname_tmp)
[08:28:27.633]                       fi <- file.info(pathname)
[08:28:27.633]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:27.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:27.633]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:27.633]                         fi[["size"]], fi[["mtime"]])
[08:28:27.633]                       stop(msg)
[08:28:27.633]                     }
[08:28:27.633]                     invisible(pathname)
[08:28:27.633]                   }
[08:28:27.633]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:27.633]                     rootPath = tempdir()) 
[08:28:27.633]                   {
[08:28:27.633]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:27.633]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:27.633]                       tmpdir = path, fileext = ".rds")
[08:28:27.633]                     save_rds(obj, file)
[08:28:27.633]                   }
[08:28:27.633]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3hT2QW/.future/immediateConditions")
[08:28:27.633]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.633]                   {
[08:28:27.633]                     inherits <- base::inherits
[08:28:27.633]                     invokeRestart <- base::invokeRestart
[08:28:27.633]                     is.null <- base::is.null
[08:28:27.633]                     muffled <- FALSE
[08:28:27.633]                     if (inherits(cond, "message")) {
[08:28:27.633]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:27.633]                       if (muffled) 
[08:28:27.633]                         invokeRestart("muffleMessage")
[08:28:27.633]                     }
[08:28:27.633]                     else if (inherits(cond, "warning")) {
[08:28:27.633]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:27.633]                       if (muffled) 
[08:28:27.633]                         invokeRestart("muffleWarning")
[08:28:27.633]                     }
[08:28:27.633]                     else if (inherits(cond, "condition")) {
[08:28:27.633]                       if (!is.null(pattern)) {
[08:28:27.633]                         computeRestarts <- base::computeRestarts
[08:28:27.633]                         grepl <- base::grepl
[08:28:27.633]                         restarts <- computeRestarts(cond)
[08:28:27.633]                         for (restart in restarts) {
[08:28:27.633]                           name <- restart$name
[08:28:27.633]                           if (is.null(name)) 
[08:28:27.633]                             next
[08:28:27.633]                           if (!grepl(pattern, name)) 
[08:28:27.633]                             next
[08:28:27.633]                           invokeRestart(restart)
[08:28:27.633]                           muffled <- TRUE
[08:28:27.633]                           break
[08:28:27.633]                         }
[08:28:27.633]                       }
[08:28:27.633]                     }
[08:28:27.633]                     invisible(muffled)
[08:28:27.633]                   }
[08:28:27.633]                   muffleCondition(cond)
[08:28:27.633]                 })
[08:28:27.633]             }))
[08:28:27.633]             future::FutureResult(value = ...future.value$value, 
[08:28:27.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.633]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.633]                     ...future.globalenv.names))
[08:28:27.633]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.633]         }, condition = base::local({
[08:28:27.633]             c <- base::c
[08:28:27.633]             inherits <- base::inherits
[08:28:27.633]             invokeRestart <- base::invokeRestart
[08:28:27.633]             length <- base::length
[08:28:27.633]             list <- base::list
[08:28:27.633]             seq.int <- base::seq.int
[08:28:27.633]             signalCondition <- base::signalCondition
[08:28:27.633]             sys.calls <- base::sys.calls
[08:28:27.633]             `[[` <- base::`[[`
[08:28:27.633]             `+` <- base::`+`
[08:28:27.633]             `<<-` <- base::`<<-`
[08:28:27.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.633]                   3L)]
[08:28:27.633]             }
[08:28:27.633]             function(cond) {
[08:28:27.633]                 is_error <- inherits(cond, "error")
[08:28:27.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.633]                   NULL)
[08:28:27.633]                 if (is_error) {
[08:28:27.633]                   sessionInformation <- function() {
[08:28:27.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.633]                       search = base::search(), system = base::Sys.info())
[08:28:27.633]                   }
[08:28:27.633]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.633]                     cond$call), session = sessionInformation(), 
[08:28:27.633]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.633]                   signalCondition(cond)
[08:28:27.633]                 }
[08:28:27.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.633]                 "immediateCondition"))) {
[08:28:27.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.633]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.633]                   if (TRUE && !signal) {
[08:28:27.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.633]                     {
[08:28:27.633]                       inherits <- base::inherits
[08:28:27.633]                       invokeRestart <- base::invokeRestart
[08:28:27.633]                       is.null <- base::is.null
[08:28:27.633]                       muffled <- FALSE
[08:28:27.633]                       if (inherits(cond, "message")) {
[08:28:27.633]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.633]                         if (muffled) 
[08:28:27.633]                           invokeRestart("muffleMessage")
[08:28:27.633]                       }
[08:28:27.633]                       else if (inherits(cond, "warning")) {
[08:28:27.633]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.633]                         if (muffled) 
[08:28:27.633]                           invokeRestart("muffleWarning")
[08:28:27.633]                       }
[08:28:27.633]                       else if (inherits(cond, "condition")) {
[08:28:27.633]                         if (!is.null(pattern)) {
[08:28:27.633]                           computeRestarts <- base::computeRestarts
[08:28:27.633]                           grepl <- base::grepl
[08:28:27.633]                           restarts <- computeRestarts(cond)
[08:28:27.633]                           for (restart in restarts) {
[08:28:27.633]                             name <- restart$name
[08:28:27.633]                             if (is.null(name)) 
[08:28:27.633]                               next
[08:28:27.633]                             if (!grepl(pattern, name)) 
[08:28:27.633]                               next
[08:28:27.633]                             invokeRestart(restart)
[08:28:27.633]                             muffled <- TRUE
[08:28:27.633]                             break
[08:28:27.633]                           }
[08:28:27.633]                         }
[08:28:27.633]                       }
[08:28:27.633]                       invisible(muffled)
[08:28:27.633]                     }
[08:28:27.633]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.633]                   }
[08:28:27.633]                 }
[08:28:27.633]                 else {
[08:28:27.633]                   if (TRUE) {
[08:28:27.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.633]                     {
[08:28:27.633]                       inherits <- base::inherits
[08:28:27.633]                       invokeRestart <- base::invokeRestart
[08:28:27.633]                       is.null <- base::is.null
[08:28:27.633]                       muffled <- FALSE
[08:28:27.633]                       if (inherits(cond, "message")) {
[08:28:27.633]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.633]                         if (muffled) 
[08:28:27.633]                           invokeRestart("muffleMessage")
[08:28:27.633]                       }
[08:28:27.633]                       else if (inherits(cond, "warning")) {
[08:28:27.633]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.633]                         if (muffled) 
[08:28:27.633]                           invokeRestart("muffleWarning")
[08:28:27.633]                       }
[08:28:27.633]                       else if (inherits(cond, "condition")) {
[08:28:27.633]                         if (!is.null(pattern)) {
[08:28:27.633]                           computeRestarts <- base::computeRestarts
[08:28:27.633]                           grepl <- base::grepl
[08:28:27.633]                           restarts <- computeRestarts(cond)
[08:28:27.633]                           for (restart in restarts) {
[08:28:27.633]                             name <- restart$name
[08:28:27.633]                             if (is.null(name)) 
[08:28:27.633]                               next
[08:28:27.633]                             if (!grepl(pattern, name)) 
[08:28:27.633]                               next
[08:28:27.633]                             invokeRestart(restart)
[08:28:27.633]                             muffled <- TRUE
[08:28:27.633]                             break
[08:28:27.633]                           }
[08:28:27.633]                         }
[08:28:27.633]                       }
[08:28:27.633]                       invisible(muffled)
[08:28:27.633]                     }
[08:28:27.633]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.633]                   }
[08:28:27.633]                 }
[08:28:27.633]             }
[08:28:27.633]         }))
[08:28:27.633]     }, error = function(ex) {
[08:28:27.633]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.633]                 ...future.rng), started = ...future.startTime, 
[08:28:27.633]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.633]             version = "1.8"), class = "FutureResult")
[08:28:27.633]     }, finally = {
[08:28:27.633]         if (!identical(...future.workdir, getwd())) 
[08:28:27.633]             setwd(...future.workdir)
[08:28:27.633]         {
[08:28:27.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.633]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.633]             }
[08:28:27.633]             base::options(...future.oldOptions)
[08:28:27.633]             if (.Platform$OS.type == "windows") {
[08:28:27.633]                 old_names <- names(...future.oldEnvVars)
[08:28:27.633]                 envs <- base::Sys.getenv()
[08:28:27.633]                 names <- names(envs)
[08:28:27.633]                 common <- intersect(names, old_names)
[08:28:27.633]                 added <- setdiff(names, old_names)
[08:28:27.633]                 removed <- setdiff(old_names, names)
[08:28:27.633]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.633]                   envs[common]]
[08:28:27.633]                 NAMES <- toupper(changed)
[08:28:27.633]                 args <- list()
[08:28:27.633]                 for (kk in seq_along(NAMES)) {
[08:28:27.633]                   name <- changed[[kk]]
[08:28:27.633]                   NAME <- NAMES[[kk]]
[08:28:27.633]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.633]                     next
[08:28:27.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.633]                 }
[08:28:27.633]                 NAMES <- toupper(added)
[08:28:27.633]                 for (kk in seq_along(NAMES)) {
[08:28:27.633]                   name <- added[[kk]]
[08:28:27.633]                   NAME <- NAMES[[kk]]
[08:28:27.633]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.633]                     next
[08:28:27.633]                   args[[name]] <- ""
[08:28:27.633]                 }
[08:28:27.633]                 NAMES <- toupper(removed)
[08:28:27.633]                 for (kk in seq_along(NAMES)) {
[08:28:27.633]                   name <- removed[[kk]]
[08:28:27.633]                   NAME <- NAMES[[kk]]
[08:28:27.633]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.633]                     next
[08:28:27.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.633]                 }
[08:28:27.633]                 if (length(args) > 0) 
[08:28:27.633]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.633]             }
[08:28:27.633]             else {
[08:28:27.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.633]             }
[08:28:27.633]             {
[08:28:27.633]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.633]                   0L) {
[08:28:27.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.633]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.633]                   base::options(opts)
[08:28:27.633]                 }
[08:28:27.633]                 {
[08:28:27.633]                   {
[08:28:27.633]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:27.633]                     NULL
[08:28:27.633]                   }
[08:28:27.633]                   options(future.plan = NULL)
[08:28:27.633]                   if (is.na(NA_character_)) 
[08:28:27.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.633]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.633]                     .init = FALSE)
[08:28:27.633]                 }
[08:28:27.633]             }
[08:28:27.633]         }
[08:28:27.633]     })
[08:28:27.633]     if (TRUE) {
[08:28:27.633]         base::sink(type = "output", split = FALSE)
[08:28:27.633]         if (TRUE) {
[08:28:27.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.633]         }
[08:28:27.633]         else {
[08:28:27.633]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.633]         }
[08:28:27.633]         base::close(...future.stdout)
[08:28:27.633]         ...future.stdout <- NULL
[08:28:27.633]     }
[08:28:27.633]     ...future.result$conditions <- ...future.conditions
[08:28:27.633]     ...future.result$finished <- base::Sys.time()
[08:28:27.633]     ...future.result
[08:28:27.633] }
[08:28:27.635] requestCore(): workers = 2
[08:28:27.637] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    stop(structure(list(message = "boom"), class = c("MyError", 
        "error", "condition")))
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:28:27.638] plan(): Setting new future strategy stack:
[08:28:27.639] List of future strategies:
[08:28:27.639] 1. sequential:
[08:28:27.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.639]    - tweaked: FALSE
[08:28:27.639]    - call: NULL
[08:28:27.640] plan(): nbrOfWorkers() = 1
[08:28:27.642] plan(): Setting new future strategy stack:
[08:28:27.642] List of future strategies:
[08:28:27.642] 1. multicore:
[08:28:27.642]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.642]    - tweaked: FALSE
[08:28:27.642]    - call: plan(multicore)
[08:28:27.645] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: fe67db3c-3915-8268-cd1a-eea92d302ca3
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:27.648] result() for MulticoreFuture ...
[08:28:27.650] result() for MulticoreFuture ...
[08:28:27.650] result() for MulticoreFuture ... done
[08:28:27.650] signalConditions() ...
[08:28:27.651]  - include = ‘immediateCondition’
[08:28:27.651]  - exclude = 
[08:28:27.651]  - resignal = FALSE
[08:28:27.651]  - Number of conditions: 1
[08:28:27.651] signalConditions() ... done
[08:28:27.651] result() for MulticoreFuture ... done
[08:28:27.651] result() for MulticoreFuture ...
[08:28:27.651] result() for MulticoreFuture ... done
[08:28:27.652] signalConditions() ...
[08:28:27.652]  - include = ‘immediateCondition’
[08:28:27.652]  - exclude = 
[08:28:27.652]  - resignal = FALSE
[08:28:27.652]  - Number of conditions: 1
[08:28:27.652] signalConditions() ... done
<MyError: boom>
[08:28:27.652] result() for MulticoreFuture ...
[08:28:27.653] result() for MulticoreFuture ... done
[08:28:27.653] result() for MulticoreFuture ...
[08:28:27.653] result() for MulticoreFuture ... done
[08:28:27.653] signalConditions() ...
[08:28:27.653]  - include = ‘immediateCondition’
[08:28:27.653]  - exclude = 
[08:28:27.653]  - resignal = FALSE
[08:28:27.653]  - Number of conditions: 1
[08:28:27.653] signalConditions() ... done
[08:28:27.654] Future state: ‘finished’
[08:28:27.654] result() for MulticoreFuture ...
[08:28:27.654] result() for MulticoreFuture ... done
[08:28:27.654] signalConditions() ...
[08:28:27.654]  - include = ‘condition’
[08:28:27.654]  - exclude = ‘immediateCondition’
[08:28:27.654]  - resignal = TRUE
[08:28:27.654]  - Number of conditions: 1
[08:28:27.654]  - Condition #1: ‘MyError’, ‘error’, ‘condition’
[08:28:27.655] signalConditions() ... done
*** multicore(..., workers = 1L) ...
[08:28:27.655] getGlobalsAndPackages() ...
[08:28:27.655] Searching for globals...
[08:28:27.656] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[08:28:27.657] Searching for globals ... DONE
[08:28:27.657] Resolving globals: FALSE
[08:28:27.657] The total size of the 2 globals is 78 bytes (78 bytes)
[08:28:27.658] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 78 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘b’ (39 bytes of class ‘numeric’)
[08:28:27.658] - globals: [2] ‘a’, ‘b’
[08:28:27.658] 
[08:28:27.658] getGlobalsAndPackages() ... DONE
[08:28:27.659] Packages needed by the future expression (n = 0): <none>
[08:28:27.659] Packages needed by future strategies (n = 0): <none>
[08:28:27.659] {
[08:28:27.659]     {
[08:28:27.659]         {
[08:28:27.659]             ...future.startTime <- base::Sys.time()
[08:28:27.659]             {
[08:28:27.659]                 {
[08:28:27.659]                   {
[08:28:27.659]                     base::local({
[08:28:27.659]                       has_future <- base::requireNamespace("future", 
[08:28:27.659]                         quietly = TRUE)
[08:28:27.659]                       if (has_future) {
[08:28:27.659]                         ns <- base::getNamespace("future")
[08:28:27.659]                         version <- ns[[".package"]][["version"]]
[08:28:27.659]                         if (is.null(version)) 
[08:28:27.659]                           version <- utils::packageVersion("future")
[08:28:27.659]                       }
[08:28:27.659]                       else {
[08:28:27.659]                         version <- NULL
[08:28:27.659]                       }
[08:28:27.659]                       if (!has_future || version < "1.8.0") {
[08:28:27.659]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:27.659]                           "", base::R.version$version.string), 
[08:28:27.659]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:27.659]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:27.659]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:27.659]                             "release", "version")], collapse = " "), 
[08:28:27.659]                           hostname = base::Sys.info()[["nodename"]])
[08:28:27.659]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:27.659]                           info)
[08:28:27.659]                         info <- base::paste(info, collapse = "; ")
[08:28:27.659]                         if (!has_future) {
[08:28:27.659]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:27.659]                             info)
[08:28:27.659]                         }
[08:28:27.659]                         else {
[08:28:27.659]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:27.659]                             info, version)
[08:28:27.659]                         }
[08:28:27.659]                         base::stop(msg)
[08:28:27.659]                       }
[08:28:27.659]                     })
[08:28:27.659]                   }
[08:28:27.659]                   ...future.strategy.old <- future::plan("list")
[08:28:27.659]                   options(future.plan = NULL)
[08:28:27.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:27.659]                 }
[08:28:27.659]                 ...future.workdir <- getwd()
[08:28:27.659]             }
[08:28:27.659]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:27.659]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:27.659]         }
[08:28:27.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:27.659]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:27.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:27.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:27.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:27.659]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:27.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:27.659]             base::names(...future.oldOptions))
[08:28:27.659]     }
[08:28:27.659]     if (FALSE) {
[08:28:27.659]     }
[08:28:27.659]     else {
[08:28:27.659]         if (TRUE) {
[08:28:27.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:27.659]                 open = "w")
[08:28:27.659]         }
[08:28:27.659]         else {
[08:28:27.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:27.659]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:27.659]         }
[08:28:27.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:27.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:27.659]             base::sink(type = "output", split = FALSE)
[08:28:27.659]             base::close(...future.stdout)
[08:28:27.659]         }, add = TRUE)
[08:28:27.659]     }
[08:28:27.659]     ...future.frame <- base::sys.nframe()
[08:28:27.659]     ...future.conditions <- base::list()
[08:28:27.659]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:27.659]     if (FALSE) {
[08:28:27.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:27.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:27.659]     }
[08:28:27.659]     ...future.result <- base::tryCatch({
[08:28:27.659]         base::withCallingHandlers({
[08:28:27.659]             ...future.value <- base::withVisible(base::local({
[08:28:27.659]                 a * b
[08:28:27.659]             }))
[08:28:27.659]             future::FutureResult(value = ...future.value$value, 
[08:28:27.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.659]                   ...future.rng), globalenv = if (FALSE) 
[08:28:27.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:27.659]                     ...future.globalenv.names))
[08:28:27.659]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:27.659]         }, condition = base::local({
[08:28:27.659]             c <- base::c
[08:28:27.659]             inherits <- base::inherits
[08:28:27.659]             invokeRestart <- base::invokeRestart
[08:28:27.659]             length <- base::length
[08:28:27.659]             list <- base::list
[08:28:27.659]             seq.int <- base::seq.int
[08:28:27.659]             signalCondition <- base::signalCondition
[08:28:27.659]             sys.calls <- base::sys.calls
[08:28:27.659]             `[[` <- base::`[[`
[08:28:27.659]             `+` <- base::`+`
[08:28:27.659]             `<<-` <- base::`<<-`
[08:28:27.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:27.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:27.659]                   3L)]
[08:28:27.659]             }
[08:28:27.659]             function(cond) {
[08:28:27.659]                 is_error <- inherits(cond, "error")
[08:28:27.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:27.659]                   NULL)
[08:28:27.659]                 if (is_error) {
[08:28:27.659]                   sessionInformation <- function() {
[08:28:27.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:27.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:27.659]                       search = base::search(), system = base::Sys.info())
[08:28:27.659]                   }
[08:28:27.659]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:27.659]                     cond$call), session = sessionInformation(), 
[08:28:27.659]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:27.659]                   signalCondition(cond)
[08:28:27.659]                 }
[08:28:27.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:27.659]                 "immediateCondition"))) {
[08:28:27.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:27.659]                   ...future.conditions[[length(...future.conditions) + 
[08:28:27.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:27.659]                   if (TRUE && !signal) {
[08:28:27.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.659]                     {
[08:28:27.659]                       inherits <- base::inherits
[08:28:27.659]                       invokeRestart <- base::invokeRestart
[08:28:27.659]                       is.null <- base::is.null
[08:28:27.659]                       muffled <- FALSE
[08:28:27.659]                       if (inherits(cond, "message")) {
[08:28:27.659]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.659]                         if (muffled) 
[08:28:27.659]                           invokeRestart("muffleMessage")
[08:28:27.659]                       }
[08:28:27.659]                       else if (inherits(cond, "warning")) {
[08:28:27.659]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.659]                         if (muffled) 
[08:28:27.659]                           invokeRestart("muffleWarning")
[08:28:27.659]                       }
[08:28:27.659]                       else if (inherits(cond, "condition")) {
[08:28:27.659]                         if (!is.null(pattern)) {
[08:28:27.659]                           computeRestarts <- base::computeRestarts
[08:28:27.659]                           grepl <- base::grepl
[08:28:27.659]                           restarts <- computeRestarts(cond)
[08:28:27.659]                           for (restart in restarts) {
[08:28:27.659]                             name <- restart$name
[08:28:27.659]                             if (is.null(name)) 
[08:28:27.659]                               next
[08:28:27.659]                             if (!grepl(pattern, name)) 
[08:28:27.659]                               next
[08:28:27.659]                             invokeRestart(restart)
[08:28:27.659]                             muffled <- TRUE
[08:28:27.659]                             break
[08:28:27.659]                           }
[08:28:27.659]                         }
[08:28:27.659]                       }
[08:28:27.659]                       invisible(muffled)
[08:28:27.659]                     }
[08:28:27.659]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.659]                   }
[08:28:27.659]                 }
[08:28:27.659]                 else {
[08:28:27.659]                   if (TRUE) {
[08:28:27.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:27.659]                     {
[08:28:27.659]                       inherits <- base::inherits
[08:28:27.659]                       invokeRestart <- base::invokeRestart
[08:28:27.659]                       is.null <- base::is.null
[08:28:27.659]                       muffled <- FALSE
[08:28:27.659]                       if (inherits(cond, "message")) {
[08:28:27.659]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:27.659]                         if (muffled) 
[08:28:27.659]                           invokeRestart("muffleMessage")
[08:28:27.659]                       }
[08:28:27.659]                       else if (inherits(cond, "warning")) {
[08:28:27.659]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:27.659]                         if (muffled) 
[08:28:27.659]                           invokeRestart("muffleWarning")
[08:28:27.659]                       }
[08:28:27.659]                       else if (inherits(cond, "condition")) {
[08:28:27.659]                         if (!is.null(pattern)) {
[08:28:27.659]                           computeRestarts <- base::computeRestarts
[08:28:27.659]                           grepl <- base::grepl
[08:28:27.659]                           restarts <- computeRestarts(cond)
[08:28:27.659]                           for (restart in restarts) {
[08:28:27.659]                             name <- restart$name
[08:28:27.659]                             if (is.null(name)) 
[08:28:27.659]                               next
[08:28:27.659]                             if (!grepl(pattern, name)) 
[08:28:27.659]                               next
[08:28:27.659]                             invokeRestart(restart)
[08:28:27.659]                             muffled <- TRUE
[08:28:27.659]                             break
[08:28:27.659]                           }
[08:28:27.659]                         }
[08:28:27.659]                       }
[08:28:27.659]                       invisible(muffled)
[08:28:27.659]                     }
[08:28:27.659]                     muffleCondition(cond, pattern = "^muffle")
[08:28:27.659]                   }
[08:28:27.659]                 }
[08:28:27.659]             }
[08:28:27.659]         }))
[08:28:27.659]     }, error = function(ex) {
[08:28:27.659]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:27.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:27.659]                 ...future.rng), started = ...future.startTime, 
[08:28:27.659]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:27.659]             version = "1.8"), class = "FutureResult")
[08:28:27.659]     }, finally = {
[08:28:27.659]         if (!identical(...future.workdir, getwd())) 
[08:28:27.659]             setwd(...future.workdir)
[08:28:27.659]         {
[08:28:27.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:27.659]                 ...future.oldOptions$nwarnings <- NULL
[08:28:27.659]             }
[08:28:27.659]             base::options(...future.oldOptions)
[08:28:27.659]             if (.Platform$OS.type == "windows") {
[08:28:27.659]                 old_names <- names(...future.oldEnvVars)
[08:28:27.659]                 envs <- base::Sys.getenv()
[08:28:27.659]                 names <- names(envs)
[08:28:27.659]                 common <- intersect(names, old_names)
[08:28:27.659]                 added <- setdiff(names, old_names)
[08:28:27.659]                 removed <- setdiff(old_names, names)
[08:28:27.659]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:27.659]                   envs[common]]
[08:28:27.659]                 NAMES <- toupper(changed)
[08:28:27.659]                 args <- list()
[08:28:27.659]                 for (kk in seq_along(NAMES)) {
[08:28:27.659]                   name <- changed[[kk]]
[08:28:27.659]                   NAME <- NAMES[[kk]]
[08:28:27.659]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.659]                     next
[08:28:27.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.659]                 }
[08:28:27.659]                 NAMES <- toupper(added)
[08:28:27.659]                 for (kk in seq_along(NAMES)) {
[08:28:27.659]                   name <- added[[kk]]
[08:28:27.659]                   NAME <- NAMES[[kk]]
[08:28:27.659]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.659]                     next
[08:28:27.659]                   args[[name]] <- ""
[08:28:27.659]                 }
[08:28:27.659]                 NAMES <- toupper(removed)
[08:28:27.659]                 for (kk in seq_along(NAMES)) {
[08:28:27.659]                   name <- removed[[kk]]
[08:28:27.659]                   NAME <- NAMES[[kk]]
[08:28:27.659]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:27.659]                     next
[08:28:27.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:27.659]                 }
[08:28:27.659]                 if (length(args) > 0) 
[08:28:27.659]                   base::do.call(base::Sys.setenv, args = args)
[08:28:27.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:27.659]             }
[08:28:27.659]             else {
[08:28:27.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:27.659]             }
[08:28:27.659]             {
[08:28:27.659]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:27.659]                   0L) {
[08:28:27.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:27.659]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:27.659]                   base::options(opts)
[08:28:27.659]                 }
[08:28:27.659]                 {
[08:28:27.659]                   {
[08:28:27.659]                     NULL
[08:28:27.659]                     RNGkind("Mersenne-Twister")
[08:28:27.659]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:27.659]                       inherits = FALSE)
[08:28:27.659]                   }
[08:28:27.659]                   options(future.plan = NULL)
[08:28:27.659]                   if (is.na(NA_character_)) 
[08:28:27.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:27.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:27.659]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:27.659]                     .init = FALSE)
[08:28:27.659]                 }
[08:28:27.659]             }
[08:28:27.659]         }
[08:28:27.659]     })
[08:28:27.659]     if (TRUE) {
[08:28:27.659]         base::sink(type = "output", split = FALSE)
[08:28:27.659]         if (TRUE) {
[08:28:27.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:27.659]         }
[08:28:27.659]         else {
[08:28:27.659]             ...future.result["stdout"] <- base::list(NULL)
[08:28:27.659]         }
[08:28:27.659]         base::close(...future.stdout)
[08:28:27.659]         ...future.stdout <- NULL
[08:28:27.659]     }
[08:28:27.659]     ...future.result$conditions <- ...future.conditions
[08:28:27.659]     ...future.result$finished <- base::Sys.time()
[08:28:27.659]     ...future.result
[08:28:27.659] }
[08:28:27.661] assign_globals() ...
[08:28:27.662] List of 2
[08:28:27.662]  $ a: num 2
[08:28:27.662]  $ b: num 3
[08:28:27.662]  - attr(*, "where")=List of 2
[08:28:27.662]   ..$ a:<environment: R_EmptyEnv> 
[08:28:27.662]   ..$ b:<environment: R_EmptyEnv> 
[08:28:27.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:27.662]  - attr(*, "resolved")= logi FALSE
[08:28:27.662]  - attr(*, "total_size")= num 78
[08:28:27.665] - copied ‘a’ to environment
[08:28:27.665] - copied ‘b’ to environment
[08:28:27.665] assign_globals() ... done
[08:28:27.666] plan(): Setting new future strategy stack:
[08:28:27.666] List of future strategies:
[08:28:27.666] 1. sequential:
[08:28:27.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.666]    - tweaked: FALSE
[08:28:27.666]    - call: NULL
[08:28:27.666] plan(): nbrOfWorkers() = 1
[08:28:27.667] plan(): Setting new future strategy stack:
[08:28:27.667] List of future strategies:
[08:28:27.667] 1. multicore:
[08:28:27.667]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:27.667]    - tweaked: FALSE
[08:28:27.667]    - call: plan(multicore)
[08:28:27.672] plan(): nbrOfWorkers() = 2
[08:28:27.672] SequentialFuture started (and completed)
[1] 6
*** multicore(..., workers = 1L) ... DONE
Testing with 2 cores ... DONE
> 
> message("*** multicore() ... DONE")
*** multicore() ... DONE
> 
> source("incl/end.R")
[08:28:27.673] plan(): Setting new future strategy stack:
[08:28:27.673] List of future strategies:
[08:28:27.673] 1. FutureStrategy:
[08:28:27.673]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:27.673]    - tweaked: FALSE
[08:28:27.673]    - call: future::plan(oplan)
[08:28:27.674] plan(): nbrOfWorkers() = 1
> 
