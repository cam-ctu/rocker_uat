
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:28:59.460] plan(): Setting new future strategy stack:
[08:28:59.461] List of future strategies:
[08:28:59.461] 1. sequential:
[08:28:59.461]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.461]    - tweaked: FALSE
[08:28:59.461]    - call: future::plan("sequential")
[08:28:59.475] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[08:28:59.663] plan(): Setting new future strategy stack:
[08:28:59.663] List of future strategies:
[08:28:59.663] 1. sequential:
[08:28:59.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.663]    - tweaked: FALSE
[08:28:59.663]    - call: plan(strategy)
[08:28:59.675] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[08:28:59.675] resolve() on list ...
[08:28:59.675]  recursive: 0
[08:28:59.675]  length: 2
[08:28:59.675]  elements: ‘a’, ‘b’
[08:28:59.676]  length: 1 (resolved future 1)
[08:28:59.676]  length: 0 (resolved future 2)
[08:28:59.676] resolve() on list ... DONE
[08:28:59.676] getGlobalsAndPackages() ...
[08:28:59.676] Searching for globals...
[08:28:59.678] 
[08:28:59.678] Searching for globals ... DONE
[08:28:59.678] - globals: [0] <none>
[08:28:59.678] getGlobalsAndPackages() ... DONE
[08:28:59.679] run() for ‘Future’ ...
[08:28:59.679] - state: ‘created’
[08:28:59.679] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:59.680] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:59.680] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:59.680]   - Field: ‘label’
[08:28:59.680]   - Field: ‘local’
[08:28:59.680]   - Field: ‘owner’
[08:28:59.680]   - Field: ‘envir’
[08:28:59.680]   - Field: ‘packages’
[08:28:59.680]   - Field: ‘gc’
[08:28:59.680]   - Field: ‘conditions’
[08:28:59.680]   - Field: ‘expr’
[08:28:59.681]   - Field: ‘uuid’
[08:28:59.681]   - Field: ‘seed’
[08:28:59.681]   - Field: ‘version’
[08:28:59.681]   - Field: ‘result’
[08:28:59.681]   - Field: ‘asynchronous’
[08:28:59.681]   - Field: ‘calls’
[08:28:59.681]   - Field: ‘globals’
[08:28:59.681]   - Field: ‘stdout’
[08:28:59.681]   - Field: ‘earlySignal’
[08:28:59.681]   - Field: ‘lazy’
[08:28:59.681]   - Field: ‘state’
[08:28:59.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:59.682] - Launch lazy future ...
[08:28:59.682] Packages needed by the future expression (n = 0): <none>
[08:28:59.682] Packages needed by future strategies (n = 0): <none>
[08:28:59.683] {
[08:28:59.683]     {
[08:28:59.683]         {
[08:28:59.683]             ...future.startTime <- base::Sys.time()
[08:28:59.683]             {
[08:28:59.683]                 {
[08:28:59.683]                   {
[08:28:59.683]                     base::local({
[08:28:59.683]                       has_future <- base::requireNamespace("future", 
[08:28:59.683]                         quietly = TRUE)
[08:28:59.683]                       if (has_future) {
[08:28:59.683]                         ns <- base::getNamespace("future")
[08:28:59.683]                         version <- ns[[".package"]][["version"]]
[08:28:59.683]                         if (is.null(version)) 
[08:28:59.683]                           version <- utils::packageVersion("future")
[08:28:59.683]                       }
[08:28:59.683]                       else {
[08:28:59.683]                         version <- NULL
[08:28:59.683]                       }
[08:28:59.683]                       if (!has_future || version < "1.8.0") {
[08:28:59.683]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:59.683]                           "", base::R.version$version.string), 
[08:28:59.683]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:59.683]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:59.683]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:59.683]                             "release", "version")], collapse = " "), 
[08:28:59.683]                           hostname = base::Sys.info()[["nodename"]])
[08:28:59.683]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:59.683]                           info)
[08:28:59.683]                         info <- base::paste(info, collapse = "; ")
[08:28:59.683]                         if (!has_future) {
[08:28:59.683]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:59.683]                             info)
[08:28:59.683]                         }
[08:28:59.683]                         else {
[08:28:59.683]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:59.683]                             info, version)
[08:28:59.683]                         }
[08:28:59.683]                         base::stop(msg)
[08:28:59.683]                       }
[08:28:59.683]                     })
[08:28:59.683]                   }
[08:28:59.683]                   ...future.strategy.old <- future::plan("list")
[08:28:59.683]                   options(future.plan = NULL)
[08:28:59.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:59.683]                 }
[08:28:59.683]                 ...future.workdir <- getwd()
[08:28:59.683]             }
[08:28:59.683]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:59.683]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:59.683]         }
[08:28:59.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:59.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:59.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:59.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:59.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:59.683]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:59.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:59.683]             base::names(...future.oldOptions))
[08:28:59.683]     }
[08:28:59.683]     if (FALSE) {
[08:28:59.683]     }
[08:28:59.683]     else {
[08:28:59.683]         if (TRUE) {
[08:28:59.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:59.683]                 open = "w")
[08:28:59.683]         }
[08:28:59.683]         else {
[08:28:59.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:59.683]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:59.683]         }
[08:28:59.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:59.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:59.683]             base::sink(type = "output", split = FALSE)
[08:28:59.683]             base::close(...future.stdout)
[08:28:59.683]         }, add = TRUE)
[08:28:59.683]     }
[08:28:59.683]     ...future.frame <- base::sys.nframe()
[08:28:59.683]     ...future.conditions <- base::list()
[08:28:59.683]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:59.683]     if (FALSE) {
[08:28:59.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:59.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:59.683]     }
[08:28:59.683]     ...future.result <- base::tryCatch({
[08:28:59.683]         base::withCallingHandlers({
[08:28:59.683]             ...future.value <- base::withVisible(base::local(1))
[08:28:59.683]             future::FutureResult(value = ...future.value$value, 
[08:28:59.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.683]                   ...future.rng), globalenv = if (FALSE) 
[08:28:59.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:59.683]                     ...future.globalenv.names))
[08:28:59.683]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:59.683]         }, condition = base::local({
[08:28:59.683]             c <- base::c
[08:28:59.683]             inherits <- base::inherits
[08:28:59.683]             invokeRestart <- base::invokeRestart
[08:28:59.683]             length <- base::length
[08:28:59.683]             list <- base::list
[08:28:59.683]             seq.int <- base::seq.int
[08:28:59.683]             signalCondition <- base::signalCondition
[08:28:59.683]             sys.calls <- base::sys.calls
[08:28:59.683]             `[[` <- base::`[[`
[08:28:59.683]             `+` <- base::`+`
[08:28:59.683]             `<<-` <- base::`<<-`
[08:28:59.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:59.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:59.683]                   3L)]
[08:28:59.683]             }
[08:28:59.683]             function(cond) {
[08:28:59.683]                 is_error <- inherits(cond, "error")
[08:28:59.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:59.683]                   NULL)
[08:28:59.683]                 if (is_error) {
[08:28:59.683]                   sessionInformation <- function() {
[08:28:59.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:59.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:59.683]                       search = base::search(), system = base::Sys.info())
[08:28:59.683]                   }
[08:28:59.683]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:59.683]                     cond$call), session = sessionInformation(), 
[08:28:59.683]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:59.683]                   signalCondition(cond)
[08:28:59.683]                 }
[08:28:59.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:59.683]                 "immediateCondition"))) {
[08:28:59.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:59.683]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:59.683]                   if (TRUE && !signal) {
[08:28:59.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.683]                     {
[08:28:59.683]                       inherits <- base::inherits
[08:28:59.683]                       invokeRestart <- base::invokeRestart
[08:28:59.683]                       is.null <- base::is.null
[08:28:59.683]                       muffled <- FALSE
[08:28:59.683]                       if (inherits(cond, "message")) {
[08:28:59.683]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.683]                         if (muffled) 
[08:28:59.683]                           invokeRestart("muffleMessage")
[08:28:59.683]                       }
[08:28:59.683]                       else if (inherits(cond, "warning")) {
[08:28:59.683]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.683]                         if (muffled) 
[08:28:59.683]                           invokeRestart("muffleWarning")
[08:28:59.683]                       }
[08:28:59.683]                       else if (inherits(cond, "condition")) {
[08:28:59.683]                         if (!is.null(pattern)) {
[08:28:59.683]                           computeRestarts <- base::computeRestarts
[08:28:59.683]                           grepl <- base::grepl
[08:28:59.683]                           restarts <- computeRestarts(cond)
[08:28:59.683]                           for (restart in restarts) {
[08:28:59.683]                             name <- restart$name
[08:28:59.683]                             if (is.null(name)) 
[08:28:59.683]                               next
[08:28:59.683]                             if (!grepl(pattern, name)) 
[08:28:59.683]                               next
[08:28:59.683]                             invokeRestart(restart)
[08:28:59.683]                             muffled <- TRUE
[08:28:59.683]                             break
[08:28:59.683]                           }
[08:28:59.683]                         }
[08:28:59.683]                       }
[08:28:59.683]                       invisible(muffled)
[08:28:59.683]                     }
[08:28:59.683]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.683]                   }
[08:28:59.683]                 }
[08:28:59.683]                 else {
[08:28:59.683]                   if (TRUE) {
[08:28:59.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.683]                     {
[08:28:59.683]                       inherits <- base::inherits
[08:28:59.683]                       invokeRestart <- base::invokeRestart
[08:28:59.683]                       is.null <- base::is.null
[08:28:59.683]                       muffled <- FALSE
[08:28:59.683]                       if (inherits(cond, "message")) {
[08:28:59.683]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.683]                         if (muffled) 
[08:28:59.683]                           invokeRestart("muffleMessage")
[08:28:59.683]                       }
[08:28:59.683]                       else if (inherits(cond, "warning")) {
[08:28:59.683]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.683]                         if (muffled) 
[08:28:59.683]                           invokeRestart("muffleWarning")
[08:28:59.683]                       }
[08:28:59.683]                       else if (inherits(cond, "condition")) {
[08:28:59.683]                         if (!is.null(pattern)) {
[08:28:59.683]                           computeRestarts <- base::computeRestarts
[08:28:59.683]                           grepl <- base::grepl
[08:28:59.683]                           restarts <- computeRestarts(cond)
[08:28:59.683]                           for (restart in restarts) {
[08:28:59.683]                             name <- restart$name
[08:28:59.683]                             if (is.null(name)) 
[08:28:59.683]                               next
[08:28:59.683]                             if (!grepl(pattern, name)) 
[08:28:59.683]                               next
[08:28:59.683]                             invokeRestart(restart)
[08:28:59.683]                             muffled <- TRUE
[08:28:59.683]                             break
[08:28:59.683]                           }
[08:28:59.683]                         }
[08:28:59.683]                       }
[08:28:59.683]                       invisible(muffled)
[08:28:59.683]                     }
[08:28:59.683]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.683]                   }
[08:28:59.683]                 }
[08:28:59.683]             }
[08:28:59.683]         }))
[08:28:59.683]     }, error = function(ex) {
[08:28:59.683]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:59.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.683]                 ...future.rng), started = ...future.startTime, 
[08:28:59.683]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:59.683]             version = "1.8"), class = "FutureResult")
[08:28:59.683]     }, finally = {
[08:28:59.683]         if (!identical(...future.workdir, getwd())) 
[08:28:59.683]             setwd(...future.workdir)
[08:28:59.683]         {
[08:28:59.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:59.683]                 ...future.oldOptions$nwarnings <- NULL
[08:28:59.683]             }
[08:28:59.683]             base::options(...future.oldOptions)
[08:28:59.683]             if (.Platform$OS.type == "windows") {
[08:28:59.683]                 old_names <- names(...future.oldEnvVars)
[08:28:59.683]                 envs <- base::Sys.getenv()
[08:28:59.683]                 names <- names(envs)
[08:28:59.683]                 common <- intersect(names, old_names)
[08:28:59.683]                 added <- setdiff(names, old_names)
[08:28:59.683]                 removed <- setdiff(old_names, names)
[08:28:59.683]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:59.683]                   envs[common]]
[08:28:59.683]                 NAMES <- toupper(changed)
[08:28:59.683]                 args <- list()
[08:28:59.683]                 for (kk in seq_along(NAMES)) {
[08:28:59.683]                   name <- changed[[kk]]
[08:28:59.683]                   NAME <- NAMES[[kk]]
[08:28:59.683]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.683]                     next
[08:28:59.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.683]                 }
[08:28:59.683]                 NAMES <- toupper(added)
[08:28:59.683]                 for (kk in seq_along(NAMES)) {
[08:28:59.683]                   name <- added[[kk]]
[08:28:59.683]                   NAME <- NAMES[[kk]]
[08:28:59.683]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.683]                     next
[08:28:59.683]                   args[[name]] <- ""
[08:28:59.683]                 }
[08:28:59.683]                 NAMES <- toupper(removed)
[08:28:59.683]                 for (kk in seq_along(NAMES)) {
[08:28:59.683]                   name <- removed[[kk]]
[08:28:59.683]                   NAME <- NAMES[[kk]]
[08:28:59.683]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.683]                     next
[08:28:59.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.683]                 }
[08:28:59.683]                 if (length(args) > 0) 
[08:28:59.683]                   base::do.call(base::Sys.setenv, args = args)
[08:28:59.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:59.683]             }
[08:28:59.683]             else {
[08:28:59.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:59.683]             }
[08:28:59.683]             {
[08:28:59.683]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:59.683]                   0L) {
[08:28:59.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:59.683]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:59.683]                   base::options(opts)
[08:28:59.683]                 }
[08:28:59.683]                 {
[08:28:59.683]                   {
[08:28:59.683]                     NULL
[08:28:59.683]                     RNGkind("Mersenne-Twister")
[08:28:59.683]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:59.683]                       inherits = FALSE)
[08:28:59.683]                   }
[08:28:59.683]                   options(future.plan = NULL)
[08:28:59.683]                   if (is.na(NA_character_)) 
[08:28:59.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:59.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:59.683]                     .init = FALSE)
[08:28:59.683]                 }
[08:28:59.683]             }
[08:28:59.683]         }
[08:28:59.683]     })
[08:28:59.683]     if (TRUE) {
[08:28:59.683]         base::sink(type = "output", split = FALSE)
[08:28:59.683]         if (TRUE) {
[08:28:59.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:59.683]         }
[08:28:59.683]         else {
[08:28:59.683]             ...future.result["stdout"] <- base::list(NULL)
[08:28:59.683]         }
[08:28:59.683]         base::close(...future.stdout)
[08:28:59.683]         ...future.stdout <- NULL
[08:28:59.683]     }
[08:28:59.683]     ...future.result$conditions <- ...future.conditions
[08:28:59.683]     ...future.result$finished <- base::Sys.time()
[08:28:59.683]     ...future.result
[08:28:59.683] }
[08:28:59.685] plan(): Setting new future strategy stack:
[08:28:59.685] List of future strategies:
[08:28:59.685] 1. sequential:
[08:28:59.685]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.685]    - tweaked: FALSE
[08:28:59.685]    - call: NULL
[08:28:59.685] plan(): nbrOfWorkers() = 1
[08:28:59.687] plan(): Setting new future strategy stack:
[08:28:59.687] List of future strategies:
[08:28:59.687] 1. sequential:
[08:28:59.687]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.687]    - tweaked: FALSE
[08:28:59.687]    - call: plan(strategy)
[08:28:59.687] plan(): nbrOfWorkers() = 1
[08:28:59.687] SequentialFuture started (and completed)
[08:28:59.688] - Launch lazy future ... done
[08:28:59.688] run() for ‘SequentialFuture’ ... done
[08:28:59.688] getGlobalsAndPackages() ...
[08:28:59.688] Searching for globals...
[08:28:59.688] 
[08:28:59.688] Searching for globals ... DONE
[08:28:59.688] - globals: [0] <none>
[08:28:59.688] getGlobalsAndPackages() ... DONE
[08:28:59.689] run() for ‘Future’ ...
[08:28:59.689] - state: ‘created’
[08:28:59.689] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:59.689] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:59.689] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:59.689]   - Field: ‘label’
[08:28:59.689]   - Field: ‘local’
[08:28:59.689]   - Field: ‘owner’
[08:28:59.690]   - Field: ‘envir’
[08:28:59.690]   - Field: ‘packages’
[08:28:59.690]   - Field: ‘gc’
[08:28:59.690]   - Field: ‘conditions’
[08:28:59.690]   - Field: ‘expr’
[08:28:59.690]   - Field: ‘uuid’
[08:28:59.690]   - Field: ‘seed’
[08:28:59.690]   - Field: ‘version’
[08:28:59.690]   - Field: ‘result’
[08:28:59.690]   - Field: ‘asynchronous’
[08:28:59.690]   - Field: ‘calls’
[08:28:59.690]   - Field: ‘globals’
[08:28:59.691]   - Field: ‘stdout’
[08:28:59.691]   - Field: ‘earlySignal’
[08:28:59.691]   - Field: ‘lazy’
[08:28:59.691]   - Field: ‘state’
[08:28:59.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:59.691] - Launch lazy future ...
[08:28:59.691] Packages needed by the future expression (n = 0): <none>
[08:28:59.691] Packages needed by future strategies (n = 0): <none>
[08:28:59.692] {
[08:28:59.692]     {
[08:28:59.692]         {
[08:28:59.692]             ...future.startTime <- base::Sys.time()
[08:28:59.692]             {
[08:28:59.692]                 {
[08:28:59.692]                   {
[08:28:59.692]                     base::local({
[08:28:59.692]                       has_future <- base::requireNamespace("future", 
[08:28:59.692]                         quietly = TRUE)
[08:28:59.692]                       if (has_future) {
[08:28:59.692]                         ns <- base::getNamespace("future")
[08:28:59.692]                         version <- ns[[".package"]][["version"]]
[08:28:59.692]                         if (is.null(version)) 
[08:28:59.692]                           version <- utils::packageVersion("future")
[08:28:59.692]                       }
[08:28:59.692]                       else {
[08:28:59.692]                         version <- NULL
[08:28:59.692]                       }
[08:28:59.692]                       if (!has_future || version < "1.8.0") {
[08:28:59.692]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:59.692]                           "", base::R.version$version.string), 
[08:28:59.692]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:59.692]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:59.692]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:59.692]                             "release", "version")], collapse = " "), 
[08:28:59.692]                           hostname = base::Sys.info()[["nodename"]])
[08:28:59.692]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:59.692]                           info)
[08:28:59.692]                         info <- base::paste(info, collapse = "; ")
[08:28:59.692]                         if (!has_future) {
[08:28:59.692]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:59.692]                             info)
[08:28:59.692]                         }
[08:28:59.692]                         else {
[08:28:59.692]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:59.692]                             info, version)
[08:28:59.692]                         }
[08:28:59.692]                         base::stop(msg)
[08:28:59.692]                       }
[08:28:59.692]                     })
[08:28:59.692]                   }
[08:28:59.692]                   ...future.strategy.old <- future::plan("list")
[08:28:59.692]                   options(future.plan = NULL)
[08:28:59.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:59.692]                 }
[08:28:59.692]                 ...future.workdir <- getwd()
[08:28:59.692]             }
[08:28:59.692]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:59.692]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:59.692]         }
[08:28:59.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:59.692]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:59.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:59.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:59.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:59.692]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:59.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:59.692]             base::names(...future.oldOptions))
[08:28:59.692]     }
[08:28:59.692]     if (FALSE) {
[08:28:59.692]     }
[08:28:59.692]     else {
[08:28:59.692]         if (TRUE) {
[08:28:59.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:59.692]                 open = "w")
[08:28:59.692]         }
[08:28:59.692]         else {
[08:28:59.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:59.692]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:59.692]         }
[08:28:59.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:59.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:59.692]             base::sink(type = "output", split = FALSE)
[08:28:59.692]             base::close(...future.stdout)
[08:28:59.692]         }, add = TRUE)
[08:28:59.692]     }
[08:28:59.692]     ...future.frame <- base::sys.nframe()
[08:28:59.692]     ...future.conditions <- base::list()
[08:28:59.692]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:59.692]     if (FALSE) {
[08:28:59.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:59.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:59.692]     }
[08:28:59.692]     ...future.result <- base::tryCatch({
[08:28:59.692]         base::withCallingHandlers({
[08:28:59.692]             ...future.value <- base::withVisible(base::local(2))
[08:28:59.692]             future::FutureResult(value = ...future.value$value, 
[08:28:59.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.692]                   ...future.rng), globalenv = if (FALSE) 
[08:28:59.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:59.692]                     ...future.globalenv.names))
[08:28:59.692]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:59.692]         }, condition = base::local({
[08:28:59.692]             c <- base::c
[08:28:59.692]             inherits <- base::inherits
[08:28:59.692]             invokeRestart <- base::invokeRestart
[08:28:59.692]             length <- base::length
[08:28:59.692]             list <- base::list
[08:28:59.692]             seq.int <- base::seq.int
[08:28:59.692]             signalCondition <- base::signalCondition
[08:28:59.692]             sys.calls <- base::sys.calls
[08:28:59.692]             `[[` <- base::`[[`
[08:28:59.692]             `+` <- base::`+`
[08:28:59.692]             `<<-` <- base::`<<-`
[08:28:59.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:59.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:59.692]                   3L)]
[08:28:59.692]             }
[08:28:59.692]             function(cond) {
[08:28:59.692]                 is_error <- inherits(cond, "error")
[08:28:59.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:59.692]                   NULL)
[08:28:59.692]                 if (is_error) {
[08:28:59.692]                   sessionInformation <- function() {
[08:28:59.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:59.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:59.692]                       search = base::search(), system = base::Sys.info())
[08:28:59.692]                   }
[08:28:59.692]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:59.692]                     cond$call), session = sessionInformation(), 
[08:28:59.692]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:59.692]                   signalCondition(cond)
[08:28:59.692]                 }
[08:28:59.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:59.692]                 "immediateCondition"))) {
[08:28:59.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:59.692]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:59.692]                   if (TRUE && !signal) {
[08:28:59.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.692]                     {
[08:28:59.692]                       inherits <- base::inherits
[08:28:59.692]                       invokeRestart <- base::invokeRestart
[08:28:59.692]                       is.null <- base::is.null
[08:28:59.692]                       muffled <- FALSE
[08:28:59.692]                       if (inherits(cond, "message")) {
[08:28:59.692]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.692]                         if (muffled) 
[08:28:59.692]                           invokeRestart("muffleMessage")
[08:28:59.692]                       }
[08:28:59.692]                       else if (inherits(cond, "warning")) {
[08:28:59.692]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.692]                         if (muffled) 
[08:28:59.692]                           invokeRestart("muffleWarning")
[08:28:59.692]                       }
[08:28:59.692]                       else if (inherits(cond, "condition")) {
[08:28:59.692]                         if (!is.null(pattern)) {
[08:28:59.692]                           computeRestarts <- base::computeRestarts
[08:28:59.692]                           grepl <- base::grepl
[08:28:59.692]                           restarts <- computeRestarts(cond)
[08:28:59.692]                           for (restart in restarts) {
[08:28:59.692]                             name <- restart$name
[08:28:59.692]                             if (is.null(name)) 
[08:28:59.692]                               next
[08:28:59.692]                             if (!grepl(pattern, name)) 
[08:28:59.692]                               next
[08:28:59.692]                             invokeRestart(restart)
[08:28:59.692]                             muffled <- TRUE
[08:28:59.692]                             break
[08:28:59.692]                           }
[08:28:59.692]                         }
[08:28:59.692]                       }
[08:28:59.692]                       invisible(muffled)
[08:28:59.692]                     }
[08:28:59.692]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.692]                   }
[08:28:59.692]                 }
[08:28:59.692]                 else {
[08:28:59.692]                   if (TRUE) {
[08:28:59.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.692]                     {
[08:28:59.692]                       inherits <- base::inherits
[08:28:59.692]                       invokeRestart <- base::invokeRestart
[08:28:59.692]                       is.null <- base::is.null
[08:28:59.692]                       muffled <- FALSE
[08:28:59.692]                       if (inherits(cond, "message")) {
[08:28:59.692]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.692]                         if (muffled) 
[08:28:59.692]                           invokeRestart("muffleMessage")
[08:28:59.692]                       }
[08:28:59.692]                       else if (inherits(cond, "warning")) {
[08:28:59.692]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.692]                         if (muffled) 
[08:28:59.692]                           invokeRestart("muffleWarning")
[08:28:59.692]                       }
[08:28:59.692]                       else if (inherits(cond, "condition")) {
[08:28:59.692]                         if (!is.null(pattern)) {
[08:28:59.692]                           computeRestarts <- base::computeRestarts
[08:28:59.692]                           grepl <- base::grepl
[08:28:59.692]                           restarts <- computeRestarts(cond)
[08:28:59.692]                           for (restart in restarts) {
[08:28:59.692]                             name <- restart$name
[08:28:59.692]                             if (is.null(name)) 
[08:28:59.692]                               next
[08:28:59.692]                             if (!grepl(pattern, name)) 
[08:28:59.692]                               next
[08:28:59.692]                             invokeRestart(restart)
[08:28:59.692]                             muffled <- TRUE
[08:28:59.692]                             break
[08:28:59.692]                           }
[08:28:59.692]                         }
[08:28:59.692]                       }
[08:28:59.692]                       invisible(muffled)
[08:28:59.692]                     }
[08:28:59.692]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.692]                   }
[08:28:59.692]                 }
[08:28:59.692]             }
[08:28:59.692]         }))
[08:28:59.692]     }, error = function(ex) {
[08:28:59.692]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:59.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.692]                 ...future.rng), started = ...future.startTime, 
[08:28:59.692]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:59.692]             version = "1.8"), class = "FutureResult")
[08:28:59.692]     }, finally = {
[08:28:59.692]         if (!identical(...future.workdir, getwd())) 
[08:28:59.692]             setwd(...future.workdir)
[08:28:59.692]         {
[08:28:59.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:59.692]                 ...future.oldOptions$nwarnings <- NULL
[08:28:59.692]             }
[08:28:59.692]             base::options(...future.oldOptions)
[08:28:59.692]             if (.Platform$OS.type == "windows") {
[08:28:59.692]                 old_names <- names(...future.oldEnvVars)
[08:28:59.692]                 envs <- base::Sys.getenv()
[08:28:59.692]                 names <- names(envs)
[08:28:59.692]                 common <- intersect(names, old_names)
[08:28:59.692]                 added <- setdiff(names, old_names)
[08:28:59.692]                 removed <- setdiff(old_names, names)
[08:28:59.692]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:59.692]                   envs[common]]
[08:28:59.692]                 NAMES <- toupper(changed)
[08:28:59.692]                 args <- list()
[08:28:59.692]                 for (kk in seq_along(NAMES)) {
[08:28:59.692]                   name <- changed[[kk]]
[08:28:59.692]                   NAME <- NAMES[[kk]]
[08:28:59.692]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.692]                     next
[08:28:59.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.692]                 }
[08:28:59.692]                 NAMES <- toupper(added)
[08:28:59.692]                 for (kk in seq_along(NAMES)) {
[08:28:59.692]                   name <- added[[kk]]
[08:28:59.692]                   NAME <- NAMES[[kk]]
[08:28:59.692]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.692]                     next
[08:28:59.692]                   args[[name]] <- ""
[08:28:59.692]                 }
[08:28:59.692]                 NAMES <- toupper(removed)
[08:28:59.692]                 for (kk in seq_along(NAMES)) {
[08:28:59.692]                   name <- removed[[kk]]
[08:28:59.692]                   NAME <- NAMES[[kk]]
[08:28:59.692]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.692]                     next
[08:28:59.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.692]                 }
[08:28:59.692]                 if (length(args) > 0) 
[08:28:59.692]                   base::do.call(base::Sys.setenv, args = args)
[08:28:59.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:59.692]             }
[08:28:59.692]             else {
[08:28:59.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:59.692]             }
[08:28:59.692]             {
[08:28:59.692]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:59.692]                   0L) {
[08:28:59.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:59.692]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:59.692]                   base::options(opts)
[08:28:59.692]                 }
[08:28:59.692]                 {
[08:28:59.692]                   {
[08:28:59.692]                     NULL
[08:28:59.692]                     RNGkind("Mersenne-Twister")
[08:28:59.692]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:59.692]                       inherits = FALSE)
[08:28:59.692]                   }
[08:28:59.692]                   options(future.plan = NULL)
[08:28:59.692]                   if (is.na(NA_character_)) 
[08:28:59.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:59.692]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:59.692]                     .init = FALSE)
[08:28:59.692]                 }
[08:28:59.692]             }
[08:28:59.692]         }
[08:28:59.692]     })
[08:28:59.692]     if (TRUE) {
[08:28:59.692]         base::sink(type = "output", split = FALSE)
[08:28:59.692]         if (TRUE) {
[08:28:59.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:59.692]         }
[08:28:59.692]         else {
[08:28:59.692]             ...future.result["stdout"] <- base::list(NULL)
[08:28:59.692]         }
[08:28:59.692]         base::close(...future.stdout)
[08:28:59.692]         ...future.stdout <- NULL
[08:28:59.692]     }
[08:28:59.692]     ...future.result$conditions <- ...future.conditions
[08:28:59.692]     ...future.result$finished <- base::Sys.time()
[08:28:59.692]     ...future.result
[08:28:59.692] }
[08:28:59.693] plan(): Setting new future strategy stack:
[08:28:59.693] List of future strategies:
[08:28:59.693] 1. sequential:
[08:28:59.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.693]    - tweaked: FALSE
[08:28:59.693]    - call: NULL
[08:28:59.694] plan(): nbrOfWorkers() = 1
[08:28:59.695] plan(): Setting new future strategy stack:
[08:28:59.695] List of future strategies:
[08:28:59.695] 1. sequential:
[08:28:59.695]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.695]    - tweaked: FALSE
[08:28:59.695]    - call: plan(strategy)
[08:28:59.695] plan(): nbrOfWorkers() = 1
[08:28:59.695] SequentialFuture started (and completed)
[08:28:59.695] - Launch lazy future ... done
[08:28:59.696] run() for ‘SequentialFuture’ ... done
[08:28:59.696] resolve() on list ...
[08:28:59.696]  recursive: 0
[08:28:59.696]  length: 3
[08:28:59.696]  elements: ‘a’, ‘b’, ‘’
[08:28:59.696] resolved() for ‘SequentialFuture’ ...
[08:28:59.696] - state: ‘finished’
[08:28:59.696] - run: TRUE
[08:28:59.696] - result: ‘FutureResult’
[08:28:59.696] resolved() for ‘SequentialFuture’ ... done
[08:28:59.697] Future #1
[08:28:59.697]  length: 2 (resolved future 1)
[08:28:59.697] resolved() for ‘SequentialFuture’ ...
[08:28:59.697] - state: ‘finished’
[08:28:59.697] - run: TRUE
[08:28:59.697] - result: ‘FutureResult’
[08:28:59.697] resolved() for ‘SequentialFuture’ ... done
[08:28:59.697] Future #2
[08:28:59.697]  length: 1 (resolved future 2)
[08:28:59.697]  length: 0 (resolved future 3)
[08:28:59.698] resolve() on list ... DONE
[08:28:59.698] resolved() for ‘SequentialFuture’ ...
[08:28:59.698] - state: ‘finished’
[08:28:59.698] - run: TRUE
[08:28:59.698] - result: ‘FutureResult’
[08:28:59.698] resolved() for ‘SequentialFuture’ ... done
[08:28:59.698] resolved() for ‘SequentialFuture’ ...
[08:28:59.698] - state: ‘finished’
[08:28:59.698] - run: TRUE
[08:28:59.698] - result: ‘FutureResult’
[08:28:59.698] resolved() for ‘SequentialFuture’ ... done
[08:28:59.699] getGlobalsAndPackages() ...
[08:28:59.699] Searching for globals...
[08:28:59.699] 
[08:28:59.699] Searching for globals ... DONE
[08:28:59.699] - globals: [0] <none>
[08:28:59.699] getGlobalsAndPackages() ... DONE
[08:28:59.699] getGlobalsAndPackages() ...
[08:28:59.699] Searching for globals...
[08:28:59.700] 
[08:28:59.700] Searching for globals ... DONE
[08:28:59.700] - globals: [0] <none>
[08:28:59.702] getGlobalsAndPackages() ... DONE
[08:28:59.702] run() for ‘Future’ ...
[08:28:59.702] - state: ‘created’
[08:28:59.702] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:59.703] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:59.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:59.703]   - Field: ‘label’
[08:28:59.703]   - Field: ‘local’
[08:28:59.703]   - Field: ‘owner’
[08:28:59.703]   - Field: ‘envir’
[08:28:59.703]   - Field: ‘packages’
[08:28:59.703]   - Field: ‘gc’
[08:28:59.703]   - Field: ‘conditions’
[08:28:59.703]   - Field: ‘expr’
[08:28:59.704]   - Field: ‘uuid’
[08:28:59.704]   - Field: ‘seed’
[08:28:59.704]   - Field: ‘version’
[08:28:59.704]   - Field: ‘result’
[08:28:59.704]   - Field: ‘asynchronous’
[08:28:59.704]   - Field: ‘calls’
[08:28:59.704]   - Field: ‘globals’
[08:28:59.704]   - Field: ‘stdout’
[08:28:59.704]   - Field: ‘earlySignal’
[08:28:59.704]   - Field: ‘lazy’
[08:28:59.704]   - Field: ‘state’
[08:28:59.705] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:59.705] - Launch lazy future ...
[08:28:59.705] Packages needed by the future expression (n = 0): <none>
[08:28:59.705] Packages needed by future strategies (n = 0): <none>
[08:28:59.705] {
[08:28:59.705]     {
[08:28:59.705]         {
[08:28:59.705]             ...future.startTime <- base::Sys.time()
[08:28:59.705]             {
[08:28:59.705]                 {
[08:28:59.705]                   {
[08:28:59.705]                     base::local({
[08:28:59.705]                       has_future <- base::requireNamespace("future", 
[08:28:59.705]                         quietly = TRUE)
[08:28:59.705]                       if (has_future) {
[08:28:59.705]                         ns <- base::getNamespace("future")
[08:28:59.705]                         version <- ns[[".package"]][["version"]]
[08:28:59.705]                         if (is.null(version)) 
[08:28:59.705]                           version <- utils::packageVersion("future")
[08:28:59.705]                       }
[08:28:59.705]                       else {
[08:28:59.705]                         version <- NULL
[08:28:59.705]                       }
[08:28:59.705]                       if (!has_future || version < "1.8.0") {
[08:28:59.705]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:59.705]                           "", base::R.version$version.string), 
[08:28:59.705]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:59.705]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:59.705]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:59.705]                             "release", "version")], collapse = " "), 
[08:28:59.705]                           hostname = base::Sys.info()[["nodename"]])
[08:28:59.705]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:59.705]                           info)
[08:28:59.705]                         info <- base::paste(info, collapse = "; ")
[08:28:59.705]                         if (!has_future) {
[08:28:59.705]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:59.705]                             info)
[08:28:59.705]                         }
[08:28:59.705]                         else {
[08:28:59.705]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:59.705]                             info, version)
[08:28:59.705]                         }
[08:28:59.705]                         base::stop(msg)
[08:28:59.705]                       }
[08:28:59.705]                     })
[08:28:59.705]                   }
[08:28:59.705]                   ...future.strategy.old <- future::plan("list")
[08:28:59.705]                   options(future.plan = NULL)
[08:28:59.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:59.705]                 }
[08:28:59.705]                 ...future.workdir <- getwd()
[08:28:59.705]             }
[08:28:59.705]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:59.705]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:59.705]         }
[08:28:59.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:59.705]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:59.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:59.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:59.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:59.705]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:59.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:59.705]             base::names(...future.oldOptions))
[08:28:59.705]     }
[08:28:59.705]     if (FALSE) {
[08:28:59.705]     }
[08:28:59.705]     else {
[08:28:59.705]         if (TRUE) {
[08:28:59.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:59.705]                 open = "w")
[08:28:59.705]         }
[08:28:59.705]         else {
[08:28:59.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:59.705]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:59.705]         }
[08:28:59.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:59.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:59.705]             base::sink(type = "output", split = FALSE)
[08:28:59.705]             base::close(...future.stdout)
[08:28:59.705]         }, add = TRUE)
[08:28:59.705]     }
[08:28:59.705]     ...future.frame <- base::sys.nframe()
[08:28:59.705]     ...future.conditions <- base::list()
[08:28:59.705]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:59.705]     if (FALSE) {
[08:28:59.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:59.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:59.705]     }
[08:28:59.705]     ...future.result <- base::tryCatch({
[08:28:59.705]         base::withCallingHandlers({
[08:28:59.705]             ...future.value <- base::withVisible(base::local(2))
[08:28:59.705]             future::FutureResult(value = ...future.value$value, 
[08:28:59.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.705]                   ...future.rng), globalenv = if (FALSE) 
[08:28:59.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:59.705]                     ...future.globalenv.names))
[08:28:59.705]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:59.705]         }, condition = base::local({
[08:28:59.705]             c <- base::c
[08:28:59.705]             inherits <- base::inherits
[08:28:59.705]             invokeRestart <- base::invokeRestart
[08:28:59.705]             length <- base::length
[08:28:59.705]             list <- base::list
[08:28:59.705]             seq.int <- base::seq.int
[08:28:59.705]             signalCondition <- base::signalCondition
[08:28:59.705]             sys.calls <- base::sys.calls
[08:28:59.705]             `[[` <- base::`[[`
[08:28:59.705]             `+` <- base::`+`
[08:28:59.705]             `<<-` <- base::`<<-`
[08:28:59.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:59.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:59.705]                   3L)]
[08:28:59.705]             }
[08:28:59.705]             function(cond) {
[08:28:59.705]                 is_error <- inherits(cond, "error")
[08:28:59.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:59.705]                   NULL)
[08:28:59.705]                 if (is_error) {
[08:28:59.705]                   sessionInformation <- function() {
[08:28:59.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:59.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:59.705]                       search = base::search(), system = base::Sys.info())
[08:28:59.705]                   }
[08:28:59.705]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:59.705]                     cond$call), session = sessionInformation(), 
[08:28:59.705]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:59.705]                   signalCondition(cond)
[08:28:59.705]                 }
[08:28:59.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:59.705]                 "immediateCondition"))) {
[08:28:59.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:59.705]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:59.705]                   if (TRUE && !signal) {
[08:28:59.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.705]                     {
[08:28:59.705]                       inherits <- base::inherits
[08:28:59.705]                       invokeRestart <- base::invokeRestart
[08:28:59.705]                       is.null <- base::is.null
[08:28:59.705]                       muffled <- FALSE
[08:28:59.705]                       if (inherits(cond, "message")) {
[08:28:59.705]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.705]                         if (muffled) 
[08:28:59.705]                           invokeRestart("muffleMessage")
[08:28:59.705]                       }
[08:28:59.705]                       else if (inherits(cond, "warning")) {
[08:28:59.705]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.705]                         if (muffled) 
[08:28:59.705]                           invokeRestart("muffleWarning")
[08:28:59.705]                       }
[08:28:59.705]                       else if (inherits(cond, "condition")) {
[08:28:59.705]                         if (!is.null(pattern)) {
[08:28:59.705]                           computeRestarts <- base::computeRestarts
[08:28:59.705]                           grepl <- base::grepl
[08:28:59.705]                           restarts <- computeRestarts(cond)
[08:28:59.705]                           for (restart in restarts) {
[08:28:59.705]                             name <- restart$name
[08:28:59.705]                             if (is.null(name)) 
[08:28:59.705]                               next
[08:28:59.705]                             if (!grepl(pattern, name)) 
[08:28:59.705]                               next
[08:28:59.705]                             invokeRestart(restart)
[08:28:59.705]                             muffled <- TRUE
[08:28:59.705]                             break
[08:28:59.705]                           }
[08:28:59.705]                         }
[08:28:59.705]                       }
[08:28:59.705]                       invisible(muffled)
[08:28:59.705]                     }
[08:28:59.705]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.705]                   }
[08:28:59.705]                 }
[08:28:59.705]                 else {
[08:28:59.705]                   if (TRUE) {
[08:28:59.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.705]                     {
[08:28:59.705]                       inherits <- base::inherits
[08:28:59.705]                       invokeRestart <- base::invokeRestart
[08:28:59.705]                       is.null <- base::is.null
[08:28:59.705]                       muffled <- FALSE
[08:28:59.705]                       if (inherits(cond, "message")) {
[08:28:59.705]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.705]                         if (muffled) 
[08:28:59.705]                           invokeRestart("muffleMessage")
[08:28:59.705]                       }
[08:28:59.705]                       else if (inherits(cond, "warning")) {
[08:28:59.705]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.705]                         if (muffled) 
[08:28:59.705]                           invokeRestart("muffleWarning")
[08:28:59.705]                       }
[08:28:59.705]                       else if (inherits(cond, "condition")) {
[08:28:59.705]                         if (!is.null(pattern)) {
[08:28:59.705]                           computeRestarts <- base::computeRestarts
[08:28:59.705]                           grepl <- base::grepl
[08:28:59.705]                           restarts <- computeRestarts(cond)
[08:28:59.705]                           for (restart in restarts) {
[08:28:59.705]                             name <- restart$name
[08:28:59.705]                             if (is.null(name)) 
[08:28:59.705]                               next
[08:28:59.705]                             if (!grepl(pattern, name)) 
[08:28:59.705]                               next
[08:28:59.705]                             invokeRestart(restart)
[08:28:59.705]                             muffled <- TRUE
[08:28:59.705]                             break
[08:28:59.705]                           }
[08:28:59.705]                         }
[08:28:59.705]                       }
[08:28:59.705]                       invisible(muffled)
[08:28:59.705]                     }
[08:28:59.705]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.705]                   }
[08:28:59.705]                 }
[08:28:59.705]             }
[08:28:59.705]         }))
[08:28:59.705]     }, error = function(ex) {
[08:28:59.705]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:59.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.705]                 ...future.rng), started = ...future.startTime, 
[08:28:59.705]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:59.705]             version = "1.8"), class = "FutureResult")
[08:28:59.705]     }, finally = {
[08:28:59.705]         if (!identical(...future.workdir, getwd())) 
[08:28:59.705]             setwd(...future.workdir)
[08:28:59.705]         {
[08:28:59.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:59.705]                 ...future.oldOptions$nwarnings <- NULL
[08:28:59.705]             }
[08:28:59.705]             base::options(...future.oldOptions)
[08:28:59.705]             if (.Platform$OS.type == "windows") {
[08:28:59.705]                 old_names <- names(...future.oldEnvVars)
[08:28:59.705]                 envs <- base::Sys.getenv()
[08:28:59.705]                 names <- names(envs)
[08:28:59.705]                 common <- intersect(names, old_names)
[08:28:59.705]                 added <- setdiff(names, old_names)
[08:28:59.705]                 removed <- setdiff(old_names, names)
[08:28:59.705]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:59.705]                   envs[common]]
[08:28:59.705]                 NAMES <- toupper(changed)
[08:28:59.705]                 args <- list()
[08:28:59.705]                 for (kk in seq_along(NAMES)) {
[08:28:59.705]                   name <- changed[[kk]]
[08:28:59.705]                   NAME <- NAMES[[kk]]
[08:28:59.705]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.705]                     next
[08:28:59.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.705]                 }
[08:28:59.705]                 NAMES <- toupper(added)
[08:28:59.705]                 for (kk in seq_along(NAMES)) {
[08:28:59.705]                   name <- added[[kk]]
[08:28:59.705]                   NAME <- NAMES[[kk]]
[08:28:59.705]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.705]                     next
[08:28:59.705]                   args[[name]] <- ""
[08:28:59.705]                 }
[08:28:59.705]                 NAMES <- toupper(removed)
[08:28:59.705]                 for (kk in seq_along(NAMES)) {
[08:28:59.705]                   name <- removed[[kk]]
[08:28:59.705]                   NAME <- NAMES[[kk]]
[08:28:59.705]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.705]                     next
[08:28:59.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.705]                 }
[08:28:59.705]                 if (length(args) > 0) 
[08:28:59.705]                   base::do.call(base::Sys.setenv, args = args)
[08:28:59.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:59.705]             }
[08:28:59.705]             else {
[08:28:59.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:59.705]             }
[08:28:59.705]             {
[08:28:59.705]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:59.705]                   0L) {
[08:28:59.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:59.705]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:59.705]                   base::options(opts)
[08:28:59.705]                 }
[08:28:59.705]                 {
[08:28:59.705]                   {
[08:28:59.705]                     NULL
[08:28:59.705]                     RNGkind("Mersenne-Twister")
[08:28:59.705]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:59.705]                       inherits = FALSE)
[08:28:59.705]                   }
[08:28:59.705]                   options(future.plan = NULL)
[08:28:59.705]                   if (is.na(NA_character_)) 
[08:28:59.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:59.705]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:59.705]                     .init = FALSE)
[08:28:59.705]                 }
[08:28:59.705]             }
[08:28:59.705]         }
[08:28:59.705]     })
[08:28:59.705]     if (TRUE) {
[08:28:59.705]         base::sink(type = "output", split = FALSE)
[08:28:59.705]         if (TRUE) {
[08:28:59.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:59.705]         }
[08:28:59.705]         else {
[08:28:59.705]             ...future.result["stdout"] <- base::list(NULL)
[08:28:59.705]         }
[08:28:59.705]         base::close(...future.stdout)
[08:28:59.705]         ...future.stdout <- NULL
[08:28:59.705]     }
[08:28:59.705]     ...future.result$conditions <- ...future.conditions
[08:28:59.705]     ...future.result$finished <- base::Sys.time()
[08:28:59.705]     ...future.result
[08:28:59.705] }
[08:28:59.707] plan(): Setting new future strategy stack:
[08:28:59.707] List of future strategies:
[08:28:59.707] 1. sequential:
[08:28:59.707]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.707]    - tweaked: FALSE
[08:28:59.707]    - call: NULL
[08:28:59.708] plan(): nbrOfWorkers() = 1
[08:28:59.708] plan(): Setting new future strategy stack:
[08:28:59.708] List of future strategies:
[08:28:59.708] 1. sequential:
[08:28:59.708]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.708]    - tweaked: FALSE
[08:28:59.708]    - call: plan(strategy)
[08:28:59.709] plan(): nbrOfWorkers() = 1
[08:28:59.709] SequentialFuture started (and completed)
[08:28:59.709] - Launch lazy future ... done
[08:28:59.709] run() for ‘SequentialFuture’ ... done
[08:28:59.709] resolve() on list ...
[08:28:59.709]  recursive: 0
[08:28:59.709]  length: 3
[08:28:59.710]  elements: ‘a’, ‘b’, ‘’
[08:28:59.710] run() for ‘Future’ ...
[08:28:59.710] - state: ‘created’
[08:28:59.710] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:59.710] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:59.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:59.710]   - Field: ‘label’
[08:28:59.710]   - Field: ‘local’
[08:28:59.711]   - Field: ‘owner’
[08:28:59.711]   - Field: ‘envir’
[08:28:59.711]   - Field: ‘packages’
[08:28:59.711]   - Field: ‘gc’
[08:28:59.711]   - Field: ‘conditions’
[08:28:59.711]   - Field: ‘expr’
[08:28:59.711]   - Field: ‘uuid’
[08:28:59.711]   - Field: ‘seed’
[08:28:59.711]   - Field: ‘version’
[08:28:59.711]   - Field: ‘result’
[08:28:59.711]   - Field: ‘asynchronous’
[08:28:59.711]   - Field: ‘calls’
[08:28:59.712]   - Field: ‘globals’
[08:28:59.712]   - Field: ‘stdout’
[08:28:59.712]   - Field: ‘earlySignal’
[08:28:59.712]   - Field: ‘lazy’
[08:28:59.712]   - Field: ‘state’
[08:28:59.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:59.712] - Launch lazy future ...
[08:28:59.712] Packages needed by the future expression (n = 0): <none>
[08:28:59.712] Packages needed by future strategies (n = 0): <none>
[08:28:59.713] {
[08:28:59.713]     {
[08:28:59.713]         {
[08:28:59.713]             ...future.startTime <- base::Sys.time()
[08:28:59.713]             {
[08:28:59.713]                 {
[08:28:59.713]                   {
[08:28:59.713]                     base::local({
[08:28:59.713]                       has_future <- base::requireNamespace("future", 
[08:28:59.713]                         quietly = TRUE)
[08:28:59.713]                       if (has_future) {
[08:28:59.713]                         ns <- base::getNamespace("future")
[08:28:59.713]                         version <- ns[[".package"]][["version"]]
[08:28:59.713]                         if (is.null(version)) 
[08:28:59.713]                           version <- utils::packageVersion("future")
[08:28:59.713]                       }
[08:28:59.713]                       else {
[08:28:59.713]                         version <- NULL
[08:28:59.713]                       }
[08:28:59.713]                       if (!has_future || version < "1.8.0") {
[08:28:59.713]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:59.713]                           "", base::R.version$version.string), 
[08:28:59.713]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:59.713]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:59.713]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:59.713]                             "release", "version")], collapse = " "), 
[08:28:59.713]                           hostname = base::Sys.info()[["nodename"]])
[08:28:59.713]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:59.713]                           info)
[08:28:59.713]                         info <- base::paste(info, collapse = "; ")
[08:28:59.713]                         if (!has_future) {
[08:28:59.713]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:59.713]                             info)
[08:28:59.713]                         }
[08:28:59.713]                         else {
[08:28:59.713]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:59.713]                             info, version)
[08:28:59.713]                         }
[08:28:59.713]                         base::stop(msg)
[08:28:59.713]                       }
[08:28:59.713]                     })
[08:28:59.713]                   }
[08:28:59.713]                   ...future.strategy.old <- future::plan("list")
[08:28:59.713]                   options(future.plan = NULL)
[08:28:59.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:59.713]                 }
[08:28:59.713]                 ...future.workdir <- getwd()
[08:28:59.713]             }
[08:28:59.713]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:59.713]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:59.713]         }
[08:28:59.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:59.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:59.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:59.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:59.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:59.713]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:59.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:59.713]             base::names(...future.oldOptions))
[08:28:59.713]     }
[08:28:59.713]     if (FALSE) {
[08:28:59.713]     }
[08:28:59.713]     else {
[08:28:59.713]         if (TRUE) {
[08:28:59.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:59.713]                 open = "w")
[08:28:59.713]         }
[08:28:59.713]         else {
[08:28:59.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:59.713]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:59.713]         }
[08:28:59.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:59.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:59.713]             base::sink(type = "output", split = FALSE)
[08:28:59.713]             base::close(...future.stdout)
[08:28:59.713]         }, add = TRUE)
[08:28:59.713]     }
[08:28:59.713]     ...future.frame <- base::sys.nframe()
[08:28:59.713]     ...future.conditions <- base::list()
[08:28:59.713]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:59.713]     if (FALSE) {
[08:28:59.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:59.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:59.713]     }
[08:28:59.713]     ...future.result <- base::tryCatch({
[08:28:59.713]         base::withCallingHandlers({
[08:28:59.713]             ...future.value <- base::withVisible(base::local(1))
[08:28:59.713]             future::FutureResult(value = ...future.value$value, 
[08:28:59.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.713]                   ...future.rng), globalenv = if (FALSE) 
[08:28:59.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:59.713]                     ...future.globalenv.names))
[08:28:59.713]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:59.713]         }, condition = base::local({
[08:28:59.713]             c <- base::c
[08:28:59.713]             inherits <- base::inherits
[08:28:59.713]             invokeRestart <- base::invokeRestart
[08:28:59.713]             length <- base::length
[08:28:59.713]             list <- base::list
[08:28:59.713]             seq.int <- base::seq.int
[08:28:59.713]             signalCondition <- base::signalCondition
[08:28:59.713]             sys.calls <- base::sys.calls
[08:28:59.713]             `[[` <- base::`[[`
[08:28:59.713]             `+` <- base::`+`
[08:28:59.713]             `<<-` <- base::`<<-`
[08:28:59.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:59.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:59.713]                   3L)]
[08:28:59.713]             }
[08:28:59.713]             function(cond) {
[08:28:59.713]                 is_error <- inherits(cond, "error")
[08:28:59.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:59.713]                   NULL)
[08:28:59.713]                 if (is_error) {
[08:28:59.713]                   sessionInformation <- function() {
[08:28:59.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:59.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:59.713]                       search = base::search(), system = base::Sys.info())
[08:28:59.713]                   }
[08:28:59.713]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:59.713]                     cond$call), session = sessionInformation(), 
[08:28:59.713]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:59.713]                   signalCondition(cond)
[08:28:59.713]                 }
[08:28:59.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:59.713]                 "immediateCondition"))) {
[08:28:59.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:59.713]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:59.713]                   if (TRUE && !signal) {
[08:28:59.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.713]                     {
[08:28:59.713]                       inherits <- base::inherits
[08:28:59.713]                       invokeRestart <- base::invokeRestart
[08:28:59.713]                       is.null <- base::is.null
[08:28:59.713]                       muffled <- FALSE
[08:28:59.713]                       if (inherits(cond, "message")) {
[08:28:59.713]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.713]                         if (muffled) 
[08:28:59.713]                           invokeRestart("muffleMessage")
[08:28:59.713]                       }
[08:28:59.713]                       else if (inherits(cond, "warning")) {
[08:28:59.713]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.713]                         if (muffled) 
[08:28:59.713]                           invokeRestart("muffleWarning")
[08:28:59.713]                       }
[08:28:59.713]                       else if (inherits(cond, "condition")) {
[08:28:59.713]                         if (!is.null(pattern)) {
[08:28:59.713]                           computeRestarts <- base::computeRestarts
[08:28:59.713]                           grepl <- base::grepl
[08:28:59.713]                           restarts <- computeRestarts(cond)
[08:28:59.713]                           for (restart in restarts) {
[08:28:59.713]                             name <- restart$name
[08:28:59.713]                             if (is.null(name)) 
[08:28:59.713]                               next
[08:28:59.713]                             if (!grepl(pattern, name)) 
[08:28:59.713]                               next
[08:28:59.713]                             invokeRestart(restart)
[08:28:59.713]                             muffled <- TRUE
[08:28:59.713]                             break
[08:28:59.713]                           }
[08:28:59.713]                         }
[08:28:59.713]                       }
[08:28:59.713]                       invisible(muffled)
[08:28:59.713]                     }
[08:28:59.713]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.713]                   }
[08:28:59.713]                 }
[08:28:59.713]                 else {
[08:28:59.713]                   if (TRUE) {
[08:28:59.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.713]                     {
[08:28:59.713]                       inherits <- base::inherits
[08:28:59.713]                       invokeRestart <- base::invokeRestart
[08:28:59.713]                       is.null <- base::is.null
[08:28:59.713]                       muffled <- FALSE
[08:28:59.713]                       if (inherits(cond, "message")) {
[08:28:59.713]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.713]                         if (muffled) 
[08:28:59.713]                           invokeRestart("muffleMessage")
[08:28:59.713]                       }
[08:28:59.713]                       else if (inherits(cond, "warning")) {
[08:28:59.713]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.713]                         if (muffled) 
[08:28:59.713]                           invokeRestart("muffleWarning")
[08:28:59.713]                       }
[08:28:59.713]                       else if (inherits(cond, "condition")) {
[08:28:59.713]                         if (!is.null(pattern)) {
[08:28:59.713]                           computeRestarts <- base::computeRestarts
[08:28:59.713]                           grepl <- base::grepl
[08:28:59.713]                           restarts <- computeRestarts(cond)
[08:28:59.713]                           for (restart in restarts) {
[08:28:59.713]                             name <- restart$name
[08:28:59.713]                             if (is.null(name)) 
[08:28:59.713]                               next
[08:28:59.713]                             if (!grepl(pattern, name)) 
[08:28:59.713]                               next
[08:28:59.713]                             invokeRestart(restart)
[08:28:59.713]                             muffled <- TRUE
[08:28:59.713]                             break
[08:28:59.713]                           }
[08:28:59.713]                         }
[08:28:59.713]                       }
[08:28:59.713]                       invisible(muffled)
[08:28:59.713]                     }
[08:28:59.713]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.713]                   }
[08:28:59.713]                 }
[08:28:59.713]             }
[08:28:59.713]         }))
[08:28:59.713]     }, error = function(ex) {
[08:28:59.713]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:59.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.713]                 ...future.rng), started = ...future.startTime, 
[08:28:59.713]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:59.713]             version = "1.8"), class = "FutureResult")
[08:28:59.713]     }, finally = {
[08:28:59.713]         if (!identical(...future.workdir, getwd())) 
[08:28:59.713]             setwd(...future.workdir)
[08:28:59.713]         {
[08:28:59.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:59.713]                 ...future.oldOptions$nwarnings <- NULL
[08:28:59.713]             }
[08:28:59.713]             base::options(...future.oldOptions)
[08:28:59.713]             if (.Platform$OS.type == "windows") {
[08:28:59.713]                 old_names <- names(...future.oldEnvVars)
[08:28:59.713]                 envs <- base::Sys.getenv()
[08:28:59.713]                 names <- names(envs)
[08:28:59.713]                 common <- intersect(names, old_names)
[08:28:59.713]                 added <- setdiff(names, old_names)
[08:28:59.713]                 removed <- setdiff(old_names, names)
[08:28:59.713]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:59.713]                   envs[common]]
[08:28:59.713]                 NAMES <- toupper(changed)
[08:28:59.713]                 args <- list()
[08:28:59.713]                 for (kk in seq_along(NAMES)) {
[08:28:59.713]                   name <- changed[[kk]]
[08:28:59.713]                   NAME <- NAMES[[kk]]
[08:28:59.713]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.713]                     next
[08:28:59.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.713]                 }
[08:28:59.713]                 NAMES <- toupper(added)
[08:28:59.713]                 for (kk in seq_along(NAMES)) {
[08:28:59.713]                   name <- added[[kk]]
[08:28:59.713]                   NAME <- NAMES[[kk]]
[08:28:59.713]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.713]                     next
[08:28:59.713]                   args[[name]] <- ""
[08:28:59.713]                 }
[08:28:59.713]                 NAMES <- toupper(removed)
[08:28:59.713]                 for (kk in seq_along(NAMES)) {
[08:28:59.713]                   name <- removed[[kk]]
[08:28:59.713]                   NAME <- NAMES[[kk]]
[08:28:59.713]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.713]                     next
[08:28:59.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.713]                 }
[08:28:59.713]                 if (length(args) > 0) 
[08:28:59.713]                   base::do.call(base::Sys.setenv, args = args)
[08:28:59.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:59.713]             }
[08:28:59.713]             else {
[08:28:59.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:59.713]             }
[08:28:59.713]             {
[08:28:59.713]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:59.713]                   0L) {
[08:28:59.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:59.713]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:59.713]                   base::options(opts)
[08:28:59.713]                 }
[08:28:59.713]                 {
[08:28:59.713]                   {
[08:28:59.713]                     NULL
[08:28:59.713]                     RNGkind("Mersenne-Twister")
[08:28:59.713]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:59.713]                       inherits = FALSE)
[08:28:59.713]                   }
[08:28:59.713]                   options(future.plan = NULL)
[08:28:59.713]                   if (is.na(NA_character_)) 
[08:28:59.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:59.713]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:59.713]                     .init = FALSE)
[08:28:59.713]                 }
[08:28:59.713]             }
[08:28:59.713]         }
[08:28:59.713]     })
[08:28:59.713]     if (TRUE) {
[08:28:59.713]         base::sink(type = "output", split = FALSE)
[08:28:59.713]         if (TRUE) {
[08:28:59.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:59.713]         }
[08:28:59.713]         else {
[08:28:59.713]             ...future.result["stdout"] <- base::list(NULL)
[08:28:59.713]         }
[08:28:59.713]         base::close(...future.stdout)
[08:28:59.713]         ...future.stdout <- NULL
[08:28:59.713]     }
[08:28:59.713]     ...future.result$conditions <- ...future.conditions
[08:28:59.713]     ...future.result$finished <- base::Sys.time()
[08:28:59.713]     ...future.result
[08:28:59.713] }
[08:28:59.714] plan(): Setting new future strategy stack:
[08:28:59.715] List of future strategies:
[08:28:59.715] 1. sequential:
[08:28:59.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.715]    - tweaked: FALSE
[08:28:59.715]    - call: NULL
[08:28:59.715] plan(): nbrOfWorkers() = 1
[08:28:59.716] plan(): Setting new future strategy stack:
[08:28:59.716] List of future strategies:
[08:28:59.716] 1. sequential:
[08:28:59.716]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.716]    - tweaked: FALSE
[08:28:59.716]    - call: plan(strategy)
[08:28:59.716] plan(): nbrOfWorkers() = 1
[08:28:59.716] SequentialFuture started (and completed)
[08:28:59.716] - Launch lazy future ... done
[08:28:59.717] run() for ‘SequentialFuture’ ... done
[08:28:59.717] resolved() for ‘SequentialFuture’ ...
[08:28:59.717] - state: ‘finished’
[08:28:59.717] - run: TRUE
[08:28:59.717] - result: ‘FutureResult’
[08:28:59.717] resolved() for ‘SequentialFuture’ ... done
[08:28:59.717] Future #1
[08:28:59.717]  length: 2 (resolved future 1)
[08:28:59.717] resolved() for ‘SequentialFuture’ ...
[08:28:59.717] - state: ‘finished’
[08:28:59.717] - run: TRUE
[08:28:59.718] - result: ‘FutureResult’
[08:28:59.718] resolved() for ‘SequentialFuture’ ... done
[08:28:59.718] Future #2
[08:28:59.718]  length: 1 (resolved future 2)
[08:28:59.718]  length: 0 (resolved future 3)
[08:28:59.718] resolve() on list ... DONE
[08:28:59.718] resolved() for ‘SequentialFuture’ ...
[08:28:59.718] - state: ‘finished’
[08:28:59.718] - run: TRUE
[08:28:59.718] - result: ‘FutureResult’
[08:28:59.718] resolved() for ‘SequentialFuture’ ... done
[08:28:59.719] resolved() for ‘SequentialFuture’ ...
[08:28:59.719] - state: ‘finished’
[08:28:59.719] - run: TRUE
[08:28:59.719] - result: ‘FutureResult’
[08:28:59.719] resolved() for ‘SequentialFuture’ ... done
[08:28:59.719] getGlobalsAndPackages() ...
[08:28:59.719] Searching for globals...
[08:28:59.719] 
[08:28:59.719] Searching for globals ... DONE
[08:28:59.719] - globals: [0] <none>
[08:28:59.720] getGlobalsAndPackages() ... DONE
[08:28:59.720] getGlobalsAndPackages() ...
[08:28:59.720] Searching for globals...
[08:28:59.720] 
[08:28:59.720] Searching for globals ... DONE
[08:28:59.720] - globals: [0] <none>
[08:28:59.720] getGlobalsAndPackages() ... DONE
[08:28:59.721] resolve() on list ...
[08:28:59.721]  recursive: 0
[08:28:59.721]  length: 3
[08:28:59.721]  elements: ‘a’, ‘b’, ‘’
[08:28:59.721] run() for ‘Future’ ...
[08:28:59.721] - state: ‘created’
[08:28:59.721] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:59.721] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:59.721] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:59.722]   - Field: ‘label’
[08:28:59.722]   - Field: ‘local’
[08:28:59.722]   - Field: ‘owner’
[08:28:59.722]   - Field: ‘envir’
[08:28:59.722]   - Field: ‘packages’
[08:28:59.722]   - Field: ‘gc’
[08:28:59.722]   - Field: ‘conditions’
[08:28:59.722]   - Field: ‘expr’
[08:28:59.722]   - Field: ‘uuid’
[08:28:59.722]   - Field: ‘seed’
[08:28:59.722]   - Field: ‘version’
[08:28:59.722]   - Field: ‘result’
[08:28:59.723]   - Field: ‘asynchronous’
[08:28:59.723]   - Field: ‘calls’
[08:28:59.723]   - Field: ‘globals’
[08:28:59.723]   - Field: ‘stdout’
[08:28:59.723]   - Field: ‘earlySignal’
[08:28:59.723]   - Field: ‘lazy’
[08:28:59.723]   - Field: ‘state’
[08:28:59.723] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:59.723] - Launch lazy future ...
[08:28:59.723] Packages needed by the future expression (n = 0): <none>
[08:28:59.723] Packages needed by future strategies (n = 0): <none>
[08:28:59.724] {
[08:28:59.724]     {
[08:28:59.724]         {
[08:28:59.724]             ...future.startTime <- base::Sys.time()
[08:28:59.724]             {
[08:28:59.724]                 {
[08:28:59.724]                   {
[08:28:59.724]                     base::local({
[08:28:59.724]                       has_future <- base::requireNamespace("future", 
[08:28:59.724]                         quietly = TRUE)
[08:28:59.724]                       if (has_future) {
[08:28:59.724]                         ns <- base::getNamespace("future")
[08:28:59.724]                         version <- ns[[".package"]][["version"]]
[08:28:59.724]                         if (is.null(version)) 
[08:28:59.724]                           version <- utils::packageVersion("future")
[08:28:59.724]                       }
[08:28:59.724]                       else {
[08:28:59.724]                         version <- NULL
[08:28:59.724]                       }
[08:28:59.724]                       if (!has_future || version < "1.8.0") {
[08:28:59.724]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:59.724]                           "", base::R.version$version.string), 
[08:28:59.724]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:59.724]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:59.724]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:59.724]                             "release", "version")], collapse = " "), 
[08:28:59.724]                           hostname = base::Sys.info()[["nodename"]])
[08:28:59.724]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:59.724]                           info)
[08:28:59.724]                         info <- base::paste(info, collapse = "; ")
[08:28:59.724]                         if (!has_future) {
[08:28:59.724]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:59.724]                             info)
[08:28:59.724]                         }
[08:28:59.724]                         else {
[08:28:59.724]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:59.724]                             info, version)
[08:28:59.724]                         }
[08:28:59.724]                         base::stop(msg)
[08:28:59.724]                       }
[08:28:59.724]                     })
[08:28:59.724]                   }
[08:28:59.724]                   ...future.strategy.old <- future::plan("list")
[08:28:59.724]                   options(future.plan = NULL)
[08:28:59.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:59.724]                 }
[08:28:59.724]                 ...future.workdir <- getwd()
[08:28:59.724]             }
[08:28:59.724]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:59.724]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:59.724]         }
[08:28:59.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:59.724]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:59.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:59.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:59.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:59.724]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:59.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:59.724]             base::names(...future.oldOptions))
[08:28:59.724]     }
[08:28:59.724]     if (FALSE) {
[08:28:59.724]     }
[08:28:59.724]     else {
[08:28:59.724]         if (TRUE) {
[08:28:59.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:59.724]                 open = "w")
[08:28:59.724]         }
[08:28:59.724]         else {
[08:28:59.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:59.724]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:59.724]         }
[08:28:59.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:59.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:59.724]             base::sink(type = "output", split = FALSE)
[08:28:59.724]             base::close(...future.stdout)
[08:28:59.724]         }, add = TRUE)
[08:28:59.724]     }
[08:28:59.724]     ...future.frame <- base::sys.nframe()
[08:28:59.724]     ...future.conditions <- base::list()
[08:28:59.724]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:59.724]     if (FALSE) {
[08:28:59.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:59.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:59.724]     }
[08:28:59.724]     ...future.result <- base::tryCatch({
[08:28:59.724]         base::withCallingHandlers({
[08:28:59.724]             ...future.value <- base::withVisible(base::local(1))
[08:28:59.724]             future::FutureResult(value = ...future.value$value, 
[08:28:59.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.724]                   ...future.rng), globalenv = if (FALSE) 
[08:28:59.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:59.724]                     ...future.globalenv.names))
[08:28:59.724]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:59.724]         }, condition = base::local({
[08:28:59.724]             c <- base::c
[08:28:59.724]             inherits <- base::inherits
[08:28:59.724]             invokeRestart <- base::invokeRestart
[08:28:59.724]             length <- base::length
[08:28:59.724]             list <- base::list
[08:28:59.724]             seq.int <- base::seq.int
[08:28:59.724]             signalCondition <- base::signalCondition
[08:28:59.724]             sys.calls <- base::sys.calls
[08:28:59.724]             `[[` <- base::`[[`
[08:28:59.724]             `+` <- base::`+`
[08:28:59.724]             `<<-` <- base::`<<-`
[08:28:59.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:59.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:59.724]                   3L)]
[08:28:59.724]             }
[08:28:59.724]             function(cond) {
[08:28:59.724]                 is_error <- inherits(cond, "error")
[08:28:59.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:59.724]                   NULL)
[08:28:59.724]                 if (is_error) {
[08:28:59.724]                   sessionInformation <- function() {
[08:28:59.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:59.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:59.724]                       search = base::search(), system = base::Sys.info())
[08:28:59.724]                   }
[08:28:59.724]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:59.724]                     cond$call), session = sessionInformation(), 
[08:28:59.724]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:59.724]                   signalCondition(cond)
[08:28:59.724]                 }
[08:28:59.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:59.724]                 "immediateCondition"))) {
[08:28:59.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:59.724]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:59.724]                   if (TRUE && !signal) {
[08:28:59.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.724]                     {
[08:28:59.724]                       inherits <- base::inherits
[08:28:59.724]                       invokeRestart <- base::invokeRestart
[08:28:59.724]                       is.null <- base::is.null
[08:28:59.724]                       muffled <- FALSE
[08:28:59.724]                       if (inherits(cond, "message")) {
[08:28:59.724]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.724]                         if (muffled) 
[08:28:59.724]                           invokeRestart("muffleMessage")
[08:28:59.724]                       }
[08:28:59.724]                       else if (inherits(cond, "warning")) {
[08:28:59.724]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.724]                         if (muffled) 
[08:28:59.724]                           invokeRestart("muffleWarning")
[08:28:59.724]                       }
[08:28:59.724]                       else if (inherits(cond, "condition")) {
[08:28:59.724]                         if (!is.null(pattern)) {
[08:28:59.724]                           computeRestarts <- base::computeRestarts
[08:28:59.724]                           grepl <- base::grepl
[08:28:59.724]                           restarts <- computeRestarts(cond)
[08:28:59.724]                           for (restart in restarts) {
[08:28:59.724]                             name <- restart$name
[08:28:59.724]                             if (is.null(name)) 
[08:28:59.724]                               next
[08:28:59.724]                             if (!grepl(pattern, name)) 
[08:28:59.724]                               next
[08:28:59.724]                             invokeRestart(restart)
[08:28:59.724]                             muffled <- TRUE
[08:28:59.724]                             break
[08:28:59.724]                           }
[08:28:59.724]                         }
[08:28:59.724]                       }
[08:28:59.724]                       invisible(muffled)
[08:28:59.724]                     }
[08:28:59.724]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.724]                   }
[08:28:59.724]                 }
[08:28:59.724]                 else {
[08:28:59.724]                   if (TRUE) {
[08:28:59.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.724]                     {
[08:28:59.724]                       inherits <- base::inherits
[08:28:59.724]                       invokeRestart <- base::invokeRestart
[08:28:59.724]                       is.null <- base::is.null
[08:28:59.724]                       muffled <- FALSE
[08:28:59.724]                       if (inherits(cond, "message")) {
[08:28:59.724]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.724]                         if (muffled) 
[08:28:59.724]                           invokeRestart("muffleMessage")
[08:28:59.724]                       }
[08:28:59.724]                       else if (inherits(cond, "warning")) {
[08:28:59.724]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.724]                         if (muffled) 
[08:28:59.724]                           invokeRestart("muffleWarning")
[08:28:59.724]                       }
[08:28:59.724]                       else if (inherits(cond, "condition")) {
[08:28:59.724]                         if (!is.null(pattern)) {
[08:28:59.724]                           computeRestarts <- base::computeRestarts
[08:28:59.724]                           grepl <- base::grepl
[08:28:59.724]                           restarts <- computeRestarts(cond)
[08:28:59.724]                           for (restart in restarts) {
[08:28:59.724]                             name <- restart$name
[08:28:59.724]                             if (is.null(name)) 
[08:28:59.724]                               next
[08:28:59.724]                             if (!grepl(pattern, name)) 
[08:28:59.724]                               next
[08:28:59.724]                             invokeRestart(restart)
[08:28:59.724]                             muffled <- TRUE
[08:28:59.724]                             break
[08:28:59.724]                           }
[08:28:59.724]                         }
[08:28:59.724]                       }
[08:28:59.724]                       invisible(muffled)
[08:28:59.724]                     }
[08:28:59.724]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.724]                   }
[08:28:59.724]                 }
[08:28:59.724]             }
[08:28:59.724]         }))
[08:28:59.724]     }, error = function(ex) {
[08:28:59.724]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:59.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.724]                 ...future.rng), started = ...future.startTime, 
[08:28:59.724]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:59.724]             version = "1.8"), class = "FutureResult")
[08:28:59.724]     }, finally = {
[08:28:59.724]         if (!identical(...future.workdir, getwd())) 
[08:28:59.724]             setwd(...future.workdir)
[08:28:59.724]         {
[08:28:59.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:59.724]                 ...future.oldOptions$nwarnings <- NULL
[08:28:59.724]             }
[08:28:59.724]             base::options(...future.oldOptions)
[08:28:59.724]             if (.Platform$OS.type == "windows") {
[08:28:59.724]                 old_names <- names(...future.oldEnvVars)
[08:28:59.724]                 envs <- base::Sys.getenv()
[08:28:59.724]                 names <- names(envs)
[08:28:59.724]                 common <- intersect(names, old_names)
[08:28:59.724]                 added <- setdiff(names, old_names)
[08:28:59.724]                 removed <- setdiff(old_names, names)
[08:28:59.724]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:59.724]                   envs[common]]
[08:28:59.724]                 NAMES <- toupper(changed)
[08:28:59.724]                 args <- list()
[08:28:59.724]                 for (kk in seq_along(NAMES)) {
[08:28:59.724]                   name <- changed[[kk]]
[08:28:59.724]                   NAME <- NAMES[[kk]]
[08:28:59.724]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.724]                     next
[08:28:59.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.724]                 }
[08:28:59.724]                 NAMES <- toupper(added)
[08:28:59.724]                 for (kk in seq_along(NAMES)) {
[08:28:59.724]                   name <- added[[kk]]
[08:28:59.724]                   NAME <- NAMES[[kk]]
[08:28:59.724]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.724]                     next
[08:28:59.724]                   args[[name]] <- ""
[08:28:59.724]                 }
[08:28:59.724]                 NAMES <- toupper(removed)
[08:28:59.724]                 for (kk in seq_along(NAMES)) {
[08:28:59.724]                   name <- removed[[kk]]
[08:28:59.724]                   NAME <- NAMES[[kk]]
[08:28:59.724]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.724]                     next
[08:28:59.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.724]                 }
[08:28:59.724]                 if (length(args) > 0) 
[08:28:59.724]                   base::do.call(base::Sys.setenv, args = args)
[08:28:59.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:59.724]             }
[08:28:59.724]             else {
[08:28:59.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:59.724]             }
[08:28:59.724]             {
[08:28:59.724]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:59.724]                   0L) {
[08:28:59.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:59.724]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:59.724]                   base::options(opts)
[08:28:59.724]                 }
[08:28:59.724]                 {
[08:28:59.724]                   {
[08:28:59.724]                     NULL
[08:28:59.724]                     RNGkind("Mersenne-Twister")
[08:28:59.724]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:59.724]                       inherits = FALSE)
[08:28:59.724]                   }
[08:28:59.724]                   options(future.plan = NULL)
[08:28:59.724]                   if (is.na(NA_character_)) 
[08:28:59.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:59.724]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:59.724]                     .init = FALSE)
[08:28:59.724]                 }
[08:28:59.724]             }
[08:28:59.724]         }
[08:28:59.724]     })
[08:28:59.724]     if (TRUE) {
[08:28:59.724]         base::sink(type = "output", split = FALSE)
[08:28:59.724]         if (TRUE) {
[08:28:59.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:59.724]         }
[08:28:59.724]         else {
[08:28:59.724]             ...future.result["stdout"] <- base::list(NULL)
[08:28:59.724]         }
[08:28:59.724]         base::close(...future.stdout)
[08:28:59.724]         ...future.stdout <- NULL
[08:28:59.724]     }
[08:28:59.724]     ...future.result$conditions <- ...future.conditions
[08:28:59.724]     ...future.result$finished <- base::Sys.time()
[08:28:59.724]     ...future.result
[08:28:59.724] }
[08:28:59.726] plan(): Setting new future strategy stack:
[08:28:59.726] List of future strategies:
[08:28:59.726] 1. sequential:
[08:28:59.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.726]    - tweaked: FALSE
[08:28:59.726]    - call: NULL
[08:28:59.726] plan(): nbrOfWorkers() = 1
[08:28:59.727] plan(): Setting new future strategy stack:
[08:28:59.727] List of future strategies:
[08:28:59.727] 1. sequential:
[08:28:59.727]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.727]    - tweaked: FALSE
[08:28:59.727]    - call: plan(strategy)
[08:28:59.727] plan(): nbrOfWorkers() = 1
[08:28:59.727] SequentialFuture started (and completed)
[08:28:59.728] - Launch lazy future ... done
[08:28:59.728] run() for ‘SequentialFuture’ ... done
[08:28:59.728] resolved() for ‘SequentialFuture’ ...
[08:28:59.728] - state: ‘finished’
[08:28:59.728] - run: TRUE
[08:28:59.728] - result: ‘FutureResult’
[08:28:59.728] resolved() for ‘SequentialFuture’ ... done
[08:28:59.728] Future #1
[08:28:59.728]  length: 2 (resolved future 1)
[08:28:59.728] run() for ‘Future’ ...
[08:28:59.728] - state: ‘created’
[08:28:59.729] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:59.729] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:59.729] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:59.729]   - Field: ‘label’
[08:28:59.729]   - Field: ‘local’
[08:28:59.729]   - Field: ‘owner’
[08:28:59.729]   - Field: ‘envir’
[08:28:59.729]   - Field: ‘packages’
[08:28:59.729]   - Field: ‘gc’
[08:28:59.730]   - Field: ‘conditions’
[08:28:59.730]   - Field: ‘expr’
[08:28:59.730]   - Field: ‘uuid’
[08:28:59.730]   - Field: ‘seed’
[08:28:59.730]   - Field: ‘version’
[08:28:59.730]   - Field: ‘result’
[08:28:59.730]   - Field: ‘asynchronous’
[08:28:59.730]   - Field: ‘calls’
[08:28:59.730]   - Field: ‘globals’
[08:28:59.730]   - Field: ‘stdout’
[08:28:59.730]   - Field: ‘earlySignal’
[08:28:59.730]   - Field: ‘lazy’
[08:28:59.731]   - Field: ‘state’
[08:28:59.731] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:59.731] - Launch lazy future ...
[08:28:59.731] Packages needed by the future expression (n = 0): <none>
[08:28:59.731] Packages needed by future strategies (n = 0): <none>
[08:28:59.731] {
[08:28:59.731]     {
[08:28:59.731]         {
[08:28:59.731]             ...future.startTime <- base::Sys.time()
[08:28:59.731]             {
[08:28:59.731]                 {
[08:28:59.731]                   {
[08:28:59.731]                     base::local({
[08:28:59.731]                       has_future <- base::requireNamespace("future", 
[08:28:59.731]                         quietly = TRUE)
[08:28:59.731]                       if (has_future) {
[08:28:59.731]                         ns <- base::getNamespace("future")
[08:28:59.731]                         version <- ns[[".package"]][["version"]]
[08:28:59.731]                         if (is.null(version)) 
[08:28:59.731]                           version <- utils::packageVersion("future")
[08:28:59.731]                       }
[08:28:59.731]                       else {
[08:28:59.731]                         version <- NULL
[08:28:59.731]                       }
[08:28:59.731]                       if (!has_future || version < "1.8.0") {
[08:28:59.731]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:59.731]                           "", base::R.version$version.string), 
[08:28:59.731]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:59.731]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:59.731]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:59.731]                             "release", "version")], collapse = " "), 
[08:28:59.731]                           hostname = base::Sys.info()[["nodename"]])
[08:28:59.731]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:59.731]                           info)
[08:28:59.731]                         info <- base::paste(info, collapse = "; ")
[08:28:59.731]                         if (!has_future) {
[08:28:59.731]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:59.731]                             info)
[08:28:59.731]                         }
[08:28:59.731]                         else {
[08:28:59.731]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:59.731]                             info, version)
[08:28:59.731]                         }
[08:28:59.731]                         base::stop(msg)
[08:28:59.731]                       }
[08:28:59.731]                     })
[08:28:59.731]                   }
[08:28:59.731]                   ...future.strategy.old <- future::plan("list")
[08:28:59.731]                   options(future.plan = NULL)
[08:28:59.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:59.731]                 }
[08:28:59.731]                 ...future.workdir <- getwd()
[08:28:59.731]             }
[08:28:59.731]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:59.731]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:59.731]         }
[08:28:59.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:59.731]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:59.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:59.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:59.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:59.731]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:59.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:59.731]             base::names(...future.oldOptions))
[08:28:59.731]     }
[08:28:59.731]     if (FALSE) {
[08:28:59.731]     }
[08:28:59.731]     else {
[08:28:59.731]         if (TRUE) {
[08:28:59.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:59.731]                 open = "w")
[08:28:59.731]         }
[08:28:59.731]         else {
[08:28:59.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:59.731]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:59.731]         }
[08:28:59.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:59.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:59.731]             base::sink(type = "output", split = FALSE)
[08:28:59.731]             base::close(...future.stdout)
[08:28:59.731]         }, add = TRUE)
[08:28:59.731]     }
[08:28:59.731]     ...future.frame <- base::sys.nframe()
[08:28:59.731]     ...future.conditions <- base::list()
[08:28:59.731]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:59.731]     if (FALSE) {
[08:28:59.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:59.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:59.731]     }
[08:28:59.731]     ...future.result <- base::tryCatch({
[08:28:59.731]         base::withCallingHandlers({
[08:28:59.731]             ...future.value <- base::withVisible(base::local(2))
[08:28:59.731]             future::FutureResult(value = ...future.value$value, 
[08:28:59.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.731]                   ...future.rng), globalenv = if (FALSE) 
[08:28:59.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:59.731]                     ...future.globalenv.names))
[08:28:59.731]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:59.731]         }, condition = base::local({
[08:28:59.731]             c <- base::c
[08:28:59.731]             inherits <- base::inherits
[08:28:59.731]             invokeRestart <- base::invokeRestart
[08:28:59.731]             length <- base::length
[08:28:59.731]             list <- base::list
[08:28:59.731]             seq.int <- base::seq.int
[08:28:59.731]             signalCondition <- base::signalCondition
[08:28:59.731]             sys.calls <- base::sys.calls
[08:28:59.731]             `[[` <- base::`[[`
[08:28:59.731]             `+` <- base::`+`
[08:28:59.731]             `<<-` <- base::`<<-`
[08:28:59.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:59.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:59.731]                   3L)]
[08:28:59.731]             }
[08:28:59.731]             function(cond) {
[08:28:59.731]                 is_error <- inherits(cond, "error")
[08:28:59.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:59.731]                   NULL)
[08:28:59.731]                 if (is_error) {
[08:28:59.731]                   sessionInformation <- function() {
[08:28:59.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:59.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:59.731]                       search = base::search(), system = base::Sys.info())
[08:28:59.731]                   }
[08:28:59.731]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:59.731]                     cond$call), session = sessionInformation(), 
[08:28:59.731]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:59.731]                   signalCondition(cond)
[08:28:59.731]                 }
[08:28:59.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:59.731]                 "immediateCondition"))) {
[08:28:59.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:59.731]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:59.731]                   if (TRUE && !signal) {
[08:28:59.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.731]                     {
[08:28:59.731]                       inherits <- base::inherits
[08:28:59.731]                       invokeRestart <- base::invokeRestart
[08:28:59.731]                       is.null <- base::is.null
[08:28:59.731]                       muffled <- FALSE
[08:28:59.731]                       if (inherits(cond, "message")) {
[08:28:59.731]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.731]                         if (muffled) 
[08:28:59.731]                           invokeRestart("muffleMessage")
[08:28:59.731]                       }
[08:28:59.731]                       else if (inherits(cond, "warning")) {
[08:28:59.731]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.731]                         if (muffled) 
[08:28:59.731]                           invokeRestart("muffleWarning")
[08:28:59.731]                       }
[08:28:59.731]                       else if (inherits(cond, "condition")) {
[08:28:59.731]                         if (!is.null(pattern)) {
[08:28:59.731]                           computeRestarts <- base::computeRestarts
[08:28:59.731]                           grepl <- base::grepl
[08:28:59.731]                           restarts <- computeRestarts(cond)
[08:28:59.731]                           for (restart in restarts) {
[08:28:59.731]                             name <- restart$name
[08:28:59.731]                             if (is.null(name)) 
[08:28:59.731]                               next
[08:28:59.731]                             if (!grepl(pattern, name)) 
[08:28:59.731]                               next
[08:28:59.731]                             invokeRestart(restart)
[08:28:59.731]                             muffled <- TRUE
[08:28:59.731]                             break
[08:28:59.731]                           }
[08:28:59.731]                         }
[08:28:59.731]                       }
[08:28:59.731]                       invisible(muffled)
[08:28:59.731]                     }
[08:28:59.731]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.731]                   }
[08:28:59.731]                 }
[08:28:59.731]                 else {
[08:28:59.731]                   if (TRUE) {
[08:28:59.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.731]                     {
[08:28:59.731]                       inherits <- base::inherits
[08:28:59.731]                       invokeRestart <- base::invokeRestart
[08:28:59.731]                       is.null <- base::is.null
[08:28:59.731]                       muffled <- FALSE
[08:28:59.731]                       if (inherits(cond, "message")) {
[08:28:59.731]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.731]                         if (muffled) 
[08:28:59.731]                           invokeRestart("muffleMessage")
[08:28:59.731]                       }
[08:28:59.731]                       else if (inherits(cond, "warning")) {
[08:28:59.731]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.731]                         if (muffled) 
[08:28:59.731]                           invokeRestart("muffleWarning")
[08:28:59.731]                       }
[08:28:59.731]                       else if (inherits(cond, "condition")) {
[08:28:59.731]                         if (!is.null(pattern)) {
[08:28:59.731]                           computeRestarts <- base::computeRestarts
[08:28:59.731]                           grepl <- base::grepl
[08:28:59.731]                           restarts <- computeRestarts(cond)
[08:28:59.731]                           for (restart in restarts) {
[08:28:59.731]                             name <- restart$name
[08:28:59.731]                             if (is.null(name)) 
[08:28:59.731]                               next
[08:28:59.731]                             if (!grepl(pattern, name)) 
[08:28:59.731]                               next
[08:28:59.731]                             invokeRestart(restart)
[08:28:59.731]                             muffled <- TRUE
[08:28:59.731]                             break
[08:28:59.731]                           }
[08:28:59.731]                         }
[08:28:59.731]                       }
[08:28:59.731]                       invisible(muffled)
[08:28:59.731]                     }
[08:28:59.731]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.731]                   }
[08:28:59.731]                 }
[08:28:59.731]             }
[08:28:59.731]         }))
[08:28:59.731]     }, error = function(ex) {
[08:28:59.731]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:59.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.731]                 ...future.rng), started = ...future.startTime, 
[08:28:59.731]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:59.731]             version = "1.8"), class = "FutureResult")
[08:28:59.731]     }, finally = {
[08:28:59.731]         if (!identical(...future.workdir, getwd())) 
[08:28:59.731]             setwd(...future.workdir)
[08:28:59.731]         {
[08:28:59.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:59.731]                 ...future.oldOptions$nwarnings <- NULL
[08:28:59.731]             }
[08:28:59.731]             base::options(...future.oldOptions)
[08:28:59.731]             if (.Platform$OS.type == "windows") {
[08:28:59.731]                 old_names <- names(...future.oldEnvVars)
[08:28:59.731]                 envs <- base::Sys.getenv()
[08:28:59.731]                 names <- names(envs)
[08:28:59.731]                 common <- intersect(names, old_names)
[08:28:59.731]                 added <- setdiff(names, old_names)
[08:28:59.731]                 removed <- setdiff(old_names, names)
[08:28:59.731]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:59.731]                   envs[common]]
[08:28:59.731]                 NAMES <- toupper(changed)
[08:28:59.731]                 args <- list()
[08:28:59.731]                 for (kk in seq_along(NAMES)) {
[08:28:59.731]                   name <- changed[[kk]]
[08:28:59.731]                   NAME <- NAMES[[kk]]
[08:28:59.731]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.731]                     next
[08:28:59.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.731]                 }
[08:28:59.731]                 NAMES <- toupper(added)
[08:28:59.731]                 for (kk in seq_along(NAMES)) {
[08:28:59.731]                   name <- added[[kk]]
[08:28:59.731]                   NAME <- NAMES[[kk]]
[08:28:59.731]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.731]                     next
[08:28:59.731]                   args[[name]] <- ""
[08:28:59.731]                 }
[08:28:59.731]                 NAMES <- toupper(removed)
[08:28:59.731]                 for (kk in seq_along(NAMES)) {
[08:28:59.731]                   name <- removed[[kk]]
[08:28:59.731]                   NAME <- NAMES[[kk]]
[08:28:59.731]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.731]                     next
[08:28:59.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.731]                 }
[08:28:59.731]                 if (length(args) > 0) 
[08:28:59.731]                   base::do.call(base::Sys.setenv, args = args)
[08:28:59.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:59.731]             }
[08:28:59.731]             else {
[08:28:59.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:59.731]             }
[08:28:59.731]             {
[08:28:59.731]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:59.731]                   0L) {
[08:28:59.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:59.731]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:59.731]                   base::options(opts)
[08:28:59.731]                 }
[08:28:59.731]                 {
[08:28:59.731]                   {
[08:28:59.731]                     NULL
[08:28:59.731]                     RNGkind("Mersenne-Twister")
[08:28:59.731]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:59.731]                       inherits = FALSE)
[08:28:59.731]                   }
[08:28:59.731]                   options(future.plan = NULL)
[08:28:59.731]                   if (is.na(NA_character_)) 
[08:28:59.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:59.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:59.731]                     .init = FALSE)
[08:28:59.731]                 }
[08:28:59.731]             }
[08:28:59.731]         }
[08:28:59.731]     })
[08:28:59.731]     if (TRUE) {
[08:28:59.731]         base::sink(type = "output", split = FALSE)
[08:28:59.731]         if (TRUE) {
[08:28:59.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:59.731]         }
[08:28:59.731]         else {
[08:28:59.731]             ...future.result["stdout"] <- base::list(NULL)
[08:28:59.731]         }
[08:28:59.731]         base::close(...future.stdout)
[08:28:59.731]         ...future.stdout <- NULL
[08:28:59.731]     }
[08:28:59.731]     ...future.result$conditions <- ...future.conditions
[08:28:59.731]     ...future.result$finished <- base::Sys.time()
[08:28:59.731]     ...future.result
[08:28:59.731] }
[08:28:59.733] plan(): Setting new future strategy stack:
[08:28:59.733] List of future strategies:
[08:28:59.733] 1. sequential:
[08:28:59.733]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.733]    - tweaked: FALSE
[08:28:59.733]    - call: NULL
[08:28:59.734] plan(): nbrOfWorkers() = 1
[08:28:59.736] plan(): Setting new future strategy stack:
[08:28:59.736] List of future strategies:
[08:28:59.736] 1. sequential:
[08:28:59.736]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.736]    - tweaked: FALSE
[08:28:59.736]    - call: plan(strategy)
[08:28:59.736] plan(): nbrOfWorkers() = 1
[08:28:59.736] SequentialFuture started (and completed)
[08:28:59.737] - Launch lazy future ... done
[08:28:59.737] run() for ‘SequentialFuture’ ... done
[08:28:59.737] resolved() for ‘SequentialFuture’ ...
[08:28:59.737] - state: ‘finished’
[08:28:59.737] - run: TRUE
[08:28:59.737] - result: ‘FutureResult’
[08:28:59.737] resolved() for ‘SequentialFuture’ ... done
[08:28:59.737] Future #2
[08:28:59.737]  length: 1 (resolved future 2)
[08:28:59.737]  length: 0 (resolved future 3)
[08:28:59.738] resolve() on list ... DONE
[08:28:59.738] resolved() for ‘SequentialFuture’ ...
[08:28:59.738] - state: ‘finished’
[08:28:59.738] - run: TRUE
[08:28:59.738] - result: ‘FutureResult’
[08:28:59.738] resolved() for ‘SequentialFuture’ ... done
[08:28:59.738] resolved() for ‘SequentialFuture’ ...
[08:28:59.738] - state: ‘finished’
[08:28:59.738] - run: TRUE
[08:28:59.738] - result: ‘FutureResult’
[08:28:59.738] resolved() for ‘SequentialFuture’ ... done
[08:28:59.739] getGlobalsAndPackages() ...
[08:28:59.739] Searching for globals...
[08:28:59.739] 
[08:28:59.739] Searching for globals ... DONE
[08:28:59.739] - globals: [0] <none>
[08:28:59.739] getGlobalsAndPackages() ... DONE
[08:28:59.739] run() for ‘Future’ ...
[08:28:59.739] - state: ‘created’
[08:28:59.740] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:59.740] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:59.740] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:59.740]   - Field: ‘label’
[08:28:59.740]   - Field: ‘local’
[08:28:59.740]   - Field: ‘owner’
[08:28:59.740]   - Field: ‘envir’
[08:28:59.740]   - Field: ‘packages’
[08:28:59.740]   - Field: ‘gc’
[08:28:59.740]   - Field: ‘conditions’
[08:28:59.741]   - Field: ‘expr’
[08:28:59.741]   - Field: ‘uuid’
[08:28:59.741]   - Field: ‘seed’
[08:28:59.741]   - Field: ‘version’
[08:28:59.741]   - Field: ‘result’
[08:28:59.741]   - Field: ‘asynchronous’
[08:28:59.741]   - Field: ‘calls’
[08:28:59.741]   - Field: ‘globals’
[08:28:59.741]   - Field: ‘stdout’
[08:28:59.741]   - Field: ‘earlySignal’
[08:28:59.741]   - Field: ‘lazy’
[08:28:59.741]   - Field: ‘state’
[08:28:59.742] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:59.742] - Launch lazy future ...
[08:28:59.742] Packages needed by the future expression (n = 0): <none>
[08:28:59.742] Packages needed by future strategies (n = 0): <none>
[08:28:59.742] {
[08:28:59.742]     {
[08:28:59.742]         {
[08:28:59.742]             ...future.startTime <- base::Sys.time()
[08:28:59.742]             {
[08:28:59.742]                 {
[08:28:59.742]                   {
[08:28:59.742]                     base::local({
[08:28:59.742]                       has_future <- base::requireNamespace("future", 
[08:28:59.742]                         quietly = TRUE)
[08:28:59.742]                       if (has_future) {
[08:28:59.742]                         ns <- base::getNamespace("future")
[08:28:59.742]                         version <- ns[[".package"]][["version"]]
[08:28:59.742]                         if (is.null(version)) 
[08:28:59.742]                           version <- utils::packageVersion("future")
[08:28:59.742]                       }
[08:28:59.742]                       else {
[08:28:59.742]                         version <- NULL
[08:28:59.742]                       }
[08:28:59.742]                       if (!has_future || version < "1.8.0") {
[08:28:59.742]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:59.742]                           "", base::R.version$version.string), 
[08:28:59.742]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:59.742]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:59.742]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:59.742]                             "release", "version")], collapse = " "), 
[08:28:59.742]                           hostname = base::Sys.info()[["nodename"]])
[08:28:59.742]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:59.742]                           info)
[08:28:59.742]                         info <- base::paste(info, collapse = "; ")
[08:28:59.742]                         if (!has_future) {
[08:28:59.742]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:59.742]                             info)
[08:28:59.742]                         }
[08:28:59.742]                         else {
[08:28:59.742]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:59.742]                             info, version)
[08:28:59.742]                         }
[08:28:59.742]                         base::stop(msg)
[08:28:59.742]                       }
[08:28:59.742]                     })
[08:28:59.742]                   }
[08:28:59.742]                   ...future.strategy.old <- future::plan("list")
[08:28:59.742]                   options(future.plan = NULL)
[08:28:59.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:59.742]                 }
[08:28:59.742]                 ...future.workdir <- getwd()
[08:28:59.742]             }
[08:28:59.742]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:59.742]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:59.742]         }
[08:28:59.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:59.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:59.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:59.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:59.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:59.742]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:59.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:59.742]             base::names(...future.oldOptions))
[08:28:59.742]     }
[08:28:59.742]     if (FALSE) {
[08:28:59.742]     }
[08:28:59.742]     else {
[08:28:59.742]         if (TRUE) {
[08:28:59.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:59.742]                 open = "w")
[08:28:59.742]         }
[08:28:59.742]         else {
[08:28:59.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:59.742]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:59.742]         }
[08:28:59.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:59.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:59.742]             base::sink(type = "output", split = FALSE)
[08:28:59.742]             base::close(...future.stdout)
[08:28:59.742]         }, add = TRUE)
[08:28:59.742]     }
[08:28:59.742]     ...future.frame <- base::sys.nframe()
[08:28:59.742]     ...future.conditions <- base::list()
[08:28:59.742]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:59.742]     if (FALSE) {
[08:28:59.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:59.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:59.742]     }
[08:28:59.742]     ...future.result <- base::tryCatch({
[08:28:59.742]         base::withCallingHandlers({
[08:28:59.742]             ...future.value <- base::withVisible(base::local(1))
[08:28:59.742]             future::FutureResult(value = ...future.value$value, 
[08:28:59.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.742]                   ...future.rng), globalenv = if (FALSE) 
[08:28:59.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:59.742]                     ...future.globalenv.names))
[08:28:59.742]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:59.742]         }, condition = base::local({
[08:28:59.742]             c <- base::c
[08:28:59.742]             inherits <- base::inherits
[08:28:59.742]             invokeRestart <- base::invokeRestart
[08:28:59.742]             length <- base::length
[08:28:59.742]             list <- base::list
[08:28:59.742]             seq.int <- base::seq.int
[08:28:59.742]             signalCondition <- base::signalCondition
[08:28:59.742]             sys.calls <- base::sys.calls
[08:28:59.742]             `[[` <- base::`[[`
[08:28:59.742]             `+` <- base::`+`
[08:28:59.742]             `<<-` <- base::`<<-`
[08:28:59.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:59.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:59.742]                   3L)]
[08:28:59.742]             }
[08:28:59.742]             function(cond) {
[08:28:59.742]                 is_error <- inherits(cond, "error")
[08:28:59.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:59.742]                   NULL)
[08:28:59.742]                 if (is_error) {
[08:28:59.742]                   sessionInformation <- function() {
[08:28:59.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:59.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:59.742]                       search = base::search(), system = base::Sys.info())
[08:28:59.742]                   }
[08:28:59.742]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:59.742]                     cond$call), session = sessionInformation(), 
[08:28:59.742]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:59.742]                   signalCondition(cond)
[08:28:59.742]                 }
[08:28:59.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:59.742]                 "immediateCondition"))) {
[08:28:59.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:59.742]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:59.742]                   if (TRUE && !signal) {
[08:28:59.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.742]                     {
[08:28:59.742]                       inherits <- base::inherits
[08:28:59.742]                       invokeRestart <- base::invokeRestart
[08:28:59.742]                       is.null <- base::is.null
[08:28:59.742]                       muffled <- FALSE
[08:28:59.742]                       if (inherits(cond, "message")) {
[08:28:59.742]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.742]                         if (muffled) 
[08:28:59.742]                           invokeRestart("muffleMessage")
[08:28:59.742]                       }
[08:28:59.742]                       else if (inherits(cond, "warning")) {
[08:28:59.742]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.742]                         if (muffled) 
[08:28:59.742]                           invokeRestart("muffleWarning")
[08:28:59.742]                       }
[08:28:59.742]                       else if (inherits(cond, "condition")) {
[08:28:59.742]                         if (!is.null(pattern)) {
[08:28:59.742]                           computeRestarts <- base::computeRestarts
[08:28:59.742]                           grepl <- base::grepl
[08:28:59.742]                           restarts <- computeRestarts(cond)
[08:28:59.742]                           for (restart in restarts) {
[08:28:59.742]                             name <- restart$name
[08:28:59.742]                             if (is.null(name)) 
[08:28:59.742]                               next
[08:28:59.742]                             if (!grepl(pattern, name)) 
[08:28:59.742]                               next
[08:28:59.742]                             invokeRestart(restart)
[08:28:59.742]                             muffled <- TRUE
[08:28:59.742]                             break
[08:28:59.742]                           }
[08:28:59.742]                         }
[08:28:59.742]                       }
[08:28:59.742]                       invisible(muffled)
[08:28:59.742]                     }
[08:28:59.742]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.742]                   }
[08:28:59.742]                 }
[08:28:59.742]                 else {
[08:28:59.742]                   if (TRUE) {
[08:28:59.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.742]                     {
[08:28:59.742]                       inherits <- base::inherits
[08:28:59.742]                       invokeRestart <- base::invokeRestart
[08:28:59.742]                       is.null <- base::is.null
[08:28:59.742]                       muffled <- FALSE
[08:28:59.742]                       if (inherits(cond, "message")) {
[08:28:59.742]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.742]                         if (muffled) 
[08:28:59.742]                           invokeRestart("muffleMessage")
[08:28:59.742]                       }
[08:28:59.742]                       else if (inherits(cond, "warning")) {
[08:28:59.742]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.742]                         if (muffled) 
[08:28:59.742]                           invokeRestart("muffleWarning")
[08:28:59.742]                       }
[08:28:59.742]                       else if (inherits(cond, "condition")) {
[08:28:59.742]                         if (!is.null(pattern)) {
[08:28:59.742]                           computeRestarts <- base::computeRestarts
[08:28:59.742]                           grepl <- base::grepl
[08:28:59.742]                           restarts <- computeRestarts(cond)
[08:28:59.742]                           for (restart in restarts) {
[08:28:59.742]                             name <- restart$name
[08:28:59.742]                             if (is.null(name)) 
[08:28:59.742]                               next
[08:28:59.742]                             if (!grepl(pattern, name)) 
[08:28:59.742]                               next
[08:28:59.742]                             invokeRestart(restart)
[08:28:59.742]                             muffled <- TRUE
[08:28:59.742]                             break
[08:28:59.742]                           }
[08:28:59.742]                         }
[08:28:59.742]                       }
[08:28:59.742]                       invisible(muffled)
[08:28:59.742]                     }
[08:28:59.742]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.742]                   }
[08:28:59.742]                 }
[08:28:59.742]             }
[08:28:59.742]         }))
[08:28:59.742]     }, error = function(ex) {
[08:28:59.742]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:59.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.742]                 ...future.rng), started = ...future.startTime, 
[08:28:59.742]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:59.742]             version = "1.8"), class = "FutureResult")
[08:28:59.742]     }, finally = {
[08:28:59.742]         if (!identical(...future.workdir, getwd())) 
[08:28:59.742]             setwd(...future.workdir)
[08:28:59.742]         {
[08:28:59.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:59.742]                 ...future.oldOptions$nwarnings <- NULL
[08:28:59.742]             }
[08:28:59.742]             base::options(...future.oldOptions)
[08:28:59.742]             if (.Platform$OS.type == "windows") {
[08:28:59.742]                 old_names <- names(...future.oldEnvVars)
[08:28:59.742]                 envs <- base::Sys.getenv()
[08:28:59.742]                 names <- names(envs)
[08:28:59.742]                 common <- intersect(names, old_names)
[08:28:59.742]                 added <- setdiff(names, old_names)
[08:28:59.742]                 removed <- setdiff(old_names, names)
[08:28:59.742]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:59.742]                   envs[common]]
[08:28:59.742]                 NAMES <- toupper(changed)
[08:28:59.742]                 args <- list()
[08:28:59.742]                 for (kk in seq_along(NAMES)) {
[08:28:59.742]                   name <- changed[[kk]]
[08:28:59.742]                   NAME <- NAMES[[kk]]
[08:28:59.742]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.742]                     next
[08:28:59.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.742]                 }
[08:28:59.742]                 NAMES <- toupper(added)
[08:28:59.742]                 for (kk in seq_along(NAMES)) {
[08:28:59.742]                   name <- added[[kk]]
[08:28:59.742]                   NAME <- NAMES[[kk]]
[08:28:59.742]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.742]                     next
[08:28:59.742]                   args[[name]] <- ""
[08:28:59.742]                 }
[08:28:59.742]                 NAMES <- toupper(removed)
[08:28:59.742]                 for (kk in seq_along(NAMES)) {
[08:28:59.742]                   name <- removed[[kk]]
[08:28:59.742]                   NAME <- NAMES[[kk]]
[08:28:59.742]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.742]                     next
[08:28:59.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.742]                 }
[08:28:59.742]                 if (length(args) > 0) 
[08:28:59.742]                   base::do.call(base::Sys.setenv, args = args)
[08:28:59.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:59.742]             }
[08:28:59.742]             else {
[08:28:59.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:59.742]             }
[08:28:59.742]             {
[08:28:59.742]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:59.742]                   0L) {
[08:28:59.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:59.742]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:59.742]                   base::options(opts)
[08:28:59.742]                 }
[08:28:59.742]                 {
[08:28:59.742]                   {
[08:28:59.742]                     NULL
[08:28:59.742]                     RNGkind("Mersenne-Twister")
[08:28:59.742]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:59.742]                       inherits = FALSE)
[08:28:59.742]                   }
[08:28:59.742]                   options(future.plan = NULL)
[08:28:59.742]                   if (is.na(NA_character_)) 
[08:28:59.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:59.742]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:59.742]                     .init = FALSE)
[08:28:59.742]                 }
[08:28:59.742]             }
[08:28:59.742]         }
[08:28:59.742]     })
[08:28:59.742]     if (TRUE) {
[08:28:59.742]         base::sink(type = "output", split = FALSE)
[08:28:59.742]         if (TRUE) {
[08:28:59.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:59.742]         }
[08:28:59.742]         else {
[08:28:59.742]             ...future.result["stdout"] <- base::list(NULL)
[08:28:59.742]         }
[08:28:59.742]         base::close(...future.stdout)
[08:28:59.742]         ...future.stdout <- NULL
[08:28:59.742]     }
[08:28:59.742]     ...future.result$conditions <- ...future.conditions
[08:28:59.742]     ...future.result$finished <- base::Sys.time()
[08:28:59.742]     ...future.result
[08:28:59.742] }
[08:28:59.744] plan(): Setting new future strategy stack:
[08:28:59.744] List of future strategies:
[08:28:59.744] 1. sequential:
[08:28:59.744]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.744]    - tweaked: FALSE
[08:28:59.744]    - call: NULL
[08:28:59.745] plan(): nbrOfWorkers() = 1
[08:28:59.745] plan(): Setting new future strategy stack:
[08:28:59.745] List of future strategies:
[08:28:59.745] 1. sequential:
[08:28:59.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.745]    - tweaked: FALSE
[08:28:59.745]    - call: plan(strategy)
[08:28:59.746] plan(): nbrOfWorkers() = 1
[08:28:59.746] SequentialFuture started (and completed)
[08:28:59.746] - Launch lazy future ... done
[08:28:59.746] run() for ‘SequentialFuture’ ... done
[08:28:59.746] getGlobalsAndPackages() ...
[08:28:59.746] Searching for globals...
[08:28:59.751] - globals found: [2] ‘{’, ‘Sys.sleep’
[08:28:59.751] Searching for globals ... DONE
[08:28:59.751] Resolving globals: FALSE
[08:28:59.751] 
[08:28:59.751] 
[08:28:59.751] getGlobalsAndPackages() ... DONE
[08:28:59.752] run() for ‘Future’ ...
[08:28:59.752] - state: ‘created’
[08:28:59.752] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:59.752] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:59.752] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:59.752]   - Field: ‘label’
[08:28:59.752]   - Field: ‘local’
[08:28:59.752]   - Field: ‘owner’
[08:28:59.753]   - Field: ‘envir’
[08:28:59.753]   - Field: ‘packages’
[08:28:59.753]   - Field: ‘gc’
[08:28:59.753]   - Field: ‘conditions’
[08:28:59.753]   - Field: ‘expr’
[08:28:59.753]   - Field: ‘uuid’
[08:28:59.753]   - Field: ‘seed’
[08:28:59.753]   - Field: ‘version’
[08:28:59.753]   - Field: ‘result’
[08:28:59.753]   - Field: ‘asynchronous’
[08:28:59.753]   - Field: ‘calls’
[08:28:59.753]   - Field: ‘globals’
[08:28:59.753]   - Field: ‘stdout’
[08:28:59.754]   - Field: ‘earlySignal’
[08:28:59.754]   - Field: ‘lazy’
[08:28:59.754]   - Field: ‘state’
[08:28:59.754] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:59.754] - Launch lazy future ...
[08:28:59.754] Packages needed by the future expression (n = 0): <none>
[08:28:59.754] Packages needed by future strategies (n = 0): <none>
[08:28:59.755] {
[08:28:59.755]     {
[08:28:59.755]         {
[08:28:59.755]             ...future.startTime <- base::Sys.time()
[08:28:59.755]             {
[08:28:59.755]                 {
[08:28:59.755]                   {
[08:28:59.755]                     base::local({
[08:28:59.755]                       has_future <- base::requireNamespace("future", 
[08:28:59.755]                         quietly = TRUE)
[08:28:59.755]                       if (has_future) {
[08:28:59.755]                         ns <- base::getNamespace("future")
[08:28:59.755]                         version <- ns[[".package"]][["version"]]
[08:28:59.755]                         if (is.null(version)) 
[08:28:59.755]                           version <- utils::packageVersion("future")
[08:28:59.755]                       }
[08:28:59.755]                       else {
[08:28:59.755]                         version <- NULL
[08:28:59.755]                       }
[08:28:59.755]                       if (!has_future || version < "1.8.0") {
[08:28:59.755]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:59.755]                           "", base::R.version$version.string), 
[08:28:59.755]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:59.755]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:59.755]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:59.755]                             "release", "version")], collapse = " "), 
[08:28:59.755]                           hostname = base::Sys.info()[["nodename"]])
[08:28:59.755]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:59.755]                           info)
[08:28:59.755]                         info <- base::paste(info, collapse = "; ")
[08:28:59.755]                         if (!has_future) {
[08:28:59.755]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:59.755]                             info)
[08:28:59.755]                         }
[08:28:59.755]                         else {
[08:28:59.755]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:59.755]                             info, version)
[08:28:59.755]                         }
[08:28:59.755]                         base::stop(msg)
[08:28:59.755]                       }
[08:28:59.755]                     })
[08:28:59.755]                   }
[08:28:59.755]                   ...future.strategy.old <- future::plan("list")
[08:28:59.755]                   options(future.plan = NULL)
[08:28:59.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:59.755]                 }
[08:28:59.755]                 ...future.workdir <- getwd()
[08:28:59.755]             }
[08:28:59.755]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:59.755]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:59.755]         }
[08:28:59.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:59.755]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:59.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:59.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:59.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:59.755]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:59.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:59.755]             base::names(...future.oldOptions))
[08:28:59.755]     }
[08:28:59.755]     if (FALSE) {
[08:28:59.755]     }
[08:28:59.755]     else {
[08:28:59.755]         if (TRUE) {
[08:28:59.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:59.755]                 open = "w")
[08:28:59.755]         }
[08:28:59.755]         else {
[08:28:59.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:59.755]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:59.755]         }
[08:28:59.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:59.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:59.755]             base::sink(type = "output", split = FALSE)
[08:28:59.755]             base::close(...future.stdout)
[08:28:59.755]         }, add = TRUE)
[08:28:59.755]     }
[08:28:59.755]     ...future.frame <- base::sys.nframe()
[08:28:59.755]     ...future.conditions <- base::list()
[08:28:59.755]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:59.755]     if (FALSE) {
[08:28:59.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:59.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:59.755]     }
[08:28:59.755]     ...future.result <- base::tryCatch({
[08:28:59.755]         base::withCallingHandlers({
[08:28:59.755]             ...future.value <- base::withVisible(base::local({
[08:28:59.755]                 Sys.sleep(0.5)
[08:28:59.755]                 2
[08:28:59.755]             }))
[08:28:59.755]             future::FutureResult(value = ...future.value$value, 
[08:28:59.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.755]                   ...future.rng), globalenv = if (FALSE) 
[08:28:59.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:59.755]                     ...future.globalenv.names))
[08:28:59.755]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:59.755]         }, condition = base::local({
[08:28:59.755]             c <- base::c
[08:28:59.755]             inherits <- base::inherits
[08:28:59.755]             invokeRestart <- base::invokeRestart
[08:28:59.755]             length <- base::length
[08:28:59.755]             list <- base::list
[08:28:59.755]             seq.int <- base::seq.int
[08:28:59.755]             signalCondition <- base::signalCondition
[08:28:59.755]             sys.calls <- base::sys.calls
[08:28:59.755]             `[[` <- base::`[[`
[08:28:59.755]             `+` <- base::`+`
[08:28:59.755]             `<<-` <- base::`<<-`
[08:28:59.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:59.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:59.755]                   3L)]
[08:28:59.755]             }
[08:28:59.755]             function(cond) {
[08:28:59.755]                 is_error <- inherits(cond, "error")
[08:28:59.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:59.755]                   NULL)
[08:28:59.755]                 if (is_error) {
[08:28:59.755]                   sessionInformation <- function() {
[08:28:59.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:59.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:59.755]                       search = base::search(), system = base::Sys.info())
[08:28:59.755]                   }
[08:28:59.755]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:59.755]                     cond$call), session = sessionInformation(), 
[08:28:59.755]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:59.755]                   signalCondition(cond)
[08:28:59.755]                 }
[08:28:59.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:59.755]                 "immediateCondition"))) {
[08:28:59.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:59.755]                   ...future.conditions[[length(...future.conditions) + 
[08:28:59.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:59.755]                   if (TRUE && !signal) {
[08:28:59.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.755]                     {
[08:28:59.755]                       inherits <- base::inherits
[08:28:59.755]                       invokeRestart <- base::invokeRestart
[08:28:59.755]                       is.null <- base::is.null
[08:28:59.755]                       muffled <- FALSE
[08:28:59.755]                       if (inherits(cond, "message")) {
[08:28:59.755]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.755]                         if (muffled) 
[08:28:59.755]                           invokeRestart("muffleMessage")
[08:28:59.755]                       }
[08:28:59.755]                       else if (inherits(cond, "warning")) {
[08:28:59.755]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.755]                         if (muffled) 
[08:28:59.755]                           invokeRestart("muffleWarning")
[08:28:59.755]                       }
[08:28:59.755]                       else if (inherits(cond, "condition")) {
[08:28:59.755]                         if (!is.null(pattern)) {
[08:28:59.755]                           computeRestarts <- base::computeRestarts
[08:28:59.755]                           grepl <- base::grepl
[08:28:59.755]                           restarts <- computeRestarts(cond)
[08:28:59.755]                           for (restart in restarts) {
[08:28:59.755]                             name <- restart$name
[08:28:59.755]                             if (is.null(name)) 
[08:28:59.755]                               next
[08:28:59.755]                             if (!grepl(pattern, name)) 
[08:28:59.755]                               next
[08:28:59.755]                             invokeRestart(restart)
[08:28:59.755]                             muffled <- TRUE
[08:28:59.755]                             break
[08:28:59.755]                           }
[08:28:59.755]                         }
[08:28:59.755]                       }
[08:28:59.755]                       invisible(muffled)
[08:28:59.755]                     }
[08:28:59.755]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.755]                   }
[08:28:59.755]                 }
[08:28:59.755]                 else {
[08:28:59.755]                   if (TRUE) {
[08:28:59.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:59.755]                     {
[08:28:59.755]                       inherits <- base::inherits
[08:28:59.755]                       invokeRestart <- base::invokeRestart
[08:28:59.755]                       is.null <- base::is.null
[08:28:59.755]                       muffled <- FALSE
[08:28:59.755]                       if (inherits(cond, "message")) {
[08:28:59.755]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:59.755]                         if (muffled) 
[08:28:59.755]                           invokeRestart("muffleMessage")
[08:28:59.755]                       }
[08:28:59.755]                       else if (inherits(cond, "warning")) {
[08:28:59.755]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:59.755]                         if (muffled) 
[08:28:59.755]                           invokeRestart("muffleWarning")
[08:28:59.755]                       }
[08:28:59.755]                       else if (inherits(cond, "condition")) {
[08:28:59.755]                         if (!is.null(pattern)) {
[08:28:59.755]                           computeRestarts <- base::computeRestarts
[08:28:59.755]                           grepl <- base::grepl
[08:28:59.755]                           restarts <- computeRestarts(cond)
[08:28:59.755]                           for (restart in restarts) {
[08:28:59.755]                             name <- restart$name
[08:28:59.755]                             if (is.null(name)) 
[08:28:59.755]                               next
[08:28:59.755]                             if (!grepl(pattern, name)) 
[08:28:59.755]                               next
[08:28:59.755]                             invokeRestart(restart)
[08:28:59.755]                             muffled <- TRUE
[08:28:59.755]                             break
[08:28:59.755]                           }
[08:28:59.755]                         }
[08:28:59.755]                       }
[08:28:59.755]                       invisible(muffled)
[08:28:59.755]                     }
[08:28:59.755]                     muffleCondition(cond, pattern = "^muffle")
[08:28:59.755]                   }
[08:28:59.755]                 }
[08:28:59.755]             }
[08:28:59.755]         }))
[08:28:59.755]     }, error = function(ex) {
[08:28:59.755]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:59.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:59.755]                 ...future.rng), started = ...future.startTime, 
[08:28:59.755]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:59.755]             version = "1.8"), class = "FutureResult")
[08:28:59.755]     }, finally = {
[08:28:59.755]         if (!identical(...future.workdir, getwd())) 
[08:28:59.755]             setwd(...future.workdir)
[08:28:59.755]         {
[08:28:59.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:59.755]                 ...future.oldOptions$nwarnings <- NULL
[08:28:59.755]             }
[08:28:59.755]             base::options(...future.oldOptions)
[08:28:59.755]             if (.Platform$OS.type == "windows") {
[08:28:59.755]                 old_names <- names(...future.oldEnvVars)
[08:28:59.755]                 envs <- base::Sys.getenv()
[08:28:59.755]                 names <- names(envs)
[08:28:59.755]                 common <- intersect(names, old_names)
[08:28:59.755]                 added <- setdiff(names, old_names)
[08:28:59.755]                 removed <- setdiff(old_names, names)
[08:28:59.755]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:59.755]                   envs[common]]
[08:28:59.755]                 NAMES <- toupper(changed)
[08:28:59.755]                 args <- list()
[08:28:59.755]                 for (kk in seq_along(NAMES)) {
[08:28:59.755]                   name <- changed[[kk]]
[08:28:59.755]                   NAME <- NAMES[[kk]]
[08:28:59.755]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.755]                     next
[08:28:59.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.755]                 }
[08:28:59.755]                 NAMES <- toupper(added)
[08:28:59.755]                 for (kk in seq_along(NAMES)) {
[08:28:59.755]                   name <- added[[kk]]
[08:28:59.755]                   NAME <- NAMES[[kk]]
[08:28:59.755]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.755]                     next
[08:28:59.755]                   args[[name]] <- ""
[08:28:59.755]                 }
[08:28:59.755]                 NAMES <- toupper(removed)
[08:28:59.755]                 for (kk in seq_along(NAMES)) {
[08:28:59.755]                   name <- removed[[kk]]
[08:28:59.755]                   NAME <- NAMES[[kk]]
[08:28:59.755]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:59.755]                     next
[08:28:59.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:59.755]                 }
[08:28:59.755]                 if (length(args) > 0) 
[08:28:59.755]                   base::do.call(base::Sys.setenv, args = args)
[08:28:59.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:59.755]             }
[08:28:59.755]             else {
[08:28:59.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:59.755]             }
[08:28:59.755]             {
[08:28:59.755]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:59.755]                   0L) {
[08:28:59.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:59.755]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:59.755]                   base::options(opts)
[08:28:59.755]                 }
[08:28:59.755]                 {
[08:28:59.755]                   {
[08:28:59.755]                     NULL
[08:28:59.755]                     RNGkind("Mersenne-Twister")
[08:28:59.755]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:59.755]                       inherits = FALSE)
[08:28:59.755]                   }
[08:28:59.755]                   options(future.plan = NULL)
[08:28:59.755]                   if (is.na(NA_character_)) 
[08:28:59.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:59.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:59.755]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:59.755]                     .init = FALSE)
[08:28:59.755]                 }
[08:28:59.755]             }
[08:28:59.755]         }
[08:28:59.755]     })
[08:28:59.755]     if (TRUE) {
[08:28:59.755]         base::sink(type = "output", split = FALSE)
[08:28:59.755]         if (TRUE) {
[08:28:59.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:59.755]         }
[08:28:59.755]         else {
[08:28:59.755]             ...future.result["stdout"] <- base::list(NULL)
[08:28:59.755]         }
[08:28:59.755]         base::close(...future.stdout)
[08:28:59.755]         ...future.stdout <- NULL
[08:28:59.755]     }
[08:28:59.755]     ...future.result$conditions <- ...future.conditions
[08:28:59.755]     ...future.result$finished <- base::Sys.time()
[08:28:59.755]     ...future.result
[08:28:59.755] }
[08:28:59.756] plan(): Setting new future strategy stack:
[08:28:59.756] List of future strategies:
[08:28:59.756] 1. sequential:
[08:28:59.756]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:59.756]    - tweaked: FALSE
[08:28:59.756]    - call: NULL
[08:28:59.757] plan(): nbrOfWorkers() = 1
[08:29:00.259] plan(): Setting new future strategy stack:
[08:29:00.259] List of future strategies:
[08:29:00.259] 1. sequential:
[08:29:00.259]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.259]    - tweaked: FALSE
[08:29:00.259]    - call: plan(strategy)
[08:29:00.259] plan(): nbrOfWorkers() = 1
[08:29:00.260] SequentialFuture started (and completed)
[08:29:00.260] - Launch lazy future ... done
[08:29:00.260] run() for ‘SequentialFuture’ ... done
[08:29:00.260] resolve() on list ...
[08:29:00.260]  recursive: 0
[08:29:00.260]  length: 1
[08:29:00.261] 
[08:29:00.261] resolved() for ‘SequentialFuture’ ...
[08:29:00.261] - state: ‘finished’
[08:29:00.261] - run: TRUE
[08:29:00.261] - result: ‘FutureResult’
[08:29:00.261] resolved() for ‘SequentialFuture’ ... done
[08:29:00.261] Future #1
[08:29:00.261]  length: 0 (resolved future 1)
[08:29:00.261] resolve() on list ... DONE
[08:29:00.261] resolved() for ‘SequentialFuture’ ...
[08:29:00.261] - state: ‘finished’
[08:29:00.262] - run: TRUE
[08:29:00.262] - result: ‘FutureResult’
[08:29:00.262] resolved() for ‘SequentialFuture’ ... done
[08:29:00.262] resolve() on list ...
[08:29:00.262]  recursive: 0
[08:29:00.262]  length: 1
[08:29:00.262] 
[08:29:00.262] resolved() for ‘SequentialFuture’ ...
[08:29:00.262] - state: ‘finished’
[08:29:00.262] - run: TRUE
[08:29:00.262] - result: ‘FutureResult’
[08:29:00.263] resolved() for ‘SequentialFuture’ ... done
[08:29:00.263] Future #1
[08:29:00.263]  length: 0 (resolved future 1)
[08:29:00.263] resolve() on list ... DONE
[08:29:00.263] resolved() for ‘SequentialFuture’ ...
[08:29:00.263] - state: ‘finished’
[08:29:00.263] - run: TRUE
[08:29:00.263] - result: ‘FutureResult’
[08:29:00.263] resolved() for ‘SequentialFuture’ ... done
[08:29:00.263] resolve() on list ...
[08:29:00.263]  recursive: 0
[08:29:00.264]  length: 1
[08:29:00.264] 
[08:29:00.264]  length: 0 (resolved future 1)
[08:29:00.264] resolve() on list ... DONE
[08:29:00.264] resolve() on list ...
[08:29:00.264]  recursive: 0
[08:29:00.264]  length: 4
[08:29:00.264] 
[08:29:00.264] resolved() for ‘SequentialFuture’ ...
[08:29:00.264] - state: ‘finished’
[08:29:00.264] - run: TRUE
[08:29:00.265] - result: ‘FutureResult’
[08:29:00.265] resolved() for ‘SequentialFuture’ ... done
[08:29:00.265] Future #1
[08:29:00.265]  length: 3 (resolved future 1)
[08:29:00.265] resolved() for ‘SequentialFuture’ ...
[08:29:00.265] - state: ‘finished’
[08:29:00.265] - run: TRUE
[08:29:00.265] - result: ‘FutureResult’
[08:29:00.265] resolved() for ‘SequentialFuture’ ... done
[08:29:00.265] Future #2
[08:29:00.267]  length: 2 (resolved future 2)
[08:29:00.267]  length: 1 (resolved future 3)
[08:29:00.268]  length: 0 (resolved future 4)
[08:29:00.268] resolve() on list ... DONE
[08:29:00.268] resolve() on list ...
[08:29:00.268]  recursive: 0
[08:29:00.268]  length: 4
[08:29:00.268] 
[08:29:00.268] resolved() for ‘SequentialFuture’ ...
[08:29:00.268] - state: ‘finished’
[08:29:00.268] - run: TRUE
[08:29:00.268] - result: ‘FutureResult’
[08:29:00.268] resolved() for ‘SequentialFuture’ ... done
[08:29:00.269] Future #1
[08:29:00.269]  length: 3 (resolved future 1)
[08:29:00.269] resolved() for ‘SequentialFuture’ ...
[08:29:00.269] - state: ‘finished’
[08:29:00.269] - run: TRUE
[08:29:00.269] - result: ‘FutureResult’
[08:29:00.269] resolved() for ‘SequentialFuture’ ... done
[08:29:00.269] Future #2
[08:29:00.269]  length: 2 (resolved future 2)
[08:29:00.269]  length: 1 (resolved future 3)
[08:29:00.269]  length: 0 (resolved future 4)
[08:29:00.270] resolve() on list ... DONE
[08:29:00.270] resolve() on list ...
[08:29:00.270]  recursive: 0
[08:29:00.270]  length: 1
[08:29:00.270] 
[08:29:00.270]  length: 0 (resolved future 1)
[08:29:00.270] resolve() on list ... DONE
[08:29:00.270] getGlobalsAndPackages() ...
[08:29:00.270] Searching for globals...
[08:29:00.271] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:00.272] Searching for globals ... DONE
[08:29:00.272] Resolving globals: FALSE
[08:29:00.272] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:00.273] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:00.273] - globals: [1] ‘kk’
[08:29:00.273] 
[08:29:00.273] getGlobalsAndPackages() ... DONE
[08:29:00.273] run() for ‘Future’ ...
[08:29:00.273] - state: ‘created’
[08:29:00.274] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:00.274] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:00.274] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:00.274]   - Field: ‘label’
[08:29:00.274]   - Field: ‘local’
[08:29:00.274]   - Field: ‘owner’
[08:29:00.274]   - Field: ‘envir’
[08:29:00.274]   - Field: ‘packages’
[08:29:00.274]   - Field: ‘gc’
[08:29:00.274]   - Field: ‘conditions’
[08:29:00.275]   - Field: ‘expr’
[08:29:00.275]   - Field: ‘uuid’
[08:29:00.275]   - Field: ‘seed’
[08:29:00.275]   - Field: ‘version’
[08:29:00.275]   - Field: ‘result’
[08:29:00.275]   - Field: ‘asynchronous’
[08:29:00.275]   - Field: ‘calls’
[08:29:00.275]   - Field: ‘globals’
[08:29:00.275]   - Field: ‘stdout’
[08:29:00.275]   - Field: ‘earlySignal’
[08:29:00.275]   - Field: ‘lazy’
[08:29:00.275]   - Field: ‘state’
[08:29:00.276] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:00.276] - Launch lazy future ...
[08:29:00.276] Packages needed by the future expression (n = 0): <none>
[08:29:00.276] Packages needed by future strategies (n = 0): <none>
[08:29:00.276] {
[08:29:00.276]     {
[08:29:00.276]         {
[08:29:00.276]             ...future.startTime <- base::Sys.time()
[08:29:00.276]             {
[08:29:00.276]                 {
[08:29:00.276]                   {
[08:29:00.276]                     base::local({
[08:29:00.276]                       has_future <- base::requireNamespace("future", 
[08:29:00.276]                         quietly = TRUE)
[08:29:00.276]                       if (has_future) {
[08:29:00.276]                         ns <- base::getNamespace("future")
[08:29:00.276]                         version <- ns[[".package"]][["version"]]
[08:29:00.276]                         if (is.null(version)) 
[08:29:00.276]                           version <- utils::packageVersion("future")
[08:29:00.276]                       }
[08:29:00.276]                       else {
[08:29:00.276]                         version <- NULL
[08:29:00.276]                       }
[08:29:00.276]                       if (!has_future || version < "1.8.0") {
[08:29:00.276]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:00.276]                           "", base::R.version$version.string), 
[08:29:00.276]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:00.276]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:00.276]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:00.276]                             "release", "version")], collapse = " "), 
[08:29:00.276]                           hostname = base::Sys.info()[["nodename"]])
[08:29:00.276]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:00.276]                           info)
[08:29:00.276]                         info <- base::paste(info, collapse = "; ")
[08:29:00.276]                         if (!has_future) {
[08:29:00.276]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:00.276]                             info)
[08:29:00.276]                         }
[08:29:00.276]                         else {
[08:29:00.276]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:00.276]                             info, version)
[08:29:00.276]                         }
[08:29:00.276]                         base::stop(msg)
[08:29:00.276]                       }
[08:29:00.276]                     })
[08:29:00.276]                   }
[08:29:00.276]                   ...future.strategy.old <- future::plan("list")
[08:29:00.276]                   options(future.plan = NULL)
[08:29:00.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:00.276]                 }
[08:29:00.276]                 ...future.workdir <- getwd()
[08:29:00.276]             }
[08:29:00.276]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:00.276]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:00.276]         }
[08:29:00.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:00.276]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:00.276]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:00.276]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:00.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:00.276]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:00.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:00.276]             base::names(...future.oldOptions))
[08:29:00.276]     }
[08:29:00.276]     if (FALSE) {
[08:29:00.276]     }
[08:29:00.276]     else {
[08:29:00.276]         if (TRUE) {
[08:29:00.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:00.276]                 open = "w")
[08:29:00.276]         }
[08:29:00.276]         else {
[08:29:00.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:00.276]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:00.276]         }
[08:29:00.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:00.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:00.276]             base::sink(type = "output", split = FALSE)
[08:29:00.276]             base::close(...future.stdout)
[08:29:00.276]         }, add = TRUE)
[08:29:00.276]     }
[08:29:00.276]     ...future.frame <- base::sys.nframe()
[08:29:00.276]     ...future.conditions <- base::list()
[08:29:00.276]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:00.276]     if (FALSE) {
[08:29:00.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:00.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:00.276]     }
[08:29:00.276]     ...future.result <- base::tryCatch({
[08:29:00.276]         base::withCallingHandlers({
[08:29:00.276]             ...future.value <- base::withVisible(base::local({
[08:29:00.276]                 Sys.sleep(0.1)
[08:29:00.276]                 kk
[08:29:00.276]             }))
[08:29:00.276]             future::FutureResult(value = ...future.value$value, 
[08:29:00.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.276]                   ...future.rng), globalenv = if (FALSE) 
[08:29:00.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:00.276]                     ...future.globalenv.names))
[08:29:00.276]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:00.276]         }, condition = base::local({
[08:29:00.276]             c <- base::c
[08:29:00.276]             inherits <- base::inherits
[08:29:00.276]             invokeRestart <- base::invokeRestart
[08:29:00.276]             length <- base::length
[08:29:00.276]             list <- base::list
[08:29:00.276]             seq.int <- base::seq.int
[08:29:00.276]             signalCondition <- base::signalCondition
[08:29:00.276]             sys.calls <- base::sys.calls
[08:29:00.276]             `[[` <- base::`[[`
[08:29:00.276]             `+` <- base::`+`
[08:29:00.276]             `<<-` <- base::`<<-`
[08:29:00.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:00.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:00.276]                   3L)]
[08:29:00.276]             }
[08:29:00.276]             function(cond) {
[08:29:00.276]                 is_error <- inherits(cond, "error")
[08:29:00.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:00.276]                   NULL)
[08:29:00.276]                 if (is_error) {
[08:29:00.276]                   sessionInformation <- function() {
[08:29:00.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:00.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:00.276]                       search = base::search(), system = base::Sys.info())
[08:29:00.276]                   }
[08:29:00.276]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:00.276]                     cond$call), session = sessionInformation(), 
[08:29:00.276]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:00.276]                   signalCondition(cond)
[08:29:00.276]                 }
[08:29:00.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:00.276]                 "immediateCondition"))) {
[08:29:00.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:00.276]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:00.276]                   if (TRUE && !signal) {
[08:29:00.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.276]                     {
[08:29:00.276]                       inherits <- base::inherits
[08:29:00.276]                       invokeRestart <- base::invokeRestart
[08:29:00.276]                       is.null <- base::is.null
[08:29:00.276]                       muffled <- FALSE
[08:29:00.276]                       if (inherits(cond, "message")) {
[08:29:00.276]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.276]                         if (muffled) 
[08:29:00.276]                           invokeRestart("muffleMessage")
[08:29:00.276]                       }
[08:29:00.276]                       else if (inherits(cond, "warning")) {
[08:29:00.276]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.276]                         if (muffled) 
[08:29:00.276]                           invokeRestart("muffleWarning")
[08:29:00.276]                       }
[08:29:00.276]                       else if (inherits(cond, "condition")) {
[08:29:00.276]                         if (!is.null(pattern)) {
[08:29:00.276]                           computeRestarts <- base::computeRestarts
[08:29:00.276]                           grepl <- base::grepl
[08:29:00.276]                           restarts <- computeRestarts(cond)
[08:29:00.276]                           for (restart in restarts) {
[08:29:00.276]                             name <- restart$name
[08:29:00.276]                             if (is.null(name)) 
[08:29:00.276]                               next
[08:29:00.276]                             if (!grepl(pattern, name)) 
[08:29:00.276]                               next
[08:29:00.276]                             invokeRestart(restart)
[08:29:00.276]                             muffled <- TRUE
[08:29:00.276]                             break
[08:29:00.276]                           }
[08:29:00.276]                         }
[08:29:00.276]                       }
[08:29:00.276]                       invisible(muffled)
[08:29:00.276]                     }
[08:29:00.276]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.276]                   }
[08:29:00.276]                 }
[08:29:00.276]                 else {
[08:29:00.276]                   if (TRUE) {
[08:29:00.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.276]                     {
[08:29:00.276]                       inherits <- base::inherits
[08:29:00.276]                       invokeRestart <- base::invokeRestart
[08:29:00.276]                       is.null <- base::is.null
[08:29:00.276]                       muffled <- FALSE
[08:29:00.276]                       if (inherits(cond, "message")) {
[08:29:00.276]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.276]                         if (muffled) 
[08:29:00.276]                           invokeRestart("muffleMessage")
[08:29:00.276]                       }
[08:29:00.276]                       else if (inherits(cond, "warning")) {
[08:29:00.276]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.276]                         if (muffled) 
[08:29:00.276]                           invokeRestart("muffleWarning")
[08:29:00.276]                       }
[08:29:00.276]                       else if (inherits(cond, "condition")) {
[08:29:00.276]                         if (!is.null(pattern)) {
[08:29:00.276]                           computeRestarts <- base::computeRestarts
[08:29:00.276]                           grepl <- base::grepl
[08:29:00.276]                           restarts <- computeRestarts(cond)
[08:29:00.276]                           for (restart in restarts) {
[08:29:00.276]                             name <- restart$name
[08:29:00.276]                             if (is.null(name)) 
[08:29:00.276]                               next
[08:29:00.276]                             if (!grepl(pattern, name)) 
[08:29:00.276]                               next
[08:29:00.276]                             invokeRestart(restart)
[08:29:00.276]                             muffled <- TRUE
[08:29:00.276]                             break
[08:29:00.276]                           }
[08:29:00.276]                         }
[08:29:00.276]                       }
[08:29:00.276]                       invisible(muffled)
[08:29:00.276]                     }
[08:29:00.276]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.276]                   }
[08:29:00.276]                 }
[08:29:00.276]             }
[08:29:00.276]         }))
[08:29:00.276]     }, error = function(ex) {
[08:29:00.276]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:00.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.276]                 ...future.rng), started = ...future.startTime, 
[08:29:00.276]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:00.276]             version = "1.8"), class = "FutureResult")
[08:29:00.276]     }, finally = {
[08:29:00.276]         if (!identical(...future.workdir, getwd())) 
[08:29:00.276]             setwd(...future.workdir)
[08:29:00.276]         {
[08:29:00.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:00.276]                 ...future.oldOptions$nwarnings <- NULL
[08:29:00.276]             }
[08:29:00.276]             base::options(...future.oldOptions)
[08:29:00.276]             if (.Platform$OS.type == "windows") {
[08:29:00.276]                 old_names <- names(...future.oldEnvVars)
[08:29:00.276]                 envs <- base::Sys.getenv()
[08:29:00.276]                 names <- names(envs)
[08:29:00.276]                 common <- intersect(names, old_names)
[08:29:00.276]                 added <- setdiff(names, old_names)
[08:29:00.276]                 removed <- setdiff(old_names, names)
[08:29:00.276]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:00.276]                   envs[common]]
[08:29:00.276]                 NAMES <- toupper(changed)
[08:29:00.276]                 args <- list()
[08:29:00.276]                 for (kk in seq_along(NAMES)) {
[08:29:00.276]                   name <- changed[[kk]]
[08:29:00.276]                   NAME <- NAMES[[kk]]
[08:29:00.276]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.276]                     next
[08:29:00.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.276]                 }
[08:29:00.276]                 NAMES <- toupper(added)
[08:29:00.276]                 for (kk in seq_along(NAMES)) {
[08:29:00.276]                   name <- added[[kk]]
[08:29:00.276]                   NAME <- NAMES[[kk]]
[08:29:00.276]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.276]                     next
[08:29:00.276]                   args[[name]] <- ""
[08:29:00.276]                 }
[08:29:00.276]                 NAMES <- toupper(removed)
[08:29:00.276]                 for (kk in seq_along(NAMES)) {
[08:29:00.276]                   name <- removed[[kk]]
[08:29:00.276]                   NAME <- NAMES[[kk]]
[08:29:00.276]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.276]                     next
[08:29:00.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.276]                 }
[08:29:00.276]                 if (length(args) > 0) 
[08:29:00.276]                   base::do.call(base::Sys.setenv, args = args)
[08:29:00.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:00.276]             }
[08:29:00.276]             else {
[08:29:00.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:00.276]             }
[08:29:00.276]             {
[08:29:00.276]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:00.276]                   0L) {
[08:29:00.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:00.276]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:00.276]                   base::options(opts)
[08:29:00.276]                 }
[08:29:00.276]                 {
[08:29:00.276]                   {
[08:29:00.276]                     NULL
[08:29:00.276]                     RNGkind("Mersenne-Twister")
[08:29:00.276]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:00.276]                       inherits = FALSE)
[08:29:00.276]                   }
[08:29:00.276]                   options(future.plan = NULL)
[08:29:00.276]                   if (is.na(NA_character_)) 
[08:29:00.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:00.276]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:00.276]                     .init = FALSE)
[08:29:00.276]                 }
[08:29:00.276]             }
[08:29:00.276]         }
[08:29:00.276]     })
[08:29:00.276]     if (TRUE) {
[08:29:00.276]         base::sink(type = "output", split = FALSE)
[08:29:00.276]         if (TRUE) {
[08:29:00.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:00.276]         }
[08:29:00.276]         else {
[08:29:00.276]             ...future.result["stdout"] <- base::list(NULL)
[08:29:00.276]         }
[08:29:00.276]         base::close(...future.stdout)
[08:29:00.276]         ...future.stdout <- NULL
[08:29:00.276]     }
[08:29:00.276]     ...future.result$conditions <- ...future.conditions
[08:29:00.276]     ...future.result$finished <- base::Sys.time()
[08:29:00.276]     ...future.result
[08:29:00.276] }
[08:29:00.278] assign_globals() ...
[08:29:00.278] List of 1
[08:29:00.278]  $ kk: int 1
[08:29:00.278]  - attr(*, "where")=List of 1
[08:29:00.278]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:00.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:00.278]  - attr(*, "resolved")= logi FALSE
[08:29:00.278]  - attr(*, "total_size")= num 35
[08:29:00.278]  - attr(*, "already-done")= logi TRUE
[08:29:00.282] - copied ‘kk’ to environment
[08:29:00.282] assign_globals() ... done
[08:29:00.283] plan(): Setting new future strategy stack:
[08:29:00.283] List of future strategies:
[08:29:00.283] 1. sequential:
[08:29:00.283]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.283]    - tweaked: FALSE
[08:29:00.283]    - call: NULL
[08:29:00.283] plan(): nbrOfWorkers() = 1
[08:29:00.384] plan(): Setting new future strategy stack:
[08:29:00.384] List of future strategies:
[08:29:00.384] 1. sequential:
[08:29:00.384]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.384]    - tweaked: FALSE
[08:29:00.384]    - call: plan(strategy)
[08:29:00.385] plan(): nbrOfWorkers() = 1
[08:29:00.385] SequentialFuture started (and completed)
[08:29:00.385] - Launch lazy future ... done
[08:29:00.385] run() for ‘SequentialFuture’ ... done
[08:29:00.386] getGlobalsAndPackages() ...
[08:29:00.386] Searching for globals...
[08:29:00.387] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:00.387] Searching for globals ... DONE
[08:29:00.387] Resolving globals: FALSE
[08:29:00.387] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:00.388] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:00.388] - globals: [1] ‘kk’
[08:29:00.388] 
[08:29:00.388] getGlobalsAndPackages() ... DONE
[08:29:00.388] run() for ‘Future’ ...
[08:29:00.388] - state: ‘created’
[08:29:00.388] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:00.389] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:00.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:00.389]   - Field: ‘label’
[08:29:00.389]   - Field: ‘local’
[08:29:00.389]   - Field: ‘owner’
[08:29:00.389]   - Field: ‘envir’
[08:29:00.389]   - Field: ‘packages’
[08:29:00.389]   - Field: ‘gc’
[08:29:00.389]   - Field: ‘conditions’
[08:29:00.390]   - Field: ‘expr’
[08:29:00.390]   - Field: ‘uuid’
[08:29:00.390]   - Field: ‘seed’
[08:29:00.390]   - Field: ‘version’
[08:29:00.390]   - Field: ‘result’
[08:29:00.390]   - Field: ‘asynchronous’
[08:29:00.390]   - Field: ‘calls’
[08:29:00.390]   - Field: ‘globals’
[08:29:00.390]   - Field: ‘stdout’
[08:29:00.390]   - Field: ‘earlySignal’
[08:29:00.390]   - Field: ‘lazy’
[08:29:00.390]   - Field: ‘state’
[08:29:00.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:00.391] - Launch lazy future ...
[08:29:00.391] Packages needed by the future expression (n = 0): <none>
[08:29:00.391] Packages needed by future strategies (n = 0): <none>
[08:29:00.391] {
[08:29:00.391]     {
[08:29:00.391]         {
[08:29:00.391]             ...future.startTime <- base::Sys.time()
[08:29:00.391]             {
[08:29:00.391]                 {
[08:29:00.391]                   {
[08:29:00.391]                     base::local({
[08:29:00.391]                       has_future <- base::requireNamespace("future", 
[08:29:00.391]                         quietly = TRUE)
[08:29:00.391]                       if (has_future) {
[08:29:00.391]                         ns <- base::getNamespace("future")
[08:29:00.391]                         version <- ns[[".package"]][["version"]]
[08:29:00.391]                         if (is.null(version)) 
[08:29:00.391]                           version <- utils::packageVersion("future")
[08:29:00.391]                       }
[08:29:00.391]                       else {
[08:29:00.391]                         version <- NULL
[08:29:00.391]                       }
[08:29:00.391]                       if (!has_future || version < "1.8.0") {
[08:29:00.391]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:00.391]                           "", base::R.version$version.string), 
[08:29:00.391]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:00.391]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:00.391]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:00.391]                             "release", "version")], collapse = " "), 
[08:29:00.391]                           hostname = base::Sys.info()[["nodename"]])
[08:29:00.391]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:00.391]                           info)
[08:29:00.391]                         info <- base::paste(info, collapse = "; ")
[08:29:00.391]                         if (!has_future) {
[08:29:00.391]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:00.391]                             info)
[08:29:00.391]                         }
[08:29:00.391]                         else {
[08:29:00.391]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:00.391]                             info, version)
[08:29:00.391]                         }
[08:29:00.391]                         base::stop(msg)
[08:29:00.391]                       }
[08:29:00.391]                     })
[08:29:00.391]                   }
[08:29:00.391]                   ...future.strategy.old <- future::plan("list")
[08:29:00.391]                   options(future.plan = NULL)
[08:29:00.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:00.391]                 }
[08:29:00.391]                 ...future.workdir <- getwd()
[08:29:00.391]             }
[08:29:00.391]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:00.391]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:00.391]         }
[08:29:00.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:00.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:00.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:00.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:00.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:00.391]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:00.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:00.391]             base::names(...future.oldOptions))
[08:29:00.391]     }
[08:29:00.391]     if (FALSE) {
[08:29:00.391]     }
[08:29:00.391]     else {
[08:29:00.391]         if (TRUE) {
[08:29:00.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:00.391]                 open = "w")
[08:29:00.391]         }
[08:29:00.391]         else {
[08:29:00.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:00.391]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:00.391]         }
[08:29:00.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:00.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:00.391]             base::sink(type = "output", split = FALSE)
[08:29:00.391]             base::close(...future.stdout)
[08:29:00.391]         }, add = TRUE)
[08:29:00.391]     }
[08:29:00.391]     ...future.frame <- base::sys.nframe()
[08:29:00.391]     ...future.conditions <- base::list()
[08:29:00.391]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:00.391]     if (FALSE) {
[08:29:00.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:00.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:00.391]     }
[08:29:00.391]     ...future.result <- base::tryCatch({
[08:29:00.391]         base::withCallingHandlers({
[08:29:00.391]             ...future.value <- base::withVisible(base::local({
[08:29:00.391]                 Sys.sleep(0.1)
[08:29:00.391]                 kk
[08:29:00.391]             }))
[08:29:00.391]             future::FutureResult(value = ...future.value$value, 
[08:29:00.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.391]                   ...future.rng), globalenv = if (FALSE) 
[08:29:00.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:00.391]                     ...future.globalenv.names))
[08:29:00.391]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:00.391]         }, condition = base::local({
[08:29:00.391]             c <- base::c
[08:29:00.391]             inherits <- base::inherits
[08:29:00.391]             invokeRestart <- base::invokeRestart
[08:29:00.391]             length <- base::length
[08:29:00.391]             list <- base::list
[08:29:00.391]             seq.int <- base::seq.int
[08:29:00.391]             signalCondition <- base::signalCondition
[08:29:00.391]             sys.calls <- base::sys.calls
[08:29:00.391]             `[[` <- base::`[[`
[08:29:00.391]             `+` <- base::`+`
[08:29:00.391]             `<<-` <- base::`<<-`
[08:29:00.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:00.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:00.391]                   3L)]
[08:29:00.391]             }
[08:29:00.391]             function(cond) {
[08:29:00.391]                 is_error <- inherits(cond, "error")
[08:29:00.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:00.391]                   NULL)
[08:29:00.391]                 if (is_error) {
[08:29:00.391]                   sessionInformation <- function() {
[08:29:00.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:00.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:00.391]                       search = base::search(), system = base::Sys.info())
[08:29:00.391]                   }
[08:29:00.391]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:00.391]                     cond$call), session = sessionInformation(), 
[08:29:00.391]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:00.391]                   signalCondition(cond)
[08:29:00.391]                 }
[08:29:00.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:00.391]                 "immediateCondition"))) {
[08:29:00.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:00.391]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:00.391]                   if (TRUE && !signal) {
[08:29:00.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.391]                     {
[08:29:00.391]                       inherits <- base::inherits
[08:29:00.391]                       invokeRestart <- base::invokeRestart
[08:29:00.391]                       is.null <- base::is.null
[08:29:00.391]                       muffled <- FALSE
[08:29:00.391]                       if (inherits(cond, "message")) {
[08:29:00.391]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.391]                         if (muffled) 
[08:29:00.391]                           invokeRestart("muffleMessage")
[08:29:00.391]                       }
[08:29:00.391]                       else if (inherits(cond, "warning")) {
[08:29:00.391]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.391]                         if (muffled) 
[08:29:00.391]                           invokeRestart("muffleWarning")
[08:29:00.391]                       }
[08:29:00.391]                       else if (inherits(cond, "condition")) {
[08:29:00.391]                         if (!is.null(pattern)) {
[08:29:00.391]                           computeRestarts <- base::computeRestarts
[08:29:00.391]                           grepl <- base::grepl
[08:29:00.391]                           restarts <- computeRestarts(cond)
[08:29:00.391]                           for (restart in restarts) {
[08:29:00.391]                             name <- restart$name
[08:29:00.391]                             if (is.null(name)) 
[08:29:00.391]                               next
[08:29:00.391]                             if (!grepl(pattern, name)) 
[08:29:00.391]                               next
[08:29:00.391]                             invokeRestart(restart)
[08:29:00.391]                             muffled <- TRUE
[08:29:00.391]                             break
[08:29:00.391]                           }
[08:29:00.391]                         }
[08:29:00.391]                       }
[08:29:00.391]                       invisible(muffled)
[08:29:00.391]                     }
[08:29:00.391]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.391]                   }
[08:29:00.391]                 }
[08:29:00.391]                 else {
[08:29:00.391]                   if (TRUE) {
[08:29:00.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.391]                     {
[08:29:00.391]                       inherits <- base::inherits
[08:29:00.391]                       invokeRestart <- base::invokeRestart
[08:29:00.391]                       is.null <- base::is.null
[08:29:00.391]                       muffled <- FALSE
[08:29:00.391]                       if (inherits(cond, "message")) {
[08:29:00.391]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.391]                         if (muffled) 
[08:29:00.391]                           invokeRestart("muffleMessage")
[08:29:00.391]                       }
[08:29:00.391]                       else if (inherits(cond, "warning")) {
[08:29:00.391]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.391]                         if (muffled) 
[08:29:00.391]                           invokeRestart("muffleWarning")
[08:29:00.391]                       }
[08:29:00.391]                       else if (inherits(cond, "condition")) {
[08:29:00.391]                         if (!is.null(pattern)) {
[08:29:00.391]                           computeRestarts <- base::computeRestarts
[08:29:00.391]                           grepl <- base::grepl
[08:29:00.391]                           restarts <- computeRestarts(cond)
[08:29:00.391]                           for (restart in restarts) {
[08:29:00.391]                             name <- restart$name
[08:29:00.391]                             if (is.null(name)) 
[08:29:00.391]                               next
[08:29:00.391]                             if (!grepl(pattern, name)) 
[08:29:00.391]                               next
[08:29:00.391]                             invokeRestart(restart)
[08:29:00.391]                             muffled <- TRUE
[08:29:00.391]                             break
[08:29:00.391]                           }
[08:29:00.391]                         }
[08:29:00.391]                       }
[08:29:00.391]                       invisible(muffled)
[08:29:00.391]                     }
[08:29:00.391]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.391]                   }
[08:29:00.391]                 }
[08:29:00.391]             }
[08:29:00.391]         }))
[08:29:00.391]     }, error = function(ex) {
[08:29:00.391]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:00.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.391]                 ...future.rng), started = ...future.startTime, 
[08:29:00.391]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:00.391]             version = "1.8"), class = "FutureResult")
[08:29:00.391]     }, finally = {
[08:29:00.391]         if (!identical(...future.workdir, getwd())) 
[08:29:00.391]             setwd(...future.workdir)
[08:29:00.391]         {
[08:29:00.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:00.391]                 ...future.oldOptions$nwarnings <- NULL
[08:29:00.391]             }
[08:29:00.391]             base::options(...future.oldOptions)
[08:29:00.391]             if (.Platform$OS.type == "windows") {
[08:29:00.391]                 old_names <- names(...future.oldEnvVars)
[08:29:00.391]                 envs <- base::Sys.getenv()
[08:29:00.391]                 names <- names(envs)
[08:29:00.391]                 common <- intersect(names, old_names)
[08:29:00.391]                 added <- setdiff(names, old_names)
[08:29:00.391]                 removed <- setdiff(old_names, names)
[08:29:00.391]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:00.391]                   envs[common]]
[08:29:00.391]                 NAMES <- toupper(changed)
[08:29:00.391]                 args <- list()
[08:29:00.391]                 for (kk in seq_along(NAMES)) {
[08:29:00.391]                   name <- changed[[kk]]
[08:29:00.391]                   NAME <- NAMES[[kk]]
[08:29:00.391]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.391]                     next
[08:29:00.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.391]                 }
[08:29:00.391]                 NAMES <- toupper(added)
[08:29:00.391]                 for (kk in seq_along(NAMES)) {
[08:29:00.391]                   name <- added[[kk]]
[08:29:00.391]                   NAME <- NAMES[[kk]]
[08:29:00.391]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.391]                     next
[08:29:00.391]                   args[[name]] <- ""
[08:29:00.391]                 }
[08:29:00.391]                 NAMES <- toupper(removed)
[08:29:00.391]                 for (kk in seq_along(NAMES)) {
[08:29:00.391]                   name <- removed[[kk]]
[08:29:00.391]                   NAME <- NAMES[[kk]]
[08:29:00.391]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.391]                     next
[08:29:00.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.391]                 }
[08:29:00.391]                 if (length(args) > 0) 
[08:29:00.391]                   base::do.call(base::Sys.setenv, args = args)
[08:29:00.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:00.391]             }
[08:29:00.391]             else {
[08:29:00.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:00.391]             }
[08:29:00.391]             {
[08:29:00.391]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:00.391]                   0L) {
[08:29:00.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:00.391]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:00.391]                   base::options(opts)
[08:29:00.391]                 }
[08:29:00.391]                 {
[08:29:00.391]                   {
[08:29:00.391]                     NULL
[08:29:00.391]                     RNGkind("Mersenne-Twister")
[08:29:00.391]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:00.391]                       inherits = FALSE)
[08:29:00.391]                   }
[08:29:00.391]                   options(future.plan = NULL)
[08:29:00.391]                   if (is.na(NA_character_)) 
[08:29:00.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:00.391]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:00.391]                     .init = FALSE)
[08:29:00.391]                 }
[08:29:00.391]             }
[08:29:00.391]         }
[08:29:00.391]     })
[08:29:00.391]     if (TRUE) {
[08:29:00.391]         base::sink(type = "output", split = FALSE)
[08:29:00.391]         if (TRUE) {
[08:29:00.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:00.391]         }
[08:29:00.391]         else {
[08:29:00.391]             ...future.result["stdout"] <- base::list(NULL)
[08:29:00.391]         }
[08:29:00.391]         base::close(...future.stdout)
[08:29:00.391]         ...future.stdout <- NULL
[08:29:00.391]     }
[08:29:00.391]     ...future.result$conditions <- ...future.conditions
[08:29:00.391]     ...future.result$finished <- base::Sys.time()
[08:29:00.391]     ...future.result
[08:29:00.391] }
[08:29:00.393] assign_globals() ...
[08:29:00.393] List of 1
[08:29:00.393]  $ kk: int 2
[08:29:00.393]  - attr(*, "where")=List of 1
[08:29:00.393]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:00.393]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:00.393]  - attr(*, "resolved")= logi FALSE
[08:29:00.393]  - attr(*, "total_size")= num 35
[08:29:00.393]  - attr(*, "already-done")= logi TRUE
[08:29:00.396] - copied ‘kk’ to environment
[08:29:00.396] assign_globals() ... done
[08:29:00.396] plan(): Setting new future strategy stack:
[08:29:00.396] List of future strategies:
[08:29:00.396] 1. sequential:
[08:29:00.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.396]    - tweaked: FALSE
[08:29:00.396]    - call: NULL
[08:29:00.396] plan(): nbrOfWorkers() = 1
[08:29:00.499] plan(): Setting new future strategy stack:
[08:29:00.500] List of future strategies:
[08:29:00.500] 1. sequential:
[08:29:00.500]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.500]    - tweaked: FALSE
[08:29:00.500]    - call: plan(strategy)
[08:29:00.500] plan(): nbrOfWorkers() = 1
[08:29:00.500] SequentialFuture started (and completed)
[08:29:00.500] - Launch lazy future ... done
[08:29:00.501] run() for ‘SequentialFuture’ ... done
[08:29:00.501] getGlobalsAndPackages() ...
[08:29:00.501] Searching for globals...
[08:29:00.502] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:00.502] Searching for globals ... DONE
[08:29:00.502] Resolving globals: FALSE
[08:29:00.502] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:00.503] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:00.503] - globals: [1] ‘kk’
[08:29:00.503] 
[08:29:00.503] getGlobalsAndPackages() ... DONE
[08:29:00.503] run() for ‘Future’ ...
[08:29:00.503] - state: ‘created’
[08:29:00.504] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:00.504] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:00.504] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:00.504]   - Field: ‘label’
[08:29:00.504]   - Field: ‘local’
[08:29:00.504]   - Field: ‘owner’
[08:29:00.504]   - Field: ‘envir’
[08:29:00.504]   - Field: ‘packages’
[08:29:00.504]   - Field: ‘gc’
[08:29:00.505]   - Field: ‘conditions’
[08:29:00.505]   - Field: ‘expr’
[08:29:00.505]   - Field: ‘uuid’
[08:29:00.505]   - Field: ‘seed’
[08:29:00.505]   - Field: ‘version’
[08:29:00.505]   - Field: ‘result’
[08:29:00.505]   - Field: ‘asynchronous’
[08:29:00.505]   - Field: ‘calls’
[08:29:00.505]   - Field: ‘globals’
[08:29:00.505]   - Field: ‘stdout’
[08:29:00.505]   - Field: ‘earlySignal’
[08:29:00.505]   - Field: ‘lazy’
[08:29:00.506]   - Field: ‘state’
[08:29:00.506] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:00.506] - Launch lazy future ...
[08:29:00.506] Packages needed by the future expression (n = 0): <none>
[08:29:00.506] Packages needed by future strategies (n = 0): <none>
[08:29:00.506] {
[08:29:00.506]     {
[08:29:00.506]         {
[08:29:00.506]             ...future.startTime <- base::Sys.time()
[08:29:00.506]             {
[08:29:00.506]                 {
[08:29:00.506]                   {
[08:29:00.506]                     base::local({
[08:29:00.506]                       has_future <- base::requireNamespace("future", 
[08:29:00.506]                         quietly = TRUE)
[08:29:00.506]                       if (has_future) {
[08:29:00.506]                         ns <- base::getNamespace("future")
[08:29:00.506]                         version <- ns[[".package"]][["version"]]
[08:29:00.506]                         if (is.null(version)) 
[08:29:00.506]                           version <- utils::packageVersion("future")
[08:29:00.506]                       }
[08:29:00.506]                       else {
[08:29:00.506]                         version <- NULL
[08:29:00.506]                       }
[08:29:00.506]                       if (!has_future || version < "1.8.0") {
[08:29:00.506]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:00.506]                           "", base::R.version$version.string), 
[08:29:00.506]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:00.506]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:00.506]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:00.506]                             "release", "version")], collapse = " "), 
[08:29:00.506]                           hostname = base::Sys.info()[["nodename"]])
[08:29:00.506]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:00.506]                           info)
[08:29:00.506]                         info <- base::paste(info, collapse = "; ")
[08:29:00.506]                         if (!has_future) {
[08:29:00.506]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:00.506]                             info)
[08:29:00.506]                         }
[08:29:00.506]                         else {
[08:29:00.506]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:00.506]                             info, version)
[08:29:00.506]                         }
[08:29:00.506]                         base::stop(msg)
[08:29:00.506]                       }
[08:29:00.506]                     })
[08:29:00.506]                   }
[08:29:00.506]                   ...future.strategy.old <- future::plan("list")
[08:29:00.506]                   options(future.plan = NULL)
[08:29:00.506]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.506]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:00.506]                 }
[08:29:00.506]                 ...future.workdir <- getwd()
[08:29:00.506]             }
[08:29:00.506]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:00.506]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:00.506]         }
[08:29:00.506]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:00.506]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:00.506]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:00.506]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:00.506]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:00.506]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:00.506]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:00.506]             base::names(...future.oldOptions))
[08:29:00.506]     }
[08:29:00.506]     if (FALSE) {
[08:29:00.506]     }
[08:29:00.506]     else {
[08:29:00.506]         if (TRUE) {
[08:29:00.506]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:00.506]                 open = "w")
[08:29:00.506]         }
[08:29:00.506]         else {
[08:29:00.506]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:00.506]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:00.506]         }
[08:29:00.506]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:00.506]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:00.506]             base::sink(type = "output", split = FALSE)
[08:29:00.506]             base::close(...future.stdout)
[08:29:00.506]         }, add = TRUE)
[08:29:00.506]     }
[08:29:00.506]     ...future.frame <- base::sys.nframe()
[08:29:00.506]     ...future.conditions <- base::list()
[08:29:00.506]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:00.506]     if (FALSE) {
[08:29:00.506]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:00.506]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:00.506]     }
[08:29:00.506]     ...future.result <- base::tryCatch({
[08:29:00.506]         base::withCallingHandlers({
[08:29:00.506]             ...future.value <- base::withVisible(base::local({
[08:29:00.506]                 Sys.sleep(0.1)
[08:29:00.506]                 kk
[08:29:00.506]             }))
[08:29:00.506]             future::FutureResult(value = ...future.value$value, 
[08:29:00.506]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.506]                   ...future.rng), globalenv = if (FALSE) 
[08:29:00.506]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:00.506]                     ...future.globalenv.names))
[08:29:00.506]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:00.506]         }, condition = base::local({
[08:29:00.506]             c <- base::c
[08:29:00.506]             inherits <- base::inherits
[08:29:00.506]             invokeRestart <- base::invokeRestart
[08:29:00.506]             length <- base::length
[08:29:00.506]             list <- base::list
[08:29:00.506]             seq.int <- base::seq.int
[08:29:00.506]             signalCondition <- base::signalCondition
[08:29:00.506]             sys.calls <- base::sys.calls
[08:29:00.506]             `[[` <- base::`[[`
[08:29:00.506]             `+` <- base::`+`
[08:29:00.506]             `<<-` <- base::`<<-`
[08:29:00.506]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:00.506]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:00.506]                   3L)]
[08:29:00.506]             }
[08:29:00.506]             function(cond) {
[08:29:00.506]                 is_error <- inherits(cond, "error")
[08:29:00.506]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:00.506]                   NULL)
[08:29:00.506]                 if (is_error) {
[08:29:00.506]                   sessionInformation <- function() {
[08:29:00.506]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:00.506]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:00.506]                       search = base::search(), system = base::Sys.info())
[08:29:00.506]                   }
[08:29:00.506]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.506]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:00.506]                     cond$call), session = sessionInformation(), 
[08:29:00.506]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:00.506]                   signalCondition(cond)
[08:29:00.506]                 }
[08:29:00.506]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:00.506]                 "immediateCondition"))) {
[08:29:00.506]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:00.506]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.506]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:00.506]                   if (TRUE && !signal) {
[08:29:00.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.506]                     {
[08:29:00.506]                       inherits <- base::inherits
[08:29:00.506]                       invokeRestart <- base::invokeRestart
[08:29:00.506]                       is.null <- base::is.null
[08:29:00.506]                       muffled <- FALSE
[08:29:00.506]                       if (inherits(cond, "message")) {
[08:29:00.506]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.506]                         if (muffled) 
[08:29:00.506]                           invokeRestart("muffleMessage")
[08:29:00.506]                       }
[08:29:00.506]                       else if (inherits(cond, "warning")) {
[08:29:00.506]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.506]                         if (muffled) 
[08:29:00.506]                           invokeRestart("muffleWarning")
[08:29:00.506]                       }
[08:29:00.506]                       else if (inherits(cond, "condition")) {
[08:29:00.506]                         if (!is.null(pattern)) {
[08:29:00.506]                           computeRestarts <- base::computeRestarts
[08:29:00.506]                           grepl <- base::grepl
[08:29:00.506]                           restarts <- computeRestarts(cond)
[08:29:00.506]                           for (restart in restarts) {
[08:29:00.506]                             name <- restart$name
[08:29:00.506]                             if (is.null(name)) 
[08:29:00.506]                               next
[08:29:00.506]                             if (!grepl(pattern, name)) 
[08:29:00.506]                               next
[08:29:00.506]                             invokeRestart(restart)
[08:29:00.506]                             muffled <- TRUE
[08:29:00.506]                             break
[08:29:00.506]                           }
[08:29:00.506]                         }
[08:29:00.506]                       }
[08:29:00.506]                       invisible(muffled)
[08:29:00.506]                     }
[08:29:00.506]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.506]                   }
[08:29:00.506]                 }
[08:29:00.506]                 else {
[08:29:00.506]                   if (TRUE) {
[08:29:00.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.506]                     {
[08:29:00.506]                       inherits <- base::inherits
[08:29:00.506]                       invokeRestart <- base::invokeRestart
[08:29:00.506]                       is.null <- base::is.null
[08:29:00.506]                       muffled <- FALSE
[08:29:00.506]                       if (inherits(cond, "message")) {
[08:29:00.506]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.506]                         if (muffled) 
[08:29:00.506]                           invokeRestart("muffleMessage")
[08:29:00.506]                       }
[08:29:00.506]                       else if (inherits(cond, "warning")) {
[08:29:00.506]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.506]                         if (muffled) 
[08:29:00.506]                           invokeRestart("muffleWarning")
[08:29:00.506]                       }
[08:29:00.506]                       else if (inherits(cond, "condition")) {
[08:29:00.506]                         if (!is.null(pattern)) {
[08:29:00.506]                           computeRestarts <- base::computeRestarts
[08:29:00.506]                           grepl <- base::grepl
[08:29:00.506]                           restarts <- computeRestarts(cond)
[08:29:00.506]                           for (restart in restarts) {
[08:29:00.506]                             name <- restart$name
[08:29:00.506]                             if (is.null(name)) 
[08:29:00.506]                               next
[08:29:00.506]                             if (!grepl(pattern, name)) 
[08:29:00.506]                               next
[08:29:00.506]                             invokeRestart(restart)
[08:29:00.506]                             muffled <- TRUE
[08:29:00.506]                             break
[08:29:00.506]                           }
[08:29:00.506]                         }
[08:29:00.506]                       }
[08:29:00.506]                       invisible(muffled)
[08:29:00.506]                     }
[08:29:00.506]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.506]                   }
[08:29:00.506]                 }
[08:29:00.506]             }
[08:29:00.506]         }))
[08:29:00.506]     }, error = function(ex) {
[08:29:00.506]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:00.506]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.506]                 ...future.rng), started = ...future.startTime, 
[08:29:00.506]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:00.506]             version = "1.8"), class = "FutureResult")
[08:29:00.506]     }, finally = {
[08:29:00.506]         if (!identical(...future.workdir, getwd())) 
[08:29:00.506]             setwd(...future.workdir)
[08:29:00.506]         {
[08:29:00.506]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:00.506]                 ...future.oldOptions$nwarnings <- NULL
[08:29:00.506]             }
[08:29:00.506]             base::options(...future.oldOptions)
[08:29:00.506]             if (.Platform$OS.type == "windows") {
[08:29:00.506]                 old_names <- names(...future.oldEnvVars)
[08:29:00.506]                 envs <- base::Sys.getenv()
[08:29:00.506]                 names <- names(envs)
[08:29:00.506]                 common <- intersect(names, old_names)
[08:29:00.506]                 added <- setdiff(names, old_names)
[08:29:00.506]                 removed <- setdiff(old_names, names)
[08:29:00.506]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:00.506]                   envs[common]]
[08:29:00.506]                 NAMES <- toupper(changed)
[08:29:00.506]                 args <- list()
[08:29:00.506]                 for (kk in seq_along(NAMES)) {
[08:29:00.506]                   name <- changed[[kk]]
[08:29:00.506]                   NAME <- NAMES[[kk]]
[08:29:00.506]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.506]                     next
[08:29:00.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.506]                 }
[08:29:00.506]                 NAMES <- toupper(added)
[08:29:00.506]                 for (kk in seq_along(NAMES)) {
[08:29:00.506]                   name <- added[[kk]]
[08:29:00.506]                   NAME <- NAMES[[kk]]
[08:29:00.506]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.506]                     next
[08:29:00.506]                   args[[name]] <- ""
[08:29:00.506]                 }
[08:29:00.506]                 NAMES <- toupper(removed)
[08:29:00.506]                 for (kk in seq_along(NAMES)) {
[08:29:00.506]                   name <- removed[[kk]]
[08:29:00.506]                   NAME <- NAMES[[kk]]
[08:29:00.506]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.506]                     next
[08:29:00.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.506]                 }
[08:29:00.506]                 if (length(args) > 0) 
[08:29:00.506]                   base::do.call(base::Sys.setenv, args = args)
[08:29:00.506]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:00.506]             }
[08:29:00.506]             else {
[08:29:00.506]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:00.506]             }
[08:29:00.506]             {
[08:29:00.506]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:00.506]                   0L) {
[08:29:00.506]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:00.506]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:00.506]                   base::options(opts)
[08:29:00.506]                 }
[08:29:00.506]                 {
[08:29:00.506]                   {
[08:29:00.506]                     NULL
[08:29:00.506]                     RNGkind("Mersenne-Twister")
[08:29:00.506]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:00.506]                       inherits = FALSE)
[08:29:00.506]                   }
[08:29:00.506]                   options(future.plan = NULL)
[08:29:00.506]                   if (is.na(NA_character_)) 
[08:29:00.506]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.506]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:00.506]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:00.506]                     .init = FALSE)
[08:29:00.506]                 }
[08:29:00.506]             }
[08:29:00.506]         }
[08:29:00.506]     })
[08:29:00.506]     if (TRUE) {
[08:29:00.506]         base::sink(type = "output", split = FALSE)
[08:29:00.506]         if (TRUE) {
[08:29:00.506]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:00.506]         }
[08:29:00.506]         else {
[08:29:00.506]             ...future.result["stdout"] <- base::list(NULL)
[08:29:00.506]         }
[08:29:00.506]         base::close(...future.stdout)
[08:29:00.506]         ...future.stdout <- NULL
[08:29:00.506]     }
[08:29:00.506]     ...future.result$conditions <- ...future.conditions
[08:29:00.506]     ...future.result$finished <- base::Sys.time()
[08:29:00.506]     ...future.result
[08:29:00.506] }
[08:29:00.508] assign_globals() ...
[08:29:00.508] List of 1
[08:29:00.508]  $ kk: int 3
[08:29:00.508]  - attr(*, "where")=List of 1
[08:29:00.508]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:00.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:00.508]  - attr(*, "resolved")= logi FALSE
[08:29:00.508]  - attr(*, "total_size")= num 35
[08:29:00.508]  - attr(*, "already-done")= logi TRUE
[08:29:00.511] - copied ‘kk’ to environment
[08:29:00.511] assign_globals() ... done
[08:29:00.511] plan(): Setting new future strategy stack:
[08:29:00.511] List of future strategies:
[08:29:00.511] 1. sequential:
[08:29:00.511]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.511]    - tweaked: FALSE
[08:29:00.511]    - call: NULL
[08:29:00.512] plan(): nbrOfWorkers() = 1
[08:29:00.613] plan(): Setting new future strategy stack:
[08:29:00.613] List of future strategies:
[08:29:00.613] 1. sequential:
[08:29:00.613]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.613]    - tweaked: FALSE
[08:29:00.613]    - call: plan(strategy)
[08:29:00.613] plan(): nbrOfWorkers() = 1
[08:29:00.614] SequentialFuture started (and completed)
[08:29:00.614] - Launch lazy future ... done
[08:29:00.614] run() for ‘SequentialFuture’ ... done
[08:29:00.614] resolve() on list ...
[08:29:00.614]  recursive: 0
[08:29:00.614]  length: 3
[08:29:00.614] 
[08:29:00.614] resolved() for ‘SequentialFuture’ ...
[08:29:00.614] - state: ‘finished’
[08:29:00.614] - run: TRUE
[08:29:00.615] - result: ‘FutureResult’
[08:29:00.615] resolved() for ‘SequentialFuture’ ... done
[08:29:00.615] Future #1
[08:29:00.615]  length: 2 (resolved future 1)
[08:29:00.615] resolved() for ‘SequentialFuture’ ...
[08:29:00.615] - state: ‘finished’
[08:29:00.615] - run: TRUE
[08:29:00.615] - result: ‘FutureResult’
[08:29:00.615] resolved() for ‘SequentialFuture’ ... done
[08:29:00.615] Future #2
[08:29:00.615]  length: 1 (resolved future 2)
[08:29:00.616] resolved() for ‘SequentialFuture’ ...
[08:29:00.616] - state: ‘finished’
[08:29:00.616] - run: TRUE
[08:29:00.616] - result: ‘FutureResult’
[08:29:00.616] resolved() for ‘SequentialFuture’ ... done
[08:29:00.616] Future #3
[08:29:00.616]  length: 0 (resolved future 3)
[08:29:00.616] resolve() on list ... DONE
[08:29:00.616] getGlobalsAndPackages() ...
[08:29:00.616] Searching for globals...
[08:29:00.617] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:00.617] Searching for globals ... DONE
[08:29:00.618] Resolving globals: FALSE
[08:29:00.618] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:00.619] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:00.619] - globals: [1] ‘kk’
[08:29:00.619] 
[08:29:00.619] getGlobalsAndPackages() ... DONE
[08:29:00.620] getGlobalsAndPackages() ...
[08:29:00.620] Searching for globals...
[08:29:00.621] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:00.621] Searching for globals ... DONE
[08:29:00.621] Resolving globals: FALSE
[08:29:00.621] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:00.621] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:00.622] - globals: [1] ‘kk’
[08:29:00.622] 
[08:29:00.622] getGlobalsAndPackages() ... DONE
[08:29:00.622] getGlobalsAndPackages() ...
[08:29:00.622] Searching for globals...
[08:29:00.623] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:00.623] Searching for globals ... DONE
[08:29:00.623] Resolving globals: FALSE
[08:29:00.623] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:00.624] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:00.624] - globals: [1] ‘kk’
[08:29:00.624] 
[08:29:00.624] getGlobalsAndPackages() ... DONE
[08:29:00.624] resolve() on list ...
[08:29:00.624]  recursive: 0
[08:29:00.624]  length: 3
[08:29:00.624] 
[08:29:00.625] run() for ‘Future’ ...
[08:29:00.625] - state: ‘created’
[08:29:00.625] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:00.625] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:00.625] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:00.625]   - Field: ‘label’
[08:29:00.625]   - Field: ‘local’
[08:29:00.625]   - Field: ‘owner’
[08:29:00.626]   - Field: ‘envir’
[08:29:00.626]   - Field: ‘packages’
[08:29:00.626]   - Field: ‘gc’
[08:29:00.626]   - Field: ‘conditions’
[08:29:00.627]   - Field: ‘expr’
[08:29:00.628]   - Field: ‘uuid’
[08:29:00.628]   - Field: ‘seed’
[08:29:00.628]   - Field: ‘version’
[08:29:00.628]   - Field: ‘result’
[08:29:00.628]   - Field: ‘asynchronous’
[08:29:00.628]   - Field: ‘calls’
[08:29:00.628]   - Field: ‘globals’
[08:29:00.628]   - Field: ‘stdout’
[08:29:00.628]   - Field: ‘earlySignal’
[08:29:00.628]   - Field: ‘lazy’
[08:29:00.628]   - Field: ‘state’
[08:29:00.629] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:00.629] - Launch lazy future ...
[08:29:00.629] Packages needed by the future expression (n = 0): <none>
[08:29:00.629] Packages needed by future strategies (n = 0): <none>
[08:29:00.629] {
[08:29:00.629]     {
[08:29:00.629]         {
[08:29:00.629]             ...future.startTime <- base::Sys.time()
[08:29:00.629]             {
[08:29:00.629]                 {
[08:29:00.629]                   {
[08:29:00.629]                     base::local({
[08:29:00.629]                       has_future <- base::requireNamespace("future", 
[08:29:00.629]                         quietly = TRUE)
[08:29:00.629]                       if (has_future) {
[08:29:00.629]                         ns <- base::getNamespace("future")
[08:29:00.629]                         version <- ns[[".package"]][["version"]]
[08:29:00.629]                         if (is.null(version)) 
[08:29:00.629]                           version <- utils::packageVersion("future")
[08:29:00.629]                       }
[08:29:00.629]                       else {
[08:29:00.629]                         version <- NULL
[08:29:00.629]                       }
[08:29:00.629]                       if (!has_future || version < "1.8.0") {
[08:29:00.629]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:00.629]                           "", base::R.version$version.string), 
[08:29:00.629]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:00.629]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:00.629]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:00.629]                             "release", "version")], collapse = " "), 
[08:29:00.629]                           hostname = base::Sys.info()[["nodename"]])
[08:29:00.629]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:00.629]                           info)
[08:29:00.629]                         info <- base::paste(info, collapse = "; ")
[08:29:00.629]                         if (!has_future) {
[08:29:00.629]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:00.629]                             info)
[08:29:00.629]                         }
[08:29:00.629]                         else {
[08:29:00.629]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:00.629]                             info, version)
[08:29:00.629]                         }
[08:29:00.629]                         base::stop(msg)
[08:29:00.629]                       }
[08:29:00.629]                     })
[08:29:00.629]                   }
[08:29:00.629]                   ...future.strategy.old <- future::plan("list")
[08:29:00.629]                   options(future.plan = NULL)
[08:29:00.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:00.629]                 }
[08:29:00.629]                 ...future.workdir <- getwd()
[08:29:00.629]             }
[08:29:00.629]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:00.629]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:00.629]         }
[08:29:00.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:00.629]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:00.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:00.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:00.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:00.629]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:00.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:00.629]             base::names(...future.oldOptions))
[08:29:00.629]     }
[08:29:00.629]     if (FALSE) {
[08:29:00.629]     }
[08:29:00.629]     else {
[08:29:00.629]         if (TRUE) {
[08:29:00.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:00.629]                 open = "w")
[08:29:00.629]         }
[08:29:00.629]         else {
[08:29:00.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:00.629]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:00.629]         }
[08:29:00.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:00.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:00.629]             base::sink(type = "output", split = FALSE)
[08:29:00.629]             base::close(...future.stdout)
[08:29:00.629]         }, add = TRUE)
[08:29:00.629]     }
[08:29:00.629]     ...future.frame <- base::sys.nframe()
[08:29:00.629]     ...future.conditions <- base::list()
[08:29:00.629]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:00.629]     if (FALSE) {
[08:29:00.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:00.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:00.629]     }
[08:29:00.629]     ...future.result <- base::tryCatch({
[08:29:00.629]         base::withCallingHandlers({
[08:29:00.629]             ...future.value <- base::withVisible(base::local({
[08:29:00.629]                 Sys.sleep(0.1)
[08:29:00.629]                 kk
[08:29:00.629]             }))
[08:29:00.629]             future::FutureResult(value = ...future.value$value, 
[08:29:00.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.629]                   ...future.rng), globalenv = if (FALSE) 
[08:29:00.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:00.629]                     ...future.globalenv.names))
[08:29:00.629]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:00.629]         }, condition = base::local({
[08:29:00.629]             c <- base::c
[08:29:00.629]             inherits <- base::inherits
[08:29:00.629]             invokeRestart <- base::invokeRestart
[08:29:00.629]             length <- base::length
[08:29:00.629]             list <- base::list
[08:29:00.629]             seq.int <- base::seq.int
[08:29:00.629]             signalCondition <- base::signalCondition
[08:29:00.629]             sys.calls <- base::sys.calls
[08:29:00.629]             `[[` <- base::`[[`
[08:29:00.629]             `+` <- base::`+`
[08:29:00.629]             `<<-` <- base::`<<-`
[08:29:00.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:00.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:00.629]                   3L)]
[08:29:00.629]             }
[08:29:00.629]             function(cond) {
[08:29:00.629]                 is_error <- inherits(cond, "error")
[08:29:00.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:00.629]                   NULL)
[08:29:00.629]                 if (is_error) {
[08:29:00.629]                   sessionInformation <- function() {
[08:29:00.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:00.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:00.629]                       search = base::search(), system = base::Sys.info())
[08:29:00.629]                   }
[08:29:00.629]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:00.629]                     cond$call), session = sessionInformation(), 
[08:29:00.629]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:00.629]                   signalCondition(cond)
[08:29:00.629]                 }
[08:29:00.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:00.629]                 "immediateCondition"))) {
[08:29:00.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:00.629]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:00.629]                   if (TRUE && !signal) {
[08:29:00.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.629]                     {
[08:29:00.629]                       inherits <- base::inherits
[08:29:00.629]                       invokeRestart <- base::invokeRestart
[08:29:00.629]                       is.null <- base::is.null
[08:29:00.629]                       muffled <- FALSE
[08:29:00.629]                       if (inherits(cond, "message")) {
[08:29:00.629]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.629]                         if (muffled) 
[08:29:00.629]                           invokeRestart("muffleMessage")
[08:29:00.629]                       }
[08:29:00.629]                       else if (inherits(cond, "warning")) {
[08:29:00.629]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.629]                         if (muffled) 
[08:29:00.629]                           invokeRestart("muffleWarning")
[08:29:00.629]                       }
[08:29:00.629]                       else if (inherits(cond, "condition")) {
[08:29:00.629]                         if (!is.null(pattern)) {
[08:29:00.629]                           computeRestarts <- base::computeRestarts
[08:29:00.629]                           grepl <- base::grepl
[08:29:00.629]                           restarts <- computeRestarts(cond)
[08:29:00.629]                           for (restart in restarts) {
[08:29:00.629]                             name <- restart$name
[08:29:00.629]                             if (is.null(name)) 
[08:29:00.629]                               next
[08:29:00.629]                             if (!grepl(pattern, name)) 
[08:29:00.629]                               next
[08:29:00.629]                             invokeRestart(restart)
[08:29:00.629]                             muffled <- TRUE
[08:29:00.629]                             break
[08:29:00.629]                           }
[08:29:00.629]                         }
[08:29:00.629]                       }
[08:29:00.629]                       invisible(muffled)
[08:29:00.629]                     }
[08:29:00.629]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.629]                   }
[08:29:00.629]                 }
[08:29:00.629]                 else {
[08:29:00.629]                   if (TRUE) {
[08:29:00.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.629]                     {
[08:29:00.629]                       inherits <- base::inherits
[08:29:00.629]                       invokeRestart <- base::invokeRestart
[08:29:00.629]                       is.null <- base::is.null
[08:29:00.629]                       muffled <- FALSE
[08:29:00.629]                       if (inherits(cond, "message")) {
[08:29:00.629]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.629]                         if (muffled) 
[08:29:00.629]                           invokeRestart("muffleMessage")
[08:29:00.629]                       }
[08:29:00.629]                       else if (inherits(cond, "warning")) {
[08:29:00.629]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.629]                         if (muffled) 
[08:29:00.629]                           invokeRestart("muffleWarning")
[08:29:00.629]                       }
[08:29:00.629]                       else if (inherits(cond, "condition")) {
[08:29:00.629]                         if (!is.null(pattern)) {
[08:29:00.629]                           computeRestarts <- base::computeRestarts
[08:29:00.629]                           grepl <- base::grepl
[08:29:00.629]                           restarts <- computeRestarts(cond)
[08:29:00.629]                           for (restart in restarts) {
[08:29:00.629]                             name <- restart$name
[08:29:00.629]                             if (is.null(name)) 
[08:29:00.629]                               next
[08:29:00.629]                             if (!grepl(pattern, name)) 
[08:29:00.629]                               next
[08:29:00.629]                             invokeRestart(restart)
[08:29:00.629]                             muffled <- TRUE
[08:29:00.629]                             break
[08:29:00.629]                           }
[08:29:00.629]                         }
[08:29:00.629]                       }
[08:29:00.629]                       invisible(muffled)
[08:29:00.629]                     }
[08:29:00.629]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.629]                   }
[08:29:00.629]                 }
[08:29:00.629]             }
[08:29:00.629]         }))
[08:29:00.629]     }, error = function(ex) {
[08:29:00.629]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:00.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.629]                 ...future.rng), started = ...future.startTime, 
[08:29:00.629]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:00.629]             version = "1.8"), class = "FutureResult")
[08:29:00.629]     }, finally = {
[08:29:00.629]         if (!identical(...future.workdir, getwd())) 
[08:29:00.629]             setwd(...future.workdir)
[08:29:00.629]         {
[08:29:00.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:00.629]                 ...future.oldOptions$nwarnings <- NULL
[08:29:00.629]             }
[08:29:00.629]             base::options(...future.oldOptions)
[08:29:00.629]             if (.Platform$OS.type == "windows") {
[08:29:00.629]                 old_names <- names(...future.oldEnvVars)
[08:29:00.629]                 envs <- base::Sys.getenv()
[08:29:00.629]                 names <- names(envs)
[08:29:00.629]                 common <- intersect(names, old_names)
[08:29:00.629]                 added <- setdiff(names, old_names)
[08:29:00.629]                 removed <- setdiff(old_names, names)
[08:29:00.629]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:00.629]                   envs[common]]
[08:29:00.629]                 NAMES <- toupper(changed)
[08:29:00.629]                 args <- list()
[08:29:00.629]                 for (kk in seq_along(NAMES)) {
[08:29:00.629]                   name <- changed[[kk]]
[08:29:00.629]                   NAME <- NAMES[[kk]]
[08:29:00.629]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.629]                     next
[08:29:00.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.629]                 }
[08:29:00.629]                 NAMES <- toupper(added)
[08:29:00.629]                 for (kk in seq_along(NAMES)) {
[08:29:00.629]                   name <- added[[kk]]
[08:29:00.629]                   NAME <- NAMES[[kk]]
[08:29:00.629]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.629]                     next
[08:29:00.629]                   args[[name]] <- ""
[08:29:00.629]                 }
[08:29:00.629]                 NAMES <- toupper(removed)
[08:29:00.629]                 for (kk in seq_along(NAMES)) {
[08:29:00.629]                   name <- removed[[kk]]
[08:29:00.629]                   NAME <- NAMES[[kk]]
[08:29:00.629]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.629]                     next
[08:29:00.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.629]                 }
[08:29:00.629]                 if (length(args) > 0) 
[08:29:00.629]                   base::do.call(base::Sys.setenv, args = args)
[08:29:00.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:00.629]             }
[08:29:00.629]             else {
[08:29:00.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:00.629]             }
[08:29:00.629]             {
[08:29:00.629]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:00.629]                   0L) {
[08:29:00.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:00.629]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:00.629]                   base::options(opts)
[08:29:00.629]                 }
[08:29:00.629]                 {
[08:29:00.629]                   {
[08:29:00.629]                     NULL
[08:29:00.629]                     RNGkind("Mersenne-Twister")
[08:29:00.629]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:00.629]                       inherits = FALSE)
[08:29:00.629]                   }
[08:29:00.629]                   options(future.plan = NULL)
[08:29:00.629]                   if (is.na(NA_character_)) 
[08:29:00.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:00.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:00.629]                     .init = FALSE)
[08:29:00.629]                 }
[08:29:00.629]             }
[08:29:00.629]         }
[08:29:00.629]     })
[08:29:00.629]     if (TRUE) {
[08:29:00.629]         base::sink(type = "output", split = FALSE)
[08:29:00.629]         if (TRUE) {
[08:29:00.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:00.629]         }
[08:29:00.629]         else {
[08:29:00.629]             ...future.result["stdout"] <- base::list(NULL)
[08:29:00.629]         }
[08:29:00.629]         base::close(...future.stdout)
[08:29:00.629]         ...future.stdout <- NULL
[08:29:00.629]     }
[08:29:00.629]     ...future.result$conditions <- ...future.conditions
[08:29:00.629]     ...future.result$finished <- base::Sys.time()
[08:29:00.629]     ...future.result
[08:29:00.629] }
[08:29:00.631] assign_globals() ...
[08:29:00.631] List of 1
[08:29:00.631]  $ kk: int 1
[08:29:00.631]  - attr(*, "where")=List of 1
[08:29:00.631]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:00.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:00.631]  - attr(*, "resolved")= logi FALSE
[08:29:00.631]  - attr(*, "total_size")= num 35
[08:29:00.631]  - attr(*, "already-done")= logi TRUE
[08:29:00.634] - copied ‘kk’ to environment
[08:29:00.634] assign_globals() ... done
[08:29:00.634] plan(): Setting new future strategy stack:
[08:29:00.634] List of future strategies:
[08:29:00.634] 1. sequential:
[08:29:00.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.634]    - tweaked: FALSE
[08:29:00.634]    - call: NULL
[08:29:00.634] plan(): nbrOfWorkers() = 1
[08:29:00.735] plan(): Setting new future strategy stack:
[08:29:00.736] List of future strategies:
[08:29:00.736] 1. sequential:
[08:29:00.736]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.736]    - tweaked: FALSE
[08:29:00.736]    - call: plan(strategy)
[08:29:00.736] plan(): nbrOfWorkers() = 1
[08:29:00.736] SequentialFuture started (and completed)
[08:29:00.736] - Launch lazy future ... done
[08:29:00.736] run() for ‘SequentialFuture’ ... done
[08:29:00.737] resolved() for ‘SequentialFuture’ ...
[08:29:00.737] - state: ‘finished’
[08:29:00.737] - run: TRUE
[08:29:00.737] - result: ‘FutureResult’
[08:29:00.737] resolved() for ‘SequentialFuture’ ... done
[08:29:00.737] Future #1
[08:29:00.737]  length: 2 (resolved future 1)
[08:29:00.737] run() for ‘Future’ ...
[08:29:00.737] - state: ‘created’
[08:29:00.737] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:00.738] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:00.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:00.738]   - Field: ‘label’
[08:29:00.738]   - Field: ‘local’
[08:29:00.738]   - Field: ‘owner’
[08:29:00.738]   - Field: ‘envir’
[08:29:00.738]   - Field: ‘packages’
[08:29:00.738]   - Field: ‘gc’
[08:29:00.739]   - Field: ‘conditions’
[08:29:00.739]   - Field: ‘expr’
[08:29:00.739]   - Field: ‘uuid’
[08:29:00.739]   - Field: ‘seed’
[08:29:00.739]   - Field: ‘version’
[08:29:00.739]   - Field: ‘result’
[08:29:00.739]   - Field: ‘asynchronous’
[08:29:00.739]   - Field: ‘calls’
[08:29:00.739]   - Field: ‘globals’
[08:29:00.739]   - Field: ‘stdout’
[08:29:00.739]   - Field: ‘earlySignal’
[08:29:00.739]   - Field: ‘lazy’
[08:29:00.740]   - Field: ‘state’
[08:29:00.740] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:00.740] - Launch lazy future ...
[08:29:00.740] Packages needed by the future expression (n = 0): <none>
[08:29:00.740] Packages needed by future strategies (n = 0): <none>
[08:29:00.740] {
[08:29:00.740]     {
[08:29:00.740]         {
[08:29:00.740]             ...future.startTime <- base::Sys.time()
[08:29:00.740]             {
[08:29:00.740]                 {
[08:29:00.740]                   {
[08:29:00.740]                     base::local({
[08:29:00.740]                       has_future <- base::requireNamespace("future", 
[08:29:00.740]                         quietly = TRUE)
[08:29:00.740]                       if (has_future) {
[08:29:00.740]                         ns <- base::getNamespace("future")
[08:29:00.740]                         version <- ns[[".package"]][["version"]]
[08:29:00.740]                         if (is.null(version)) 
[08:29:00.740]                           version <- utils::packageVersion("future")
[08:29:00.740]                       }
[08:29:00.740]                       else {
[08:29:00.740]                         version <- NULL
[08:29:00.740]                       }
[08:29:00.740]                       if (!has_future || version < "1.8.0") {
[08:29:00.740]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:00.740]                           "", base::R.version$version.string), 
[08:29:00.740]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:00.740]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:00.740]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:00.740]                             "release", "version")], collapse = " "), 
[08:29:00.740]                           hostname = base::Sys.info()[["nodename"]])
[08:29:00.740]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:00.740]                           info)
[08:29:00.740]                         info <- base::paste(info, collapse = "; ")
[08:29:00.740]                         if (!has_future) {
[08:29:00.740]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:00.740]                             info)
[08:29:00.740]                         }
[08:29:00.740]                         else {
[08:29:00.740]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:00.740]                             info, version)
[08:29:00.740]                         }
[08:29:00.740]                         base::stop(msg)
[08:29:00.740]                       }
[08:29:00.740]                     })
[08:29:00.740]                   }
[08:29:00.740]                   ...future.strategy.old <- future::plan("list")
[08:29:00.740]                   options(future.plan = NULL)
[08:29:00.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:00.740]                 }
[08:29:00.740]                 ...future.workdir <- getwd()
[08:29:00.740]             }
[08:29:00.740]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:00.740]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:00.740]         }
[08:29:00.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:00.740]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:00.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:00.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:00.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:00.740]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:00.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:00.740]             base::names(...future.oldOptions))
[08:29:00.740]     }
[08:29:00.740]     if (FALSE) {
[08:29:00.740]     }
[08:29:00.740]     else {
[08:29:00.740]         if (TRUE) {
[08:29:00.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:00.740]                 open = "w")
[08:29:00.740]         }
[08:29:00.740]         else {
[08:29:00.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:00.740]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:00.740]         }
[08:29:00.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:00.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:00.740]             base::sink(type = "output", split = FALSE)
[08:29:00.740]             base::close(...future.stdout)
[08:29:00.740]         }, add = TRUE)
[08:29:00.740]     }
[08:29:00.740]     ...future.frame <- base::sys.nframe()
[08:29:00.740]     ...future.conditions <- base::list()
[08:29:00.740]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:00.740]     if (FALSE) {
[08:29:00.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:00.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:00.740]     }
[08:29:00.740]     ...future.result <- base::tryCatch({
[08:29:00.740]         base::withCallingHandlers({
[08:29:00.740]             ...future.value <- base::withVisible(base::local({
[08:29:00.740]                 Sys.sleep(0.1)
[08:29:00.740]                 kk
[08:29:00.740]             }))
[08:29:00.740]             future::FutureResult(value = ...future.value$value, 
[08:29:00.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.740]                   ...future.rng), globalenv = if (FALSE) 
[08:29:00.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:00.740]                     ...future.globalenv.names))
[08:29:00.740]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:00.740]         }, condition = base::local({
[08:29:00.740]             c <- base::c
[08:29:00.740]             inherits <- base::inherits
[08:29:00.740]             invokeRestart <- base::invokeRestart
[08:29:00.740]             length <- base::length
[08:29:00.740]             list <- base::list
[08:29:00.740]             seq.int <- base::seq.int
[08:29:00.740]             signalCondition <- base::signalCondition
[08:29:00.740]             sys.calls <- base::sys.calls
[08:29:00.740]             `[[` <- base::`[[`
[08:29:00.740]             `+` <- base::`+`
[08:29:00.740]             `<<-` <- base::`<<-`
[08:29:00.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:00.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:00.740]                   3L)]
[08:29:00.740]             }
[08:29:00.740]             function(cond) {
[08:29:00.740]                 is_error <- inherits(cond, "error")
[08:29:00.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:00.740]                   NULL)
[08:29:00.740]                 if (is_error) {
[08:29:00.740]                   sessionInformation <- function() {
[08:29:00.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:00.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:00.740]                       search = base::search(), system = base::Sys.info())
[08:29:00.740]                   }
[08:29:00.740]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:00.740]                     cond$call), session = sessionInformation(), 
[08:29:00.740]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:00.740]                   signalCondition(cond)
[08:29:00.740]                 }
[08:29:00.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:00.740]                 "immediateCondition"))) {
[08:29:00.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:00.740]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:00.740]                   if (TRUE && !signal) {
[08:29:00.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.740]                     {
[08:29:00.740]                       inherits <- base::inherits
[08:29:00.740]                       invokeRestart <- base::invokeRestart
[08:29:00.740]                       is.null <- base::is.null
[08:29:00.740]                       muffled <- FALSE
[08:29:00.740]                       if (inherits(cond, "message")) {
[08:29:00.740]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.740]                         if (muffled) 
[08:29:00.740]                           invokeRestart("muffleMessage")
[08:29:00.740]                       }
[08:29:00.740]                       else if (inherits(cond, "warning")) {
[08:29:00.740]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.740]                         if (muffled) 
[08:29:00.740]                           invokeRestart("muffleWarning")
[08:29:00.740]                       }
[08:29:00.740]                       else if (inherits(cond, "condition")) {
[08:29:00.740]                         if (!is.null(pattern)) {
[08:29:00.740]                           computeRestarts <- base::computeRestarts
[08:29:00.740]                           grepl <- base::grepl
[08:29:00.740]                           restarts <- computeRestarts(cond)
[08:29:00.740]                           for (restart in restarts) {
[08:29:00.740]                             name <- restart$name
[08:29:00.740]                             if (is.null(name)) 
[08:29:00.740]                               next
[08:29:00.740]                             if (!grepl(pattern, name)) 
[08:29:00.740]                               next
[08:29:00.740]                             invokeRestart(restart)
[08:29:00.740]                             muffled <- TRUE
[08:29:00.740]                             break
[08:29:00.740]                           }
[08:29:00.740]                         }
[08:29:00.740]                       }
[08:29:00.740]                       invisible(muffled)
[08:29:00.740]                     }
[08:29:00.740]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.740]                   }
[08:29:00.740]                 }
[08:29:00.740]                 else {
[08:29:00.740]                   if (TRUE) {
[08:29:00.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.740]                     {
[08:29:00.740]                       inherits <- base::inherits
[08:29:00.740]                       invokeRestart <- base::invokeRestart
[08:29:00.740]                       is.null <- base::is.null
[08:29:00.740]                       muffled <- FALSE
[08:29:00.740]                       if (inherits(cond, "message")) {
[08:29:00.740]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.740]                         if (muffled) 
[08:29:00.740]                           invokeRestart("muffleMessage")
[08:29:00.740]                       }
[08:29:00.740]                       else if (inherits(cond, "warning")) {
[08:29:00.740]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.740]                         if (muffled) 
[08:29:00.740]                           invokeRestart("muffleWarning")
[08:29:00.740]                       }
[08:29:00.740]                       else if (inherits(cond, "condition")) {
[08:29:00.740]                         if (!is.null(pattern)) {
[08:29:00.740]                           computeRestarts <- base::computeRestarts
[08:29:00.740]                           grepl <- base::grepl
[08:29:00.740]                           restarts <- computeRestarts(cond)
[08:29:00.740]                           for (restart in restarts) {
[08:29:00.740]                             name <- restart$name
[08:29:00.740]                             if (is.null(name)) 
[08:29:00.740]                               next
[08:29:00.740]                             if (!grepl(pattern, name)) 
[08:29:00.740]                               next
[08:29:00.740]                             invokeRestart(restart)
[08:29:00.740]                             muffled <- TRUE
[08:29:00.740]                             break
[08:29:00.740]                           }
[08:29:00.740]                         }
[08:29:00.740]                       }
[08:29:00.740]                       invisible(muffled)
[08:29:00.740]                     }
[08:29:00.740]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.740]                   }
[08:29:00.740]                 }
[08:29:00.740]             }
[08:29:00.740]         }))
[08:29:00.740]     }, error = function(ex) {
[08:29:00.740]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:00.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.740]                 ...future.rng), started = ...future.startTime, 
[08:29:00.740]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:00.740]             version = "1.8"), class = "FutureResult")
[08:29:00.740]     }, finally = {
[08:29:00.740]         if (!identical(...future.workdir, getwd())) 
[08:29:00.740]             setwd(...future.workdir)
[08:29:00.740]         {
[08:29:00.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:00.740]                 ...future.oldOptions$nwarnings <- NULL
[08:29:00.740]             }
[08:29:00.740]             base::options(...future.oldOptions)
[08:29:00.740]             if (.Platform$OS.type == "windows") {
[08:29:00.740]                 old_names <- names(...future.oldEnvVars)
[08:29:00.740]                 envs <- base::Sys.getenv()
[08:29:00.740]                 names <- names(envs)
[08:29:00.740]                 common <- intersect(names, old_names)
[08:29:00.740]                 added <- setdiff(names, old_names)
[08:29:00.740]                 removed <- setdiff(old_names, names)
[08:29:00.740]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:00.740]                   envs[common]]
[08:29:00.740]                 NAMES <- toupper(changed)
[08:29:00.740]                 args <- list()
[08:29:00.740]                 for (kk in seq_along(NAMES)) {
[08:29:00.740]                   name <- changed[[kk]]
[08:29:00.740]                   NAME <- NAMES[[kk]]
[08:29:00.740]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.740]                     next
[08:29:00.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.740]                 }
[08:29:00.740]                 NAMES <- toupper(added)
[08:29:00.740]                 for (kk in seq_along(NAMES)) {
[08:29:00.740]                   name <- added[[kk]]
[08:29:00.740]                   NAME <- NAMES[[kk]]
[08:29:00.740]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.740]                     next
[08:29:00.740]                   args[[name]] <- ""
[08:29:00.740]                 }
[08:29:00.740]                 NAMES <- toupper(removed)
[08:29:00.740]                 for (kk in seq_along(NAMES)) {
[08:29:00.740]                   name <- removed[[kk]]
[08:29:00.740]                   NAME <- NAMES[[kk]]
[08:29:00.740]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.740]                     next
[08:29:00.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.740]                 }
[08:29:00.740]                 if (length(args) > 0) 
[08:29:00.740]                   base::do.call(base::Sys.setenv, args = args)
[08:29:00.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:00.740]             }
[08:29:00.740]             else {
[08:29:00.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:00.740]             }
[08:29:00.740]             {
[08:29:00.740]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:00.740]                   0L) {
[08:29:00.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:00.740]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:00.740]                   base::options(opts)
[08:29:00.740]                 }
[08:29:00.740]                 {
[08:29:00.740]                   {
[08:29:00.740]                     NULL
[08:29:00.740]                     RNGkind("Mersenne-Twister")
[08:29:00.740]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:00.740]                       inherits = FALSE)
[08:29:00.740]                   }
[08:29:00.740]                   options(future.plan = NULL)
[08:29:00.740]                   if (is.na(NA_character_)) 
[08:29:00.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:00.740]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:00.740]                     .init = FALSE)
[08:29:00.740]                 }
[08:29:00.740]             }
[08:29:00.740]         }
[08:29:00.740]     })
[08:29:00.740]     if (TRUE) {
[08:29:00.740]         base::sink(type = "output", split = FALSE)
[08:29:00.740]         if (TRUE) {
[08:29:00.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:00.740]         }
[08:29:00.740]         else {
[08:29:00.740]             ...future.result["stdout"] <- base::list(NULL)
[08:29:00.740]         }
[08:29:00.740]         base::close(...future.stdout)
[08:29:00.740]         ...future.stdout <- NULL
[08:29:00.740]     }
[08:29:00.740]     ...future.result$conditions <- ...future.conditions
[08:29:00.740]     ...future.result$finished <- base::Sys.time()
[08:29:00.740]     ...future.result
[08:29:00.740] }
[08:29:00.742] assign_globals() ...
[08:29:00.742] List of 1
[08:29:00.742]  $ kk: int 2
[08:29:00.742]  - attr(*, "where")=List of 1
[08:29:00.742]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:00.742]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:00.742]  - attr(*, "resolved")= logi FALSE
[08:29:00.742]  - attr(*, "total_size")= num 35
[08:29:00.742]  - attr(*, "already-done")= logi TRUE
[08:29:00.745] - copied ‘kk’ to environment
[08:29:00.745] assign_globals() ... done
[08:29:00.745] plan(): Setting new future strategy stack:
[08:29:00.745] List of future strategies:
[08:29:00.745] 1. sequential:
[08:29:00.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.745]    - tweaked: FALSE
[08:29:00.745]    - call: NULL
[08:29:00.745] plan(): nbrOfWorkers() = 1
[08:29:00.847] plan(): Setting new future strategy stack:
[08:29:00.847] List of future strategies:
[08:29:00.847] 1. sequential:
[08:29:00.847]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.847]    - tweaked: FALSE
[08:29:00.847]    - call: plan(strategy)
[08:29:00.847] plan(): nbrOfWorkers() = 1
[08:29:00.847] SequentialFuture started (and completed)
[08:29:00.847] - Launch lazy future ... done
[08:29:00.848] run() for ‘SequentialFuture’ ... done
[08:29:00.848] resolved() for ‘SequentialFuture’ ...
[08:29:00.848] - state: ‘finished’
[08:29:00.848] - run: TRUE
[08:29:00.848] - result: ‘FutureResult’
[08:29:00.848] resolved() for ‘SequentialFuture’ ... done
[08:29:00.848] Future #2
[08:29:00.848]  length: 1 (resolved future 2)
[08:29:00.848] run() for ‘Future’ ...
[08:29:00.848] - state: ‘created’
[08:29:00.849] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:00.849] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:00.849] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:00.849]   - Field: ‘label’
[08:29:00.849]   - Field: ‘local’
[08:29:00.849]   - Field: ‘owner’
[08:29:00.849]   - Field: ‘envir’
[08:29:00.849]   - Field: ‘packages’
[08:29:00.849]   - Field: ‘gc’
[08:29:00.850]   - Field: ‘conditions’
[08:29:00.850]   - Field: ‘expr’
[08:29:00.850]   - Field: ‘uuid’
[08:29:00.850]   - Field: ‘seed’
[08:29:00.850]   - Field: ‘version’
[08:29:00.850]   - Field: ‘result’
[08:29:00.850]   - Field: ‘asynchronous’
[08:29:00.850]   - Field: ‘calls’
[08:29:00.850]   - Field: ‘globals’
[08:29:00.850]   - Field: ‘stdout’
[08:29:00.850]   - Field: ‘earlySignal’
[08:29:00.850]   - Field: ‘lazy’
[08:29:00.851]   - Field: ‘state’
[08:29:00.851] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:00.851] - Launch lazy future ...
[08:29:00.851] Packages needed by the future expression (n = 0): <none>
[08:29:00.851] Packages needed by future strategies (n = 0): <none>
[08:29:00.851] {
[08:29:00.851]     {
[08:29:00.851]         {
[08:29:00.851]             ...future.startTime <- base::Sys.time()
[08:29:00.851]             {
[08:29:00.851]                 {
[08:29:00.851]                   {
[08:29:00.851]                     base::local({
[08:29:00.851]                       has_future <- base::requireNamespace("future", 
[08:29:00.851]                         quietly = TRUE)
[08:29:00.851]                       if (has_future) {
[08:29:00.851]                         ns <- base::getNamespace("future")
[08:29:00.851]                         version <- ns[[".package"]][["version"]]
[08:29:00.851]                         if (is.null(version)) 
[08:29:00.851]                           version <- utils::packageVersion("future")
[08:29:00.851]                       }
[08:29:00.851]                       else {
[08:29:00.851]                         version <- NULL
[08:29:00.851]                       }
[08:29:00.851]                       if (!has_future || version < "1.8.0") {
[08:29:00.851]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:00.851]                           "", base::R.version$version.string), 
[08:29:00.851]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:00.851]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:00.851]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:00.851]                             "release", "version")], collapse = " "), 
[08:29:00.851]                           hostname = base::Sys.info()[["nodename"]])
[08:29:00.851]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:00.851]                           info)
[08:29:00.851]                         info <- base::paste(info, collapse = "; ")
[08:29:00.851]                         if (!has_future) {
[08:29:00.851]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:00.851]                             info)
[08:29:00.851]                         }
[08:29:00.851]                         else {
[08:29:00.851]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:00.851]                             info, version)
[08:29:00.851]                         }
[08:29:00.851]                         base::stop(msg)
[08:29:00.851]                       }
[08:29:00.851]                     })
[08:29:00.851]                   }
[08:29:00.851]                   ...future.strategy.old <- future::plan("list")
[08:29:00.851]                   options(future.plan = NULL)
[08:29:00.851]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.851]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:00.851]                 }
[08:29:00.851]                 ...future.workdir <- getwd()
[08:29:00.851]             }
[08:29:00.851]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:00.851]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:00.851]         }
[08:29:00.851]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:00.851]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:00.851]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:00.851]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:00.851]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:00.851]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:00.851]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:00.851]             base::names(...future.oldOptions))
[08:29:00.851]     }
[08:29:00.851]     if (FALSE) {
[08:29:00.851]     }
[08:29:00.851]     else {
[08:29:00.851]         if (TRUE) {
[08:29:00.851]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:00.851]                 open = "w")
[08:29:00.851]         }
[08:29:00.851]         else {
[08:29:00.851]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:00.851]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:00.851]         }
[08:29:00.851]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:00.851]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:00.851]             base::sink(type = "output", split = FALSE)
[08:29:00.851]             base::close(...future.stdout)
[08:29:00.851]         }, add = TRUE)
[08:29:00.851]     }
[08:29:00.851]     ...future.frame <- base::sys.nframe()
[08:29:00.851]     ...future.conditions <- base::list()
[08:29:00.851]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:00.851]     if (FALSE) {
[08:29:00.851]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:00.851]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:00.851]     }
[08:29:00.851]     ...future.result <- base::tryCatch({
[08:29:00.851]         base::withCallingHandlers({
[08:29:00.851]             ...future.value <- base::withVisible(base::local({
[08:29:00.851]                 Sys.sleep(0.1)
[08:29:00.851]                 kk
[08:29:00.851]             }))
[08:29:00.851]             future::FutureResult(value = ...future.value$value, 
[08:29:00.851]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.851]                   ...future.rng), globalenv = if (FALSE) 
[08:29:00.851]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:00.851]                     ...future.globalenv.names))
[08:29:00.851]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:00.851]         }, condition = base::local({
[08:29:00.851]             c <- base::c
[08:29:00.851]             inherits <- base::inherits
[08:29:00.851]             invokeRestart <- base::invokeRestart
[08:29:00.851]             length <- base::length
[08:29:00.851]             list <- base::list
[08:29:00.851]             seq.int <- base::seq.int
[08:29:00.851]             signalCondition <- base::signalCondition
[08:29:00.851]             sys.calls <- base::sys.calls
[08:29:00.851]             `[[` <- base::`[[`
[08:29:00.851]             `+` <- base::`+`
[08:29:00.851]             `<<-` <- base::`<<-`
[08:29:00.851]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:00.851]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:00.851]                   3L)]
[08:29:00.851]             }
[08:29:00.851]             function(cond) {
[08:29:00.851]                 is_error <- inherits(cond, "error")
[08:29:00.851]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:00.851]                   NULL)
[08:29:00.851]                 if (is_error) {
[08:29:00.851]                   sessionInformation <- function() {
[08:29:00.851]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:00.851]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:00.851]                       search = base::search(), system = base::Sys.info())
[08:29:00.851]                   }
[08:29:00.851]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.851]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:00.851]                     cond$call), session = sessionInformation(), 
[08:29:00.851]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:00.851]                   signalCondition(cond)
[08:29:00.851]                 }
[08:29:00.851]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:00.851]                 "immediateCondition"))) {
[08:29:00.851]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:00.851]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.851]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:00.851]                   if (TRUE && !signal) {
[08:29:00.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.851]                     {
[08:29:00.851]                       inherits <- base::inherits
[08:29:00.851]                       invokeRestart <- base::invokeRestart
[08:29:00.851]                       is.null <- base::is.null
[08:29:00.851]                       muffled <- FALSE
[08:29:00.851]                       if (inherits(cond, "message")) {
[08:29:00.851]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.851]                         if (muffled) 
[08:29:00.851]                           invokeRestart("muffleMessage")
[08:29:00.851]                       }
[08:29:00.851]                       else if (inherits(cond, "warning")) {
[08:29:00.851]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.851]                         if (muffled) 
[08:29:00.851]                           invokeRestart("muffleWarning")
[08:29:00.851]                       }
[08:29:00.851]                       else if (inherits(cond, "condition")) {
[08:29:00.851]                         if (!is.null(pattern)) {
[08:29:00.851]                           computeRestarts <- base::computeRestarts
[08:29:00.851]                           grepl <- base::grepl
[08:29:00.851]                           restarts <- computeRestarts(cond)
[08:29:00.851]                           for (restart in restarts) {
[08:29:00.851]                             name <- restart$name
[08:29:00.851]                             if (is.null(name)) 
[08:29:00.851]                               next
[08:29:00.851]                             if (!grepl(pattern, name)) 
[08:29:00.851]                               next
[08:29:00.851]                             invokeRestart(restart)
[08:29:00.851]                             muffled <- TRUE
[08:29:00.851]                             break
[08:29:00.851]                           }
[08:29:00.851]                         }
[08:29:00.851]                       }
[08:29:00.851]                       invisible(muffled)
[08:29:00.851]                     }
[08:29:00.851]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.851]                   }
[08:29:00.851]                 }
[08:29:00.851]                 else {
[08:29:00.851]                   if (TRUE) {
[08:29:00.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.851]                     {
[08:29:00.851]                       inherits <- base::inherits
[08:29:00.851]                       invokeRestart <- base::invokeRestart
[08:29:00.851]                       is.null <- base::is.null
[08:29:00.851]                       muffled <- FALSE
[08:29:00.851]                       if (inherits(cond, "message")) {
[08:29:00.851]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.851]                         if (muffled) 
[08:29:00.851]                           invokeRestart("muffleMessage")
[08:29:00.851]                       }
[08:29:00.851]                       else if (inherits(cond, "warning")) {
[08:29:00.851]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.851]                         if (muffled) 
[08:29:00.851]                           invokeRestart("muffleWarning")
[08:29:00.851]                       }
[08:29:00.851]                       else if (inherits(cond, "condition")) {
[08:29:00.851]                         if (!is.null(pattern)) {
[08:29:00.851]                           computeRestarts <- base::computeRestarts
[08:29:00.851]                           grepl <- base::grepl
[08:29:00.851]                           restarts <- computeRestarts(cond)
[08:29:00.851]                           for (restart in restarts) {
[08:29:00.851]                             name <- restart$name
[08:29:00.851]                             if (is.null(name)) 
[08:29:00.851]                               next
[08:29:00.851]                             if (!grepl(pattern, name)) 
[08:29:00.851]                               next
[08:29:00.851]                             invokeRestart(restart)
[08:29:00.851]                             muffled <- TRUE
[08:29:00.851]                             break
[08:29:00.851]                           }
[08:29:00.851]                         }
[08:29:00.851]                       }
[08:29:00.851]                       invisible(muffled)
[08:29:00.851]                     }
[08:29:00.851]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.851]                   }
[08:29:00.851]                 }
[08:29:00.851]             }
[08:29:00.851]         }))
[08:29:00.851]     }, error = function(ex) {
[08:29:00.851]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:00.851]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.851]                 ...future.rng), started = ...future.startTime, 
[08:29:00.851]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:00.851]             version = "1.8"), class = "FutureResult")
[08:29:00.851]     }, finally = {
[08:29:00.851]         if (!identical(...future.workdir, getwd())) 
[08:29:00.851]             setwd(...future.workdir)
[08:29:00.851]         {
[08:29:00.851]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:00.851]                 ...future.oldOptions$nwarnings <- NULL
[08:29:00.851]             }
[08:29:00.851]             base::options(...future.oldOptions)
[08:29:00.851]             if (.Platform$OS.type == "windows") {
[08:29:00.851]                 old_names <- names(...future.oldEnvVars)
[08:29:00.851]                 envs <- base::Sys.getenv()
[08:29:00.851]                 names <- names(envs)
[08:29:00.851]                 common <- intersect(names, old_names)
[08:29:00.851]                 added <- setdiff(names, old_names)
[08:29:00.851]                 removed <- setdiff(old_names, names)
[08:29:00.851]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:00.851]                   envs[common]]
[08:29:00.851]                 NAMES <- toupper(changed)
[08:29:00.851]                 args <- list()
[08:29:00.851]                 for (kk in seq_along(NAMES)) {
[08:29:00.851]                   name <- changed[[kk]]
[08:29:00.851]                   NAME <- NAMES[[kk]]
[08:29:00.851]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.851]                     next
[08:29:00.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.851]                 }
[08:29:00.851]                 NAMES <- toupper(added)
[08:29:00.851]                 for (kk in seq_along(NAMES)) {
[08:29:00.851]                   name <- added[[kk]]
[08:29:00.851]                   NAME <- NAMES[[kk]]
[08:29:00.851]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.851]                     next
[08:29:00.851]                   args[[name]] <- ""
[08:29:00.851]                 }
[08:29:00.851]                 NAMES <- toupper(removed)
[08:29:00.851]                 for (kk in seq_along(NAMES)) {
[08:29:00.851]                   name <- removed[[kk]]
[08:29:00.851]                   NAME <- NAMES[[kk]]
[08:29:00.851]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.851]                     next
[08:29:00.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.851]                 }
[08:29:00.851]                 if (length(args) > 0) 
[08:29:00.851]                   base::do.call(base::Sys.setenv, args = args)
[08:29:00.851]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:00.851]             }
[08:29:00.851]             else {
[08:29:00.851]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:00.851]             }
[08:29:00.851]             {
[08:29:00.851]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:00.851]                   0L) {
[08:29:00.851]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:00.851]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:00.851]                   base::options(opts)
[08:29:00.851]                 }
[08:29:00.851]                 {
[08:29:00.851]                   {
[08:29:00.851]                     NULL
[08:29:00.851]                     RNGkind("Mersenne-Twister")
[08:29:00.851]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:00.851]                       inherits = FALSE)
[08:29:00.851]                   }
[08:29:00.851]                   options(future.plan = NULL)
[08:29:00.851]                   if (is.na(NA_character_)) 
[08:29:00.851]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.851]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:00.851]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:00.851]                     .init = FALSE)
[08:29:00.851]                 }
[08:29:00.851]             }
[08:29:00.851]         }
[08:29:00.851]     })
[08:29:00.851]     if (TRUE) {
[08:29:00.851]         base::sink(type = "output", split = FALSE)
[08:29:00.851]         if (TRUE) {
[08:29:00.851]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:00.851]         }
[08:29:00.851]         else {
[08:29:00.851]             ...future.result["stdout"] <- base::list(NULL)
[08:29:00.851]         }
[08:29:00.851]         base::close(...future.stdout)
[08:29:00.851]         ...future.stdout <- NULL
[08:29:00.851]     }
[08:29:00.851]     ...future.result$conditions <- ...future.conditions
[08:29:00.851]     ...future.result$finished <- base::Sys.time()
[08:29:00.851]     ...future.result
[08:29:00.851] }
[08:29:00.853] assign_globals() ...
[08:29:00.853] List of 1
[08:29:00.853]  $ kk: int 3
[08:29:00.853]  - attr(*, "where")=List of 1
[08:29:00.853]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:00.853]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:00.853]  - attr(*, "resolved")= logi FALSE
[08:29:00.853]  - attr(*, "total_size")= num 35
[08:29:00.853]  - attr(*, "already-done")= logi TRUE
[08:29:00.856] - copied ‘kk’ to environment
[08:29:00.856] assign_globals() ... done
[08:29:00.856] plan(): Setting new future strategy stack:
[08:29:00.856] List of future strategies:
[08:29:00.856] 1. sequential:
[08:29:00.856]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.856]    - tweaked: FALSE
[08:29:00.856]    - call: NULL
[08:29:00.858] plan(): nbrOfWorkers() = 1
[08:29:00.959] plan(): Setting new future strategy stack:
[08:29:00.959] List of future strategies:
[08:29:00.959] 1. sequential:
[08:29:00.959]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.959]    - tweaked: FALSE
[08:29:00.959]    - call: plan(strategy)
[08:29:00.960] plan(): nbrOfWorkers() = 1
[08:29:00.960] SequentialFuture started (and completed)
[08:29:00.960] - Launch lazy future ... done
[08:29:00.960] run() for ‘SequentialFuture’ ... done
[08:29:00.961] resolved() for ‘SequentialFuture’ ...
[08:29:00.961] - state: ‘finished’
[08:29:00.961] - run: TRUE
[08:29:00.961] - result: ‘FutureResult’
[08:29:00.961] resolved() for ‘SequentialFuture’ ... done
[08:29:00.961] Future #3
[08:29:00.961]  length: 0 (resolved future 3)
[08:29:00.961] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[08:29:00.962] resolve() on environment ...
[08:29:00.962]  recursive: 0
[08:29:00.963]  elements: [2] ‘a’, ‘b’
[08:29:00.963]  length: 1 (resolved future 1)
[08:29:00.963]  length: 0 (resolved future 2)
[08:29:00.963] resolve() on environment ... DONE
[08:29:00.964] getGlobalsAndPackages() ...
[08:29:00.964] Searching for globals...
[08:29:00.964] 
[08:29:00.964] Searching for globals ... DONE
[08:29:00.964] - globals: [0] <none>
[08:29:00.964] getGlobalsAndPackages() ... DONE
[08:29:00.965] run() for ‘Future’ ...
[08:29:00.965] - state: ‘created’
[08:29:00.965] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:00.965] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:00.965] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:00.965]   - Field: ‘label’
[08:29:00.965]   - Field: ‘local’
[08:29:00.966]   - Field: ‘owner’
[08:29:00.966]   - Field: ‘envir’
[08:29:00.966]   - Field: ‘packages’
[08:29:00.966]   - Field: ‘gc’
[08:29:00.966]   - Field: ‘conditions’
[08:29:00.966]   - Field: ‘expr’
[08:29:00.966]   - Field: ‘uuid’
[08:29:00.966]   - Field: ‘seed’
[08:29:00.966]   - Field: ‘version’
[08:29:00.966]   - Field: ‘result’
[08:29:00.966]   - Field: ‘asynchronous’
[08:29:00.966]   - Field: ‘calls’
[08:29:00.967]   - Field: ‘globals’
[08:29:00.967]   - Field: ‘stdout’
[08:29:00.967]   - Field: ‘earlySignal’
[08:29:00.967]   - Field: ‘lazy’
[08:29:00.967]   - Field: ‘state’
[08:29:00.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:00.967] - Launch lazy future ...
[08:29:00.967] Packages needed by the future expression (n = 0): <none>
[08:29:00.967] Packages needed by future strategies (n = 0): <none>
[08:29:00.968] {
[08:29:00.968]     {
[08:29:00.968]         {
[08:29:00.968]             ...future.startTime <- base::Sys.time()
[08:29:00.968]             {
[08:29:00.968]                 {
[08:29:00.968]                   {
[08:29:00.968]                     base::local({
[08:29:00.968]                       has_future <- base::requireNamespace("future", 
[08:29:00.968]                         quietly = TRUE)
[08:29:00.968]                       if (has_future) {
[08:29:00.968]                         ns <- base::getNamespace("future")
[08:29:00.968]                         version <- ns[[".package"]][["version"]]
[08:29:00.968]                         if (is.null(version)) 
[08:29:00.968]                           version <- utils::packageVersion("future")
[08:29:00.968]                       }
[08:29:00.968]                       else {
[08:29:00.968]                         version <- NULL
[08:29:00.968]                       }
[08:29:00.968]                       if (!has_future || version < "1.8.0") {
[08:29:00.968]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:00.968]                           "", base::R.version$version.string), 
[08:29:00.968]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:00.968]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:00.968]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:00.968]                             "release", "version")], collapse = " "), 
[08:29:00.968]                           hostname = base::Sys.info()[["nodename"]])
[08:29:00.968]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:00.968]                           info)
[08:29:00.968]                         info <- base::paste(info, collapse = "; ")
[08:29:00.968]                         if (!has_future) {
[08:29:00.968]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:00.968]                             info)
[08:29:00.968]                         }
[08:29:00.968]                         else {
[08:29:00.968]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:00.968]                             info, version)
[08:29:00.968]                         }
[08:29:00.968]                         base::stop(msg)
[08:29:00.968]                       }
[08:29:00.968]                     })
[08:29:00.968]                   }
[08:29:00.968]                   ...future.strategy.old <- future::plan("list")
[08:29:00.968]                   options(future.plan = NULL)
[08:29:00.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:00.968]                 }
[08:29:00.968]                 ...future.workdir <- getwd()
[08:29:00.968]             }
[08:29:00.968]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:00.968]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:00.968]         }
[08:29:00.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:00.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:00.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:00.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:00.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:00.968]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:00.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:00.968]             base::names(...future.oldOptions))
[08:29:00.968]     }
[08:29:00.968]     if (FALSE) {
[08:29:00.968]     }
[08:29:00.968]     else {
[08:29:00.968]         if (TRUE) {
[08:29:00.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:00.968]                 open = "w")
[08:29:00.968]         }
[08:29:00.968]         else {
[08:29:00.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:00.968]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:00.968]         }
[08:29:00.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:00.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:00.968]             base::sink(type = "output", split = FALSE)
[08:29:00.968]             base::close(...future.stdout)
[08:29:00.968]         }, add = TRUE)
[08:29:00.968]     }
[08:29:00.968]     ...future.frame <- base::sys.nframe()
[08:29:00.968]     ...future.conditions <- base::list()
[08:29:00.968]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:00.968]     if (FALSE) {
[08:29:00.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:00.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:00.968]     }
[08:29:00.968]     ...future.result <- base::tryCatch({
[08:29:00.968]         base::withCallingHandlers({
[08:29:00.968]             ...future.value <- base::withVisible(base::local(1))
[08:29:00.968]             future::FutureResult(value = ...future.value$value, 
[08:29:00.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.968]                   ...future.rng), globalenv = if (FALSE) 
[08:29:00.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:00.968]                     ...future.globalenv.names))
[08:29:00.968]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:00.968]         }, condition = base::local({
[08:29:00.968]             c <- base::c
[08:29:00.968]             inherits <- base::inherits
[08:29:00.968]             invokeRestart <- base::invokeRestart
[08:29:00.968]             length <- base::length
[08:29:00.968]             list <- base::list
[08:29:00.968]             seq.int <- base::seq.int
[08:29:00.968]             signalCondition <- base::signalCondition
[08:29:00.968]             sys.calls <- base::sys.calls
[08:29:00.968]             `[[` <- base::`[[`
[08:29:00.968]             `+` <- base::`+`
[08:29:00.968]             `<<-` <- base::`<<-`
[08:29:00.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:00.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:00.968]                   3L)]
[08:29:00.968]             }
[08:29:00.968]             function(cond) {
[08:29:00.968]                 is_error <- inherits(cond, "error")
[08:29:00.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:00.968]                   NULL)
[08:29:00.968]                 if (is_error) {
[08:29:00.968]                   sessionInformation <- function() {
[08:29:00.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:00.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:00.968]                       search = base::search(), system = base::Sys.info())
[08:29:00.968]                   }
[08:29:00.968]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:00.968]                     cond$call), session = sessionInformation(), 
[08:29:00.968]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:00.968]                   signalCondition(cond)
[08:29:00.968]                 }
[08:29:00.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:00.968]                 "immediateCondition"))) {
[08:29:00.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:00.968]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:00.968]                   if (TRUE && !signal) {
[08:29:00.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.968]                     {
[08:29:00.968]                       inherits <- base::inherits
[08:29:00.968]                       invokeRestart <- base::invokeRestart
[08:29:00.968]                       is.null <- base::is.null
[08:29:00.968]                       muffled <- FALSE
[08:29:00.968]                       if (inherits(cond, "message")) {
[08:29:00.968]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.968]                         if (muffled) 
[08:29:00.968]                           invokeRestart("muffleMessage")
[08:29:00.968]                       }
[08:29:00.968]                       else if (inherits(cond, "warning")) {
[08:29:00.968]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.968]                         if (muffled) 
[08:29:00.968]                           invokeRestart("muffleWarning")
[08:29:00.968]                       }
[08:29:00.968]                       else if (inherits(cond, "condition")) {
[08:29:00.968]                         if (!is.null(pattern)) {
[08:29:00.968]                           computeRestarts <- base::computeRestarts
[08:29:00.968]                           grepl <- base::grepl
[08:29:00.968]                           restarts <- computeRestarts(cond)
[08:29:00.968]                           for (restart in restarts) {
[08:29:00.968]                             name <- restart$name
[08:29:00.968]                             if (is.null(name)) 
[08:29:00.968]                               next
[08:29:00.968]                             if (!grepl(pattern, name)) 
[08:29:00.968]                               next
[08:29:00.968]                             invokeRestart(restart)
[08:29:00.968]                             muffled <- TRUE
[08:29:00.968]                             break
[08:29:00.968]                           }
[08:29:00.968]                         }
[08:29:00.968]                       }
[08:29:00.968]                       invisible(muffled)
[08:29:00.968]                     }
[08:29:00.968]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.968]                   }
[08:29:00.968]                 }
[08:29:00.968]                 else {
[08:29:00.968]                   if (TRUE) {
[08:29:00.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.968]                     {
[08:29:00.968]                       inherits <- base::inherits
[08:29:00.968]                       invokeRestart <- base::invokeRestart
[08:29:00.968]                       is.null <- base::is.null
[08:29:00.968]                       muffled <- FALSE
[08:29:00.968]                       if (inherits(cond, "message")) {
[08:29:00.968]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.968]                         if (muffled) 
[08:29:00.968]                           invokeRestart("muffleMessage")
[08:29:00.968]                       }
[08:29:00.968]                       else if (inherits(cond, "warning")) {
[08:29:00.968]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.968]                         if (muffled) 
[08:29:00.968]                           invokeRestart("muffleWarning")
[08:29:00.968]                       }
[08:29:00.968]                       else if (inherits(cond, "condition")) {
[08:29:00.968]                         if (!is.null(pattern)) {
[08:29:00.968]                           computeRestarts <- base::computeRestarts
[08:29:00.968]                           grepl <- base::grepl
[08:29:00.968]                           restarts <- computeRestarts(cond)
[08:29:00.968]                           for (restart in restarts) {
[08:29:00.968]                             name <- restart$name
[08:29:00.968]                             if (is.null(name)) 
[08:29:00.968]                               next
[08:29:00.968]                             if (!grepl(pattern, name)) 
[08:29:00.968]                               next
[08:29:00.968]                             invokeRestart(restart)
[08:29:00.968]                             muffled <- TRUE
[08:29:00.968]                             break
[08:29:00.968]                           }
[08:29:00.968]                         }
[08:29:00.968]                       }
[08:29:00.968]                       invisible(muffled)
[08:29:00.968]                     }
[08:29:00.968]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.968]                   }
[08:29:00.968]                 }
[08:29:00.968]             }
[08:29:00.968]         }))
[08:29:00.968]     }, error = function(ex) {
[08:29:00.968]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:00.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.968]                 ...future.rng), started = ...future.startTime, 
[08:29:00.968]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:00.968]             version = "1.8"), class = "FutureResult")
[08:29:00.968]     }, finally = {
[08:29:00.968]         if (!identical(...future.workdir, getwd())) 
[08:29:00.968]             setwd(...future.workdir)
[08:29:00.968]         {
[08:29:00.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:00.968]                 ...future.oldOptions$nwarnings <- NULL
[08:29:00.968]             }
[08:29:00.968]             base::options(...future.oldOptions)
[08:29:00.968]             if (.Platform$OS.type == "windows") {
[08:29:00.968]                 old_names <- names(...future.oldEnvVars)
[08:29:00.968]                 envs <- base::Sys.getenv()
[08:29:00.968]                 names <- names(envs)
[08:29:00.968]                 common <- intersect(names, old_names)
[08:29:00.968]                 added <- setdiff(names, old_names)
[08:29:00.968]                 removed <- setdiff(old_names, names)
[08:29:00.968]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:00.968]                   envs[common]]
[08:29:00.968]                 NAMES <- toupper(changed)
[08:29:00.968]                 args <- list()
[08:29:00.968]                 for (kk in seq_along(NAMES)) {
[08:29:00.968]                   name <- changed[[kk]]
[08:29:00.968]                   NAME <- NAMES[[kk]]
[08:29:00.968]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.968]                     next
[08:29:00.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.968]                 }
[08:29:00.968]                 NAMES <- toupper(added)
[08:29:00.968]                 for (kk in seq_along(NAMES)) {
[08:29:00.968]                   name <- added[[kk]]
[08:29:00.968]                   NAME <- NAMES[[kk]]
[08:29:00.968]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.968]                     next
[08:29:00.968]                   args[[name]] <- ""
[08:29:00.968]                 }
[08:29:00.968]                 NAMES <- toupper(removed)
[08:29:00.968]                 for (kk in seq_along(NAMES)) {
[08:29:00.968]                   name <- removed[[kk]]
[08:29:00.968]                   NAME <- NAMES[[kk]]
[08:29:00.968]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.968]                     next
[08:29:00.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.968]                 }
[08:29:00.968]                 if (length(args) > 0) 
[08:29:00.968]                   base::do.call(base::Sys.setenv, args = args)
[08:29:00.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:00.968]             }
[08:29:00.968]             else {
[08:29:00.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:00.968]             }
[08:29:00.968]             {
[08:29:00.968]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:00.968]                   0L) {
[08:29:00.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:00.968]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:00.968]                   base::options(opts)
[08:29:00.968]                 }
[08:29:00.968]                 {
[08:29:00.968]                   {
[08:29:00.968]                     NULL
[08:29:00.968]                     RNGkind("Mersenne-Twister")
[08:29:00.968]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:00.968]                       inherits = FALSE)
[08:29:00.968]                   }
[08:29:00.968]                   options(future.plan = NULL)
[08:29:00.968]                   if (is.na(NA_character_)) 
[08:29:00.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:00.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:00.968]                     .init = FALSE)
[08:29:00.968]                 }
[08:29:00.968]             }
[08:29:00.968]         }
[08:29:00.968]     })
[08:29:00.968]     if (TRUE) {
[08:29:00.968]         base::sink(type = "output", split = FALSE)
[08:29:00.968]         if (TRUE) {
[08:29:00.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:00.968]         }
[08:29:00.968]         else {
[08:29:00.968]             ...future.result["stdout"] <- base::list(NULL)
[08:29:00.968]         }
[08:29:00.968]         base::close(...future.stdout)
[08:29:00.968]         ...future.stdout <- NULL
[08:29:00.968]     }
[08:29:00.968]     ...future.result$conditions <- ...future.conditions
[08:29:00.968]     ...future.result$finished <- base::Sys.time()
[08:29:00.968]     ...future.result
[08:29:00.968] }
[08:29:00.969] plan(): Setting new future strategy stack:
[08:29:00.970] List of future strategies:
[08:29:00.970] 1. sequential:
[08:29:00.970]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.970]    - tweaked: FALSE
[08:29:00.970]    - call: NULL
[08:29:00.970] plan(): nbrOfWorkers() = 1
[08:29:00.971] plan(): Setting new future strategy stack:
[08:29:00.971] List of future strategies:
[08:29:00.971] 1. sequential:
[08:29:00.971]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.971]    - tweaked: FALSE
[08:29:00.971]    - call: plan(strategy)
[08:29:00.971] plan(): nbrOfWorkers() = 1
[08:29:00.971] SequentialFuture started (and completed)
[08:29:00.971] - Launch lazy future ... done
[08:29:00.972] run() for ‘SequentialFuture’ ... done
[08:29:00.972] getGlobalsAndPackages() ...
[08:29:00.972] Searching for globals...
[08:29:00.972] 
[08:29:00.972] Searching for globals ... DONE
[08:29:00.972] - globals: [0] <none>
[08:29:00.972] getGlobalsAndPackages() ... DONE
[08:29:00.973] run() for ‘Future’ ...
[08:29:00.973] - state: ‘created’
[08:29:00.973] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:00.973] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:00.973] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:00.973]   - Field: ‘label’
[08:29:00.973]   - Field: ‘local’
[08:29:00.973]   - Field: ‘owner’
[08:29:00.973]   - Field: ‘envir’
[08:29:00.974]   - Field: ‘packages’
[08:29:00.974]   - Field: ‘gc’
[08:29:00.974]   - Field: ‘conditions’
[08:29:00.974]   - Field: ‘expr’
[08:29:00.974]   - Field: ‘uuid’
[08:29:00.974]   - Field: ‘seed’
[08:29:00.974]   - Field: ‘version’
[08:29:00.974]   - Field: ‘result’
[08:29:00.974]   - Field: ‘asynchronous’
[08:29:00.974]   - Field: ‘calls’
[08:29:00.974]   - Field: ‘globals’
[08:29:00.974]   - Field: ‘stdout’
[08:29:00.975]   - Field: ‘earlySignal’
[08:29:00.975]   - Field: ‘lazy’
[08:29:00.975]   - Field: ‘state’
[08:29:00.975] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:00.975] - Launch lazy future ...
[08:29:00.975] Packages needed by the future expression (n = 0): <none>
[08:29:00.975] Packages needed by future strategies (n = 0): <none>
[08:29:00.976] {
[08:29:00.976]     {
[08:29:00.976]         {
[08:29:00.976]             ...future.startTime <- base::Sys.time()
[08:29:00.976]             {
[08:29:00.976]                 {
[08:29:00.976]                   {
[08:29:00.976]                     base::local({
[08:29:00.976]                       has_future <- base::requireNamespace("future", 
[08:29:00.976]                         quietly = TRUE)
[08:29:00.976]                       if (has_future) {
[08:29:00.976]                         ns <- base::getNamespace("future")
[08:29:00.976]                         version <- ns[[".package"]][["version"]]
[08:29:00.976]                         if (is.null(version)) 
[08:29:00.976]                           version <- utils::packageVersion("future")
[08:29:00.976]                       }
[08:29:00.976]                       else {
[08:29:00.976]                         version <- NULL
[08:29:00.976]                       }
[08:29:00.976]                       if (!has_future || version < "1.8.0") {
[08:29:00.976]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:00.976]                           "", base::R.version$version.string), 
[08:29:00.976]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:00.976]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:00.976]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:00.976]                             "release", "version")], collapse = " "), 
[08:29:00.976]                           hostname = base::Sys.info()[["nodename"]])
[08:29:00.976]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:00.976]                           info)
[08:29:00.976]                         info <- base::paste(info, collapse = "; ")
[08:29:00.976]                         if (!has_future) {
[08:29:00.976]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:00.976]                             info)
[08:29:00.976]                         }
[08:29:00.976]                         else {
[08:29:00.976]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:00.976]                             info, version)
[08:29:00.976]                         }
[08:29:00.976]                         base::stop(msg)
[08:29:00.976]                       }
[08:29:00.976]                     })
[08:29:00.976]                   }
[08:29:00.976]                   ...future.strategy.old <- future::plan("list")
[08:29:00.976]                   options(future.plan = NULL)
[08:29:00.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.976]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:00.976]                 }
[08:29:00.976]                 ...future.workdir <- getwd()
[08:29:00.976]             }
[08:29:00.976]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:00.976]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:00.976]         }
[08:29:00.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:00.976]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:00.976]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:00.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:00.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:00.976]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:00.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:00.976]             base::names(...future.oldOptions))
[08:29:00.976]     }
[08:29:00.976]     if (FALSE) {
[08:29:00.976]     }
[08:29:00.976]     else {
[08:29:00.976]         if (TRUE) {
[08:29:00.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:00.976]                 open = "w")
[08:29:00.976]         }
[08:29:00.976]         else {
[08:29:00.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:00.976]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:00.976]         }
[08:29:00.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:00.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:00.976]             base::sink(type = "output", split = FALSE)
[08:29:00.976]             base::close(...future.stdout)
[08:29:00.976]         }, add = TRUE)
[08:29:00.976]     }
[08:29:00.976]     ...future.frame <- base::sys.nframe()
[08:29:00.976]     ...future.conditions <- base::list()
[08:29:00.976]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:00.976]     if (FALSE) {
[08:29:00.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:00.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:00.976]     }
[08:29:00.976]     ...future.result <- base::tryCatch({
[08:29:00.976]         base::withCallingHandlers({
[08:29:00.976]             ...future.value <- base::withVisible(base::local(2))
[08:29:00.976]             future::FutureResult(value = ...future.value$value, 
[08:29:00.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.976]                   ...future.rng), globalenv = if (FALSE) 
[08:29:00.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:00.976]                     ...future.globalenv.names))
[08:29:00.976]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:00.976]         }, condition = base::local({
[08:29:00.976]             c <- base::c
[08:29:00.976]             inherits <- base::inherits
[08:29:00.976]             invokeRestart <- base::invokeRestart
[08:29:00.976]             length <- base::length
[08:29:00.976]             list <- base::list
[08:29:00.976]             seq.int <- base::seq.int
[08:29:00.976]             signalCondition <- base::signalCondition
[08:29:00.976]             sys.calls <- base::sys.calls
[08:29:00.976]             `[[` <- base::`[[`
[08:29:00.976]             `+` <- base::`+`
[08:29:00.976]             `<<-` <- base::`<<-`
[08:29:00.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:00.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:00.976]                   3L)]
[08:29:00.976]             }
[08:29:00.976]             function(cond) {
[08:29:00.976]                 is_error <- inherits(cond, "error")
[08:29:00.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:00.976]                   NULL)
[08:29:00.976]                 if (is_error) {
[08:29:00.976]                   sessionInformation <- function() {
[08:29:00.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:00.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:00.976]                       search = base::search(), system = base::Sys.info())
[08:29:00.976]                   }
[08:29:00.976]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:00.976]                     cond$call), session = sessionInformation(), 
[08:29:00.976]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:00.976]                   signalCondition(cond)
[08:29:00.976]                 }
[08:29:00.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:00.976]                 "immediateCondition"))) {
[08:29:00.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:00.976]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:00.976]                   if (TRUE && !signal) {
[08:29:00.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.976]                     {
[08:29:00.976]                       inherits <- base::inherits
[08:29:00.976]                       invokeRestart <- base::invokeRestart
[08:29:00.976]                       is.null <- base::is.null
[08:29:00.976]                       muffled <- FALSE
[08:29:00.976]                       if (inherits(cond, "message")) {
[08:29:00.976]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.976]                         if (muffled) 
[08:29:00.976]                           invokeRestart("muffleMessage")
[08:29:00.976]                       }
[08:29:00.976]                       else if (inherits(cond, "warning")) {
[08:29:00.976]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.976]                         if (muffled) 
[08:29:00.976]                           invokeRestart("muffleWarning")
[08:29:00.976]                       }
[08:29:00.976]                       else if (inherits(cond, "condition")) {
[08:29:00.976]                         if (!is.null(pattern)) {
[08:29:00.976]                           computeRestarts <- base::computeRestarts
[08:29:00.976]                           grepl <- base::grepl
[08:29:00.976]                           restarts <- computeRestarts(cond)
[08:29:00.976]                           for (restart in restarts) {
[08:29:00.976]                             name <- restart$name
[08:29:00.976]                             if (is.null(name)) 
[08:29:00.976]                               next
[08:29:00.976]                             if (!grepl(pattern, name)) 
[08:29:00.976]                               next
[08:29:00.976]                             invokeRestart(restart)
[08:29:00.976]                             muffled <- TRUE
[08:29:00.976]                             break
[08:29:00.976]                           }
[08:29:00.976]                         }
[08:29:00.976]                       }
[08:29:00.976]                       invisible(muffled)
[08:29:00.976]                     }
[08:29:00.976]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.976]                   }
[08:29:00.976]                 }
[08:29:00.976]                 else {
[08:29:00.976]                   if (TRUE) {
[08:29:00.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.976]                     {
[08:29:00.976]                       inherits <- base::inherits
[08:29:00.976]                       invokeRestart <- base::invokeRestart
[08:29:00.976]                       is.null <- base::is.null
[08:29:00.976]                       muffled <- FALSE
[08:29:00.976]                       if (inherits(cond, "message")) {
[08:29:00.976]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.976]                         if (muffled) 
[08:29:00.976]                           invokeRestart("muffleMessage")
[08:29:00.976]                       }
[08:29:00.976]                       else if (inherits(cond, "warning")) {
[08:29:00.976]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.976]                         if (muffled) 
[08:29:00.976]                           invokeRestart("muffleWarning")
[08:29:00.976]                       }
[08:29:00.976]                       else if (inherits(cond, "condition")) {
[08:29:00.976]                         if (!is.null(pattern)) {
[08:29:00.976]                           computeRestarts <- base::computeRestarts
[08:29:00.976]                           grepl <- base::grepl
[08:29:00.976]                           restarts <- computeRestarts(cond)
[08:29:00.976]                           for (restart in restarts) {
[08:29:00.976]                             name <- restart$name
[08:29:00.976]                             if (is.null(name)) 
[08:29:00.976]                               next
[08:29:00.976]                             if (!grepl(pattern, name)) 
[08:29:00.976]                               next
[08:29:00.976]                             invokeRestart(restart)
[08:29:00.976]                             muffled <- TRUE
[08:29:00.976]                             break
[08:29:00.976]                           }
[08:29:00.976]                         }
[08:29:00.976]                       }
[08:29:00.976]                       invisible(muffled)
[08:29:00.976]                     }
[08:29:00.976]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.976]                   }
[08:29:00.976]                 }
[08:29:00.976]             }
[08:29:00.976]         }))
[08:29:00.976]     }, error = function(ex) {
[08:29:00.976]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:00.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.976]                 ...future.rng), started = ...future.startTime, 
[08:29:00.976]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:00.976]             version = "1.8"), class = "FutureResult")
[08:29:00.976]     }, finally = {
[08:29:00.976]         if (!identical(...future.workdir, getwd())) 
[08:29:00.976]             setwd(...future.workdir)
[08:29:00.976]         {
[08:29:00.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:00.976]                 ...future.oldOptions$nwarnings <- NULL
[08:29:00.976]             }
[08:29:00.976]             base::options(...future.oldOptions)
[08:29:00.976]             if (.Platform$OS.type == "windows") {
[08:29:00.976]                 old_names <- names(...future.oldEnvVars)
[08:29:00.976]                 envs <- base::Sys.getenv()
[08:29:00.976]                 names <- names(envs)
[08:29:00.976]                 common <- intersect(names, old_names)
[08:29:00.976]                 added <- setdiff(names, old_names)
[08:29:00.976]                 removed <- setdiff(old_names, names)
[08:29:00.976]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:00.976]                   envs[common]]
[08:29:00.976]                 NAMES <- toupper(changed)
[08:29:00.976]                 args <- list()
[08:29:00.976]                 for (kk in seq_along(NAMES)) {
[08:29:00.976]                   name <- changed[[kk]]
[08:29:00.976]                   NAME <- NAMES[[kk]]
[08:29:00.976]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.976]                     next
[08:29:00.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.976]                 }
[08:29:00.976]                 NAMES <- toupper(added)
[08:29:00.976]                 for (kk in seq_along(NAMES)) {
[08:29:00.976]                   name <- added[[kk]]
[08:29:00.976]                   NAME <- NAMES[[kk]]
[08:29:00.976]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.976]                     next
[08:29:00.976]                   args[[name]] <- ""
[08:29:00.976]                 }
[08:29:00.976]                 NAMES <- toupper(removed)
[08:29:00.976]                 for (kk in seq_along(NAMES)) {
[08:29:00.976]                   name <- removed[[kk]]
[08:29:00.976]                   NAME <- NAMES[[kk]]
[08:29:00.976]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.976]                     next
[08:29:00.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.976]                 }
[08:29:00.976]                 if (length(args) > 0) 
[08:29:00.976]                   base::do.call(base::Sys.setenv, args = args)
[08:29:00.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:00.976]             }
[08:29:00.976]             else {
[08:29:00.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:00.976]             }
[08:29:00.976]             {
[08:29:00.976]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:00.976]                   0L) {
[08:29:00.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:00.976]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:00.976]                   base::options(opts)
[08:29:00.976]                 }
[08:29:00.976]                 {
[08:29:00.976]                   {
[08:29:00.976]                     NULL
[08:29:00.976]                     RNGkind("Mersenne-Twister")
[08:29:00.976]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:00.976]                       inherits = FALSE)
[08:29:00.976]                   }
[08:29:00.976]                   options(future.plan = NULL)
[08:29:00.976]                   if (is.na(NA_character_)) 
[08:29:00.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:00.976]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:00.976]                     .init = FALSE)
[08:29:00.976]                 }
[08:29:00.976]             }
[08:29:00.976]         }
[08:29:00.976]     })
[08:29:00.976]     if (TRUE) {
[08:29:00.976]         base::sink(type = "output", split = FALSE)
[08:29:00.976]         if (TRUE) {
[08:29:00.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:00.976]         }
[08:29:00.976]         else {
[08:29:00.976]             ...future.result["stdout"] <- base::list(NULL)
[08:29:00.976]         }
[08:29:00.976]         base::close(...future.stdout)
[08:29:00.976]         ...future.stdout <- NULL
[08:29:00.976]     }
[08:29:00.976]     ...future.result$conditions <- ...future.conditions
[08:29:00.976]     ...future.result$finished <- base::Sys.time()
[08:29:00.976]     ...future.result
[08:29:00.976] }
[08:29:00.977] plan(): Setting new future strategy stack:
[08:29:00.977] List of future strategies:
[08:29:00.977] 1. sequential:
[08:29:00.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.977]    - tweaked: FALSE
[08:29:00.977]    - call: NULL
[08:29:00.978] plan(): nbrOfWorkers() = 1
[08:29:00.978] plan(): Setting new future strategy stack:
[08:29:00.979] List of future strategies:
[08:29:00.979] 1. sequential:
[08:29:00.979]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.979]    - tweaked: FALSE
[08:29:00.979]    - call: plan(strategy)
[08:29:00.979] plan(): nbrOfWorkers() = 1
[08:29:00.979] SequentialFuture started (and completed)
[08:29:00.979] - Launch lazy future ... done
[08:29:00.979] run() for ‘SequentialFuture’ ... done
[08:29:00.980] resolve() on environment ...
[08:29:00.980]  recursive: 0
[08:29:00.980]  elements: [3] ‘a’, ‘b’, ‘c’
[08:29:00.980] resolved() for ‘SequentialFuture’ ...
[08:29:00.980] - state: ‘finished’
[08:29:00.981] - run: TRUE
[08:29:00.981] - result: ‘FutureResult’
[08:29:00.981] resolved() for ‘SequentialFuture’ ... done
[08:29:00.981] Future #1
[08:29:00.981]  length: 2 (resolved future 1)
[08:29:00.981] resolved() for ‘SequentialFuture’ ...
[08:29:00.981] - state: ‘finished’
[08:29:00.981] - run: TRUE
[08:29:00.981] - result: ‘FutureResult’
[08:29:00.981] resolved() for ‘SequentialFuture’ ... done
[08:29:00.981] Future #2
[08:29:00.982]  length: 1 (resolved future 2)
[08:29:00.982]  length: 0 (resolved future 3)
[08:29:00.982] resolve() on environment ... DONE
[08:29:00.982] resolved() for ‘SequentialFuture’ ...
[08:29:00.982] - state: ‘finished’
[08:29:00.982] - run: TRUE
[08:29:00.982] - result: ‘FutureResult’
[08:29:00.982] resolved() for ‘SequentialFuture’ ... done
[08:29:00.982] resolved() for ‘SequentialFuture’ ...
[08:29:00.982] - state: ‘finished’
[08:29:00.982] - run: TRUE
[08:29:00.982] - result: ‘FutureResult’
[08:29:00.983] resolved() for ‘SequentialFuture’ ... done
[08:29:00.983] getGlobalsAndPackages() ...
[08:29:00.983] Searching for globals...
[08:29:00.984] - globals found: [1] ‘{’
[08:29:00.984] Searching for globals ... DONE
[08:29:00.984] Resolving globals: FALSE
[08:29:00.984] 
[08:29:00.984] 
[08:29:00.985] getGlobalsAndPackages() ... DONE
[08:29:00.985] run() for ‘Future’ ...
[08:29:00.985] - state: ‘created’
[08:29:00.986] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:00.987] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:00.987] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:00.987]   - Field: ‘label’
[08:29:00.987]   - Field: ‘local’
[08:29:00.987]   - Field: ‘owner’
[08:29:00.987]   - Field: ‘envir’
[08:29:00.987]   - Field: ‘packages’
[08:29:00.987]   - Field: ‘gc’
[08:29:00.988]   - Field: ‘conditions’
[08:29:00.988]   - Field: ‘expr’
[08:29:00.988]   - Field: ‘uuid’
[08:29:00.988]   - Field: ‘seed’
[08:29:00.988]   - Field: ‘version’
[08:29:00.988]   - Field: ‘result’
[08:29:00.988]   - Field: ‘asynchronous’
[08:29:00.988]   - Field: ‘calls’
[08:29:00.988]   - Field: ‘globals’
[08:29:00.988]   - Field: ‘stdout’
[08:29:00.988]   - Field: ‘earlySignal’
[08:29:00.988]   - Field: ‘lazy’
[08:29:00.989]   - Field: ‘state’
[08:29:00.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:00.989] - Launch lazy future ...
[08:29:00.989] Packages needed by the future expression (n = 0): <none>
[08:29:00.989] Packages needed by future strategies (n = 0): <none>
[08:29:00.989] {
[08:29:00.989]     {
[08:29:00.989]         {
[08:29:00.989]             ...future.startTime <- base::Sys.time()
[08:29:00.989]             {
[08:29:00.989]                 {
[08:29:00.989]                   {
[08:29:00.989]                     base::local({
[08:29:00.989]                       has_future <- base::requireNamespace("future", 
[08:29:00.989]                         quietly = TRUE)
[08:29:00.989]                       if (has_future) {
[08:29:00.989]                         ns <- base::getNamespace("future")
[08:29:00.989]                         version <- ns[[".package"]][["version"]]
[08:29:00.989]                         if (is.null(version)) 
[08:29:00.989]                           version <- utils::packageVersion("future")
[08:29:00.989]                       }
[08:29:00.989]                       else {
[08:29:00.989]                         version <- NULL
[08:29:00.989]                       }
[08:29:00.989]                       if (!has_future || version < "1.8.0") {
[08:29:00.989]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:00.989]                           "", base::R.version$version.string), 
[08:29:00.989]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:00.989]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:00.989]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:00.989]                             "release", "version")], collapse = " "), 
[08:29:00.989]                           hostname = base::Sys.info()[["nodename"]])
[08:29:00.989]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:00.989]                           info)
[08:29:00.989]                         info <- base::paste(info, collapse = "; ")
[08:29:00.989]                         if (!has_future) {
[08:29:00.989]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:00.989]                             info)
[08:29:00.989]                         }
[08:29:00.989]                         else {
[08:29:00.989]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:00.989]                             info, version)
[08:29:00.989]                         }
[08:29:00.989]                         base::stop(msg)
[08:29:00.989]                       }
[08:29:00.989]                     })
[08:29:00.989]                   }
[08:29:00.989]                   ...future.strategy.old <- future::plan("list")
[08:29:00.989]                   options(future.plan = NULL)
[08:29:00.989]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.989]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:00.989]                 }
[08:29:00.989]                 ...future.workdir <- getwd()
[08:29:00.989]             }
[08:29:00.989]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:00.989]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:00.989]         }
[08:29:00.989]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:00.989]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:00.989]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:00.989]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:00.989]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:00.989]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:00.989]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:00.989]             base::names(...future.oldOptions))
[08:29:00.989]     }
[08:29:00.989]     if (FALSE) {
[08:29:00.989]     }
[08:29:00.989]     else {
[08:29:00.989]         if (TRUE) {
[08:29:00.989]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:00.989]                 open = "w")
[08:29:00.989]         }
[08:29:00.989]         else {
[08:29:00.989]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:00.989]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:00.989]         }
[08:29:00.989]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:00.989]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:00.989]             base::sink(type = "output", split = FALSE)
[08:29:00.989]             base::close(...future.stdout)
[08:29:00.989]         }, add = TRUE)
[08:29:00.989]     }
[08:29:00.989]     ...future.frame <- base::sys.nframe()
[08:29:00.989]     ...future.conditions <- base::list()
[08:29:00.989]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:00.989]     if (FALSE) {
[08:29:00.989]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:00.989]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:00.989]     }
[08:29:00.989]     ...future.result <- base::tryCatch({
[08:29:00.989]         base::withCallingHandlers({
[08:29:00.989]             ...future.value <- base::withVisible(base::local({
[08:29:00.989]                 1
[08:29:00.989]             }))
[08:29:00.989]             future::FutureResult(value = ...future.value$value, 
[08:29:00.989]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.989]                   ...future.rng), globalenv = if (FALSE) 
[08:29:00.989]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:00.989]                     ...future.globalenv.names))
[08:29:00.989]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:00.989]         }, condition = base::local({
[08:29:00.989]             c <- base::c
[08:29:00.989]             inherits <- base::inherits
[08:29:00.989]             invokeRestart <- base::invokeRestart
[08:29:00.989]             length <- base::length
[08:29:00.989]             list <- base::list
[08:29:00.989]             seq.int <- base::seq.int
[08:29:00.989]             signalCondition <- base::signalCondition
[08:29:00.989]             sys.calls <- base::sys.calls
[08:29:00.989]             `[[` <- base::`[[`
[08:29:00.989]             `+` <- base::`+`
[08:29:00.989]             `<<-` <- base::`<<-`
[08:29:00.989]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:00.989]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:00.989]                   3L)]
[08:29:00.989]             }
[08:29:00.989]             function(cond) {
[08:29:00.989]                 is_error <- inherits(cond, "error")
[08:29:00.989]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:00.989]                   NULL)
[08:29:00.989]                 if (is_error) {
[08:29:00.989]                   sessionInformation <- function() {
[08:29:00.989]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:00.989]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:00.989]                       search = base::search(), system = base::Sys.info())
[08:29:00.989]                   }
[08:29:00.989]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.989]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:00.989]                     cond$call), session = sessionInformation(), 
[08:29:00.989]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:00.989]                   signalCondition(cond)
[08:29:00.989]                 }
[08:29:00.989]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:00.989]                 "immediateCondition"))) {
[08:29:00.989]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:00.989]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.989]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:00.989]                   if (TRUE && !signal) {
[08:29:00.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.989]                     {
[08:29:00.989]                       inherits <- base::inherits
[08:29:00.989]                       invokeRestart <- base::invokeRestart
[08:29:00.989]                       is.null <- base::is.null
[08:29:00.989]                       muffled <- FALSE
[08:29:00.989]                       if (inherits(cond, "message")) {
[08:29:00.989]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.989]                         if (muffled) 
[08:29:00.989]                           invokeRestart("muffleMessage")
[08:29:00.989]                       }
[08:29:00.989]                       else if (inherits(cond, "warning")) {
[08:29:00.989]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.989]                         if (muffled) 
[08:29:00.989]                           invokeRestart("muffleWarning")
[08:29:00.989]                       }
[08:29:00.989]                       else if (inherits(cond, "condition")) {
[08:29:00.989]                         if (!is.null(pattern)) {
[08:29:00.989]                           computeRestarts <- base::computeRestarts
[08:29:00.989]                           grepl <- base::grepl
[08:29:00.989]                           restarts <- computeRestarts(cond)
[08:29:00.989]                           for (restart in restarts) {
[08:29:00.989]                             name <- restart$name
[08:29:00.989]                             if (is.null(name)) 
[08:29:00.989]                               next
[08:29:00.989]                             if (!grepl(pattern, name)) 
[08:29:00.989]                               next
[08:29:00.989]                             invokeRestart(restart)
[08:29:00.989]                             muffled <- TRUE
[08:29:00.989]                             break
[08:29:00.989]                           }
[08:29:00.989]                         }
[08:29:00.989]                       }
[08:29:00.989]                       invisible(muffled)
[08:29:00.989]                     }
[08:29:00.989]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.989]                   }
[08:29:00.989]                 }
[08:29:00.989]                 else {
[08:29:00.989]                   if (TRUE) {
[08:29:00.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.989]                     {
[08:29:00.989]                       inherits <- base::inherits
[08:29:00.989]                       invokeRestart <- base::invokeRestart
[08:29:00.989]                       is.null <- base::is.null
[08:29:00.989]                       muffled <- FALSE
[08:29:00.989]                       if (inherits(cond, "message")) {
[08:29:00.989]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.989]                         if (muffled) 
[08:29:00.989]                           invokeRestart("muffleMessage")
[08:29:00.989]                       }
[08:29:00.989]                       else if (inherits(cond, "warning")) {
[08:29:00.989]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.989]                         if (muffled) 
[08:29:00.989]                           invokeRestart("muffleWarning")
[08:29:00.989]                       }
[08:29:00.989]                       else if (inherits(cond, "condition")) {
[08:29:00.989]                         if (!is.null(pattern)) {
[08:29:00.989]                           computeRestarts <- base::computeRestarts
[08:29:00.989]                           grepl <- base::grepl
[08:29:00.989]                           restarts <- computeRestarts(cond)
[08:29:00.989]                           for (restart in restarts) {
[08:29:00.989]                             name <- restart$name
[08:29:00.989]                             if (is.null(name)) 
[08:29:00.989]                               next
[08:29:00.989]                             if (!grepl(pattern, name)) 
[08:29:00.989]                               next
[08:29:00.989]                             invokeRestart(restart)
[08:29:00.989]                             muffled <- TRUE
[08:29:00.989]                             break
[08:29:00.989]                           }
[08:29:00.989]                         }
[08:29:00.989]                       }
[08:29:00.989]                       invisible(muffled)
[08:29:00.989]                     }
[08:29:00.989]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.989]                   }
[08:29:00.989]                 }
[08:29:00.989]             }
[08:29:00.989]         }))
[08:29:00.989]     }, error = function(ex) {
[08:29:00.989]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:00.989]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.989]                 ...future.rng), started = ...future.startTime, 
[08:29:00.989]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:00.989]             version = "1.8"), class = "FutureResult")
[08:29:00.989]     }, finally = {
[08:29:00.989]         if (!identical(...future.workdir, getwd())) 
[08:29:00.989]             setwd(...future.workdir)
[08:29:00.989]         {
[08:29:00.989]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:00.989]                 ...future.oldOptions$nwarnings <- NULL
[08:29:00.989]             }
[08:29:00.989]             base::options(...future.oldOptions)
[08:29:00.989]             if (.Platform$OS.type == "windows") {
[08:29:00.989]                 old_names <- names(...future.oldEnvVars)
[08:29:00.989]                 envs <- base::Sys.getenv()
[08:29:00.989]                 names <- names(envs)
[08:29:00.989]                 common <- intersect(names, old_names)
[08:29:00.989]                 added <- setdiff(names, old_names)
[08:29:00.989]                 removed <- setdiff(old_names, names)
[08:29:00.989]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:00.989]                   envs[common]]
[08:29:00.989]                 NAMES <- toupper(changed)
[08:29:00.989]                 args <- list()
[08:29:00.989]                 for (kk in seq_along(NAMES)) {
[08:29:00.989]                   name <- changed[[kk]]
[08:29:00.989]                   NAME <- NAMES[[kk]]
[08:29:00.989]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.989]                     next
[08:29:00.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.989]                 }
[08:29:00.989]                 NAMES <- toupper(added)
[08:29:00.989]                 for (kk in seq_along(NAMES)) {
[08:29:00.989]                   name <- added[[kk]]
[08:29:00.989]                   NAME <- NAMES[[kk]]
[08:29:00.989]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.989]                     next
[08:29:00.989]                   args[[name]] <- ""
[08:29:00.989]                 }
[08:29:00.989]                 NAMES <- toupper(removed)
[08:29:00.989]                 for (kk in seq_along(NAMES)) {
[08:29:00.989]                   name <- removed[[kk]]
[08:29:00.989]                   NAME <- NAMES[[kk]]
[08:29:00.989]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.989]                     next
[08:29:00.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.989]                 }
[08:29:00.989]                 if (length(args) > 0) 
[08:29:00.989]                   base::do.call(base::Sys.setenv, args = args)
[08:29:00.989]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:00.989]             }
[08:29:00.989]             else {
[08:29:00.989]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:00.989]             }
[08:29:00.989]             {
[08:29:00.989]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:00.989]                   0L) {
[08:29:00.989]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:00.989]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:00.989]                   base::options(opts)
[08:29:00.989]                 }
[08:29:00.989]                 {
[08:29:00.989]                   {
[08:29:00.989]                     NULL
[08:29:00.989]                     RNGkind("Mersenne-Twister")
[08:29:00.989]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:00.989]                       inherits = FALSE)
[08:29:00.989]                   }
[08:29:00.989]                   options(future.plan = NULL)
[08:29:00.989]                   if (is.na(NA_character_)) 
[08:29:00.989]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.989]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:00.989]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:00.989]                     .init = FALSE)
[08:29:00.989]                 }
[08:29:00.989]             }
[08:29:00.989]         }
[08:29:00.989]     })
[08:29:00.989]     if (TRUE) {
[08:29:00.989]         base::sink(type = "output", split = FALSE)
[08:29:00.989]         if (TRUE) {
[08:29:00.989]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:00.989]         }
[08:29:00.989]         else {
[08:29:00.989]             ...future.result["stdout"] <- base::list(NULL)
[08:29:00.989]         }
[08:29:00.989]         base::close(...future.stdout)
[08:29:00.989]         ...future.stdout <- NULL
[08:29:00.989]     }
[08:29:00.989]     ...future.result$conditions <- ...future.conditions
[08:29:00.989]     ...future.result$finished <- base::Sys.time()
[08:29:00.989]     ...future.result
[08:29:00.989] }
[08:29:00.991] plan(): Setting new future strategy stack:
[08:29:00.991] List of future strategies:
[08:29:00.991] 1. sequential:
[08:29:00.991]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.991]    - tweaked: FALSE
[08:29:00.991]    - call: NULL
[08:29:00.992] plan(): nbrOfWorkers() = 1
[08:29:00.992] plan(): Setting new future strategy stack:
[08:29:00.992] List of future strategies:
[08:29:00.992] 1. sequential:
[08:29:00.992]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:00.992]    - tweaked: FALSE
[08:29:00.992]    - call: plan(strategy)
[08:29:00.993] plan(): nbrOfWorkers() = 1
[08:29:00.993] SequentialFuture started (and completed)
[08:29:00.993] - Launch lazy future ... done
[08:29:00.993] run() for ‘SequentialFuture’ ... done
[08:29:00.993] getGlobalsAndPackages() ...
[08:29:00.993] Searching for globals...
[08:29:00.994] - globals found: [1] ‘{’
[08:29:00.994] Searching for globals ... DONE
[08:29:00.994] Resolving globals: FALSE
[08:29:00.994] 
[08:29:00.995] 
[08:29:00.995] getGlobalsAndPackages() ... DONE
[08:29:00.995] run() for ‘Future’ ...
[08:29:00.995] - state: ‘created’
[08:29:00.995] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:00.995] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:00.995] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:00.995]   - Field: ‘label’
[08:29:00.996]   - Field: ‘local’
[08:29:00.996]   - Field: ‘owner’
[08:29:00.996]   - Field: ‘envir’
[08:29:00.996]   - Field: ‘packages’
[08:29:00.996]   - Field: ‘gc’
[08:29:00.996]   - Field: ‘conditions’
[08:29:00.996]   - Field: ‘expr’
[08:29:00.996]   - Field: ‘uuid’
[08:29:00.996]   - Field: ‘seed’
[08:29:00.996]   - Field: ‘version’
[08:29:00.996]   - Field: ‘result’
[08:29:00.996]   - Field: ‘asynchronous’
[08:29:00.997]   - Field: ‘calls’
[08:29:00.997]   - Field: ‘globals’
[08:29:00.997]   - Field: ‘stdout’
[08:29:00.997]   - Field: ‘earlySignal’
[08:29:00.997]   - Field: ‘lazy’
[08:29:00.997]   - Field: ‘state’
[08:29:00.997] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:00.997] - Launch lazy future ...
[08:29:00.997] Packages needed by the future expression (n = 0): <none>
[08:29:00.997] Packages needed by future strategies (n = 0): <none>
[08:29:00.998] {
[08:29:00.998]     {
[08:29:00.998]         {
[08:29:00.998]             ...future.startTime <- base::Sys.time()
[08:29:00.998]             {
[08:29:00.998]                 {
[08:29:00.998]                   {
[08:29:00.998]                     base::local({
[08:29:00.998]                       has_future <- base::requireNamespace("future", 
[08:29:00.998]                         quietly = TRUE)
[08:29:00.998]                       if (has_future) {
[08:29:00.998]                         ns <- base::getNamespace("future")
[08:29:00.998]                         version <- ns[[".package"]][["version"]]
[08:29:00.998]                         if (is.null(version)) 
[08:29:00.998]                           version <- utils::packageVersion("future")
[08:29:00.998]                       }
[08:29:00.998]                       else {
[08:29:00.998]                         version <- NULL
[08:29:00.998]                       }
[08:29:00.998]                       if (!has_future || version < "1.8.0") {
[08:29:00.998]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:00.998]                           "", base::R.version$version.string), 
[08:29:00.998]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:00.998]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:00.998]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:00.998]                             "release", "version")], collapse = " "), 
[08:29:00.998]                           hostname = base::Sys.info()[["nodename"]])
[08:29:00.998]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:00.998]                           info)
[08:29:00.998]                         info <- base::paste(info, collapse = "; ")
[08:29:00.998]                         if (!has_future) {
[08:29:00.998]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:00.998]                             info)
[08:29:00.998]                         }
[08:29:00.998]                         else {
[08:29:00.998]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:00.998]                             info, version)
[08:29:00.998]                         }
[08:29:00.998]                         base::stop(msg)
[08:29:00.998]                       }
[08:29:00.998]                     })
[08:29:00.998]                   }
[08:29:00.998]                   ...future.strategy.old <- future::plan("list")
[08:29:00.998]                   options(future.plan = NULL)
[08:29:00.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:00.998]                 }
[08:29:00.998]                 ...future.workdir <- getwd()
[08:29:00.998]             }
[08:29:00.998]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:00.998]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:00.998]         }
[08:29:00.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:00.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:00.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:00.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:00.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:00.998]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:00.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:00.998]             base::names(...future.oldOptions))
[08:29:00.998]     }
[08:29:00.998]     if (FALSE) {
[08:29:00.998]     }
[08:29:00.998]     else {
[08:29:00.998]         if (TRUE) {
[08:29:00.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:00.998]                 open = "w")
[08:29:00.998]         }
[08:29:00.998]         else {
[08:29:00.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:00.998]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:00.998]         }
[08:29:00.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:00.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:00.998]             base::sink(type = "output", split = FALSE)
[08:29:00.998]             base::close(...future.stdout)
[08:29:00.998]         }, add = TRUE)
[08:29:00.998]     }
[08:29:00.998]     ...future.frame <- base::sys.nframe()
[08:29:00.998]     ...future.conditions <- base::list()
[08:29:00.998]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:00.998]     if (FALSE) {
[08:29:00.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:00.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:00.998]     }
[08:29:00.998]     ...future.result <- base::tryCatch({
[08:29:00.998]         base::withCallingHandlers({
[08:29:00.998]             ...future.value <- base::withVisible(base::local({
[08:29:00.998]                 2
[08:29:00.998]             }))
[08:29:00.998]             future::FutureResult(value = ...future.value$value, 
[08:29:00.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.998]                   ...future.rng), globalenv = if (FALSE) 
[08:29:00.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:00.998]                     ...future.globalenv.names))
[08:29:00.998]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:00.998]         }, condition = base::local({
[08:29:00.998]             c <- base::c
[08:29:00.998]             inherits <- base::inherits
[08:29:00.998]             invokeRestart <- base::invokeRestart
[08:29:00.998]             length <- base::length
[08:29:00.998]             list <- base::list
[08:29:00.998]             seq.int <- base::seq.int
[08:29:00.998]             signalCondition <- base::signalCondition
[08:29:00.998]             sys.calls <- base::sys.calls
[08:29:00.998]             `[[` <- base::`[[`
[08:29:00.998]             `+` <- base::`+`
[08:29:00.998]             `<<-` <- base::`<<-`
[08:29:00.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:00.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:00.998]                   3L)]
[08:29:00.998]             }
[08:29:00.998]             function(cond) {
[08:29:00.998]                 is_error <- inherits(cond, "error")
[08:29:00.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:00.998]                   NULL)
[08:29:00.998]                 if (is_error) {
[08:29:00.998]                   sessionInformation <- function() {
[08:29:00.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:00.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:00.998]                       search = base::search(), system = base::Sys.info())
[08:29:00.998]                   }
[08:29:00.998]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:00.998]                     cond$call), session = sessionInformation(), 
[08:29:00.998]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:00.998]                   signalCondition(cond)
[08:29:00.998]                 }
[08:29:00.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:00.998]                 "immediateCondition"))) {
[08:29:00.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:00.998]                   ...future.conditions[[length(...future.conditions) + 
[08:29:00.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:00.998]                   if (TRUE && !signal) {
[08:29:00.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.998]                     {
[08:29:00.998]                       inherits <- base::inherits
[08:29:00.998]                       invokeRestart <- base::invokeRestart
[08:29:00.998]                       is.null <- base::is.null
[08:29:00.998]                       muffled <- FALSE
[08:29:00.998]                       if (inherits(cond, "message")) {
[08:29:00.998]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.998]                         if (muffled) 
[08:29:00.998]                           invokeRestart("muffleMessage")
[08:29:00.998]                       }
[08:29:00.998]                       else if (inherits(cond, "warning")) {
[08:29:00.998]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.998]                         if (muffled) 
[08:29:00.998]                           invokeRestart("muffleWarning")
[08:29:00.998]                       }
[08:29:00.998]                       else if (inherits(cond, "condition")) {
[08:29:00.998]                         if (!is.null(pattern)) {
[08:29:00.998]                           computeRestarts <- base::computeRestarts
[08:29:00.998]                           grepl <- base::grepl
[08:29:00.998]                           restarts <- computeRestarts(cond)
[08:29:00.998]                           for (restart in restarts) {
[08:29:00.998]                             name <- restart$name
[08:29:00.998]                             if (is.null(name)) 
[08:29:00.998]                               next
[08:29:00.998]                             if (!grepl(pattern, name)) 
[08:29:00.998]                               next
[08:29:00.998]                             invokeRestart(restart)
[08:29:00.998]                             muffled <- TRUE
[08:29:00.998]                             break
[08:29:00.998]                           }
[08:29:00.998]                         }
[08:29:00.998]                       }
[08:29:00.998]                       invisible(muffled)
[08:29:00.998]                     }
[08:29:00.998]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.998]                   }
[08:29:00.998]                 }
[08:29:00.998]                 else {
[08:29:00.998]                   if (TRUE) {
[08:29:00.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:00.998]                     {
[08:29:00.998]                       inherits <- base::inherits
[08:29:00.998]                       invokeRestart <- base::invokeRestart
[08:29:00.998]                       is.null <- base::is.null
[08:29:00.998]                       muffled <- FALSE
[08:29:00.998]                       if (inherits(cond, "message")) {
[08:29:00.998]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:00.998]                         if (muffled) 
[08:29:00.998]                           invokeRestart("muffleMessage")
[08:29:00.998]                       }
[08:29:00.998]                       else if (inherits(cond, "warning")) {
[08:29:00.998]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:00.998]                         if (muffled) 
[08:29:00.998]                           invokeRestart("muffleWarning")
[08:29:00.998]                       }
[08:29:00.998]                       else if (inherits(cond, "condition")) {
[08:29:00.998]                         if (!is.null(pattern)) {
[08:29:00.998]                           computeRestarts <- base::computeRestarts
[08:29:00.998]                           grepl <- base::grepl
[08:29:00.998]                           restarts <- computeRestarts(cond)
[08:29:00.998]                           for (restart in restarts) {
[08:29:00.998]                             name <- restart$name
[08:29:00.998]                             if (is.null(name)) 
[08:29:00.998]                               next
[08:29:00.998]                             if (!grepl(pattern, name)) 
[08:29:00.998]                               next
[08:29:00.998]                             invokeRestart(restart)
[08:29:00.998]                             muffled <- TRUE
[08:29:00.998]                             break
[08:29:00.998]                           }
[08:29:00.998]                         }
[08:29:00.998]                       }
[08:29:00.998]                       invisible(muffled)
[08:29:00.998]                     }
[08:29:00.998]                     muffleCondition(cond, pattern = "^muffle")
[08:29:00.998]                   }
[08:29:00.998]                 }
[08:29:00.998]             }
[08:29:00.998]         }))
[08:29:00.998]     }, error = function(ex) {
[08:29:00.998]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:00.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:00.998]                 ...future.rng), started = ...future.startTime, 
[08:29:00.998]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:00.998]             version = "1.8"), class = "FutureResult")
[08:29:00.998]     }, finally = {
[08:29:00.998]         if (!identical(...future.workdir, getwd())) 
[08:29:00.998]             setwd(...future.workdir)
[08:29:00.998]         {
[08:29:00.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:00.998]                 ...future.oldOptions$nwarnings <- NULL
[08:29:00.998]             }
[08:29:00.998]             base::options(...future.oldOptions)
[08:29:00.998]             if (.Platform$OS.type == "windows") {
[08:29:00.998]                 old_names <- names(...future.oldEnvVars)
[08:29:00.998]                 envs <- base::Sys.getenv()
[08:29:00.998]                 names <- names(envs)
[08:29:00.998]                 common <- intersect(names, old_names)
[08:29:00.998]                 added <- setdiff(names, old_names)
[08:29:00.998]                 removed <- setdiff(old_names, names)
[08:29:00.998]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:00.998]                   envs[common]]
[08:29:00.998]                 NAMES <- toupper(changed)
[08:29:00.998]                 args <- list()
[08:29:00.998]                 for (kk in seq_along(NAMES)) {
[08:29:00.998]                   name <- changed[[kk]]
[08:29:00.998]                   NAME <- NAMES[[kk]]
[08:29:00.998]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.998]                     next
[08:29:00.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.998]                 }
[08:29:00.998]                 NAMES <- toupper(added)
[08:29:00.998]                 for (kk in seq_along(NAMES)) {
[08:29:00.998]                   name <- added[[kk]]
[08:29:00.998]                   NAME <- NAMES[[kk]]
[08:29:00.998]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.998]                     next
[08:29:00.998]                   args[[name]] <- ""
[08:29:00.998]                 }
[08:29:00.998]                 NAMES <- toupper(removed)
[08:29:00.998]                 for (kk in seq_along(NAMES)) {
[08:29:00.998]                   name <- removed[[kk]]
[08:29:00.998]                   NAME <- NAMES[[kk]]
[08:29:00.998]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:00.998]                     next
[08:29:00.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:00.998]                 }
[08:29:00.998]                 if (length(args) > 0) 
[08:29:00.998]                   base::do.call(base::Sys.setenv, args = args)
[08:29:00.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:00.998]             }
[08:29:00.998]             else {
[08:29:00.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:00.998]             }
[08:29:00.998]             {
[08:29:00.998]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:00.998]                   0L) {
[08:29:00.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:00.998]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:00.998]                   base::options(opts)
[08:29:00.998]                 }
[08:29:00.998]                 {
[08:29:00.998]                   {
[08:29:00.998]                     NULL
[08:29:00.998]                     RNGkind("Mersenne-Twister")
[08:29:00.998]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:00.998]                       inherits = FALSE)
[08:29:00.998]                   }
[08:29:00.998]                   options(future.plan = NULL)
[08:29:00.998]                   if (is.na(NA_character_)) 
[08:29:00.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:00.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:00.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:00.998]                     .init = FALSE)
[08:29:00.998]                 }
[08:29:00.998]             }
[08:29:00.998]         }
[08:29:00.998]     })
[08:29:00.998]     if (TRUE) {
[08:29:00.998]         base::sink(type = "output", split = FALSE)
[08:29:00.998]         if (TRUE) {
[08:29:00.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:00.998]         }
[08:29:00.998]         else {
[08:29:00.998]             ...future.result["stdout"] <- base::list(NULL)
[08:29:00.998]         }
[08:29:00.998]         base::close(...future.stdout)
[08:29:00.998]         ...future.stdout <- NULL
[08:29:00.998]     }
[08:29:00.998]     ...future.result$conditions <- ...future.conditions
[08:29:00.998]     ...future.result$finished <- base::Sys.time()
[08:29:00.998]     ...future.result
[08:29:00.998] }
[08:29:00.999] plan(): Setting new future strategy stack:
[08:29:01.000] List of future strategies:
[08:29:01.000] 1. sequential:
[08:29:01.000]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.000]    - tweaked: FALSE
[08:29:01.000]    - call: NULL
[08:29:01.000] plan(): nbrOfWorkers() = 1
[08:29:01.001] plan(): Setting new future strategy stack:
[08:29:01.001] List of future strategies:
[08:29:01.001] 1. sequential:
[08:29:01.001]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.001]    - tweaked: FALSE
[08:29:01.001]    - call: plan(strategy)
[08:29:01.001] plan(): nbrOfWorkers() = 1
[08:29:01.001] SequentialFuture started (and completed)
[08:29:01.001] - Launch lazy future ... done
[08:29:01.001] run() for ‘SequentialFuture’ ... done
[08:29:01.002] resolve() on environment ...
[08:29:01.002]  recursive: 0
[08:29:01.002]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[08:29:01.003] resolved() for ‘SequentialFuture’ ...
[08:29:01.003] - state: ‘finished’
[08:29:01.003] - run: TRUE
[08:29:01.003] - result: ‘FutureResult’
[08:29:01.003] resolved() for ‘SequentialFuture’ ... done
[08:29:01.003] Future #1
[08:29:01.003]  length: 2 (resolved future 1)
[08:29:01.003] resolved() for ‘SequentialFuture’ ...
[08:29:01.003] - state: ‘finished’
[08:29:01.003] - run: TRUE
[08:29:01.003] - result: ‘FutureResult’
[08:29:01.004] resolved() for ‘SequentialFuture’ ... done
[08:29:01.004] Future #2
[08:29:01.004]  length: 1 (resolved future 2)
[08:29:01.004]  length: 0 (resolved future 3)
[08:29:01.004] resolve() on environment ... DONE
[08:29:01.004] getGlobalsAndPackages() ...
[08:29:01.004] Searching for globals...
[08:29:01.005] - globals found: [1] ‘{’
[08:29:01.005] Searching for globals ... DONE
[08:29:01.005] Resolving globals: FALSE
[08:29:01.005] 
[08:29:01.005] 
[08:29:01.005] getGlobalsAndPackages() ... DONE
[08:29:01.006] run() for ‘Future’ ...
[08:29:01.006] - state: ‘created’
[08:29:01.006] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:01.006] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:01.006] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:01.006]   - Field: ‘label’
[08:29:01.006]   - Field: ‘local’
[08:29:01.006]   - Field: ‘owner’
[08:29:01.007]   - Field: ‘envir’
[08:29:01.007]   - Field: ‘packages’
[08:29:01.007]   - Field: ‘gc’
[08:29:01.007]   - Field: ‘conditions’
[08:29:01.007]   - Field: ‘expr’
[08:29:01.007]   - Field: ‘uuid’
[08:29:01.007]   - Field: ‘seed’
[08:29:01.007]   - Field: ‘version’
[08:29:01.007]   - Field: ‘result’
[08:29:01.007]   - Field: ‘asynchronous’
[08:29:01.007]   - Field: ‘calls’
[08:29:01.007]   - Field: ‘globals’
[08:29:01.007]   - Field: ‘stdout’
[08:29:01.008]   - Field: ‘earlySignal’
[08:29:01.008]   - Field: ‘lazy’
[08:29:01.008]   - Field: ‘state’
[08:29:01.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:01.008] - Launch lazy future ...
[08:29:01.008] Packages needed by the future expression (n = 0): <none>
[08:29:01.008] Packages needed by future strategies (n = 0): <none>
[08:29:01.009] {
[08:29:01.009]     {
[08:29:01.009]         {
[08:29:01.009]             ...future.startTime <- base::Sys.time()
[08:29:01.009]             {
[08:29:01.009]                 {
[08:29:01.009]                   {
[08:29:01.009]                     base::local({
[08:29:01.009]                       has_future <- base::requireNamespace("future", 
[08:29:01.009]                         quietly = TRUE)
[08:29:01.009]                       if (has_future) {
[08:29:01.009]                         ns <- base::getNamespace("future")
[08:29:01.009]                         version <- ns[[".package"]][["version"]]
[08:29:01.009]                         if (is.null(version)) 
[08:29:01.009]                           version <- utils::packageVersion("future")
[08:29:01.009]                       }
[08:29:01.009]                       else {
[08:29:01.009]                         version <- NULL
[08:29:01.009]                       }
[08:29:01.009]                       if (!has_future || version < "1.8.0") {
[08:29:01.009]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.009]                           "", base::R.version$version.string), 
[08:29:01.009]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:01.009]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.009]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.009]                             "release", "version")], collapse = " "), 
[08:29:01.009]                           hostname = base::Sys.info()[["nodename"]])
[08:29:01.009]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.009]                           info)
[08:29:01.009]                         info <- base::paste(info, collapse = "; ")
[08:29:01.009]                         if (!has_future) {
[08:29:01.009]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.009]                             info)
[08:29:01.009]                         }
[08:29:01.009]                         else {
[08:29:01.009]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.009]                             info, version)
[08:29:01.009]                         }
[08:29:01.009]                         base::stop(msg)
[08:29:01.009]                       }
[08:29:01.009]                     })
[08:29:01.009]                   }
[08:29:01.009]                   ...future.strategy.old <- future::plan("list")
[08:29:01.009]                   options(future.plan = NULL)
[08:29:01.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.009]                 }
[08:29:01.009]                 ...future.workdir <- getwd()
[08:29:01.009]             }
[08:29:01.009]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.009]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.009]         }
[08:29:01.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.009]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.009]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.009]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.009]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.009]             base::names(...future.oldOptions))
[08:29:01.009]     }
[08:29:01.009]     if (FALSE) {
[08:29:01.009]     }
[08:29:01.009]     else {
[08:29:01.009]         if (TRUE) {
[08:29:01.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.009]                 open = "w")
[08:29:01.009]         }
[08:29:01.009]         else {
[08:29:01.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.009]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.009]         }
[08:29:01.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.009]             base::sink(type = "output", split = FALSE)
[08:29:01.009]             base::close(...future.stdout)
[08:29:01.009]         }, add = TRUE)
[08:29:01.009]     }
[08:29:01.009]     ...future.frame <- base::sys.nframe()
[08:29:01.009]     ...future.conditions <- base::list()
[08:29:01.009]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.009]     if (FALSE) {
[08:29:01.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.009]     }
[08:29:01.009]     ...future.result <- base::tryCatch({
[08:29:01.009]         base::withCallingHandlers({
[08:29:01.009]             ...future.value <- base::withVisible(base::local({
[08:29:01.009]                 1
[08:29:01.009]             }))
[08:29:01.009]             future::FutureResult(value = ...future.value$value, 
[08:29:01.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.009]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.009]                     ...future.globalenv.names))
[08:29:01.009]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.009]         }, condition = base::local({
[08:29:01.009]             c <- base::c
[08:29:01.009]             inherits <- base::inherits
[08:29:01.009]             invokeRestart <- base::invokeRestart
[08:29:01.009]             length <- base::length
[08:29:01.009]             list <- base::list
[08:29:01.009]             seq.int <- base::seq.int
[08:29:01.009]             signalCondition <- base::signalCondition
[08:29:01.009]             sys.calls <- base::sys.calls
[08:29:01.009]             `[[` <- base::`[[`
[08:29:01.009]             `+` <- base::`+`
[08:29:01.009]             `<<-` <- base::`<<-`
[08:29:01.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.009]                   3L)]
[08:29:01.009]             }
[08:29:01.009]             function(cond) {
[08:29:01.009]                 is_error <- inherits(cond, "error")
[08:29:01.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.009]                   NULL)
[08:29:01.009]                 if (is_error) {
[08:29:01.009]                   sessionInformation <- function() {
[08:29:01.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.009]                       search = base::search(), system = base::Sys.info())
[08:29:01.009]                   }
[08:29:01.009]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.009]                     cond$call), session = sessionInformation(), 
[08:29:01.009]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.009]                   signalCondition(cond)
[08:29:01.009]                 }
[08:29:01.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.009]                 "immediateCondition"))) {
[08:29:01.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.009]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.009]                   if (TRUE && !signal) {
[08:29:01.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.009]                     {
[08:29:01.009]                       inherits <- base::inherits
[08:29:01.009]                       invokeRestart <- base::invokeRestart
[08:29:01.009]                       is.null <- base::is.null
[08:29:01.009]                       muffled <- FALSE
[08:29:01.009]                       if (inherits(cond, "message")) {
[08:29:01.009]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.009]                         if (muffled) 
[08:29:01.009]                           invokeRestart("muffleMessage")
[08:29:01.009]                       }
[08:29:01.009]                       else if (inherits(cond, "warning")) {
[08:29:01.009]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.009]                         if (muffled) 
[08:29:01.009]                           invokeRestart("muffleWarning")
[08:29:01.009]                       }
[08:29:01.009]                       else if (inherits(cond, "condition")) {
[08:29:01.009]                         if (!is.null(pattern)) {
[08:29:01.009]                           computeRestarts <- base::computeRestarts
[08:29:01.009]                           grepl <- base::grepl
[08:29:01.009]                           restarts <- computeRestarts(cond)
[08:29:01.009]                           for (restart in restarts) {
[08:29:01.009]                             name <- restart$name
[08:29:01.009]                             if (is.null(name)) 
[08:29:01.009]                               next
[08:29:01.009]                             if (!grepl(pattern, name)) 
[08:29:01.009]                               next
[08:29:01.009]                             invokeRestart(restart)
[08:29:01.009]                             muffled <- TRUE
[08:29:01.009]                             break
[08:29:01.009]                           }
[08:29:01.009]                         }
[08:29:01.009]                       }
[08:29:01.009]                       invisible(muffled)
[08:29:01.009]                     }
[08:29:01.009]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.009]                   }
[08:29:01.009]                 }
[08:29:01.009]                 else {
[08:29:01.009]                   if (TRUE) {
[08:29:01.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.009]                     {
[08:29:01.009]                       inherits <- base::inherits
[08:29:01.009]                       invokeRestart <- base::invokeRestart
[08:29:01.009]                       is.null <- base::is.null
[08:29:01.009]                       muffled <- FALSE
[08:29:01.009]                       if (inherits(cond, "message")) {
[08:29:01.009]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.009]                         if (muffled) 
[08:29:01.009]                           invokeRestart("muffleMessage")
[08:29:01.009]                       }
[08:29:01.009]                       else if (inherits(cond, "warning")) {
[08:29:01.009]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.009]                         if (muffled) 
[08:29:01.009]                           invokeRestart("muffleWarning")
[08:29:01.009]                       }
[08:29:01.009]                       else if (inherits(cond, "condition")) {
[08:29:01.009]                         if (!is.null(pattern)) {
[08:29:01.009]                           computeRestarts <- base::computeRestarts
[08:29:01.009]                           grepl <- base::grepl
[08:29:01.009]                           restarts <- computeRestarts(cond)
[08:29:01.009]                           for (restart in restarts) {
[08:29:01.009]                             name <- restart$name
[08:29:01.009]                             if (is.null(name)) 
[08:29:01.009]                               next
[08:29:01.009]                             if (!grepl(pattern, name)) 
[08:29:01.009]                               next
[08:29:01.009]                             invokeRestart(restart)
[08:29:01.009]                             muffled <- TRUE
[08:29:01.009]                             break
[08:29:01.009]                           }
[08:29:01.009]                         }
[08:29:01.009]                       }
[08:29:01.009]                       invisible(muffled)
[08:29:01.009]                     }
[08:29:01.009]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.009]                   }
[08:29:01.009]                 }
[08:29:01.009]             }
[08:29:01.009]         }))
[08:29:01.009]     }, error = function(ex) {
[08:29:01.009]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.009]                 ...future.rng), started = ...future.startTime, 
[08:29:01.009]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.009]             version = "1.8"), class = "FutureResult")
[08:29:01.009]     }, finally = {
[08:29:01.009]         if (!identical(...future.workdir, getwd())) 
[08:29:01.009]             setwd(...future.workdir)
[08:29:01.009]         {
[08:29:01.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.009]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.009]             }
[08:29:01.009]             base::options(...future.oldOptions)
[08:29:01.009]             if (.Platform$OS.type == "windows") {
[08:29:01.009]                 old_names <- names(...future.oldEnvVars)
[08:29:01.009]                 envs <- base::Sys.getenv()
[08:29:01.009]                 names <- names(envs)
[08:29:01.009]                 common <- intersect(names, old_names)
[08:29:01.009]                 added <- setdiff(names, old_names)
[08:29:01.009]                 removed <- setdiff(old_names, names)
[08:29:01.009]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.009]                   envs[common]]
[08:29:01.009]                 NAMES <- toupper(changed)
[08:29:01.009]                 args <- list()
[08:29:01.009]                 for (kk in seq_along(NAMES)) {
[08:29:01.009]                   name <- changed[[kk]]
[08:29:01.009]                   NAME <- NAMES[[kk]]
[08:29:01.009]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.009]                     next
[08:29:01.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.009]                 }
[08:29:01.009]                 NAMES <- toupper(added)
[08:29:01.009]                 for (kk in seq_along(NAMES)) {
[08:29:01.009]                   name <- added[[kk]]
[08:29:01.009]                   NAME <- NAMES[[kk]]
[08:29:01.009]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.009]                     next
[08:29:01.009]                   args[[name]] <- ""
[08:29:01.009]                 }
[08:29:01.009]                 NAMES <- toupper(removed)
[08:29:01.009]                 for (kk in seq_along(NAMES)) {
[08:29:01.009]                   name <- removed[[kk]]
[08:29:01.009]                   NAME <- NAMES[[kk]]
[08:29:01.009]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.009]                     next
[08:29:01.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.009]                 }
[08:29:01.009]                 if (length(args) > 0) 
[08:29:01.009]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.009]             }
[08:29:01.009]             else {
[08:29:01.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.009]             }
[08:29:01.009]             {
[08:29:01.009]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.009]                   0L) {
[08:29:01.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.009]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.009]                   base::options(opts)
[08:29:01.009]                 }
[08:29:01.009]                 {
[08:29:01.009]                   {
[08:29:01.009]                     NULL
[08:29:01.009]                     RNGkind("Mersenne-Twister")
[08:29:01.009]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:01.009]                       inherits = FALSE)
[08:29:01.009]                   }
[08:29:01.009]                   options(future.plan = NULL)
[08:29:01.009]                   if (is.na(NA_character_)) 
[08:29:01.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.009]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.009]                     .init = FALSE)
[08:29:01.009]                 }
[08:29:01.009]             }
[08:29:01.009]         }
[08:29:01.009]     })
[08:29:01.009]     if (TRUE) {
[08:29:01.009]         base::sink(type = "output", split = FALSE)
[08:29:01.009]         if (TRUE) {
[08:29:01.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.009]         }
[08:29:01.009]         else {
[08:29:01.009]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.009]         }
[08:29:01.009]         base::close(...future.stdout)
[08:29:01.009]         ...future.stdout <- NULL
[08:29:01.009]     }
[08:29:01.009]     ...future.result$conditions <- ...future.conditions
[08:29:01.009]     ...future.result$finished <- base::Sys.time()
[08:29:01.009]     ...future.result
[08:29:01.009] }
[08:29:01.010] plan(): Setting new future strategy stack:
[08:29:01.010] List of future strategies:
[08:29:01.010] 1. sequential:
[08:29:01.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.010]    - tweaked: FALSE
[08:29:01.010]    - call: NULL
[08:29:01.011] plan(): nbrOfWorkers() = 1
[08:29:01.011] plan(): Setting new future strategy stack:
[08:29:01.012] List of future strategies:
[08:29:01.012] 1. sequential:
[08:29:01.012]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.012]    - tweaked: FALSE
[08:29:01.012]    - call: plan(strategy)
[08:29:01.012] plan(): nbrOfWorkers() = 1
[08:29:01.013] SequentialFuture started (and completed)
[08:29:01.013] - Launch lazy future ... done
[08:29:01.014] run() for ‘SequentialFuture’ ... done
[08:29:01.014] getGlobalsAndPackages() ...
[08:29:01.014] Searching for globals...
[08:29:01.014] - globals found: [1] ‘{’
[08:29:01.015] Searching for globals ... DONE
[08:29:01.015] Resolving globals: FALSE
[08:29:01.015] 
[08:29:01.015] 
[08:29:01.015] getGlobalsAndPackages() ... DONE
[08:29:01.015] run() for ‘Future’ ...
[08:29:01.015] - state: ‘created’
[08:29:01.015] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:01.016] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:01.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:01.016]   - Field: ‘label’
[08:29:01.016]   - Field: ‘local’
[08:29:01.016]   - Field: ‘owner’
[08:29:01.016]   - Field: ‘envir’
[08:29:01.016]   - Field: ‘packages’
[08:29:01.016]   - Field: ‘gc’
[08:29:01.016]   - Field: ‘conditions’
[08:29:01.016]   - Field: ‘expr’
[08:29:01.017]   - Field: ‘uuid’
[08:29:01.017]   - Field: ‘seed’
[08:29:01.017]   - Field: ‘version’
[08:29:01.017]   - Field: ‘result’
[08:29:01.017]   - Field: ‘asynchronous’
[08:29:01.017]   - Field: ‘calls’
[08:29:01.017]   - Field: ‘globals’
[08:29:01.017]   - Field: ‘stdout’
[08:29:01.017]   - Field: ‘earlySignal’
[08:29:01.017]   - Field: ‘lazy’
[08:29:01.017]   - Field: ‘state’
[08:29:01.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:01.018] - Launch lazy future ...
[08:29:01.018] Packages needed by the future expression (n = 0): <none>
[08:29:01.018] Packages needed by future strategies (n = 0): <none>
[08:29:01.018] {
[08:29:01.018]     {
[08:29:01.018]         {
[08:29:01.018]             ...future.startTime <- base::Sys.time()
[08:29:01.018]             {
[08:29:01.018]                 {
[08:29:01.018]                   {
[08:29:01.018]                     base::local({
[08:29:01.018]                       has_future <- base::requireNamespace("future", 
[08:29:01.018]                         quietly = TRUE)
[08:29:01.018]                       if (has_future) {
[08:29:01.018]                         ns <- base::getNamespace("future")
[08:29:01.018]                         version <- ns[[".package"]][["version"]]
[08:29:01.018]                         if (is.null(version)) 
[08:29:01.018]                           version <- utils::packageVersion("future")
[08:29:01.018]                       }
[08:29:01.018]                       else {
[08:29:01.018]                         version <- NULL
[08:29:01.018]                       }
[08:29:01.018]                       if (!has_future || version < "1.8.0") {
[08:29:01.018]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.018]                           "", base::R.version$version.string), 
[08:29:01.018]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:01.018]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.018]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.018]                             "release", "version")], collapse = " "), 
[08:29:01.018]                           hostname = base::Sys.info()[["nodename"]])
[08:29:01.018]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.018]                           info)
[08:29:01.018]                         info <- base::paste(info, collapse = "; ")
[08:29:01.018]                         if (!has_future) {
[08:29:01.018]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.018]                             info)
[08:29:01.018]                         }
[08:29:01.018]                         else {
[08:29:01.018]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.018]                             info, version)
[08:29:01.018]                         }
[08:29:01.018]                         base::stop(msg)
[08:29:01.018]                       }
[08:29:01.018]                     })
[08:29:01.018]                   }
[08:29:01.018]                   ...future.strategy.old <- future::plan("list")
[08:29:01.018]                   options(future.plan = NULL)
[08:29:01.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.018]                 }
[08:29:01.018]                 ...future.workdir <- getwd()
[08:29:01.018]             }
[08:29:01.018]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.018]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.018]         }
[08:29:01.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.018]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.018]             base::names(...future.oldOptions))
[08:29:01.018]     }
[08:29:01.018]     if (FALSE) {
[08:29:01.018]     }
[08:29:01.018]     else {
[08:29:01.018]         if (TRUE) {
[08:29:01.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.018]                 open = "w")
[08:29:01.018]         }
[08:29:01.018]         else {
[08:29:01.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.018]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.018]         }
[08:29:01.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.018]             base::sink(type = "output", split = FALSE)
[08:29:01.018]             base::close(...future.stdout)
[08:29:01.018]         }, add = TRUE)
[08:29:01.018]     }
[08:29:01.018]     ...future.frame <- base::sys.nframe()
[08:29:01.018]     ...future.conditions <- base::list()
[08:29:01.018]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.018]     if (FALSE) {
[08:29:01.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.018]     }
[08:29:01.018]     ...future.result <- base::tryCatch({
[08:29:01.018]         base::withCallingHandlers({
[08:29:01.018]             ...future.value <- base::withVisible(base::local({
[08:29:01.018]                 2
[08:29:01.018]             }))
[08:29:01.018]             future::FutureResult(value = ...future.value$value, 
[08:29:01.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.018]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.018]                     ...future.globalenv.names))
[08:29:01.018]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.018]         }, condition = base::local({
[08:29:01.018]             c <- base::c
[08:29:01.018]             inherits <- base::inherits
[08:29:01.018]             invokeRestart <- base::invokeRestart
[08:29:01.018]             length <- base::length
[08:29:01.018]             list <- base::list
[08:29:01.018]             seq.int <- base::seq.int
[08:29:01.018]             signalCondition <- base::signalCondition
[08:29:01.018]             sys.calls <- base::sys.calls
[08:29:01.018]             `[[` <- base::`[[`
[08:29:01.018]             `+` <- base::`+`
[08:29:01.018]             `<<-` <- base::`<<-`
[08:29:01.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.018]                   3L)]
[08:29:01.018]             }
[08:29:01.018]             function(cond) {
[08:29:01.018]                 is_error <- inherits(cond, "error")
[08:29:01.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.018]                   NULL)
[08:29:01.018]                 if (is_error) {
[08:29:01.018]                   sessionInformation <- function() {
[08:29:01.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.018]                       search = base::search(), system = base::Sys.info())
[08:29:01.018]                   }
[08:29:01.018]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.018]                     cond$call), session = sessionInformation(), 
[08:29:01.018]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.018]                   signalCondition(cond)
[08:29:01.018]                 }
[08:29:01.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.018]                 "immediateCondition"))) {
[08:29:01.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.018]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.018]                   if (TRUE && !signal) {
[08:29:01.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.018]                     {
[08:29:01.018]                       inherits <- base::inherits
[08:29:01.018]                       invokeRestart <- base::invokeRestart
[08:29:01.018]                       is.null <- base::is.null
[08:29:01.018]                       muffled <- FALSE
[08:29:01.018]                       if (inherits(cond, "message")) {
[08:29:01.018]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.018]                         if (muffled) 
[08:29:01.018]                           invokeRestart("muffleMessage")
[08:29:01.018]                       }
[08:29:01.018]                       else if (inherits(cond, "warning")) {
[08:29:01.018]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.018]                         if (muffled) 
[08:29:01.018]                           invokeRestart("muffleWarning")
[08:29:01.018]                       }
[08:29:01.018]                       else if (inherits(cond, "condition")) {
[08:29:01.018]                         if (!is.null(pattern)) {
[08:29:01.018]                           computeRestarts <- base::computeRestarts
[08:29:01.018]                           grepl <- base::grepl
[08:29:01.018]                           restarts <- computeRestarts(cond)
[08:29:01.018]                           for (restart in restarts) {
[08:29:01.018]                             name <- restart$name
[08:29:01.018]                             if (is.null(name)) 
[08:29:01.018]                               next
[08:29:01.018]                             if (!grepl(pattern, name)) 
[08:29:01.018]                               next
[08:29:01.018]                             invokeRestart(restart)
[08:29:01.018]                             muffled <- TRUE
[08:29:01.018]                             break
[08:29:01.018]                           }
[08:29:01.018]                         }
[08:29:01.018]                       }
[08:29:01.018]                       invisible(muffled)
[08:29:01.018]                     }
[08:29:01.018]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.018]                   }
[08:29:01.018]                 }
[08:29:01.018]                 else {
[08:29:01.018]                   if (TRUE) {
[08:29:01.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.018]                     {
[08:29:01.018]                       inherits <- base::inherits
[08:29:01.018]                       invokeRestart <- base::invokeRestart
[08:29:01.018]                       is.null <- base::is.null
[08:29:01.018]                       muffled <- FALSE
[08:29:01.018]                       if (inherits(cond, "message")) {
[08:29:01.018]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.018]                         if (muffled) 
[08:29:01.018]                           invokeRestart("muffleMessage")
[08:29:01.018]                       }
[08:29:01.018]                       else if (inherits(cond, "warning")) {
[08:29:01.018]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.018]                         if (muffled) 
[08:29:01.018]                           invokeRestart("muffleWarning")
[08:29:01.018]                       }
[08:29:01.018]                       else if (inherits(cond, "condition")) {
[08:29:01.018]                         if (!is.null(pattern)) {
[08:29:01.018]                           computeRestarts <- base::computeRestarts
[08:29:01.018]                           grepl <- base::grepl
[08:29:01.018]                           restarts <- computeRestarts(cond)
[08:29:01.018]                           for (restart in restarts) {
[08:29:01.018]                             name <- restart$name
[08:29:01.018]                             if (is.null(name)) 
[08:29:01.018]                               next
[08:29:01.018]                             if (!grepl(pattern, name)) 
[08:29:01.018]                               next
[08:29:01.018]                             invokeRestart(restart)
[08:29:01.018]                             muffled <- TRUE
[08:29:01.018]                             break
[08:29:01.018]                           }
[08:29:01.018]                         }
[08:29:01.018]                       }
[08:29:01.018]                       invisible(muffled)
[08:29:01.018]                     }
[08:29:01.018]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.018]                   }
[08:29:01.018]                 }
[08:29:01.018]             }
[08:29:01.018]         }))
[08:29:01.018]     }, error = function(ex) {
[08:29:01.018]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.018]                 ...future.rng), started = ...future.startTime, 
[08:29:01.018]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.018]             version = "1.8"), class = "FutureResult")
[08:29:01.018]     }, finally = {
[08:29:01.018]         if (!identical(...future.workdir, getwd())) 
[08:29:01.018]             setwd(...future.workdir)
[08:29:01.018]         {
[08:29:01.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.018]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.018]             }
[08:29:01.018]             base::options(...future.oldOptions)
[08:29:01.018]             if (.Platform$OS.type == "windows") {
[08:29:01.018]                 old_names <- names(...future.oldEnvVars)
[08:29:01.018]                 envs <- base::Sys.getenv()
[08:29:01.018]                 names <- names(envs)
[08:29:01.018]                 common <- intersect(names, old_names)
[08:29:01.018]                 added <- setdiff(names, old_names)
[08:29:01.018]                 removed <- setdiff(old_names, names)
[08:29:01.018]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.018]                   envs[common]]
[08:29:01.018]                 NAMES <- toupper(changed)
[08:29:01.018]                 args <- list()
[08:29:01.018]                 for (kk in seq_along(NAMES)) {
[08:29:01.018]                   name <- changed[[kk]]
[08:29:01.018]                   NAME <- NAMES[[kk]]
[08:29:01.018]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.018]                     next
[08:29:01.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.018]                 }
[08:29:01.018]                 NAMES <- toupper(added)
[08:29:01.018]                 for (kk in seq_along(NAMES)) {
[08:29:01.018]                   name <- added[[kk]]
[08:29:01.018]                   NAME <- NAMES[[kk]]
[08:29:01.018]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.018]                     next
[08:29:01.018]                   args[[name]] <- ""
[08:29:01.018]                 }
[08:29:01.018]                 NAMES <- toupper(removed)
[08:29:01.018]                 for (kk in seq_along(NAMES)) {
[08:29:01.018]                   name <- removed[[kk]]
[08:29:01.018]                   NAME <- NAMES[[kk]]
[08:29:01.018]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.018]                     next
[08:29:01.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.018]                 }
[08:29:01.018]                 if (length(args) > 0) 
[08:29:01.018]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.018]             }
[08:29:01.018]             else {
[08:29:01.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.018]             }
[08:29:01.018]             {
[08:29:01.018]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.018]                   0L) {
[08:29:01.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.018]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.018]                   base::options(opts)
[08:29:01.018]                 }
[08:29:01.018]                 {
[08:29:01.018]                   {
[08:29:01.018]                     NULL
[08:29:01.018]                     RNGkind("Mersenne-Twister")
[08:29:01.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:01.018]                       inherits = FALSE)
[08:29:01.018]                   }
[08:29:01.018]                   options(future.plan = NULL)
[08:29:01.018]                   if (is.na(NA_character_)) 
[08:29:01.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.018]                     .init = FALSE)
[08:29:01.018]                 }
[08:29:01.018]             }
[08:29:01.018]         }
[08:29:01.018]     })
[08:29:01.018]     if (TRUE) {
[08:29:01.018]         base::sink(type = "output", split = FALSE)
[08:29:01.018]         if (TRUE) {
[08:29:01.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.018]         }
[08:29:01.018]         else {
[08:29:01.018]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.018]         }
[08:29:01.018]         base::close(...future.stdout)
[08:29:01.018]         ...future.stdout <- NULL
[08:29:01.018]     }
[08:29:01.018]     ...future.result$conditions <- ...future.conditions
[08:29:01.018]     ...future.result$finished <- base::Sys.time()
[08:29:01.018]     ...future.result
[08:29:01.018] }
[08:29:01.020] plan(): Setting new future strategy stack:
[08:29:01.020] List of future strategies:
[08:29:01.020] 1. sequential:
[08:29:01.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.020]    - tweaked: FALSE
[08:29:01.020]    - call: NULL
[08:29:01.020] plan(): nbrOfWorkers() = 1
[08:29:01.021] plan(): Setting new future strategy stack:
[08:29:01.021] List of future strategies:
[08:29:01.021] 1. sequential:
[08:29:01.021]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.021]    - tweaked: FALSE
[08:29:01.021]    - call: plan(strategy)
[08:29:01.021] plan(): nbrOfWorkers() = 1
[08:29:01.022] SequentialFuture started (and completed)
[08:29:01.022] - Launch lazy future ... done
[08:29:01.022] run() for ‘SequentialFuture’ ... done
[08:29:01.022] resolve() on environment ...
[08:29:01.022]  recursive: 0
[08:29:01.023]  elements: [3] ‘a’
[08:29:01.023] resolved() for ‘SequentialFuture’ ...
[08:29:01.023] - state: ‘finished’
[08:29:01.023] - run: TRUE
[08:29:01.023] - result: ‘FutureResult’
[08:29:01.023] resolved() for ‘SequentialFuture’ ... done
[08:29:01.023] Future #1
[08:29:01.023]  length: 2 (resolved future 1)
[08:29:01.023] resolved() for ‘SequentialFuture’ ...
[08:29:01.024] - state: ‘finished’
[08:29:01.024] - run: TRUE
[08:29:01.024] - result: ‘FutureResult’
[08:29:01.024] resolved() for ‘SequentialFuture’ ... done
[08:29:01.024] Future #2
[08:29:01.024]  length: 1 (resolved future 2)
[08:29:01.024]  length: 0 (resolved future 3)
[08:29:01.024] resolve() on environment ... DONE
[08:29:01.024] resolved() for ‘SequentialFuture’ ...
[08:29:01.024] - state: ‘finished’
[08:29:01.024] - run: TRUE
[08:29:01.024] - result: ‘FutureResult’
[08:29:01.025] resolved() for ‘SequentialFuture’ ... done
[08:29:01.025] resolve() on environment ...
[08:29:01.025]  recursive: 0
[08:29:01.026]  elements: [3] ‘b’
[08:29:01.026] resolved() for ‘SequentialFuture’ ...
[08:29:01.026] - state: ‘finished’
[08:29:01.026] - run: TRUE
[08:29:01.026] - result: ‘FutureResult’
[08:29:01.026] resolved() for ‘SequentialFuture’ ... done
[08:29:01.026] Future #1
[08:29:01.026]  length: 2 (resolved future 1)
[08:29:01.026] resolved() for ‘SequentialFuture’ ...
[08:29:01.026] - state: ‘finished’
[08:29:01.026] - run: TRUE
[08:29:01.026] - result: ‘FutureResult’
[08:29:01.027] resolved() for ‘SequentialFuture’ ... done
[08:29:01.027] Future #2
[08:29:01.027]  length: 1 (resolved future 2)
[08:29:01.027]  length: 0 (resolved future 3)
[08:29:01.027] resolve() on environment ... DONE
[08:29:01.027] resolve() on environment ...
[08:29:01.027]  recursive: 0
[08:29:01.028]  elements: [3] ‘c’
[08:29:01.028] resolved() for ‘SequentialFuture’ ...
[08:29:01.028] - state: ‘finished’
[08:29:01.028] - run: TRUE
[08:29:01.028] - result: ‘FutureResult’
[08:29:01.028] resolved() for ‘SequentialFuture’ ... done
[08:29:01.028] Future #1
[08:29:01.028]  length: 2 (resolved future 1)
[08:29:01.028] resolved() for ‘SequentialFuture’ ...
[08:29:01.029] - state: ‘finished’
[08:29:01.029] - run: TRUE
[08:29:01.029] - result: ‘FutureResult’
[08:29:01.029] resolved() for ‘SequentialFuture’ ... done
[08:29:01.029] Future #2
[08:29:01.029]  length: 1 (resolved future 2)
[08:29:01.029]  length: 0 (resolved future 3)
[08:29:01.029] resolve() on environment ... DONE
[08:29:01.030] resolve() on environment ...
[08:29:01.030]  recursive: 0
[08:29:01.030]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[08:29:01.030] resolved() for ‘SequentialFuture’ ...
[08:29:01.030] - state: ‘finished’
[08:29:01.030] - run: TRUE
[08:29:01.030] - result: ‘FutureResult’
[08:29:01.030] resolved() for ‘SequentialFuture’ ... done
[08:29:01.030] Future #1
[08:29:01.031]  length: 2 (resolved future 1)
[08:29:01.031] resolved() for ‘SequentialFuture’ ...
[08:29:01.031] - state: ‘finished’
[08:29:01.031] - run: TRUE
[08:29:01.031] - result: ‘FutureResult’
[08:29:01.031] resolved() for ‘SequentialFuture’ ... done
[08:29:01.031] Future #2
[08:29:01.032]  length: 1 (resolved future 2)
[08:29:01.032]  length: 0 (resolved future 3)
[08:29:01.032] resolve() on environment ... DONE
[08:29:01.032] resolve() on environment ...
[08:29:01.032]  recursive: 99
[08:29:01.033]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[08:29:01.033] resolved() for ‘SequentialFuture’ ...
[08:29:01.033] - state: ‘finished’
[08:29:01.033] - run: TRUE
[08:29:01.033] - result: ‘FutureResult’
[08:29:01.033] resolved() for ‘SequentialFuture’ ... done
[08:29:01.033] Future #1
[08:29:01.033] resolved() for ‘SequentialFuture’ ...
[08:29:01.033] - state: ‘finished’
[08:29:01.033] - run: TRUE
[08:29:01.033] - result: ‘FutureResult’
[08:29:01.034] resolved() for ‘SequentialFuture’ ... done
[08:29:01.034] A SequentialFuture was resolved
[08:29:01.034]  length: 2 (resolved future 1)
[08:29:01.034] resolved() for ‘SequentialFuture’ ...
[08:29:01.034] - state: ‘finished’
[08:29:01.034] - run: TRUE
[08:29:01.034] - result: ‘FutureResult’
[08:29:01.034] resolved() for ‘SequentialFuture’ ... done
[08:29:01.034] Future #2
[08:29:01.034] resolved() for ‘SequentialFuture’ ...
[08:29:01.034] - state: ‘finished’
[08:29:01.035] - run: TRUE
[08:29:01.035] - result: ‘FutureResult’
[08:29:01.036] resolved() for ‘SequentialFuture’ ... done
[08:29:01.036] A SequentialFuture was resolved
[08:29:01.036]  length: 1 (resolved future 2)
[08:29:01.036]  length: 0 (resolved future 3)
[08:29:01.036] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[08:29:01.037] resolve() on list environment ...
[08:29:01.037]  recursive: 0
[08:29:01.038]  length: 2
[08:29:01.038]  elements: ‘a’, ‘b’
[08:29:01.038]  length: 1 (resolved future 1)
[08:29:01.038]  length: 0 (resolved future 2)
[08:29:01.038] resolve() on list environment ... DONE
[08:29:01.038] getGlobalsAndPackages() ...
[08:29:01.038] Searching for globals...
[08:29:01.039] 
[08:29:01.039] Searching for globals ... DONE
[08:29:01.039] - globals: [0] <none>
[08:29:01.039] getGlobalsAndPackages() ... DONE
[08:29:01.039] run() for ‘Future’ ...
[08:29:01.039] - state: ‘created’
[08:29:01.039] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:01.040] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:01.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:01.040]   - Field: ‘label’
[08:29:01.040]   - Field: ‘local’
[08:29:01.040]   - Field: ‘owner’
[08:29:01.040]   - Field: ‘envir’
[08:29:01.040]   - Field: ‘packages’
[08:29:01.040]   - Field: ‘gc’
[08:29:01.040]   - Field: ‘conditions’
[08:29:01.040]   - Field: ‘expr’
[08:29:01.040]   - Field: ‘uuid’
[08:29:01.040]   - Field: ‘seed’
[08:29:01.041]   - Field: ‘version’
[08:29:01.041]   - Field: ‘result’
[08:29:01.041]   - Field: ‘asynchronous’
[08:29:01.041]   - Field: ‘calls’
[08:29:01.041]   - Field: ‘globals’
[08:29:01.041]   - Field: ‘stdout’
[08:29:01.041]   - Field: ‘earlySignal’
[08:29:01.041]   - Field: ‘lazy’
[08:29:01.041]   - Field: ‘state’
[08:29:01.041] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:01.041] - Launch lazy future ...
[08:29:01.041] Packages needed by the future expression (n = 0): <none>
[08:29:01.042] Packages needed by future strategies (n = 0): <none>
[08:29:01.042] {
[08:29:01.042]     {
[08:29:01.042]         {
[08:29:01.042]             ...future.startTime <- base::Sys.time()
[08:29:01.042]             {
[08:29:01.042]                 {
[08:29:01.042]                   {
[08:29:01.042]                     base::local({
[08:29:01.042]                       has_future <- base::requireNamespace("future", 
[08:29:01.042]                         quietly = TRUE)
[08:29:01.042]                       if (has_future) {
[08:29:01.042]                         ns <- base::getNamespace("future")
[08:29:01.042]                         version <- ns[[".package"]][["version"]]
[08:29:01.042]                         if (is.null(version)) 
[08:29:01.042]                           version <- utils::packageVersion("future")
[08:29:01.042]                       }
[08:29:01.042]                       else {
[08:29:01.042]                         version <- NULL
[08:29:01.042]                       }
[08:29:01.042]                       if (!has_future || version < "1.8.0") {
[08:29:01.042]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.042]                           "", base::R.version$version.string), 
[08:29:01.042]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:01.042]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.042]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.042]                             "release", "version")], collapse = " "), 
[08:29:01.042]                           hostname = base::Sys.info()[["nodename"]])
[08:29:01.042]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.042]                           info)
[08:29:01.042]                         info <- base::paste(info, collapse = "; ")
[08:29:01.042]                         if (!has_future) {
[08:29:01.042]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.042]                             info)
[08:29:01.042]                         }
[08:29:01.042]                         else {
[08:29:01.042]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.042]                             info, version)
[08:29:01.042]                         }
[08:29:01.042]                         base::stop(msg)
[08:29:01.042]                       }
[08:29:01.042]                     })
[08:29:01.042]                   }
[08:29:01.042]                   ...future.strategy.old <- future::plan("list")
[08:29:01.042]                   options(future.plan = NULL)
[08:29:01.042]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.042]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.042]                 }
[08:29:01.042]                 ...future.workdir <- getwd()
[08:29:01.042]             }
[08:29:01.042]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.042]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.042]         }
[08:29:01.042]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.042]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.042]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.042]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.042]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.042]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.042]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.042]             base::names(...future.oldOptions))
[08:29:01.042]     }
[08:29:01.042]     if (FALSE) {
[08:29:01.042]     }
[08:29:01.042]     else {
[08:29:01.042]         if (TRUE) {
[08:29:01.042]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.042]                 open = "w")
[08:29:01.042]         }
[08:29:01.042]         else {
[08:29:01.042]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.042]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.042]         }
[08:29:01.042]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.042]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.042]             base::sink(type = "output", split = FALSE)
[08:29:01.042]             base::close(...future.stdout)
[08:29:01.042]         }, add = TRUE)
[08:29:01.042]     }
[08:29:01.042]     ...future.frame <- base::sys.nframe()
[08:29:01.042]     ...future.conditions <- base::list()
[08:29:01.042]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.042]     if (FALSE) {
[08:29:01.042]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.042]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.042]     }
[08:29:01.042]     ...future.result <- base::tryCatch({
[08:29:01.042]         base::withCallingHandlers({
[08:29:01.042]             ...future.value <- base::withVisible(base::local(1))
[08:29:01.042]             future::FutureResult(value = ...future.value$value, 
[08:29:01.042]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.042]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.042]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.042]                     ...future.globalenv.names))
[08:29:01.042]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.042]         }, condition = base::local({
[08:29:01.042]             c <- base::c
[08:29:01.042]             inherits <- base::inherits
[08:29:01.042]             invokeRestart <- base::invokeRestart
[08:29:01.042]             length <- base::length
[08:29:01.042]             list <- base::list
[08:29:01.042]             seq.int <- base::seq.int
[08:29:01.042]             signalCondition <- base::signalCondition
[08:29:01.042]             sys.calls <- base::sys.calls
[08:29:01.042]             `[[` <- base::`[[`
[08:29:01.042]             `+` <- base::`+`
[08:29:01.042]             `<<-` <- base::`<<-`
[08:29:01.042]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.042]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.042]                   3L)]
[08:29:01.042]             }
[08:29:01.042]             function(cond) {
[08:29:01.042]                 is_error <- inherits(cond, "error")
[08:29:01.042]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.042]                   NULL)
[08:29:01.042]                 if (is_error) {
[08:29:01.042]                   sessionInformation <- function() {
[08:29:01.042]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.042]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.042]                       search = base::search(), system = base::Sys.info())
[08:29:01.042]                   }
[08:29:01.042]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.042]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.042]                     cond$call), session = sessionInformation(), 
[08:29:01.042]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.042]                   signalCondition(cond)
[08:29:01.042]                 }
[08:29:01.042]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.042]                 "immediateCondition"))) {
[08:29:01.042]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.042]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.042]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.042]                   if (TRUE && !signal) {
[08:29:01.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.042]                     {
[08:29:01.042]                       inherits <- base::inherits
[08:29:01.042]                       invokeRestart <- base::invokeRestart
[08:29:01.042]                       is.null <- base::is.null
[08:29:01.042]                       muffled <- FALSE
[08:29:01.042]                       if (inherits(cond, "message")) {
[08:29:01.042]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.042]                         if (muffled) 
[08:29:01.042]                           invokeRestart("muffleMessage")
[08:29:01.042]                       }
[08:29:01.042]                       else if (inherits(cond, "warning")) {
[08:29:01.042]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.042]                         if (muffled) 
[08:29:01.042]                           invokeRestart("muffleWarning")
[08:29:01.042]                       }
[08:29:01.042]                       else if (inherits(cond, "condition")) {
[08:29:01.042]                         if (!is.null(pattern)) {
[08:29:01.042]                           computeRestarts <- base::computeRestarts
[08:29:01.042]                           grepl <- base::grepl
[08:29:01.042]                           restarts <- computeRestarts(cond)
[08:29:01.042]                           for (restart in restarts) {
[08:29:01.042]                             name <- restart$name
[08:29:01.042]                             if (is.null(name)) 
[08:29:01.042]                               next
[08:29:01.042]                             if (!grepl(pattern, name)) 
[08:29:01.042]                               next
[08:29:01.042]                             invokeRestart(restart)
[08:29:01.042]                             muffled <- TRUE
[08:29:01.042]                             break
[08:29:01.042]                           }
[08:29:01.042]                         }
[08:29:01.042]                       }
[08:29:01.042]                       invisible(muffled)
[08:29:01.042]                     }
[08:29:01.042]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.042]                   }
[08:29:01.042]                 }
[08:29:01.042]                 else {
[08:29:01.042]                   if (TRUE) {
[08:29:01.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.042]                     {
[08:29:01.042]                       inherits <- base::inherits
[08:29:01.042]                       invokeRestart <- base::invokeRestart
[08:29:01.042]                       is.null <- base::is.null
[08:29:01.042]                       muffled <- FALSE
[08:29:01.042]                       if (inherits(cond, "message")) {
[08:29:01.042]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.042]                         if (muffled) 
[08:29:01.042]                           invokeRestart("muffleMessage")
[08:29:01.042]                       }
[08:29:01.042]                       else if (inherits(cond, "warning")) {
[08:29:01.042]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.042]                         if (muffled) 
[08:29:01.042]                           invokeRestart("muffleWarning")
[08:29:01.042]                       }
[08:29:01.042]                       else if (inherits(cond, "condition")) {
[08:29:01.042]                         if (!is.null(pattern)) {
[08:29:01.042]                           computeRestarts <- base::computeRestarts
[08:29:01.042]                           grepl <- base::grepl
[08:29:01.042]                           restarts <- computeRestarts(cond)
[08:29:01.042]                           for (restart in restarts) {
[08:29:01.042]                             name <- restart$name
[08:29:01.042]                             if (is.null(name)) 
[08:29:01.042]                               next
[08:29:01.042]                             if (!grepl(pattern, name)) 
[08:29:01.042]                               next
[08:29:01.042]                             invokeRestart(restart)
[08:29:01.042]                             muffled <- TRUE
[08:29:01.042]                             break
[08:29:01.042]                           }
[08:29:01.042]                         }
[08:29:01.042]                       }
[08:29:01.042]                       invisible(muffled)
[08:29:01.042]                     }
[08:29:01.042]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.042]                   }
[08:29:01.042]                 }
[08:29:01.042]             }
[08:29:01.042]         }))
[08:29:01.042]     }, error = function(ex) {
[08:29:01.042]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.042]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.042]                 ...future.rng), started = ...future.startTime, 
[08:29:01.042]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.042]             version = "1.8"), class = "FutureResult")
[08:29:01.042]     }, finally = {
[08:29:01.042]         if (!identical(...future.workdir, getwd())) 
[08:29:01.042]             setwd(...future.workdir)
[08:29:01.042]         {
[08:29:01.042]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.042]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.042]             }
[08:29:01.042]             base::options(...future.oldOptions)
[08:29:01.042]             if (.Platform$OS.type == "windows") {
[08:29:01.042]                 old_names <- names(...future.oldEnvVars)
[08:29:01.042]                 envs <- base::Sys.getenv()
[08:29:01.042]                 names <- names(envs)
[08:29:01.042]                 common <- intersect(names, old_names)
[08:29:01.042]                 added <- setdiff(names, old_names)
[08:29:01.042]                 removed <- setdiff(old_names, names)
[08:29:01.042]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.042]                   envs[common]]
[08:29:01.042]                 NAMES <- toupper(changed)
[08:29:01.042]                 args <- list()
[08:29:01.042]                 for (kk in seq_along(NAMES)) {
[08:29:01.042]                   name <- changed[[kk]]
[08:29:01.042]                   NAME <- NAMES[[kk]]
[08:29:01.042]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.042]                     next
[08:29:01.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.042]                 }
[08:29:01.042]                 NAMES <- toupper(added)
[08:29:01.042]                 for (kk in seq_along(NAMES)) {
[08:29:01.042]                   name <- added[[kk]]
[08:29:01.042]                   NAME <- NAMES[[kk]]
[08:29:01.042]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.042]                     next
[08:29:01.042]                   args[[name]] <- ""
[08:29:01.042]                 }
[08:29:01.042]                 NAMES <- toupper(removed)
[08:29:01.042]                 for (kk in seq_along(NAMES)) {
[08:29:01.042]                   name <- removed[[kk]]
[08:29:01.042]                   NAME <- NAMES[[kk]]
[08:29:01.042]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.042]                     next
[08:29:01.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.042]                 }
[08:29:01.042]                 if (length(args) > 0) 
[08:29:01.042]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.042]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.042]             }
[08:29:01.042]             else {
[08:29:01.042]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.042]             }
[08:29:01.042]             {
[08:29:01.042]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.042]                   0L) {
[08:29:01.042]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.042]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.042]                   base::options(opts)
[08:29:01.042]                 }
[08:29:01.042]                 {
[08:29:01.042]                   {
[08:29:01.042]                     NULL
[08:29:01.042]                     RNGkind("Mersenne-Twister")
[08:29:01.042]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:01.042]                       inherits = FALSE)
[08:29:01.042]                   }
[08:29:01.042]                   options(future.plan = NULL)
[08:29:01.042]                   if (is.na(NA_character_)) 
[08:29:01.042]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.042]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.042]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.042]                     .init = FALSE)
[08:29:01.042]                 }
[08:29:01.042]             }
[08:29:01.042]         }
[08:29:01.042]     })
[08:29:01.042]     if (TRUE) {
[08:29:01.042]         base::sink(type = "output", split = FALSE)
[08:29:01.042]         if (TRUE) {
[08:29:01.042]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.042]         }
[08:29:01.042]         else {
[08:29:01.042]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.042]         }
[08:29:01.042]         base::close(...future.stdout)
[08:29:01.042]         ...future.stdout <- NULL
[08:29:01.042]     }
[08:29:01.042]     ...future.result$conditions <- ...future.conditions
[08:29:01.042]     ...future.result$finished <- base::Sys.time()
[08:29:01.042]     ...future.result
[08:29:01.042] }
[08:29:01.044] plan(): Setting new future strategy stack:
[08:29:01.044] List of future strategies:
[08:29:01.044] 1. sequential:
[08:29:01.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.044]    - tweaked: FALSE
[08:29:01.044]    - call: NULL
[08:29:01.044] plan(): nbrOfWorkers() = 1
[08:29:01.045] plan(): Setting new future strategy stack:
[08:29:01.045] List of future strategies:
[08:29:01.045] 1. sequential:
[08:29:01.045]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.045]    - tweaked: FALSE
[08:29:01.045]    - call: plan(strategy)
[08:29:01.045] plan(): nbrOfWorkers() = 1
[08:29:01.045] SequentialFuture started (and completed)
[08:29:01.046] - Launch lazy future ... done
[08:29:01.046] run() for ‘SequentialFuture’ ... done
[08:29:01.046] getGlobalsAndPackages() ...
[08:29:01.046] Searching for globals...
[08:29:01.046] 
[08:29:01.046] Searching for globals ... DONE
[08:29:01.046] - globals: [0] <none>
[08:29:01.046] getGlobalsAndPackages() ... DONE
[08:29:01.047] run() for ‘Future’ ...
[08:29:01.047] - state: ‘created’
[08:29:01.047] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:01.047] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:01.047] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:01.047]   - Field: ‘label’
[08:29:01.047]   - Field: ‘local’
[08:29:01.047]   - Field: ‘owner’
[08:29:01.047]   - Field: ‘envir’
[08:29:01.048]   - Field: ‘packages’
[08:29:01.048]   - Field: ‘gc’
[08:29:01.048]   - Field: ‘conditions’
[08:29:01.048]   - Field: ‘expr’
[08:29:01.048]   - Field: ‘uuid’
[08:29:01.048]   - Field: ‘seed’
[08:29:01.048]   - Field: ‘version’
[08:29:01.048]   - Field: ‘result’
[08:29:01.048]   - Field: ‘asynchronous’
[08:29:01.048]   - Field: ‘calls’
[08:29:01.048]   - Field: ‘globals’
[08:29:01.048]   - Field: ‘stdout’
[08:29:01.048]   - Field: ‘earlySignal’
[08:29:01.049]   - Field: ‘lazy’
[08:29:01.049]   - Field: ‘state’
[08:29:01.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:01.049] - Launch lazy future ...
[08:29:01.049] Packages needed by the future expression (n = 0): <none>
[08:29:01.049] Packages needed by future strategies (n = 0): <none>
[08:29:01.049] {
[08:29:01.049]     {
[08:29:01.049]         {
[08:29:01.049]             ...future.startTime <- base::Sys.time()
[08:29:01.049]             {
[08:29:01.049]                 {
[08:29:01.049]                   {
[08:29:01.049]                     base::local({
[08:29:01.049]                       has_future <- base::requireNamespace("future", 
[08:29:01.049]                         quietly = TRUE)
[08:29:01.049]                       if (has_future) {
[08:29:01.049]                         ns <- base::getNamespace("future")
[08:29:01.049]                         version <- ns[[".package"]][["version"]]
[08:29:01.049]                         if (is.null(version)) 
[08:29:01.049]                           version <- utils::packageVersion("future")
[08:29:01.049]                       }
[08:29:01.049]                       else {
[08:29:01.049]                         version <- NULL
[08:29:01.049]                       }
[08:29:01.049]                       if (!has_future || version < "1.8.0") {
[08:29:01.049]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.049]                           "", base::R.version$version.string), 
[08:29:01.049]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:01.049]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.049]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.049]                             "release", "version")], collapse = " "), 
[08:29:01.049]                           hostname = base::Sys.info()[["nodename"]])
[08:29:01.049]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.049]                           info)
[08:29:01.049]                         info <- base::paste(info, collapse = "; ")
[08:29:01.049]                         if (!has_future) {
[08:29:01.049]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.049]                             info)
[08:29:01.049]                         }
[08:29:01.049]                         else {
[08:29:01.049]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.049]                             info, version)
[08:29:01.049]                         }
[08:29:01.049]                         base::stop(msg)
[08:29:01.049]                       }
[08:29:01.049]                     })
[08:29:01.049]                   }
[08:29:01.049]                   ...future.strategy.old <- future::plan("list")
[08:29:01.049]                   options(future.plan = NULL)
[08:29:01.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.049]                 }
[08:29:01.049]                 ...future.workdir <- getwd()
[08:29:01.049]             }
[08:29:01.049]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.049]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.049]         }
[08:29:01.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.049]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.049]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.049]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.049]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.049]             base::names(...future.oldOptions))
[08:29:01.049]     }
[08:29:01.049]     if (FALSE) {
[08:29:01.049]     }
[08:29:01.049]     else {
[08:29:01.049]         if (TRUE) {
[08:29:01.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.049]                 open = "w")
[08:29:01.049]         }
[08:29:01.049]         else {
[08:29:01.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.049]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.049]         }
[08:29:01.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.049]             base::sink(type = "output", split = FALSE)
[08:29:01.049]             base::close(...future.stdout)
[08:29:01.049]         }, add = TRUE)
[08:29:01.049]     }
[08:29:01.049]     ...future.frame <- base::sys.nframe()
[08:29:01.049]     ...future.conditions <- base::list()
[08:29:01.049]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.049]     if (FALSE) {
[08:29:01.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.049]     }
[08:29:01.049]     ...future.result <- base::tryCatch({
[08:29:01.049]         base::withCallingHandlers({
[08:29:01.049]             ...future.value <- base::withVisible(base::local(2))
[08:29:01.049]             future::FutureResult(value = ...future.value$value, 
[08:29:01.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.049]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.049]                     ...future.globalenv.names))
[08:29:01.049]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.049]         }, condition = base::local({
[08:29:01.049]             c <- base::c
[08:29:01.049]             inherits <- base::inherits
[08:29:01.049]             invokeRestart <- base::invokeRestart
[08:29:01.049]             length <- base::length
[08:29:01.049]             list <- base::list
[08:29:01.049]             seq.int <- base::seq.int
[08:29:01.049]             signalCondition <- base::signalCondition
[08:29:01.049]             sys.calls <- base::sys.calls
[08:29:01.049]             `[[` <- base::`[[`
[08:29:01.049]             `+` <- base::`+`
[08:29:01.049]             `<<-` <- base::`<<-`
[08:29:01.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.049]                   3L)]
[08:29:01.049]             }
[08:29:01.049]             function(cond) {
[08:29:01.049]                 is_error <- inherits(cond, "error")
[08:29:01.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.049]                   NULL)
[08:29:01.049]                 if (is_error) {
[08:29:01.049]                   sessionInformation <- function() {
[08:29:01.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.049]                       search = base::search(), system = base::Sys.info())
[08:29:01.049]                   }
[08:29:01.049]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.049]                     cond$call), session = sessionInformation(), 
[08:29:01.049]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.049]                   signalCondition(cond)
[08:29:01.049]                 }
[08:29:01.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.049]                 "immediateCondition"))) {
[08:29:01.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.049]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.049]                   if (TRUE && !signal) {
[08:29:01.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.049]                     {
[08:29:01.049]                       inherits <- base::inherits
[08:29:01.049]                       invokeRestart <- base::invokeRestart
[08:29:01.049]                       is.null <- base::is.null
[08:29:01.049]                       muffled <- FALSE
[08:29:01.049]                       if (inherits(cond, "message")) {
[08:29:01.049]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.049]                         if (muffled) 
[08:29:01.049]                           invokeRestart("muffleMessage")
[08:29:01.049]                       }
[08:29:01.049]                       else if (inherits(cond, "warning")) {
[08:29:01.049]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.049]                         if (muffled) 
[08:29:01.049]                           invokeRestart("muffleWarning")
[08:29:01.049]                       }
[08:29:01.049]                       else if (inherits(cond, "condition")) {
[08:29:01.049]                         if (!is.null(pattern)) {
[08:29:01.049]                           computeRestarts <- base::computeRestarts
[08:29:01.049]                           grepl <- base::grepl
[08:29:01.049]                           restarts <- computeRestarts(cond)
[08:29:01.049]                           for (restart in restarts) {
[08:29:01.049]                             name <- restart$name
[08:29:01.049]                             if (is.null(name)) 
[08:29:01.049]                               next
[08:29:01.049]                             if (!grepl(pattern, name)) 
[08:29:01.049]                               next
[08:29:01.049]                             invokeRestart(restart)
[08:29:01.049]                             muffled <- TRUE
[08:29:01.049]                             break
[08:29:01.049]                           }
[08:29:01.049]                         }
[08:29:01.049]                       }
[08:29:01.049]                       invisible(muffled)
[08:29:01.049]                     }
[08:29:01.049]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.049]                   }
[08:29:01.049]                 }
[08:29:01.049]                 else {
[08:29:01.049]                   if (TRUE) {
[08:29:01.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.049]                     {
[08:29:01.049]                       inherits <- base::inherits
[08:29:01.049]                       invokeRestart <- base::invokeRestart
[08:29:01.049]                       is.null <- base::is.null
[08:29:01.049]                       muffled <- FALSE
[08:29:01.049]                       if (inherits(cond, "message")) {
[08:29:01.049]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.049]                         if (muffled) 
[08:29:01.049]                           invokeRestart("muffleMessage")
[08:29:01.049]                       }
[08:29:01.049]                       else if (inherits(cond, "warning")) {
[08:29:01.049]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.049]                         if (muffled) 
[08:29:01.049]                           invokeRestart("muffleWarning")
[08:29:01.049]                       }
[08:29:01.049]                       else if (inherits(cond, "condition")) {
[08:29:01.049]                         if (!is.null(pattern)) {
[08:29:01.049]                           computeRestarts <- base::computeRestarts
[08:29:01.049]                           grepl <- base::grepl
[08:29:01.049]                           restarts <- computeRestarts(cond)
[08:29:01.049]                           for (restart in restarts) {
[08:29:01.049]                             name <- restart$name
[08:29:01.049]                             if (is.null(name)) 
[08:29:01.049]                               next
[08:29:01.049]                             if (!grepl(pattern, name)) 
[08:29:01.049]                               next
[08:29:01.049]                             invokeRestart(restart)
[08:29:01.049]                             muffled <- TRUE
[08:29:01.049]                             break
[08:29:01.049]                           }
[08:29:01.049]                         }
[08:29:01.049]                       }
[08:29:01.049]                       invisible(muffled)
[08:29:01.049]                     }
[08:29:01.049]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.049]                   }
[08:29:01.049]                 }
[08:29:01.049]             }
[08:29:01.049]         }))
[08:29:01.049]     }, error = function(ex) {
[08:29:01.049]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.049]                 ...future.rng), started = ...future.startTime, 
[08:29:01.049]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.049]             version = "1.8"), class = "FutureResult")
[08:29:01.049]     }, finally = {
[08:29:01.049]         if (!identical(...future.workdir, getwd())) 
[08:29:01.049]             setwd(...future.workdir)
[08:29:01.049]         {
[08:29:01.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.049]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.049]             }
[08:29:01.049]             base::options(...future.oldOptions)
[08:29:01.049]             if (.Platform$OS.type == "windows") {
[08:29:01.049]                 old_names <- names(...future.oldEnvVars)
[08:29:01.049]                 envs <- base::Sys.getenv()
[08:29:01.049]                 names <- names(envs)
[08:29:01.049]                 common <- intersect(names, old_names)
[08:29:01.049]                 added <- setdiff(names, old_names)
[08:29:01.049]                 removed <- setdiff(old_names, names)
[08:29:01.049]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.049]                   envs[common]]
[08:29:01.049]                 NAMES <- toupper(changed)
[08:29:01.049]                 args <- list()
[08:29:01.049]                 for (kk in seq_along(NAMES)) {
[08:29:01.049]                   name <- changed[[kk]]
[08:29:01.049]                   NAME <- NAMES[[kk]]
[08:29:01.049]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.049]                     next
[08:29:01.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.049]                 }
[08:29:01.049]                 NAMES <- toupper(added)
[08:29:01.049]                 for (kk in seq_along(NAMES)) {
[08:29:01.049]                   name <- added[[kk]]
[08:29:01.049]                   NAME <- NAMES[[kk]]
[08:29:01.049]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.049]                     next
[08:29:01.049]                   args[[name]] <- ""
[08:29:01.049]                 }
[08:29:01.049]                 NAMES <- toupper(removed)
[08:29:01.049]                 for (kk in seq_along(NAMES)) {
[08:29:01.049]                   name <- removed[[kk]]
[08:29:01.049]                   NAME <- NAMES[[kk]]
[08:29:01.049]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.049]                     next
[08:29:01.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.049]                 }
[08:29:01.049]                 if (length(args) > 0) 
[08:29:01.049]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.049]             }
[08:29:01.049]             else {
[08:29:01.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.049]             }
[08:29:01.049]             {
[08:29:01.049]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.049]                   0L) {
[08:29:01.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.049]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.049]                   base::options(opts)
[08:29:01.049]                 }
[08:29:01.049]                 {
[08:29:01.049]                   {
[08:29:01.049]                     NULL
[08:29:01.049]                     RNGkind("Mersenne-Twister")
[08:29:01.049]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:01.049]                       inherits = FALSE)
[08:29:01.049]                   }
[08:29:01.049]                   options(future.plan = NULL)
[08:29:01.049]                   if (is.na(NA_character_)) 
[08:29:01.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.049]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.049]                     .init = FALSE)
[08:29:01.049]                 }
[08:29:01.049]             }
[08:29:01.049]         }
[08:29:01.049]     })
[08:29:01.049]     if (TRUE) {
[08:29:01.049]         base::sink(type = "output", split = FALSE)
[08:29:01.049]         if (TRUE) {
[08:29:01.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.049]         }
[08:29:01.049]         else {
[08:29:01.049]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.049]         }
[08:29:01.049]         base::close(...future.stdout)
[08:29:01.049]         ...future.stdout <- NULL
[08:29:01.049]     }
[08:29:01.049]     ...future.result$conditions <- ...future.conditions
[08:29:01.049]     ...future.result$finished <- base::Sys.time()
[08:29:01.049]     ...future.result
[08:29:01.049] }
[08:29:01.051] plan(): Setting new future strategy stack:
[08:29:01.051] List of future strategies:
[08:29:01.051] 1. sequential:
[08:29:01.051]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.051]    - tweaked: FALSE
[08:29:01.051]    - call: NULL
[08:29:01.052] plan(): nbrOfWorkers() = 1
[08:29:01.052] plan(): Setting new future strategy stack:
[08:29:01.052] List of future strategies:
[08:29:01.052] 1. sequential:
[08:29:01.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.052]    - tweaked: FALSE
[08:29:01.052]    - call: plan(strategy)
[08:29:01.053] plan(): nbrOfWorkers() = 1
[08:29:01.053] SequentialFuture started (and completed)
[08:29:01.053] - Launch lazy future ... done
[08:29:01.053] run() for ‘SequentialFuture’ ... done
[08:29:01.054] resolve() on list environment ...
[08:29:01.054]  recursive: 0
[08:29:01.054]  length: 3
[08:29:01.054]  elements: ‘a’, ‘b’, ‘c’
[08:29:01.055] resolved() for ‘SequentialFuture’ ...
[08:29:01.055] - state: ‘finished’
[08:29:01.055] - run: TRUE
[08:29:01.055] - result: ‘FutureResult’
[08:29:01.055] resolved() for ‘SequentialFuture’ ... done
[08:29:01.055] Future #1
[08:29:01.055]  length: 2 (resolved future 1)
[08:29:01.055] resolved() for ‘SequentialFuture’ ...
[08:29:01.055] - state: ‘finished’
[08:29:01.055] - run: TRUE
[08:29:01.055] - result: ‘FutureResult’
[08:29:01.056] resolved() for ‘SequentialFuture’ ... done
[08:29:01.056] Future #2
[08:29:01.056]  length: 1 (resolved future 2)
[08:29:01.056]  length: 0 (resolved future 3)
[08:29:01.056] resolve() on list environment ... DONE
[08:29:01.057] getGlobalsAndPackages() ...
[08:29:01.057] Searching for globals...
[08:29:01.057] - globals found: [1] ‘{’
[08:29:01.057] Searching for globals ... DONE
[08:29:01.057] Resolving globals: FALSE
[08:29:01.058] 
[08:29:01.058] 
[08:29:01.058] getGlobalsAndPackages() ... DONE
[08:29:01.058] run() for ‘Future’ ...
[08:29:01.058] - state: ‘created’
[08:29:01.058] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:01.058] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:01.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:01.059]   - Field: ‘label’
[08:29:01.059]   - Field: ‘local’
[08:29:01.059]   - Field: ‘owner’
[08:29:01.059]   - Field: ‘envir’
[08:29:01.059]   - Field: ‘packages’
[08:29:01.060]   - Field: ‘gc’
[08:29:01.060]   - Field: ‘conditions’
[08:29:01.060]   - Field: ‘expr’
[08:29:01.061]   - Field: ‘uuid’
[08:29:01.061]   - Field: ‘seed’
[08:29:01.061]   - Field: ‘version’
[08:29:01.061]   - Field: ‘result’
[08:29:01.061]   - Field: ‘asynchronous’
[08:29:01.061]   - Field: ‘calls’
[08:29:01.061]   - Field: ‘globals’
[08:29:01.061]   - Field: ‘stdout’
[08:29:01.061]   - Field: ‘earlySignal’
[08:29:01.061]   - Field: ‘lazy’
[08:29:01.061]   - Field: ‘state’
[08:29:01.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:01.062] - Launch lazy future ...
[08:29:01.062] Packages needed by the future expression (n = 0): <none>
[08:29:01.062] Packages needed by future strategies (n = 0): <none>
[08:29:01.062] {
[08:29:01.062]     {
[08:29:01.062]         {
[08:29:01.062]             ...future.startTime <- base::Sys.time()
[08:29:01.062]             {
[08:29:01.062]                 {
[08:29:01.062]                   {
[08:29:01.062]                     base::local({
[08:29:01.062]                       has_future <- base::requireNamespace("future", 
[08:29:01.062]                         quietly = TRUE)
[08:29:01.062]                       if (has_future) {
[08:29:01.062]                         ns <- base::getNamespace("future")
[08:29:01.062]                         version <- ns[[".package"]][["version"]]
[08:29:01.062]                         if (is.null(version)) 
[08:29:01.062]                           version <- utils::packageVersion("future")
[08:29:01.062]                       }
[08:29:01.062]                       else {
[08:29:01.062]                         version <- NULL
[08:29:01.062]                       }
[08:29:01.062]                       if (!has_future || version < "1.8.0") {
[08:29:01.062]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.062]                           "", base::R.version$version.string), 
[08:29:01.062]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:01.062]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.062]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.062]                             "release", "version")], collapse = " "), 
[08:29:01.062]                           hostname = base::Sys.info()[["nodename"]])
[08:29:01.062]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.062]                           info)
[08:29:01.062]                         info <- base::paste(info, collapse = "; ")
[08:29:01.062]                         if (!has_future) {
[08:29:01.062]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.062]                             info)
[08:29:01.062]                         }
[08:29:01.062]                         else {
[08:29:01.062]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.062]                             info, version)
[08:29:01.062]                         }
[08:29:01.062]                         base::stop(msg)
[08:29:01.062]                       }
[08:29:01.062]                     })
[08:29:01.062]                   }
[08:29:01.062]                   ...future.strategy.old <- future::plan("list")
[08:29:01.062]                   options(future.plan = NULL)
[08:29:01.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.062]                 }
[08:29:01.062]                 ...future.workdir <- getwd()
[08:29:01.062]             }
[08:29:01.062]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.062]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.062]         }
[08:29:01.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.062]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.062]             base::names(...future.oldOptions))
[08:29:01.062]     }
[08:29:01.062]     if (FALSE) {
[08:29:01.062]     }
[08:29:01.062]     else {
[08:29:01.062]         if (TRUE) {
[08:29:01.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.062]                 open = "w")
[08:29:01.062]         }
[08:29:01.062]         else {
[08:29:01.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.062]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.062]         }
[08:29:01.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.062]             base::sink(type = "output", split = FALSE)
[08:29:01.062]             base::close(...future.stdout)
[08:29:01.062]         }, add = TRUE)
[08:29:01.062]     }
[08:29:01.062]     ...future.frame <- base::sys.nframe()
[08:29:01.062]     ...future.conditions <- base::list()
[08:29:01.062]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.062]     if (FALSE) {
[08:29:01.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.062]     }
[08:29:01.062]     ...future.result <- base::tryCatch({
[08:29:01.062]         base::withCallingHandlers({
[08:29:01.062]             ...future.value <- base::withVisible(base::local({
[08:29:01.062]                 1
[08:29:01.062]             }))
[08:29:01.062]             future::FutureResult(value = ...future.value$value, 
[08:29:01.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.062]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.062]                     ...future.globalenv.names))
[08:29:01.062]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.062]         }, condition = base::local({
[08:29:01.062]             c <- base::c
[08:29:01.062]             inherits <- base::inherits
[08:29:01.062]             invokeRestart <- base::invokeRestart
[08:29:01.062]             length <- base::length
[08:29:01.062]             list <- base::list
[08:29:01.062]             seq.int <- base::seq.int
[08:29:01.062]             signalCondition <- base::signalCondition
[08:29:01.062]             sys.calls <- base::sys.calls
[08:29:01.062]             `[[` <- base::`[[`
[08:29:01.062]             `+` <- base::`+`
[08:29:01.062]             `<<-` <- base::`<<-`
[08:29:01.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.062]                   3L)]
[08:29:01.062]             }
[08:29:01.062]             function(cond) {
[08:29:01.062]                 is_error <- inherits(cond, "error")
[08:29:01.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.062]                   NULL)
[08:29:01.062]                 if (is_error) {
[08:29:01.062]                   sessionInformation <- function() {
[08:29:01.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.062]                       search = base::search(), system = base::Sys.info())
[08:29:01.062]                   }
[08:29:01.062]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.062]                     cond$call), session = sessionInformation(), 
[08:29:01.062]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.062]                   signalCondition(cond)
[08:29:01.062]                 }
[08:29:01.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.062]                 "immediateCondition"))) {
[08:29:01.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.062]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.062]                   if (TRUE && !signal) {
[08:29:01.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.062]                     {
[08:29:01.062]                       inherits <- base::inherits
[08:29:01.062]                       invokeRestart <- base::invokeRestart
[08:29:01.062]                       is.null <- base::is.null
[08:29:01.062]                       muffled <- FALSE
[08:29:01.062]                       if (inherits(cond, "message")) {
[08:29:01.062]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.062]                         if (muffled) 
[08:29:01.062]                           invokeRestart("muffleMessage")
[08:29:01.062]                       }
[08:29:01.062]                       else if (inherits(cond, "warning")) {
[08:29:01.062]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.062]                         if (muffled) 
[08:29:01.062]                           invokeRestart("muffleWarning")
[08:29:01.062]                       }
[08:29:01.062]                       else if (inherits(cond, "condition")) {
[08:29:01.062]                         if (!is.null(pattern)) {
[08:29:01.062]                           computeRestarts <- base::computeRestarts
[08:29:01.062]                           grepl <- base::grepl
[08:29:01.062]                           restarts <- computeRestarts(cond)
[08:29:01.062]                           for (restart in restarts) {
[08:29:01.062]                             name <- restart$name
[08:29:01.062]                             if (is.null(name)) 
[08:29:01.062]                               next
[08:29:01.062]                             if (!grepl(pattern, name)) 
[08:29:01.062]                               next
[08:29:01.062]                             invokeRestart(restart)
[08:29:01.062]                             muffled <- TRUE
[08:29:01.062]                             break
[08:29:01.062]                           }
[08:29:01.062]                         }
[08:29:01.062]                       }
[08:29:01.062]                       invisible(muffled)
[08:29:01.062]                     }
[08:29:01.062]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.062]                   }
[08:29:01.062]                 }
[08:29:01.062]                 else {
[08:29:01.062]                   if (TRUE) {
[08:29:01.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.062]                     {
[08:29:01.062]                       inherits <- base::inherits
[08:29:01.062]                       invokeRestart <- base::invokeRestart
[08:29:01.062]                       is.null <- base::is.null
[08:29:01.062]                       muffled <- FALSE
[08:29:01.062]                       if (inherits(cond, "message")) {
[08:29:01.062]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.062]                         if (muffled) 
[08:29:01.062]                           invokeRestart("muffleMessage")
[08:29:01.062]                       }
[08:29:01.062]                       else if (inherits(cond, "warning")) {
[08:29:01.062]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.062]                         if (muffled) 
[08:29:01.062]                           invokeRestart("muffleWarning")
[08:29:01.062]                       }
[08:29:01.062]                       else if (inherits(cond, "condition")) {
[08:29:01.062]                         if (!is.null(pattern)) {
[08:29:01.062]                           computeRestarts <- base::computeRestarts
[08:29:01.062]                           grepl <- base::grepl
[08:29:01.062]                           restarts <- computeRestarts(cond)
[08:29:01.062]                           for (restart in restarts) {
[08:29:01.062]                             name <- restart$name
[08:29:01.062]                             if (is.null(name)) 
[08:29:01.062]                               next
[08:29:01.062]                             if (!grepl(pattern, name)) 
[08:29:01.062]                               next
[08:29:01.062]                             invokeRestart(restart)
[08:29:01.062]                             muffled <- TRUE
[08:29:01.062]                             break
[08:29:01.062]                           }
[08:29:01.062]                         }
[08:29:01.062]                       }
[08:29:01.062]                       invisible(muffled)
[08:29:01.062]                     }
[08:29:01.062]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.062]                   }
[08:29:01.062]                 }
[08:29:01.062]             }
[08:29:01.062]         }))
[08:29:01.062]     }, error = function(ex) {
[08:29:01.062]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.062]                 ...future.rng), started = ...future.startTime, 
[08:29:01.062]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.062]             version = "1.8"), class = "FutureResult")
[08:29:01.062]     }, finally = {
[08:29:01.062]         if (!identical(...future.workdir, getwd())) 
[08:29:01.062]             setwd(...future.workdir)
[08:29:01.062]         {
[08:29:01.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.062]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.062]             }
[08:29:01.062]             base::options(...future.oldOptions)
[08:29:01.062]             if (.Platform$OS.type == "windows") {
[08:29:01.062]                 old_names <- names(...future.oldEnvVars)
[08:29:01.062]                 envs <- base::Sys.getenv()
[08:29:01.062]                 names <- names(envs)
[08:29:01.062]                 common <- intersect(names, old_names)
[08:29:01.062]                 added <- setdiff(names, old_names)
[08:29:01.062]                 removed <- setdiff(old_names, names)
[08:29:01.062]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.062]                   envs[common]]
[08:29:01.062]                 NAMES <- toupper(changed)
[08:29:01.062]                 args <- list()
[08:29:01.062]                 for (kk in seq_along(NAMES)) {
[08:29:01.062]                   name <- changed[[kk]]
[08:29:01.062]                   NAME <- NAMES[[kk]]
[08:29:01.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.062]                     next
[08:29:01.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.062]                 }
[08:29:01.062]                 NAMES <- toupper(added)
[08:29:01.062]                 for (kk in seq_along(NAMES)) {
[08:29:01.062]                   name <- added[[kk]]
[08:29:01.062]                   NAME <- NAMES[[kk]]
[08:29:01.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.062]                     next
[08:29:01.062]                   args[[name]] <- ""
[08:29:01.062]                 }
[08:29:01.062]                 NAMES <- toupper(removed)
[08:29:01.062]                 for (kk in seq_along(NAMES)) {
[08:29:01.062]                   name <- removed[[kk]]
[08:29:01.062]                   NAME <- NAMES[[kk]]
[08:29:01.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.062]                     next
[08:29:01.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.062]                 }
[08:29:01.062]                 if (length(args) > 0) 
[08:29:01.062]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.062]             }
[08:29:01.062]             else {
[08:29:01.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.062]             }
[08:29:01.062]             {
[08:29:01.062]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.062]                   0L) {
[08:29:01.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.062]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.062]                   base::options(opts)
[08:29:01.062]                 }
[08:29:01.062]                 {
[08:29:01.062]                   {
[08:29:01.062]                     NULL
[08:29:01.062]                     RNGkind("Mersenne-Twister")
[08:29:01.062]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:01.062]                       inherits = FALSE)
[08:29:01.062]                   }
[08:29:01.062]                   options(future.plan = NULL)
[08:29:01.062]                   if (is.na(NA_character_)) 
[08:29:01.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.062]                     .init = FALSE)
[08:29:01.062]                 }
[08:29:01.062]             }
[08:29:01.062]         }
[08:29:01.062]     })
[08:29:01.062]     if (TRUE) {
[08:29:01.062]         base::sink(type = "output", split = FALSE)
[08:29:01.062]         if (TRUE) {
[08:29:01.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.062]         }
[08:29:01.062]         else {
[08:29:01.062]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.062]         }
[08:29:01.062]         base::close(...future.stdout)
[08:29:01.062]         ...future.stdout <- NULL
[08:29:01.062]     }
[08:29:01.062]     ...future.result$conditions <- ...future.conditions
[08:29:01.062]     ...future.result$finished <- base::Sys.time()
[08:29:01.062]     ...future.result
[08:29:01.062] }
[08:29:01.064] plan(): Setting new future strategy stack:
[08:29:01.064] List of future strategies:
[08:29:01.064] 1. sequential:
[08:29:01.064]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.064]    - tweaked: FALSE
[08:29:01.064]    - call: NULL
[08:29:01.064] plan(): nbrOfWorkers() = 1
[08:29:01.065] plan(): Setting new future strategy stack:
[08:29:01.065] List of future strategies:
[08:29:01.065] 1. sequential:
[08:29:01.065]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.065]    - tweaked: FALSE
[08:29:01.065]    - call: plan(strategy)
[08:29:01.066] plan(): nbrOfWorkers() = 1
[08:29:01.066] SequentialFuture started (and completed)
[08:29:01.066] - Launch lazy future ... done
[08:29:01.066] run() for ‘SequentialFuture’ ... done
[08:29:01.066] getGlobalsAndPackages() ...
[08:29:01.066] Searching for globals...
[08:29:01.067] - globals found: [1] ‘{’
[08:29:01.067] Searching for globals ... DONE
[08:29:01.067] Resolving globals: FALSE
[08:29:01.067] 
[08:29:01.067] 
[08:29:01.067] getGlobalsAndPackages() ... DONE
[08:29:01.068] run() for ‘Future’ ...
[08:29:01.068] - state: ‘created’
[08:29:01.068] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:01.068] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:01.068] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:01.068]   - Field: ‘label’
[08:29:01.068]   - Field: ‘local’
[08:29:01.068]   - Field: ‘owner’
[08:29:01.069]   - Field: ‘envir’
[08:29:01.069]   - Field: ‘packages’
[08:29:01.069]   - Field: ‘gc’
[08:29:01.069]   - Field: ‘conditions’
[08:29:01.069]   - Field: ‘expr’
[08:29:01.069]   - Field: ‘uuid’
[08:29:01.069]   - Field: ‘seed’
[08:29:01.069]   - Field: ‘version’
[08:29:01.069]   - Field: ‘result’
[08:29:01.069]   - Field: ‘asynchronous’
[08:29:01.069]   - Field: ‘calls’
[08:29:01.069]   - Field: ‘globals’
[08:29:01.069]   - Field: ‘stdout’
[08:29:01.070]   - Field: ‘earlySignal’
[08:29:01.070]   - Field: ‘lazy’
[08:29:01.070]   - Field: ‘state’
[08:29:01.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:01.070] - Launch lazy future ...
[08:29:01.070] Packages needed by the future expression (n = 0): <none>
[08:29:01.070] Packages needed by future strategies (n = 0): <none>
[08:29:01.070] {
[08:29:01.070]     {
[08:29:01.070]         {
[08:29:01.070]             ...future.startTime <- base::Sys.time()
[08:29:01.070]             {
[08:29:01.070]                 {
[08:29:01.070]                   {
[08:29:01.070]                     base::local({
[08:29:01.070]                       has_future <- base::requireNamespace("future", 
[08:29:01.070]                         quietly = TRUE)
[08:29:01.070]                       if (has_future) {
[08:29:01.070]                         ns <- base::getNamespace("future")
[08:29:01.070]                         version <- ns[[".package"]][["version"]]
[08:29:01.070]                         if (is.null(version)) 
[08:29:01.070]                           version <- utils::packageVersion("future")
[08:29:01.070]                       }
[08:29:01.070]                       else {
[08:29:01.070]                         version <- NULL
[08:29:01.070]                       }
[08:29:01.070]                       if (!has_future || version < "1.8.0") {
[08:29:01.070]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.070]                           "", base::R.version$version.string), 
[08:29:01.070]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:01.070]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.070]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.070]                             "release", "version")], collapse = " "), 
[08:29:01.070]                           hostname = base::Sys.info()[["nodename"]])
[08:29:01.070]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.070]                           info)
[08:29:01.070]                         info <- base::paste(info, collapse = "; ")
[08:29:01.070]                         if (!has_future) {
[08:29:01.070]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.070]                             info)
[08:29:01.070]                         }
[08:29:01.070]                         else {
[08:29:01.070]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.070]                             info, version)
[08:29:01.070]                         }
[08:29:01.070]                         base::stop(msg)
[08:29:01.070]                       }
[08:29:01.070]                     })
[08:29:01.070]                   }
[08:29:01.070]                   ...future.strategy.old <- future::plan("list")
[08:29:01.070]                   options(future.plan = NULL)
[08:29:01.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.070]                 }
[08:29:01.070]                 ...future.workdir <- getwd()
[08:29:01.070]             }
[08:29:01.070]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.070]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.070]         }
[08:29:01.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.070]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.070]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.070]             base::names(...future.oldOptions))
[08:29:01.070]     }
[08:29:01.070]     if (FALSE) {
[08:29:01.070]     }
[08:29:01.070]     else {
[08:29:01.070]         if (TRUE) {
[08:29:01.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.070]                 open = "w")
[08:29:01.070]         }
[08:29:01.070]         else {
[08:29:01.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.070]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.070]         }
[08:29:01.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.070]             base::sink(type = "output", split = FALSE)
[08:29:01.070]             base::close(...future.stdout)
[08:29:01.070]         }, add = TRUE)
[08:29:01.070]     }
[08:29:01.070]     ...future.frame <- base::sys.nframe()
[08:29:01.070]     ...future.conditions <- base::list()
[08:29:01.070]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.070]     if (FALSE) {
[08:29:01.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.070]     }
[08:29:01.070]     ...future.result <- base::tryCatch({
[08:29:01.070]         base::withCallingHandlers({
[08:29:01.070]             ...future.value <- base::withVisible(base::local({
[08:29:01.070]                 2
[08:29:01.070]             }))
[08:29:01.070]             future::FutureResult(value = ...future.value$value, 
[08:29:01.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.070]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.070]                     ...future.globalenv.names))
[08:29:01.070]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.070]         }, condition = base::local({
[08:29:01.070]             c <- base::c
[08:29:01.070]             inherits <- base::inherits
[08:29:01.070]             invokeRestart <- base::invokeRestart
[08:29:01.070]             length <- base::length
[08:29:01.070]             list <- base::list
[08:29:01.070]             seq.int <- base::seq.int
[08:29:01.070]             signalCondition <- base::signalCondition
[08:29:01.070]             sys.calls <- base::sys.calls
[08:29:01.070]             `[[` <- base::`[[`
[08:29:01.070]             `+` <- base::`+`
[08:29:01.070]             `<<-` <- base::`<<-`
[08:29:01.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.070]                   3L)]
[08:29:01.070]             }
[08:29:01.070]             function(cond) {
[08:29:01.070]                 is_error <- inherits(cond, "error")
[08:29:01.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.070]                   NULL)
[08:29:01.070]                 if (is_error) {
[08:29:01.070]                   sessionInformation <- function() {
[08:29:01.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.070]                       search = base::search(), system = base::Sys.info())
[08:29:01.070]                   }
[08:29:01.070]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.070]                     cond$call), session = sessionInformation(), 
[08:29:01.070]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.070]                   signalCondition(cond)
[08:29:01.070]                 }
[08:29:01.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.070]                 "immediateCondition"))) {
[08:29:01.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.070]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.070]                   if (TRUE && !signal) {
[08:29:01.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.070]                     {
[08:29:01.070]                       inherits <- base::inherits
[08:29:01.070]                       invokeRestart <- base::invokeRestart
[08:29:01.070]                       is.null <- base::is.null
[08:29:01.070]                       muffled <- FALSE
[08:29:01.070]                       if (inherits(cond, "message")) {
[08:29:01.070]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.070]                         if (muffled) 
[08:29:01.070]                           invokeRestart("muffleMessage")
[08:29:01.070]                       }
[08:29:01.070]                       else if (inherits(cond, "warning")) {
[08:29:01.070]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.070]                         if (muffled) 
[08:29:01.070]                           invokeRestart("muffleWarning")
[08:29:01.070]                       }
[08:29:01.070]                       else if (inherits(cond, "condition")) {
[08:29:01.070]                         if (!is.null(pattern)) {
[08:29:01.070]                           computeRestarts <- base::computeRestarts
[08:29:01.070]                           grepl <- base::grepl
[08:29:01.070]                           restarts <- computeRestarts(cond)
[08:29:01.070]                           for (restart in restarts) {
[08:29:01.070]                             name <- restart$name
[08:29:01.070]                             if (is.null(name)) 
[08:29:01.070]                               next
[08:29:01.070]                             if (!grepl(pattern, name)) 
[08:29:01.070]                               next
[08:29:01.070]                             invokeRestart(restart)
[08:29:01.070]                             muffled <- TRUE
[08:29:01.070]                             break
[08:29:01.070]                           }
[08:29:01.070]                         }
[08:29:01.070]                       }
[08:29:01.070]                       invisible(muffled)
[08:29:01.070]                     }
[08:29:01.070]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.070]                   }
[08:29:01.070]                 }
[08:29:01.070]                 else {
[08:29:01.070]                   if (TRUE) {
[08:29:01.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.070]                     {
[08:29:01.070]                       inherits <- base::inherits
[08:29:01.070]                       invokeRestart <- base::invokeRestart
[08:29:01.070]                       is.null <- base::is.null
[08:29:01.070]                       muffled <- FALSE
[08:29:01.070]                       if (inherits(cond, "message")) {
[08:29:01.070]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.070]                         if (muffled) 
[08:29:01.070]                           invokeRestart("muffleMessage")
[08:29:01.070]                       }
[08:29:01.070]                       else if (inherits(cond, "warning")) {
[08:29:01.070]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.070]                         if (muffled) 
[08:29:01.070]                           invokeRestart("muffleWarning")
[08:29:01.070]                       }
[08:29:01.070]                       else if (inherits(cond, "condition")) {
[08:29:01.070]                         if (!is.null(pattern)) {
[08:29:01.070]                           computeRestarts <- base::computeRestarts
[08:29:01.070]                           grepl <- base::grepl
[08:29:01.070]                           restarts <- computeRestarts(cond)
[08:29:01.070]                           for (restart in restarts) {
[08:29:01.070]                             name <- restart$name
[08:29:01.070]                             if (is.null(name)) 
[08:29:01.070]                               next
[08:29:01.070]                             if (!grepl(pattern, name)) 
[08:29:01.070]                               next
[08:29:01.070]                             invokeRestart(restart)
[08:29:01.070]                             muffled <- TRUE
[08:29:01.070]                             break
[08:29:01.070]                           }
[08:29:01.070]                         }
[08:29:01.070]                       }
[08:29:01.070]                       invisible(muffled)
[08:29:01.070]                     }
[08:29:01.070]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.070]                   }
[08:29:01.070]                 }
[08:29:01.070]             }
[08:29:01.070]         }))
[08:29:01.070]     }, error = function(ex) {
[08:29:01.070]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.070]                 ...future.rng), started = ...future.startTime, 
[08:29:01.070]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.070]             version = "1.8"), class = "FutureResult")
[08:29:01.070]     }, finally = {
[08:29:01.070]         if (!identical(...future.workdir, getwd())) 
[08:29:01.070]             setwd(...future.workdir)
[08:29:01.070]         {
[08:29:01.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.070]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.070]             }
[08:29:01.070]             base::options(...future.oldOptions)
[08:29:01.070]             if (.Platform$OS.type == "windows") {
[08:29:01.070]                 old_names <- names(...future.oldEnvVars)
[08:29:01.070]                 envs <- base::Sys.getenv()
[08:29:01.070]                 names <- names(envs)
[08:29:01.070]                 common <- intersect(names, old_names)
[08:29:01.070]                 added <- setdiff(names, old_names)
[08:29:01.070]                 removed <- setdiff(old_names, names)
[08:29:01.070]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.070]                   envs[common]]
[08:29:01.070]                 NAMES <- toupper(changed)
[08:29:01.070]                 args <- list()
[08:29:01.070]                 for (kk in seq_along(NAMES)) {
[08:29:01.070]                   name <- changed[[kk]]
[08:29:01.070]                   NAME <- NAMES[[kk]]
[08:29:01.070]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.070]                     next
[08:29:01.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.070]                 }
[08:29:01.070]                 NAMES <- toupper(added)
[08:29:01.070]                 for (kk in seq_along(NAMES)) {
[08:29:01.070]                   name <- added[[kk]]
[08:29:01.070]                   NAME <- NAMES[[kk]]
[08:29:01.070]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.070]                     next
[08:29:01.070]                   args[[name]] <- ""
[08:29:01.070]                 }
[08:29:01.070]                 NAMES <- toupper(removed)
[08:29:01.070]                 for (kk in seq_along(NAMES)) {
[08:29:01.070]                   name <- removed[[kk]]
[08:29:01.070]                   NAME <- NAMES[[kk]]
[08:29:01.070]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.070]                     next
[08:29:01.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.070]                 }
[08:29:01.070]                 if (length(args) > 0) 
[08:29:01.070]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.070]             }
[08:29:01.070]             else {
[08:29:01.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.070]             }
[08:29:01.070]             {
[08:29:01.070]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.070]                   0L) {
[08:29:01.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.070]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.070]                   base::options(opts)
[08:29:01.070]                 }
[08:29:01.070]                 {
[08:29:01.070]                   {
[08:29:01.070]                     NULL
[08:29:01.070]                     RNGkind("Mersenne-Twister")
[08:29:01.070]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:01.070]                       inherits = FALSE)
[08:29:01.070]                   }
[08:29:01.070]                   options(future.plan = NULL)
[08:29:01.070]                   if (is.na(NA_character_)) 
[08:29:01.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.070]                     .init = FALSE)
[08:29:01.070]                 }
[08:29:01.070]             }
[08:29:01.070]         }
[08:29:01.070]     })
[08:29:01.070]     if (TRUE) {
[08:29:01.070]         base::sink(type = "output", split = FALSE)
[08:29:01.070]         if (TRUE) {
[08:29:01.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.070]         }
[08:29:01.070]         else {
[08:29:01.070]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.070]         }
[08:29:01.070]         base::close(...future.stdout)
[08:29:01.070]         ...future.stdout <- NULL
[08:29:01.070]     }
[08:29:01.070]     ...future.result$conditions <- ...future.conditions
[08:29:01.070]     ...future.result$finished <- base::Sys.time()
[08:29:01.070]     ...future.result
[08:29:01.070] }
[08:29:01.072] plan(): Setting new future strategy stack:
[08:29:01.072] List of future strategies:
[08:29:01.072] 1. sequential:
[08:29:01.072]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.072]    - tweaked: FALSE
[08:29:01.072]    - call: NULL
[08:29:01.073] plan(): nbrOfWorkers() = 1
[08:29:01.073] plan(): Setting new future strategy stack:
[08:29:01.073] List of future strategies:
[08:29:01.073] 1. sequential:
[08:29:01.073]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.073]    - tweaked: FALSE
[08:29:01.073]    - call: plan(strategy)
[08:29:01.074] plan(): nbrOfWorkers() = 1
[08:29:01.074] SequentialFuture started (and completed)
[08:29:01.074] - Launch lazy future ... done
[08:29:01.074] run() for ‘SequentialFuture’ ... done
[08:29:01.075] resolve() on list environment ...
[08:29:01.075]  recursive: 0
[08:29:01.075]  length: 3
[08:29:01.075]  elements: ‘a’, ‘b’, ‘c’
[08:29:01.075] resolved() for ‘SequentialFuture’ ...
[08:29:01.075] - state: ‘finished’
[08:29:01.076] - run: TRUE
[08:29:01.076] - result: ‘FutureResult’
[08:29:01.076] resolved() for ‘SequentialFuture’ ... done
[08:29:01.076] Future #1
[08:29:01.076]  length: 2 (resolved future 1)
[08:29:01.076] resolved() for ‘SequentialFuture’ ...
[08:29:01.076] - state: ‘finished’
[08:29:01.076] - run: TRUE
[08:29:01.076] - result: ‘FutureResult’
[08:29:01.076] resolved() for ‘SequentialFuture’ ... done
[08:29:01.076] Future #2
[08:29:01.076]  length: 1 (resolved future 2)
[08:29:01.077]  length: 0 (resolved future 3)
[08:29:01.077] resolve() on list environment ... DONE
[08:29:01.077] getGlobalsAndPackages() ...
[08:29:01.077] Searching for globals...
[08:29:01.078] - globals found: [1] ‘{’
[08:29:01.078] Searching for globals ... DONE
[08:29:01.078] Resolving globals: FALSE
[08:29:01.078] 
[08:29:01.078] 
[08:29:01.078] getGlobalsAndPackages() ... DONE
[08:29:01.078] run() for ‘Future’ ...
[08:29:01.078] - state: ‘created’
[08:29:01.079] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:01.079] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:01.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:01.079]   - Field: ‘label’
[08:29:01.079]   - Field: ‘local’
[08:29:01.079]   - Field: ‘owner’
[08:29:01.079]   - Field: ‘envir’
[08:29:01.079]   - Field: ‘packages’
[08:29:01.079]   - Field: ‘gc’
[08:29:01.079]   - Field: ‘conditions’
[08:29:01.080]   - Field: ‘expr’
[08:29:01.080]   - Field: ‘uuid’
[08:29:01.080]   - Field: ‘seed’
[08:29:01.080]   - Field: ‘version’
[08:29:01.080]   - Field: ‘result’
[08:29:01.080]   - Field: ‘asynchronous’
[08:29:01.080]   - Field: ‘calls’
[08:29:01.080]   - Field: ‘globals’
[08:29:01.080]   - Field: ‘stdout’
[08:29:01.080]   - Field: ‘earlySignal’
[08:29:01.080]   - Field: ‘lazy’
[08:29:01.080]   - Field: ‘state’
[08:29:01.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:01.081] - Launch lazy future ...
[08:29:01.081] Packages needed by the future expression (n = 0): <none>
[08:29:01.081] Packages needed by future strategies (n = 0): <none>
[08:29:01.081] {
[08:29:01.081]     {
[08:29:01.081]         {
[08:29:01.081]             ...future.startTime <- base::Sys.time()
[08:29:01.081]             {
[08:29:01.081]                 {
[08:29:01.081]                   {
[08:29:01.081]                     base::local({
[08:29:01.081]                       has_future <- base::requireNamespace("future", 
[08:29:01.081]                         quietly = TRUE)
[08:29:01.081]                       if (has_future) {
[08:29:01.081]                         ns <- base::getNamespace("future")
[08:29:01.081]                         version <- ns[[".package"]][["version"]]
[08:29:01.081]                         if (is.null(version)) 
[08:29:01.081]                           version <- utils::packageVersion("future")
[08:29:01.081]                       }
[08:29:01.081]                       else {
[08:29:01.081]                         version <- NULL
[08:29:01.081]                       }
[08:29:01.081]                       if (!has_future || version < "1.8.0") {
[08:29:01.081]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.081]                           "", base::R.version$version.string), 
[08:29:01.081]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:01.081]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.081]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.081]                             "release", "version")], collapse = " "), 
[08:29:01.081]                           hostname = base::Sys.info()[["nodename"]])
[08:29:01.081]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.081]                           info)
[08:29:01.081]                         info <- base::paste(info, collapse = "; ")
[08:29:01.081]                         if (!has_future) {
[08:29:01.081]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.081]                             info)
[08:29:01.081]                         }
[08:29:01.081]                         else {
[08:29:01.081]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.081]                             info, version)
[08:29:01.081]                         }
[08:29:01.081]                         base::stop(msg)
[08:29:01.081]                       }
[08:29:01.081]                     })
[08:29:01.081]                   }
[08:29:01.081]                   ...future.strategy.old <- future::plan("list")
[08:29:01.081]                   options(future.plan = NULL)
[08:29:01.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.081]                 }
[08:29:01.081]                 ...future.workdir <- getwd()
[08:29:01.081]             }
[08:29:01.081]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.081]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.081]         }
[08:29:01.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.081]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.081]             base::names(...future.oldOptions))
[08:29:01.081]     }
[08:29:01.081]     if (FALSE) {
[08:29:01.081]     }
[08:29:01.081]     else {
[08:29:01.081]         if (TRUE) {
[08:29:01.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.081]                 open = "w")
[08:29:01.081]         }
[08:29:01.081]         else {
[08:29:01.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.081]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.081]         }
[08:29:01.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.081]             base::sink(type = "output", split = FALSE)
[08:29:01.081]             base::close(...future.stdout)
[08:29:01.081]         }, add = TRUE)
[08:29:01.081]     }
[08:29:01.081]     ...future.frame <- base::sys.nframe()
[08:29:01.081]     ...future.conditions <- base::list()
[08:29:01.081]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.081]     if (FALSE) {
[08:29:01.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.081]     }
[08:29:01.081]     ...future.result <- base::tryCatch({
[08:29:01.081]         base::withCallingHandlers({
[08:29:01.081]             ...future.value <- base::withVisible(base::local({
[08:29:01.081]                 1
[08:29:01.081]             }))
[08:29:01.081]             future::FutureResult(value = ...future.value$value, 
[08:29:01.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.081]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.081]                     ...future.globalenv.names))
[08:29:01.081]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.081]         }, condition = base::local({
[08:29:01.081]             c <- base::c
[08:29:01.081]             inherits <- base::inherits
[08:29:01.081]             invokeRestart <- base::invokeRestart
[08:29:01.081]             length <- base::length
[08:29:01.081]             list <- base::list
[08:29:01.081]             seq.int <- base::seq.int
[08:29:01.081]             signalCondition <- base::signalCondition
[08:29:01.081]             sys.calls <- base::sys.calls
[08:29:01.081]             `[[` <- base::`[[`
[08:29:01.081]             `+` <- base::`+`
[08:29:01.081]             `<<-` <- base::`<<-`
[08:29:01.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.081]                   3L)]
[08:29:01.081]             }
[08:29:01.081]             function(cond) {
[08:29:01.081]                 is_error <- inherits(cond, "error")
[08:29:01.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.081]                   NULL)
[08:29:01.081]                 if (is_error) {
[08:29:01.081]                   sessionInformation <- function() {
[08:29:01.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.081]                       search = base::search(), system = base::Sys.info())
[08:29:01.081]                   }
[08:29:01.081]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.081]                     cond$call), session = sessionInformation(), 
[08:29:01.081]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.081]                   signalCondition(cond)
[08:29:01.081]                 }
[08:29:01.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.081]                 "immediateCondition"))) {
[08:29:01.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.081]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.081]                   if (TRUE && !signal) {
[08:29:01.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.081]                     {
[08:29:01.081]                       inherits <- base::inherits
[08:29:01.081]                       invokeRestart <- base::invokeRestart
[08:29:01.081]                       is.null <- base::is.null
[08:29:01.081]                       muffled <- FALSE
[08:29:01.081]                       if (inherits(cond, "message")) {
[08:29:01.081]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.081]                         if (muffled) 
[08:29:01.081]                           invokeRestart("muffleMessage")
[08:29:01.081]                       }
[08:29:01.081]                       else if (inherits(cond, "warning")) {
[08:29:01.081]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.081]                         if (muffled) 
[08:29:01.081]                           invokeRestart("muffleWarning")
[08:29:01.081]                       }
[08:29:01.081]                       else if (inherits(cond, "condition")) {
[08:29:01.081]                         if (!is.null(pattern)) {
[08:29:01.081]                           computeRestarts <- base::computeRestarts
[08:29:01.081]                           grepl <- base::grepl
[08:29:01.081]                           restarts <- computeRestarts(cond)
[08:29:01.081]                           for (restart in restarts) {
[08:29:01.081]                             name <- restart$name
[08:29:01.081]                             if (is.null(name)) 
[08:29:01.081]                               next
[08:29:01.081]                             if (!grepl(pattern, name)) 
[08:29:01.081]                               next
[08:29:01.081]                             invokeRestart(restart)
[08:29:01.081]                             muffled <- TRUE
[08:29:01.081]                             break
[08:29:01.081]                           }
[08:29:01.081]                         }
[08:29:01.081]                       }
[08:29:01.081]                       invisible(muffled)
[08:29:01.081]                     }
[08:29:01.081]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.081]                   }
[08:29:01.081]                 }
[08:29:01.081]                 else {
[08:29:01.081]                   if (TRUE) {
[08:29:01.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.081]                     {
[08:29:01.081]                       inherits <- base::inherits
[08:29:01.081]                       invokeRestart <- base::invokeRestart
[08:29:01.081]                       is.null <- base::is.null
[08:29:01.081]                       muffled <- FALSE
[08:29:01.081]                       if (inherits(cond, "message")) {
[08:29:01.081]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.081]                         if (muffled) 
[08:29:01.081]                           invokeRestart("muffleMessage")
[08:29:01.081]                       }
[08:29:01.081]                       else if (inherits(cond, "warning")) {
[08:29:01.081]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.081]                         if (muffled) 
[08:29:01.081]                           invokeRestart("muffleWarning")
[08:29:01.081]                       }
[08:29:01.081]                       else if (inherits(cond, "condition")) {
[08:29:01.081]                         if (!is.null(pattern)) {
[08:29:01.081]                           computeRestarts <- base::computeRestarts
[08:29:01.081]                           grepl <- base::grepl
[08:29:01.081]                           restarts <- computeRestarts(cond)
[08:29:01.081]                           for (restart in restarts) {
[08:29:01.081]                             name <- restart$name
[08:29:01.081]                             if (is.null(name)) 
[08:29:01.081]                               next
[08:29:01.081]                             if (!grepl(pattern, name)) 
[08:29:01.081]                               next
[08:29:01.081]                             invokeRestart(restart)
[08:29:01.081]                             muffled <- TRUE
[08:29:01.081]                             break
[08:29:01.081]                           }
[08:29:01.081]                         }
[08:29:01.081]                       }
[08:29:01.081]                       invisible(muffled)
[08:29:01.081]                     }
[08:29:01.081]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.081]                   }
[08:29:01.081]                 }
[08:29:01.081]             }
[08:29:01.081]         }))
[08:29:01.081]     }, error = function(ex) {
[08:29:01.081]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.081]                 ...future.rng), started = ...future.startTime, 
[08:29:01.081]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.081]             version = "1.8"), class = "FutureResult")
[08:29:01.081]     }, finally = {
[08:29:01.081]         if (!identical(...future.workdir, getwd())) 
[08:29:01.081]             setwd(...future.workdir)
[08:29:01.081]         {
[08:29:01.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.081]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.081]             }
[08:29:01.081]             base::options(...future.oldOptions)
[08:29:01.081]             if (.Platform$OS.type == "windows") {
[08:29:01.081]                 old_names <- names(...future.oldEnvVars)
[08:29:01.081]                 envs <- base::Sys.getenv()
[08:29:01.081]                 names <- names(envs)
[08:29:01.081]                 common <- intersect(names, old_names)
[08:29:01.081]                 added <- setdiff(names, old_names)
[08:29:01.081]                 removed <- setdiff(old_names, names)
[08:29:01.081]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.081]                   envs[common]]
[08:29:01.081]                 NAMES <- toupper(changed)
[08:29:01.081]                 args <- list()
[08:29:01.081]                 for (kk in seq_along(NAMES)) {
[08:29:01.081]                   name <- changed[[kk]]
[08:29:01.081]                   NAME <- NAMES[[kk]]
[08:29:01.081]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.081]                     next
[08:29:01.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.081]                 }
[08:29:01.081]                 NAMES <- toupper(added)
[08:29:01.081]                 for (kk in seq_along(NAMES)) {
[08:29:01.081]                   name <- added[[kk]]
[08:29:01.081]                   NAME <- NAMES[[kk]]
[08:29:01.081]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.081]                     next
[08:29:01.081]                   args[[name]] <- ""
[08:29:01.081]                 }
[08:29:01.081]                 NAMES <- toupper(removed)
[08:29:01.081]                 for (kk in seq_along(NAMES)) {
[08:29:01.081]                   name <- removed[[kk]]
[08:29:01.081]                   NAME <- NAMES[[kk]]
[08:29:01.081]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.081]                     next
[08:29:01.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.081]                 }
[08:29:01.081]                 if (length(args) > 0) 
[08:29:01.081]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.081]             }
[08:29:01.081]             else {
[08:29:01.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.081]             }
[08:29:01.081]             {
[08:29:01.081]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.081]                   0L) {
[08:29:01.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.081]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.081]                   base::options(opts)
[08:29:01.081]                 }
[08:29:01.081]                 {
[08:29:01.081]                   {
[08:29:01.081]                     NULL
[08:29:01.081]                     RNGkind("Mersenne-Twister")
[08:29:01.081]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:01.081]                       inherits = FALSE)
[08:29:01.081]                   }
[08:29:01.081]                   options(future.plan = NULL)
[08:29:01.081]                   if (is.na(NA_character_)) 
[08:29:01.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.081]                     .init = FALSE)
[08:29:01.081]                 }
[08:29:01.081]             }
[08:29:01.081]         }
[08:29:01.081]     })
[08:29:01.081]     if (TRUE) {
[08:29:01.081]         base::sink(type = "output", split = FALSE)
[08:29:01.081]         if (TRUE) {
[08:29:01.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.081]         }
[08:29:01.081]         else {
[08:29:01.081]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.081]         }
[08:29:01.081]         base::close(...future.stdout)
[08:29:01.081]         ...future.stdout <- NULL
[08:29:01.081]     }
[08:29:01.081]     ...future.result$conditions <- ...future.conditions
[08:29:01.081]     ...future.result$finished <- base::Sys.time()
[08:29:01.081]     ...future.result
[08:29:01.081] }
[08:29:01.083] plan(): Setting new future strategy stack:
[08:29:01.083] List of future strategies:
[08:29:01.083] 1. sequential:
[08:29:01.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.083]    - tweaked: FALSE
[08:29:01.083]    - call: NULL
[08:29:01.084] plan(): nbrOfWorkers() = 1
[08:29:01.084] plan(): Setting new future strategy stack:
[08:29:01.085] List of future strategies:
[08:29:01.085] 1. sequential:
[08:29:01.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.085]    - tweaked: FALSE
[08:29:01.085]    - call: plan(strategy)
[08:29:01.086] plan(): nbrOfWorkers() = 1
[08:29:01.086] SequentialFuture started (and completed)
[08:29:01.086] - Launch lazy future ... done
[08:29:01.086] run() for ‘SequentialFuture’ ... done
[08:29:01.087] getGlobalsAndPackages() ...
[08:29:01.087] Searching for globals...
[08:29:01.087] - globals found: [2] ‘{’, ‘Sys.sleep’
[08:29:01.088] Searching for globals ... DONE
[08:29:01.088] Resolving globals: FALSE
[08:29:01.088] 
[08:29:01.088] 
[08:29:01.088] getGlobalsAndPackages() ... DONE
[08:29:01.088] run() for ‘Future’ ...
[08:29:01.088] - state: ‘created’
[08:29:01.088] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:01.089] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:01.089] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:01.089]   - Field: ‘label’
[08:29:01.089]   - Field: ‘local’
[08:29:01.089]   - Field: ‘owner’
[08:29:01.089]   - Field: ‘envir’
[08:29:01.089]   - Field: ‘packages’
[08:29:01.089]   - Field: ‘gc’
[08:29:01.089]   - Field: ‘conditions’
[08:29:01.089]   - Field: ‘expr’
[08:29:01.090]   - Field: ‘uuid’
[08:29:01.090]   - Field: ‘seed’
[08:29:01.090]   - Field: ‘version’
[08:29:01.090]   - Field: ‘result’
[08:29:01.090]   - Field: ‘asynchronous’
[08:29:01.090]   - Field: ‘calls’
[08:29:01.090]   - Field: ‘globals’
[08:29:01.090]   - Field: ‘stdout’
[08:29:01.090]   - Field: ‘earlySignal’
[08:29:01.090]   - Field: ‘lazy’
[08:29:01.090]   - Field: ‘state’
[08:29:01.090] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:01.090] - Launch lazy future ...
[08:29:01.091] Packages needed by the future expression (n = 0): <none>
[08:29:01.091] Packages needed by future strategies (n = 0): <none>
[08:29:01.091] {
[08:29:01.091]     {
[08:29:01.091]         {
[08:29:01.091]             ...future.startTime <- base::Sys.time()
[08:29:01.091]             {
[08:29:01.091]                 {
[08:29:01.091]                   {
[08:29:01.091]                     base::local({
[08:29:01.091]                       has_future <- base::requireNamespace("future", 
[08:29:01.091]                         quietly = TRUE)
[08:29:01.091]                       if (has_future) {
[08:29:01.091]                         ns <- base::getNamespace("future")
[08:29:01.091]                         version <- ns[[".package"]][["version"]]
[08:29:01.091]                         if (is.null(version)) 
[08:29:01.091]                           version <- utils::packageVersion("future")
[08:29:01.091]                       }
[08:29:01.091]                       else {
[08:29:01.091]                         version <- NULL
[08:29:01.091]                       }
[08:29:01.091]                       if (!has_future || version < "1.8.0") {
[08:29:01.091]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.091]                           "", base::R.version$version.string), 
[08:29:01.091]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:01.091]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.091]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.091]                             "release", "version")], collapse = " "), 
[08:29:01.091]                           hostname = base::Sys.info()[["nodename"]])
[08:29:01.091]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.091]                           info)
[08:29:01.091]                         info <- base::paste(info, collapse = "; ")
[08:29:01.091]                         if (!has_future) {
[08:29:01.091]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.091]                             info)
[08:29:01.091]                         }
[08:29:01.091]                         else {
[08:29:01.091]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.091]                             info, version)
[08:29:01.091]                         }
[08:29:01.091]                         base::stop(msg)
[08:29:01.091]                       }
[08:29:01.091]                     })
[08:29:01.091]                   }
[08:29:01.091]                   ...future.strategy.old <- future::plan("list")
[08:29:01.091]                   options(future.plan = NULL)
[08:29:01.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.091]                 }
[08:29:01.091]                 ...future.workdir <- getwd()
[08:29:01.091]             }
[08:29:01.091]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.091]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.091]         }
[08:29:01.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.091]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.091]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.091]             base::names(...future.oldOptions))
[08:29:01.091]     }
[08:29:01.091]     if (FALSE) {
[08:29:01.091]     }
[08:29:01.091]     else {
[08:29:01.091]         if (TRUE) {
[08:29:01.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.091]                 open = "w")
[08:29:01.091]         }
[08:29:01.091]         else {
[08:29:01.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.091]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.091]         }
[08:29:01.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.091]             base::sink(type = "output", split = FALSE)
[08:29:01.091]             base::close(...future.stdout)
[08:29:01.091]         }, add = TRUE)
[08:29:01.091]     }
[08:29:01.091]     ...future.frame <- base::sys.nframe()
[08:29:01.091]     ...future.conditions <- base::list()
[08:29:01.091]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.091]     if (FALSE) {
[08:29:01.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.091]     }
[08:29:01.091]     ...future.result <- base::tryCatch({
[08:29:01.091]         base::withCallingHandlers({
[08:29:01.091]             ...future.value <- base::withVisible(base::local({
[08:29:01.091]                 Sys.sleep(0.5)
[08:29:01.091]                 2
[08:29:01.091]             }))
[08:29:01.091]             future::FutureResult(value = ...future.value$value, 
[08:29:01.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.091]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.091]                     ...future.globalenv.names))
[08:29:01.091]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.091]         }, condition = base::local({
[08:29:01.091]             c <- base::c
[08:29:01.091]             inherits <- base::inherits
[08:29:01.091]             invokeRestart <- base::invokeRestart
[08:29:01.091]             length <- base::length
[08:29:01.091]             list <- base::list
[08:29:01.091]             seq.int <- base::seq.int
[08:29:01.091]             signalCondition <- base::signalCondition
[08:29:01.091]             sys.calls <- base::sys.calls
[08:29:01.091]             `[[` <- base::`[[`
[08:29:01.091]             `+` <- base::`+`
[08:29:01.091]             `<<-` <- base::`<<-`
[08:29:01.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.091]                   3L)]
[08:29:01.091]             }
[08:29:01.091]             function(cond) {
[08:29:01.091]                 is_error <- inherits(cond, "error")
[08:29:01.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.091]                   NULL)
[08:29:01.091]                 if (is_error) {
[08:29:01.091]                   sessionInformation <- function() {
[08:29:01.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.091]                       search = base::search(), system = base::Sys.info())
[08:29:01.091]                   }
[08:29:01.091]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.091]                     cond$call), session = sessionInformation(), 
[08:29:01.091]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.091]                   signalCondition(cond)
[08:29:01.091]                 }
[08:29:01.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.091]                 "immediateCondition"))) {
[08:29:01.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.091]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.091]                   if (TRUE && !signal) {
[08:29:01.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.091]                     {
[08:29:01.091]                       inherits <- base::inherits
[08:29:01.091]                       invokeRestart <- base::invokeRestart
[08:29:01.091]                       is.null <- base::is.null
[08:29:01.091]                       muffled <- FALSE
[08:29:01.091]                       if (inherits(cond, "message")) {
[08:29:01.091]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.091]                         if (muffled) 
[08:29:01.091]                           invokeRestart("muffleMessage")
[08:29:01.091]                       }
[08:29:01.091]                       else if (inherits(cond, "warning")) {
[08:29:01.091]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.091]                         if (muffled) 
[08:29:01.091]                           invokeRestart("muffleWarning")
[08:29:01.091]                       }
[08:29:01.091]                       else if (inherits(cond, "condition")) {
[08:29:01.091]                         if (!is.null(pattern)) {
[08:29:01.091]                           computeRestarts <- base::computeRestarts
[08:29:01.091]                           grepl <- base::grepl
[08:29:01.091]                           restarts <- computeRestarts(cond)
[08:29:01.091]                           for (restart in restarts) {
[08:29:01.091]                             name <- restart$name
[08:29:01.091]                             if (is.null(name)) 
[08:29:01.091]                               next
[08:29:01.091]                             if (!grepl(pattern, name)) 
[08:29:01.091]                               next
[08:29:01.091]                             invokeRestart(restart)
[08:29:01.091]                             muffled <- TRUE
[08:29:01.091]                             break
[08:29:01.091]                           }
[08:29:01.091]                         }
[08:29:01.091]                       }
[08:29:01.091]                       invisible(muffled)
[08:29:01.091]                     }
[08:29:01.091]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.091]                   }
[08:29:01.091]                 }
[08:29:01.091]                 else {
[08:29:01.091]                   if (TRUE) {
[08:29:01.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.091]                     {
[08:29:01.091]                       inherits <- base::inherits
[08:29:01.091]                       invokeRestart <- base::invokeRestart
[08:29:01.091]                       is.null <- base::is.null
[08:29:01.091]                       muffled <- FALSE
[08:29:01.091]                       if (inherits(cond, "message")) {
[08:29:01.091]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.091]                         if (muffled) 
[08:29:01.091]                           invokeRestart("muffleMessage")
[08:29:01.091]                       }
[08:29:01.091]                       else if (inherits(cond, "warning")) {
[08:29:01.091]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.091]                         if (muffled) 
[08:29:01.091]                           invokeRestart("muffleWarning")
[08:29:01.091]                       }
[08:29:01.091]                       else if (inherits(cond, "condition")) {
[08:29:01.091]                         if (!is.null(pattern)) {
[08:29:01.091]                           computeRestarts <- base::computeRestarts
[08:29:01.091]                           grepl <- base::grepl
[08:29:01.091]                           restarts <- computeRestarts(cond)
[08:29:01.091]                           for (restart in restarts) {
[08:29:01.091]                             name <- restart$name
[08:29:01.091]                             if (is.null(name)) 
[08:29:01.091]                               next
[08:29:01.091]                             if (!grepl(pattern, name)) 
[08:29:01.091]                               next
[08:29:01.091]                             invokeRestart(restart)
[08:29:01.091]                             muffled <- TRUE
[08:29:01.091]                             break
[08:29:01.091]                           }
[08:29:01.091]                         }
[08:29:01.091]                       }
[08:29:01.091]                       invisible(muffled)
[08:29:01.091]                     }
[08:29:01.091]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.091]                   }
[08:29:01.091]                 }
[08:29:01.091]             }
[08:29:01.091]         }))
[08:29:01.091]     }, error = function(ex) {
[08:29:01.091]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.091]                 ...future.rng), started = ...future.startTime, 
[08:29:01.091]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.091]             version = "1.8"), class = "FutureResult")
[08:29:01.091]     }, finally = {
[08:29:01.091]         if (!identical(...future.workdir, getwd())) 
[08:29:01.091]             setwd(...future.workdir)
[08:29:01.091]         {
[08:29:01.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.091]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.091]             }
[08:29:01.091]             base::options(...future.oldOptions)
[08:29:01.091]             if (.Platform$OS.type == "windows") {
[08:29:01.091]                 old_names <- names(...future.oldEnvVars)
[08:29:01.091]                 envs <- base::Sys.getenv()
[08:29:01.091]                 names <- names(envs)
[08:29:01.091]                 common <- intersect(names, old_names)
[08:29:01.091]                 added <- setdiff(names, old_names)
[08:29:01.091]                 removed <- setdiff(old_names, names)
[08:29:01.091]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.091]                   envs[common]]
[08:29:01.091]                 NAMES <- toupper(changed)
[08:29:01.091]                 args <- list()
[08:29:01.091]                 for (kk in seq_along(NAMES)) {
[08:29:01.091]                   name <- changed[[kk]]
[08:29:01.091]                   NAME <- NAMES[[kk]]
[08:29:01.091]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.091]                     next
[08:29:01.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.091]                 }
[08:29:01.091]                 NAMES <- toupper(added)
[08:29:01.091]                 for (kk in seq_along(NAMES)) {
[08:29:01.091]                   name <- added[[kk]]
[08:29:01.091]                   NAME <- NAMES[[kk]]
[08:29:01.091]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.091]                     next
[08:29:01.091]                   args[[name]] <- ""
[08:29:01.091]                 }
[08:29:01.091]                 NAMES <- toupper(removed)
[08:29:01.091]                 for (kk in seq_along(NAMES)) {
[08:29:01.091]                   name <- removed[[kk]]
[08:29:01.091]                   NAME <- NAMES[[kk]]
[08:29:01.091]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.091]                     next
[08:29:01.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.091]                 }
[08:29:01.091]                 if (length(args) > 0) 
[08:29:01.091]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.091]             }
[08:29:01.091]             else {
[08:29:01.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.091]             }
[08:29:01.091]             {
[08:29:01.091]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.091]                   0L) {
[08:29:01.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.091]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.091]                   base::options(opts)
[08:29:01.091]                 }
[08:29:01.091]                 {
[08:29:01.091]                   {
[08:29:01.091]                     NULL
[08:29:01.091]                     RNGkind("Mersenne-Twister")
[08:29:01.091]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:01.091]                       inherits = FALSE)
[08:29:01.091]                   }
[08:29:01.091]                   options(future.plan = NULL)
[08:29:01.091]                   if (is.na(NA_character_)) 
[08:29:01.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.091]                     .init = FALSE)
[08:29:01.091]                 }
[08:29:01.091]             }
[08:29:01.091]         }
[08:29:01.091]     })
[08:29:01.091]     if (TRUE) {
[08:29:01.091]         base::sink(type = "output", split = FALSE)
[08:29:01.091]         if (TRUE) {
[08:29:01.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.091]         }
[08:29:01.091]         else {
[08:29:01.091]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.091]         }
[08:29:01.091]         base::close(...future.stdout)
[08:29:01.091]         ...future.stdout <- NULL
[08:29:01.091]     }
[08:29:01.091]     ...future.result$conditions <- ...future.conditions
[08:29:01.091]     ...future.result$finished <- base::Sys.time()
[08:29:01.091]     ...future.result
[08:29:01.091] }
[08:29:01.093] plan(): Setting new future strategy stack:
[08:29:01.093] List of future strategies:
[08:29:01.093] 1. sequential:
[08:29:01.093]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.093]    - tweaked: FALSE
[08:29:01.093]    - call: NULL
[08:29:01.093] plan(): nbrOfWorkers() = 1
[08:29:01.595] plan(): Setting new future strategy stack:
[08:29:01.595] List of future strategies:
[08:29:01.595] 1. sequential:
[08:29:01.595]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.595]    - tweaked: FALSE
[08:29:01.595]    - call: plan(strategy)
[08:29:01.596] plan(): nbrOfWorkers() = 1
[08:29:01.596] SequentialFuture started (and completed)
[08:29:01.596] - Launch lazy future ... done
[08:29:01.596] run() for ‘SequentialFuture’ ... done
[08:29:01.597] getGlobalsAndPackages() ...
[08:29:01.597] Searching for globals...
[08:29:01.597] - globals found: [1] ‘{’
[08:29:01.597] Searching for globals ... DONE
[08:29:01.597] Resolving globals: FALSE
[08:29:01.598] 
[08:29:01.598] 
[08:29:01.598] getGlobalsAndPackages() ... DONE
[08:29:01.598] run() for ‘Future’ ...
[08:29:01.598] - state: ‘created’
[08:29:01.598] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:29:01.599] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:29:01.599] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:29:01.599]   - Field: ‘label’
[08:29:01.599]   - Field: ‘local’
[08:29:01.599]   - Field: ‘owner’
[08:29:01.599]   - Field: ‘envir’
[08:29:01.599]   - Field: ‘packages’
[08:29:01.599]   - Field: ‘gc’
[08:29:01.599]   - Field: ‘conditions’
[08:29:01.599]   - Field: ‘expr’
[08:29:01.600]   - Field: ‘uuid’
[08:29:01.600]   - Field: ‘seed’
[08:29:01.600]   - Field: ‘version’
[08:29:01.600]   - Field: ‘result’
[08:29:01.600]   - Field: ‘asynchronous’
[08:29:01.600]   - Field: ‘calls’
[08:29:01.600]   - Field: ‘globals’
[08:29:01.600]   - Field: ‘stdout’
[08:29:01.600]   - Field: ‘earlySignal’
[08:29:01.600]   - Field: ‘lazy’
[08:29:01.600]   - Field: ‘state’
[08:29:01.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:29:01.601] - Launch lazy future ...
[08:29:01.601] Packages needed by the future expression (n = 0): <none>
[08:29:01.601] Packages needed by future strategies (n = 0): <none>
[08:29:01.601] {
[08:29:01.601]     {
[08:29:01.601]         {
[08:29:01.601]             ...future.startTime <- base::Sys.time()
[08:29:01.601]             {
[08:29:01.601]                 {
[08:29:01.601]                   {
[08:29:01.601]                     base::local({
[08:29:01.601]                       has_future <- base::requireNamespace("future", 
[08:29:01.601]                         quietly = TRUE)
[08:29:01.601]                       if (has_future) {
[08:29:01.601]                         ns <- base::getNamespace("future")
[08:29:01.601]                         version <- ns[[".package"]][["version"]]
[08:29:01.601]                         if (is.null(version)) 
[08:29:01.601]                           version <- utils::packageVersion("future")
[08:29:01.601]                       }
[08:29:01.601]                       else {
[08:29:01.601]                         version <- NULL
[08:29:01.601]                       }
[08:29:01.601]                       if (!has_future || version < "1.8.0") {
[08:29:01.601]                         info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.601]                           "", base::R.version$version.string), 
[08:29:01.601]                           platform = base::sprintf("%s (%s-bit)", 
[08:29:01.601]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.601]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.601]                             "release", "version")], collapse = " "), 
[08:29:01.601]                           hostname = base::Sys.info()[["nodename"]])
[08:29:01.601]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.601]                           info)
[08:29:01.601]                         info <- base::paste(info, collapse = "; ")
[08:29:01.601]                         if (!has_future) {
[08:29:01.601]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.601]                             info)
[08:29:01.601]                         }
[08:29:01.601]                         else {
[08:29:01.601]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.601]                             info, version)
[08:29:01.601]                         }
[08:29:01.601]                         base::stop(msg)
[08:29:01.601]                       }
[08:29:01.601]                     })
[08:29:01.601]                   }
[08:29:01.601]                   ...future.strategy.old <- future::plan("list")
[08:29:01.601]                   options(future.plan = NULL)
[08:29:01.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.601]                 }
[08:29:01.601]                 ...future.workdir <- getwd()
[08:29:01.601]             }
[08:29:01.601]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.601]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.601]         }
[08:29:01.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.601]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.601]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.601]             base::names(...future.oldOptions))
[08:29:01.601]     }
[08:29:01.601]     if (FALSE) {
[08:29:01.601]     }
[08:29:01.601]     else {
[08:29:01.601]         if (TRUE) {
[08:29:01.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.601]                 open = "w")
[08:29:01.601]         }
[08:29:01.601]         else {
[08:29:01.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.601]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.601]         }
[08:29:01.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.601]             base::sink(type = "output", split = FALSE)
[08:29:01.601]             base::close(...future.stdout)
[08:29:01.601]         }, add = TRUE)
[08:29:01.601]     }
[08:29:01.601]     ...future.frame <- base::sys.nframe()
[08:29:01.601]     ...future.conditions <- base::list()
[08:29:01.601]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.601]     if (FALSE) {
[08:29:01.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.601]     }
[08:29:01.601]     ...future.result <- base::tryCatch({
[08:29:01.601]         base::withCallingHandlers({
[08:29:01.601]             ...future.value <- base::withVisible(base::local({
[08:29:01.601]                 3
[08:29:01.601]             }))
[08:29:01.601]             future::FutureResult(value = ...future.value$value, 
[08:29:01.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.601]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.601]                     ...future.globalenv.names))
[08:29:01.601]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.601]         }, condition = base::local({
[08:29:01.601]             c <- base::c
[08:29:01.601]             inherits <- base::inherits
[08:29:01.601]             invokeRestart <- base::invokeRestart
[08:29:01.601]             length <- base::length
[08:29:01.601]             list <- base::list
[08:29:01.601]             seq.int <- base::seq.int
[08:29:01.601]             signalCondition <- base::signalCondition
[08:29:01.601]             sys.calls <- base::sys.calls
[08:29:01.601]             `[[` <- base::`[[`
[08:29:01.601]             `+` <- base::`+`
[08:29:01.601]             `<<-` <- base::`<<-`
[08:29:01.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.601]                   3L)]
[08:29:01.601]             }
[08:29:01.601]             function(cond) {
[08:29:01.601]                 is_error <- inherits(cond, "error")
[08:29:01.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.601]                   NULL)
[08:29:01.601]                 if (is_error) {
[08:29:01.601]                   sessionInformation <- function() {
[08:29:01.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.601]                       search = base::search(), system = base::Sys.info())
[08:29:01.601]                   }
[08:29:01.601]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.601]                     cond$call), session = sessionInformation(), 
[08:29:01.601]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.601]                   signalCondition(cond)
[08:29:01.601]                 }
[08:29:01.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.601]                 "immediateCondition"))) {
[08:29:01.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.601]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.601]                   if (TRUE && !signal) {
[08:29:01.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.601]                     {
[08:29:01.601]                       inherits <- base::inherits
[08:29:01.601]                       invokeRestart <- base::invokeRestart
[08:29:01.601]                       is.null <- base::is.null
[08:29:01.601]                       muffled <- FALSE
[08:29:01.601]                       if (inherits(cond, "message")) {
[08:29:01.601]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.601]                         if (muffled) 
[08:29:01.601]                           invokeRestart("muffleMessage")
[08:29:01.601]                       }
[08:29:01.601]                       else if (inherits(cond, "warning")) {
[08:29:01.601]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.601]                         if (muffled) 
[08:29:01.601]                           invokeRestart("muffleWarning")
[08:29:01.601]                       }
[08:29:01.601]                       else if (inherits(cond, "condition")) {
[08:29:01.601]                         if (!is.null(pattern)) {
[08:29:01.601]                           computeRestarts <- base::computeRestarts
[08:29:01.601]                           grepl <- base::grepl
[08:29:01.601]                           restarts <- computeRestarts(cond)
[08:29:01.601]                           for (restart in restarts) {
[08:29:01.601]                             name <- restart$name
[08:29:01.601]                             if (is.null(name)) 
[08:29:01.601]                               next
[08:29:01.601]                             if (!grepl(pattern, name)) 
[08:29:01.601]                               next
[08:29:01.601]                             invokeRestart(restart)
[08:29:01.601]                             muffled <- TRUE
[08:29:01.601]                             break
[08:29:01.601]                           }
[08:29:01.601]                         }
[08:29:01.601]                       }
[08:29:01.601]                       invisible(muffled)
[08:29:01.601]                     }
[08:29:01.601]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.601]                   }
[08:29:01.601]                 }
[08:29:01.601]                 else {
[08:29:01.601]                   if (TRUE) {
[08:29:01.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.601]                     {
[08:29:01.601]                       inherits <- base::inherits
[08:29:01.601]                       invokeRestart <- base::invokeRestart
[08:29:01.601]                       is.null <- base::is.null
[08:29:01.601]                       muffled <- FALSE
[08:29:01.601]                       if (inherits(cond, "message")) {
[08:29:01.601]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.601]                         if (muffled) 
[08:29:01.601]                           invokeRestart("muffleMessage")
[08:29:01.601]                       }
[08:29:01.601]                       else if (inherits(cond, "warning")) {
[08:29:01.601]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.601]                         if (muffled) 
[08:29:01.601]                           invokeRestart("muffleWarning")
[08:29:01.601]                       }
[08:29:01.601]                       else if (inherits(cond, "condition")) {
[08:29:01.601]                         if (!is.null(pattern)) {
[08:29:01.601]                           computeRestarts <- base::computeRestarts
[08:29:01.601]                           grepl <- base::grepl
[08:29:01.601]                           restarts <- computeRestarts(cond)
[08:29:01.601]                           for (restart in restarts) {
[08:29:01.601]                             name <- restart$name
[08:29:01.601]                             if (is.null(name)) 
[08:29:01.601]                               next
[08:29:01.601]                             if (!grepl(pattern, name)) 
[08:29:01.601]                               next
[08:29:01.601]                             invokeRestart(restart)
[08:29:01.601]                             muffled <- TRUE
[08:29:01.601]                             break
[08:29:01.601]                           }
[08:29:01.601]                         }
[08:29:01.601]                       }
[08:29:01.601]                       invisible(muffled)
[08:29:01.601]                     }
[08:29:01.601]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.601]                   }
[08:29:01.601]                 }
[08:29:01.601]             }
[08:29:01.601]         }))
[08:29:01.601]     }, error = function(ex) {
[08:29:01.601]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.601]                 ...future.rng), started = ...future.startTime, 
[08:29:01.601]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.601]             version = "1.8"), class = "FutureResult")
[08:29:01.601]     }, finally = {
[08:29:01.601]         if (!identical(...future.workdir, getwd())) 
[08:29:01.601]             setwd(...future.workdir)
[08:29:01.601]         {
[08:29:01.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.601]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.601]             }
[08:29:01.601]             base::options(...future.oldOptions)
[08:29:01.601]             if (.Platform$OS.type == "windows") {
[08:29:01.601]                 old_names <- names(...future.oldEnvVars)
[08:29:01.601]                 envs <- base::Sys.getenv()
[08:29:01.601]                 names <- names(envs)
[08:29:01.601]                 common <- intersect(names, old_names)
[08:29:01.601]                 added <- setdiff(names, old_names)
[08:29:01.601]                 removed <- setdiff(old_names, names)
[08:29:01.601]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.601]                   envs[common]]
[08:29:01.601]                 NAMES <- toupper(changed)
[08:29:01.601]                 args <- list()
[08:29:01.601]                 for (kk in seq_along(NAMES)) {
[08:29:01.601]                   name <- changed[[kk]]
[08:29:01.601]                   NAME <- NAMES[[kk]]
[08:29:01.601]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.601]                     next
[08:29:01.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.601]                 }
[08:29:01.601]                 NAMES <- toupper(added)
[08:29:01.601]                 for (kk in seq_along(NAMES)) {
[08:29:01.601]                   name <- added[[kk]]
[08:29:01.601]                   NAME <- NAMES[[kk]]
[08:29:01.601]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.601]                     next
[08:29:01.601]                   args[[name]] <- ""
[08:29:01.601]                 }
[08:29:01.601]                 NAMES <- toupper(removed)
[08:29:01.601]                 for (kk in seq_along(NAMES)) {
[08:29:01.601]                   name <- removed[[kk]]
[08:29:01.601]                   NAME <- NAMES[[kk]]
[08:29:01.601]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.601]                     next
[08:29:01.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.601]                 }
[08:29:01.601]                 if (length(args) > 0) 
[08:29:01.601]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.601]             }
[08:29:01.601]             else {
[08:29:01.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.601]             }
[08:29:01.601]             {
[08:29:01.601]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.601]                   0L) {
[08:29:01.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.601]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.601]                   base::options(opts)
[08:29:01.601]                 }
[08:29:01.601]                 {
[08:29:01.601]                   {
[08:29:01.601]                     NULL
[08:29:01.601]                     RNGkind("Mersenne-Twister")
[08:29:01.601]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:29:01.601]                       inherits = FALSE)
[08:29:01.601]                   }
[08:29:01.601]                   options(future.plan = NULL)
[08:29:01.601]                   if (is.na(NA_character_)) 
[08:29:01.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.601]                     .init = FALSE)
[08:29:01.601]                 }
[08:29:01.601]             }
[08:29:01.601]         }
[08:29:01.601]     })
[08:29:01.601]     if (TRUE) {
[08:29:01.601]         base::sink(type = "output", split = FALSE)
[08:29:01.601]         if (TRUE) {
[08:29:01.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.601]         }
[08:29:01.601]         else {
[08:29:01.601]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.601]         }
[08:29:01.601]         base::close(...future.stdout)
[08:29:01.601]         ...future.stdout <- NULL
[08:29:01.601]     }
[08:29:01.601]     ...future.result$conditions <- ...future.conditions
[08:29:01.601]     ...future.result$finished <- base::Sys.time()
[08:29:01.601]     ...future.result
[08:29:01.601] }
[08:29:01.603] plan(): Setting new future strategy stack:
[08:29:01.603] List of future strategies:
[08:29:01.603] 1. sequential:
[08:29:01.603]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.603]    - tweaked: FALSE
[08:29:01.603]    - call: NULL
[08:29:01.604] plan(): nbrOfWorkers() = 1
[08:29:01.604] plan(): Setting new future strategy stack:
[08:29:01.605] List of future strategies:
[08:29:01.605] 1. sequential:
[08:29:01.605]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.605]    - tweaked: FALSE
[08:29:01.605]    - call: plan(strategy)
[08:29:01.605] plan(): nbrOfWorkers() = 1
[08:29:01.605] SequentialFuture started (and completed)
[08:29:01.605] - Launch lazy future ... done
[08:29:01.605] run() for ‘SequentialFuture’ ... done
[08:29:01.606] resolve() on list environment ...
[08:29:01.606]  recursive: 0
[08:29:01.607]  length: 4
[08:29:01.607]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:01.607] resolved() for ‘SequentialFuture’ ...
[08:29:01.607] - state: ‘finished’
[08:29:01.607] - run: TRUE
[08:29:01.607] - result: ‘FutureResult’
[08:29:01.607] resolved() for ‘SequentialFuture’ ... done
[08:29:01.607] Future #1
[08:29:01.607]  length: 3 (resolved future 1)
[08:29:01.608] resolved() for ‘SequentialFuture’ ...
[08:29:01.608] - state: ‘finished’
[08:29:01.608] - run: TRUE
[08:29:01.608] - result: ‘FutureResult’
[08:29:01.608] resolved() for ‘SequentialFuture’ ... done
[08:29:01.608] Future #2
[08:29:01.608]  length: 2 (resolved future 2)
[08:29:01.608] resolved() for ‘SequentialFuture’ ...
[08:29:01.608] - state: ‘finished’
[08:29:01.608] - run: TRUE
[08:29:01.608] - result: ‘FutureResult’
[08:29:01.608] resolved() for ‘SequentialFuture’ ... done
[08:29:01.609] Future #3
[08:29:01.609]  length: 1 (resolved future 3)
[08:29:01.609]  length: 0 (resolved future 4)
[08:29:01.609] resolve() on list environment ... DONE
[08:29:01.609] resolved() for ‘SequentialFuture’ ...
[08:29:01.609] - state: ‘finished’
[08:29:01.609] - run: TRUE
[08:29:01.609] - result: ‘FutureResult’
[08:29:01.610] resolved() for ‘SequentialFuture’ ... done
[08:29:01.610] resolve() on list environment ...
[08:29:01.610]  recursive: 0
[08:29:01.612]  length: 4
[08:29:01.612]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:01.612] resolved() for ‘SequentialFuture’ ...
[08:29:01.612] - state: ‘finished’
[08:29:01.613] - run: TRUE
[08:29:01.613] - result: ‘FutureResult’
[08:29:01.613] resolved() for ‘SequentialFuture’ ... done
[08:29:01.613] Future #1
[08:29:01.613]  length: 3 (resolved future 1)
[08:29:01.613] resolved() for ‘SequentialFuture’ ...
[08:29:01.613] - state: ‘finished’
[08:29:01.613] - run: TRUE
[08:29:01.613] - result: ‘FutureResult’
[08:29:01.613] resolved() for ‘SequentialFuture’ ... done
[08:29:01.614] Future #2
[08:29:01.614]  length: 2 (resolved future 2)
[08:29:01.614] resolved() for ‘SequentialFuture’ ...
[08:29:01.614] - state: ‘finished’
[08:29:01.614] - run: TRUE
[08:29:01.614] - result: ‘FutureResult’
[08:29:01.614] resolved() for ‘SequentialFuture’ ... done
[08:29:01.614] Future #3
[08:29:01.614]  length: 1 (resolved future 3)
[08:29:01.614]  length: 0 (resolved future 4)
[08:29:01.614] resolve() on list environment ... DONE
[08:29:01.615] resolve() on list environment ...
[08:29:01.615]  recursive: 0
[08:29:01.616]  length: 4
[08:29:01.616]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:01.616] resolved() for ‘SequentialFuture’ ...
[08:29:01.616] - state: ‘finished’
[08:29:01.616] - run: TRUE
[08:29:01.616] - result: ‘FutureResult’
[08:29:01.616] resolved() for ‘SequentialFuture’ ... done
[08:29:01.616] Future #1
[08:29:01.616]  length: 3 (resolved future 1)
[08:29:01.617] resolved() for ‘SequentialFuture’ ...
[08:29:01.617] - state: ‘finished’
[08:29:01.617] - run: TRUE
[08:29:01.617] - result: ‘FutureResult’
[08:29:01.617] resolved() for ‘SequentialFuture’ ... done
[08:29:01.617] Future #2
[08:29:01.617]  length: 2 (resolved future 2)
[08:29:01.617] resolved() for ‘SequentialFuture’ ...
[08:29:01.617] - state: ‘finished’
[08:29:01.617] - run: TRUE
[08:29:01.618] - result: ‘FutureResult’
[08:29:01.618] resolved() for ‘SequentialFuture’ ... done
[08:29:01.618] Future #3
[08:29:01.618]  length: 1 (resolved future 3)
[08:29:01.618]  length: 0 (resolved future 4)
[08:29:01.618] resolve() on list environment ... DONE
[08:29:01.618] resolve() on list environment ...
[08:29:01.618]  recursive: 0
[08:29:01.619]  length: 4
[08:29:01.619]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:01.619] resolved() for ‘SequentialFuture’ ...
[08:29:01.619] - state: ‘finished’
[08:29:01.619] - run: TRUE
[08:29:01.620] - result: ‘FutureResult’
[08:29:01.620] resolved() for ‘SequentialFuture’ ... done
[08:29:01.620] Future #1
[08:29:01.620]  length: 3 (resolved future 1)
[08:29:01.620] resolved() for ‘SequentialFuture’ ...
[08:29:01.620] - state: ‘finished’
[08:29:01.620] - run: TRUE
[08:29:01.621] - result: ‘FutureResult’
[08:29:01.621] resolved() for ‘SequentialFuture’ ... done
[08:29:01.621] Future #2
[08:29:01.621]  length: 2 (resolved future 2)
[08:29:01.621] resolved() for ‘SequentialFuture’ ...
[08:29:01.621] - state: ‘finished’
[08:29:01.621] - run: TRUE
[08:29:01.621] - result: ‘FutureResult’
[08:29:01.621] resolved() for ‘SequentialFuture’ ... done
[08:29:01.621] Future #3
[08:29:01.622]  length: 1 (resolved future 3)
[08:29:01.622]  length: 0 (resolved future 4)
[08:29:01.622] resolve() on list environment ... DONE
[08:29:01.622] resolve() on list environment ...
[08:29:01.622]  recursive: 0
[08:29:01.623]  length: 4
[08:29:01.623]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:01.623] resolved() for ‘SequentialFuture’ ...
[08:29:01.623] - state: ‘finished’
[08:29:01.623] - run: TRUE
[08:29:01.623] - result: ‘FutureResult’
[08:29:01.623] resolved() for ‘SequentialFuture’ ... done
[08:29:01.624] Future #1
[08:29:01.624]  length: 3 (resolved future 1)
[08:29:01.624] resolved() for ‘SequentialFuture’ ...
[08:29:01.624] - state: ‘finished’
[08:29:01.624] - run: TRUE
[08:29:01.624] - result: ‘FutureResult’
[08:29:01.624] resolved() for ‘SequentialFuture’ ... done
[08:29:01.624] Future #2
[08:29:01.624]  length: 2 (resolved future 2)
[08:29:01.625] resolved() for ‘SequentialFuture’ ...
[08:29:01.625] - state: ‘finished’
[08:29:01.625] - run: TRUE
[08:29:01.625] - result: ‘FutureResult’
[08:29:01.625] resolved() for ‘SequentialFuture’ ... done
[08:29:01.625] Future #3
[08:29:01.625]  length: 1 (resolved future 3)
[08:29:01.625]  length: 0 (resolved future 4)
[08:29:01.625] resolve() on list environment ... DONE
[08:29:01.626] resolve() on list environment ...
[08:29:01.626]  recursive: 99
[08:29:01.626]  length: 4
[08:29:01.626]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:01.627] resolved() for ‘SequentialFuture’ ...
[08:29:01.627] - state: ‘finished’
[08:29:01.627] - run: TRUE
[08:29:01.627] - result: ‘FutureResult’
[08:29:01.627] resolved() for ‘SequentialFuture’ ... done
[08:29:01.627] Future #1
[08:29:01.627] resolved() for ‘SequentialFuture’ ...
[08:29:01.627] - state: ‘finished’
[08:29:01.627] - run: TRUE
[08:29:01.627] - result: ‘FutureResult’
[08:29:01.628] resolved() for ‘SequentialFuture’ ... done
[08:29:01.628] A SequentialFuture was resolved
[08:29:01.628]  length: 3 (resolved future 1)
[08:29:01.628] resolved() for ‘SequentialFuture’ ...
[08:29:01.628] - state: ‘finished’
[08:29:01.628] - run: TRUE
[08:29:01.628] - result: ‘FutureResult’
[08:29:01.628] resolved() for ‘SequentialFuture’ ... done
[08:29:01.628] Future #2
[08:29:01.628] resolved() for ‘SequentialFuture’ ...
[08:29:01.628] - state: ‘finished’
[08:29:01.629] - run: TRUE
[08:29:01.629] - result: ‘FutureResult’
[08:29:01.629] resolved() for ‘SequentialFuture’ ... done
[08:29:01.629] A SequentialFuture was resolved
[08:29:01.629]  length: 2 (resolved future 2)
[08:29:01.629] resolved() for ‘SequentialFuture’ ...
[08:29:01.629] - state: ‘finished’
[08:29:01.629] - run: TRUE
[08:29:01.629] - result: ‘FutureResult’
[08:29:01.629] resolved() for ‘SequentialFuture’ ... done
[08:29:01.629] Future #3
[08:29:01.630] resolved() for ‘SequentialFuture’ ...
[08:29:01.630] - state: ‘finished’
[08:29:01.630] - run: TRUE
[08:29:01.630] - result: ‘FutureResult’
[08:29:01.630] resolved() for ‘SequentialFuture’ ... done
[08:29:01.630] A SequentialFuture was resolved
[08:29:01.630]  length: 1 (resolved future 3)
[08:29:01.630]  length: 0 (resolved future 4)
[08:29:01.630] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[08:29:01.631] plan(): Setting new future strategy stack:
[08:29:01.631] List of future strategies:
[08:29:01.631] 1. multicore:
[08:29:01.631]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:01.631]    - tweaked: FALSE
[08:29:01.631]    - call: plan(strategy)
[08:29:01.661] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[08:29:01.661] resolve() on list ...
[08:29:01.661]  recursive: 0
[08:29:01.661]  length: 2
[08:29:01.661]  elements: ‘a’, ‘b’
[08:29:01.661]  length: 1 (resolved future 1)
[08:29:01.662]  length: 0 (resolved future 2)
[08:29:01.662] resolve() on list ... DONE
[08:29:01.662] getGlobalsAndPackages() ...
[08:29:01.662] Searching for globals...
[08:29:01.662] 
[08:29:01.662] Searching for globals ... DONE
[08:29:01.662] - globals: [0] <none>
[08:29:01.662] getGlobalsAndPackages() ... DONE
[08:29:01.663] run() for ‘Future’ ...
[08:29:01.663] - state: ‘created’
[08:29:01.663] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:01.664] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:01.665] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:01.665]   - Field: ‘label’
[08:29:01.665]   - Field: ‘local’
[08:29:01.665]   - Field: ‘owner’
[08:29:01.665]   - Field: ‘envir’
[08:29:01.665]   - Field: ‘workers’
[08:29:01.665]   - Field: ‘packages’
[08:29:01.665]   - Field: ‘gc’
[08:29:01.665]   - Field: ‘job’
[08:29:01.665]   - Field: ‘conditions’
[08:29:01.665]   - Field: ‘expr’
[08:29:01.666]   - Field: ‘uuid’
[08:29:01.666]   - Field: ‘seed’
[08:29:01.666]   - Field: ‘version’
[08:29:01.666]   - Field: ‘result’
[08:29:01.666]   - Field: ‘asynchronous’
[08:29:01.666]   - Field: ‘calls’
[08:29:01.666]   - Field: ‘globals’
[08:29:01.666]   - Field: ‘stdout’
[08:29:01.666]   - Field: ‘earlySignal’
[08:29:01.666]   - Field: ‘lazy’
[08:29:01.666]   - Field: ‘state’
[08:29:01.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:01.667] - Launch lazy future ...
[08:29:01.667] Packages needed by the future expression (n = 0): <none>
[08:29:01.668] Packages needed by future strategies (n = 0): <none>
[08:29:01.668] {
[08:29:01.668]     {
[08:29:01.668]         {
[08:29:01.668]             ...future.startTime <- base::Sys.time()
[08:29:01.668]             {
[08:29:01.668]                 {
[08:29:01.668]                   {
[08:29:01.668]                     {
[08:29:01.668]                       base::local({
[08:29:01.668]                         has_future <- base::requireNamespace("future", 
[08:29:01.668]                           quietly = TRUE)
[08:29:01.668]                         if (has_future) {
[08:29:01.668]                           ns <- base::getNamespace("future")
[08:29:01.668]                           version <- ns[[".package"]][["version"]]
[08:29:01.668]                           if (is.null(version)) 
[08:29:01.668]                             version <- utils::packageVersion("future")
[08:29:01.668]                         }
[08:29:01.668]                         else {
[08:29:01.668]                           version <- NULL
[08:29:01.668]                         }
[08:29:01.668]                         if (!has_future || version < "1.8.0") {
[08:29:01.668]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.668]                             "", base::R.version$version.string), 
[08:29:01.668]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:01.668]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.668]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.668]                               "release", "version")], collapse = " "), 
[08:29:01.668]                             hostname = base::Sys.info()[["nodename"]])
[08:29:01.668]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.668]                             info)
[08:29:01.668]                           info <- base::paste(info, collapse = "; ")
[08:29:01.668]                           if (!has_future) {
[08:29:01.668]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.668]                               info)
[08:29:01.668]                           }
[08:29:01.668]                           else {
[08:29:01.668]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.668]                               info, version)
[08:29:01.668]                           }
[08:29:01.668]                           base::stop(msg)
[08:29:01.668]                         }
[08:29:01.668]                       })
[08:29:01.668]                     }
[08:29:01.668]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:01.668]                     base::options(mc.cores = 1L)
[08:29:01.668]                   }
[08:29:01.668]                   ...future.strategy.old <- future::plan("list")
[08:29:01.668]                   options(future.plan = NULL)
[08:29:01.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.668]                 }
[08:29:01.668]                 ...future.workdir <- getwd()
[08:29:01.668]             }
[08:29:01.668]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.668]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.668]         }
[08:29:01.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.668]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.668]             base::names(...future.oldOptions))
[08:29:01.668]     }
[08:29:01.668]     if (FALSE) {
[08:29:01.668]     }
[08:29:01.668]     else {
[08:29:01.668]         if (TRUE) {
[08:29:01.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.668]                 open = "w")
[08:29:01.668]         }
[08:29:01.668]         else {
[08:29:01.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.668]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.668]         }
[08:29:01.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.668]             base::sink(type = "output", split = FALSE)
[08:29:01.668]             base::close(...future.stdout)
[08:29:01.668]         }, add = TRUE)
[08:29:01.668]     }
[08:29:01.668]     ...future.frame <- base::sys.nframe()
[08:29:01.668]     ...future.conditions <- base::list()
[08:29:01.668]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.668]     if (FALSE) {
[08:29:01.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.668]     }
[08:29:01.668]     ...future.result <- base::tryCatch({
[08:29:01.668]         base::withCallingHandlers({
[08:29:01.668]             ...future.value <- base::withVisible(base::local({
[08:29:01.668]                 withCallingHandlers({
[08:29:01.668]                   1
[08:29:01.668]                 }, immediateCondition = function(cond) {
[08:29:01.668]                   save_rds <- function (object, pathname, ...) 
[08:29:01.668]                   {
[08:29:01.668]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:01.668]                     if (file_test("-f", pathname_tmp)) {
[08:29:01.668]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.668]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:01.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.668]                         fi_tmp[["mtime"]])
[08:29:01.668]                     }
[08:29:01.668]                     tryCatch({
[08:29:01.668]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:01.668]                     }, error = function(ex) {
[08:29:01.668]                       msg <- conditionMessage(ex)
[08:29:01.668]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.668]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:01.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.668]                         fi_tmp[["mtime"]], msg)
[08:29:01.668]                       ex$message <- msg
[08:29:01.668]                       stop(ex)
[08:29:01.668]                     })
[08:29:01.668]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:01.668]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:01.668]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:01.668]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.668]                       fi <- file.info(pathname)
[08:29:01.668]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:01.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.668]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:01.668]                         fi[["size"]], fi[["mtime"]])
[08:29:01.668]                       stop(msg)
[08:29:01.668]                     }
[08:29:01.668]                     invisible(pathname)
[08:29:01.668]                   }
[08:29:01.668]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:01.668]                     rootPath = tempdir()) 
[08:29:01.668]                   {
[08:29:01.668]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:01.668]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:01.668]                       tmpdir = path, fileext = ".rds")
[08:29:01.668]                     save_rds(obj, file)
[08:29:01.668]                   }
[08:29:01.668]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:01.668]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.668]                   {
[08:29:01.668]                     inherits <- base::inherits
[08:29:01.668]                     invokeRestart <- base::invokeRestart
[08:29:01.668]                     is.null <- base::is.null
[08:29:01.668]                     muffled <- FALSE
[08:29:01.668]                     if (inherits(cond, "message")) {
[08:29:01.668]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:01.668]                       if (muffled) 
[08:29:01.668]                         invokeRestart("muffleMessage")
[08:29:01.668]                     }
[08:29:01.668]                     else if (inherits(cond, "warning")) {
[08:29:01.668]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:01.668]                       if (muffled) 
[08:29:01.668]                         invokeRestart("muffleWarning")
[08:29:01.668]                     }
[08:29:01.668]                     else if (inherits(cond, "condition")) {
[08:29:01.668]                       if (!is.null(pattern)) {
[08:29:01.668]                         computeRestarts <- base::computeRestarts
[08:29:01.668]                         grepl <- base::grepl
[08:29:01.668]                         restarts <- computeRestarts(cond)
[08:29:01.668]                         for (restart in restarts) {
[08:29:01.668]                           name <- restart$name
[08:29:01.668]                           if (is.null(name)) 
[08:29:01.668]                             next
[08:29:01.668]                           if (!grepl(pattern, name)) 
[08:29:01.668]                             next
[08:29:01.668]                           invokeRestart(restart)
[08:29:01.668]                           muffled <- TRUE
[08:29:01.668]                           break
[08:29:01.668]                         }
[08:29:01.668]                       }
[08:29:01.668]                     }
[08:29:01.668]                     invisible(muffled)
[08:29:01.668]                   }
[08:29:01.668]                   muffleCondition(cond)
[08:29:01.668]                 })
[08:29:01.668]             }))
[08:29:01.668]             future::FutureResult(value = ...future.value$value, 
[08:29:01.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.668]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.668]                     ...future.globalenv.names))
[08:29:01.668]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.668]         }, condition = base::local({
[08:29:01.668]             c <- base::c
[08:29:01.668]             inherits <- base::inherits
[08:29:01.668]             invokeRestart <- base::invokeRestart
[08:29:01.668]             length <- base::length
[08:29:01.668]             list <- base::list
[08:29:01.668]             seq.int <- base::seq.int
[08:29:01.668]             signalCondition <- base::signalCondition
[08:29:01.668]             sys.calls <- base::sys.calls
[08:29:01.668]             `[[` <- base::`[[`
[08:29:01.668]             `+` <- base::`+`
[08:29:01.668]             `<<-` <- base::`<<-`
[08:29:01.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.668]                   3L)]
[08:29:01.668]             }
[08:29:01.668]             function(cond) {
[08:29:01.668]                 is_error <- inherits(cond, "error")
[08:29:01.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.668]                   NULL)
[08:29:01.668]                 if (is_error) {
[08:29:01.668]                   sessionInformation <- function() {
[08:29:01.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.668]                       search = base::search(), system = base::Sys.info())
[08:29:01.668]                   }
[08:29:01.668]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.668]                     cond$call), session = sessionInformation(), 
[08:29:01.668]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.668]                   signalCondition(cond)
[08:29:01.668]                 }
[08:29:01.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.668]                 "immediateCondition"))) {
[08:29:01.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.668]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.668]                   if (TRUE && !signal) {
[08:29:01.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.668]                     {
[08:29:01.668]                       inherits <- base::inherits
[08:29:01.668]                       invokeRestart <- base::invokeRestart
[08:29:01.668]                       is.null <- base::is.null
[08:29:01.668]                       muffled <- FALSE
[08:29:01.668]                       if (inherits(cond, "message")) {
[08:29:01.668]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.668]                         if (muffled) 
[08:29:01.668]                           invokeRestart("muffleMessage")
[08:29:01.668]                       }
[08:29:01.668]                       else if (inherits(cond, "warning")) {
[08:29:01.668]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.668]                         if (muffled) 
[08:29:01.668]                           invokeRestart("muffleWarning")
[08:29:01.668]                       }
[08:29:01.668]                       else if (inherits(cond, "condition")) {
[08:29:01.668]                         if (!is.null(pattern)) {
[08:29:01.668]                           computeRestarts <- base::computeRestarts
[08:29:01.668]                           grepl <- base::grepl
[08:29:01.668]                           restarts <- computeRestarts(cond)
[08:29:01.668]                           for (restart in restarts) {
[08:29:01.668]                             name <- restart$name
[08:29:01.668]                             if (is.null(name)) 
[08:29:01.668]                               next
[08:29:01.668]                             if (!grepl(pattern, name)) 
[08:29:01.668]                               next
[08:29:01.668]                             invokeRestart(restart)
[08:29:01.668]                             muffled <- TRUE
[08:29:01.668]                             break
[08:29:01.668]                           }
[08:29:01.668]                         }
[08:29:01.668]                       }
[08:29:01.668]                       invisible(muffled)
[08:29:01.668]                     }
[08:29:01.668]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.668]                   }
[08:29:01.668]                 }
[08:29:01.668]                 else {
[08:29:01.668]                   if (TRUE) {
[08:29:01.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.668]                     {
[08:29:01.668]                       inherits <- base::inherits
[08:29:01.668]                       invokeRestart <- base::invokeRestart
[08:29:01.668]                       is.null <- base::is.null
[08:29:01.668]                       muffled <- FALSE
[08:29:01.668]                       if (inherits(cond, "message")) {
[08:29:01.668]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.668]                         if (muffled) 
[08:29:01.668]                           invokeRestart("muffleMessage")
[08:29:01.668]                       }
[08:29:01.668]                       else if (inherits(cond, "warning")) {
[08:29:01.668]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.668]                         if (muffled) 
[08:29:01.668]                           invokeRestart("muffleWarning")
[08:29:01.668]                       }
[08:29:01.668]                       else if (inherits(cond, "condition")) {
[08:29:01.668]                         if (!is.null(pattern)) {
[08:29:01.668]                           computeRestarts <- base::computeRestarts
[08:29:01.668]                           grepl <- base::grepl
[08:29:01.668]                           restarts <- computeRestarts(cond)
[08:29:01.668]                           for (restart in restarts) {
[08:29:01.668]                             name <- restart$name
[08:29:01.668]                             if (is.null(name)) 
[08:29:01.668]                               next
[08:29:01.668]                             if (!grepl(pattern, name)) 
[08:29:01.668]                               next
[08:29:01.668]                             invokeRestart(restart)
[08:29:01.668]                             muffled <- TRUE
[08:29:01.668]                             break
[08:29:01.668]                           }
[08:29:01.668]                         }
[08:29:01.668]                       }
[08:29:01.668]                       invisible(muffled)
[08:29:01.668]                     }
[08:29:01.668]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.668]                   }
[08:29:01.668]                 }
[08:29:01.668]             }
[08:29:01.668]         }))
[08:29:01.668]     }, error = function(ex) {
[08:29:01.668]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.668]                 ...future.rng), started = ...future.startTime, 
[08:29:01.668]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.668]             version = "1.8"), class = "FutureResult")
[08:29:01.668]     }, finally = {
[08:29:01.668]         if (!identical(...future.workdir, getwd())) 
[08:29:01.668]             setwd(...future.workdir)
[08:29:01.668]         {
[08:29:01.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.668]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.668]             }
[08:29:01.668]             base::options(...future.oldOptions)
[08:29:01.668]             if (.Platform$OS.type == "windows") {
[08:29:01.668]                 old_names <- names(...future.oldEnvVars)
[08:29:01.668]                 envs <- base::Sys.getenv()
[08:29:01.668]                 names <- names(envs)
[08:29:01.668]                 common <- intersect(names, old_names)
[08:29:01.668]                 added <- setdiff(names, old_names)
[08:29:01.668]                 removed <- setdiff(old_names, names)
[08:29:01.668]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.668]                   envs[common]]
[08:29:01.668]                 NAMES <- toupper(changed)
[08:29:01.668]                 args <- list()
[08:29:01.668]                 for (kk in seq_along(NAMES)) {
[08:29:01.668]                   name <- changed[[kk]]
[08:29:01.668]                   NAME <- NAMES[[kk]]
[08:29:01.668]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.668]                     next
[08:29:01.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.668]                 }
[08:29:01.668]                 NAMES <- toupper(added)
[08:29:01.668]                 for (kk in seq_along(NAMES)) {
[08:29:01.668]                   name <- added[[kk]]
[08:29:01.668]                   NAME <- NAMES[[kk]]
[08:29:01.668]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.668]                     next
[08:29:01.668]                   args[[name]] <- ""
[08:29:01.668]                 }
[08:29:01.668]                 NAMES <- toupper(removed)
[08:29:01.668]                 for (kk in seq_along(NAMES)) {
[08:29:01.668]                   name <- removed[[kk]]
[08:29:01.668]                   NAME <- NAMES[[kk]]
[08:29:01.668]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.668]                     next
[08:29:01.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.668]                 }
[08:29:01.668]                 if (length(args) > 0) 
[08:29:01.668]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.668]             }
[08:29:01.668]             else {
[08:29:01.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.668]             }
[08:29:01.668]             {
[08:29:01.668]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.668]                   0L) {
[08:29:01.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.668]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.668]                   base::options(opts)
[08:29:01.668]                 }
[08:29:01.668]                 {
[08:29:01.668]                   {
[08:29:01.668]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:01.668]                     NULL
[08:29:01.668]                   }
[08:29:01.668]                   options(future.plan = NULL)
[08:29:01.668]                   if (is.na(NA_character_)) 
[08:29:01.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.668]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.668]                     .init = FALSE)
[08:29:01.668]                 }
[08:29:01.668]             }
[08:29:01.668]         }
[08:29:01.668]     })
[08:29:01.668]     if (TRUE) {
[08:29:01.668]         base::sink(type = "output", split = FALSE)
[08:29:01.668]         if (TRUE) {
[08:29:01.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.668]         }
[08:29:01.668]         else {
[08:29:01.668]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.668]         }
[08:29:01.668]         base::close(...future.stdout)
[08:29:01.668]         ...future.stdout <- NULL
[08:29:01.668]     }
[08:29:01.668]     ...future.result$conditions <- ...future.conditions
[08:29:01.668]     ...future.result$finished <- base::Sys.time()
[08:29:01.668]     ...future.result
[08:29:01.668] }
[08:29:01.670] requestCore(): workers = 2
[08:29:01.673] MulticoreFuture started
[08:29:01.674] - Launch lazy future ... done
[08:29:01.674] plan(): Setting new future strategy stack:
[08:29:01.674] run() for ‘MulticoreFuture’ ... done
[08:29:01.675] getGlobalsAndPackages() ...
[08:29:01.675] Searching for globals...
[08:29:01.674] List of future strategies:
[08:29:01.674] 1. sequential:
[08:29:01.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.674]    - tweaked: FALSE
[08:29:01.674]    - call: NULL
[08:29:01.675] plan(): nbrOfWorkers() = 1
[08:29:01.676] 
[08:29:01.676] Searching for globals ... DONE
[08:29:01.676] - globals: [0] <none>
[08:29:01.676] getGlobalsAndPackages() ... DONE
[08:29:01.677] run() for ‘Future’ ...
[08:29:01.677] - state: ‘created’
[08:29:01.678] plan(): Setting new future strategy stack:
[08:29:01.678] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:01.678] List of future strategies:
[08:29:01.678] 1. multicore:
[08:29:01.678]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:01.678]    - tweaked: FALSE
[08:29:01.678]    - call: plan(strategy)
[08:29:01.681] plan(): nbrOfWorkers() = 2
[08:29:01.681] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:01.681] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:01.681]   - Field: ‘label’
[08:29:01.681]   - Field: ‘local’
[08:29:01.682]   - Field: ‘owner’
[08:29:01.682]   - Field: ‘envir’
[08:29:01.682]   - Field: ‘workers’
[08:29:01.682]   - Field: ‘packages’
[08:29:01.682]   - Field: ‘gc’
[08:29:01.683]   - Field: ‘job’
[08:29:01.683]   - Field: ‘conditions’
[08:29:01.683]   - Field: ‘expr’
[08:29:01.683]   - Field: ‘uuid’
[08:29:01.683]   - Field: ‘seed’
[08:29:01.683]   - Field: ‘version’
[08:29:01.684]   - Field: ‘result’
[08:29:01.684]   - Field: ‘asynchronous’
[08:29:01.684]   - Field: ‘calls’
[08:29:01.684]   - Field: ‘globals’
[08:29:01.684]   - Field: ‘stdout’
[08:29:01.685]   - Field: ‘earlySignal’
[08:29:01.685]   - Field: ‘lazy’
[08:29:01.685]   - Field: ‘state’
[08:29:01.685] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:01.685] - Launch lazy future ...
[08:29:01.686] Packages needed by the future expression (n = 0): <none>
[08:29:01.686] Packages needed by future strategies (n = 0): <none>
[08:29:01.687] {
[08:29:01.687]     {
[08:29:01.687]         {
[08:29:01.687]             ...future.startTime <- base::Sys.time()
[08:29:01.687]             {
[08:29:01.687]                 {
[08:29:01.687]                   {
[08:29:01.687]                     {
[08:29:01.687]                       base::local({
[08:29:01.687]                         has_future <- base::requireNamespace("future", 
[08:29:01.687]                           quietly = TRUE)
[08:29:01.687]                         if (has_future) {
[08:29:01.687]                           ns <- base::getNamespace("future")
[08:29:01.687]                           version <- ns[[".package"]][["version"]]
[08:29:01.687]                           if (is.null(version)) 
[08:29:01.687]                             version <- utils::packageVersion("future")
[08:29:01.687]                         }
[08:29:01.687]                         else {
[08:29:01.687]                           version <- NULL
[08:29:01.687]                         }
[08:29:01.687]                         if (!has_future || version < "1.8.0") {
[08:29:01.687]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.687]                             "", base::R.version$version.string), 
[08:29:01.687]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:01.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.687]                               "release", "version")], collapse = " "), 
[08:29:01.687]                             hostname = base::Sys.info()[["nodename"]])
[08:29:01.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.687]                             info)
[08:29:01.687]                           info <- base::paste(info, collapse = "; ")
[08:29:01.687]                           if (!has_future) {
[08:29:01.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.687]                               info)
[08:29:01.687]                           }
[08:29:01.687]                           else {
[08:29:01.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.687]                               info, version)
[08:29:01.687]                           }
[08:29:01.687]                           base::stop(msg)
[08:29:01.687]                         }
[08:29:01.687]                       })
[08:29:01.687]                     }
[08:29:01.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:01.687]                     base::options(mc.cores = 1L)
[08:29:01.687]                   }
[08:29:01.687]                   ...future.strategy.old <- future::plan("list")
[08:29:01.687]                   options(future.plan = NULL)
[08:29:01.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.687]                 }
[08:29:01.687]                 ...future.workdir <- getwd()
[08:29:01.687]             }
[08:29:01.687]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.687]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.687]         }
[08:29:01.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.687]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.687]             base::names(...future.oldOptions))
[08:29:01.687]     }
[08:29:01.687]     if (FALSE) {
[08:29:01.687]     }
[08:29:01.687]     else {
[08:29:01.687]         if (TRUE) {
[08:29:01.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.687]                 open = "w")
[08:29:01.687]         }
[08:29:01.687]         else {
[08:29:01.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.687]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.687]         }
[08:29:01.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.687]             base::sink(type = "output", split = FALSE)
[08:29:01.687]             base::close(...future.stdout)
[08:29:01.687]         }, add = TRUE)
[08:29:01.687]     }
[08:29:01.687]     ...future.frame <- base::sys.nframe()
[08:29:01.687]     ...future.conditions <- base::list()
[08:29:01.687]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.687]     if (FALSE) {
[08:29:01.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.687]     }
[08:29:01.687]     ...future.result <- base::tryCatch({
[08:29:01.687]         base::withCallingHandlers({
[08:29:01.687]             ...future.value <- base::withVisible(base::local({
[08:29:01.687]                 withCallingHandlers({
[08:29:01.687]                   2
[08:29:01.687]                 }, immediateCondition = function(cond) {
[08:29:01.687]                   save_rds <- function (object, pathname, ...) 
[08:29:01.687]                   {
[08:29:01.687]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:01.687]                     if (file_test("-f", pathname_tmp)) {
[08:29:01.687]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.687]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:01.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.687]                         fi_tmp[["mtime"]])
[08:29:01.687]                     }
[08:29:01.687]                     tryCatch({
[08:29:01.687]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:01.687]                     }, error = function(ex) {
[08:29:01.687]                       msg <- conditionMessage(ex)
[08:29:01.687]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.687]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:01.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.687]                         fi_tmp[["mtime"]], msg)
[08:29:01.687]                       ex$message <- msg
[08:29:01.687]                       stop(ex)
[08:29:01.687]                     })
[08:29:01.687]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:01.687]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:01.687]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:01.687]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.687]                       fi <- file.info(pathname)
[08:29:01.687]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:01.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.687]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:01.687]                         fi[["size"]], fi[["mtime"]])
[08:29:01.687]                       stop(msg)
[08:29:01.687]                     }
[08:29:01.687]                     invisible(pathname)
[08:29:01.687]                   }
[08:29:01.687]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:01.687]                     rootPath = tempdir()) 
[08:29:01.687]                   {
[08:29:01.687]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:01.687]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:01.687]                       tmpdir = path, fileext = ".rds")
[08:29:01.687]                     save_rds(obj, file)
[08:29:01.687]                   }
[08:29:01.687]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:01.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.687]                   {
[08:29:01.687]                     inherits <- base::inherits
[08:29:01.687]                     invokeRestart <- base::invokeRestart
[08:29:01.687]                     is.null <- base::is.null
[08:29:01.687]                     muffled <- FALSE
[08:29:01.687]                     if (inherits(cond, "message")) {
[08:29:01.687]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:01.687]                       if (muffled) 
[08:29:01.687]                         invokeRestart("muffleMessage")
[08:29:01.687]                     }
[08:29:01.687]                     else if (inherits(cond, "warning")) {
[08:29:01.687]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:01.687]                       if (muffled) 
[08:29:01.687]                         invokeRestart("muffleWarning")
[08:29:01.687]                     }
[08:29:01.687]                     else if (inherits(cond, "condition")) {
[08:29:01.687]                       if (!is.null(pattern)) {
[08:29:01.687]                         computeRestarts <- base::computeRestarts
[08:29:01.687]                         grepl <- base::grepl
[08:29:01.687]                         restarts <- computeRestarts(cond)
[08:29:01.687]                         for (restart in restarts) {
[08:29:01.687]                           name <- restart$name
[08:29:01.687]                           if (is.null(name)) 
[08:29:01.687]                             next
[08:29:01.687]                           if (!grepl(pattern, name)) 
[08:29:01.687]                             next
[08:29:01.687]                           invokeRestart(restart)
[08:29:01.687]                           muffled <- TRUE
[08:29:01.687]                           break
[08:29:01.687]                         }
[08:29:01.687]                       }
[08:29:01.687]                     }
[08:29:01.687]                     invisible(muffled)
[08:29:01.687]                   }
[08:29:01.687]                   muffleCondition(cond)
[08:29:01.687]                 })
[08:29:01.687]             }))
[08:29:01.687]             future::FutureResult(value = ...future.value$value, 
[08:29:01.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.687]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.687]                     ...future.globalenv.names))
[08:29:01.687]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.687]         }, condition = base::local({
[08:29:01.687]             c <- base::c
[08:29:01.687]             inherits <- base::inherits
[08:29:01.687]             invokeRestart <- base::invokeRestart
[08:29:01.687]             length <- base::length
[08:29:01.687]             list <- base::list
[08:29:01.687]             seq.int <- base::seq.int
[08:29:01.687]             signalCondition <- base::signalCondition
[08:29:01.687]             sys.calls <- base::sys.calls
[08:29:01.687]             `[[` <- base::`[[`
[08:29:01.687]             `+` <- base::`+`
[08:29:01.687]             `<<-` <- base::`<<-`
[08:29:01.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.687]                   3L)]
[08:29:01.687]             }
[08:29:01.687]             function(cond) {
[08:29:01.687]                 is_error <- inherits(cond, "error")
[08:29:01.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.687]                   NULL)
[08:29:01.687]                 if (is_error) {
[08:29:01.687]                   sessionInformation <- function() {
[08:29:01.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.687]                       search = base::search(), system = base::Sys.info())
[08:29:01.687]                   }
[08:29:01.687]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.687]                     cond$call), session = sessionInformation(), 
[08:29:01.687]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.687]                   signalCondition(cond)
[08:29:01.687]                 }
[08:29:01.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.687]                 "immediateCondition"))) {
[08:29:01.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.687]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.687]                   if (TRUE && !signal) {
[08:29:01.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.687]                     {
[08:29:01.687]                       inherits <- base::inherits
[08:29:01.687]                       invokeRestart <- base::invokeRestart
[08:29:01.687]                       is.null <- base::is.null
[08:29:01.687]                       muffled <- FALSE
[08:29:01.687]                       if (inherits(cond, "message")) {
[08:29:01.687]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.687]                         if (muffled) 
[08:29:01.687]                           invokeRestart("muffleMessage")
[08:29:01.687]                       }
[08:29:01.687]                       else if (inherits(cond, "warning")) {
[08:29:01.687]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.687]                         if (muffled) 
[08:29:01.687]                           invokeRestart("muffleWarning")
[08:29:01.687]                       }
[08:29:01.687]                       else if (inherits(cond, "condition")) {
[08:29:01.687]                         if (!is.null(pattern)) {
[08:29:01.687]                           computeRestarts <- base::computeRestarts
[08:29:01.687]                           grepl <- base::grepl
[08:29:01.687]                           restarts <- computeRestarts(cond)
[08:29:01.687]                           for (restart in restarts) {
[08:29:01.687]                             name <- restart$name
[08:29:01.687]                             if (is.null(name)) 
[08:29:01.687]                               next
[08:29:01.687]                             if (!grepl(pattern, name)) 
[08:29:01.687]                               next
[08:29:01.687]                             invokeRestart(restart)
[08:29:01.687]                             muffled <- TRUE
[08:29:01.687]                             break
[08:29:01.687]                           }
[08:29:01.687]                         }
[08:29:01.687]                       }
[08:29:01.687]                       invisible(muffled)
[08:29:01.687]                     }
[08:29:01.687]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.687]                   }
[08:29:01.687]                 }
[08:29:01.687]                 else {
[08:29:01.687]                   if (TRUE) {
[08:29:01.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.687]                     {
[08:29:01.687]                       inherits <- base::inherits
[08:29:01.687]                       invokeRestart <- base::invokeRestart
[08:29:01.687]                       is.null <- base::is.null
[08:29:01.687]                       muffled <- FALSE
[08:29:01.687]                       if (inherits(cond, "message")) {
[08:29:01.687]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.687]                         if (muffled) 
[08:29:01.687]                           invokeRestart("muffleMessage")
[08:29:01.687]                       }
[08:29:01.687]                       else if (inherits(cond, "warning")) {
[08:29:01.687]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.687]                         if (muffled) 
[08:29:01.687]                           invokeRestart("muffleWarning")
[08:29:01.687]                       }
[08:29:01.687]                       else if (inherits(cond, "condition")) {
[08:29:01.687]                         if (!is.null(pattern)) {
[08:29:01.687]                           computeRestarts <- base::computeRestarts
[08:29:01.687]                           grepl <- base::grepl
[08:29:01.687]                           restarts <- computeRestarts(cond)
[08:29:01.687]                           for (restart in restarts) {
[08:29:01.687]                             name <- restart$name
[08:29:01.687]                             if (is.null(name)) 
[08:29:01.687]                               next
[08:29:01.687]                             if (!grepl(pattern, name)) 
[08:29:01.687]                               next
[08:29:01.687]                             invokeRestart(restart)
[08:29:01.687]                             muffled <- TRUE
[08:29:01.687]                             break
[08:29:01.687]                           }
[08:29:01.687]                         }
[08:29:01.687]                       }
[08:29:01.687]                       invisible(muffled)
[08:29:01.687]                     }
[08:29:01.687]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.687]                   }
[08:29:01.687]                 }
[08:29:01.687]             }
[08:29:01.687]         }))
[08:29:01.687]     }, error = function(ex) {
[08:29:01.687]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.687]                 ...future.rng), started = ...future.startTime, 
[08:29:01.687]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.687]             version = "1.8"), class = "FutureResult")
[08:29:01.687]     }, finally = {
[08:29:01.687]         if (!identical(...future.workdir, getwd())) 
[08:29:01.687]             setwd(...future.workdir)
[08:29:01.687]         {
[08:29:01.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.687]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.687]             }
[08:29:01.687]             base::options(...future.oldOptions)
[08:29:01.687]             if (.Platform$OS.type == "windows") {
[08:29:01.687]                 old_names <- names(...future.oldEnvVars)
[08:29:01.687]                 envs <- base::Sys.getenv()
[08:29:01.687]                 names <- names(envs)
[08:29:01.687]                 common <- intersect(names, old_names)
[08:29:01.687]                 added <- setdiff(names, old_names)
[08:29:01.687]                 removed <- setdiff(old_names, names)
[08:29:01.687]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.687]                   envs[common]]
[08:29:01.687]                 NAMES <- toupper(changed)
[08:29:01.687]                 args <- list()
[08:29:01.687]                 for (kk in seq_along(NAMES)) {
[08:29:01.687]                   name <- changed[[kk]]
[08:29:01.687]                   NAME <- NAMES[[kk]]
[08:29:01.687]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.687]                     next
[08:29:01.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.687]                 }
[08:29:01.687]                 NAMES <- toupper(added)
[08:29:01.687]                 for (kk in seq_along(NAMES)) {
[08:29:01.687]                   name <- added[[kk]]
[08:29:01.687]                   NAME <- NAMES[[kk]]
[08:29:01.687]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.687]                     next
[08:29:01.687]                   args[[name]] <- ""
[08:29:01.687]                 }
[08:29:01.687]                 NAMES <- toupper(removed)
[08:29:01.687]                 for (kk in seq_along(NAMES)) {
[08:29:01.687]                   name <- removed[[kk]]
[08:29:01.687]                   NAME <- NAMES[[kk]]
[08:29:01.687]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.687]                     next
[08:29:01.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.687]                 }
[08:29:01.687]                 if (length(args) > 0) 
[08:29:01.687]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.687]             }
[08:29:01.687]             else {
[08:29:01.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.687]             }
[08:29:01.687]             {
[08:29:01.687]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.687]                   0L) {
[08:29:01.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.687]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.687]                   base::options(opts)
[08:29:01.687]                 }
[08:29:01.687]                 {
[08:29:01.687]                   {
[08:29:01.687]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:01.687]                     NULL
[08:29:01.687]                   }
[08:29:01.687]                   options(future.plan = NULL)
[08:29:01.687]                   if (is.na(NA_character_)) 
[08:29:01.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.687]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.687]                     .init = FALSE)
[08:29:01.687]                 }
[08:29:01.687]             }
[08:29:01.687]         }
[08:29:01.687]     })
[08:29:01.687]     if (TRUE) {
[08:29:01.687]         base::sink(type = "output", split = FALSE)
[08:29:01.687]         if (TRUE) {
[08:29:01.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.687]         }
[08:29:01.687]         else {
[08:29:01.687]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.687]         }
[08:29:01.687]         base::close(...future.stdout)
[08:29:01.687]         ...future.stdout <- NULL
[08:29:01.687]     }
[08:29:01.687]     ...future.result$conditions <- ...future.conditions
[08:29:01.687]     ...future.result$finished <- base::Sys.time()
[08:29:01.687]     ...future.result
[08:29:01.687] }
[08:29:01.691] requestCore(): workers = 2
[08:29:01.698] MulticoreFuture started
[08:29:01.699] - Launch lazy future ... done
[08:29:01.699] run() for ‘MulticoreFuture’ ... done
[08:29:01.699] resolve() on list ...
[08:29:01.699] plan(): Setting new future strategy stack:
[08:29:01.700]  recursive: 0
[08:29:01.700]  length: 3
[08:29:01.700]  elements: ‘a’, ‘b’, ‘’
[08:29:01.700] List of future strategies:
[08:29:01.700] 1. sequential:
[08:29:01.700]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.700]    - tweaked: FALSE
[08:29:01.700]    - call: NULL
[08:29:01.701] plan(): nbrOfWorkers() = 1
[08:29:01.702] Future #1
[08:29:01.702]  length: 2 (resolved future 1)
[08:29:01.703] plan(): Setting new future strategy stack:
[08:29:01.703] List of future strategies:
[08:29:01.703] 1. multicore:
[08:29:01.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:01.703]    - tweaked: FALSE
[08:29:01.703]    - call: plan(strategy)
[08:29:01.706] plan(): nbrOfWorkers() = 2
[08:29:01.707] Future #2
[08:29:01.707]  length: 1 (resolved future 2)
[08:29:01.707]  length: 0 (resolved future 3)
[08:29:01.707] resolve() on list ... DONE
[08:29:01.708] getGlobalsAndPackages() ...
[08:29:01.708] Searching for globals...
[08:29:01.709] 
[08:29:01.709] Searching for globals ... DONE
[08:29:01.709] - globals: [0] <none>
[08:29:01.709] getGlobalsAndPackages() ... DONE
[08:29:01.709] getGlobalsAndPackages() ...
[08:29:01.710] Searching for globals...
[08:29:01.710] 
[08:29:01.710] Searching for globals ... DONE
[08:29:01.710] - globals: [0] <none>
[08:29:01.710] getGlobalsAndPackages() ... DONE
[08:29:01.711] run() for ‘Future’ ...
[08:29:01.711] - state: ‘created’
[08:29:01.711] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:01.714] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:01.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:01.714]   - Field: ‘label’
[08:29:01.714]   - Field: ‘local’
[08:29:01.714]   - Field: ‘owner’
[08:29:01.714]   - Field: ‘envir’
[08:29:01.714]   - Field: ‘workers’
[08:29:01.715]   - Field: ‘packages’
[08:29:01.715]   - Field: ‘gc’
[08:29:01.715]   - Field: ‘job’
[08:29:01.715]   - Field: ‘conditions’
[08:29:01.715]   - Field: ‘expr’
[08:29:01.715]   - Field: ‘uuid’
[08:29:01.715]   - Field: ‘seed’
[08:29:01.716]   - Field: ‘version’
[08:29:01.716]   - Field: ‘result’
[08:29:01.716]   - Field: ‘asynchronous’
[08:29:01.716]   - Field: ‘calls’
[08:29:01.716]   - Field: ‘globals’
[08:29:01.716]   - Field: ‘stdout’
[08:29:01.716]   - Field: ‘earlySignal’
[08:29:01.716]   - Field: ‘lazy’
[08:29:01.717]   - Field: ‘state’
[08:29:01.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:01.717] - Launch lazy future ...
[08:29:01.717] Packages needed by the future expression (n = 0): <none>
[08:29:01.722] Packages needed by future strategies (n = 0): <none>
[08:29:01.723] {
[08:29:01.723]     {
[08:29:01.723]         {
[08:29:01.723]             ...future.startTime <- base::Sys.time()
[08:29:01.723]             {
[08:29:01.723]                 {
[08:29:01.723]                   {
[08:29:01.723]                     {
[08:29:01.723]                       base::local({
[08:29:01.723]                         has_future <- base::requireNamespace("future", 
[08:29:01.723]                           quietly = TRUE)
[08:29:01.723]                         if (has_future) {
[08:29:01.723]                           ns <- base::getNamespace("future")
[08:29:01.723]                           version <- ns[[".package"]][["version"]]
[08:29:01.723]                           if (is.null(version)) 
[08:29:01.723]                             version <- utils::packageVersion("future")
[08:29:01.723]                         }
[08:29:01.723]                         else {
[08:29:01.723]                           version <- NULL
[08:29:01.723]                         }
[08:29:01.723]                         if (!has_future || version < "1.8.0") {
[08:29:01.723]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.723]                             "", base::R.version$version.string), 
[08:29:01.723]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:01.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.723]                               "release", "version")], collapse = " "), 
[08:29:01.723]                             hostname = base::Sys.info()[["nodename"]])
[08:29:01.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.723]                             info)
[08:29:01.723]                           info <- base::paste(info, collapse = "; ")
[08:29:01.723]                           if (!has_future) {
[08:29:01.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.723]                               info)
[08:29:01.723]                           }
[08:29:01.723]                           else {
[08:29:01.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.723]                               info, version)
[08:29:01.723]                           }
[08:29:01.723]                           base::stop(msg)
[08:29:01.723]                         }
[08:29:01.723]                       })
[08:29:01.723]                     }
[08:29:01.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:01.723]                     base::options(mc.cores = 1L)
[08:29:01.723]                   }
[08:29:01.723]                   ...future.strategy.old <- future::plan("list")
[08:29:01.723]                   options(future.plan = NULL)
[08:29:01.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.723]                 }
[08:29:01.723]                 ...future.workdir <- getwd()
[08:29:01.723]             }
[08:29:01.723]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.723]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.723]         }
[08:29:01.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.723]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.723]             base::names(...future.oldOptions))
[08:29:01.723]     }
[08:29:01.723]     if (FALSE) {
[08:29:01.723]     }
[08:29:01.723]     else {
[08:29:01.723]         if (TRUE) {
[08:29:01.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.723]                 open = "w")
[08:29:01.723]         }
[08:29:01.723]         else {
[08:29:01.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.723]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.723]         }
[08:29:01.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.723]             base::sink(type = "output", split = FALSE)
[08:29:01.723]             base::close(...future.stdout)
[08:29:01.723]         }, add = TRUE)
[08:29:01.723]     }
[08:29:01.723]     ...future.frame <- base::sys.nframe()
[08:29:01.723]     ...future.conditions <- base::list()
[08:29:01.723]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.723]     if (FALSE) {
[08:29:01.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.723]     }
[08:29:01.723]     ...future.result <- base::tryCatch({
[08:29:01.723]         base::withCallingHandlers({
[08:29:01.723]             ...future.value <- base::withVisible(base::local({
[08:29:01.723]                 withCallingHandlers({
[08:29:01.723]                   2
[08:29:01.723]                 }, immediateCondition = function(cond) {
[08:29:01.723]                   save_rds <- function (object, pathname, ...) 
[08:29:01.723]                   {
[08:29:01.723]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:01.723]                     if (file_test("-f", pathname_tmp)) {
[08:29:01.723]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.723]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:01.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.723]                         fi_tmp[["mtime"]])
[08:29:01.723]                     }
[08:29:01.723]                     tryCatch({
[08:29:01.723]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:01.723]                     }, error = function(ex) {
[08:29:01.723]                       msg <- conditionMessage(ex)
[08:29:01.723]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.723]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:01.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.723]                         fi_tmp[["mtime"]], msg)
[08:29:01.723]                       ex$message <- msg
[08:29:01.723]                       stop(ex)
[08:29:01.723]                     })
[08:29:01.723]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:01.723]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:01.723]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:01.723]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.723]                       fi <- file.info(pathname)
[08:29:01.723]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:01.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.723]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:01.723]                         fi[["size"]], fi[["mtime"]])
[08:29:01.723]                       stop(msg)
[08:29:01.723]                     }
[08:29:01.723]                     invisible(pathname)
[08:29:01.723]                   }
[08:29:01.723]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:01.723]                     rootPath = tempdir()) 
[08:29:01.723]                   {
[08:29:01.723]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:01.723]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:01.723]                       tmpdir = path, fileext = ".rds")
[08:29:01.723]                     save_rds(obj, file)
[08:29:01.723]                   }
[08:29:01.723]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:01.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.723]                   {
[08:29:01.723]                     inherits <- base::inherits
[08:29:01.723]                     invokeRestart <- base::invokeRestart
[08:29:01.723]                     is.null <- base::is.null
[08:29:01.723]                     muffled <- FALSE
[08:29:01.723]                     if (inherits(cond, "message")) {
[08:29:01.723]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:01.723]                       if (muffled) 
[08:29:01.723]                         invokeRestart("muffleMessage")
[08:29:01.723]                     }
[08:29:01.723]                     else if (inherits(cond, "warning")) {
[08:29:01.723]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:01.723]                       if (muffled) 
[08:29:01.723]                         invokeRestart("muffleWarning")
[08:29:01.723]                     }
[08:29:01.723]                     else if (inherits(cond, "condition")) {
[08:29:01.723]                       if (!is.null(pattern)) {
[08:29:01.723]                         computeRestarts <- base::computeRestarts
[08:29:01.723]                         grepl <- base::grepl
[08:29:01.723]                         restarts <- computeRestarts(cond)
[08:29:01.723]                         for (restart in restarts) {
[08:29:01.723]                           name <- restart$name
[08:29:01.723]                           if (is.null(name)) 
[08:29:01.723]                             next
[08:29:01.723]                           if (!grepl(pattern, name)) 
[08:29:01.723]                             next
[08:29:01.723]                           invokeRestart(restart)
[08:29:01.723]                           muffled <- TRUE
[08:29:01.723]                           break
[08:29:01.723]                         }
[08:29:01.723]                       }
[08:29:01.723]                     }
[08:29:01.723]                     invisible(muffled)
[08:29:01.723]                   }
[08:29:01.723]                   muffleCondition(cond)
[08:29:01.723]                 })
[08:29:01.723]             }))
[08:29:01.723]             future::FutureResult(value = ...future.value$value, 
[08:29:01.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.723]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.723]                     ...future.globalenv.names))
[08:29:01.723]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.723]         }, condition = base::local({
[08:29:01.723]             c <- base::c
[08:29:01.723]             inherits <- base::inherits
[08:29:01.723]             invokeRestart <- base::invokeRestart
[08:29:01.723]             length <- base::length
[08:29:01.723]             list <- base::list
[08:29:01.723]             seq.int <- base::seq.int
[08:29:01.723]             signalCondition <- base::signalCondition
[08:29:01.723]             sys.calls <- base::sys.calls
[08:29:01.723]             `[[` <- base::`[[`
[08:29:01.723]             `+` <- base::`+`
[08:29:01.723]             `<<-` <- base::`<<-`
[08:29:01.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.723]                   3L)]
[08:29:01.723]             }
[08:29:01.723]             function(cond) {
[08:29:01.723]                 is_error <- inherits(cond, "error")
[08:29:01.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.723]                   NULL)
[08:29:01.723]                 if (is_error) {
[08:29:01.723]                   sessionInformation <- function() {
[08:29:01.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.723]                       search = base::search(), system = base::Sys.info())
[08:29:01.723]                   }
[08:29:01.723]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.723]                     cond$call), session = sessionInformation(), 
[08:29:01.723]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.723]                   signalCondition(cond)
[08:29:01.723]                 }
[08:29:01.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.723]                 "immediateCondition"))) {
[08:29:01.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.723]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.723]                   if (TRUE && !signal) {
[08:29:01.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.723]                     {
[08:29:01.723]                       inherits <- base::inherits
[08:29:01.723]                       invokeRestart <- base::invokeRestart
[08:29:01.723]                       is.null <- base::is.null
[08:29:01.723]                       muffled <- FALSE
[08:29:01.723]                       if (inherits(cond, "message")) {
[08:29:01.723]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.723]                         if (muffled) 
[08:29:01.723]                           invokeRestart("muffleMessage")
[08:29:01.723]                       }
[08:29:01.723]                       else if (inherits(cond, "warning")) {
[08:29:01.723]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.723]                         if (muffled) 
[08:29:01.723]                           invokeRestart("muffleWarning")
[08:29:01.723]                       }
[08:29:01.723]                       else if (inherits(cond, "condition")) {
[08:29:01.723]                         if (!is.null(pattern)) {
[08:29:01.723]                           computeRestarts <- base::computeRestarts
[08:29:01.723]                           grepl <- base::grepl
[08:29:01.723]                           restarts <- computeRestarts(cond)
[08:29:01.723]                           for (restart in restarts) {
[08:29:01.723]                             name <- restart$name
[08:29:01.723]                             if (is.null(name)) 
[08:29:01.723]                               next
[08:29:01.723]                             if (!grepl(pattern, name)) 
[08:29:01.723]                               next
[08:29:01.723]                             invokeRestart(restart)
[08:29:01.723]                             muffled <- TRUE
[08:29:01.723]                             break
[08:29:01.723]                           }
[08:29:01.723]                         }
[08:29:01.723]                       }
[08:29:01.723]                       invisible(muffled)
[08:29:01.723]                     }
[08:29:01.723]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.723]                   }
[08:29:01.723]                 }
[08:29:01.723]                 else {
[08:29:01.723]                   if (TRUE) {
[08:29:01.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.723]                     {
[08:29:01.723]                       inherits <- base::inherits
[08:29:01.723]                       invokeRestart <- base::invokeRestart
[08:29:01.723]                       is.null <- base::is.null
[08:29:01.723]                       muffled <- FALSE
[08:29:01.723]                       if (inherits(cond, "message")) {
[08:29:01.723]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.723]                         if (muffled) 
[08:29:01.723]                           invokeRestart("muffleMessage")
[08:29:01.723]                       }
[08:29:01.723]                       else if (inherits(cond, "warning")) {
[08:29:01.723]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.723]                         if (muffled) 
[08:29:01.723]                           invokeRestart("muffleWarning")
[08:29:01.723]                       }
[08:29:01.723]                       else if (inherits(cond, "condition")) {
[08:29:01.723]                         if (!is.null(pattern)) {
[08:29:01.723]                           computeRestarts <- base::computeRestarts
[08:29:01.723]                           grepl <- base::grepl
[08:29:01.723]                           restarts <- computeRestarts(cond)
[08:29:01.723]                           for (restart in restarts) {
[08:29:01.723]                             name <- restart$name
[08:29:01.723]                             if (is.null(name)) 
[08:29:01.723]                               next
[08:29:01.723]                             if (!grepl(pattern, name)) 
[08:29:01.723]                               next
[08:29:01.723]                             invokeRestart(restart)
[08:29:01.723]                             muffled <- TRUE
[08:29:01.723]                             break
[08:29:01.723]                           }
[08:29:01.723]                         }
[08:29:01.723]                       }
[08:29:01.723]                       invisible(muffled)
[08:29:01.723]                     }
[08:29:01.723]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.723]                   }
[08:29:01.723]                 }
[08:29:01.723]             }
[08:29:01.723]         }))
[08:29:01.723]     }, error = function(ex) {
[08:29:01.723]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.723]                 ...future.rng), started = ...future.startTime, 
[08:29:01.723]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.723]             version = "1.8"), class = "FutureResult")
[08:29:01.723]     }, finally = {
[08:29:01.723]         if (!identical(...future.workdir, getwd())) 
[08:29:01.723]             setwd(...future.workdir)
[08:29:01.723]         {
[08:29:01.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.723]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.723]             }
[08:29:01.723]             base::options(...future.oldOptions)
[08:29:01.723]             if (.Platform$OS.type == "windows") {
[08:29:01.723]                 old_names <- names(...future.oldEnvVars)
[08:29:01.723]                 envs <- base::Sys.getenv()
[08:29:01.723]                 names <- names(envs)
[08:29:01.723]                 common <- intersect(names, old_names)
[08:29:01.723]                 added <- setdiff(names, old_names)
[08:29:01.723]                 removed <- setdiff(old_names, names)
[08:29:01.723]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.723]                   envs[common]]
[08:29:01.723]                 NAMES <- toupper(changed)
[08:29:01.723]                 args <- list()
[08:29:01.723]                 for (kk in seq_along(NAMES)) {
[08:29:01.723]                   name <- changed[[kk]]
[08:29:01.723]                   NAME <- NAMES[[kk]]
[08:29:01.723]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.723]                     next
[08:29:01.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.723]                 }
[08:29:01.723]                 NAMES <- toupper(added)
[08:29:01.723]                 for (kk in seq_along(NAMES)) {
[08:29:01.723]                   name <- added[[kk]]
[08:29:01.723]                   NAME <- NAMES[[kk]]
[08:29:01.723]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.723]                     next
[08:29:01.723]                   args[[name]] <- ""
[08:29:01.723]                 }
[08:29:01.723]                 NAMES <- toupper(removed)
[08:29:01.723]                 for (kk in seq_along(NAMES)) {
[08:29:01.723]                   name <- removed[[kk]]
[08:29:01.723]                   NAME <- NAMES[[kk]]
[08:29:01.723]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.723]                     next
[08:29:01.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.723]                 }
[08:29:01.723]                 if (length(args) > 0) 
[08:29:01.723]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.723]             }
[08:29:01.723]             else {
[08:29:01.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.723]             }
[08:29:01.723]             {
[08:29:01.723]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.723]                   0L) {
[08:29:01.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.723]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.723]                   base::options(opts)
[08:29:01.723]                 }
[08:29:01.723]                 {
[08:29:01.723]                   {
[08:29:01.723]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:01.723]                     NULL
[08:29:01.723]                   }
[08:29:01.723]                   options(future.plan = NULL)
[08:29:01.723]                   if (is.na(NA_character_)) 
[08:29:01.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.723]                     .init = FALSE)
[08:29:01.723]                 }
[08:29:01.723]             }
[08:29:01.723]         }
[08:29:01.723]     })
[08:29:01.723]     if (TRUE) {
[08:29:01.723]         base::sink(type = "output", split = FALSE)
[08:29:01.723]         if (TRUE) {
[08:29:01.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.723]         }
[08:29:01.723]         else {
[08:29:01.723]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.723]         }
[08:29:01.723]         base::close(...future.stdout)
[08:29:01.723]         ...future.stdout <- NULL
[08:29:01.723]     }
[08:29:01.723]     ...future.result$conditions <- ...future.conditions
[08:29:01.723]     ...future.result$finished <- base::Sys.time()
[08:29:01.723]     ...future.result
[08:29:01.723] }
[08:29:01.726] requestCore(): workers = 2
[08:29:01.727] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:01.738] result() for MulticoreFuture ...
[08:29:01.740] result() for MulticoreFuture ...
[08:29:01.740] result() for MulticoreFuture ... done
[08:29:01.740] result() for MulticoreFuture ... done
[08:29:01.741] result() for MulticoreFuture ...
[08:29:01.741] result() for MulticoreFuture ... done
[08:29:01.743] MulticoreFuture started
[08:29:01.744] - Launch lazy future ... done
[08:29:01.744] run() for ‘MulticoreFuture’ ... done
[08:29:01.745] plan(): Setting new future strategy stack:
[08:29:01.745] resolve() on list ...
[08:29:01.745]  recursive: 0
[08:29:01.746]  length: 3
[08:29:01.746]  elements: ‘a’, ‘b’, ‘’
[08:29:01.747] run() for ‘Future’ ...
[08:29:01.745] List of future strategies:
[08:29:01.745] 1. sequential:
[08:29:01.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.745]    - tweaked: FALSE
[08:29:01.745]    - call: NULL
[08:29:01.747] - state: ‘created’
[08:29:01.747] plan(): nbrOfWorkers() = 1
[08:29:01.747] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:01.750] plan(): Setting new future strategy stack:
[08:29:01.751] List of future strategies:
[08:29:01.751] 1. multicore:
[08:29:01.751]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:01.751]    - tweaked: FALSE
[08:29:01.751]    - call: plan(strategy)
[08:29:01.753] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:01.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:01.753]   - Field: ‘label’
[08:29:01.753]   - Field: ‘local’
[08:29:01.754]   - Field: ‘owner’
[08:29:01.754]   - Field: ‘envir’
[08:29:01.754]   - Field: ‘workers’
[08:29:01.754]   - Field: ‘packages’
[08:29:01.755]   - Field: ‘gc’
[08:29:01.755] plan(): nbrOfWorkers() = 2
[08:29:01.755]   - Field: ‘job’
[08:29:01.755]   - Field: ‘conditions’
[08:29:01.755]   - Field: ‘expr’
[08:29:01.756]   - Field: ‘uuid’
[08:29:01.756]   - Field: ‘seed’
[08:29:01.756]   - Field: ‘version’
[08:29:01.756]   - Field: ‘result’
[08:29:01.756]   - Field: ‘asynchronous’
[08:29:01.756]   - Field: ‘calls’
[08:29:01.757]   - Field: ‘globals’
[08:29:01.757]   - Field: ‘stdout’
[08:29:01.757]   - Field: ‘earlySignal’
[08:29:01.757]   - Field: ‘lazy’
[08:29:01.757]   - Field: ‘state’
[08:29:01.757] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:01.758] - Launch lazy future ...
[08:29:01.758] Packages needed by the future expression (n = 0): <none>
[08:29:01.758] Packages needed by future strategies (n = 0): <none>
[08:29:01.759] {
[08:29:01.759]     {
[08:29:01.759]         {
[08:29:01.759]             ...future.startTime <- base::Sys.time()
[08:29:01.759]             {
[08:29:01.759]                 {
[08:29:01.759]                   {
[08:29:01.759]                     {
[08:29:01.759]                       base::local({
[08:29:01.759]                         has_future <- base::requireNamespace("future", 
[08:29:01.759]                           quietly = TRUE)
[08:29:01.759]                         if (has_future) {
[08:29:01.759]                           ns <- base::getNamespace("future")
[08:29:01.759]                           version <- ns[[".package"]][["version"]]
[08:29:01.759]                           if (is.null(version)) 
[08:29:01.759]                             version <- utils::packageVersion("future")
[08:29:01.759]                         }
[08:29:01.759]                         else {
[08:29:01.759]                           version <- NULL
[08:29:01.759]                         }
[08:29:01.759]                         if (!has_future || version < "1.8.0") {
[08:29:01.759]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.759]                             "", base::R.version$version.string), 
[08:29:01.759]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:01.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.759]                               "release", "version")], collapse = " "), 
[08:29:01.759]                             hostname = base::Sys.info()[["nodename"]])
[08:29:01.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.759]                             info)
[08:29:01.759]                           info <- base::paste(info, collapse = "; ")
[08:29:01.759]                           if (!has_future) {
[08:29:01.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.759]                               info)
[08:29:01.759]                           }
[08:29:01.759]                           else {
[08:29:01.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.759]                               info, version)
[08:29:01.759]                           }
[08:29:01.759]                           base::stop(msg)
[08:29:01.759]                         }
[08:29:01.759]                       })
[08:29:01.759]                     }
[08:29:01.759]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:01.759]                     base::options(mc.cores = 1L)
[08:29:01.759]                   }
[08:29:01.759]                   ...future.strategy.old <- future::plan("list")
[08:29:01.759]                   options(future.plan = NULL)
[08:29:01.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.759]                 }
[08:29:01.759]                 ...future.workdir <- getwd()
[08:29:01.759]             }
[08:29:01.759]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.759]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.759]         }
[08:29:01.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.759]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.759]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.759]             base::names(...future.oldOptions))
[08:29:01.759]     }
[08:29:01.759]     if (FALSE) {
[08:29:01.759]     }
[08:29:01.759]     else {
[08:29:01.759]         if (TRUE) {
[08:29:01.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.759]                 open = "w")
[08:29:01.759]         }
[08:29:01.759]         else {
[08:29:01.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.759]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.759]         }
[08:29:01.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.759]             base::sink(type = "output", split = FALSE)
[08:29:01.759]             base::close(...future.stdout)
[08:29:01.759]         }, add = TRUE)
[08:29:01.759]     }
[08:29:01.759]     ...future.frame <- base::sys.nframe()
[08:29:01.759]     ...future.conditions <- base::list()
[08:29:01.759]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.759]     if (FALSE) {
[08:29:01.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.759]     }
[08:29:01.759]     ...future.result <- base::tryCatch({
[08:29:01.759]         base::withCallingHandlers({
[08:29:01.759]             ...future.value <- base::withVisible(base::local({
[08:29:01.759]                 withCallingHandlers({
[08:29:01.759]                   1
[08:29:01.759]                 }, immediateCondition = function(cond) {
[08:29:01.759]                   save_rds <- function (object, pathname, ...) 
[08:29:01.759]                   {
[08:29:01.759]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:01.759]                     if (file_test("-f", pathname_tmp)) {
[08:29:01.759]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.759]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:01.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.759]                         fi_tmp[["mtime"]])
[08:29:01.759]                     }
[08:29:01.759]                     tryCatch({
[08:29:01.759]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:01.759]                     }, error = function(ex) {
[08:29:01.759]                       msg <- conditionMessage(ex)
[08:29:01.759]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.759]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:01.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.759]                         fi_tmp[["mtime"]], msg)
[08:29:01.759]                       ex$message <- msg
[08:29:01.759]                       stop(ex)
[08:29:01.759]                     })
[08:29:01.759]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:01.759]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:01.759]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:01.759]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.759]                       fi <- file.info(pathname)
[08:29:01.759]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:01.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.759]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:01.759]                         fi[["size"]], fi[["mtime"]])
[08:29:01.759]                       stop(msg)
[08:29:01.759]                     }
[08:29:01.759]                     invisible(pathname)
[08:29:01.759]                   }
[08:29:01.759]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:01.759]                     rootPath = tempdir()) 
[08:29:01.759]                   {
[08:29:01.759]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:01.759]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:01.759]                       tmpdir = path, fileext = ".rds")
[08:29:01.759]                     save_rds(obj, file)
[08:29:01.759]                   }
[08:29:01.759]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:01.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.759]                   {
[08:29:01.759]                     inherits <- base::inherits
[08:29:01.759]                     invokeRestart <- base::invokeRestart
[08:29:01.759]                     is.null <- base::is.null
[08:29:01.759]                     muffled <- FALSE
[08:29:01.759]                     if (inherits(cond, "message")) {
[08:29:01.759]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:01.759]                       if (muffled) 
[08:29:01.759]                         invokeRestart("muffleMessage")
[08:29:01.759]                     }
[08:29:01.759]                     else if (inherits(cond, "warning")) {
[08:29:01.759]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:01.759]                       if (muffled) 
[08:29:01.759]                         invokeRestart("muffleWarning")
[08:29:01.759]                     }
[08:29:01.759]                     else if (inherits(cond, "condition")) {
[08:29:01.759]                       if (!is.null(pattern)) {
[08:29:01.759]                         computeRestarts <- base::computeRestarts
[08:29:01.759]                         grepl <- base::grepl
[08:29:01.759]                         restarts <- computeRestarts(cond)
[08:29:01.759]                         for (restart in restarts) {
[08:29:01.759]                           name <- restart$name
[08:29:01.759]                           if (is.null(name)) 
[08:29:01.759]                             next
[08:29:01.759]                           if (!grepl(pattern, name)) 
[08:29:01.759]                             next
[08:29:01.759]                           invokeRestart(restart)
[08:29:01.759]                           muffled <- TRUE
[08:29:01.759]                           break
[08:29:01.759]                         }
[08:29:01.759]                       }
[08:29:01.759]                     }
[08:29:01.759]                     invisible(muffled)
[08:29:01.759]                   }
[08:29:01.759]                   muffleCondition(cond)
[08:29:01.759]                 })
[08:29:01.759]             }))
[08:29:01.759]             future::FutureResult(value = ...future.value$value, 
[08:29:01.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.759]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.759]                     ...future.globalenv.names))
[08:29:01.759]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.759]         }, condition = base::local({
[08:29:01.759]             c <- base::c
[08:29:01.759]             inherits <- base::inherits
[08:29:01.759]             invokeRestart <- base::invokeRestart
[08:29:01.759]             length <- base::length
[08:29:01.759]             list <- base::list
[08:29:01.759]             seq.int <- base::seq.int
[08:29:01.759]             signalCondition <- base::signalCondition
[08:29:01.759]             sys.calls <- base::sys.calls
[08:29:01.759]             `[[` <- base::`[[`
[08:29:01.759]             `+` <- base::`+`
[08:29:01.759]             `<<-` <- base::`<<-`
[08:29:01.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.759]                   3L)]
[08:29:01.759]             }
[08:29:01.759]             function(cond) {
[08:29:01.759]                 is_error <- inherits(cond, "error")
[08:29:01.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.759]                   NULL)
[08:29:01.759]                 if (is_error) {
[08:29:01.759]                   sessionInformation <- function() {
[08:29:01.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.759]                       search = base::search(), system = base::Sys.info())
[08:29:01.759]                   }
[08:29:01.759]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.759]                     cond$call), session = sessionInformation(), 
[08:29:01.759]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.759]                   signalCondition(cond)
[08:29:01.759]                 }
[08:29:01.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.759]                 "immediateCondition"))) {
[08:29:01.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.759]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.759]                   if (TRUE && !signal) {
[08:29:01.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.759]                     {
[08:29:01.759]                       inherits <- base::inherits
[08:29:01.759]                       invokeRestart <- base::invokeRestart
[08:29:01.759]                       is.null <- base::is.null
[08:29:01.759]                       muffled <- FALSE
[08:29:01.759]                       if (inherits(cond, "message")) {
[08:29:01.759]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.759]                         if (muffled) 
[08:29:01.759]                           invokeRestart("muffleMessage")
[08:29:01.759]                       }
[08:29:01.759]                       else if (inherits(cond, "warning")) {
[08:29:01.759]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.759]                         if (muffled) 
[08:29:01.759]                           invokeRestart("muffleWarning")
[08:29:01.759]                       }
[08:29:01.759]                       else if (inherits(cond, "condition")) {
[08:29:01.759]                         if (!is.null(pattern)) {
[08:29:01.759]                           computeRestarts <- base::computeRestarts
[08:29:01.759]                           grepl <- base::grepl
[08:29:01.759]                           restarts <- computeRestarts(cond)
[08:29:01.759]                           for (restart in restarts) {
[08:29:01.759]                             name <- restart$name
[08:29:01.759]                             if (is.null(name)) 
[08:29:01.759]                               next
[08:29:01.759]                             if (!grepl(pattern, name)) 
[08:29:01.759]                               next
[08:29:01.759]                             invokeRestart(restart)
[08:29:01.759]                             muffled <- TRUE
[08:29:01.759]                             break
[08:29:01.759]                           }
[08:29:01.759]                         }
[08:29:01.759]                       }
[08:29:01.759]                       invisible(muffled)
[08:29:01.759]                     }
[08:29:01.759]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.759]                   }
[08:29:01.759]                 }
[08:29:01.759]                 else {
[08:29:01.759]                   if (TRUE) {
[08:29:01.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.759]                     {
[08:29:01.759]                       inherits <- base::inherits
[08:29:01.759]                       invokeRestart <- base::invokeRestart
[08:29:01.759]                       is.null <- base::is.null
[08:29:01.759]                       muffled <- FALSE
[08:29:01.759]                       if (inherits(cond, "message")) {
[08:29:01.759]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.759]                         if (muffled) 
[08:29:01.759]                           invokeRestart("muffleMessage")
[08:29:01.759]                       }
[08:29:01.759]                       else if (inherits(cond, "warning")) {
[08:29:01.759]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.759]                         if (muffled) 
[08:29:01.759]                           invokeRestart("muffleWarning")
[08:29:01.759]                       }
[08:29:01.759]                       else if (inherits(cond, "condition")) {
[08:29:01.759]                         if (!is.null(pattern)) {
[08:29:01.759]                           computeRestarts <- base::computeRestarts
[08:29:01.759]                           grepl <- base::grepl
[08:29:01.759]                           restarts <- computeRestarts(cond)
[08:29:01.759]                           for (restart in restarts) {
[08:29:01.759]                             name <- restart$name
[08:29:01.759]                             if (is.null(name)) 
[08:29:01.759]                               next
[08:29:01.759]                             if (!grepl(pattern, name)) 
[08:29:01.759]                               next
[08:29:01.759]                             invokeRestart(restart)
[08:29:01.759]                             muffled <- TRUE
[08:29:01.759]                             break
[08:29:01.759]                           }
[08:29:01.759]                         }
[08:29:01.759]                       }
[08:29:01.759]                       invisible(muffled)
[08:29:01.759]                     }
[08:29:01.759]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.759]                   }
[08:29:01.759]                 }
[08:29:01.759]             }
[08:29:01.759]         }))
[08:29:01.759]     }, error = function(ex) {
[08:29:01.759]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.759]                 ...future.rng), started = ...future.startTime, 
[08:29:01.759]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.759]             version = "1.8"), class = "FutureResult")
[08:29:01.759]     }, finally = {
[08:29:01.759]         if (!identical(...future.workdir, getwd())) 
[08:29:01.759]             setwd(...future.workdir)
[08:29:01.759]         {
[08:29:01.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.759]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.759]             }
[08:29:01.759]             base::options(...future.oldOptions)
[08:29:01.759]             if (.Platform$OS.type == "windows") {
[08:29:01.759]                 old_names <- names(...future.oldEnvVars)
[08:29:01.759]                 envs <- base::Sys.getenv()
[08:29:01.759]                 names <- names(envs)
[08:29:01.759]                 common <- intersect(names, old_names)
[08:29:01.759]                 added <- setdiff(names, old_names)
[08:29:01.759]                 removed <- setdiff(old_names, names)
[08:29:01.759]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.759]                   envs[common]]
[08:29:01.759]                 NAMES <- toupper(changed)
[08:29:01.759]                 args <- list()
[08:29:01.759]                 for (kk in seq_along(NAMES)) {
[08:29:01.759]                   name <- changed[[kk]]
[08:29:01.759]                   NAME <- NAMES[[kk]]
[08:29:01.759]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.759]                     next
[08:29:01.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.759]                 }
[08:29:01.759]                 NAMES <- toupper(added)
[08:29:01.759]                 for (kk in seq_along(NAMES)) {
[08:29:01.759]                   name <- added[[kk]]
[08:29:01.759]                   NAME <- NAMES[[kk]]
[08:29:01.759]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.759]                     next
[08:29:01.759]                   args[[name]] <- ""
[08:29:01.759]                 }
[08:29:01.759]                 NAMES <- toupper(removed)
[08:29:01.759]                 for (kk in seq_along(NAMES)) {
[08:29:01.759]                   name <- removed[[kk]]
[08:29:01.759]                   NAME <- NAMES[[kk]]
[08:29:01.759]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.759]                     next
[08:29:01.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.759]                 }
[08:29:01.759]                 if (length(args) > 0) 
[08:29:01.759]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.759]             }
[08:29:01.759]             else {
[08:29:01.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.759]             }
[08:29:01.759]             {
[08:29:01.759]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.759]                   0L) {
[08:29:01.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.759]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.759]                   base::options(opts)
[08:29:01.759]                 }
[08:29:01.759]                 {
[08:29:01.759]                   {
[08:29:01.759]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:01.759]                     NULL
[08:29:01.759]                   }
[08:29:01.759]                   options(future.plan = NULL)
[08:29:01.759]                   if (is.na(NA_character_)) 
[08:29:01.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.759]                     .init = FALSE)
[08:29:01.759]                 }
[08:29:01.759]             }
[08:29:01.759]         }
[08:29:01.759]     })
[08:29:01.759]     if (TRUE) {
[08:29:01.759]         base::sink(type = "output", split = FALSE)
[08:29:01.759]         if (TRUE) {
[08:29:01.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.759]         }
[08:29:01.759]         else {
[08:29:01.759]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.759]         }
[08:29:01.759]         base::close(...future.stdout)
[08:29:01.759]         ...future.stdout <- NULL
[08:29:01.759]     }
[08:29:01.759]     ...future.result$conditions <- ...future.conditions
[08:29:01.759]     ...future.result$finished <- base::Sys.time()
[08:29:01.759]     ...future.result
[08:29:01.759] }
[08:29:01.762] requestCore(): workers = 2
[08:29:01.763] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:01.786] result() for MulticoreFuture ...
[08:29:01.787] result() for MulticoreFuture ...
[08:29:01.787] result() for MulticoreFuture ... done
[08:29:01.787] result() for MulticoreFuture ... done
[08:29:01.788] result() for MulticoreFuture ...
[08:29:01.788] result() for MulticoreFuture ... done
[08:29:01.790] MulticoreFuture started
[08:29:01.790] - Launch lazy future ... done
[08:29:01.791] run() for ‘MulticoreFuture’ ... done
[08:29:01.791] plan(): Setting new future strategy stack:
[08:29:01.791] List of future strategies:
[08:29:01.791] 1. sequential:
[08:29:01.791]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.791]    - tweaked: FALSE
[08:29:01.791]    - call: NULL
[08:29:01.793] plan(): nbrOfWorkers() = 1
[08:29:01.795] plan(): Setting new future strategy stack:
[08:29:01.795] List of future strategies:
[08:29:01.795] 1. multicore:
[08:29:01.795]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:01.795]    - tweaked: FALSE
[08:29:01.795]    - call: plan(strategy)
[08:29:01.798] plan(): nbrOfWorkers() = 2
[08:29:01.799] Future #1
[08:29:01.799]  length: 2 (resolved future 1)
[08:29:01.799] Future #2
[08:29:01.800]  length: 1 (resolved future 2)
[08:29:01.800]  length: 0 (resolved future 3)
[08:29:01.800] resolve() on list ... DONE
[08:29:01.800] getGlobalsAndPackages() ...
[08:29:01.801] Searching for globals...
[08:29:01.801] 
[08:29:01.801] Searching for globals ... DONE
[08:29:01.802] - globals: [0] <none>
[08:29:01.802] getGlobalsAndPackages() ... DONE
[08:29:01.802] getGlobalsAndPackages() ...
[08:29:01.802] Searching for globals...
[08:29:01.803] 
[08:29:01.803] Searching for globals ... DONE
[08:29:01.803] - globals: [0] <none>
[08:29:01.803] getGlobalsAndPackages() ... DONE
[08:29:01.803] resolve() on list ...
[08:29:01.804]  recursive: 0
[08:29:01.804]  length: 3
[08:29:01.804]  elements: ‘a’, ‘b’, ‘’
[08:29:01.804] run() for ‘Future’ ...
[08:29:01.804] - state: ‘created’
[08:29:01.804] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:01.813] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:01.813] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:01.813]   - Field: ‘label’
[08:29:01.814]   - Field: ‘local’
[08:29:01.814]   - Field: ‘owner’
[08:29:01.814]   - Field: ‘envir’
[08:29:01.815]   - Field: ‘workers’
[08:29:01.815]   - Field: ‘packages’
[08:29:01.815]   - Field: ‘gc’
[08:29:01.815]   - Field: ‘job’
[08:29:01.815]   - Field: ‘conditions’
[08:29:01.816]   - Field: ‘expr’
[08:29:01.816]   - Field: ‘uuid’
[08:29:01.816]   - Field: ‘seed’
[08:29:01.816]   - Field: ‘version’
[08:29:01.816]   - Field: ‘result’
[08:29:01.816]   - Field: ‘asynchronous’
[08:29:01.816]   - Field: ‘calls’
[08:29:01.817]   - Field: ‘globals’
[08:29:01.817]   - Field: ‘stdout’
[08:29:01.817]   - Field: ‘earlySignal’
[08:29:01.817]   - Field: ‘lazy’
[08:29:01.817]   - Field: ‘state’
[08:29:01.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:01.818] - Launch lazy future ...
[08:29:01.818] Packages needed by the future expression (n = 0): <none>
[08:29:01.818] Packages needed by future strategies (n = 0): <none>
[08:29:01.819] {
[08:29:01.819]     {
[08:29:01.819]         {
[08:29:01.819]             ...future.startTime <- base::Sys.time()
[08:29:01.819]             {
[08:29:01.819]                 {
[08:29:01.819]                   {
[08:29:01.819]                     {
[08:29:01.819]                       base::local({
[08:29:01.819]                         has_future <- base::requireNamespace("future", 
[08:29:01.819]                           quietly = TRUE)
[08:29:01.819]                         if (has_future) {
[08:29:01.819]                           ns <- base::getNamespace("future")
[08:29:01.819]                           version <- ns[[".package"]][["version"]]
[08:29:01.819]                           if (is.null(version)) 
[08:29:01.819]                             version <- utils::packageVersion("future")
[08:29:01.819]                         }
[08:29:01.819]                         else {
[08:29:01.819]                           version <- NULL
[08:29:01.819]                         }
[08:29:01.819]                         if (!has_future || version < "1.8.0") {
[08:29:01.819]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.819]                             "", base::R.version$version.string), 
[08:29:01.819]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:01.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.819]                               "release", "version")], collapse = " "), 
[08:29:01.819]                             hostname = base::Sys.info()[["nodename"]])
[08:29:01.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.819]                             info)
[08:29:01.819]                           info <- base::paste(info, collapse = "; ")
[08:29:01.819]                           if (!has_future) {
[08:29:01.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.819]                               info)
[08:29:01.819]                           }
[08:29:01.819]                           else {
[08:29:01.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.819]                               info, version)
[08:29:01.819]                           }
[08:29:01.819]                           base::stop(msg)
[08:29:01.819]                         }
[08:29:01.819]                       })
[08:29:01.819]                     }
[08:29:01.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:01.819]                     base::options(mc.cores = 1L)
[08:29:01.819]                   }
[08:29:01.819]                   ...future.strategy.old <- future::plan("list")
[08:29:01.819]                   options(future.plan = NULL)
[08:29:01.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.819]                 }
[08:29:01.819]                 ...future.workdir <- getwd()
[08:29:01.819]             }
[08:29:01.819]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.819]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.819]         }
[08:29:01.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.819]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.819]             base::names(...future.oldOptions))
[08:29:01.819]     }
[08:29:01.819]     if (FALSE) {
[08:29:01.819]     }
[08:29:01.819]     else {
[08:29:01.819]         if (TRUE) {
[08:29:01.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.819]                 open = "w")
[08:29:01.819]         }
[08:29:01.819]         else {
[08:29:01.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.819]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.819]         }
[08:29:01.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.819]             base::sink(type = "output", split = FALSE)
[08:29:01.819]             base::close(...future.stdout)
[08:29:01.819]         }, add = TRUE)
[08:29:01.819]     }
[08:29:01.819]     ...future.frame <- base::sys.nframe()
[08:29:01.819]     ...future.conditions <- base::list()
[08:29:01.819]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.819]     if (FALSE) {
[08:29:01.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.819]     }
[08:29:01.819]     ...future.result <- base::tryCatch({
[08:29:01.819]         base::withCallingHandlers({
[08:29:01.819]             ...future.value <- base::withVisible(base::local({
[08:29:01.819]                 withCallingHandlers({
[08:29:01.819]                   1
[08:29:01.819]                 }, immediateCondition = function(cond) {
[08:29:01.819]                   save_rds <- function (object, pathname, ...) 
[08:29:01.819]                   {
[08:29:01.819]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:01.819]                     if (file_test("-f", pathname_tmp)) {
[08:29:01.819]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.819]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:01.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.819]                         fi_tmp[["mtime"]])
[08:29:01.819]                     }
[08:29:01.819]                     tryCatch({
[08:29:01.819]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:01.819]                     }, error = function(ex) {
[08:29:01.819]                       msg <- conditionMessage(ex)
[08:29:01.819]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.819]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:01.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.819]                         fi_tmp[["mtime"]], msg)
[08:29:01.819]                       ex$message <- msg
[08:29:01.819]                       stop(ex)
[08:29:01.819]                     })
[08:29:01.819]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:01.819]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:01.819]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:01.819]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.819]                       fi <- file.info(pathname)
[08:29:01.819]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:01.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.819]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:01.819]                         fi[["size"]], fi[["mtime"]])
[08:29:01.819]                       stop(msg)
[08:29:01.819]                     }
[08:29:01.819]                     invisible(pathname)
[08:29:01.819]                   }
[08:29:01.819]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:01.819]                     rootPath = tempdir()) 
[08:29:01.819]                   {
[08:29:01.819]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:01.819]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:01.819]                       tmpdir = path, fileext = ".rds")
[08:29:01.819]                     save_rds(obj, file)
[08:29:01.819]                   }
[08:29:01.819]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:01.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.819]                   {
[08:29:01.819]                     inherits <- base::inherits
[08:29:01.819]                     invokeRestart <- base::invokeRestart
[08:29:01.819]                     is.null <- base::is.null
[08:29:01.819]                     muffled <- FALSE
[08:29:01.819]                     if (inherits(cond, "message")) {
[08:29:01.819]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:01.819]                       if (muffled) 
[08:29:01.819]                         invokeRestart("muffleMessage")
[08:29:01.819]                     }
[08:29:01.819]                     else if (inherits(cond, "warning")) {
[08:29:01.819]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:01.819]                       if (muffled) 
[08:29:01.819]                         invokeRestart("muffleWarning")
[08:29:01.819]                     }
[08:29:01.819]                     else if (inherits(cond, "condition")) {
[08:29:01.819]                       if (!is.null(pattern)) {
[08:29:01.819]                         computeRestarts <- base::computeRestarts
[08:29:01.819]                         grepl <- base::grepl
[08:29:01.819]                         restarts <- computeRestarts(cond)
[08:29:01.819]                         for (restart in restarts) {
[08:29:01.819]                           name <- restart$name
[08:29:01.819]                           if (is.null(name)) 
[08:29:01.819]                             next
[08:29:01.819]                           if (!grepl(pattern, name)) 
[08:29:01.819]                             next
[08:29:01.819]                           invokeRestart(restart)
[08:29:01.819]                           muffled <- TRUE
[08:29:01.819]                           break
[08:29:01.819]                         }
[08:29:01.819]                       }
[08:29:01.819]                     }
[08:29:01.819]                     invisible(muffled)
[08:29:01.819]                   }
[08:29:01.819]                   muffleCondition(cond)
[08:29:01.819]                 })
[08:29:01.819]             }))
[08:29:01.819]             future::FutureResult(value = ...future.value$value, 
[08:29:01.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.819]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.819]                     ...future.globalenv.names))
[08:29:01.819]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.819]         }, condition = base::local({
[08:29:01.819]             c <- base::c
[08:29:01.819]             inherits <- base::inherits
[08:29:01.819]             invokeRestart <- base::invokeRestart
[08:29:01.819]             length <- base::length
[08:29:01.819]             list <- base::list
[08:29:01.819]             seq.int <- base::seq.int
[08:29:01.819]             signalCondition <- base::signalCondition
[08:29:01.819]             sys.calls <- base::sys.calls
[08:29:01.819]             `[[` <- base::`[[`
[08:29:01.819]             `+` <- base::`+`
[08:29:01.819]             `<<-` <- base::`<<-`
[08:29:01.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.819]                   3L)]
[08:29:01.819]             }
[08:29:01.819]             function(cond) {
[08:29:01.819]                 is_error <- inherits(cond, "error")
[08:29:01.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.819]                   NULL)
[08:29:01.819]                 if (is_error) {
[08:29:01.819]                   sessionInformation <- function() {
[08:29:01.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.819]                       search = base::search(), system = base::Sys.info())
[08:29:01.819]                   }
[08:29:01.819]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.819]                     cond$call), session = sessionInformation(), 
[08:29:01.819]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.819]                   signalCondition(cond)
[08:29:01.819]                 }
[08:29:01.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.819]                 "immediateCondition"))) {
[08:29:01.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.819]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.819]                   if (TRUE && !signal) {
[08:29:01.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.819]                     {
[08:29:01.819]                       inherits <- base::inherits
[08:29:01.819]                       invokeRestart <- base::invokeRestart
[08:29:01.819]                       is.null <- base::is.null
[08:29:01.819]                       muffled <- FALSE
[08:29:01.819]                       if (inherits(cond, "message")) {
[08:29:01.819]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.819]                         if (muffled) 
[08:29:01.819]                           invokeRestart("muffleMessage")
[08:29:01.819]                       }
[08:29:01.819]                       else if (inherits(cond, "warning")) {
[08:29:01.819]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.819]                         if (muffled) 
[08:29:01.819]                           invokeRestart("muffleWarning")
[08:29:01.819]                       }
[08:29:01.819]                       else if (inherits(cond, "condition")) {
[08:29:01.819]                         if (!is.null(pattern)) {
[08:29:01.819]                           computeRestarts <- base::computeRestarts
[08:29:01.819]                           grepl <- base::grepl
[08:29:01.819]                           restarts <- computeRestarts(cond)
[08:29:01.819]                           for (restart in restarts) {
[08:29:01.819]                             name <- restart$name
[08:29:01.819]                             if (is.null(name)) 
[08:29:01.819]                               next
[08:29:01.819]                             if (!grepl(pattern, name)) 
[08:29:01.819]                               next
[08:29:01.819]                             invokeRestart(restart)
[08:29:01.819]                             muffled <- TRUE
[08:29:01.819]                             break
[08:29:01.819]                           }
[08:29:01.819]                         }
[08:29:01.819]                       }
[08:29:01.819]                       invisible(muffled)
[08:29:01.819]                     }
[08:29:01.819]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.819]                   }
[08:29:01.819]                 }
[08:29:01.819]                 else {
[08:29:01.819]                   if (TRUE) {
[08:29:01.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.819]                     {
[08:29:01.819]                       inherits <- base::inherits
[08:29:01.819]                       invokeRestart <- base::invokeRestart
[08:29:01.819]                       is.null <- base::is.null
[08:29:01.819]                       muffled <- FALSE
[08:29:01.819]                       if (inherits(cond, "message")) {
[08:29:01.819]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.819]                         if (muffled) 
[08:29:01.819]                           invokeRestart("muffleMessage")
[08:29:01.819]                       }
[08:29:01.819]                       else if (inherits(cond, "warning")) {
[08:29:01.819]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.819]                         if (muffled) 
[08:29:01.819]                           invokeRestart("muffleWarning")
[08:29:01.819]                       }
[08:29:01.819]                       else if (inherits(cond, "condition")) {
[08:29:01.819]                         if (!is.null(pattern)) {
[08:29:01.819]                           computeRestarts <- base::computeRestarts
[08:29:01.819]                           grepl <- base::grepl
[08:29:01.819]                           restarts <- computeRestarts(cond)
[08:29:01.819]                           for (restart in restarts) {
[08:29:01.819]                             name <- restart$name
[08:29:01.819]                             if (is.null(name)) 
[08:29:01.819]                               next
[08:29:01.819]                             if (!grepl(pattern, name)) 
[08:29:01.819]                               next
[08:29:01.819]                             invokeRestart(restart)
[08:29:01.819]                             muffled <- TRUE
[08:29:01.819]                             break
[08:29:01.819]                           }
[08:29:01.819]                         }
[08:29:01.819]                       }
[08:29:01.819]                       invisible(muffled)
[08:29:01.819]                     }
[08:29:01.819]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.819]                   }
[08:29:01.819]                 }
[08:29:01.819]             }
[08:29:01.819]         }))
[08:29:01.819]     }, error = function(ex) {
[08:29:01.819]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.819]                 ...future.rng), started = ...future.startTime, 
[08:29:01.819]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.819]             version = "1.8"), class = "FutureResult")
[08:29:01.819]     }, finally = {
[08:29:01.819]         if (!identical(...future.workdir, getwd())) 
[08:29:01.819]             setwd(...future.workdir)
[08:29:01.819]         {
[08:29:01.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.819]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.819]             }
[08:29:01.819]             base::options(...future.oldOptions)
[08:29:01.819]             if (.Platform$OS.type == "windows") {
[08:29:01.819]                 old_names <- names(...future.oldEnvVars)
[08:29:01.819]                 envs <- base::Sys.getenv()
[08:29:01.819]                 names <- names(envs)
[08:29:01.819]                 common <- intersect(names, old_names)
[08:29:01.819]                 added <- setdiff(names, old_names)
[08:29:01.819]                 removed <- setdiff(old_names, names)
[08:29:01.819]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.819]                   envs[common]]
[08:29:01.819]                 NAMES <- toupper(changed)
[08:29:01.819]                 args <- list()
[08:29:01.819]                 for (kk in seq_along(NAMES)) {
[08:29:01.819]                   name <- changed[[kk]]
[08:29:01.819]                   NAME <- NAMES[[kk]]
[08:29:01.819]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.819]                     next
[08:29:01.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.819]                 }
[08:29:01.819]                 NAMES <- toupper(added)
[08:29:01.819]                 for (kk in seq_along(NAMES)) {
[08:29:01.819]                   name <- added[[kk]]
[08:29:01.819]                   NAME <- NAMES[[kk]]
[08:29:01.819]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.819]                     next
[08:29:01.819]                   args[[name]] <- ""
[08:29:01.819]                 }
[08:29:01.819]                 NAMES <- toupper(removed)
[08:29:01.819]                 for (kk in seq_along(NAMES)) {
[08:29:01.819]                   name <- removed[[kk]]
[08:29:01.819]                   NAME <- NAMES[[kk]]
[08:29:01.819]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.819]                     next
[08:29:01.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.819]                 }
[08:29:01.819]                 if (length(args) > 0) 
[08:29:01.819]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.819]             }
[08:29:01.819]             else {
[08:29:01.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.819]             }
[08:29:01.819]             {
[08:29:01.819]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.819]                   0L) {
[08:29:01.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.819]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.819]                   base::options(opts)
[08:29:01.819]                 }
[08:29:01.819]                 {
[08:29:01.819]                   {
[08:29:01.819]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:01.819]                     NULL
[08:29:01.819]                   }
[08:29:01.819]                   options(future.plan = NULL)
[08:29:01.819]                   if (is.na(NA_character_)) 
[08:29:01.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.819]                     .init = FALSE)
[08:29:01.819]                 }
[08:29:01.819]             }
[08:29:01.819]         }
[08:29:01.819]     })
[08:29:01.819]     if (TRUE) {
[08:29:01.819]         base::sink(type = "output", split = FALSE)
[08:29:01.819]         if (TRUE) {
[08:29:01.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.819]         }
[08:29:01.819]         else {
[08:29:01.819]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.819]         }
[08:29:01.819]         base::close(...future.stdout)
[08:29:01.819]         ...future.stdout <- NULL
[08:29:01.819]     }
[08:29:01.819]     ...future.result$conditions <- ...future.conditions
[08:29:01.819]     ...future.result$finished <- base::Sys.time()
[08:29:01.819]     ...future.result
[08:29:01.819] }
[08:29:01.822] requestCore(): workers = 2
[08:29:01.822] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:01.833] result() for MulticoreFuture ...
[08:29:01.833] result() for MulticoreFuture ...
[08:29:01.834] result() for MulticoreFuture ... done
[08:29:01.834] result() for MulticoreFuture ... done
[08:29:01.834] result() for MulticoreFuture ...
[08:29:01.834] result() for MulticoreFuture ... done
[08:29:01.837] MulticoreFuture started
[08:29:01.837] - Launch lazy future ... done
[08:29:01.838] run() for ‘MulticoreFuture’ ... done
[08:29:01.838] plan(): Setting new future strategy stack:
[08:29:01.838] List of future strategies:
[08:29:01.838] 1. sequential:
[08:29:01.838]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.838]    - tweaked: FALSE
[08:29:01.838]    - call: NULL
[08:29:01.839] plan(): nbrOfWorkers() = 1
[08:29:01.842] plan(): Setting new future strategy stack:
[08:29:01.842] List of future strategies:
[08:29:01.842] 1. multicore:
[08:29:01.842]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:01.842]    - tweaked: FALSE
[08:29:01.842]    - call: plan(strategy)
[08:29:01.845] plan(): nbrOfWorkers() = 2
[08:29:01.846] Future #1
[08:29:01.846]  length: 2 (resolved future 1)
[08:29:01.846] run() for ‘Future’ ...
[08:29:01.846] - state: ‘created’
[08:29:01.847] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:01.849] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:01.850] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:01.850]   - Field: ‘label’
[08:29:01.850]   - Field: ‘local’
[08:29:01.850]   - Field: ‘owner’
[08:29:01.850]   - Field: ‘envir’
[08:29:01.850]   - Field: ‘workers’
[08:29:01.850]   - Field: ‘packages’
[08:29:01.851]   - Field: ‘gc’
[08:29:01.851]   - Field: ‘job’
[08:29:01.851]   - Field: ‘conditions’
[08:29:01.851]   - Field: ‘expr’
[08:29:01.851]   - Field: ‘uuid’
[08:29:01.851]   - Field: ‘seed’
[08:29:01.851]   - Field: ‘version’
[08:29:01.851]   - Field: ‘result’
[08:29:01.852]   - Field: ‘asynchronous’
[08:29:01.852]   - Field: ‘calls’
[08:29:01.852]   - Field: ‘globals’
[08:29:01.852]   - Field: ‘stdout’
[08:29:01.852]   - Field: ‘earlySignal’
[08:29:01.852]   - Field: ‘lazy’
[08:29:01.853]   - Field: ‘state’
[08:29:01.853] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:01.853] - Launch lazy future ...
[08:29:01.853] Packages needed by the future expression (n = 0): <none>
[08:29:01.854] Packages needed by future strategies (n = 0): <none>
[08:29:01.854] {
[08:29:01.854]     {
[08:29:01.854]         {
[08:29:01.854]             ...future.startTime <- base::Sys.time()
[08:29:01.854]             {
[08:29:01.854]                 {
[08:29:01.854]                   {
[08:29:01.854]                     {
[08:29:01.854]                       base::local({
[08:29:01.854]                         has_future <- base::requireNamespace("future", 
[08:29:01.854]                           quietly = TRUE)
[08:29:01.854]                         if (has_future) {
[08:29:01.854]                           ns <- base::getNamespace("future")
[08:29:01.854]                           version <- ns[[".package"]][["version"]]
[08:29:01.854]                           if (is.null(version)) 
[08:29:01.854]                             version <- utils::packageVersion("future")
[08:29:01.854]                         }
[08:29:01.854]                         else {
[08:29:01.854]                           version <- NULL
[08:29:01.854]                         }
[08:29:01.854]                         if (!has_future || version < "1.8.0") {
[08:29:01.854]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.854]                             "", base::R.version$version.string), 
[08:29:01.854]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:01.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.854]                               "release", "version")], collapse = " "), 
[08:29:01.854]                             hostname = base::Sys.info()[["nodename"]])
[08:29:01.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.854]                             info)
[08:29:01.854]                           info <- base::paste(info, collapse = "; ")
[08:29:01.854]                           if (!has_future) {
[08:29:01.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.854]                               info)
[08:29:01.854]                           }
[08:29:01.854]                           else {
[08:29:01.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.854]                               info, version)
[08:29:01.854]                           }
[08:29:01.854]                           base::stop(msg)
[08:29:01.854]                         }
[08:29:01.854]                       })
[08:29:01.854]                     }
[08:29:01.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:01.854]                     base::options(mc.cores = 1L)
[08:29:01.854]                   }
[08:29:01.854]                   ...future.strategy.old <- future::plan("list")
[08:29:01.854]                   options(future.plan = NULL)
[08:29:01.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.854]                 }
[08:29:01.854]                 ...future.workdir <- getwd()
[08:29:01.854]             }
[08:29:01.854]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.854]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.854]         }
[08:29:01.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.854]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.854]             base::names(...future.oldOptions))
[08:29:01.854]     }
[08:29:01.854]     if (FALSE) {
[08:29:01.854]     }
[08:29:01.854]     else {
[08:29:01.854]         if (TRUE) {
[08:29:01.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.854]                 open = "w")
[08:29:01.854]         }
[08:29:01.854]         else {
[08:29:01.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.854]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.854]         }
[08:29:01.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.854]             base::sink(type = "output", split = FALSE)
[08:29:01.854]             base::close(...future.stdout)
[08:29:01.854]         }, add = TRUE)
[08:29:01.854]     }
[08:29:01.854]     ...future.frame <- base::sys.nframe()
[08:29:01.854]     ...future.conditions <- base::list()
[08:29:01.854]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.854]     if (FALSE) {
[08:29:01.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.854]     }
[08:29:01.854]     ...future.result <- base::tryCatch({
[08:29:01.854]         base::withCallingHandlers({
[08:29:01.854]             ...future.value <- base::withVisible(base::local({
[08:29:01.854]                 withCallingHandlers({
[08:29:01.854]                   2
[08:29:01.854]                 }, immediateCondition = function(cond) {
[08:29:01.854]                   save_rds <- function (object, pathname, ...) 
[08:29:01.854]                   {
[08:29:01.854]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:01.854]                     if (file_test("-f", pathname_tmp)) {
[08:29:01.854]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.854]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:01.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.854]                         fi_tmp[["mtime"]])
[08:29:01.854]                     }
[08:29:01.854]                     tryCatch({
[08:29:01.854]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:01.854]                     }, error = function(ex) {
[08:29:01.854]                       msg <- conditionMessage(ex)
[08:29:01.854]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.854]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:01.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.854]                         fi_tmp[["mtime"]], msg)
[08:29:01.854]                       ex$message <- msg
[08:29:01.854]                       stop(ex)
[08:29:01.854]                     })
[08:29:01.854]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:01.854]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:01.854]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:01.854]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.854]                       fi <- file.info(pathname)
[08:29:01.854]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:01.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.854]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:01.854]                         fi[["size"]], fi[["mtime"]])
[08:29:01.854]                       stop(msg)
[08:29:01.854]                     }
[08:29:01.854]                     invisible(pathname)
[08:29:01.854]                   }
[08:29:01.854]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:01.854]                     rootPath = tempdir()) 
[08:29:01.854]                   {
[08:29:01.854]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:01.854]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:01.854]                       tmpdir = path, fileext = ".rds")
[08:29:01.854]                     save_rds(obj, file)
[08:29:01.854]                   }
[08:29:01.854]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:01.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.854]                   {
[08:29:01.854]                     inherits <- base::inherits
[08:29:01.854]                     invokeRestart <- base::invokeRestart
[08:29:01.854]                     is.null <- base::is.null
[08:29:01.854]                     muffled <- FALSE
[08:29:01.854]                     if (inherits(cond, "message")) {
[08:29:01.854]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:01.854]                       if (muffled) 
[08:29:01.854]                         invokeRestart("muffleMessage")
[08:29:01.854]                     }
[08:29:01.854]                     else if (inherits(cond, "warning")) {
[08:29:01.854]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:01.854]                       if (muffled) 
[08:29:01.854]                         invokeRestart("muffleWarning")
[08:29:01.854]                     }
[08:29:01.854]                     else if (inherits(cond, "condition")) {
[08:29:01.854]                       if (!is.null(pattern)) {
[08:29:01.854]                         computeRestarts <- base::computeRestarts
[08:29:01.854]                         grepl <- base::grepl
[08:29:01.854]                         restarts <- computeRestarts(cond)
[08:29:01.854]                         for (restart in restarts) {
[08:29:01.854]                           name <- restart$name
[08:29:01.854]                           if (is.null(name)) 
[08:29:01.854]                             next
[08:29:01.854]                           if (!grepl(pattern, name)) 
[08:29:01.854]                             next
[08:29:01.854]                           invokeRestart(restart)
[08:29:01.854]                           muffled <- TRUE
[08:29:01.854]                           break
[08:29:01.854]                         }
[08:29:01.854]                       }
[08:29:01.854]                     }
[08:29:01.854]                     invisible(muffled)
[08:29:01.854]                   }
[08:29:01.854]                   muffleCondition(cond)
[08:29:01.854]                 })
[08:29:01.854]             }))
[08:29:01.854]             future::FutureResult(value = ...future.value$value, 
[08:29:01.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.854]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.854]                     ...future.globalenv.names))
[08:29:01.854]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.854]         }, condition = base::local({
[08:29:01.854]             c <- base::c
[08:29:01.854]             inherits <- base::inherits
[08:29:01.854]             invokeRestart <- base::invokeRestart
[08:29:01.854]             length <- base::length
[08:29:01.854]             list <- base::list
[08:29:01.854]             seq.int <- base::seq.int
[08:29:01.854]             signalCondition <- base::signalCondition
[08:29:01.854]             sys.calls <- base::sys.calls
[08:29:01.854]             `[[` <- base::`[[`
[08:29:01.854]             `+` <- base::`+`
[08:29:01.854]             `<<-` <- base::`<<-`
[08:29:01.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.854]                   3L)]
[08:29:01.854]             }
[08:29:01.854]             function(cond) {
[08:29:01.854]                 is_error <- inherits(cond, "error")
[08:29:01.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.854]                   NULL)
[08:29:01.854]                 if (is_error) {
[08:29:01.854]                   sessionInformation <- function() {
[08:29:01.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.854]                       search = base::search(), system = base::Sys.info())
[08:29:01.854]                   }
[08:29:01.854]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.854]                     cond$call), session = sessionInformation(), 
[08:29:01.854]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.854]                   signalCondition(cond)
[08:29:01.854]                 }
[08:29:01.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.854]                 "immediateCondition"))) {
[08:29:01.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.854]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.854]                   if (TRUE && !signal) {
[08:29:01.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.854]                     {
[08:29:01.854]                       inherits <- base::inherits
[08:29:01.854]                       invokeRestart <- base::invokeRestart
[08:29:01.854]                       is.null <- base::is.null
[08:29:01.854]                       muffled <- FALSE
[08:29:01.854]                       if (inherits(cond, "message")) {
[08:29:01.854]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.854]                         if (muffled) 
[08:29:01.854]                           invokeRestart("muffleMessage")
[08:29:01.854]                       }
[08:29:01.854]                       else if (inherits(cond, "warning")) {
[08:29:01.854]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.854]                         if (muffled) 
[08:29:01.854]                           invokeRestart("muffleWarning")
[08:29:01.854]                       }
[08:29:01.854]                       else if (inherits(cond, "condition")) {
[08:29:01.854]                         if (!is.null(pattern)) {
[08:29:01.854]                           computeRestarts <- base::computeRestarts
[08:29:01.854]                           grepl <- base::grepl
[08:29:01.854]                           restarts <- computeRestarts(cond)
[08:29:01.854]                           for (restart in restarts) {
[08:29:01.854]                             name <- restart$name
[08:29:01.854]                             if (is.null(name)) 
[08:29:01.854]                               next
[08:29:01.854]                             if (!grepl(pattern, name)) 
[08:29:01.854]                               next
[08:29:01.854]                             invokeRestart(restart)
[08:29:01.854]                             muffled <- TRUE
[08:29:01.854]                             break
[08:29:01.854]                           }
[08:29:01.854]                         }
[08:29:01.854]                       }
[08:29:01.854]                       invisible(muffled)
[08:29:01.854]                     }
[08:29:01.854]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.854]                   }
[08:29:01.854]                 }
[08:29:01.854]                 else {
[08:29:01.854]                   if (TRUE) {
[08:29:01.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.854]                     {
[08:29:01.854]                       inherits <- base::inherits
[08:29:01.854]                       invokeRestart <- base::invokeRestart
[08:29:01.854]                       is.null <- base::is.null
[08:29:01.854]                       muffled <- FALSE
[08:29:01.854]                       if (inherits(cond, "message")) {
[08:29:01.854]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.854]                         if (muffled) 
[08:29:01.854]                           invokeRestart("muffleMessage")
[08:29:01.854]                       }
[08:29:01.854]                       else if (inherits(cond, "warning")) {
[08:29:01.854]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.854]                         if (muffled) 
[08:29:01.854]                           invokeRestart("muffleWarning")
[08:29:01.854]                       }
[08:29:01.854]                       else if (inherits(cond, "condition")) {
[08:29:01.854]                         if (!is.null(pattern)) {
[08:29:01.854]                           computeRestarts <- base::computeRestarts
[08:29:01.854]                           grepl <- base::grepl
[08:29:01.854]                           restarts <- computeRestarts(cond)
[08:29:01.854]                           for (restart in restarts) {
[08:29:01.854]                             name <- restart$name
[08:29:01.854]                             if (is.null(name)) 
[08:29:01.854]                               next
[08:29:01.854]                             if (!grepl(pattern, name)) 
[08:29:01.854]                               next
[08:29:01.854]                             invokeRestart(restart)
[08:29:01.854]                             muffled <- TRUE
[08:29:01.854]                             break
[08:29:01.854]                           }
[08:29:01.854]                         }
[08:29:01.854]                       }
[08:29:01.854]                       invisible(muffled)
[08:29:01.854]                     }
[08:29:01.854]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.854]                   }
[08:29:01.854]                 }
[08:29:01.854]             }
[08:29:01.854]         }))
[08:29:01.854]     }, error = function(ex) {
[08:29:01.854]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.854]                 ...future.rng), started = ...future.startTime, 
[08:29:01.854]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.854]             version = "1.8"), class = "FutureResult")
[08:29:01.854]     }, finally = {
[08:29:01.854]         if (!identical(...future.workdir, getwd())) 
[08:29:01.854]             setwd(...future.workdir)
[08:29:01.854]         {
[08:29:01.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.854]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.854]             }
[08:29:01.854]             base::options(...future.oldOptions)
[08:29:01.854]             if (.Platform$OS.type == "windows") {
[08:29:01.854]                 old_names <- names(...future.oldEnvVars)
[08:29:01.854]                 envs <- base::Sys.getenv()
[08:29:01.854]                 names <- names(envs)
[08:29:01.854]                 common <- intersect(names, old_names)
[08:29:01.854]                 added <- setdiff(names, old_names)
[08:29:01.854]                 removed <- setdiff(old_names, names)
[08:29:01.854]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.854]                   envs[common]]
[08:29:01.854]                 NAMES <- toupper(changed)
[08:29:01.854]                 args <- list()
[08:29:01.854]                 for (kk in seq_along(NAMES)) {
[08:29:01.854]                   name <- changed[[kk]]
[08:29:01.854]                   NAME <- NAMES[[kk]]
[08:29:01.854]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.854]                     next
[08:29:01.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.854]                 }
[08:29:01.854]                 NAMES <- toupper(added)
[08:29:01.854]                 for (kk in seq_along(NAMES)) {
[08:29:01.854]                   name <- added[[kk]]
[08:29:01.854]                   NAME <- NAMES[[kk]]
[08:29:01.854]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.854]                     next
[08:29:01.854]                   args[[name]] <- ""
[08:29:01.854]                 }
[08:29:01.854]                 NAMES <- toupper(removed)
[08:29:01.854]                 for (kk in seq_along(NAMES)) {
[08:29:01.854]                   name <- removed[[kk]]
[08:29:01.854]                   NAME <- NAMES[[kk]]
[08:29:01.854]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.854]                     next
[08:29:01.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.854]                 }
[08:29:01.854]                 if (length(args) > 0) 
[08:29:01.854]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.854]             }
[08:29:01.854]             else {
[08:29:01.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.854]             }
[08:29:01.854]             {
[08:29:01.854]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.854]                   0L) {
[08:29:01.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.854]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.854]                   base::options(opts)
[08:29:01.854]                 }
[08:29:01.854]                 {
[08:29:01.854]                   {
[08:29:01.854]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:01.854]                     NULL
[08:29:01.854]                   }
[08:29:01.854]                   options(future.plan = NULL)
[08:29:01.854]                   if (is.na(NA_character_)) 
[08:29:01.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.854]                     .init = FALSE)
[08:29:01.854]                 }
[08:29:01.854]             }
[08:29:01.854]         }
[08:29:01.854]     })
[08:29:01.854]     if (TRUE) {
[08:29:01.854]         base::sink(type = "output", split = FALSE)
[08:29:01.854]         if (TRUE) {
[08:29:01.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.854]         }
[08:29:01.854]         else {
[08:29:01.854]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.854]         }
[08:29:01.854]         base::close(...future.stdout)
[08:29:01.854]         ...future.stdout <- NULL
[08:29:01.854]     }
[08:29:01.854]     ...future.result$conditions <- ...future.conditions
[08:29:01.854]     ...future.result$finished <- base::Sys.time()
[08:29:01.854]     ...future.result
[08:29:01.854] }
[08:29:01.858] requestCore(): workers = 2
[08:29:01.858] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:01.869] result() for MulticoreFuture ...
[08:29:01.870] result() for MulticoreFuture ...
[08:29:01.870] result() for MulticoreFuture ... done
[08:29:01.870] result() for MulticoreFuture ... done
[08:29:01.870] result() for MulticoreFuture ...
[08:29:01.871] result() for MulticoreFuture ... done
[08:29:01.873] MulticoreFuture started
[08:29:01.874] - Launch lazy future ... done
[08:29:01.874] run() for ‘MulticoreFuture’ ... done
[08:29:01.874] plan(): Setting new future strategy stack:
[08:29:01.875] List of future strategies:
[08:29:01.875] 1. sequential:
[08:29:01.875]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.875]    - tweaked: FALSE
[08:29:01.875]    - call: NULL
[08:29:01.876] plan(): nbrOfWorkers() = 1
[08:29:01.878] plan(): Setting new future strategy stack:
[08:29:01.878] List of future strategies:
[08:29:01.878] 1. multicore:
[08:29:01.878]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:01.878]    - tweaked: FALSE
[08:29:01.878]    - call: plan(strategy)
[08:29:01.881] plan(): nbrOfWorkers() = 2
[08:29:01.882] Future #2
[08:29:01.882]  length: 1 (resolved future 2)
[08:29:01.882]  length: 0 (resolved future 3)
[08:29:01.882] resolve() on list ... DONE
[08:29:01.883] getGlobalsAndPackages() ...
[08:29:01.883] Searching for globals...
[08:29:01.884] 
[08:29:01.884] Searching for globals ... DONE
[08:29:01.884] - globals: [0] <none>
[08:29:01.884] getGlobalsAndPackages() ... DONE
[08:29:01.885] run() for ‘Future’ ...
[08:29:01.885] - state: ‘created’
[08:29:01.885] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:01.888] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:01.888] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:01.888]   - Field: ‘label’
[08:29:01.888]   - Field: ‘local’
[08:29:01.888]   - Field: ‘owner’
[08:29:01.888]   - Field: ‘envir’
[08:29:01.888]   - Field: ‘workers’
[08:29:01.889]   - Field: ‘packages’
[08:29:01.889]   - Field: ‘gc’
[08:29:01.889]   - Field: ‘job’
[08:29:01.889]   - Field: ‘conditions’
[08:29:01.889]   - Field: ‘expr’
[08:29:01.889]   - Field: ‘uuid’
[08:29:01.889]   - Field: ‘seed’
[08:29:01.890]   - Field: ‘version’
[08:29:01.890]   - Field: ‘result’
[08:29:01.890]   - Field: ‘asynchronous’
[08:29:01.890]   - Field: ‘calls’
[08:29:01.890]   - Field: ‘globals’
[08:29:01.890]   - Field: ‘stdout’
[08:29:01.890]   - Field: ‘earlySignal’
[08:29:01.890]   - Field: ‘lazy’
[08:29:01.891]   - Field: ‘state’
[08:29:01.891] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:01.891] - Launch lazy future ...
[08:29:01.891] Packages needed by the future expression (n = 0): <none>
[08:29:01.891] Packages needed by future strategies (n = 0): <none>
[08:29:01.892] {
[08:29:01.892]     {
[08:29:01.892]         {
[08:29:01.892]             ...future.startTime <- base::Sys.time()
[08:29:01.892]             {
[08:29:01.892]                 {
[08:29:01.892]                   {
[08:29:01.892]                     {
[08:29:01.892]                       base::local({
[08:29:01.892]                         has_future <- base::requireNamespace("future", 
[08:29:01.892]                           quietly = TRUE)
[08:29:01.892]                         if (has_future) {
[08:29:01.892]                           ns <- base::getNamespace("future")
[08:29:01.892]                           version <- ns[[".package"]][["version"]]
[08:29:01.892]                           if (is.null(version)) 
[08:29:01.892]                             version <- utils::packageVersion("future")
[08:29:01.892]                         }
[08:29:01.892]                         else {
[08:29:01.892]                           version <- NULL
[08:29:01.892]                         }
[08:29:01.892]                         if (!has_future || version < "1.8.0") {
[08:29:01.892]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.892]                             "", base::R.version$version.string), 
[08:29:01.892]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:01.892]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.892]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.892]                               "release", "version")], collapse = " "), 
[08:29:01.892]                             hostname = base::Sys.info()[["nodename"]])
[08:29:01.892]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.892]                             info)
[08:29:01.892]                           info <- base::paste(info, collapse = "; ")
[08:29:01.892]                           if (!has_future) {
[08:29:01.892]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.892]                               info)
[08:29:01.892]                           }
[08:29:01.892]                           else {
[08:29:01.892]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.892]                               info, version)
[08:29:01.892]                           }
[08:29:01.892]                           base::stop(msg)
[08:29:01.892]                         }
[08:29:01.892]                       })
[08:29:01.892]                     }
[08:29:01.892]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:01.892]                     base::options(mc.cores = 1L)
[08:29:01.892]                   }
[08:29:01.892]                   ...future.strategy.old <- future::plan("list")
[08:29:01.892]                   options(future.plan = NULL)
[08:29:01.892]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.892]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.892]                 }
[08:29:01.892]                 ...future.workdir <- getwd()
[08:29:01.892]             }
[08:29:01.892]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.892]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.892]         }
[08:29:01.892]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.892]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.892]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.892]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.892]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.892]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.892]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.892]             base::names(...future.oldOptions))
[08:29:01.892]     }
[08:29:01.892]     if (FALSE) {
[08:29:01.892]     }
[08:29:01.892]     else {
[08:29:01.892]         if (TRUE) {
[08:29:01.892]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.892]                 open = "w")
[08:29:01.892]         }
[08:29:01.892]         else {
[08:29:01.892]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.892]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.892]         }
[08:29:01.892]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.892]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.892]             base::sink(type = "output", split = FALSE)
[08:29:01.892]             base::close(...future.stdout)
[08:29:01.892]         }, add = TRUE)
[08:29:01.892]     }
[08:29:01.892]     ...future.frame <- base::sys.nframe()
[08:29:01.892]     ...future.conditions <- base::list()
[08:29:01.892]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.892]     if (FALSE) {
[08:29:01.892]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.892]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.892]     }
[08:29:01.892]     ...future.result <- base::tryCatch({
[08:29:01.892]         base::withCallingHandlers({
[08:29:01.892]             ...future.value <- base::withVisible(base::local({
[08:29:01.892]                 withCallingHandlers({
[08:29:01.892]                   1
[08:29:01.892]                 }, immediateCondition = function(cond) {
[08:29:01.892]                   save_rds <- function (object, pathname, ...) 
[08:29:01.892]                   {
[08:29:01.892]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:01.892]                     if (file_test("-f", pathname_tmp)) {
[08:29:01.892]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.892]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:01.892]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.892]                         fi_tmp[["mtime"]])
[08:29:01.892]                     }
[08:29:01.892]                     tryCatch({
[08:29:01.892]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:01.892]                     }, error = function(ex) {
[08:29:01.892]                       msg <- conditionMessage(ex)
[08:29:01.892]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.892]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:01.892]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.892]                         fi_tmp[["mtime"]], msg)
[08:29:01.892]                       ex$message <- msg
[08:29:01.892]                       stop(ex)
[08:29:01.892]                     })
[08:29:01.892]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:01.892]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:01.892]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:01.892]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.892]                       fi <- file.info(pathname)
[08:29:01.892]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:01.892]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.892]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:01.892]                         fi[["size"]], fi[["mtime"]])
[08:29:01.892]                       stop(msg)
[08:29:01.892]                     }
[08:29:01.892]                     invisible(pathname)
[08:29:01.892]                   }
[08:29:01.892]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:01.892]                     rootPath = tempdir()) 
[08:29:01.892]                   {
[08:29:01.892]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:01.892]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:01.892]                       tmpdir = path, fileext = ".rds")
[08:29:01.892]                     save_rds(obj, file)
[08:29:01.892]                   }
[08:29:01.892]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:01.892]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.892]                   {
[08:29:01.892]                     inherits <- base::inherits
[08:29:01.892]                     invokeRestart <- base::invokeRestart
[08:29:01.892]                     is.null <- base::is.null
[08:29:01.892]                     muffled <- FALSE
[08:29:01.892]                     if (inherits(cond, "message")) {
[08:29:01.892]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:01.892]                       if (muffled) 
[08:29:01.892]                         invokeRestart("muffleMessage")
[08:29:01.892]                     }
[08:29:01.892]                     else if (inherits(cond, "warning")) {
[08:29:01.892]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:01.892]                       if (muffled) 
[08:29:01.892]                         invokeRestart("muffleWarning")
[08:29:01.892]                     }
[08:29:01.892]                     else if (inherits(cond, "condition")) {
[08:29:01.892]                       if (!is.null(pattern)) {
[08:29:01.892]                         computeRestarts <- base::computeRestarts
[08:29:01.892]                         grepl <- base::grepl
[08:29:01.892]                         restarts <- computeRestarts(cond)
[08:29:01.892]                         for (restart in restarts) {
[08:29:01.892]                           name <- restart$name
[08:29:01.892]                           if (is.null(name)) 
[08:29:01.892]                             next
[08:29:01.892]                           if (!grepl(pattern, name)) 
[08:29:01.892]                             next
[08:29:01.892]                           invokeRestart(restart)
[08:29:01.892]                           muffled <- TRUE
[08:29:01.892]                           break
[08:29:01.892]                         }
[08:29:01.892]                       }
[08:29:01.892]                     }
[08:29:01.892]                     invisible(muffled)
[08:29:01.892]                   }
[08:29:01.892]                   muffleCondition(cond)
[08:29:01.892]                 })
[08:29:01.892]             }))
[08:29:01.892]             future::FutureResult(value = ...future.value$value, 
[08:29:01.892]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.892]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.892]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.892]                     ...future.globalenv.names))
[08:29:01.892]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.892]         }, condition = base::local({
[08:29:01.892]             c <- base::c
[08:29:01.892]             inherits <- base::inherits
[08:29:01.892]             invokeRestart <- base::invokeRestart
[08:29:01.892]             length <- base::length
[08:29:01.892]             list <- base::list
[08:29:01.892]             seq.int <- base::seq.int
[08:29:01.892]             signalCondition <- base::signalCondition
[08:29:01.892]             sys.calls <- base::sys.calls
[08:29:01.892]             `[[` <- base::`[[`
[08:29:01.892]             `+` <- base::`+`
[08:29:01.892]             `<<-` <- base::`<<-`
[08:29:01.892]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.892]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.892]                   3L)]
[08:29:01.892]             }
[08:29:01.892]             function(cond) {
[08:29:01.892]                 is_error <- inherits(cond, "error")
[08:29:01.892]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.892]                   NULL)
[08:29:01.892]                 if (is_error) {
[08:29:01.892]                   sessionInformation <- function() {
[08:29:01.892]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.892]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.892]                       search = base::search(), system = base::Sys.info())
[08:29:01.892]                   }
[08:29:01.892]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.892]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.892]                     cond$call), session = sessionInformation(), 
[08:29:01.892]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.892]                   signalCondition(cond)
[08:29:01.892]                 }
[08:29:01.892]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.892]                 "immediateCondition"))) {
[08:29:01.892]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.892]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.892]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.892]                   if (TRUE && !signal) {
[08:29:01.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.892]                     {
[08:29:01.892]                       inherits <- base::inherits
[08:29:01.892]                       invokeRestart <- base::invokeRestart
[08:29:01.892]                       is.null <- base::is.null
[08:29:01.892]                       muffled <- FALSE
[08:29:01.892]                       if (inherits(cond, "message")) {
[08:29:01.892]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.892]                         if (muffled) 
[08:29:01.892]                           invokeRestart("muffleMessage")
[08:29:01.892]                       }
[08:29:01.892]                       else if (inherits(cond, "warning")) {
[08:29:01.892]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.892]                         if (muffled) 
[08:29:01.892]                           invokeRestart("muffleWarning")
[08:29:01.892]                       }
[08:29:01.892]                       else if (inherits(cond, "condition")) {
[08:29:01.892]                         if (!is.null(pattern)) {
[08:29:01.892]                           computeRestarts <- base::computeRestarts
[08:29:01.892]                           grepl <- base::grepl
[08:29:01.892]                           restarts <- computeRestarts(cond)
[08:29:01.892]                           for (restart in restarts) {
[08:29:01.892]                             name <- restart$name
[08:29:01.892]                             if (is.null(name)) 
[08:29:01.892]                               next
[08:29:01.892]                             if (!grepl(pattern, name)) 
[08:29:01.892]                               next
[08:29:01.892]                             invokeRestart(restart)
[08:29:01.892]                             muffled <- TRUE
[08:29:01.892]                             break
[08:29:01.892]                           }
[08:29:01.892]                         }
[08:29:01.892]                       }
[08:29:01.892]                       invisible(muffled)
[08:29:01.892]                     }
[08:29:01.892]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.892]                   }
[08:29:01.892]                 }
[08:29:01.892]                 else {
[08:29:01.892]                   if (TRUE) {
[08:29:01.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.892]                     {
[08:29:01.892]                       inherits <- base::inherits
[08:29:01.892]                       invokeRestart <- base::invokeRestart
[08:29:01.892]                       is.null <- base::is.null
[08:29:01.892]                       muffled <- FALSE
[08:29:01.892]                       if (inherits(cond, "message")) {
[08:29:01.892]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.892]                         if (muffled) 
[08:29:01.892]                           invokeRestart("muffleMessage")
[08:29:01.892]                       }
[08:29:01.892]                       else if (inherits(cond, "warning")) {
[08:29:01.892]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.892]                         if (muffled) 
[08:29:01.892]                           invokeRestart("muffleWarning")
[08:29:01.892]                       }
[08:29:01.892]                       else if (inherits(cond, "condition")) {
[08:29:01.892]                         if (!is.null(pattern)) {
[08:29:01.892]                           computeRestarts <- base::computeRestarts
[08:29:01.892]                           grepl <- base::grepl
[08:29:01.892]                           restarts <- computeRestarts(cond)
[08:29:01.892]                           for (restart in restarts) {
[08:29:01.892]                             name <- restart$name
[08:29:01.892]                             if (is.null(name)) 
[08:29:01.892]                               next
[08:29:01.892]                             if (!grepl(pattern, name)) 
[08:29:01.892]                               next
[08:29:01.892]                             invokeRestart(restart)
[08:29:01.892]                             muffled <- TRUE
[08:29:01.892]                             break
[08:29:01.892]                           }
[08:29:01.892]                         }
[08:29:01.892]                       }
[08:29:01.892]                       invisible(muffled)
[08:29:01.892]                     }
[08:29:01.892]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.892]                   }
[08:29:01.892]                 }
[08:29:01.892]             }
[08:29:01.892]         }))
[08:29:01.892]     }, error = function(ex) {
[08:29:01.892]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.892]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.892]                 ...future.rng), started = ...future.startTime, 
[08:29:01.892]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.892]             version = "1.8"), class = "FutureResult")
[08:29:01.892]     }, finally = {
[08:29:01.892]         if (!identical(...future.workdir, getwd())) 
[08:29:01.892]             setwd(...future.workdir)
[08:29:01.892]         {
[08:29:01.892]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.892]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.892]             }
[08:29:01.892]             base::options(...future.oldOptions)
[08:29:01.892]             if (.Platform$OS.type == "windows") {
[08:29:01.892]                 old_names <- names(...future.oldEnvVars)
[08:29:01.892]                 envs <- base::Sys.getenv()
[08:29:01.892]                 names <- names(envs)
[08:29:01.892]                 common <- intersect(names, old_names)
[08:29:01.892]                 added <- setdiff(names, old_names)
[08:29:01.892]                 removed <- setdiff(old_names, names)
[08:29:01.892]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.892]                   envs[common]]
[08:29:01.892]                 NAMES <- toupper(changed)
[08:29:01.892]                 args <- list()
[08:29:01.892]                 for (kk in seq_along(NAMES)) {
[08:29:01.892]                   name <- changed[[kk]]
[08:29:01.892]                   NAME <- NAMES[[kk]]
[08:29:01.892]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.892]                     next
[08:29:01.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.892]                 }
[08:29:01.892]                 NAMES <- toupper(added)
[08:29:01.892]                 for (kk in seq_along(NAMES)) {
[08:29:01.892]                   name <- added[[kk]]
[08:29:01.892]                   NAME <- NAMES[[kk]]
[08:29:01.892]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.892]                     next
[08:29:01.892]                   args[[name]] <- ""
[08:29:01.892]                 }
[08:29:01.892]                 NAMES <- toupper(removed)
[08:29:01.892]                 for (kk in seq_along(NAMES)) {
[08:29:01.892]                   name <- removed[[kk]]
[08:29:01.892]                   NAME <- NAMES[[kk]]
[08:29:01.892]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.892]                     next
[08:29:01.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.892]                 }
[08:29:01.892]                 if (length(args) > 0) 
[08:29:01.892]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.892]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.892]             }
[08:29:01.892]             else {
[08:29:01.892]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.892]             }
[08:29:01.892]             {
[08:29:01.892]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.892]                   0L) {
[08:29:01.892]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.892]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.892]                   base::options(opts)
[08:29:01.892]                 }
[08:29:01.892]                 {
[08:29:01.892]                   {
[08:29:01.892]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:01.892]                     NULL
[08:29:01.892]                   }
[08:29:01.892]                   options(future.plan = NULL)
[08:29:01.892]                   if (is.na(NA_character_)) 
[08:29:01.892]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.892]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.892]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.892]                     .init = FALSE)
[08:29:01.892]                 }
[08:29:01.892]             }
[08:29:01.892]         }
[08:29:01.892]     })
[08:29:01.892]     if (TRUE) {
[08:29:01.892]         base::sink(type = "output", split = FALSE)
[08:29:01.892]         if (TRUE) {
[08:29:01.892]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.892]         }
[08:29:01.892]         else {
[08:29:01.892]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.892]         }
[08:29:01.892]         base::close(...future.stdout)
[08:29:01.892]         ...future.stdout <- NULL
[08:29:01.892]     }
[08:29:01.892]     ...future.result$conditions <- ...future.conditions
[08:29:01.892]     ...future.result$finished <- base::Sys.time()
[08:29:01.892]     ...future.result
[08:29:01.892] }
[08:29:01.896] requestCore(): workers = 2
[08:29:01.896] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:01.907] result() for MulticoreFuture ...
[08:29:01.907] result() for MulticoreFuture ...
[08:29:01.908] result() for MulticoreFuture ... done
[08:29:01.908] result() for MulticoreFuture ... done
[08:29:01.908] result() for MulticoreFuture ...
[08:29:01.908] result() for MulticoreFuture ... done
[08:29:01.910] MulticoreFuture started
[08:29:01.911] - Launch lazy future ... done
[08:29:01.911] run() for ‘MulticoreFuture’ ... done
[08:29:01.911] getGlobalsAndPackages() ...
[08:29:01.911] plan(): Setting new future strategy stack:
[08:29:01.912] Searching for globals...
[08:29:01.912] List of future strategies:
[08:29:01.912] 1. sequential:
[08:29:01.912]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.912]    - tweaked: FALSE
[08:29:01.912]    - call: NULL
[08:29:01.913] plan(): nbrOfWorkers() = 1
[08:29:01.914] - globals found: [2] ‘{’, ‘Sys.sleep’
[08:29:01.915] Searching for globals ... DONE
[08:29:01.915] Resolving globals: FALSE
[08:29:01.916] 
[08:29:01.916] 
[08:29:01.916] plan(): Setting new future strategy stack:
[08:29:01.916] getGlobalsAndPackages() ... DONE
[08:29:01.917] run() for ‘Future’ ...
[08:29:01.916] List of future strategies:
[08:29:01.916] 1. multicore:
[08:29:01.916]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:01.916]    - tweaked: FALSE
[08:29:01.916]    - call: plan(strategy)
[08:29:01.917] - state: ‘created’
[08:29:01.917] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:01.921] plan(): nbrOfWorkers() = 2
[08:29:01.926] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:01.927] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:01.927]   - Field: ‘label’
[08:29:01.927]   - Field: ‘local’
[08:29:01.928]   - Field: ‘owner’
[08:29:01.928]   - Field: ‘envir’
[08:29:01.928]   - Field: ‘workers’
[08:29:01.929]   - Field: ‘packages’
[08:29:01.929]   - Field: ‘gc’
[08:29:01.929]   - Field: ‘job’
[08:29:01.929]   - Field: ‘conditions’
[08:29:01.929]   - Field: ‘expr’
[08:29:01.930]   - Field: ‘uuid’
[08:29:01.930]   - Field: ‘seed’
[08:29:01.930]   - Field: ‘version’
[08:29:01.930]   - Field: ‘result’
[08:29:01.930]   - Field: ‘asynchronous’
[08:29:01.930]   - Field: ‘calls’
[08:29:01.931]   - Field: ‘globals’
[08:29:01.931]   - Field: ‘stdout’
[08:29:01.931]   - Field: ‘earlySignal’
[08:29:01.931]   - Field: ‘lazy’
[08:29:01.931]   - Field: ‘state’
[08:29:01.931] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:01.932] - Launch lazy future ...
[08:29:01.932] Packages needed by the future expression (n = 0): <none>
[08:29:01.932] Packages needed by future strategies (n = 0): <none>
[08:29:01.933] {
[08:29:01.933]     {
[08:29:01.933]         {
[08:29:01.933]             ...future.startTime <- base::Sys.time()
[08:29:01.933]             {
[08:29:01.933]                 {
[08:29:01.933]                   {
[08:29:01.933]                     {
[08:29:01.933]                       base::local({
[08:29:01.933]                         has_future <- base::requireNamespace("future", 
[08:29:01.933]                           quietly = TRUE)
[08:29:01.933]                         if (has_future) {
[08:29:01.933]                           ns <- base::getNamespace("future")
[08:29:01.933]                           version <- ns[[".package"]][["version"]]
[08:29:01.933]                           if (is.null(version)) 
[08:29:01.933]                             version <- utils::packageVersion("future")
[08:29:01.933]                         }
[08:29:01.933]                         else {
[08:29:01.933]                           version <- NULL
[08:29:01.933]                         }
[08:29:01.933]                         if (!has_future || version < "1.8.0") {
[08:29:01.933]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:01.933]                             "", base::R.version$version.string), 
[08:29:01.933]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:01.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:01.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:01.933]                               "release", "version")], collapse = " "), 
[08:29:01.933]                             hostname = base::Sys.info()[["nodename"]])
[08:29:01.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:01.933]                             info)
[08:29:01.933]                           info <- base::paste(info, collapse = "; ")
[08:29:01.933]                           if (!has_future) {
[08:29:01.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:01.933]                               info)
[08:29:01.933]                           }
[08:29:01.933]                           else {
[08:29:01.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:01.933]                               info, version)
[08:29:01.933]                           }
[08:29:01.933]                           base::stop(msg)
[08:29:01.933]                         }
[08:29:01.933]                       })
[08:29:01.933]                     }
[08:29:01.933]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:01.933]                     base::options(mc.cores = 1L)
[08:29:01.933]                   }
[08:29:01.933]                   ...future.strategy.old <- future::plan("list")
[08:29:01.933]                   options(future.plan = NULL)
[08:29:01.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:01.933]                 }
[08:29:01.933]                 ...future.workdir <- getwd()
[08:29:01.933]             }
[08:29:01.933]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:01.933]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:01.933]         }
[08:29:01.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:01.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:01.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:01.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:01.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:01.933]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:01.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:01.933]             base::names(...future.oldOptions))
[08:29:01.933]     }
[08:29:01.933]     if (FALSE) {
[08:29:01.933]     }
[08:29:01.933]     else {
[08:29:01.933]         if (TRUE) {
[08:29:01.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:01.933]                 open = "w")
[08:29:01.933]         }
[08:29:01.933]         else {
[08:29:01.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:01.933]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:01.933]         }
[08:29:01.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:01.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:01.933]             base::sink(type = "output", split = FALSE)
[08:29:01.933]             base::close(...future.stdout)
[08:29:01.933]         }, add = TRUE)
[08:29:01.933]     }
[08:29:01.933]     ...future.frame <- base::sys.nframe()
[08:29:01.933]     ...future.conditions <- base::list()
[08:29:01.933]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:01.933]     if (FALSE) {
[08:29:01.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:01.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:01.933]     }
[08:29:01.933]     ...future.result <- base::tryCatch({
[08:29:01.933]         base::withCallingHandlers({
[08:29:01.933]             ...future.value <- base::withVisible(base::local({
[08:29:01.933]                 withCallingHandlers({
[08:29:01.933]                   {
[08:29:01.933]                     Sys.sleep(0.5)
[08:29:01.933]                     2
[08:29:01.933]                   }
[08:29:01.933]                 }, immediateCondition = function(cond) {
[08:29:01.933]                   save_rds <- function (object, pathname, ...) 
[08:29:01.933]                   {
[08:29:01.933]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:01.933]                     if (file_test("-f", pathname_tmp)) {
[08:29:01.933]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.933]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:01.933]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.933]                         fi_tmp[["mtime"]])
[08:29:01.933]                     }
[08:29:01.933]                     tryCatch({
[08:29:01.933]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:01.933]                     }, error = function(ex) {
[08:29:01.933]                       msg <- conditionMessage(ex)
[08:29:01.933]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.933]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:01.933]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.933]                         fi_tmp[["mtime"]], msg)
[08:29:01.933]                       ex$message <- msg
[08:29:01.933]                       stop(ex)
[08:29:01.933]                     })
[08:29:01.933]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:01.933]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:01.933]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:01.933]                       fi_tmp <- file.info(pathname_tmp)
[08:29:01.933]                       fi <- file.info(pathname)
[08:29:01.933]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:01.933]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:01.933]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:01.933]                         fi[["size"]], fi[["mtime"]])
[08:29:01.933]                       stop(msg)
[08:29:01.933]                     }
[08:29:01.933]                     invisible(pathname)
[08:29:01.933]                   }
[08:29:01.933]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:01.933]                     rootPath = tempdir()) 
[08:29:01.933]                   {
[08:29:01.933]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:01.933]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:01.933]                       tmpdir = path, fileext = ".rds")
[08:29:01.933]                     save_rds(obj, file)
[08:29:01.933]                   }
[08:29:01.933]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:01.933]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.933]                   {
[08:29:01.933]                     inherits <- base::inherits
[08:29:01.933]                     invokeRestart <- base::invokeRestart
[08:29:01.933]                     is.null <- base::is.null
[08:29:01.933]                     muffled <- FALSE
[08:29:01.933]                     if (inherits(cond, "message")) {
[08:29:01.933]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:01.933]                       if (muffled) 
[08:29:01.933]                         invokeRestart("muffleMessage")
[08:29:01.933]                     }
[08:29:01.933]                     else if (inherits(cond, "warning")) {
[08:29:01.933]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:01.933]                       if (muffled) 
[08:29:01.933]                         invokeRestart("muffleWarning")
[08:29:01.933]                     }
[08:29:01.933]                     else if (inherits(cond, "condition")) {
[08:29:01.933]                       if (!is.null(pattern)) {
[08:29:01.933]                         computeRestarts <- base::computeRestarts
[08:29:01.933]                         grepl <- base::grepl
[08:29:01.933]                         restarts <- computeRestarts(cond)
[08:29:01.933]                         for (restart in restarts) {
[08:29:01.933]                           name <- restart$name
[08:29:01.933]                           if (is.null(name)) 
[08:29:01.933]                             next
[08:29:01.933]                           if (!grepl(pattern, name)) 
[08:29:01.933]                             next
[08:29:01.933]                           invokeRestart(restart)
[08:29:01.933]                           muffled <- TRUE
[08:29:01.933]                           break
[08:29:01.933]                         }
[08:29:01.933]                       }
[08:29:01.933]                     }
[08:29:01.933]                     invisible(muffled)
[08:29:01.933]                   }
[08:29:01.933]                   muffleCondition(cond)
[08:29:01.933]                 })
[08:29:01.933]             }))
[08:29:01.933]             future::FutureResult(value = ...future.value$value, 
[08:29:01.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.933]                   ...future.rng), globalenv = if (FALSE) 
[08:29:01.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:01.933]                     ...future.globalenv.names))
[08:29:01.933]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:01.933]         }, condition = base::local({
[08:29:01.933]             c <- base::c
[08:29:01.933]             inherits <- base::inherits
[08:29:01.933]             invokeRestart <- base::invokeRestart
[08:29:01.933]             length <- base::length
[08:29:01.933]             list <- base::list
[08:29:01.933]             seq.int <- base::seq.int
[08:29:01.933]             signalCondition <- base::signalCondition
[08:29:01.933]             sys.calls <- base::sys.calls
[08:29:01.933]             `[[` <- base::`[[`
[08:29:01.933]             `+` <- base::`+`
[08:29:01.933]             `<<-` <- base::`<<-`
[08:29:01.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:01.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:01.933]                   3L)]
[08:29:01.933]             }
[08:29:01.933]             function(cond) {
[08:29:01.933]                 is_error <- inherits(cond, "error")
[08:29:01.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:01.933]                   NULL)
[08:29:01.933]                 if (is_error) {
[08:29:01.933]                   sessionInformation <- function() {
[08:29:01.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:01.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:01.933]                       search = base::search(), system = base::Sys.info())
[08:29:01.933]                   }
[08:29:01.933]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:01.933]                     cond$call), session = sessionInformation(), 
[08:29:01.933]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:01.933]                   signalCondition(cond)
[08:29:01.933]                 }
[08:29:01.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:01.933]                 "immediateCondition"))) {
[08:29:01.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:01.933]                   ...future.conditions[[length(...future.conditions) + 
[08:29:01.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:01.933]                   if (TRUE && !signal) {
[08:29:01.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.933]                     {
[08:29:01.933]                       inherits <- base::inherits
[08:29:01.933]                       invokeRestart <- base::invokeRestart
[08:29:01.933]                       is.null <- base::is.null
[08:29:01.933]                       muffled <- FALSE
[08:29:01.933]                       if (inherits(cond, "message")) {
[08:29:01.933]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.933]                         if (muffled) 
[08:29:01.933]                           invokeRestart("muffleMessage")
[08:29:01.933]                       }
[08:29:01.933]                       else if (inherits(cond, "warning")) {
[08:29:01.933]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.933]                         if (muffled) 
[08:29:01.933]                           invokeRestart("muffleWarning")
[08:29:01.933]                       }
[08:29:01.933]                       else if (inherits(cond, "condition")) {
[08:29:01.933]                         if (!is.null(pattern)) {
[08:29:01.933]                           computeRestarts <- base::computeRestarts
[08:29:01.933]                           grepl <- base::grepl
[08:29:01.933]                           restarts <- computeRestarts(cond)
[08:29:01.933]                           for (restart in restarts) {
[08:29:01.933]                             name <- restart$name
[08:29:01.933]                             if (is.null(name)) 
[08:29:01.933]                               next
[08:29:01.933]                             if (!grepl(pattern, name)) 
[08:29:01.933]                               next
[08:29:01.933]                             invokeRestart(restart)
[08:29:01.933]                             muffled <- TRUE
[08:29:01.933]                             break
[08:29:01.933]                           }
[08:29:01.933]                         }
[08:29:01.933]                       }
[08:29:01.933]                       invisible(muffled)
[08:29:01.933]                     }
[08:29:01.933]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.933]                   }
[08:29:01.933]                 }
[08:29:01.933]                 else {
[08:29:01.933]                   if (TRUE) {
[08:29:01.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:01.933]                     {
[08:29:01.933]                       inherits <- base::inherits
[08:29:01.933]                       invokeRestart <- base::invokeRestart
[08:29:01.933]                       is.null <- base::is.null
[08:29:01.933]                       muffled <- FALSE
[08:29:01.933]                       if (inherits(cond, "message")) {
[08:29:01.933]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:01.933]                         if (muffled) 
[08:29:01.933]                           invokeRestart("muffleMessage")
[08:29:01.933]                       }
[08:29:01.933]                       else if (inherits(cond, "warning")) {
[08:29:01.933]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:01.933]                         if (muffled) 
[08:29:01.933]                           invokeRestart("muffleWarning")
[08:29:01.933]                       }
[08:29:01.933]                       else if (inherits(cond, "condition")) {
[08:29:01.933]                         if (!is.null(pattern)) {
[08:29:01.933]                           computeRestarts <- base::computeRestarts
[08:29:01.933]                           grepl <- base::grepl
[08:29:01.933]                           restarts <- computeRestarts(cond)
[08:29:01.933]                           for (restart in restarts) {
[08:29:01.933]                             name <- restart$name
[08:29:01.933]                             if (is.null(name)) 
[08:29:01.933]                               next
[08:29:01.933]                             if (!grepl(pattern, name)) 
[08:29:01.933]                               next
[08:29:01.933]                             invokeRestart(restart)
[08:29:01.933]                             muffled <- TRUE
[08:29:01.933]                             break
[08:29:01.933]                           }
[08:29:01.933]                         }
[08:29:01.933]                       }
[08:29:01.933]                       invisible(muffled)
[08:29:01.933]                     }
[08:29:01.933]                     muffleCondition(cond, pattern = "^muffle")
[08:29:01.933]                   }
[08:29:01.933]                 }
[08:29:01.933]             }
[08:29:01.933]         }))
[08:29:01.933]     }, error = function(ex) {
[08:29:01.933]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:01.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:01.933]                 ...future.rng), started = ...future.startTime, 
[08:29:01.933]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:01.933]             version = "1.8"), class = "FutureResult")
[08:29:01.933]     }, finally = {
[08:29:01.933]         if (!identical(...future.workdir, getwd())) 
[08:29:01.933]             setwd(...future.workdir)
[08:29:01.933]         {
[08:29:01.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:01.933]                 ...future.oldOptions$nwarnings <- NULL
[08:29:01.933]             }
[08:29:01.933]             base::options(...future.oldOptions)
[08:29:01.933]             if (.Platform$OS.type == "windows") {
[08:29:01.933]                 old_names <- names(...future.oldEnvVars)
[08:29:01.933]                 envs <- base::Sys.getenv()
[08:29:01.933]                 names <- names(envs)
[08:29:01.933]                 common <- intersect(names, old_names)
[08:29:01.933]                 added <- setdiff(names, old_names)
[08:29:01.933]                 removed <- setdiff(old_names, names)
[08:29:01.933]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:01.933]                   envs[common]]
[08:29:01.933]                 NAMES <- toupper(changed)
[08:29:01.933]                 args <- list()
[08:29:01.933]                 for (kk in seq_along(NAMES)) {
[08:29:01.933]                   name <- changed[[kk]]
[08:29:01.933]                   NAME <- NAMES[[kk]]
[08:29:01.933]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.933]                     next
[08:29:01.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.933]                 }
[08:29:01.933]                 NAMES <- toupper(added)
[08:29:01.933]                 for (kk in seq_along(NAMES)) {
[08:29:01.933]                   name <- added[[kk]]
[08:29:01.933]                   NAME <- NAMES[[kk]]
[08:29:01.933]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.933]                     next
[08:29:01.933]                   args[[name]] <- ""
[08:29:01.933]                 }
[08:29:01.933]                 NAMES <- toupper(removed)
[08:29:01.933]                 for (kk in seq_along(NAMES)) {
[08:29:01.933]                   name <- removed[[kk]]
[08:29:01.933]                   NAME <- NAMES[[kk]]
[08:29:01.933]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:01.933]                     next
[08:29:01.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:01.933]                 }
[08:29:01.933]                 if (length(args) > 0) 
[08:29:01.933]                   base::do.call(base::Sys.setenv, args = args)
[08:29:01.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:01.933]             }
[08:29:01.933]             else {
[08:29:01.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:01.933]             }
[08:29:01.933]             {
[08:29:01.933]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:01.933]                   0L) {
[08:29:01.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:01.933]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:01.933]                   base::options(opts)
[08:29:01.933]                 }
[08:29:01.933]                 {
[08:29:01.933]                   {
[08:29:01.933]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:01.933]                     NULL
[08:29:01.933]                   }
[08:29:01.933]                   options(future.plan = NULL)
[08:29:01.933]                   if (is.na(NA_character_)) 
[08:29:01.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:01.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:01.933]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:01.933]                     .init = FALSE)
[08:29:01.933]                 }
[08:29:01.933]             }
[08:29:01.933]         }
[08:29:01.933]     })
[08:29:01.933]     if (TRUE) {
[08:29:01.933]         base::sink(type = "output", split = FALSE)
[08:29:01.933]         if (TRUE) {
[08:29:01.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:01.933]         }
[08:29:01.933]         else {
[08:29:01.933]             ...future.result["stdout"] <- base::list(NULL)
[08:29:01.933]         }
[08:29:01.933]         base::close(...future.stdout)
[08:29:01.933]         ...future.stdout <- NULL
[08:29:01.933]     }
[08:29:01.933]     ...future.result$conditions <- ...future.conditions
[08:29:01.933]     ...future.result$finished <- base::Sys.time()
[08:29:01.933]     ...future.result
[08:29:01.933] }
[08:29:01.936] requestCore(): workers = 2
[08:29:01.936] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:01.947] result() for MulticoreFuture ...
[08:29:01.947] result() for MulticoreFuture ...
[08:29:01.948] result() for MulticoreFuture ... done
[08:29:01.948] result() for MulticoreFuture ... done
[08:29:01.948] result() for MulticoreFuture ...
[08:29:01.948] result() for MulticoreFuture ... done
[08:29:01.950] MulticoreFuture started
[08:29:01.951] - Launch lazy future ... done
[08:29:01.951] run() for ‘MulticoreFuture’ ... done
[08:29:01.951] plan(): Setting new future strategy stack:
[08:29:01.952] resolve() on list ...
[08:29:01.952]  recursive: 0
[08:29:01.952]  length: 1
[08:29:01.953] 
[08:29:01.952] List of future strategies:
[08:29:01.952] 1. sequential:
[08:29:01.952]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:01.952]    - tweaked: FALSE
[08:29:01.952]    - call: NULL
[08:29:01.953] plan(): nbrOfWorkers() = 1
[08:29:01.954] Future #1
[08:29:01.954]  length: 0 (resolved future 1)
[08:29:01.954] resolve() on list ... DONE
[08:29:01.955] resolve() on list ...
[08:29:01.955]  recursive: 0
[08:29:01.955]  length: 1
[08:29:01.955] 
[08:29:02.457] plan(): Setting new future strategy stack:
[08:29:02.457] List of future strategies:
[08:29:02.457] 1. multicore:
[08:29:02.457]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:02.457]    - tweaked: FALSE
[08:29:02.457]    - call: plan(strategy)
[08:29:02.460] plan(): nbrOfWorkers() = 2
[08:29:02.466] Future #1
[08:29:02.467]  length: 0 (resolved future 1)
[08:29:02.467] resolve() on list ... DONE
[08:29:02.467] resolve() on list ...
[08:29:02.468]  recursive: 0
[08:29:02.468]  length: 1
[08:29:02.468] 
[08:29:02.468]  length: 0 (resolved future 1)
[08:29:02.468] resolve() on list ... DONE
[08:29:02.469] resolve() on list ...
[08:29:02.469]  recursive: 0
[08:29:02.469]  length: 4
[08:29:02.469] 
[08:29:02.469] Future #1
[08:29:02.470]  length: 3 (resolved future 1)
[08:29:02.470] Future #2
[08:29:02.470]  length: 2 (resolved future 2)
[08:29:02.470]  length: 1 (resolved future 3)
[08:29:02.470]  length: 0 (resolved future 4)
[08:29:02.470] resolve() on list ... DONE
[08:29:02.471] resolve() on list ...
[08:29:02.471]  recursive: 0
[08:29:02.471]  length: 4
[08:29:02.471] 
[08:29:02.471] Future #1
[08:29:02.472]  length: 3 (resolved future 1)
[08:29:02.472] Future #2
[08:29:02.472]  length: 2 (resolved future 2)
[08:29:02.472]  length: 1 (resolved future 3)
[08:29:02.472]  length: 0 (resolved future 4)
[08:29:02.473] resolve() on list ... DONE
[08:29:02.473] resolve() on list ...
[08:29:02.473]  recursive: 0
[08:29:02.473]  length: 1
[08:29:02.473] 
[08:29:02.473]  length: 0 (resolved future 1)
[08:29:02.474] resolve() on list ... DONE
[08:29:02.474] getGlobalsAndPackages() ...
[08:29:02.474] Searching for globals...
[08:29:02.476] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:02.476] Searching for globals ... DONE
[08:29:02.476] Resolving globals: FALSE
[08:29:02.477] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:02.477] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:02.478] - globals: [1] ‘kk’
[08:29:02.478] 
[08:29:02.478] getGlobalsAndPackages() ... DONE
[08:29:02.478] run() for ‘Future’ ...
[08:29:02.478] - state: ‘created’
[08:29:02.479] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:02.481] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:02.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:02.481]   - Field: ‘label’
[08:29:02.482]   - Field: ‘local’
[08:29:02.482]   - Field: ‘owner’
[08:29:02.482]   - Field: ‘envir’
[08:29:02.482]   - Field: ‘workers’
[08:29:02.482]   - Field: ‘packages’
[08:29:02.482]   - Field: ‘gc’
[08:29:02.482]   - Field: ‘job’
[08:29:02.483]   - Field: ‘conditions’
[08:29:02.483]   - Field: ‘expr’
[08:29:02.483]   - Field: ‘uuid’
[08:29:02.483]   - Field: ‘seed’
[08:29:02.483]   - Field: ‘version’
[08:29:02.483]   - Field: ‘result’
[08:29:02.483]   - Field: ‘asynchronous’
[08:29:02.483]   - Field: ‘calls’
[08:29:02.484]   - Field: ‘globals’
[08:29:02.484]   - Field: ‘stdout’
[08:29:02.484]   - Field: ‘earlySignal’
[08:29:02.484]   - Field: ‘lazy’
[08:29:02.484]   - Field: ‘state’
[08:29:02.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:02.484] - Launch lazy future ...
[08:29:02.485] Packages needed by the future expression (n = 0): <none>
[08:29:02.485] Packages needed by future strategies (n = 0): <none>
[08:29:02.486] {
[08:29:02.486]     {
[08:29:02.486]         {
[08:29:02.486]             ...future.startTime <- base::Sys.time()
[08:29:02.486]             {
[08:29:02.486]                 {
[08:29:02.486]                   {
[08:29:02.486]                     {
[08:29:02.486]                       base::local({
[08:29:02.486]                         has_future <- base::requireNamespace("future", 
[08:29:02.486]                           quietly = TRUE)
[08:29:02.486]                         if (has_future) {
[08:29:02.486]                           ns <- base::getNamespace("future")
[08:29:02.486]                           version <- ns[[".package"]][["version"]]
[08:29:02.486]                           if (is.null(version)) 
[08:29:02.486]                             version <- utils::packageVersion("future")
[08:29:02.486]                         }
[08:29:02.486]                         else {
[08:29:02.486]                           version <- NULL
[08:29:02.486]                         }
[08:29:02.486]                         if (!has_future || version < "1.8.0") {
[08:29:02.486]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:02.486]                             "", base::R.version$version.string), 
[08:29:02.486]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:02.486]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:02.486]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:02.486]                               "release", "version")], collapse = " "), 
[08:29:02.486]                             hostname = base::Sys.info()[["nodename"]])
[08:29:02.486]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:02.486]                             info)
[08:29:02.486]                           info <- base::paste(info, collapse = "; ")
[08:29:02.486]                           if (!has_future) {
[08:29:02.486]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:02.486]                               info)
[08:29:02.486]                           }
[08:29:02.486]                           else {
[08:29:02.486]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:02.486]                               info, version)
[08:29:02.486]                           }
[08:29:02.486]                           base::stop(msg)
[08:29:02.486]                         }
[08:29:02.486]                       })
[08:29:02.486]                     }
[08:29:02.486]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:02.486]                     base::options(mc.cores = 1L)
[08:29:02.486]                   }
[08:29:02.486]                   ...future.strategy.old <- future::plan("list")
[08:29:02.486]                   options(future.plan = NULL)
[08:29:02.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:02.486]                 }
[08:29:02.486]                 ...future.workdir <- getwd()
[08:29:02.486]             }
[08:29:02.486]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:02.486]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:02.486]         }
[08:29:02.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:02.486]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:02.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:02.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:02.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:02.486]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:02.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:02.486]             base::names(...future.oldOptions))
[08:29:02.486]     }
[08:29:02.486]     if (FALSE) {
[08:29:02.486]     }
[08:29:02.486]     else {
[08:29:02.486]         if (TRUE) {
[08:29:02.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:02.486]                 open = "w")
[08:29:02.486]         }
[08:29:02.486]         else {
[08:29:02.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:02.486]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:02.486]         }
[08:29:02.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:02.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:02.486]             base::sink(type = "output", split = FALSE)
[08:29:02.486]             base::close(...future.stdout)
[08:29:02.486]         }, add = TRUE)
[08:29:02.486]     }
[08:29:02.486]     ...future.frame <- base::sys.nframe()
[08:29:02.486]     ...future.conditions <- base::list()
[08:29:02.486]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:02.486]     if (FALSE) {
[08:29:02.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:02.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:02.486]     }
[08:29:02.486]     ...future.result <- base::tryCatch({
[08:29:02.486]         base::withCallingHandlers({
[08:29:02.486]             ...future.value <- base::withVisible(base::local({
[08:29:02.486]                 withCallingHandlers({
[08:29:02.486]                   {
[08:29:02.486]                     Sys.sleep(0.1)
[08:29:02.486]                     kk
[08:29:02.486]                   }
[08:29:02.486]                 }, immediateCondition = function(cond) {
[08:29:02.486]                   save_rds <- function (object, pathname, ...) 
[08:29:02.486]                   {
[08:29:02.486]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:02.486]                     if (file_test("-f", pathname_tmp)) {
[08:29:02.486]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.486]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:02.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.486]                         fi_tmp[["mtime"]])
[08:29:02.486]                     }
[08:29:02.486]                     tryCatch({
[08:29:02.486]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:02.486]                     }, error = function(ex) {
[08:29:02.486]                       msg <- conditionMessage(ex)
[08:29:02.486]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.486]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:02.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.486]                         fi_tmp[["mtime"]], msg)
[08:29:02.486]                       ex$message <- msg
[08:29:02.486]                       stop(ex)
[08:29:02.486]                     })
[08:29:02.486]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:02.486]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:02.486]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:02.486]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.486]                       fi <- file.info(pathname)
[08:29:02.486]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:02.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.486]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:02.486]                         fi[["size"]], fi[["mtime"]])
[08:29:02.486]                       stop(msg)
[08:29:02.486]                     }
[08:29:02.486]                     invisible(pathname)
[08:29:02.486]                   }
[08:29:02.486]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:02.486]                     rootPath = tempdir()) 
[08:29:02.486]                   {
[08:29:02.486]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:02.486]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:02.486]                       tmpdir = path, fileext = ".rds")
[08:29:02.486]                     save_rds(obj, file)
[08:29:02.486]                   }
[08:29:02.486]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:02.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.486]                   {
[08:29:02.486]                     inherits <- base::inherits
[08:29:02.486]                     invokeRestart <- base::invokeRestart
[08:29:02.486]                     is.null <- base::is.null
[08:29:02.486]                     muffled <- FALSE
[08:29:02.486]                     if (inherits(cond, "message")) {
[08:29:02.486]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:02.486]                       if (muffled) 
[08:29:02.486]                         invokeRestart("muffleMessage")
[08:29:02.486]                     }
[08:29:02.486]                     else if (inherits(cond, "warning")) {
[08:29:02.486]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:02.486]                       if (muffled) 
[08:29:02.486]                         invokeRestart("muffleWarning")
[08:29:02.486]                     }
[08:29:02.486]                     else if (inherits(cond, "condition")) {
[08:29:02.486]                       if (!is.null(pattern)) {
[08:29:02.486]                         computeRestarts <- base::computeRestarts
[08:29:02.486]                         grepl <- base::grepl
[08:29:02.486]                         restarts <- computeRestarts(cond)
[08:29:02.486]                         for (restart in restarts) {
[08:29:02.486]                           name <- restart$name
[08:29:02.486]                           if (is.null(name)) 
[08:29:02.486]                             next
[08:29:02.486]                           if (!grepl(pattern, name)) 
[08:29:02.486]                             next
[08:29:02.486]                           invokeRestart(restart)
[08:29:02.486]                           muffled <- TRUE
[08:29:02.486]                           break
[08:29:02.486]                         }
[08:29:02.486]                       }
[08:29:02.486]                     }
[08:29:02.486]                     invisible(muffled)
[08:29:02.486]                   }
[08:29:02.486]                   muffleCondition(cond)
[08:29:02.486]                 })
[08:29:02.486]             }))
[08:29:02.486]             future::FutureResult(value = ...future.value$value, 
[08:29:02.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.486]                   ...future.rng), globalenv = if (FALSE) 
[08:29:02.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:02.486]                     ...future.globalenv.names))
[08:29:02.486]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:02.486]         }, condition = base::local({
[08:29:02.486]             c <- base::c
[08:29:02.486]             inherits <- base::inherits
[08:29:02.486]             invokeRestart <- base::invokeRestart
[08:29:02.486]             length <- base::length
[08:29:02.486]             list <- base::list
[08:29:02.486]             seq.int <- base::seq.int
[08:29:02.486]             signalCondition <- base::signalCondition
[08:29:02.486]             sys.calls <- base::sys.calls
[08:29:02.486]             `[[` <- base::`[[`
[08:29:02.486]             `+` <- base::`+`
[08:29:02.486]             `<<-` <- base::`<<-`
[08:29:02.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:02.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:02.486]                   3L)]
[08:29:02.486]             }
[08:29:02.486]             function(cond) {
[08:29:02.486]                 is_error <- inherits(cond, "error")
[08:29:02.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:02.486]                   NULL)
[08:29:02.486]                 if (is_error) {
[08:29:02.486]                   sessionInformation <- function() {
[08:29:02.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:02.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:02.486]                       search = base::search(), system = base::Sys.info())
[08:29:02.486]                   }
[08:29:02.486]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:02.486]                     cond$call), session = sessionInformation(), 
[08:29:02.486]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:02.486]                   signalCondition(cond)
[08:29:02.486]                 }
[08:29:02.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:02.486]                 "immediateCondition"))) {
[08:29:02.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:02.486]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:02.486]                   if (TRUE && !signal) {
[08:29:02.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.486]                     {
[08:29:02.486]                       inherits <- base::inherits
[08:29:02.486]                       invokeRestart <- base::invokeRestart
[08:29:02.486]                       is.null <- base::is.null
[08:29:02.486]                       muffled <- FALSE
[08:29:02.486]                       if (inherits(cond, "message")) {
[08:29:02.486]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.486]                         if (muffled) 
[08:29:02.486]                           invokeRestart("muffleMessage")
[08:29:02.486]                       }
[08:29:02.486]                       else if (inherits(cond, "warning")) {
[08:29:02.486]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.486]                         if (muffled) 
[08:29:02.486]                           invokeRestart("muffleWarning")
[08:29:02.486]                       }
[08:29:02.486]                       else if (inherits(cond, "condition")) {
[08:29:02.486]                         if (!is.null(pattern)) {
[08:29:02.486]                           computeRestarts <- base::computeRestarts
[08:29:02.486]                           grepl <- base::grepl
[08:29:02.486]                           restarts <- computeRestarts(cond)
[08:29:02.486]                           for (restart in restarts) {
[08:29:02.486]                             name <- restart$name
[08:29:02.486]                             if (is.null(name)) 
[08:29:02.486]                               next
[08:29:02.486]                             if (!grepl(pattern, name)) 
[08:29:02.486]                               next
[08:29:02.486]                             invokeRestart(restart)
[08:29:02.486]                             muffled <- TRUE
[08:29:02.486]                             break
[08:29:02.486]                           }
[08:29:02.486]                         }
[08:29:02.486]                       }
[08:29:02.486]                       invisible(muffled)
[08:29:02.486]                     }
[08:29:02.486]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.486]                   }
[08:29:02.486]                 }
[08:29:02.486]                 else {
[08:29:02.486]                   if (TRUE) {
[08:29:02.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.486]                     {
[08:29:02.486]                       inherits <- base::inherits
[08:29:02.486]                       invokeRestart <- base::invokeRestart
[08:29:02.486]                       is.null <- base::is.null
[08:29:02.486]                       muffled <- FALSE
[08:29:02.486]                       if (inherits(cond, "message")) {
[08:29:02.486]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.486]                         if (muffled) 
[08:29:02.486]                           invokeRestart("muffleMessage")
[08:29:02.486]                       }
[08:29:02.486]                       else if (inherits(cond, "warning")) {
[08:29:02.486]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.486]                         if (muffled) 
[08:29:02.486]                           invokeRestart("muffleWarning")
[08:29:02.486]                       }
[08:29:02.486]                       else if (inherits(cond, "condition")) {
[08:29:02.486]                         if (!is.null(pattern)) {
[08:29:02.486]                           computeRestarts <- base::computeRestarts
[08:29:02.486]                           grepl <- base::grepl
[08:29:02.486]                           restarts <- computeRestarts(cond)
[08:29:02.486]                           for (restart in restarts) {
[08:29:02.486]                             name <- restart$name
[08:29:02.486]                             if (is.null(name)) 
[08:29:02.486]                               next
[08:29:02.486]                             if (!grepl(pattern, name)) 
[08:29:02.486]                               next
[08:29:02.486]                             invokeRestart(restart)
[08:29:02.486]                             muffled <- TRUE
[08:29:02.486]                             break
[08:29:02.486]                           }
[08:29:02.486]                         }
[08:29:02.486]                       }
[08:29:02.486]                       invisible(muffled)
[08:29:02.486]                     }
[08:29:02.486]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.486]                   }
[08:29:02.486]                 }
[08:29:02.486]             }
[08:29:02.486]         }))
[08:29:02.486]     }, error = function(ex) {
[08:29:02.486]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:02.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.486]                 ...future.rng), started = ...future.startTime, 
[08:29:02.486]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:02.486]             version = "1.8"), class = "FutureResult")
[08:29:02.486]     }, finally = {
[08:29:02.486]         if (!identical(...future.workdir, getwd())) 
[08:29:02.486]             setwd(...future.workdir)
[08:29:02.486]         {
[08:29:02.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:02.486]                 ...future.oldOptions$nwarnings <- NULL
[08:29:02.486]             }
[08:29:02.486]             base::options(...future.oldOptions)
[08:29:02.486]             if (.Platform$OS.type == "windows") {
[08:29:02.486]                 old_names <- names(...future.oldEnvVars)
[08:29:02.486]                 envs <- base::Sys.getenv()
[08:29:02.486]                 names <- names(envs)
[08:29:02.486]                 common <- intersect(names, old_names)
[08:29:02.486]                 added <- setdiff(names, old_names)
[08:29:02.486]                 removed <- setdiff(old_names, names)
[08:29:02.486]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:02.486]                   envs[common]]
[08:29:02.486]                 NAMES <- toupper(changed)
[08:29:02.486]                 args <- list()
[08:29:02.486]                 for (kk in seq_along(NAMES)) {
[08:29:02.486]                   name <- changed[[kk]]
[08:29:02.486]                   NAME <- NAMES[[kk]]
[08:29:02.486]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.486]                     next
[08:29:02.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.486]                 }
[08:29:02.486]                 NAMES <- toupper(added)
[08:29:02.486]                 for (kk in seq_along(NAMES)) {
[08:29:02.486]                   name <- added[[kk]]
[08:29:02.486]                   NAME <- NAMES[[kk]]
[08:29:02.486]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.486]                     next
[08:29:02.486]                   args[[name]] <- ""
[08:29:02.486]                 }
[08:29:02.486]                 NAMES <- toupper(removed)
[08:29:02.486]                 for (kk in seq_along(NAMES)) {
[08:29:02.486]                   name <- removed[[kk]]
[08:29:02.486]                   NAME <- NAMES[[kk]]
[08:29:02.486]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.486]                     next
[08:29:02.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.486]                 }
[08:29:02.486]                 if (length(args) > 0) 
[08:29:02.486]                   base::do.call(base::Sys.setenv, args = args)
[08:29:02.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:02.486]             }
[08:29:02.486]             else {
[08:29:02.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:02.486]             }
[08:29:02.486]             {
[08:29:02.486]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:02.486]                   0L) {
[08:29:02.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:02.486]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:02.486]                   base::options(opts)
[08:29:02.486]                 }
[08:29:02.486]                 {
[08:29:02.486]                   {
[08:29:02.486]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:02.486]                     NULL
[08:29:02.486]                   }
[08:29:02.486]                   options(future.plan = NULL)
[08:29:02.486]                   if (is.na(NA_character_)) 
[08:29:02.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:02.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:02.486]                     .init = FALSE)
[08:29:02.486]                 }
[08:29:02.486]             }
[08:29:02.486]         }
[08:29:02.486]     })
[08:29:02.486]     if (TRUE) {
[08:29:02.486]         base::sink(type = "output", split = FALSE)
[08:29:02.486]         if (TRUE) {
[08:29:02.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:02.486]         }
[08:29:02.486]         else {
[08:29:02.486]             ...future.result["stdout"] <- base::list(NULL)
[08:29:02.486]         }
[08:29:02.486]         base::close(...future.stdout)
[08:29:02.486]         ...future.stdout <- NULL
[08:29:02.486]     }
[08:29:02.486]     ...future.result$conditions <- ...future.conditions
[08:29:02.486]     ...future.result$finished <- base::Sys.time()
[08:29:02.486]     ...future.result
[08:29:02.486] }
[08:29:02.489] assign_globals() ...
[08:29:02.489] List of 1
[08:29:02.489]  $ kk: int 1
[08:29:02.489]  - attr(*, "where")=List of 1
[08:29:02.489]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:02.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:02.489]  - attr(*, "resolved")= logi FALSE
[08:29:02.489]  - attr(*, "total_size")= num 35
[08:29:02.489]  - attr(*, "already-done")= logi TRUE
[08:29:02.493] - copied ‘kk’ to environment
[08:29:02.496] assign_globals() ... done
[08:29:02.496] requestCore(): workers = 2
[08:29:02.497] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:02.508] result() for MulticoreFuture ...
[08:29:02.509] result() for MulticoreFuture ...
[08:29:02.509] result() for MulticoreFuture ... done
[08:29:02.509] result() for MulticoreFuture ... done
[08:29:02.510] result() for MulticoreFuture ...
[08:29:02.510] result() for MulticoreFuture ... done
[08:29:02.513] MulticoreFuture started
[08:29:02.514] - Launch lazy future ... done
[08:29:02.514] run() for ‘MulticoreFuture’ ... done
[08:29:02.514] plan(): Setting new future strategy stack:
[08:29:02.515] getGlobalsAndPackages() ...
[08:29:02.515] Searching for globals...
[08:29:02.515] List of future strategies:
[08:29:02.515] 1. sequential:
[08:29:02.515]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:02.515]    - tweaked: FALSE
[08:29:02.515]    - call: NULL
[08:29:02.516] plan(): nbrOfWorkers() = 1
[08:29:02.518] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:02.518] Searching for globals ... DONE
[08:29:02.518] Resolving globals: FALSE
[08:29:02.519] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:02.520] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:02.520] - globals: [1] ‘kk’
[08:29:02.521] 
[08:29:02.521] getGlobalsAndPackages() ... DONE
[08:29:02.521] run() for ‘Future’ ...
[08:29:02.521] - state: ‘created’
[08:29:02.522] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:02.525] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:02.525] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:02.525]   - Field: ‘label’
[08:29:02.525]   - Field: ‘local’
[08:29:02.525]   - Field: ‘owner’
[08:29:02.526]   - Field: ‘envir’
[08:29:02.526]   - Field: ‘workers’
[08:29:02.526]   - Field: ‘packages’
[08:29:02.526]   - Field: ‘gc’
[08:29:02.526]   - Field: ‘job’
[08:29:02.526]   - Field: ‘conditions’
[08:29:02.526]   - Field: ‘expr’
[08:29:02.527]   - Field: ‘uuid’
[08:29:02.527]   - Field: ‘seed’
[08:29:02.527]   - Field: ‘version’
[08:29:02.527]   - Field: ‘result’
[08:29:02.527]   - Field: ‘asynchronous’
[08:29:02.527]   - Field: ‘calls’
[08:29:02.527]   - Field: ‘globals’
[08:29:02.528]   - Field: ‘stdout’
[08:29:02.528]   - Field: ‘earlySignal’
[08:29:02.528]   - Field: ‘lazy’
[08:29:02.528]   - Field: ‘state’
[08:29:02.528] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:02.528] - Launch lazy future ...
[08:29:02.529] Packages needed by the future expression (n = 0): <none>
[08:29:02.529] Packages needed by future strategies (n = 0): <none>
[08:29:02.530] {
[08:29:02.530]     {
[08:29:02.530]         {
[08:29:02.530]             ...future.startTime <- base::Sys.time()
[08:29:02.530]             {
[08:29:02.530]                 {
[08:29:02.530]                   {
[08:29:02.530]                     {
[08:29:02.530]                       base::local({
[08:29:02.530]                         has_future <- base::requireNamespace("future", 
[08:29:02.530]                           quietly = TRUE)
[08:29:02.530]                         if (has_future) {
[08:29:02.530]                           ns <- base::getNamespace("future")
[08:29:02.530]                           version <- ns[[".package"]][["version"]]
[08:29:02.530]                           if (is.null(version)) 
[08:29:02.530]                             version <- utils::packageVersion("future")
[08:29:02.530]                         }
[08:29:02.530]                         else {
[08:29:02.530]                           version <- NULL
[08:29:02.530]                         }
[08:29:02.530]                         if (!has_future || version < "1.8.0") {
[08:29:02.530]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:02.530]                             "", base::R.version$version.string), 
[08:29:02.530]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:02.530]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:02.530]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:02.530]                               "release", "version")], collapse = " "), 
[08:29:02.530]                             hostname = base::Sys.info()[["nodename"]])
[08:29:02.530]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:02.530]                             info)
[08:29:02.530]                           info <- base::paste(info, collapse = "; ")
[08:29:02.530]                           if (!has_future) {
[08:29:02.530]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:02.530]                               info)
[08:29:02.530]                           }
[08:29:02.530]                           else {
[08:29:02.530]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:02.530]                               info, version)
[08:29:02.530]                           }
[08:29:02.530]                           base::stop(msg)
[08:29:02.530]                         }
[08:29:02.530]                       })
[08:29:02.530]                     }
[08:29:02.530]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:02.530]                     base::options(mc.cores = 1L)
[08:29:02.530]                   }
[08:29:02.530]                   ...future.strategy.old <- future::plan("list")
[08:29:02.530]                   options(future.plan = NULL)
[08:29:02.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:02.530]                 }
[08:29:02.530]                 ...future.workdir <- getwd()
[08:29:02.530]             }
[08:29:02.530]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:02.530]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:02.530]         }
[08:29:02.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:02.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:02.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:02.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:02.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:02.530]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:02.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:02.530]             base::names(...future.oldOptions))
[08:29:02.530]     }
[08:29:02.530]     if (FALSE) {
[08:29:02.530]     }
[08:29:02.530]     else {
[08:29:02.530]         if (TRUE) {
[08:29:02.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:02.530]                 open = "w")
[08:29:02.530]         }
[08:29:02.530]         else {
[08:29:02.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:02.530]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:02.530]         }
[08:29:02.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:02.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:02.530]             base::sink(type = "output", split = FALSE)
[08:29:02.530]             base::close(...future.stdout)
[08:29:02.530]         }, add = TRUE)
[08:29:02.530]     }
[08:29:02.530]     ...future.frame <- base::sys.nframe()
[08:29:02.530]     ...future.conditions <- base::list()
[08:29:02.530]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:02.530]     if (FALSE) {
[08:29:02.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:02.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:02.530]     }
[08:29:02.530]     ...future.result <- base::tryCatch({
[08:29:02.530]         base::withCallingHandlers({
[08:29:02.530]             ...future.value <- base::withVisible(base::local({
[08:29:02.530]                 withCallingHandlers({
[08:29:02.530]                   {
[08:29:02.530]                     Sys.sleep(0.1)
[08:29:02.530]                     kk
[08:29:02.530]                   }
[08:29:02.530]                 }, immediateCondition = function(cond) {
[08:29:02.530]                   save_rds <- function (object, pathname, ...) 
[08:29:02.530]                   {
[08:29:02.530]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:02.530]                     if (file_test("-f", pathname_tmp)) {
[08:29:02.530]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.530]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:02.530]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.530]                         fi_tmp[["mtime"]])
[08:29:02.530]                     }
[08:29:02.530]                     tryCatch({
[08:29:02.530]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:02.530]                     }, error = function(ex) {
[08:29:02.530]                       msg <- conditionMessage(ex)
[08:29:02.530]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.530]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:02.530]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.530]                         fi_tmp[["mtime"]], msg)
[08:29:02.530]                       ex$message <- msg
[08:29:02.530]                       stop(ex)
[08:29:02.530]                     })
[08:29:02.530]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:02.530]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:02.530]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:02.530]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.530]                       fi <- file.info(pathname)
[08:29:02.530]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:02.530]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.530]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:02.530]                         fi[["size"]], fi[["mtime"]])
[08:29:02.530]                       stop(msg)
[08:29:02.530]                     }
[08:29:02.530]                     invisible(pathname)
[08:29:02.530]                   }
[08:29:02.530]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:02.530]                     rootPath = tempdir()) 
[08:29:02.530]                   {
[08:29:02.530]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:02.530]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:02.530]                       tmpdir = path, fileext = ".rds")
[08:29:02.530]                     save_rds(obj, file)
[08:29:02.530]                   }
[08:29:02.530]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:02.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.530]                   {
[08:29:02.530]                     inherits <- base::inherits
[08:29:02.530]                     invokeRestart <- base::invokeRestart
[08:29:02.530]                     is.null <- base::is.null
[08:29:02.530]                     muffled <- FALSE
[08:29:02.530]                     if (inherits(cond, "message")) {
[08:29:02.530]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:02.530]                       if (muffled) 
[08:29:02.530]                         invokeRestart("muffleMessage")
[08:29:02.530]                     }
[08:29:02.530]                     else if (inherits(cond, "warning")) {
[08:29:02.530]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:02.530]                       if (muffled) 
[08:29:02.530]                         invokeRestart("muffleWarning")
[08:29:02.530]                     }
[08:29:02.530]                     else if (inherits(cond, "condition")) {
[08:29:02.530]                       if (!is.null(pattern)) {
[08:29:02.530]                         computeRestarts <- base::computeRestarts
[08:29:02.530]                         grepl <- base::grepl
[08:29:02.530]                         restarts <- computeRestarts(cond)
[08:29:02.530]                         for (restart in restarts) {
[08:29:02.530]                           name <- restart$name
[08:29:02.530]                           if (is.null(name)) 
[08:29:02.530]                             next
[08:29:02.530]                           if (!grepl(pattern, name)) 
[08:29:02.530]                             next
[08:29:02.530]                           invokeRestart(restart)
[08:29:02.530]                           muffled <- TRUE
[08:29:02.530]                           break
[08:29:02.530]                         }
[08:29:02.530]                       }
[08:29:02.530]                     }
[08:29:02.530]                     invisible(muffled)
[08:29:02.530]                   }
[08:29:02.530]                   muffleCondition(cond)
[08:29:02.530]                 })
[08:29:02.530]             }))
[08:29:02.530]             future::FutureResult(value = ...future.value$value, 
[08:29:02.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.530]                   ...future.rng), globalenv = if (FALSE) 
[08:29:02.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:02.530]                     ...future.globalenv.names))
[08:29:02.530]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:02.530]         }, condition = base::local({
[08:29:02.530]             c <- base::c
[08:29:02.530]             inherits <- base::inherits
[08:29:02.530]             invokeRestart <- base::invokeRestart
[08:29:02.530]             length <- base::length
[08:29:02.530]             list <- base::list
[08:29:02.530]             seq.int <- base::seq.int
[08:29:02.530]             signalCondition <- base::signalCondition
[08:29:02.530]             sys.calls <- base::sys.calls
[08:29:02.530]             `[[` <- base::`[[`
[08:29:02.530]             `+` <- base::`+`
[08:29:02.530]             `<<-` <- base::`<<-`
[08:29:02.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:02.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:02.530]                   3L)]
[08:29:02.530]             }
[08:29:02.530]             function(cond) {
[08:29:02.530]                 is_error <- inherits(cond, "error")
[08:29:02.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:02.530]                   NULL)
[08:29:02.530]                 if (is_error) {
[08:29:02.530]                   sessionInformation <- function() {
[08:29:02.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:02.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:02.530]                       search = base::search(), system = base::Sys.info())
[08:29:02.530]                   }
[08:29:02.530]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:02.530]                     cond$call), session = sessionInformation(), 
[08:29:02.530]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:02.530]                   signalCondition(cond)
[08:29:02.530]                 }
[08:29:02.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:02.530]                 "immediateCondition"))) {
[08:29:02.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:02.530]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:02.530]                   if (TRUE && !signal) {
[08:29:02.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.530]                     {
[08:29:02.530]                       inherits <- base::inherits
[08:29:02.530]                       invokeRestart <- base::invokeRestart
[08:29:02.530]                       is.null <- base::is.null
[08:29:02.530]                       muffled <- FALSE
[08:29:02.530]                       if (inherits(cond, "message")) {
[08:29:02.530]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.530]                         if (muffled) 
[08:29:02.530]                           invokeRestart("muffleMessage")
[08:29:02.530]                       }
[08:29:02.530]                       else if (inherits(cond, "warning")) {
[08:29:02.530]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.530]                         if (muffled) 
[08:29:02.530]                           invokeRestart("muffleWarning")
[08:29:02.530]                       }
[08:29:02.530]                       else if (inherits(cond, "condition")) {
[08:29:02.530]                         if (!is.null(pattern)) {
[08:29:02.530]                           computeRestarts <- base::computeRestarts
[08:29:02.530]                           grepl <- base::grepl
[08:29:02.530]                           restarts <- computeRestarts(cond)
[08:29:02.530]                           for (restart in restarts) {
[08:29:02.530]                             name <- restart$name
[08:29:02.530]                             if (is.null(name)) 
[08:29:02.530]                               next
[08:29:02.530]                             if (!grepl(pattern, name)) 
[08:29:02.530]                               next
[08:29:02.530]                             invokeRestart(restart)
[08:29:02.530]                             muffled <- TRUE
[08:29:02.530]                             break
[08:29:02.530]                           }
[08:29:02.530]                         }
[08:29:02.530]                       }
[08:29:02.530]                       invisible(muffled)
[08:29:02.530]                     }
[08:29:02.530]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.530]                   }
[08:29:02.530]                 }
[08:29:02.530]                 else {
[08:29:02.530]                   if (TRUE) {
[08:29:02.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.530]                     {
[08:29:02.530]                       inherits <- base::inherits
[08:29:02.530]                       invokeRestart <- base::invokeRestart
[08:29:02.530]                       is.null <- base::is.null
[08:29:02.530]                       muffled <- FALSE
[08:29:02.530]                       if (inherits(cond, "message")) {
[08:29:02.530]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.530]                         if (muffled) 
[08:29:02.530]                           invokeRestart("muffleMessage")
[08:29:02.530]                       }
[08:29:02.530]                       else if (inherits(cond, "warning")) {
[08:29:02.530]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.530]                         if (muffled) 
[08:29:02.530]                           invokeRestart("muffleWarning")
[08:29:02.530]                       }
[08:29:02.530]                       else if (inherits(cond, "condition")) {
[08:29:02.530]                         if (!is.null(pattern)) {
[08:29:02.530]                           computeRestarts <- base::computeRestarts
[08:29:02.530]                           grepl <- base::grepl
[08:29:02.530]                           restarts <- computeRestarts(cond)
[08:29:02.530]                           for (restart in restarts) {
[08:29:02.530]                             name <- restart$name
[08:29:02.530]                             if (is.null(name)) 
[08:29:02.530]                               next
[08:29:02.530]                             if (!grepl(pattern, name)) 
[08:29:02.530]                               next
[08:29:02.530]                             invokeRestart(restart)
[08:29:02.530]                             muffled <- TRUE
[08:29:02.530]                             break
[08:29:02.530]                           }
[08:29:02.530]                         }
[08:29:02.530]                       }
[08:29:02.530]                       invisible(muffled)
[08:29:02.530]                     }
[08:29:02.530]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.530]                   }
[08:29:02.530]                 }
[08:29:02.530]             }
[08:29:02.530]         }))
[08:29:02.530]     }, error = function(ex) {
[08:29:02.530]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:02.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.530]                 ...future.rng), started = ...future.startTime, 
[08:29:02.530]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:02.530]             version = "1.8"), class = "FutureResult")
[08:29:02.530]     }, finally = {
[08:29:02.530]         if (!identical(...future.workdir, getwd())) 
[08:29:02.530]             setwd(...future.workdir)
[08:29:02.530]         {
[08:29:02.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:02.530]                 ...future.oldOptions$nwarnings <- NULL
[08:29:02.530]             }
[08:29:02.530]             base::options(...future.oldOptions)
[08:29:02.530]             if (.Platform$OS.type == "windows") {
[08:29:02.530]                 old_names <- names(...future.oldEnvVars)
[08:29:02.530]                 envs <- base::Sys.getenv()
[08:29:02.530]                 names <- names(envs)
[08:29:02.530]                 common <- intersect(names, old_names)
[08:29:02.530]                 added <- setdiff(names, old_names)
[08:29:02.530]                 removed <- setdiff(old_names, names)
[08:29:02.530]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:02.530]                   envs[common]]
[08:29:02.530]                 NAMES <- toupper(changed)
[08:29:02.530]                 args <- list()
[08:29:02.530]                 for (kk in seq_along(NAMES)) {
[08:29:02.530]                   name <- changed[[kk]]
[08:29:02.530]                   NAME <- NAMES[[kk]]
[08:29:02.530]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.530]                     next
[08:29:02.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.530]                 }
[08:29:02.530]                 NAMES <- toupper(added)
[08:29:02.530]                 for (kk in seq_along(NAMES)) {
[08:29:02.530]                   name <- added[[kk]]
[08:29:02.530]                   NAME <- NAMES[[kk]]
[08:29:02.530]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.530]                     next
[08:29:02.530]                   args[[name]] <- ""
[08:29:02.530]                 }
[08:29:02.530]                 NAMES <- toupper(removed)
[08:29:02.530]                 for (kk in seq_along(NAMES)) {
[08:29:02.530]                   name <- removed[[kk]]
[08:29:02.530]                   NAME <- NAMES[[kk]]
[08:29:02.530]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.530]                     next
[08:29:02.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.530]                 }
[08:29:02.530]                 if (length(args) > 0) 
[08:29:02.530]                   base::do.call(base::Sys.setenv, args = args)
[08:29:02.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:02.530]             }
[08:29:02.530]             else {
[08:29:02.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:02.530]             }
[08:29:02.530]             {
[08:29:02.530]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:02.530]                   0L) {
[08:29:02.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:02.530]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:02.530]                   base::options(opts)
[08:29:02.530]                 }
[08:29:02.530]                 {
[08:29:02.530]                   {
[08:29:02.530]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:02.530]                     NULL
[08:29:02.530]                   }
[08:29:02.530]                   options(future.plan = NULL)
[08:29:02.530]                   if (is.na(NA_character_)) 
[08:29:02.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:02.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:02.530]                     .init = FALSE)
[08:29:02.530]                 }
[08:29:02.530]             }
[08:29:02.530]         }
[08:29:02.530]     })
[08:29:02.530]     if (TRUE) {
[08:29:02.530]         base::sink(type = "output", split = FALSE)
[08:29:02.530]         if (TRUE) {
[08:29:02.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:02.530]         }
[08:29:02.530]         else {
[08:29:02.530]             ...future.result["stdout"] <- base::list(NULL)
[08:29:02.530]         }
[08:29:02.530]         base::close(...future.stdout)
[08:29:02.530]         ...future.stdout <- NULL
[08:29:02.530]     }
[08:29:02.530]     ...future.result$conditions <- ...future.conditions
[08:29:02.530]     ...future.result$finished <- base::Sys.time()
[08:29:02.530]     ...future.result
[08:29:02.530] }
[08:29:02.533] assign_globals() ...
[08:29:02.533] List of 1
[08:29:02.533]  $ kk: int 2
[08:29:02.533]  - attr(*, "where")=List of 1
[08:29:02.533]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:02.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:02.533]  - attr(*, "resolved")= logi FALSE
[08:29:02.533]  - attr(*, "total_size")= num 35
[08:29:02.533]  - attr(*, "already-done")= logi TRUE
[08:29:02.537] - copied ‘kk’ to environment
[08:29:02.537] assign_globals() ... done
[08:29:02.537] requestCore(): workers = 2
[08:29:02.537] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:02.548] result() for MulticoreFuture ...
[08:29:02.549] result() for MulticoreFuture ...
[08:29:02.549] result() for MulticoreFuture ... done
[08:29:02.549] result() for MulticoreFuture ... done
[08:29:02.550] result() for MulticoreFuture ...
[08:29:02.550] result() for MulticoreFuture ... done
[08:29:02.552] MulticoreFuture started
[08:29:02.553] - Launch lazy future ... done
[08:29:02.553] run() for ‘MulticoreFuture’ ... done
[08:29:02.554] getGlobalsAndPackages() ...
[08:29:02.554] plan(): Setting new future strategy stack:
[08:29:02.554] Searching for globals...
[08:29:02.554] List of future strategies:
[08:29:02.554] 1. sequential:
[08:29:02.554]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:02.554]    - tweaked: FALSE
[08:29:02.554]    - call: NULL
[08:29:02.555] plan(): nbrOfWorkers() = 1
[08:29:02.556] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:02.556] Searching for globals ... DONE
[08:29:02.556] Resolving globals: FALSE
[08:29:02.557] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:02.558] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:02.558] - globals: [1] ‘kk’
[08:29:02.558] 
[08:29:02.558] getGlobalsAndPackages() ... DONE
[08:29:02.559] run() for ‘Future’ ...
[08:29:02.559] - state: ‘created’
[08:29:02.559] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:02.562] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:02.562] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:02.563]   - Field: ‘label’
[08:29:02.563]   - Field: ‘local’
[08:29:02.563]   - Field: ‘owner’
[08:29:02.563]   - Field: ‘envir’
[08:29:02.563]   - Field: ‘workers’
[08:29:02.563]   - Field: ‘packages’
[08:29:02.563]   - Field: ‘gc’
[08:29:02.564]   - Field: ‘job’
[08:29:02.564]   - Field: ‘conditions’
[08:29:02.564]   - Field: ‘expr’
[08:29:02.564]   - Field: ‘uuid’
[08:29:02.564]   - Field: ‘seed’
[08:29:02.564]   - Field: ‘version’
[08:29:02.564]   - Field: ‘result’
[08:29:02.565]   - Field: ‘asynchronous’
[08:29:02.565]   - Field: ‘calls’
[08:29:02.565]   - Field: ‘globals’
[08:29:02.565]   - Field: ‘stdout’
[08:29:02.565]   - Field: ‘earlySignal’
[08:29:02.565]   - Field: ‘lazy’
[08:29:02.565]   - Field: ‘state’
[08:29:02.566] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:02.566] - Launch lazy future ...
[08:29:02.566] Packages needed by the future expression (n = 0): <none>
[08:29:02.566] Packages needed by future strategies (n = 0): <none>
[08:29:02.567] {
[08:29:02.567]     {
[08:29:02.567]         {
[08:29:02.567]             ...future.startTime <- base::Sys.time()
[08:29:02.567]             {
[08:29:02.567]                 {
[08:29:02.567]                   {
[08:29:02.567]                     {
[08:29:02.567]                       base::local({
[08:29:02.567]                         has_future <- base::requireNamespace("future", 
[08:29:02.567]                           quietly = TRUE)
[08:29:02.567]                         if (has_future) {
[08:29:02.567]                           ns <- base::getNamespace("future")
[08:29:02.567]                           version <- ns[[".package"]][["version"]]
[08:29:02.567]                           if (is.null(version)) 
[08:29:02.567]                             version <- utils::packageVersion("future")
[08:29:02.567]                         }
[08:29:02.567]                         else {
[08:29:02.567]                           version <- NULL
[08:29:02.567]                         }
[08:29:02.567]                         if (!has_future || version < "1.8.0") {
[08:29:02.567]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:02.567]                             "", base::R.version$version.string), 
[08:29:02.567]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:02.567]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:02.567]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:02.567]                               "release", "version")], collapse = " "), 
[08:29:02.567]                             hostname = base::Sys.info()[["nodename"]])
[08:29:02.567]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:02.567]                             info)
[08:29:02.567]                           info <- base::paste(info, collapse = "; ")
[08:29:02.567]                           if (!has_future) {
[08:29:02.567]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:02.567]                               info)
[08:29:02.567]                           }
[08:29:02.567]                           else {
[08:29:02.567]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:02.567]                               info, version)
[08:29:02.567]                           }
[08:29:02.567]                           base::stop(msg)
[08:29:02.567]                         }
[08:29:02.567]                       })
[08:29:02.567]                     }
[08:29:02.567]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:02.567]                     base::options(mc.cores = 1L)
[08:29:02.567]                   }
[08:29:02.567]                   ...future.strategy.old <- future::plan("list")
[08:29:02.567]                   options(future.plan = NULL)
[08:29:02.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:02.567]                 }
[08:29:02.567]                 ...future.workdir <- getwd()
[08:29:02.567]             }
[08:29:02.567]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:02.567]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:02.567]         }
[08:29:02.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:02.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:02.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:02.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:02.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:02.567]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:02.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:02.567]             base::names(...future.oldOptions))
[08:29:02.567]     }
[08:29:02.567]     if (FALSE) {
[08:29:02.567]     }
[08:29:02.567]     else {
[08:29:02.567]         if (TRUE) {
[08:29:02.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:02.567]                 open = "w")
[08:29:02.567]         }
[08:29:02.567]         else {
[08:29:02.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:02.567]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:02.567]         }
[08:29:02.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:02.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:02.567]             base::sink(type = "output", split = FALSE)
[08:29:02.567]             base::close(...future.stdout)
[08:29:02.567]         }, add = TRUE)
[08:29:02.567]     }
[08:29:02.567]     ...future.frame <- base::sys.nframe()
[08:29:02.567]     ...future.conditions <- base::list()
[08:29:02.567]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:02.567]     if (FALSE) {
[08:29:02.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:02.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:02.567]     }
[08:29:02.567]     ...future.result <- base::tryCatch({
[08:29:02.567]         base::withCallingHandlers({
[08:29:02.567]             ...future.value <- base::withVisible(base::local({
[08:29:02.567]                 withCallingHandlers({
[08:29:02.567]                   {
[08:29:02.567]                     Sys.sleep(0.1)
[08:29:02.567]                     kk
[08:29:02.567]                   }
[08:29:02.567]                 }, immediateCondition = function(cond) {
[08:29:02.567]                   save_rds <- function (object, pathname, ...) 
[08:29:02.567]                   {
[08:29:02.567]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:02.567]                     if (file_test("-f", pathname_tmp)) {
[08:29:02.567]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.567]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:02.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.567]                         fi_tmp[["mtime"]])
[08:29:02.567]                     }
[08:29:02.567]                     tryCatch({
[08:29:02.567]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:02.567]                     }, error = function(ex) {
[08:29:02.567]                       msg <- conditionMessage(ex)
[08:29:02.567]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.567]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:02.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.567]                         fi_tmp[["mtime"]], msg)
[08:29:02.567]                       ex$message <- msg
[08:29:02.567]                       stop(ex)
[08:29:02.567]                     })
[08:29:02.567]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:02.567]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:02.567]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:02.567]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.567]                       fi <- file.info(pathname)
[08:29:02.567]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:02.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.567]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:02.567]                         fi[["size"]], fi[["mtime"]])
[08:29:02.567]                       stop(msg)
[08:29:02.567]                     }
[08:29:02.567]                     invisible(pathname)
[08:29:02.567]                   }
[08:29:02.567]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:02.567]                     rootPath = tempdir()) 
[08:29:02.567]                   {
[08:29:02.567]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:02.567]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:02.567]                       tmpdir = path, fileext = ".rds")
[08:29:02.567]                     save_rds(obj, file)
[08:29:02.567]                   }
[08:29:02.567]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:02.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.567]                   {
[08:29:02.567]                     inherits <- base::inherits
[08:29:02.567]                     invokeRestart <- base::invokeRestart
[08:29:02.567]                     is.null <- base::is.null
[08:29:02.567]                     muffled <- FALSE
[08:29:02.567]                     if (inherits(cond, "message")) {
[08:29:02.567]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:02.567]                       if (muffled) 
[08:29:02.567]                         invokeRestart("muffleMessage")
[08:29:02.567]                     }
[08:29:02.567]                     else if (inherits(cond, "warning")) {
[08:29:02.567]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:02.567]                       if (muffled) 
[08:29:02.567]                         invokeRestart("muffleWarning")
[08:29:02.567]                     }
[08:29:02.567]                     else if (inherits(cond, "condition")) {
[08:29:02.567]                       if (!is.null(pattern)) {
[08:29:02.567]                         computeRestarts <- base::computeRestarts
[08:29:02.567]                         grepl <- base::grepl
[08:29:02.567]                         restarts <- computeRestarts(cond)
[08:29:02.567]                         for (restart in restarts) {
[08:29:02.567]                           name <- restart$name
[08:29:02.567]                           if (is.null(name)) 
[08:29:02.567]                             next
[08:29:02.567]                           if (!grepl(pattern, name)) 
[08:29:02.567]                             next
[08:29:02.567]                           invokeRestart(restart)
[08:29:02.567]                           muffled <- TRUE
[08:29:02.567]                           break
[08:29:02.567]                         }
[08:29:02.567]                       }
[08:29:02.567]                     }
[08:29:02.567]                     invisible(muffled)
[08:29:02.567]                   }
[08:29:02.567]                   muffleCondition(cond)
[08:29:02.567]                 })
[08:29:02.567]             }))
[08:29:02.567]             future::FutureResult(value = ...future.value$value, 
[08:29:02.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.567]                   ...future.rng), globalenv = if (FALSE) 
[08:29:02.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:02.567]                     ...future.globalenv.names))
[08:29:02.567]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:02.567]         }, condition = base::local({
[08:29:02.567]             c <- base::c
[08:29:02.567]             inherits <- base::inherits
[08:29:02.567]             invokeRestart <- base::invokeRestart
[08:29:02.567]             length <- base::length
[08:29:02.567]             list <- base::list
[08:29:02.567]             seq.int <- base::seq.int
[08:29:02.567]             signalCondition <- base::signalCondition
[08:29:02.567]             sys.calls <- base::sys.calls
[08:29:02.567]             `[[` <- base::`[[`
[08:29:02.567]             `+` <- base::`+`
[08:29:02.567]             `<<-` <- base::`<<-`
[08:29:02.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:02.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:02.567]                   3L)]
[08:29:02.567]             }
[08:29:02.567]             function(cond) {
[08:29:02.567]                 is_error <- inherits(cond, "error")
[08:29:02.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:02.567]                   NULL)
[08:29:02.567]                 if (is_error) {
[08:29:02.567]                   sessionInformation <- function() {
[08:29:02.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:02.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:02.567]                       search = base::search(), system = base::Sys.info())
[08:29:02.567]                   }
[08:29:02.567]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:02.567]                     cond$call), session = sessionInformation(), 
[08:29:02.567]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:02.567]                   signalCondition(cond)
[08:29:02.567]                 }
[08:29:02.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:02.567]                 "immediateCondition"))) {
[08:29:02.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:02.567]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:02.567]                   if (TRUE && !signal) {
[08:29:02.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.567]                     {
[08:29:02.567]                       inherits <- base::inherits
[08:29:02.567]                       invokeRestart <- base::invokeRestart
[08:29:02.567]                       is.null <- base::is.null
[08:29:02.567]                       muffled <- FALSE
[08:29:02.567]                       if (inherits(cond, "message")) {
[08:29:02.567]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.567]                         if (muffled) 
[08:29:02.567]                           invokeRestart("muffleMessage")
[08:29:02.567]                       }
[08:29:02.567]                       else if (inherits(cond, "warning")) {
[08:29:02.567]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.567]                         if (muffled) 
[08:29:02.567]                           invokeRestart("muffleWarning")
[08:29:02.567]                       }
[08:29:02.567]                       else if (inherits(cond, "condition")) {
[08:29:02.567]                         if (!is.null(pattern)) {
[08:29:02.567]                           computeRestarts <- base::computeRestarts
[08:29:02.567]                           grepl <- base::grepl
[08:29:02.567]                           restarts <- computeRestarts(cond)
[08:29:02.567]                           for (restart in restarts) {
[08:29:02.567]                             name <- restart$name
[08:29:02.567]                             if (is.null(name)) 
[08:29:02.567]                               next
[08:29:02.567]                             if (!grepl(pattern, name)) 
[08:29:02.567]                               next
[08:29:02.567]                             invokeRestart(restart)
[08:29:02.567]                             muffled <- TRUE
[08:29:02.567]                             break
[08:29:02.567]                           }
[08:29:02.567]                         }
[08:29:02.567]                       }
[08:29:02.567]                       invisible(muffled)
[08:29:02.567]                     }
[08:29:02.567]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.567]                   }
[08:29:02.567]                 }
[08:29:02.567]                 else {
[08:29:02.567]                   if (TRUE) {
[08:29:02.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.567]                     {
[08:29:02.567]                       inherits <- base::inherits
[08:29:02.567]                       invokeRestart <- base::invokeRestart
[08:29:02.567]                       is.null <- base::is.null
[08:29:02.567]                       muffled <- FALSE
[08:29:02.567]                       if (inherits(cond, "message")) {
[08:29:02.567]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.567]                         if (muffled) 
[08:29:02.567]                           invokeRestart("muffleMessage")
[08:29:02.567]                       }
[08:29:02.567]                       else if (inherits(cond, "warning")) {
[08:29:02.567]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.567]                         if (muffled) 
[08:29:02.567]                           invokeRestart("muffleWarning")
[08:29:02.567]                       }
[08:29:02.567]                       else if (inherits(cond, "condition")) {
[08:29:02.567]                         if (!is.null(pattern)) {
[08:29:02.567]                           computeRestarts <- base::computeRestarts
[08:29:02.567]                           grepl <- base::grepl
[08:29:02.567]                           restarts <- computeRestarts(cond)
[08:29:02.567]                           for (restart in restarts) {
[08:29:02.567]                             name <- restart$name
[08:29:02.567]                             if (is.null(name)) 
[08:29:02.567]                               next
[08:29:02.567]                             if (!grepl(pattern, name)) 
[08:29:02.567]                               next
[08:29:02.567]                             invokeRestart(restart)
[08:29:02.567]                             muffled <- TRUE
[08:29:02.567]                             break
[08:29:02.567]                           }
[08:29:02.567]                         }
[08:29:02.567]                       }
[08:29:02.567]                       invisible(muffled)
[08:29:02.567]                     }
[08:29:02.567]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.567]                   }
[08:29:02.567]                 }
[08:29:02.567]             }
[08:29:02.567]         }))
[08:29:02.567]     }, error = function(ex) {
[08:29:02.567]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:02.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.567]                 ...future.rng), started = ...future.startTime, 
[08:29:02.567]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:02.567]             version = "1.8"), class = "FutureResult")
[08:29:02.567]     }, finally = {
[08:29:02.567]         if (!identical(...future.workdir, getwd())) 
[08:29:02.567]             setwd(...future.workdir)
[08:29:02.567]         {
[08:29:02.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:02.567]                 ...future.oldOptions$nwarnings <- NULL
[08:29:02.567]             }
[08:29:02.567]             base::options(...future.oldOptions)
[08:29:02.567]             if (.Platform$OS.type == "windows") {
[08:29:02.567]                 old_names <- names(...future.oldEnvVars)
[08:29:02.567]                 envs <- base::Sys.getenv()
[08:29:02.567]                 names <- names(envs)
[08:29:02.567]                 common <- intersect(names, old_names)
[08:29:02.567]                 added <- setdiff(names, old_names)
[08:29:02.567]                 removed <- setdiff(old_names, names)
[08:29:02.567]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:02.567]                   envs[common]]
[08:29:02.567]                 NAMES <- toupper(changed)
[08:29:02.567]                 args <- list()
[08:29:02.567]                 for (kk in seq_along(NAMES)) {
[08:29:02.567]                   name <- changed[[kk]]
[08:29:02.567]                   NAME <- NAMES[[kk]]
[08:29:02.567]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.567]                     next
[08:29:02.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.567]                 }
[08:29:02.567]                 NAMES <- toupper(added)
[08:29:02.567]                 for (kk in seq_along(NAMES)) {
[08:29:02.567]                   name <- added[[kk]]
[08:29:02.567]                   NAME <- NAMES[[kk]]
[08:29:02.567]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.567]                     next
[08:29:02.567]                   args[[name]] <- ""
[08:29:02.567]                 }
[08:29:02.567]                 NAMES <- toupper(removed)
[08:29:02.567]                 for (kk in seq_along(NAMES)) {
[08:29:02.567]                   name <- removed[[kk]]
[08:29:02.567]                   NAME <- NAMES[[kk]]
[08:29:02.567]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.567]                     next
[08:29:02.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.567]                 }
[08:29:02.567]                 if (length(args) > 0) 
[08:29:02.567]                   base::do.call(base::Sys.setenv, args = args)
[08:29:02.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:02.567]             }
[08:29:02.567]             else {
[08:29:02.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:02.567]             }
[08:29:02.567]             {
[08:29:02.567]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:02.567]                   0L) {
[08:29:02.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:02.567]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:02.567]                   base::options(opts)
[08:29:02.567]                 }
[08:29:02.567]                 {
[08:29:02.567]                   {
[08:29:02.567]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:02.567]                     NULL
[08:29:02.567]                   }
[08:29:02.567]                   options(future.plan = NULL)
[08:29:02.567]                   if (is.na(NA_character_)) 
[08:29:02.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:02.567]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:02.567]                     .init = FALSE)
[08:29:02.567]                 }
[08:29:02.567]             }
[08:29:02.567]         }
[08:29:02.567]     })
[08:29:02.567]     if (TRUE) {
[08:29:02.567]         base::sink(type = "output", split = FALSE)
[08:29:02.567]         if (TRUE) {
[08:29:02.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:02.567]         }
[08:29:02.567]         else {
[08:29:02.567]             ...future.result["stdout"] <- base::list(NULL)
[08:29:02.567]         }
[08:29:02.567]         base::close(...future.stdout)
[08:29:02.567]         ...future.stdout <- NULL
[08:29:02.567]     }
[08:29:02.567]     ...future.result$conditions <- ...future.conditions
[08:29:02.567]     ...future.result$finished <- base::Sys.time()
[08:29:02.567]     ...future.result
[08:29:02.567] }
[08:29:02.570] assign_globals() ...
[08:29:02.571] List of 1
[08:29:02.571]  $ kk: int 3
[08:29:02.571]  - attr(*, "where")=List of 1
[08:29:02.571]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:02.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:02.571]  - attr(*, "resolved")= logi FALSE
[08:29:02.571]  - attr(*, "total_size")= num 35
[08:29:02.571]  - attr(*, "already-done")= logi TRUE
[08:29:02.578] - copied ‘kk’ to environment
[08:29:02.578] assign_globals() ... done
[08:29:02.579] requestCore(): workers = 2
[08:29:02.579] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:02.611] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[08:29:02.619] plan(): Setting new future strategy stack:
[08:29:02.619] List of future strategies:
[08:29:02.619] 1. multicore:
[08:29:02.619]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:02.619]    - tweaked: FALSE
[08:29:02.619]    - call: plan(strategy)
[08:29:02.622] plan(): nbrOfWorkers() = 2
[08:29:02.622] result() for MulticoreFuture ...
[08:29:02.623] result() for MulticoreFuture ...
[08:29:02.623] result() for MulticoreFuture ... done
[08:29:02.623] result() for MulticoreFuture ... done
[08:29:02.624] result() for MulticoreFuture ...
[08:29:02.624] result() for MulticoreFuture ... done
[08:29:02.626] MulticoreFuture started
[08:29:02.627] - Launch lazy future ... done
[08:29:02.627] run() for ‘MulticoreFuture’ ... done
[08:29:02.628] plan(): Setting new future strategy stack:
[08:29:02.628] resolve() on list ...
[08:29:02.628]  recursive: 0
[08:29:02.628]  length: 3
[08:29:02.629] 
[08:29:02.629] Future #1
[08:29:02.628] List of future strategies:
[08:29:02.628] 1. sequential:
[08:29:02.628]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:02.628]    - tweaked: FALSE
[08:29:02.628]    - call: NULL
[08:29:02.629]  length: 2 (resolved future 1)
[08:29:02.630] plan(): nbrOfWorkers() = 1
[08:29:02.657] plan(): Setting new future strategy stack:
[08:29:02.657] List of future strategies:
[08:29:02.657] 1. multicore:
[08:29:02.657]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:02.657]    - tweaked: FALSE
[08:29:02.657]    - call: plan(strategy)
[08:29:02.660] plan(): nbrOfWorkers() = 2
[08:29:02.661] Future #2
[08:29:02.661]  length: 1 (resolved future 2)
[08:29:02.733] plan(): Setting new future strategy stack:
[08:29:02.733] List of future strategies:
[08:29:02.733] 1. multicore:
[08:29:02.733]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:02.733]    - tweaked: FALSE
[08:29:02.733]    - call: plan(strategy)
[08:29:02.736] plan(): nbrOfWorkers() = 2
[08:29:02.743] Future #3
[08:29:02.743]  length: 0 (resolved future 3)
[08:29:02.743] resolve() on list ... DONE
[08:29:02.744] getGlobalsAndPackages() ...
[08:29:02.744] Searching for globals...
[08:29:02.746] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:02.746] Searching for globals ... DONE
[08:29:02.746] Resolving globals: FALSE
[08:29:02.747] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:02.748] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:02.748] - globals: [1] ‘kk’
[08:29:02.748] 
[08:29:02.748] getGlobalsAndPackages() ... DONE
[08:29:02.749] getGlobalsAndPackages() ...
[08:29:02.749] Searching for globals...
[08:29:02.750] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:02.750] Searching for globals ... DONE
[08:29:02.751] Resolving globals: FALSE
[08:29:02.751] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:02.752] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:02.752] - globals: [1] ‘kk’
[08:29:02.752] 
[08:29:02.752] getGlobalsAndPackages() ... DONE
[08:29:02.752] getGlobalsAndPackages() ...
[08:29:02.753] Searching for globals...
[08:29:02.754] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:02.754] Searching for globals ... DONE
[08:29:02.754] Resolving globals: FALSE
[08:29:02.755] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:02.755] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:02.755] - globals: [1] ‘kk’
[08:29:02.756] 
[08:29:02.756] getGlobalsAndPackages() ... DONE
[08:29:02.756] resolve() on list ...
[08:29:02.756]  recursive: 0
[08:29:02.756]  length: 3
[08:29:02.757] 
[08:29:02.757] run() for ‘Future’ ...
[08:29:02.757] - state: ‘created’
[08:29:02.757] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:02.759] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:02.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:02.760]   - Field: ‘label’
[08:29:02.760]   - Field: ‘local’
[08:29:02.760]   - Field: ‘owner’
[08:29:02.760]   - Field: ‘envir’
[08:29:02.761]   - Field: ‘workers’
[08:29:02.761]   - Field: ‘packages’
[08:29:02.761]   - Field: ‘gc’
[08:29:02.761]   - Field: ‘job’
[08:29:02.761]   - Field: ‘conditions’
[08:29:02.761]   - Field: ‘expr’
[08:29:02.761]   - Field: ‘uuid’
[08:29:02.761]   - Field: ‘seed’
[08:29:02.762]   - Field: ‘version’
[08:29:02.762]   - Field: ‘result’
[08:29:02.762]   - Field: ‘asynchronous’
[08:29:02.762]   - Field: ‘calls’
[08:29:02.762]   - Field: ‘globals’
[08:29:02.762]   - Field: ‘stdout’
[08:29:02.762]   - Field: ‘earlySignal’
[08:29:02.762]   - Field: ‘lazy’
[08:29:02.763]   - Field: ‘state’
[08:29:02.763] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:02.763] - Launch lazy future ...
[08:29:02.763] Packages needed by the future expression (n = 0): <none>
[08:29:02.763] Packages needed by future strategies (n = 0): <none>
[08:29:02.764] {
[08:29:02.764]     {
[08:29:02.764]         {
[08:29:02.764]             ...future.startTime <- base::Sys.time()
[08:29:02.764]             {
[08:29:02.764]                 {
[08:29:02.764]                   {
[08:29:02.764]                     {
[08:29:02.764]                       base::local({
[08:29:02.764]                         has_future <- base::requireNamespace("future", 
[08:29:02.764]                           quietly = TRUE)
[08:29:02.764]                         if (has_future) {
[08:29:02.764]                           ns <- base::getNamespace("future")
[08:29:02.764]                           version <- ns[[".package"]][["version"]]
[08:29:02.764]                           if (is.null(version)) 
[08:29:02.764]                             version <- utils::packageVersion("future")
[08:29:02.764]                         }
[08:29:02.764]                         else {
[08:29:02.764]                           version <- NULL
[08:29:02.764]                         }
[08:29:02.764]                         if (!has_future || version < "1.8.0") {
[08:29:02.764]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:02.764]                             "", base::R.version$version.string), 
[08:29:02.764]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:02.764]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:02.764]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:02.764]                               "release", "version")], collapse = " "), 
[08:29:02.764]                             hostname = base::Sys.info()[["nodename"]])
[08:29:02.764]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:02.764]                             info)
[08:29:02.764]                           info <- base::paste(info, collapse = "; ")
[08:29:02.764]                           if (!has_future) {
[08:29:02.764]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:02.764]                               info)
[08:29:02.764]                           }
[08:29:02.764]                           else {
[08:29:02.764]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:02.764]                               info, version)
[08:29:02.764]                           }
[08:29:02.764]                           base::stop(msg)
[08:29:02.764]                         }
[08:29:02.764]                       })
[08:29:02.764]                     }
[08:29:02.764]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:02.764]                     base::options(mc.cores = 1L)
[08:29:02.764]                   }
[08:29:02.764]                   ...future.strategy.old <- future::plan("list")
[08:29:02.764]                   options(future.plan = NULL)
[08:29:02.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:02.764]                 }
[08:29:02.764]                 ...future.workdir <- getwd()
[08:29:02.764]             }
[08:29:02.764]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:02.764]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:02.764]         }
[08:29:02.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:02.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:02.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:02.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:02.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:02.764]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:02.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:02.764]             base::names(...future.oldOptions))
[08:29:02.764]     }
[08:29:02.764]     if (FALSE) {
[08:29:02.764]     }
[08:29:02.764]     else {
[08:29:02.764]         if (TRUE) {
[08:29:02.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:02.764]                 open = "w")
[08:29:02.764]         }
[08:29:02.764]         else {
[08:29:02.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:02.764]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:02.764]         }
[08:29:02.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:02.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:02.764]             base::sink(type = "output", split = FALSE)
[08:29:02.764]             base::close(...future.stdout)
[08:29:02.764]         }, add = TRUE)
[08:29:02.764]     }
[08:29:02.764]     ...future.frame <- base::sys.nframe()
[08:29:02.764]     ...future.conditions <- base::list()
[08:29:02.764]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:02.764]     if (FALSE) {
[08:29:02.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:02.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:02.764]     }
[08:29:02.764]     ...future.result <- base::tryCatch({
[08:29:02.764]         base::withCallingHandlers({
[08:29:02.764]             ...future.value <- base::withVisible(base::local({
[08:29:02.764]                 withCallingHandlers({
[08:29:02.764]                   {
[08:29:02.764]                     Sys.sleep(0.1)
[08:29:02.764]                     kk
[08:29:02.764]                   }
[08:29:02.764]                 }, immediateCondition = function(cond) {
[08:29:02.764]                   save_rds <- function (object, pathname, ...) 
[08:29:02.764]                   {
[08:29:02.764]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:02.764]                     if (file_test("-f", pathname_tmp)) {
[08:29:02.764]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.764]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:02.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.764]                         fi_tmp[["mtime"]])
[08:29:02.764]                     }
[08:29:02.764]                     tryCatch({
[08:29:02.764]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:02.764]                     }, error = function(ex) {
[08:29:02.764]                       msg <- conditionMessage(ex)
[08:29:02.764]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.764]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:02.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.764]                         fi_tmp[["mtime"]], msg)
[08:29:02.764]                       ex$message <- msg
[08:29:02.764]                       stop(ex)
[08:29:02.764]                     })
[08:29:02.764]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:02.764]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:02.764]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:02.764]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.764]                       fi <- file.info(pathname)
[08:29:02.764]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:02.764]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.764]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:02.764]                         fi[["size"]], fi[["mtime"]])
[08:29:02.764]                       stop(msg)
[08:29:02.764]                     }
[08:29:02.764]                     invisible(pathname)
[08:29:02.764]                   }
[08:29:02.764]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:02.764]                     rootPath = tempdir()) 
[08:29:02.764]                   {
[08:29:02.764]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:02.764]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:02.764]                       tmpdir = path, fileext = ".rds")
[08:29:02.764]                     save_rds(obj, file)
[08:29:02.764]                   }
[08:29:02.764]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:02.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.764]                   {
[08:29:02.764]                     inherits <- base::inherits
[08:29:02.764]                     invokeRestart <- base::invokeRestart
[08:29:02.764]                     is.null <- base::is.null
[08:29:02.764]                     muffled <- FALSE
[08:29:02.764]                     if (inherits(cond, "message")) {
[08:29:02.764]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:02.764]                       if (muffled) 
[08:29:02.764]                         invokeRestart("muffleMessage")
[08:29:02.764]                     }
[08:29:02.764]                     else if (inherits(cond, "warning")) {
[08:29:02.764]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:02.764]                       if (muffled) 
[08:29:02.764]                         invokeRestart("muffleWarning")
[08:29:02.764]                     }
[08:29:02.764]                     else if (inherits(cond, "condition")) {
[08:29:02.764]                       if (!is.null(pattern)) {
[08:29:02.764]                         computeRestarts <- base::computeRestarts
[08:29:02.764]                         grepl <- base::grepl
[08:29:02.764]                         restarts <- computeRestarts(cond)
[08:29:02.764]                         for (restart in restarts) {
[08:29:02.764]                           name <- restart$name
[08:29:02.764]                           if (is.null(name)) 
[08:29:02.764]                             next
[08:29:02.764]                           if (!grepl(pattern, name)) 
[08:29:02.764]                             next
[08:29:02.764]                           invokeRestart(restart)
[08:29:02.764]                           muffled <- TRUE
[08:29:02.764]                           break
[08:29:02.764]                         }
[08:29:02.764]                       }
[08:29:02.764]                     }
[08:29:02.764]                     invisible(muffled)
[08:29:02.764]                   }
[08:29:02.764]                   muffleCondition(cond)
[08:29:02.764]                 })
[08:29:02.764]             }))
[08:29:02.764]             future::FutureResult(value = ...future.value$value, 
[08:29:02.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.764]                   ...future.rng), globalenv = if (FALSE) 
[08:29:02.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:02.764]                     ...future.globalenv.names))
[08:29:02.764]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:02.764]         }, condition = base::local({
[08:29:02.764]             c <- base::c
[08:29:02.764]             inherits <- base::inherits
[08:29:02.764]             invokeRestart <- base::invokeRestart
[08:29:02.764]             length <- base::length
[08:29:02.764]             list <- base::list
[08:29:02.764]             seq.int <- base::seq.int
[08:29:02.764]             signalCondition <- base::signalCondition
[08:29:02.764]             sys.calls <- base::sys.calls
[08:29:02.764]             `[[` <- base::`[[`
[08:29:02.764]             `+` <- base::`+`
[08:29:02.764]             `<<-` <- base::`<<-`
[08:29:02.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:02.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:02.764]                   3L)]
[08:29:02.764]             }
[08:29:02.764]             function(cond) {
[08:29:02.764]                 is_error <- inherits(cond, "error")
[08:29:02.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:02.764]                   NULL)
[08:29:02.764]                 if (is_error) {
[08:29:02.764]                   sessionInformation <- function() {
[08:29:02.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:02.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:02.764]                       search = base::search(), system = base::Sys.info())
[08:29:02.764]                   }
[08:29:02.764]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:02.764]                     cond$call), session = sessionInformation(), 
[08:29:02.764]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:02.764]                   signalCondition(cond)
[08:29:02.764]                 }
[08:29:02.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:02.764]                 "immediateCondition"))) {
[08:29:02.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:02.764]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:02.764]                   if (TRUE && !signal) {
[08:29:02.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.764]                     {
[08:29:02.764]                       inherits <- base::inherits
[08:29:02.764]                       invokeRestart <- base::invokeRestart
[08:29:02.764]                       is.null <- base::is.null
[08:29:02.764]                       muffled <- FALSE
[08:29:02.764]                       if (inherits(cond, "message")) {
[08:29:02.764]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.764]                         if (muffled) 
[08:29:02.764]                           invokeRestart("muffleMessage")
[08:29:02.764]                       }
[08:29:02.764]                       else if (inherits(cond, "warning")) {
[08:29:02.764]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.764]                         if (muffled) 
[08:29:02.764]                           invokeRestart("muffleWarning")
[08:29:02.764]                       }
[08:29:02.764]                       else if (inherits(cond, "condition")) {
[08:29:02.764]                         if (!is.null(pattern)) {
[08:29:02.764]                           computeRestarts <- base::computeRestarts
[08:29:02.764]                           grepl <- base::grepl
[08:29:02.764]                           restarts <- computeRestarts(cond)
[08:29:02.764]                           for (restart in restarts) {
[08:29:02.764]                             name <- restart$name
[08:29:02.764]                             if (is.null(name)) 
[08:29:02.764]                               next
[08:29:02.764]                             if (!grepl(pattern, name)) 
[08:29:02.764]                               next
[08:29:02.764]                             invokeRestart(restart)
[08:29:02.764]                             muffled <- TRUE
[08:29:02.764]                             break
[08:29:02.764]                           }
[08:29:02.764]                         }
[08:29:02.764]                       }
[08:29:02.764]                       invisible(muffled)
[08:29:02.764]                     }
[08:29:02.764]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.764]                   }
[08:29:02.764]                 }
[08:29:02.764]                 else {
[08:29:02.764]                   if (TRUE) {
[08:29:02.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.764]                     {
[08:29:02.764]                       inherits <- base::inherits
[08:29:02.764]                       invokeRestart <- base::invokeRestart
[08:29:02.764]                       is.null <- base::is.null
[08:29:02.764]                       muffled <- FALSE
[08:29:02.764]                       if (inherits(cond, "message")) {
[08:29:02.764]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.764]                         if (muffled) 
[08:29:02.764]                           invokeRestart("muffleMessage")
[08:29:02.764]                       }
[08:29:02.764]                       else if (inherits(cond, "warning")) {
[08:29:02.764]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.764]                         if (muffled) 
[08:29:02.764]                           invokeRestart("muffleWarning")
[08:29:02.764]                       }
[08:29:02.764]                       else if (inherits(cond, "condition")) {
[08:29:02.764]                         if (!is.null(pattern)) {
[08:29:02.764]                           computeRestarts <- base::computeRestarts
[08:29:02.764]                           grepl <- base::grepl
[08:29:02.764]                           restarts <- computeRestarts(cond)
[08:29:02.764]                           for (restart in restarts) {
[08:29:02.764]                             name <- restart$name
[08:29:02.764]                             if (is.null(name)) 
[08:29:02.764]                               next
[08:29:02.764]                             if (!grepl(pattern, name)) 
[08:29:02.764]                               next
[08:29:02.764]                             invokeRestart(restart)
[08:29:02.764]                             muffled <- TRUE
[08:29:02.764]                             break
[08:29:02.764]                           }
[08:29:02.764]                         }
[08:29:02.764]                       }
[08:29:02.764]                       invisible(muffled)
[08:29:02.764]                     }
[08:29:02.764]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.764]                   }
[08:29:02.764]                 }
[08:29:02.764]             }
[08:29:02.764]         }))
[08:29:02.764]     }, error = function(ex) {
[08:29:02.764]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:02.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.764]                 ...future.rng), started = ...future.startTime, 
[08:29:02.764]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:02.764]             version = "1.8"), class = "FutureResult")
[08:29:02.764]     }, finally = {
[08:29:02.764]         if (!identical(...future.workdir, getwd())) 
[08:29:02.764]             setwd(...future.workdir)
[08:29:02.764]         {
[08:29:02.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:02.764]                 ...future.oldOptions$nwarnings <- NULL
[08:29:02.764]             }
[08:29:02.764]             base::options(...future.oldOptions)
[08:29:02.764]             if (.Platform$OS.type == "windows") {
[08:29:02.764]                 old_names <- names(...future.oldEnvVars)
[08:29:02.764]                 envs <- base::Sys.getenv()
[08:29:02.764]                 names <- names(envs)
[08:29:02.764]                 common <- intersect(names, old_names)
[08:29:02.764]                 added <- setdiff(names, old_names)
[08:29:02.764]                 removed <- setdiff(old_names, names)
[08:29:02.764]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:02.764]                   envs[common]]
[08:29:02.764]                 NAMES <- toupper(changed)
[08:29:02.764]                 args <- list()
[08:29:02.764]                 for (kk in seq_along(NAMES)) {
[08:29:02.764]                   name <- changed[[kk]]
[08:29:02.764]                   NAME <- NAMES[[kk]]
[08:29:02.764]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.764]                     next
[08:29:02.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.764]                 }
[08:29:02.764]                 NAMES <- toupper(added)
[08:29:02.764]                 for (kk in seq_along(NAMES)) {
[08:29:02.764]                   name <- added[[kk]]
[08:29:02.764]                   NAME <- NAMES[[kk]]
[08:29:02.764]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.764]                     next
[08:29:02.764]                   args[[name]] <- ""
[08:29:02.764]                 }
[08:29:02.764]                 NAMES <- toupper(removed)
[08:29:02.764]                 for (kk in seq_along(NAMES)) {
[08:29:02.764]                   name <- removed[[kk]]
[08:29:02.764]                   NAME <- NAMES[[kk]]
[08:29:02.764]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.764]                     next
[08:29:02.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.764]                 }
[08:29:02.764]                 if (length(args) > 0) 
[08:29:02.764]                   base::do.call(base::Sys.setenv, args = args)
[08:29:02.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:02.764]             }
[08:29:02.764]             else {
[08:29:02.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:02.764]             }
[08:29:02.764]             {
[08:29:02.764]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:02.764]                   0L) {
[08:29:02.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:02.764]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:02.764]                   base::options(opts)
[08:29:02.764]                 }
[08:29:02.764]                 {
[08:29:02.764]                   {
[08:29:02.764]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:02.764]                     NULL
[08:29:02.764]                   }
[08:29:02.764]                   options(future.plan = NULL)
[08:29:02.764]                   if (is.na(NA_character_)) 
[08:29:02.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:02.764]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:02.764]                     .init = FALSE)
[08:29:02.764]                 }
[08:29:02.764]             }
[08:29:02.764]         }
[08:29:02.764]     })
[08:29:02.764]     if (TRUE) {
[08:29:02.764]         base::sink(type = "output", split = FALSE)
[08:29:02.764]         if (TRUE) {
[08:29:02.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:02.764]         }
[08:29:02.764]         else {
[08:29:02.764]             ...future.result["stdout"] <- base::list(NULL)
[08:29:02.764]         }
[08:29:02.764]         base::close(...future.stdout)
[08:29:02.764]         ...future.stdout <- NULL
[08:29:02.764]     }
[08:29:02.764]     ...future.result$conditions <- ...future.conditions
[08:29:02.764]     ...future.result$finished <- base::Sys.time()
[08:29:02.764]     ...future.result
[08:29:02.764] }
[08:29:02.767] assign_globals() ...
[08:29:02.767] List of 1
[08:29:02.767]  $ kk: int 1
[08:29:02.767]  - attr(*, "where")=List of 1
[08:29:02.767]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:02.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:02.767]  - attr(*, "resolved")= logi FALSE
[08:29:02.767]  - attr(*, "total_size")= num 35
[08:29:02.767]  - attr(*, "already-done")= logi TRUE
[08:29:02.771] - copied ‘kk’ to environment
[08:29:02.771] assign_globals() ... done
[08:29:02.771] requestCore(): workers = 2
[08:29:02.772] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:02.782] result() for MulticoreFuture ...
[08:29:02.783] result() for MulticoreFuture ...
[08:29:02.783] result() for MulticoreFuture ... done
[08:29:02.784] result() for MulticoreFuture ... done
[08:29:02.784] result() for MulticoreFuture ...
[08:29:02.784] result() for MulticoreFuture ... done
[08:29:02.786] MulticoreFuture started
[08:29:02.787] - Launch lazy future ... done
[08:29:02.787] run() for ‘MulticoreFuture’ ... done
[08:29:02.787] plan(): Setting new future strategy stack:
[08:29:02.788] List of future strategies:
[08:29:02.788] 1. sequential:
[08:29:02.788]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:02.788]    - tweaked: FALSE
[08:29:02.788]    - call: NULL
[08:29:02.789] plan(): nbrOfWorkers() = 1
[08:29:02.798] run() for ‘Future’ ...
[08:29:02.798] - state: ‘created’
[08:29:02.798] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:02.807] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:02.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:02.807]   - Field: ‘label’
[08:29:02.808]   - Field: ‘local’
[08:29:02.808]   - Field: ‘owner’
[08:29:02.809]   - Field: ‘envir’
[08:29:02.809]   - Field: ‘workers’
[08:29:02.809]   - Field: ‘packages’
[08:29:02.809]   - Field: ‘gc’
[08:29:02.809]   - Field: ‘job’
[08:29:02.810]   - Field: ‘conditions’
[08:29:02.810]   - Field: ‘expr’
[08:29:02.810]   - Field: ‘uuid’
[08:29:02.810]   - Field: ‘seed’
[08:29:02.810]   - Field: ‘version’
[08:29:02.811]   - Field: ‘result’
[08:29:02.811]   - Field: ‘asynchronous’
[08:29:02.811]   - Field: ‘calls’
[08:29:02.811]   - Field: ‘globals’
[08:29:02.811]   - Field: ‘stdout’
[08:29:02.811]   - Field: ‘earlySignal’
[08:29:02.812]   - Field: ‘lazy’
[08:29:02.812]   - Field: ‘state’
[08:29:02.812] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:02.812] - Launch lazy future ...
[08:29:02.813] Packages needed by the future expression (n = 0): <none>
[08:29:02.813] Packages needed by future strategies (n = 0): <none>
[08:29:02.814] {
[08:29:02.814]     {
[08:29:02.814]         {
[08:29:02.814]             ...future.startTime <- base::Sys.time()
[08:29:02.814]             {
[08:29:02.814]                 {
[08:29:02.814]                   {
[08:29:02.814]                     {
[08:29:02.814]                       base::local({
[08:29:02.814]                         has_future <- base::requireNamespace("future", 
[08:29:02.814]                           quietly = TRUE)
[08:29:02.814]                         if (has_future) {
[08:29:02.814]                           ns <- base::getNamespace("future")
[08:29:02.814]                           version <- ns[[".package"]][["version"]]
[08:29:02.814]                           if (is.null(version)) 
[08:29:02.814]                             version <- utils::packageVersion("future")
[08:29:02.814]                         }
[08:29:02.814]                         else {
[08:29:02.814]                           version <- NULL
[08:29:02.814]                         }
[08:29:02.814]                         if (!has_future || version < "1.8.0") {
[08:29:02.814]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:02.814]                             "", base::R.version$version.string), 
[08:29:02.814]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:02.814]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:02.814]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:02.814]                               "release", "version")], collapse = " "), 
[08:29:02.814]                             hostname = base::Sys.info()[["nodename"]])
[08:29:02.814]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:02.814]                             info)
[08:29:02.814]                           info <- base::paste(info, collapse = "; ")
[08:29:02.814]                           if (!has_future) {
[08:29:02.814]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:02.814]                               info)
[08:29:02.814]                           }
[08:29:02.814]                           else {
[08:29:02.814]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:02.814]                               info, version)
[08:29:02.814]                           }
[08:29:02.814]                           base::stop(msg)
[08:29:02.814]                         }
[08:29:02.814]                       })
[08:29:02.814]                     }
[08:29:02.814]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:02.814]                     base::options(mc.cores = 1L)
[08:29:02.814]                   }
[08:29:02.814]                   ...future.strategy.old <- future::plan("list")
[08:29:02.814]                   options(future.plan = NULL)
[08:29:02.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:02.814]                 }
[08:29:02.814]                 ...future.workdir <- getwd()
[08:29:02.814]             }
[08:29:02.814]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:02.814]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:02.814]         }
[08:29:02.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:02.814]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:02.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:02.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:02.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:02.814]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:02.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:02.814]             base::names(...future.oldOptions))
[08:29:02.814]     }
[08:29:02.814]     if (FALSE) {
[08:29:02.814]     }
[08:29:02.814]     else {
[08:29:02.814]         if (TRUE) {
[08:29:02.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:02.814]                 open = "w")
[08:29:02.814]         }
[08:29:02.814]         else {
[08:29:02.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:02.814]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:02.814]         }
[08:29:02.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:02.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:02.814]             base::sink(type = "output", split = FALSE)
[08:29:02.814]             base::close(...future.stdout)
[08:29:02.814]         }, add = TRUE)
[08:29:02.814]     }
[08:29:02.814]     ...future.frame <- base::sys.nframe()
[08:29:02.814]     ...future.conditions <- base::list()
[08:29:02.814]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:02.814]     if (FALSE) {
[08:29:02.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:02.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:02.814]     }
[08:29:02.814]     ...future.result <- base::tryCatch({
[08:29:02.814]         base::withCallingHandlers({
[08:29:02.814]             ...future.value <- base::withVisible(base::local({
[08:29:02.814]                 withCallingHandlers({
[08:29:02.814]                   {
[08:29:02.814]                     Sys.sleep(0.1)
[08:29:02.814]                     kk
[08:29:02.814]                   }
[08:29:02.814]                 }, immediateCondition = function(cond) {
[08:29:02.814]                   save_rds <- function (object, pathname, ...) 
[08:29:02.814]                   {
[08:29:02.814]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:02.814]                     if (file_test("-f", pathname_tmp)) {
[08:29:02.814]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.814]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:02.814]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.814]                         fi_tmp[["mtime"]])
[08:29:02.814]                     }
[08:29:02.814]                     tryCatch({
[08:29:02.814]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:02.814]                     }, error = function(ex) {
[08:29:02.814]                       msg <- conditionMessage(ex)
[08:29:02.814]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.814]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:02.814]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.814]                         fi_tmp[["mtime"]], msg)
[08:29:02.814]                       ex$message <- msg
[08:29:02.814]                       stop(ex)
[08:29:02.814]                     })
[08:29:02.814]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:02.814]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:02.814]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:02.814]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.814]                       fi <- file.info(pathname)
[08:29:02.814]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:02.814]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.814]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:02.814]                         fi[["size"]], fi[["mtime"]])
[08:29:02.814]                       stop(msg)
[08:29:02.814]                     }
[08:29:02.814]                     invisible(pathname)
[08:29:02.814]                   }
[08:29:02.814]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:02.814]                     rootPath = tempdir()) 
[08:29:02.814]                   {
[08:29:02.814]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:02.814]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:02.814]                       tmpdir = path, fileext = ".rds")
[08:29:02.814]                     save_rds(obj, file)
[08:29:02.814]                   }
[08:29:02.814]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:02.814]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.814]                   {
[08:29:02.814]                     inherits <- base::inherits
[08:29:02.814]                     invokeRestart <- base::invokeRestart
[08:29:02.814]                     is.null <- base::is.null
[08:29:02.814]                     muffled <- FALSE
[08:29:02.814]                     if (inherits(cond, "message")) {
[08:29:02.814]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:02.814]                       if (muffled) 
[08:29:02.814]                         invokeRestart("muffleMessage")
[08:29:02.814]                     }
[08:29:02.814]                     else if (inherits(cond, "warning")) {
[08:29:02.814]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:02.814]                       if (muffled) 
[08:29:02.814]                         invokeRestart("muffleWarning")
[08:29:02.814]                     }
[08:29:02.814]                     else if (inherits(cond, "condition")) {
[08:29:02.814]                       if (!is.null(pattern)) {
[08:29:02.814]                         computeRestarts <- base::computeRestarts
[08:29:02.814]                         grepl <- base::grepl
[08:29:02.814]                         restarts <- computeRestarts(cond)
[08:29:02.814]                         for (restart in restarts) {
[08:29:02.814]                           name <- restart$name
[08:29:02.814]                           if (is.null(name)) 
[08:29:02.814]                             next
[08:29:02.814]                           if (!grepl(pattern, name)) 
[08:29:02.814]                             next
[08:29:02.814]                           invokeRestart(restart)
[08:29:02.814]                           muffled <- TRUE
[08:29:02.814]                           break
[08:29:02.814]                         }
[08:29:02.814]                       }
[08:29:02.814]                     }
[08:29:02.814]                     invisible(muffled)
[08:29:02.814]                   }
[08:29:02.814]                   muffleCondition(cond)
[08:29:02.814]                 })
[08:29:02.814]             }))
[08:29:02.814]             future::FutureResult(value = ...future.value$value, 
[08:29:02.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.814]                   ...future.rng), globalenv = if (FALSE) 
[08:29:02.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:02.814]                     ...future.globalenv.names))
[08:29:02.814]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:02.814]         }, condition = base::local({
[08:29:02.814]             c <- base::c
[08:29:02.814]             inherits <- base::inherits
[08:29:02.814]             invokeRestart <- base::invokeRestart
[08:29:02.814]             length <- base::length
[08:29:02.814]             list <- base::list
[08:29:02.814]             seq.int <- base::seq.int
[08:29:02.814]             signalCondition <- base::signalCondition
[08:29:02.814]             sys.calls <- base::sys.calls
[08:29:02.814]             `[[` <- base::`[[`
[08:29:02.814]             `+` <- base::`+`
[08:29:02.814]             `<<-` <- base::`<<-`
[08:29:02.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:02.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:02.814]                   3L)]
[08:29:02.814]             }
[08:29:02.814]             function(cond) {
[08:29:02.814]                 is_error <- inherits(cond, "error")
[08:29:02.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:02.814]                   NULL)
[08:29:02.814]                 if (is_error) {
[08:29:02.814]                   sessionInformation <- function() {
[08:29:02.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:02.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:02.814]                       search = base::search(), system = base::Sys.info())
[08:29:02.814]                   }
[08:29:02.814]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:02.814]                     cond$call), session = sessionInformation(), 
[08:29:02.814]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:02.814]                   signalCondition(cond)
[08:29:02.814]                 }
[08:29:02.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:02.814]                 "immediateCondition"))) {
[08:29:02.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:02.814]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:02.814]                   if (TRUE && !signal) {
[08:29:02.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.814]                     {
[08:29:02.814]                       inherits <- base::inherits
[08:29:02.814]                       invokeRestart <- base::invokeRestart
[08:29:02.814]                       is.null <- base::is.null
[08:29:02.814]                       muffled <- FALSE
[08:29:02.814]                       if (inherits(cond, "message")) {
[08:29:02.814]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.814]                         if (muffled) 
[08:29:02.814]                           invokeRestart("muffleMessage")
[08:29:02.814]                       }
[08:29:02.814]                       else if (inherits(cond, "warning")) {
[08:29:02.814]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.814]                         if (muffled) 
[08:29:02.814]                           invokeRestart("muffleWarning")
[08:29:02.814]                       }
[08:29:02.814]                       else if (inherits(cond, "condition")) {
[08:29:02.814]                         if (!is.null(pattern)) {
[08:29:02.814]                           computeRestarts <- base::computeRestarts
[08:29:02.814]                           grepl <- base::grepl
[08:29:02.814]                           restarts <- computeRestarts(cond)
[08:29:02.814]                           for (restart in restarts) {
[08:29:02.814]                             name <- restart$name
[08:29:02.814]                             if (is.null(name)) 
[08:29:02.814]                               next
[08:29:02.814]                             if (!grepl(pattern, name)) 
[08:29:02.814]                               next
[08:29:02.814]                             invokeRestart(restart)
[08:29:02.814]                             muffled <- TRUE
[08:29:02.814]                             break
[08:29:02.814]                           }
[08:29:02.814]                         }
[08:29:02.814]                       }
[08:29:02.814]                       invisible(muffled)
[08:29:02.814]                     }
[08:29:02.814]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.814]                   }
[08:29:02.814]                 }
[08:29:02.814]                 else {
[08:29:02.814]                   if (TRUE) {
[08:29:02.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.814]                     {
[08:29:02.814]                       inherits <- base::inherits
[08:29:02.814]                       invokeRestart <- base::invokeRestart
[08:29:02.814]                       is.null <- base::is.null
[08:29:02.814]                       muffled <- FALSE
[08:29:02.814]                       if (inherits(cond, "message")) {
[08:29:02.814]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.814]                         if (muffled) 
[08:29:02.814]                           invokeRestart("muffleMessage")
[08:29:02.814]                       }
[08:29:02.814]                       else if (inherits(cond, "warning")) {
[08:29:02.814]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.814]                         if (muffled) 
[08:29:02.814]                           invokeRestart("muffleWarning")
[08:29:02.814]                       }
[08:29:02.814]                       else if (inherits(cond, "condition")) {
[08:29:02.814]                         if (!is.null(pattern)) {
[08:29:02.814]                           computeRestarts <- base::computeRestarts
[08:29:02.814]                           grepl <- base::grepl
[08:29:02.814]                           restarts <- computeRestarts(cond)
[08:29:02.814]                           for (restart in restarts) {
[08:29:02.814]                             name <- restart$name
[08:29:02.814]                             if (is.null(name)) 
[08:29:02.814]                               next
[08:29:02.814]                             if (!grepl(pattern, name)) 
[08:29:02.814]                               next
[08:29:02.814]                             invokeRestart(restart)
[08:29:02.814]                             muffled <- TRUE
[08:29:02.814]                             break
[08:29:02.814]                           }
[08:29:02.814]                         }
[08:29:02.814]                       }
[08:29:02.814]                       invisible(muffled)
[08:29:02.814]                     }
[08:29:02.814]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.814]                   }
[08:29:02.814]                 }
[08:29:02.814]             }
[08:29:02.814]         }))
[08:29:02.814]     }, error = function(ex) {
[08:29:02.814]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:02.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.814]                 ...future.rng), started = ...future.startTime, 
[08:29:02.814]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:02.814]             version = "1.8"), class = "FutureResult")
[08:29:02.814]     }, finally = {
[08:29:02.814]         if (!identical(...future.workdir, getwd())) 
[08:29:02.814]             setwd(...future.workdir)
[08:29:02.814]         {
[08:29:02.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:02.814]                 ...future.oldOptions$nwarnings <- NULL
[08:29:02.814]             }
[08:29:02.814]             base::options(...future.oldOptions)
[08:29:02.814]             if (.Platform$OS.type == "windows") {
[08:29:02.814]                 old_names <- names(...future.oldEnvVars)
[08:29:02.814]                 envs <- base::Sys.getenv()
[08:29:02.814]                 names <- names(envs)
[08:29:02.814]                 common <- intersect(names, old_names)
[08:29:02.814]                 added <- setdiff(names, old_names)
[08:29:02.814]                 removed <- setdiff(old_names, names)
[08:29:02.814]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:02.814]                   envs[common]]
[08:29:02.814]                 NAMES <- toupper(changed)
[08:29:02.814]                 args <- list()
[08:29:02.814]                 for (kk in seq_along(NAMES)) {
[08:29:02.814]                   name <- changed[[kk]]
[08:29:02.814]                   NAME <- NAMES[[kk]]
[08:29:02.814]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.814]                     next
[08:29:02.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.814]                 }
[08:29:02.814]                 NAMES <- toupper(added)
[08:29:02.814]                 for (kk in seq_along(NAMES)) {
[08:29:02.814]                   name <- added[[kk]]
[08:29:02.814]                   NAME <- NAMES[[kk]]
[08:29:02.814]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.814]                     next
[08:29:02.814]                   args[[name]] <- ""
[08:29:02.814]                 }
[08:29:02.814]                 NAMES <- toupper(removed)
[08:29:02.814]                 for (kk in seq_along(NAMES)) {
[08:29:02.814]                   name <- removed[[kk]]
[08:29:02.814]                   NAME <- NAMES[[kk]]
[08:29:02.814]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.814]                     next
[08:29:02.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.814]                 }
[08:29:02.814]                 if (length(args) > 0) 
[08:29:02.814]                   base::do.call(base::Sys.setenv, args = args)
[08:29:02.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:02.814]             }
[08:29:02.814]             else {
[08:29:02.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:02.814]             }
[08:29:02.814]             {
[08:29:02.814]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:02.814]                   0L) {
[08:29:02.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:02.814]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:02.814]                   base::options(opts)
[08:29:02.814]                 }
[08:29:02.814]                 {
[08:29:02.814]                   {
[08:29:02.814]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:02.814]                     NULL
[08:29:02.814]                   }
[08:29:02.814]                   options(future.plan = NULL)
[08:29:02.814]                   if (is.na(NA_character_)) 
[08:29:02.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:02.814]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:02.814]                     .init = FALSE)
[08:29:02.814]                 }
[08:29:02.814]             }
[08:29:02.814]         }
[08:29:02.814]     })
[08:29:02.814]     if (TRUE) {
[08:29:02.814]         base::sink(type = "output", split = FALSE)
[08:29:02.814]         if (TRUE) {
[08:29:02.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:02.814]         }
[08:29:02.814]         else {
[08:29:02.814]             ...future.result["stdout"] <- base::list(NULL)
[08:29:02.814]         }
[08:29:02.814]         base::close(...future.stdout)
[08:29:02.814]         ...future.stdout <- NULL
[08:29:02.814]     }
[08:29:02.814]     ...future.result$conditions <- ...future.conditions
[08:29:02.814]     ...future.result$finished <- base::Sys.time()
[08:29:02.814]     ...future.result
[08:29:02.814] }
[08:29:02.816] assign_globals() ...
[08:29:02.817] List of 1
[08:29:02.817]  $ kk: int 2
[08:29:02.817]  - attr(*, "where")=List of 1
[08:29:02.817]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:02.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:02.817]  - attr(*, "resolved")= logi FALSE
[08:29:02.817]  - attr(*, "total_size")= num 35
[08:29:02.817]  - attr(*, "already-done")= logi TRUE
[08:29:02.821] - copied ‘kk’ to environment
[08:29:02.821] assign_globals() ... done
[08:29:02.821] requestCore(): workers = 2
[08:29:02.821] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:02.832] result() for MulticoreFuture ...
[08:29:02.833] result() for MulticoreFuture ...
[08:29:02.833] result() for MulticoreFuture ... done
[08:29:02.833] result() for MulticoreFuture ... done
[08:29:02.833] result() for MulticoreFuture ...
[08:29:02.833] result() for MulticoreFuture ... done
[08:29:02.836] MulticoreFuture started
[08:29:02.836] - Launch lazy future ... done
[08:29:02.837] run() for ‘MulticoreFuture’ ... done
[08:29:02.837] plan(): Setting new future strategy stack:
[08:29:02.837] List of future strategies:
[08:29:02.837] 1. sequential:
[08:29:02.837]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:02.837]    - tweaked: FALSE
[08:29:02.837]    - call: NULL
[08:29:02.838] plan(): nbrOfWorkers() = 1
[08:29:02.847] run() for ‘Future’ ...
[08:29:02.848] - state: ‘created’
[08:29:02.848] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:02.851] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:02.852] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:02.852]   - Field: ‘label’
[08:29:02.852]   - Field: ‘local’
[08:29:02.852]   - Field: ‘owner’
[08:29:02.852]   - Field: ‘envir’
[08:29:02.852]   - Field: ‘workers’
[08:29:02.852]   - Field: ‘packages’
[08:29:02.853]   - Field: ‘gc’
[08:29:02.853]   - Field: ‘job’
[08:29:02.853]   - Field: ‘conditions’
[08:29:02.853]   - Field: ‘expr’
[08:29:02.853]   - Field: ‘uuid’
[08:29:02.853]   - Field: ‘seed’
[08:29:02.854]   - Field: ‘version’
[08:29:02.854]   - Field: ‘result’
[08:29:02.854]   - Field: ‘asynchronous’
[08:29:02.854]   - Field: ‘calls’
[08:29:02.854]   - Field: ‘globals’
[08:29:02.854]   - Field: ‘stdout’
[08:29:02.854]   - Field: ‘earlySignal’
[08:29:02.855]   - Field: ‘lazy’
[08:29:02.855]   - Field: ‘state’
[08:29:02.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:02.855] - Launch lazy future ...
[08:29:02.856] Packages needed by the future expression (n = 0): <none>
[08:29:02.856] Packages needed by future strategies (n = 0): <none>
[08:29:02.857] {
[08:29:02.857]     {
[08:29:02.857]         {
[08:29:02.857]             ...future.startTime <- base::Sys.time()
[08:29:02.857]             {
[08:29:02.857]                 {
[08:29:02.857]                   {
[08:29:02.857]                     {
[08:29:02.857]                       base::local({
[08:29:02.857]                         has_future <- base::requireNamespace("future", 
[08:29:02.857]                           quietly = TRUE)
[08:29:02.857]                         if (has_future) {
[08:29:02.857]                           ns <- base::getNamespace("future")
[08:29:02.857]                           version <- ns[[".package"]][["version"]]
[08:29:02.857]                           if (is.null(version)) 
[08:29:02.857]                             version <- utils::packageVersion("future")
[08:29:02.857]                         }
[08:29:02.857]                         else {
[08:29:02.857]                           version <- NULL
[08:29:02.857]                         }
[08:29:02.857]                         if (!has_future || version < "1.8.0") {
[08:29:02.857]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:02.857]                             "", base::R.version$version.string), 
[08:29:02.857]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:02.857]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:02.857]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:02.857]                               "release", "version")], collapse = " "), 
[08:29:02.857]                             hostname = base::Sys.info()[["nodename"]])
[08:29:02.857]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:02.857]                             info)
[08:29:02.857]                           info <- base::paste(info, collapse = "; ")
[08:29:02.857]                           if (!has_future) {
[08:29:02.857]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:02.857]                               info)
[08:29:02.857]                           }
[08:29:02.857]                           else {
[08:29:02.857]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:02.857]                               info, version)
[08:29:02.857]                           }
[08:29:02.857]                           base::stop(msg)
[08:29:02.857]                         }
[08:29:02.857]                       })
[08:29:02.857]                     }
[08:29:02.857]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:02.857]                     base::options(mc.cores = 1L)
[08:29:02.857]                   }
[08:29:02.857]                   ...future.strategy.old <- future::plan("list")
[08:29:02.857]                   options(future.plan = NULL)
[08:29:02.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:02.857]                 }
[08:29:02.857]                 ...future.workdir <- getwd()
[08:29:02.857]             }
[08:29:02.857]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:02.857]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:02.857]         }
[08:29:02.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:02.857]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:02.857]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:02.857]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:02.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:02.857]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:02.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:02.857]             base::names(...future.oldOptions))
[08:29:02.857]     }
[08:29:02.857]     if (FALSE) {
[08:29:02.857]     }
[08:29:02.857]     else {
[08:29:02.857]         if (TRUE) {
[08:29:02.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:02.857]                 open = "w")
[08:29:02.857]         }
[08:29:02.857]         else {
[08:29:02.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:02.857]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:02.857]         }
[08:29:02.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:02.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:02.857]             base::sink(type = "output", split = FALSE)
[08:29:02.857]             base::close(...future.stdout)
[08:29:02.857]         }, add = TRUE)
[08:29:02.857]     }
[08:29:02.857]     ...future.frame <- base::sys.nframe()
[08:29:02.857]     ...future.conditions <- base::list()
[08:29:02.857]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:02.857]     if (FALSE) {
[08:29:02.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:02.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:02.857]     }
[08:29:02.857]     ...future.result <- base::tryCatch({
[08:29:02.857]         base::withCallingHandlers({
[08:29:02.857]             ...future.value <- base::withVisible(base::local({
[08:29:02.857]                 withCallingHandlers({
[08:29:02.857]                   {
[08:29:02.857]                     Sys.sleep(0.1)
[08:29:02.857]                     kk
[08:29:02.857]                   }
[08:29:02.857]                 }, immediateCondition = function(cond) {
[08:29:02.857]                   save_rds <- function (object, pathname, ...) 
[08:29:02.857]                   {
[08:29:02.857]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:02.857]                     if (file_test("-f", pathname_tmp)) {
[08:29:02.857]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.857]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:02.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.857]                         fi_tmp[["mtime"]])
[08:29:02.857]                     }
[08:29:02.857]                     tryCatch({
[08:29:02.857]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:02.857]                     }, error = function(ex) {
[08:29:02.857]                       msg <- conditionMessage(ex)
[08:29:02.857]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.857]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:02.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.857]                         fi_tmp[["mtime"]], msg)
[08:29:02.857]                       ex$message <- msg
[08:29:02.857]                       stop(ex)
[08:29:02.857]                     })
[08:29:02.857]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:02.857]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:02.857]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:02.857]                       fi_tmp <- file.info(pathname_tmp)
[08:29:02.857]                       fi <- file.info(pathname)
[08:29:02.857]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:02.857]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:02.857]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:02.857]                         fi[["size"]], fi[["mtime"]])
[08:29:02.857]                       stop(msg)
[08:29:02.857]                     }
[08:29:02.857]                     invisible(pathname)
[08:29:02.857]                   }
[08:29:02.857]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:02.857]                     rootPath = tempdir()) 
[08:29:02.857]                   {
[08:29:02.857]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:02.857]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:02.857]                       tmpdir = path, fileext = ".rds")
[08:29:02.857]                     save_rds(obj, file)
[08:29:02.857]                   }
[08:29:02.857]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:02.857]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.857]                   {
[08:29:02.857]                     inherits <- base::inherits
[08:29:02.857]                     invokeRestart <- base::invokeRestart
[08:29:02.857]                     is.null <- base::is.null
[08:29:02.857]                     muffled <- FALSE
[08:29:02.857]                     if (inherits(cond, "message")) {
[08:29:02.857]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:02.857]                       if (muffled) 
[08:29:02.857]                         invokeRestart("muffleMessage")
[08:29:02.857]                     }
[08:29:02.857]                     else if (inherits(cond, "warning")) {
[08:29:02.857]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:02.857]                       if (muffled) 
[08:29:02.857]                         invokeRestart("muffleWarning")
[08:29:02.857]                     }
[08:29:02.857]                     else if (inherits(cond, "condition")) {
[08:29:02.857]                       if (!is.null(pattern)) {
[08:29:02.857]                         computeRestarts <- base::computeRestarts
[08:29:02.857]                         grepl <- base::grepl
[08:29:02.857]                         restarts <- computeRestarts(cond)
[08:29:02.857]                         for (restart in restarts) {
[08:29:02.857]                           name <- restart$name
[08:29:02.857]                           if (is.null(name)) 
[08:29:02.857]                             next
[08:29:02.857]                           if (!grepl(pattern, name)) 
[08:29:02.857]                             next
[08:29:02.857]                           invokeRestart(restart)
[08:29:02.857]                           muffled <- TRUE
[08:29:02.857]                           break
[08:29:02.857]                         }
[08:29:02.857]                       }
[08:29:02.857]                     }
[08:29:02.857]                     invisible(muffled)
[08:29:02.857]                   }
[08:29:02.857]                   muffleCondition(cond)
[08:29:02.857]                 })
[08:29:02.857]             }))
[08:29:02.857]             future::FutureResult(value = ...future.value$value, 
[08:29:02.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.857]                   ...future.rng), globalenv = if (FALSE) 
[08:29:02.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:02.857]                     ...future.globalenv.names))
[08:29:02.857]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:02.857]         }, condition = base::local({
[08:29:02.857]             c <- base::c
[08:29:02.857]             inherits <- base::inherits
[08:29:02.857]             invokeRestart <- base::invokeRestart
[08:29:02.857]             length <- base::length
[08:29:02.857]             list <- base::list
[08:29:02.857]             seq.int <- base::seq.int
[08:29:02.857]             signalCondition <- base::signalCondition
[08:29:02.857]             sys.calls <- base::sys.calls
[08:29:02.857]             `[[` <- base::`[[`
[08:29:02.857]             `+` <- base::`+`
[08:29:02.857]             `<<-` <- base::`<<-`
[08:29:02.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:02.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:02.857]                   3L)]
[08:29:02.857]             }
[08:29:02.857]             function(cond) {
[08:29:02.857]                 is_error <- inherits(cond, "error")
[08:29:02.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:02.857]                   NULL)
[08:29:02.857]                 if (is_error) {
[08:29:02.857]                   sessionInformation <- function() {
[08:29:02.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:02.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:02.857]                       search = base::search(), system = base::Sys.info())
[08:29:02.857]                   }
[08:29:02.857]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:02.857]                     cond$call), session = sessionInformation(), 
[08:29:02.857]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:02.857]                   signalCondition(cond)
[08:29:02.857]                 }
[08:29:02.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:02.857]                 "immediateCondition"))) {
[08:29:02.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:02.857]                   ...future.conditions[[length(...future.conditions) + 
[08:29:02.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:02.857]                   if (TRUE && !signal) {
[08:29:02.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.857]                     {
[08:29:02.857]                       inherits <- base::inherits
[08:29:02.857]                       invokeRestart <- base::invokeRestart
[08:29:02.857]                       is.null <- base::is.null
[08:29:02.857]                       muffled <- FALSE
[08:29:02.857]                       if (inherits(cond, "message")) {
[08:29:02.857]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.857]                         if (muffled) 
[08:29:02.857]                           invokeRestart("muffleMessage")
[08:29:02.857]                       }
[08:29:02.857]                       else if (inherits(cond, "warning")) {
[08:29:02.857]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.857]                         if (muffled) 
[08:29:02.857]                           invokeRestart("muffleWarning")
[08:29:02.857]                       }
[08:29:02.857]                       else if (inherits(cond, "condition")) {
[08:29:02.857]                         if (!is.null(pattern)) {
[08:29:02.857]                           computeRestarts <- base::computeRestarts
[08:29:02.857]                           grepl <- base::grepl
[08:29:02.857]                           restarts <- computeRestarts(cond)
[08:29:02.857]                           for (restart in restarts) {
[08:29:02.857]                             name <- restart$name
[08:29:02.857]                             if (is.null(name)) 
[08:29:02.857]                               next
[08:29:02.857]                             if (!grepl(pattern, name)) 
[08:29:02.857]                               next
[08:29:02.857]                             invokeRestart(restart)
[08:29:02.857]                             muffled <- TRUE
[08:29:02.857]                             break
[08:29:02.857]                           }
[08:29:02.857]                         }
[08:29:02.857]                       }
[08:29:02.857]                       invisible(muffled)
[08:29:02.857]                     }
[08:29:02.857]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.857]                   }
[08:29:02.857]                 }
[08:29:02.857]                 else {
[08:29:02.857]                   if (TRUE) {
[08:29:02.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:02.857]                     {
[08:29:02.857]                       inherits <- base::inherits
[08:29:02.857]                       invokeRestart <- base::invokeRestart
[08:29:02.857]                       is.null <- base::is.null
[08:29:02.857]                       muffled <- FALSE
[08:29:02.857]                       if (inherits(cond, "message")) {
[08:29:02.857]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:02.857]                         if (muffled) 
[08:29:02.857]                           invokeRestart("muffleMessage")
[08:29:02.857]                       }
[08:29:02.857]                       else if (inherits(cond, "warning")) {
[08:29:02.857]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:02.857]                         if (muffled) 
[08:29:02.857]                           invokeRestart("muffleWarning")
[08:29:02.857]                       }
[08:29:02.857]                       else if (inherits(cond, "condition")) {
[08:29:02.857]                         if (!is.null(pattern)) {
[08:29:02.857]                           computeRestarts <- base::computeRestarts
[08:29:02.857]                           grepl <- base::grepl
[08:29:02.857]                           restarts <- computeRestarts(cond)
[08:29:02.857]                           for (restart in restarts) {
[08:29:02.857]                             name <- restart$name
[08:29:02.857]                             if (is.null(name)) 
[08:29:02.857]                               next
[08:29:02.857]                             if (!grepl(pattern, name)) 
[08:29:02.857]                               next
[08:29:02.857]                             invokeRestart(restart)
[08:29:02.857]                             muffled <- TRUE
[08:29:02.857]                             break
[08:29:02.857]                           }
[08:29:02.857]                         }
[08:29:02.857]                       }
[08:29:02.857]                       invisible(muffled)
[08:29:02.857]                     }
[08:29:02.857]                     muffleCondition(cond, pattern = "^muffle")
[08:29:02.857]                   }
[08:29:02.857]                 }
[08:29:02.857]             }
[08:29:02.857]         }))
[08:29:02.857]     }, error = function(ex) {
[08:29:02.857]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:02.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:02.857]                 ...future.rng), started = ...future.startTime, 
[08:29:02.857]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:02.857]             version = "1.8"), class = "FutureResult")
[08:29:02.857]     }, finally = {
[08:29:02.857]         if (!identical(...future.workdir, getwd())) 
[08:29:02.857]             setwd(...future.workdir)
[08:29:02.857]         {
[08:29:02.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:02.857]                 ...future.oldOptions$nwarnings <- NULL
[08:29:02.857]             }
[08:29:02.857]             base::options(...future.oldOptions)
[08:29:02.857]             if (.Platform$OS.type == "windows") {
[08:29:02.857]                 old_names <- names(...future.oldEnvVars)
[08:29:02.857]                 envs <- base::Sys.getenv()
[08:29:02.857]                 names <- names(envs)
[08:29:02.857]                 common <- intersect(names, old_names)
[08:29:02.857]                 added <- setdiff(names, old_names)
[08:29:02.857]                 removed <- setdiff(old_names, names)
[08:29:02.857]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:02.857]                   envs[common]]
[08:29:02.857]                 NAMES <- toupper(changed)
[08:29:02.857]                 args <- list()
[08:29:02.857]                 for (kk in seq_along(NAMES)) {
[08:29:02.857]                   name <- changed[[kk]]
[08:29:02.857]                   NAME <- NAMES[[kk]]
[08:29:02.857]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.857]                     next
[08:29:02.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.857]                 }
[08:29:02.857]                 NAMES <- toupper(added)
[08:29:02.857]                 for (kk in seq_along(NAMES)) {
[08:29:02.857]                   name <- added[[kk]]
[08:29:02.857]                   NAME <- NAMES[[kk]]
[08:29:02.857]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.857]                     next
[08:29:02.857]                   args[[name]] <- ""
[08:29:02.857]                 }
[08:29:02.857]                 NAMES <- toupper(removed)
[08:29:02.857]                 for (kk in seq_along(NAMES)) {
[08:29:02.857]                   name <- removed[[kk]]
[08:29:02.857]                   NAME <- NAMES[[kk]]
[08:29:02.857]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:02.857]                     next
[08:29:02.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:02.857]                 }
[08:29:02.857]                 if (length(args) > 0) 
[08:29:02.857]                   base::do.call(base::Sys.setenv, args = args)
[08:29:02.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:02.857]             }
[08:29:02.857]             else {
[08:29:02.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:02.857]             }
[08:29:02.857]             {
[08:29:02.857]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:02.857]                   0L) {
[08:29:02.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:02.857]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:02.857]                   base::options(opts)
[08:29:02.857]                 }
[08:29:02.857]                 {
[08:29:02.857]                   {
[08:29:02.857]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:02.857]                     NULL
[08:29:02.857]                   }
[08:29:02.857]                   options(future.plan = NULL)
[08:29:02.857]                   if (is.na(NA_character_)) 
[08:29:02.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:02.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:02.857]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:02.857]                     .init = FALSE)
[08:29:02.857]                 }
[08:29:02.857]             }
[08:29:02.857]         }
[08:29:02.857]     })
[08:29:02.857]     if (TRUE) {
[08:29:02.857]         base::sink(type = "output", split = FALSE)
[08:29:02.857]         if (TRUE) {
[08:29:02.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:02.857]         }
[08:29:02.857]         else {
[08:29:02.857]             ...future.result["stdout"] <- base::list(NULL)
[08:29:02.857]         }
[08:29:02.857]         base::close(...future.stdout)
[08:29:02.857]         ...future.stdout <- NULL
[08:29:02.857]     }
[08:29:02.857]     ...future.result$conditions <- ...future.conditions
[08:29:02.857]     ...future.result$finished <- base::Sys.time()
[08:29:02.857]     ...future.result
[08:29:02.857] }
[08:29:02.860] assign_globals() ...
[08:29:02.860] List of 1
[08:29:02.860]  $ kk: int 3
[08:29:02.860]  - attr(*, "where")=List of 1
[08:29:02.860]   ..$ kk:<environment: R_EmptyEnv> 
[08:29:02.860]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:29:02.860]  - attr(*, "resolved")= logi FALSE
[08:29:02.860]  - attr(*, "total_size")= num 35
[08:29:02.860]  - attr(*, "already-done")= logi TRUE
[08:29:02.864] - copied ‘kk’ to environment
[08:29:02.864] assign_globals() ... done
[08:29:02.864] requestCore(): workers = 2
[08:29:02.865] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:02.894] plan(): Setting new future strategy stack:
[08:29:02.895] List of future strategies:
[08:29:02.895] 1. multicore:
[08:29:02.895]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:02.895]    - tweaked: FALSE
[08:29:02.895]    - call: plan(strategy)
[08:29:02.896] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[08:29:02.898] plan(): nbrOfWorkers() = 2
[08:29:02.907] result() for MulticoreFuture ...
[08:29:02.908] result() for MulticoreFuture ...
[08:29:02.908] result() for MulticoreFuture ... done
[08:29:02.909] result() for MulticoreFuture ... done
[08:29:02.909] result() for MulticoreFuture ...
[08:29:02.909] result() for MulticoreFuture ... done
[08:29:02.911] MulticoreFuture started
[08:29:02.912] - Launch lazy future ... done
[08:29:02.912] run() for ‘MulticoreFuture’ ... done
[08:29:02.913] plan(): Setting new future strategy stack:
[08:29:02.913] List of future strategies:
[08:29:02.913] 1. sequential:
[08:29:02.913]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:02.913]    - tweaked: FALSE
[08:29:02.913]    - call: NULL
[08:29:02.914] plan(): nbrOfWorkers() = 1
[08:29:02.933] Future #1
[08:29:02.933]  length: 2 (resolved future 1)
[08:29:02.941] plan(): Setting new future strategy stack:
[08:29:02.941] List of future strategies:
[08:29:02.941] 1. multicore:
[08:29:02.941]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:02.941]    - tweaked: FALSE
[08:29:02.941]    - call: plan(strategy)
[08:29:02.943] plan(): nbrOfWorkers() = 2
[08:29:02.944] Future #2
[08:29:02.944]  length: 1 (resolved future 2)
[08:29:03.016] plan(): Setting new future strategy stack:
[08:29:03.016] List of future strategies:
[08:29:03.016] 1. multicore:
[08:29:03.016]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.016]    - tweaked: FALSE
[08:29:03.016]    - call: plan(strategy)
[08:29:03.020] plan(): nbrOfWorkers() = 2
[08:29:03.026] Future #3
[08:29:03.026]  length: 0 (resolved future 3)
[08:29:03.026] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[08:29:03.027] resolve() on environment ...
[08:29:03.027]  recursive: 0
[08:29:03.028]  elements: [2] ‘a’, ‘b’
[08:29:03.028]  length: 1 (resolved future 1)
[08:29:03.029]  length: 0 (resolved future 2)
[08:29:03.029] resolve() on environment ... DONE
[08:29:03.029] getGlobalsAndPackages() ...
[08:29:03.029] Searching for globals...
[08:29:03.030] 
[08:29:03.030] Searching for globals ... DONE
[08:29:03.030] - globals: [0] <none>
[08:29:03.031] getGlobalsAndPackages() ... DONE
[08:29:03.031] run() for ‘Future’ ...
[08:29:03.031] - state: ‘created’
[08:29:03.031] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.039] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.040] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.040]   - Field: ‘label’
[08:29:03.040]   - Field: ‘local’
[08:29:03.041]   - Field: ‘owner’
[08:29:03.041]   - Field: ‘envir’
[08:29:03.041]   - Field: ‘workers’
[08:29:03.041]   - Field: ‘packages’
[08:29:03.041]   - Field: ‘gc’
[08:29:03.042]   - Field: ‘job’
[08:29:03.042]   - Field: ‘conditions’
[08:29:03.042]   - Field: ‘expr’
[08:29:03.042]   - Field: ‘uuid’
[08:29:03.042]   - Field: ‘seed’
[08:29:03.043]   - Field: ‘version’
[08:29:03.043]   - Field: ‘result’
[08:29:03.043]   - Field: ‘asynchronous’
[08:29:03.043]   - Field: ‘calls’
[08:29:03.043]   - Field: ‘globals’
[08:29:03.044]   - Field: ‘stdout’
[08:29:03.044]   - Field: ‘earlySignal’
[08:29:03.044]   - Field: ‘lazy’
[08:29:03.044]   - Field: ‘state’
[08:29:03.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.044] - Launch lazy future ...
[08:29:03.045] Packages needed by the future expression (n = 0): <none>
[08:29:03.045] Packages needed by future strategies (n = 0): <none>
[08:29:03.046] {
[08:29:03.046]     {
[08:29:03.046]         {
[08:29:03.046]             ...future.startTime <- base::Sys.time()
[08:29:03.046]             {
[08:29:03.046]                 {
[08:29:03.046]                   {
[08:29:03.046]                     {
[08:29:03.046]                       base::local({
[08:29:03.046]                         has_future <- base::requireNamespace("future", 
[08:29:03.046]                           quietly = TRUE)
[08:29:03.046]                         if (has_future) {
[08:29:03.046]                           ns <- base::getNamespace("future")
[08:29:03.046]                           version <- ns[[".package"]][["version"]]
[08:29:03.046]                           if (is.null(version)) 
[08:29:03.046]                             version <- utils::packageVersion("future")
[08:29:03.046]                         }
[08:29:03.046]                         else {
[08:29:03.046]                           version <- NULL
[08:29:03.046]                         }
[08:29:03.046]                         if (!has_future || version < "1.8.0") {
[08:29:03.046]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.046]                             "", base::R.version$version.string), 
[08:29:03.046]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.046]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.046]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.046]                               "release", "version")], collapse = " "), 
[08:29:03.046]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.046]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.046]                             info)
[08:29:03.046]                           info <- base::paste(info, collapse = "; ")
[08:29:03.046]                           if (!has_future) {
[08:29:03.046]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.046]                               info)
[08:29:03.046]                           }
[08:29:03.046]                           else {
[08:29:03.046]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.046]                               info, version)
[08:29:03.046]                           }
[08:29:03.046]                           base::stop(msg)
[08:29:03.046]                         }
[08:29:03.046]                       })
[08:29:03.046]                     }
[08:29:03.046]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.046]                     base::options(mc.cores = 1L)
[08:29:03.046]                   }
[08:29:03.046]                   ...future.strategy.old <- future::plan("list")
[08:29:03.046]                   options(future.plan = NULL)
[08:29:03.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.046]                 }
[08:29:03.046]                 ...future.workdir <- getwd()
[08:29:03.046]             }
[08:29:03.046]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.046]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.046]         }
[08:29:03.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.046]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.046]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.046]             base::names(...future.oldOptions))
[08:29:03.046]     }
[08:29:03.046]     if (FALSE) {
[08:29:03.046]     }
[08:29:03.046]     else {
[08:29:03.046]         if (TRUE) {
[08:29:03.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.046]                 open = "w")
[08:29:03.046]         }
[08:29:03.046]         else {
[08:29:03.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.046]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.046]         }
[08:29:03.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.046]             base::sink(type = "output", split = FALSE)
[08:29:03.046]             base::close(...future.stdout)
[08:29:03.046]         }, add = TRUE)
[08:29:03.046]     }
[08:29:03.046]     ...future.frame <- base::sys.nframe()
[08:29:03.046]     ...future.conditions <- base::list()
[08:29:03.046]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.046]     if (FALSE) {
[08:29:03.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.046]     }
[08:29:03.046]     ...future.result <- base::tryCatch({
[08:29:03.046]         base::withCallingHandlers({
[08:29:03.046]             ...future.value <- base::withVisible(base::local({
[08:29:03.046]                 withCallingHandlers({
[08:29:03.046]                   1
[08:29:03.046]                 }, immediateCondition = function(cond) {
[08:29:03.046]                   save_rds <- function (object, pathname, ...) 
[08:29:03.046]                   {
[08:29:03.046]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.046]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.046]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.046]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.046]                         fi_tmp[["mtime"]])
[08:29:03.046]                     }
[08:29:03.046]                     tryCatch({
[08:29:03.046]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.046]                     }, error = function(ex) {
[08:29:03.046]                       msg <- conditionMessage(ex)
[08:29:03.046]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.046]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.046]                         fi_tmp[["mtime"]], msg)
[08:29:03.046]                       ex$message <- msg
[08:29:03.046]                       stop(ex)
[08:29:03.046]                     })
[08:29:03.046]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.046]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.046]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.046]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.046]                       fi <- file.info(pathname)
[08:29:03.046]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.046]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.046]                         fi[["size"]], fi[["mtime"]])
[08:29:03.046]                       stop(msg)
[08:29:03.046]                     }
[08:29:03.046]                     invisible(pathname)
[08:29:03.046]                   }
[08:29:03.046]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.046]                     rootPath = tempdir()) 
[08:29:03.046]                   {
[08:29:03.046]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.046]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.046]                       tmpdir = path, fileext = ".rds")
[08:29:03.046]                     save_rds(obj, file)
[08:29:03.046]                   }
[08:29:03.046]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.046]                   {
[08:29:03.046]                     inherits <- base::inherits
[08:29:03.046]                     invokeRestart <- base::invokeRestart
[08:29:03.046]                     is.null <- base::is.null
[08:29:03.046]                     muffled <- FALSE
[08:29:03.046]                     if (inherits(cond, "message")) {
[08:29:03.046]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.046]                       if (muffled) 
[08:29:03.046]                         invokeRestart("muffleMessage")
[08:29:03.046]                     }
[08:29:03.046]                     else if (inherits(cond, "warning")) {
[08:29:03.046]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.046]                       if (muffled) 
[08:29:03.046]                         invokeRestart("muffleWarning")
[08:29:03.046]                     }
[08:29:03.046]                     else if (inherits(cond, "condition")) {
[08:29:03.046]                       if (!is.null(pattern)) {
[08:29:03.046]                         computeRestarts <- base::computeRestarts
[08:29:03.046]                         grepl <- base::grepl
[08:29:03.046]                         restarts <- computeRestarts(cond)
[08:29:03.046]                         for (restart in restarts) {
[08:29:03.046]                           name <- restart$name
[08:29:03.046]                           if (is.null(name)) 
[08:29:03.046]                             next
[08:29:03.046]                           if (!grepl(pattern, name)) 
[08:29:03.046]                             next
[08:29:03.046]                           invokeRestart(restart)
[08:29:03.046]                           muffled <- TRUE
[08:29:03.046]                           break
[08:29:03.046]                         }
[08:29:03.046]                       }
[08:29:03.046]                     }
[08:29:03.046]                     invisible(muffled)
[08:29:03.046]                   }
[08:29:03.046]                   muffleCondition(cond)
[08:29:03.046]                 })
[08:29:03.046]             }))
[08:29:03.046]             future::FutureResult(value = ...future.value$value, 
[08:29:03.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.046]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.046]                     ...future.globalenv.names))
[08:29:03.046]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.046]         }, condition = base::local({
[08:29:03.046]             c <- base::c
[08:29:03.046]             inherits <- base::inherits
[08:29:03.046]             invokeRestart <- base::invokeRestart
[08:29:03.046]             length <- base::length
[08:29:03.046]             list <- base::list
[08:29:03.046]             seq.int <- base::seq.int
[08:29:03.046]             signalCondition <- base::signalCondition
[08:29:03.046]             sys.calls <- base::sys.calls
[08:29:03.046]             `[[` <- base::`[[`
[08:29:03.046]             `+` <- base::`+`
[08:29:03.046]             `<<-` <- base::`<<-`
[08:29:03.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.046]                   3L)]
[08:29:03.046]             }
[08:29:03.046]             function(cond) {
[08:29:03.046]                 is_error <- inherits(cond, "error")
[08:29:03.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.046]                   NULL)
[08:29:03.046]                 if (is_error) {
[08:29:03.046]                   sessionInformation <- function() {
[08:29:03.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.046]                       search = base::search(), system = base::Sys.info())
[08:29:03.046]                   }
[08:29:03.046]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.046]                     cond$call), session = sessionInformation(), 
[08:29:03.046]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.046]                   signalCondition(cond)
[08:29:03.046]                 }
[08:29:03.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.046]                 "immediateCondition"))) {
[08:29:03.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.046]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.046]                   if (TRUE && !signal) {
[08:29:03.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.046]                     {
[08:29:03.046]                       inherits <- base::inherits
[08:29:03.046]                       invokeRestart <- base::invokeRestart
[08:29:03.046]                       is.null <- base::is.null
[08:29:03.046]                       muffled <- FALSE
[08:29:03.046]                       if (inherits(cond, "message")) {
[08:29:03.046]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.046]                         if (muffled) 
[08:29:03.046]                           invokeRestart("muffleMessage")
[08:29:03.046]                       }
[08:29:03.046]                       else if (inherits(cond, "warning")) {
[08:29:03.046]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.046]                         if (muffled) 
[08:29:03.046]                           invokeRestart("muffleWarning")
[08:29:03.046]                       }
[08:29:03.046]                       else if (inherits(cond, "condition")) {
[08:29:03.046]                         if (!is.null(pattern)) {
[08:29:03.046]                           computeRestarts <- base::computeRestarts
[08:29:03.046]                           grepl <- base::grepl
[08:29:03.046]                           restarts <- computeRestarts(cond)
[08:29:03.046]                           for (restart in restarts) {
[08:29:03.046]                             name <- restart$name
[08:29:03.046]                             if (is.null(name)) 
[08:29:03.046]                               next
[08:29:03.046]                             if (!grepl(pattern, name)) 
[08:29:03.046]                               next
[08:29:03.046]                             invokeRestart(restart)
[08:29:03.046]                             muffled <- TRUE
[08:29:03.046]                             break
[08:29:03.046]                           }
[08:29:03.046]                         }
[08:29:03.046]                       }
[08:29:03.046]                       invisible(muffled)
[08:29:03.046]                     }
[08:29:03.046]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.046]                   }
[08:29:03.046]                 }
[08:29:03.046]                 else {
[08:29:03.046]                   if (TRUE) {
[08:29:03.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.046]                     {
[08:29:03.046]                       inherits <- base::inherits
[08:29:03.046]                       invokeRestart <- base::invokeRestart
[08:29:03.046]                       is.null <- base::is.null
[08:29:03.046]                       muffled <- FALSE
[08:29:03.046]                       if (inherits(cond, "message")) {
[08:29:03.046]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.046]                         if (muffled) 
[08:29:03.046]                           invokeRestart("muffleMessage")
[08:29:03.046]                       }
[08:29:03.046]                       else if (inherits(cond, "warning")) {
[08:29:03.046]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.046]                         if (muffled) 
[08:29:03.046]                           invokeRestart("muffleWarning")
[08:29:03.046]                       }
[08:29:03.046]                       else if (inherits(cond, "condition")) {
[08:29:03.046]                         if (!is.null(pattern)) {
[08:29:03.046]                           computeRestarts <- base::computeRestarts
[08:29:03.046]                           grepl <- base::grepl
[08:29:03.046]                           restarts <- computeRestarts(cond)
[08:29:03.046]                           for (restart in restarts) {
[08:29:03.046]                             name <- restart$name
[08:29:03.046]                             if (is.null(name)) 
[08:29:03.046]                               next
[08:29:03.046]                             if (!grepl(pattern, name)) 
[08:29:03.046]                               next
[08:29:03.046]                             invokeRestart(restart)
[08:29:03.046]                             muffled <- TRUE
[08:29:03.046]                             break
[08:29:03.046]                           }
[08:29:03.046]                         }
[08:29:03.046]                       }
[08:29:03.046]                       invisible(muffled)
[08:29:03.046]                     }
[08:29:03.046]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.046]                   }
[08:29:03.046]                 }
[08:29:03.046]             }
[08:29:03.046]         }))
[08:29:03.046]     }, error = function(ex) {
[08:29:03.046]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.046]                 ...future.rng), started = ...future.startTime, 
[08:29:03.046]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.046]             version = "1.8"), class = "FutureResult")
[08:29:03.046]     }, finally = {
[08:29:03.046]         if (!identical(...future.workdir, getwd())) 
[08:29:03.046]             setwd(...future.workdir)
[08:29:03.046]         {
[08:29:03.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.046]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.046]             }
[08:29:03.046]             base::options(...future.oldOptions)
[08:29:03.046]             if (.Platform$OS.type == "windows") {
[08:29:03.046]                 old_names <- names(...future.oldEnvVars)
[08:29:03.046]                 envs <- base::Sys.getenv()
[08:29:03.046]                 names <- names(envs)
[08:29:03.046]                 common <- intersect(names, old_names)
[08:29:03.046]                 added <- setdiff(names, old_names)
[08:29:03.046]                 removed <- setdiff(old_names, names)
[08:29:03.046]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.046]                   envs[common]]
[08:29:03.046]                 NAMES <- toupper(changed)
[08:29:03.046]                 args <- list()
[08:29:03.046]                 for (kk in seq_along(NAMES)) {
[08:29:03.046]                   name <- changed[[kk]]
[08:29:03.046]                   NAME <- NAMES[[kk]]
[08:29:03.046]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.046]                     next
[08:29:03.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.046]                 }
[08:29:03.046]                 NAMES <- toupper(added)
[08:29:03.046]                 for (kk in seq_along(NAMES)) {
[08:29:03.046]                   name <- added[[kk]]
[08:29:03.046]                   NAME <- NAMES[[kk]]
[08:29:03.046]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.046]                     next
[08:29:03.046]                   args[[name]] <- ""
[08:29:03.046]                 }
[08:29:03.046]                 NAMES <- toupper(removed)
[08:29:03.046]                 for (kk in seq_along(NAMES)) {
[08:29:03.046]                   name <- removed[[kk]]
[08:29:03.046]                   NAME <- NAMES[[kk]]
[08:29:03.046]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.046]                     next
[08:29:03.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.046]                 }
[08:29:03.046]                 if (length(args) > 0) 
[08:29:03.046]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.046]             }
[08:29:03.046]             else {
[08:29:03.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.046]             }
[08:29:03.046]             {
[08:29:03.046]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.046]                   0L) {
[08:29:03.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.046]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.046]                   base::options(opts)
[08:29:03.046]                 }
[08:29:03.046]                 {
[08:29:03.046]                   {
[08:29:03.046]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.046]                     NULL
[08:29:03.046]                   }
[08:29:03.046]                   options(future.plan = NULL)
[08:29:03.046]                   if (is.na(NA_character_)) 
[08:29:03.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.046]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.046]                     .init = FALSE)
[08:29:03.046]                 }
[08:29:03.046]             }
[08:29:03.046]         }
[08:29:03.046]     })
[08:29:03.046]     if (TRUE) {
[08:29:03.046]         base::sink(type = "output", split = FALSE)
[08:29:03.046]         if (TRUE) {
[08:29:03.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.046]         }
[08:29:03.046]         else {
[08:29:03.046]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.046]         }
[08:29:03.046]         base::close(...future.stdout)
[08:29:03.046]         ...future.stdout <- NULL
[08:29:03.046]     }
[08:29:03.046]     ...future.result$conditions <- ...future.conditions
[08:29:03.046]     ...future.result$finished <- base::Sys.time()
[08:29:03.046]     ...future.result
[08:29:03.046] }
[08:29:03.048] requestCore(): workers = 2
[08:29:03.049] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.059] result() for MulticoreFuture ...
[08:29:03.060] result() for MulticoreFuture ...
[08:29:03.060] result() for MulticoreFuture ... done
[08:29:03.061] result() for MulticoreFuture ... done
[08:29:03.061] result() for MulticoreFuture ...
[08:29:03.061] result() for MulticoreFuture ... done
[08:29:03.063] MulticoreFuture started
[08:29:03.063] - Launch lazy future ... done
[08:29:03.064] run() for ‘MulticoreFuture’ ... done
[08:29:03.064] plan(): Setting new future strategy stack:
[08:29:03.064] getGlobalsAndPackages() ...
[08:29:03.065] Searching for globals...
[08:29:03.066] 
[08:29:03.065] List of future strategies:
[08:29:03.065] 1. sequential:
[08:29:03.065]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.065]    - tweaked: FALSE
[08:29:03.065]    - call: NULL
[08:29:03.066] Searching for globals ... DONE
[08:29:03.066] plan(): nbrOfWorkers() = 1
[08:29:03.066] - globals: [0] <none>
[08:29:03.067] getGlobalsAndPackages() ... DONE
[08:29:03.067] run() for ‘Future’ ...
[08:29:03.068] - state: ‘created’
[08:29:03.068] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.069] plan(): Setting new future strategy stack:
[08:29:03.070] List of future strategies:
[08:29:03.070] 1. multicore:
[08:29:03.070]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.070]    - tweaked: FALSE
[08:29:03.070]    - call: plan(strategy)
[08:29:03.073] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.073] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.073]   - Field: ‘label’
[08:29:03.073]   - Field: ‘local’
[08:29:03.073] plan(): nbrOfWorkers() = 2
[08:29:03.074]   - Field: ‘owner’
[08:29:03.074]   - Field: ‘envir’
[08:29:03.074]   - Field: ‘workers’
[08:29:03.074]   - Field: ‘packages’
[08:29:03.074]   - Field: ‘gc’
[08:29:03.075]   - Field: ‘job’
[08:29:03.075]   - Field: ‘conditions’
[08:29:03.075]   - Field: ‘expr’
[08:29:03.075]   - Field: ‘uuid’
[08:29:03.075]   - Field: ‘seed’
[08:29:03.075]   - Field: ‘version’
[08:29:03.075]   - Field: ‘result’
[08:29:03.076]   - Field: ‘asynchronous’
[08:29:03.076]   - Field: ‘calls’
[08:29:03.076]   - Field: ‘globals’
[08:29:03.076]   - Field: ‘stdout’
[08:29:03.076]   - Field: ‘earlySignal’
[08:29:03.076]   - Field: ‘lazy’
[08:29:03.076]   - Field: ‘state’
[08:29:03.077] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.077] - Launch lazy future ...
[08:29:03.077] Packages needed by the future expression (n = 0): <none>
[08:29:03.077] Packages needed by future strategies (n = 0): <none>
[08:29:03.078] {
[08:29:03.078]     {
[08:29:03.078]         {
[08:29:03.078]             ...future.startTime <- base::Sys.time()
[08:29:03.078]             {
[08:29:03.078]                 {
[08:29:03.078]                   {
[08:29:03.078]                     {
[08:29:03.078]                       base::local({
[08:29:03.078]                         has_future <- base::requireNamespace("future", 
[08:29:03.078]                           quietly = TRUE)
[08:29:03.078]                         if (has_future) {
[08:29:03.078]                           ns <- base::getNamespace("future")
[08:29:03.078]                           version <- ns[[".package"]][["version"]]
[08:29:03.078]                           if (is.null(version)) 
[08:29:03.078]                             version <- utils::packageVersion("future")
[08:29:03.078]                         }
[08:29:03.078]                         else {
[08:29:03.078]                           version <- NULL
[08:29:03.078]                         }
[08:29:03.078]                         if (!has_future || version < "1.8.0") {
[08:29:03.078]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.078]                             "", base::R.version$version.string), 
[08:29:03.078]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.078]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.078]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.078]                               "release", "version")], collapse = " "), 
[08:29:03.078]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.078]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.078]                             info)
[08:29:03.078]                           info <- base::paste(info, collapse = "; ")
[08:29:03.078]                           if (!has_future) {
[08:29:03.078]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.078]                               info)
[08:29:03.078]                           }
[08:29:03.078]                           else {
[08:29:03.078]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.078]                               info, version)
[08:29:03.078]                           }
[08:29:03.078]                           base::stop(msg)
[08:29:03.078]                         }
[08:29:03.078]                       })
[08:29:03.078]                     }
[08:29:03.078]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.078]                     base::options(mc.cores = 1L)
[08:29:03.078]                   }
[08:29:03.078]                   ...future.strategy.old <- future::plan("list")
[08:29:03.078]                   options(future.plan = NULL)
[08:29:03.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.078]                 }
[08:29:03.078]                 ...future.workdir <- getwd()
[08:29:03.078]             }
[08:29:03.078]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.078]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.078]         }
[08:29:03.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.078]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.078]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.078]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.078]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.078]             base::names(...future.oldOptions))
[08:29:03.078]     }
[08:29:03.078]     if (FALSE) {
[08:29:03.078]     }
[08:29:03.078]     else {
[08:29:03.078]         if (TRUE) {
[08:29:03.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.078]                 open = "w")
[08:29:03.078]         }
[08:29:03.078]         else {
[08:29:03.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.078]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.078]         }
[08:29:03.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.078]             base::sink(type = "output", split = FALSE)
[08:29:03.078]             base::close(...future.stdout)
[08:29:03.078]         }, add = TRUE)
[08:29:03.078]     }
[08:29:03.078]     ...future.frame <- base::sys.nframe()
[08:29:03.078]     ...future.conditions <- base::list()
[08:29:03.078]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.078]     if (FALSE) {
[08:29:03.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.078]     }
[08:29:03.078]     ...future.result <- base::tryCatch({
[08:29:03.078]         base::withCallingHandlers({
[08:29:03.078]             ...future.value <- base::withVisible(base::local({
[08:29:03.078]                 withCallingHandlers({
[08:29:03.078]                   2
[08:29:03.078]                 }, immediateCondition = function(cond) {
[08:29:03.078]                   save_rds <- function (object, pathname, ...) 
[08:29:03.078]                   {
[08:29:03.078]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.078]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.078]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.078]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.078]                         fi_tmp[["mtime"]])
[08:29:03.078]                     }
[08:29:03.078]                     tryCatch({
[08:29:03.078]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.078]                     }, error = function(ex) {
[08:29:03.078]                       msg <- conditionMessage(ex)
[08:29:03.078]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.078]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.078]                         fi_tmp[["mtime"]], msg)
[08:29:03.078]                       ex$message <- msg
[08:29:03.078]                       stop(ex)
[08:29:03.078]                     })
[08:29:03.078]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.078]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.078]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.078]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.078]                       fi <- file.info(pathname)
[08:29:03.078]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.078]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.078]                         fi[["size"]], fi[["mtime"]])
[08:29:03.078]                       stop(msg)
[08:29:03.078]                     }
[08:29:03.078]                     invisible(pathname)
[08:29:03.078]                   }
[08:29:03.078]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.078]                     rootPath = tempdir()) 
[08:29:03.078]                   {
[08:29:03.078]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.078]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.078]                       tmpdir = path, fileext = ".rds")
[08:29:03.078]                     save_rds(obj, file)
[08:29:03.078]                   }
[08:29:03.078]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.078]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.078]                   {
[08:29:03.078]                     inherits <- base::inherits
[08:29:03.078]                     invokeRestart <- base::invokeRestart
[08:29:03.078]                     is.null <- base::is.null
[08:29:03.078]                     muffled <- FALSE
[08:29:03.078]                     if (inherits(cond, "message")) {
[08:29:03.078]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.078]                       if (muffled) 
[08:29:03.078]                         invokeRestart("muffleMessage")
[08:29:03.078]                     }
[08:29:03.078]                     else if (inherits(cond, "warning")) {
[08:29:03.078]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.078]                       if (muffled) 
[08:29:03.078]                         invokeRestart("muffleWarning")
[08:29:03.078]                     }
[08:29:03.078]                     else if (inherits(cond, "condition")) {
[08:29:03.078]                       if (!is.null(pattern)) {
[08:29:03.078]                         computeRestarts <- base::computeRestarts
[08:29:03.078]                         grepl <- base::grepl
[08:29:03.078]                         restarts <- computeRestarts(cond)
[08:29:03.078]                         for (restart in restarts) {
[08:29:03.078]                           name <- restart$name
[08:29:03.078]                           if (is.null(name)) 
[08:29:03.078]                             next
[08:29:03.078]                           if (!grepl(pattern, name)) 
[08:29:03.078]                             next
[08:29:03.078]                           invokeRestart(restart)
[08:29:03.078]                           muffled <- TRUE
[08:29:03.078]                           break
[08:29:03.078]                         }
[08:29:03.078]                       }
[08:29:03.078]                     }
[08:29:03.078]                     invisible(muffled)
[08:29:03.078]                   }
[08:29:03.078]                   muffleCondition(cond)
[08:29:03.078]                 })
[08:29:03.078]             }))
[08:29:03.078]             future::FutureResult(value = ...future.value$value, 
[08:29:03.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.078]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.078]                     ...future.globalenv.names))
[08:29:03.078]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.078]         }, condition = base::local({
[08:29:03.078]             c <- base::c
[08:29:03.078]             inherits <- base::inherits
[08:29:03.078]             invokeRestart <- base::invokeRestart
[08:29:03.078]             length <- base::length
[08:29:03.078]             list <- base::list
[08:29:03.078]             seq.int <- base::seq.int
[08:29:03.078]             signalCondition <- base::signalCondition
[08:29:03.078]             sys.calls <- base::sys.calls
[08:29:03.078]             `[[` <- base::`[[`
[08:29:03.078]             `+` <- base::`+`
[08:29:03.078]             `<<-` <- base::`<<-`
[08:29:03.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.078]                   3L)]
[08:29:03.078]             }
[08:29:03.078]             function(cond) {
[08:29:03.078]                 is_error <- inherits(cond, "error")
[08:29:03.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.078]                   NULL)
[08:29:03.078]                 if (is_error) {
[08:29:03.078]                   sessionInformation <- function() {
[08:29:03.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.078]                       search = base::search(), system = base::Sys.info())
[08:29:03.078]                   }
[08:29:03.078]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.078]                     cond$call), session = sessionInformation(), 
[08:29:03.078]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.078]                   signalCondition(cond)
[08:29:03.078]                 }
[08:29:03.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.078]                 "immediateCondition"))) {
[08:29:03.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.078]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.078]                   if (TRUE && !signal) {
[08:29:03.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.078]                     {
[08:29:03.078]                       inherits <- base::inherits
[08:29:03.078]                       invokeRestart <- base::invokeRestart
[08:29:03.078]                       is.null <- base::is.null
[08:29:03.078]                       muffled <- FALSE
[08:29:03.078]                       if (inherits(cond, "message")) {
[08:29:03.078]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.078]                         if (muffled) 
[08:29:03.078]                           invokeRestart("muffleMessage")
[08:29:03.078]                       }
[08:29:03.078]                       else if (inherits(cond, "warning")) {
[08:29:03.078]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.078]                         if (muffled) 
[08:29:03.078]                           invokeRestart("muffleWarning")
[08:29:03.078]                       }
[08:29:03.078]                       else if (inherits(cond, "condition")) {
[08:29:03.078]                         if (!is.null(pattern)) {
[08:29:03.078]                           computeRestarts <- base::computeRestarts
[08:29:03.078]                           grepl <- base::grepl
[08:29:03.078]                           restarts <- computeRestarts(cond)
[08:29:03.078]                           for (restart in restarts) {
[08:29:03.078]                             name <- restart$name
[08:29:03.078]                             if (is.null(name)) 
[08:29:03.078]                               next
[08:29:03.078]                             if (!grepl(pattern, name)) 
[08:29:03.078]                               next
[08:29:03.078]                             invokeRestart(restart)
[08:29:03.078]                             muffled <- TRUE
[08:29:03.078]                             break
[08:29:03.078]                           }
[08:29:03.078]                         }
[08:29:03.078]                       }
[08:29:03.078]                       invisible(muffled)
[08:29:03.078]                     }
[08:29:03.078]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.078]                   }
[08:29:03.078]                 }
[08:29:03.078]                 else {
[08:29:03.078]                   if (TRUE) {
[08:29:03.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.078]                     {
[08:29:03.078]                       inherits <- base::inherits
[08:29:03.078]                       invokeRestart <- base::invokeRestart
[08:29:03.078]                       is.null <- base::is.null
[08:29:03.078]                       muffled <- FALSE
[08:29:03.078]                       if (inherits(cond, "message")) {
[08:29:03.078]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.078]                         if (muffled) 
[08:29:03.078]                           invokeRestart("muffleMessage")
[08:29:03.078]                       }
[08:29:03.078]                       else if (inherits(cond, "warning")) {
[08:29:03.078]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.078]                         if (muffled) 
[08:29:03.078]                           invokeRestart("muffleWarning")
[08:29:03.078]                       }
[08:29:03.078]                       else if (inherits(cond, "condition")) {
[08:29:03.078]                         if (!is.null(pattern)) {
[08:29:03.078]                           computeRestarts <- base::computeRestarts
[08:29:03.078]                           grepl <- base::grepl
[08:29:03.078]                           restarts <- computeRestarts(cond)
[08:29:03.078]                           for (restart in restarts) {
[08:29:03.078]                             name <- restart$name
[08:29:03.078]                             if (is.null(name)) 
[08:29:03.078]                               next
[08:29:03.078]                             if (!grepl(pattern, name)) 
[08:29:03.078]                               next
[08:29:03.078]                             invokeRestart(restart)
[08:29:03.078]                             muffled <- TRUE
[08:29:03.078]                             break
[08:29:03.078]                           }
[08:29:03.078]                         }
[08:29:03.078]                       }
[08:29:03.078]                       invisible(muffled)
[08:29:03.078]                     }
[08:29:03.078]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.078]                   }
[08:29:03.078]                 }
[08:29:03.078]             }
[08:29:03.078]         }))
[08:29:03.078]     }, error = function(ex) {
[08:29:03.078]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.078]                 ...future.rng), started = ...future.startTime, 
[08:29:03.078]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.078]             version = "1.8"), class = "FutureResult")
[08:29:03.078]     }, finally = {
[08:29:03.078]         if (!identical(...future.workdir, getwd())) 
[08:29:03.078]             setwd(...future.workdir)
[08:29:03.078]         {
[08:29:03.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.078]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.078]             }
[08:29:03.078]             base::options(...future.oldOptions)
[08:29:03.078]             if (.Platform$OS.type == "windows") {
[08:29:03.078]                 old_names <- names(...future.oldEnvVars)
[08:29:03.078]                 envs <- base::Sys.getenv()
[08:29:03.078]                 names <- names(envs)
[08:29:03.078]                 common <- intersect(names, old_names)
[08:29:03.078]                 added <- setdiff(names, old_names)
[08:29:03.078]                 removed <- setdiff(old_names, names)
[08:29:03.078]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.078]                   envs[common]]
[08:29:03.078]                 NAMES <- toupper(changed)
[08:29:03.078]                 args <- list()
[08:29:03.078]                 for (kk in seq_along(NAMES)) {
[08:29:03.078]                   name <- changed[[kk]]
[08:29:03.078]                   NAME <- NAMES[[kk]]
[08:29:03.078]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.078]                     next
[08:29:03.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.078]                 }
[08:29:03.078]                 NAMES <- toupper(added)
[08:29:03.078]                 for (kk in seq_along(NAMES)) {
[08:29:03.078]                   name <- added[[kk]]
[08:29:03.078]                   NAME <- NAMES[[kk]]
[08:29:03.078]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.078]                     next
[08:29:03.078]                   args[[name]] <- ""
[08:29:03.078]                 }
[08:29:03.078]                 NAMES <- toupper(removed)
[08:29:03.078]                 for (kk in seq_along(NAMES)) {
[08:29:03.078]                   name <- removed[[kk]]
[08:29:03.078]                   NAME <- NAMES[[kk]]
[08:29:03.078]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.078]                     next
[08:29:03.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.078]                 }
[08:29:03.078]                 if (length(args) > 0) 
[08:29:03.078]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.078]             }
[08:29:03.078]             else {
[08:29:03.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.078]             }
[08:29:03.078]             {
[08:29:03.078]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.078]                   0L) {
[08:29:03.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.078]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.078]                   base::options(opts)
[08:29:03.078]                 }
[08:29:03.078]                 {
[08:29:03.078]                   {
[08:29:03.078]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.078]                     NULL
[08:29:03.078]                   }
[08:29:03.078]                   options(future.plan = NULL)
[08:29:03.078]                   if (is.na(NA_character_)) 
[08:29:03.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.078]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.078]                     .init = FALSE)
[08:29:03.078]                 }
[08:29:03.078]             }
[08:29:03.078]         }
[08:29:03.078]     })
[08:29:03.078]     if (TRUE) {
[08:29:03.078]         base::sink(type = "output", split = FALSE)
[08:29:03.078]         if (TRUE) {
[08:29:03.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.078]         }
[08:29:03.078]         else {
[08:29:03.078]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.078]         }
[08:29:03.078]         base::close(...future.stdout)
[08:29:03.078]         ...future.stdout <- NULL
[08:29:03.078]     }
[08:29:03.078]     ...future.result$conditions <- ...future.conditions
[08:29:03.078]     ...future.result$finished <- base::Sys.time()
[08:29:03.078]     ...future.result
[08:29:03.078] }
[08:29:03.082] requestCore(): workers = 2
[08:29:03.082] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.093] result() for MulticoreFuture ...
[08:29:03.094] result() for MulticoreFuture ...
[08:29:03.094] result() for MulticoreFuture ... done
[08:29:03.094] result() for MulticoreFuture ... done
[08:29:03.094] result() for MulticoreFuture ...
[08:29:03.094] result() for MulticoreFuture ... done
[08:29:03.096] MulticoreFuture started
[08:29:03.097] - Launch lazy future ... done
[08:29:03.097] run() for ‘MulticoreFuture’ ... done
[08:29:03.098] plan(): Setting new future strategy stack:
[08:29:03.099] resolve() on environment ...
[08:29:03.099]  recursive: 0
[08:29:03.098] List of future strategies:
[08:29:03.098] 1. sequential:
[08:29:03.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.098]    - tweaked: FALSE
[08:29:03.098]    - call: NULL
[08:29:03.099] plan(): nbrOfWorkers() = 1
[08:29:03.100]  elements: [3] ‘a’, ‘b’, ‘c’
[08:29:03.100] Future #1
[08:29:03.100]  length: 2 (resolved future 1)
[08:29:03.102] plan(): Setting new future strategy stack:
[08:29:03.102] List of future strategies:
[08:29:03.102] 1. multicore:
[08:29:03.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.102]    - tweaked: FALSE
[08:29:03.102]    - call: plan(strategy)
[08:29:03.106] plan(): nbrOfWorkers() = 2
[08:29:03.107] Future #2
[08:29:03.107]  length: 1 (resolved future 2)
[08:29:03.107]  length: 0 (resolved future 3)
[08:29:03.107] resolve() on environment ... DONE
[08:29:03.108] getGlobalsAndPackages() ...
[08:29:03.109] Searching for globals...
[08:29:03.110] - globals found: [1] ‘{’
[08:29:03.110] Searching for globals ... DONE
[08:29:03.110] Resolving globals: FALSE
[08:29:03.111] 
[08:29:03.111] 
[08:29:03.111] getGlobalsAndPackages() ... DONE
[08:29:03.111] run() for ‘Future’ ...
[08:29:03.111] - state: ‘created’
[08:29:03.112] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.114] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.114] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.115]   - Field: ‘label’
[08:29:03.115]   - Field: ‘local’
[08:29:03.115]   - Field: ‘owner’
[08:29:03.115]   - Field: ‘envir’
[08:29:03.115]   - Field: ‘workers’
[08:29:03.115]   - Field: ‘packages’
[08:29:03.116]   - Field: ‘gc’
[08:29:03.116]   - Field: ‘job’
[08:29:03.116]   - Field: ‘conditions’
[08:29:03.116]   - Field: ‘expr’
[08:29:03.116]   - Field: ‘uuid’
[08:29:03.116]   - Field: ‘seed’
[08:29:03.116]   - Field: ‘version’
[08:29:03.116]   - Field: ‘result’
[08:29:03.117]   - Field: ‘asynchronous’
[08:29:03.117]   - Field: ‘calls’
[08:29:03.117]   - Field: ‘globals’
[08:29:03.117]   - Field: ‘stdout’
[08:29:03.117]   - Field: ‘earlySignal’
[08:29:03.117]   - Field: ‘lazy’
[08:29:03.117]   - Field: ‘state’
[08:29:03.118] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.118] - Launch lazy future ...
[08:29:03.118] Packages needed by the future expression (n = 0): <none>
[08:29:03.118] Packages needed by future strategies (n = 0): <none>
[08:29:03.119] {
[08:29:03.119]     {
[08:29:03.119]         {
[08:29:03.119]             ...future.startTime <- base::Sys.time()
[08:29:03.119]             {
[08:29:03.119]                 {
[08:29:03.119]                   {
[08:29:03.119]                     {
[08:29:03.119]                       base::local({
[08:29:03.119]                         has_future <- base::requireNamespace("future", 
[08:29:03.119]                           quietly = TRUE)
[08:29:03.119]                         if (has_future) {
[08:29:03.119]                           ns <- base::getNamespace("future")
[08:29:03.119]                           version <- ns[[".package"]][["version"]]
[08:29:03.119]                           if (is.null(version)) 
[08:29:03.119]                             version <- utils::packageVersion("future")
[08:29:03.119]                         }
[08:29:03.119]                         else {
[08:29:03.119]                           version <- NULL
[08:29:03.119]                         }
[08:29:03.119]                         if (!has_future || version < "1.8.0") {
[08:29:03.119]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.119]                             "", base::R.version$version.string), 
[08:29:03.119]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.119]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.119]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.119]                               "release", "version")], collapse = " "), 
[08:29:03.119]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.119]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.119]                             info)
[08:29:03.119]                           info <- base::paste(info, collapse = "; ")
[08:29:03.119]                           if (!has_future) {
[08:29:03.119]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.119]                               info)
[08:29:03.119]                           }
[08:29:03.119]                           else {
[08:29:03.119]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.119]                               info, version)
[08:29:03.119]                           }
[08:29:03.119]                           base::stop(msg)
[08:29:03.119]                         }
[08:29:03.119]                       })
[08:29:03.119]                     }
[08:29:03.119]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.119]                     base::options(mc.cores = 1L)
[08:29:03.119]                   }
[08:29:03.119]                   ...future.strategy.old <- future::plan("list")
[08:29:03.119]                   options(future.plan = NULL)
[08:29:03.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.119]                 }
[08:29:03.119]                 ...future.workdir <- getwd()
[08:29:03.119]             }
[08:29:03.119]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.119]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.119]         }
[08:29:03.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.119]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.119]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.119]             base::names(...future.oldOptions))
[08:29:03.119]     }
[08:29:03.119]     if (FALSE) {
[08:29:03.119]     }
[08:29:03.119]     else {
[08:29:03.119]         if (TRUE) {
[08:29:03.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.119]                 open = "w")
[08:29:03.119]         }
[08:29:03.119]         else {
[08:29:03.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.119]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.119]         }
[08:29:03.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.119]             base::sink(type = "output", split = FALSE)
[08:29:03.119]             base::close(...future.stdout)
[08:29:03.119]         }, add = TRUE)
[08:29:03.119]     }
[08:29:03.119]     ...future.frame <- base::sys.nframe()
[08:29:03.119]     ...future.conditions <- base::list()
[08:29:03.119]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.119]     if (FALSE) {
[08:29:03.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.119]     }
[08:29:03.119]     ...future.result <- base::tryCatch({
[08:29:03.119]         base::withCallingHandlers({
[08:29:03.119]             ...future.value <- base::withVisible(base::local({
[08:29:03.119]                 withCallingHandlers({
[08:29:03.119]                   {
[08:29:03.119]                     1
[08:29:03.119]                   }
[08:29:03.119]                 }, immediateCondition = function(cond) {
[08:29:03.119]                   save_rds <- function (object, pathname, ...) 
[08:29:03.119]                   {
[08:29:03.119]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.119]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.119]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.119]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.119]                         fi_tmp[["mtime"]])
[08:29:03.119]                     }
[08:29:03.119]                     tryCatch({
[08:29:03.119]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.119]                     }, error = function(ex) {
[08:29:03.119]                       msg <- conditionMessage(ex)
[08:29:03.119]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.119]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.119]                         fi_tmp[["mtime"]], msg)
[08:29:03.119]                       ex$message <- msg
[08:29:03.119]                       stop(ex)
[08:29:03.119]                     })
[08:29:03.119]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.119]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.119]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.119]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.119]                       fi <- file.info(pathname)
[08:29:03.119]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.119]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.119]                         fi[["size"]], fi[["mtime"]])
[08:29:03.119]                       stop(msg)
[08:29:03.119]                     }
[08:29:03.119]                     invisible(pathname)
[08:29:03.119]                   }
[08:29:03.119]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.119]                     rootPath = tempdir()) 
[08:29:03.119]                   {
[08:29:03.119]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.119]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.119]                       tmpdir = path, fileext = ".rds")
[08:29:03.119]                     save_rds(obj, file)
[08:29:03.119]                   }
[08:29:03.119]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.119]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.119]                   {
[08:29:03.119]                     inherits <- base::inherits
[08:29:03.119]                     invokeRestart <- base::invokeRestart
[08:29:03.119]                     is.null <- base::is.null
[08:29:03.119]                     muffled <- FALSE
[08:29:03.119]                     if (inherits(cond, "message")) {
[08:29:03.119]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.119]                       if (muffled) 
[08:29:03.119]                         invokeRestart("muffleMessage")
[08:29:03.119]                     }
[08:29:03.119]                     else if (inherits(cond, "warning")) {
[08:29:03.119]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.119]                       if (muffled) 
[08:29:03.119]                         invokeRestart("muffleWarning")
[08:29:03.119]                     }
[08:29:03.119]                     else if (inherits(cond, "condition")) {
[08:29:03.119]                       if (!is.null(pattern)) {
[08:29:03.119]                         computeRestarts <- base::computeRestarts
[08:29:03.119]                         grepl <- base::grepl
[08:29:03.119]                         restarts <- computeRestarts(cond)
[08:29:03.119]                         for (restart in restarts) {
[08:29:03.119]                           name <- restart$name
[08:29:03.119]                           if (is.null(name)) 
[08:29:03.119]                             next
[08:29:03.119]                           if (!grepl(pattern, name)) 
[08:29:03.119]                             next
[08:29:03.119]                           invokeRestart(restart)
[08:29:03.119]                           muffled <- TRUE
[08:29:03.119]                           break
[08:29:03.119]                         }
[08:29:03.119]                       }
[08:29:03.119]                     }
[08:29:03.119]                     invisible(muffled)
[08:29:03.119]                   }
[08:29:03.119]                   muffleCondition(cond)
[08:29:03.119]                 })
[08:29:03.119]             }))
[08:29:03.119]             future::FutureResult(value = ...future.value$value, 
[08:29:03.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.119]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.119]                     ...future.globalenv.names))
[08:29:03.119]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.119]         }, condition = base::local({
[08:29:03.119]             c <- base::c
[08:29:03.119]             inherits <- base::inherits
[08:29:03.119]             invokeRestart <- base::invokeRestart
[08:29:03.119]             length <- base::length
[08:29:03.119]             list <- base::list
[08:29:03.119]             seq.int <- base::seq.int
[08:29:03.119]             signalCondition <- base::signalCondition
[08:29:03.119]             sys.calls <- base::sys.calls
[08:29:03.119]             `[[` <- base::`[[`
[08:29:03.119]             `+` <- base::`+`
[08:29:03.119]             `<<-` <- base::`<<-`
[08:29:03.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.119]                   3L)]
[08:29:03.119]             }
[08:29:03.119]             function(cond) {
[08:29:03.119]                 is_error <- inherits(cond, "error")
[08:29:03.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.119]                   NULL)
[08:29:03.119]                 if (is_error) {
[08:29:03.119]                   sessionInformation <- function() {
[08:29:03.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.119]                       search = base::search(), system = base::Sys.info())
[08:29:03.119]                   }
[08:29:03.119]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.119]                     cond$call), session = sessionInformation(), 
[08:29:03.119]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.119]                   signalCondition(cond)
[08:29:03.119]                 }
[08:29:03.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.119]                 "immediateCondition"))) {
[08:29:03.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.119]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.119]                   if (TRUE && !signal) {
[08:29:03.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.119]                     {
[08:29:03.119]                       inherits <- base::inherits
[08:29:03.119]                       invokeRestart <- base::invokeRestart
[08:29:03.119]                       is.null <- base::is.null
[08:29:03.119]                       muffled <- FALSE
[08:29:03.119]                       if (inherits(cond, "message")) {
[08:29:03.119]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.119]                         if (muffled) 
[08:29:03.119]                           invokeRestart("muffleMessage")
[08:29:03.119]                       }
[08:29:03.119]                       else if (inherits(cond, "warning")) {
[08:29:03.119]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.119]                         if (muffled) 
[08:29:03.119]                           invokeRestart("muffleWarning")
[08:29:03.119]                       }
[08:29:03.119]                       else if (inherits(cond, "condition")) {
[08:29:03.119]                         if (!is.null(pattern)) {
[08:29:03.119]                           computeRestarts <- base::computeRestarts
[08:29:03.119]                           grepl <- base::grepl
[08:29:03.119]                           restarts <- computeRestarts(cond)
[08:29:03.119]                           for (restart in restarts) {
[08:29:03.119]                             name <- restart$name
[08:29:03.119]                             if (is.null(name)) 
[08:29:03.119]                               next
[08:29:03.119]                             if (!grepl(pattern, name)) 
[08:29:03.119]                               next
[08:29:03.119]                             invokeRestart(restart)
[08:29:03.119]                             muffled <- TRUE
[08:29:03.119]                             break
[08:29:03.119]                           }
[08:29:03.119]                         }
[08:29:03.119]                       }
[08:29:03.119]                       invisible(muffled)
[08:29:03.119]                     }
[08:29:03.119]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.119]                   }
[08:29:03.119]                 }
[08:29:03.119]                 else {
[08:29:03.119]                   if (TRUE) {
[08:29:03.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.119]                     {
[08:29:03.119]                       inherits <- base::inherits
[08:29:03.119]                       invokeRestart <- base::invokeRestart
[08:29:03.119]                       is.null <- base::is.null
[08:29:03.119]                       muffled <- FALSE
[08:29:03.119]                       if (inherits(cond, "message")) {
[08:29:03.119]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.119]                         if (muffled) 
[08:29:03.119]                           invokeRestart("muffleMessage")
[08:29:03.119]                       }
[08:29:03.119]                       else if (inherits(cond, "warning")) {
[08:29:03.119]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.119]                         if (muffled) 
[08:29:03.119]                           invokeRestart("muffleWarning")
[08:29:03.119]                       }
[08:29:03.119]                       else if (inherits(cond, "condition")) {
[08:29:03.119]                         if (!is.null(pattern)) {
[08:29:03.119]                           computeRestarts <- base::computeRestarts
[08:29:03.119]                           grepl <- base::grepl
[08:29:03.119]                           restarts <- computeRestarts(cond)
[08:29:03.119]                           for (restart in restarts) {
[08:29:03.119]                             name <- restart$name
[08:29:03.119]                             if (is.null(name)) 
[08:29:03.119]                               next
[08:29:03.119]                             if (!grepl(pattern, name)) 
[08:29:03.119]                               next
[08:29:03.119]                             invokeRestart(restart)
[08:29:03.119]                             muffled <- TRUE
[08:29:03.119]                             break
[08:29:03.119]                           }
[08:29:03.119]                         }
[08:29:03.119]                       }
[08:29:03.119]                       invisible(muffled)
[08:29:03.119]                     }
[08:29:03.119]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.119]                   }
[08:29:03.119]                 }
[08:29:03.119]             }
[08:29:03.119]         }))
[08:29:03.119]     }, error = function(ex) {
[08:29:03.119]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.119]                 ...future.rng), started = ...future.startTime, 
[08:29:03.119]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.119]             version = "1.8"), class = "FutureResult")
[08:29:03.119]     }, finally = {
[08:29:03.119]         if (!identical(...future.workdir, getwd())) 
[08:29:03.119]             setwd(...future.workdir)
[08:29:03.119]         {
[08:29:03.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.119]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.119]             }
[08:29:03.119]             base::options(...future.oldOptions)
[08:29:03.119]             if (.Platform$OS.type == "windows") {
[08:29:03.119]                 old_names <- names(...future.oldEnvVars)
[08:29:03.119]                 envs <- base::Sys.getenv()
[08:29:03.119]                 names <- names(envs)
[08:29:03.119]                 common <- intersect(names, old_names)
[08:29:03.119]                 added <- setdiff(names, old_names)
[08:29:03.119]                 removed <- setdiff(old_names, names)
[08:29:03.119]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.119]                   envs[common]]
[08:29:03.119]                 NAMES <- toupper(changed)
[08:29:03.119]                 args <- list()
[08:29:03.119]                 for (kk in seq_along(NAMES)) {
[08:29:03.119]                   name <- changed[[kk]]
[08:29:03.119]                   NAME <- NAMES[[kk]]
[08:29:03.119]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.119]                     next
[08:29:03.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.119]                 }
[08:29:03.119]                 NAMES <- toupper(added)
[08:29:03.119]                 for (kk in seq_along(NAMES)) {
[08:29:03.119]                   name <- added[[kk]]
[08:29:03.119]                   NAME <- NAMES[[kk]]
[08:29:03.119]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.119]                     next
[08:29:03.119]                   args[[name]] <- ""
[08:29:03.119]                 }
[08:29:03.119]                 NAMES <- toupper(removed)
[08:29:03.119]                 for (kk in seq_along(NAMES)) {
[08:29:03.119]                   name <- removed[[kk]]
[08:29:03.119]                   NAME <- NAMES[[kk]]
[08:29:03.119]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.119]                     next
[08:29:03.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.119]                 }
[08:29:03.119]                 if (length(args) > 0) 
[08:29:03.119]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.119]             }
[08:29:03.119]             else {
[08:29:03.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.119]             }
[08:29:03.119]             {
[08:29:03.119]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.119]                   0L) {
[08:29:03.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.119]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.119]                   base::options(opts)
[08:29:03.119]                 }
[08:29:03.119]                 {
[08:29:03.119]                   {
[08:29:03.119]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.119]                     NULL
[08:29:03.119]                   }
[08:29:03.119]                   options(future.plan = NULL)
[08:29:03.119]                   if (is.na(NA_character_)) 
[08:29:03.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.119]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.119]                     .init = FALSE)
[08:29:03.119]                 }
[08:29:03.119]             }
[08:29:03.119]         }
[08:29:03.119]     })
[08:29:03.119]     if (TRUE) {
[08:29:03.119]         base::sink(type = "output", split = FALSE)
[08:29:03.119]         if (TRUE) {
[08:29:03.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.119]         }
[08:29:03.119]         else {
[08:29:03.119]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.119]         }
[08:29:03.119]         base::close(...future.stdout)
[08:29:03.119]         ...future.stdout <- NULL
[08:29:03.119]     }
[08:29:03.119]     ...future.result$conditions <- ...future.conditions
[08:29:03.119]     ...future.result$finished <- base::Sys.time()
[08:29:03.119]     ...future.result
[08:29:03.119] }
[08:29:03.122] requestCore(): workers = 2
[08:29:03.127] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.137] result() for MulticoreFuture ...
[08:29:03.139] result() for MulticoreFuture ...
[08:29:03.139] result() for MulticoreFuture ... done
[08:29:03.140] result() for MulticoreFuture ... done
[08:29:03.140] result() for MulticoreFuture ...
[08:29:03.141] result() for MulticoreFuture ... done
[08:29:03.143] MulticoreFuture started
[08:29:03.144] - Launch lazy future ... done
[08:29:03.144] run() for ‘MulticoreFuture’ ... done
[08:29:03.145] plan(): Setting new future strategy stack:
[08:29:03.146] getGlobalsAndPackages() ...
[08:29:03.145] List of future strategies:
[08:29:03.145] 1. sequential:
[08:29:03.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.145]    - tweaked: FALSE
[08:29:03.145]    - call: NULL
[08:29:03.146] Searching for globals...
[08:29:03.146] plan(): nbrOfWorkers() = 1
[08:29:03.148] - globals found: [1] ‘{’
[08:29:03.148] Searching for globals ... DONE
[08:29:03.148] Resolving globals: FALSE
[08:29:03.149] plan(): Setting new future strategy stack:
[08:29:03.149] 
[08:29:03.149] 
[08:29:03.149] getGlobalsAndPackages() ... DONE
[08:29:03.149] List of future strategies:
[08:29:03.149] 1. multicore:
[08:29:03.149]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.149]    - tweaked: FALSE
[08:29:03.149]    - call: plan(strategy)
[08:29:03.150] run() for ‘Future’ ...
[08:29:03.150] - state: ‘created’
[08:29:03.150] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.152] plan(): nbrOfWorkers() = 2
[08:29:03.153] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.153] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.154]   - Field: ‘label’
[08:29:03.154]   - Field: ‘local’
[08:29:03.154]   - Field: ‘owner’
[08:29:03.154]   - Field: ‘envir’
[08:29:03.154]   - Field: ‘workers’
[08:29:03.154]   - Field: ‘packages’
[08:29:03.155]   - Field: ‘gc’
[08:29:03.155]   - Field: ‘job’
[08:29:03.155]   - Field: ‘conditions’
[08:29:03.155]   - Field: ‘expr’
[08:29:03.155]   - Field: ‘uuid’
[08:29:03.155]   - Field: ‘seed’
[08:29:03.156]   - Field: ‘version’
[08:29:03.156]   - Field: ‘result’
[08:29:03.156]   - Field: ‘asynchronous’
[08:29:03.156]   - Field: ‘calls’
[08:29:03.156]   - Field: ‘globals’
[08:29:03.156]   - Field: ‘stdout’
[08:29:03.156]   - Field: ‘earlySignal’
[08:29:03.157]   - Field: ‘lazy’
[08:29:03.157]   - Field: ‘state’
[08:29:03.157] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.157] - Launch lazy future ...
[08:29:03.157] Packages needed by the future expression (n = 0): <none>
[08:29:03.158] Packages needed by future strategies (n = 0): <none>
[08:29:03.158] {
[08:29:03.158]     {
[08:29:03.158]         {
[08:29:03.158]             ...future.startTime <- base::Sys.time()
[08:29:03.158]             {
[08:29:03.158]                 {
[08:29:03.158]                   {
[08:29:03.158]                     {
[08:29:03.158]                       base::local({
[08:29:03.158]                         has_future <- base::requireNamespace("future", 
[08:29:03.158]                           quietly = TRUE)
[08:29:03.158]                         if (has_future) {
[08:29:03.158]                           ns <- base::getNamespace("future")
[08:29:03.158]                           version <- ns[[".package"]][["version"]]
[08:29:03.158]                           if (is.null(version)) 
[08:29:03.158]                             version <- utils::packageVersion("future")
[08:29:03.158]                         }
[08:29:03.158]                         else {
[08:29:03.158]                           version <- NULL
[08:29:03.158]                         }
[08:29:03.158]                         if (!has_future || version < "1.8.0") {
[08:29:03.158]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.158]                             "", base::R.version$version.string), 
[08:29:03.158]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.158]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.158]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.158]                               "release", "version")], collapse = " "), 
[08:29:03.158]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.158]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.158]                             info)
[08:29:03.158]                           info <- base::paste(info, collapse = "; ")
[08:29:03.158]                           if (!has_future) {
[08:29:03.158]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.158]                               info)
[08:29:03.158]                           }
[08:29:03.158]                           else {
[08:29:03.158]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.158]                               info, version)
[08:29:03.158]                           }
[08:29:03.158]                           base::stop(msg)
[08:29:03.158]                         }
[08:29:03.158]                       })
[08:29:03.158]                     }
[08:29:03.158]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.158]                     base::options(mc.cores = 1L)
[08:29:03.158]                   }
[08:29:03.158]                   ...future.strategy.old <- future::plan("list")
[08:29:03.158]                   options(future.plan = NULL)
[08:29:03.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.158]                 }
[08:29:03.158]                 ...future.workdir <- getwd()
[08:29:03.158]             }
[08:29:03.158]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.158]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.158]         }
[08:29:03.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.158]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.158]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.158]             base::names(...future.oldOptions))
[08:29:03.158]     }
[08:29:03.158]     if (FALSE) {
[08:29:03.158]     }
[08:29:03.158]     else {
[08:29:03.158]         if (TRUE) {
[08:29:03.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.158]                 open = "w")
[08:29:03.158]         }
[08:29:03.158]         else {
[08:29:03.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.158]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.158]         }
[08:29:03.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.158]             base::sink(type = "output", split = FALSE)
[08:29:03.158]             base::close(...future.stdout)
[08:29:03.158]         }, add = TRUE)
[08:29:03.158]     }
[08:29:03.158]     ...future.frame <- base::sys.nframe()
[08:29:03.158]     ...future.conditions <- base::list()
[08:29:03.158]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.158]     if (FALSE) {
[08:29:03.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.158]     }
[08:29:03.158]     ...future.result <- base::tryCatch({
[08:29:03.158]         base::withCallingHandlers({
[08:29:03.158]             ...future.value <- base::withVisible(base::local({
[08:29:03.158]                 withCallingHandlers({
[08:29:03.158]                   {
[08:29:03.158]                     2
[08:29:03.158]                   }
[08:29:03.158]                 }, immediateCondition = function(cond) {
[08:29:03.158]                   save_rds <- function (object, pathname, ...) 
[08:29:03.158]                   {
[08:29:03.158]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.158]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.158]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.158]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.158]                         fi_tmp[["mtime"]])
[08:29:03.158]                     }
[08:29:03.158]                     tryCatch({
[08:29:03.158]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.158]                     }, error = function(ex) {
[08:29:03.158]                       msg <- conditionMessage(ex)
[08:29:03.158]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.158]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.158]                         fi_tmp[["mtime"]], msg)
[08:29:03.158]                       ex$message <- msg
[08:29:03.158]                       stop(ex)
[08:29:03.158]                     })
[08:29:03.158]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.158]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.158]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.158]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.158]                       fi <- file.info(pathname)
[08:29:03.158]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.158]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.158]                         fi[["size"]], fi[["mtime"]])
[08:29:03.158]                       stop(msg)
[08:29:03.158]                     }
[08:29:03.158]                     invisible(pathname)
[08:29:03.158]                   }
[08:29:03.158]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.158]                     rootPath = tempdir()) 
[08:29:03.158]                   {
[08:29:03.158]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.158]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.158]                       tmpdir = path, fileext = ".rds")
[08:29:03.158]                     save_rds(obj, file)
[08:29:03.158]                   }
[08:29:03.158]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.158]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.158]                   {
[08:29:03.158]                     inherits <- base::inherits
[08:29:03.158]                     invokeRestart <- base::invokeRestart
[08:29:03.158]                     is.null <- base::is.null
[08:29:03.158]                     muffled <- FALSE
[08:29:03.158]                     if (inherits(cond, "message")) {
[08:29:03.158]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.158]                       if (muffled) 
[08:29:03.158]                         invokeRestart("muffleMessage")
[08:29:03.158]                     }
[08:29:03.158]                     else if (inherits(cond, "warning")) {
[08:29:03.158]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.158]                       if (muffled) 
[08:29:03.158]                         invokeRestart("muffleWarning")
[08:29:03.158]                     }
[08:29:03.158]                     else if (inherits(cond, "condition")) {
[08:29:03.158]                       if (!is.null(pattern)) {
[08:29:03.158]                         computeRestarts <- base::computeRestarts
[08:29:03.158]                         grepl <- base::grepl
[08:29:03.158]                         restarts <- computeRestarts(cond)
[08:29:03.158]                         for (restart in restarts) {
[08:29:03.158]                           name <- restart$name
[08:29:03.158]                           if (is.null(name)) 
[08:29:03.158]                             next
[08:29:03.158]                           if (!grepl(pattern, name)) 
[08:29:03.158]                             next
[08:29:03.158]                           invokeRestart(restart)
[08:29:03.158]                           muffled <- TRUE
[08:29:03.158]                           break
[08:29:03.158]                         }
[08:29:03.158]                       }
[08:29:03.158]                     }
[08:29:03.158]                     invisible(muffled)
[08:29:03.158]                   }
[08:29:03.158]                   muffleCondition(cond)
[08:29:03.158]                 })
[08:29:03.158]             }))
[08:29:03.158]             future::FutureResult(value = ...future.value$value, 
[08:29:03.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.158]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.158]                     ...future.globalenv.names))
[08:29:03.158]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.158]         }, condition = base::local({
[08:29:03.158]             c <- base::c
[08:29:03.158]             inherits <- base::inherits
[08:29:03.158]             invokeRestart <- base::invokeRestart
[08:29:03.158]             length <- base::length
[08:29:03.158]             list <- base::list
[08:29:03.158]             seq.int <- base::seq.int
[08:29:03.158]             signalCondition <- base::signalCondition
[08:29:03.158]             sys.calls <- base::sys.calls
[08:29:03.158]             `[[` <- base::`[[`
[08:29:03.158]             `+` <- base::`+`
[08:29:03.158]             `<<-` <- base::`<<-`
[08:29:03.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.158]                   3L)]
[08:29:03.158]             }
[08:29:03.158]             function(cond) {
[08:29:03.158]                 is_error <- inherits(cond, "error")
[08:29:03.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.158]                   NULL)
[08:29:03.158]                 if (is_error) {
[08:29:03.158]                   sessionInformation <- function() {
[08:29:03.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.158]                       search = base::search(), system = base::Sys.info())
[08:29:03.158]                   }
[08:29:03.158]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.158]                     cond$call), session = sessionInformation(), 
[08:29:03.158]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.158]                   signalCondition(cond)
[08:29:03.158]                 }
[08:29:03.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.158]                 "immediateCondition"))) {
[08:29:03.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.158]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.158]                   if (TRUE && !signal) {
[08:29:03.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.158]                     {
[08:29:03.158]                       inherits <- base::inherits
[08:29:03.158]                       invokeRestart <- base::invokeRestart
[08:29:03.158]                       is.null <- base::is.null
[08:29:03.158]                       muffled <- FALSE
[08:29:03.158]                       if (inherits(cond, "message")) {
[08:29:03.158]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.158]                         if (muffled) 
[08:29:03.158]                           invokeRestart("muffleMessage")
[08:29:03.158]                       }
[08:29:03.158]                       else if (inherits(cond, "warning")) {
[08:29:03.158]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.158]                         if (muffled) 
[08:29:03.158]                           invokeRestart("muffleWarning")
[08:29:03.158]                       }
[08:29:03.158]                       else if (inherits(cond, "condition")) {
[08:29:03.158]                         if (!is.null(pattern)) {
[08:29:03.158]                           computeRestarts <- base::computeRestarts
[08:29:03.158]                           grepl <- base::grepl
[08:29:03.158]                           restarts <- computeRestarts(cond)
[08:29:03.158]                           for (restart in restarts) {
[08:29:03.158]                             name <- restart$name
[08:29:03.158]                             if (is.null(name)) 
[08:29:03.158]                               next
[08:29:03.158]                             if (!grepl(pattern, name)) 
[08:29:03.158]                               next
[08:29:03.158]                             invokeRestart(restart)
[08:29:03.158]                             muffled <- TRUE
[08:29:03.158]                             break
[08:29:03.158]                           }
[08:29:03.158]                         }
[08:29:03.158]                       }
[08:29:03.158]                       invisible(muffled)
[08:29:03.158]                     }
[08:29:03.158]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.158]                   }
[08:29:03.158]                 }
[08:29:03.158]                 else {
[08:29:03.158]                   if (TRUE) {
[08:29:03.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.158]                     {
[08:29:03.158]                       inherits <- base::inherits
[08:29:03.158]                       invokeRestart <- base::invokeRestart
[08:29:03.158]                       is.null <- base::is.null
[08:29:03.158]                       muffled <- FALSE
[08:29:03.158]                       if (inherits(cond, "message")) {
[08:29:03.158]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.158]                         if (muffled) 
[08:29:03.158]                           invokeRestart("muffleMessage")
[08:29:03.158]                       }
[08:29:03.158]                       else if (inherits(cond, "warning")) {
[08:29:03.158]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.158]                         if (muffled) 
[08:29:03.158]                           invokeRestart("muffleWarning")
[08:29:03.158]                       }
[08:29:03.158]                       else if (inherits(cond, "condition")) {
[08:29:03.158]                         if (!is.null(pattern)) {
[08:29:03.158]                           computeRestarts <- base::computeRestarts
[08:29:03.158]                           grepl <- base::grepl
[08:29:03.158]                           restarts <- computeRestarts(cond)
[08:29:03.158]                           for (restart in restarts) {
[08:29:03.158]                             name <- restart$name
[08:29:03.158]                             if (is.null(name)) 
[08:29:03.158]                               next
[08:29:03.158]                             if (!grepl(pattern, name)) 
[08:29:03.158]                               next
[08:29:03.158]                             invokeRestart(restart)
[08:29:03.158]                             muffled <- TRUE
[08:29:03.158]                             break
[08:29:03.158]                           }
[08:29:03.158]                         }
[08:29:03.158]                       }
[08:29:03.158]                       invisible(muffled)
[08:29:03.158]                     }
[08:29:03.158]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.158]                   }
[08:29:03.158]                 }
[08:29:03.158]             }
[08:29:03.158]         }))
[08:29:03.158]     }, error = function(ex) {
[08:29:03.158]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.158]                 ...future.rng), started = ...future.startTime, 
[08:29:03.158]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.158]             version = "1.8"), class = "FutureResult")
[08:29:03.158]     }, finally = {
[08:29:03.158]         if (!identical(...future.workdir, getwd())) 
[08:29:03.158]             setwd(...future.workdir)
[08:29:03.158]         {
[08:29:03.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.158]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.158]             }
[08:29:03.158]             base::options(...future.oldOptions)
[08:29:03.158]             if (.Platform$OS.type == "windows") {
[08:29:03.158]                 old_names <- names(...future.oldEnvVars)
[08:29:03.158]                 envs <- base::Sys.getenv()
[08:29:03.158]                 names <- names(envs)
[08:29:03.158]                 common <- intersect(names, old_names)
[08:29:03.158]                 added <- setdiff(names, old_names)
[08:29:03.158]                 removed <- setdiff(old_names, names)
[08:29:03.158]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.158]                   envs[common]]
[08:29:03.158]                 NAMES <- toupper(changed)
[08:29:03.158]                 args <- list()
[08:29:03.158]                 for (kk in seq_along(NAMES)) {
[08:29:03.158]                   name <- changed[[kk]]
[08:29:03.158]                   NAME <- NAMES[[kk]]
[08:29:03.158]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.158]                     next
[08:29:03.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.158]                 }
[08:29:03.158]                 NAMES <- toupper(added)
[08:29:03.158]                 for (kk in seq_along(NAMES)) {
[08:29:03.158]                   name <- added[[kk]]
[08:29:03.158]                   NAME <- NAMES[[kk]]
[08:29:03.158]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.158]                     next
[08:29:03.158]                   args[[name]] <- ""
[08:29:03.158]                 }
[08:29:03.158]                 NAMES <- toupper(removed)
[08:29:03.158]                 for (kk in seq_along(NAMES)) {
[08:29:03.158]                   name <- removed[[kk]]
[08:29:03.158]                   NAME <- NAMES[[kk]]
[08:29:03.158]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.158]                     next
[08:29:03.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.158]                 }
[08:29:03.158]                 if (length(args) > 0) 
[08:29:03.158]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.158]             }
[08:29:03.158]             else {
[08:29:03.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.158]             }
[08:29:03.158]             {
[08:29:03.158]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.158]                   0L) {
[08:29:03.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.158]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.158]                   base::options(opts)
[08:29:03.158]                 }
[08:29:03.158]                 {
[08:29:03.158]                   {
[08:29:03.158]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.158]                     NULL
[08:29:03.158]                   }
[08:29:03.158]                   options(future.plan = NULL)
[08:29:03.158]                   if (is.na(NA_character_)) 
[08:29:03.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.158]                     .init = FALSE)
[08:29:03.158]                 }
[08:29:03.158]             }
[08:29:03.158]         }
[08:29:03.158]     })
[08:29:03.158]     if (TRUE) {
[08:29:03.158]         base::sink(type = "output", split = FALSE)
[08:29:03.158]         if (TRUE) {
[08:29:03.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.158]         }
[08:29:03.158]         else {
[08:29:03.158]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.158]         }
[08:29:03.158]         base::close(...future.stdout)
[08:29:03.158]         ...future.stdout <- NULL
[08:29:03.158]     }
[08:29:03.158]     ...future.result$conditions <- ...future.conditions
[08:29:03.158]     ...future.result$finished <- base::Sys.time()
[08:29:03.158]     ...future.result
[08:29:03.158] }
[08:29:03.162] requestCore(): workers = 2
[08:29:03.162] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.173] result() for MulticoreFuture ...
[08:29:03.174] result() for MulticoreFuture ...
[08:29:03.174] result() for MulticoreFuture ... done
[08:29:03.174] result() for MulticoreFuture ... done
[08:29:03.174] result() for MulticoreFuture ...
[08:29:03.175] result() for MulticoreFuture ... done
[08:29:03.177] MulticoreFuture started
[08:29:03.177] - Launch lazy future ... done
[08:29:03.177] run() for ‘MulticoreFuture’ ... done
[08:29:03.178] plan(): Setting new future strategy stack:
[08:29:03.178] List of future strategies:
[08:29:03.178] 1. sequential:
[08:29:03.178]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.178]    - tweaked: FALSE
[08:29:03.178]    - call: NULL
[08:29:03.180] resolve() on environment ...
[08:29:03.180]  recursive: 0
[08:29:03.180] plan(): nbrOfWorkers() = 1
[08:29:03.181]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[08:29:03.182] Future #1
[08:29:03.182]  length: 2 (resolved future 1)
[08:29:03.183] plan(): Setting new future strategy stack:
[08:29:03.183] List of future strategies:
[08:29:03.183] 1. multicore:
[08:29:03.183]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.183]    - tweaked: FALSE
[08:29:03.183]    - call: plan(strategy)
[08:29:03.186] plan(): nbrOfWorkers() = 2
[08:29:03.187] Future #2
[08:29:03.187]  length: 1 (resolved future 2)
[08:29:03.187]  length: 0 (resolved future 3)
[08:29:03.187] resolve() on environment ... DONE
[08:29:03.188] getGlobalsAndPackages() ...
[08:29:03.188] Searching for globals...
[08:29:03.189] - globals found: [1] ‘{’
[08:29:03.189] Searching for globals ... DONE
[08:29:03.189] Resolving globals: FALSE
[08:29:03.190] 
[08:29:03.190] 
[08:29:03.190] getGlobalsAndPackages() ... DONE
[08:29:03.191] run() for ‘Future’ ...
[08:29:03.191] - state: ‘created’
[08:29:03.191] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.193] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.194] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.194]   - Field: ‘label’
[08:29:03.194]   - Field: ‘local’
[08:29:03.194]   - Field: ‘owner’
[08:29:03.194]   - Field: ‘envir’
[08:29:03.194]   - Field: ‘workers’
[08:29:03.194]   - Field: ‘packages’
[08:29:03.195]   - Field: ‘gc’
[08:29:03.195]   - Field: ‘job’
[08:29:03.195]   - Field: ‘conditions’
[08:29:03.195]   - Field: ‘expr’
[08:29:03.195]   - Field: ‘uuid’
[08:29:03.195]   - Field: ‘seed’
[08:29:03.195]   - Field: ‘version’
[08:29:03.196]   - Field: ‘result’
[08:29:03.196]   - Field: ‘asynchronous’
[08:29:03.196]   - Field: ‘calls’
[08:29:03.196]   - Field: ‘globals’
[08:29:03.196]   - Field: ‘stdout’
[08:29:03.196]   - Field: ‘earlySignal’
[08:29:03.196]   - Field: ‘lazy’
[08:29:03.196]   - Field: ‘state’
[08:29:03.197] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.197] - Launch lazy future ...
[08:29:03.197] Packages needed by the future expression (n = 0): <none>
[08:29:03.197] Packages needed by future strategies (n = 0): <none>
[08:29:03.198] {
[08:29:03.198]     {
[08:29:03.198]         {
[08:29:03.198]             ...future.startTime <- base::Sys.time()
[08:29:03.198]             {
[08:29:03.198]                 {
[08:29:03.198]                   {
[08:29:03.198]                     {
[08:29:03.198]                       base::local({
[08:29:03.198]                         has_future <- base::requireNamespace("future", 
[08:29:03.198]                           quietly = TRUE)
[08:29:03.198]                         if (has_future) {
[08:29:03.198]                           ns <- base::getNamespace("future")
[08:29:03.198]                           version <- ns[[".package"]][["version"]]
[08:29:03.198]                           if (is.null(version)) 
[08:29:03.198]                             version <- utils::packageVersion("future")
[08:29:03.198]                         }
[08:29:03.198]                         else {
[08:29:03.198]                           version <- NULL
[08:29:03.198]                         }
[08:29:03.198]                         if (!has_future || version < "1.8.0") {
[08:29:03.198]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.198]                             "", base::R.version$version.string), 
[08:29:03.198]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.198]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.198]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.198]                               "release", "version")], collapse = " "), 
[08:29:03.198]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.198]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.198]                             info)
[08:29:03.198]                           info <- base::paste(info, collapse = "; ")
[08:29:03.198]                           if (!has_future) {
[08:29:03.198]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.198]                               info)
[08:29:03.198]                           }
[08:29:03.198]                           else {
[08:29:03.198]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.198]                               info, version)
[08:29:03.198]                           }
[08:29:03.198]                           base::stop(msg)
[08:29:03.198]                         }
[08:29:03.198]                       })
[08:29:03.198]                     }
[08:29:03.198]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.198]                     base::options(mc.cores = 1L)
[08:29:03.198]                   }
[08:29:03.198]                   ...future.strategy.old <- future::plan("list")
[08:29:03.198]                   options(future.plan = NULL)
[08:29:03.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.198]                 }
[08:29:03.198]                 ...future.workdir <- getwd()
[08:29:03.198]             }
[08:29:03.198]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.198]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.198]         }
[08:29:03.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.198]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.198]             base::names(...future.oldOptions))
[08:29:03.198]     }
[08:29:03.198]     if (FALSE) {
[08:29:03.198]     }
[08:29:03.198]     else {
[08:29:03.198]         if (TRUE) {
[08:29:03.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.198]                 open = "w")
[08:29:03.198]         }
[08:29:03.198]         else {
[08:29:03.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.198]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.198]         }
[08:29:03.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.198]             base::sink(type = "output", split = FALSE)
[08:29:03.198]             base::close(...future.stdout)
[08:29:03.198]         }, add = TRUE)
[08:29:03.198]     }
[08:29:03.198]     ...future.frame <- base::sys.nframe()
[08:29:03.198]     ...future.conditions <- base::list()
[08:29:03.198]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.198]     if (FALSE) {
[08:29:03.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.198]     }
[08:29:03.198]     ...future.result <- base::tryCatch({
[08:29:03.198]         base::withCallingHandlers({
[08:29:03.198]             ...future.value <- base::withVisible(base::local({
[08:29:03.198]                 withCallingHandlers({
[08:29:03.198]                   {
[08:29:03.198]                     1
[08:29:03.198]                   }
[08:29:03.198]                 }, immediateCondition = function(cond) {
[08:29:03.198]                   save_rds <- function (object, pathname, ...) 
[08:29:03.198]                   {
[08:29:03.198]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.198]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.198]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.198]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.198]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.198]                         fi_tmp[["mtime"]])
[08:29:03.198]                     }
[08:29:03.198]                     tryCatch({
[08:29:03.198]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.198]                     }, error = function(ex) {
[08:29:03.198]                       msg <- conditionMessage(ex)
[08:29:03.198]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.198]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.198]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.198]                         fi_tmp[["mtime"]], msg)
[08:29:03.198]                       ex$message <- msg
[08:29:03.198]                       stop(ex)
[08:29:03.198]                     })
[08:29:03.198]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.198]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.198]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.198]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.198]                       fi <- file.info(pathname)
[08:29:03.198]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.198]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.198]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.198]                         fi[["size"]], fi[["mtime"]])
[08:29:03.198]                       stop(msg)
[08:29:03.198]                     }
[08:29:03.198]                     invisible(pathname)
[08:29:03.198]                   }
[08:29:03.198]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.198]                     rootPath = tempdir()) 
[08:29:03.198]                   {
[08:29:03.198]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.198]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.198]                       tmpdir = path, fileext = ".rds")
[08:29:03.198]                     save_rds(obj, file)
[08:29:03.198]                   }
[08:29:03.198]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.198]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.198]                   {
[08:29:03.198]                     inherits <- base::inherits
[08:29:03.198]                     invokeRestart <- base::invokeRestart
[08:29:03.198]                     is.null <- base::is.null
[08:29:03.198]                     muffled <- FALSE
[08:29:03.198]                     if (inherits(cond, "message")) {
[08:29:03.198]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.198]                       if (muffled) 
[08:29:03.198]                         invokeRestart("muffleMessage")
[08:29:03.198]                     }
[08:29:03.198]                     else if (inherits(cond, "warning")) {
[08:29:03.198]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.198]                       if (muffled) 
[08:29:03.198]                         invokeRestart("muffleWarning")
[08:29:03.198]                     }
[08:29:03.198]                     else if (inherits(cond, "condition")) {
[08:29:03.198]                       if (!is.null(pattern)) {
[08:29:03.198]                         computeRestarts <- base::computeRestarts
[08:29:03.198]                         grepl <- base::grepl
[08:29:03.198]                         restarts <- computeRestarts(cond)
[08:29:03.198]                         for (restart in restarts) {
[08:29:03.198]                           name <- restart$name
[08:29:03.198]                           if (is.null(name)) 
[08:29:03.198]                             next
[08:29:03.198]                           if (!grepl(pattern, name)) 
[08:29:03.198]                             next
[08:29:03.198]                           invokeRestart(restart)
[08:29:03.198]                           muffled <- TRUE
[08:29:03.198]                           break
[08:29:03.198]                         }
[08:29:03.198]                       }
[08:29:03.198]                     }
[08:29:03.198]                     invisible(muffled)
[08:29:03.198]                   }
[08:29:03.198]                   muffleCondition(cond)
[08:29:03.198]                 })
[08:29:03.198]             }))
[08:29:03.198]             future::FutureResult(value = ...future.value$value, 
[08:29:03.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.198]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.198]                     ...future.globalenv.names))
[08:29:03.198]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.198]         }, condition = base::local({
[08:29:03.198]             c <- base::c
[08:29:03.198]             inherits <- base::inherits
[08:29:03.198]             invokeRestart <- base::invokeRestart
[08:29:03.198]             length <- base::length
[08:29:03.198]             list <- base::list
[08:29:03.198]             seq.int <- base::seq.int
[08:29:03.198]             signalCondition <- base::signalCondition
[08:29:03.198]             sys.calls <- base::sys.calls
[08:29:03.198]             `[[` <- base::`[[`
[08:29:03.198]             `+` <- base::`+`
[08:29:03.198]             `<<-` <- base::`<<-`
[08:29:03.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.198]                   3L)]
[08:29:03.198]             }
[08:29:03.198]             function(cond) {
[08:29:03.198]                 is_error <- inherits(cond, "error")
[08:29:03.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.198]                   NULL)
[08:29:03.198]                 if (is_error) {
[08:29:03.198]                   sessionInformation <- function() {
[08:29:03.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.198]                       search = base::search(), system = base::Sys.info())
[08:29:03.198]                   }
[08:29:03.198]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.198]                     cond$call), session = sessionInformation(), 
[08:29:03.198]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.198]                   signalCondition(cond)
[08:29:03.198]                 }
[08:29:03.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.198]                 "immediateCondition"))) {
[08:29:03.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.198]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.198]                   if (TRUE && !signal) {
[08:29:03.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.198]                     {
[08:29:03.198]                       inherits <- base::inherits
[08:29:03.198]                       invokeRestart <- base::invokeRestart
[08:29:03.198]                       is.null <- base::is.null
[08:29:03.198]                       muffled <- FALSE
[08:29:03.198]                       if (inherits(cond, "message")) {
[08:29:03.198]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.198]                         if (muffled) 
[08:29:03.198]                           invokeRestart("muffleMessage")
[08:29:03.198]                       }
[08:29:03.198]                       else if (inherits(cond, "warning")) {
[08:29:03.198]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.198]                         if (muffled) 
[08:29:03.198]                           invokeRestart("muffleWarning")
[08:29:03.198]                       }
[08:29:03.198]                       else if (inherits(cond, "condition")) {
[08:29:03.198]                         if (!is.null(pattern)) {
[08:29:03.198]                           computeRestarts <- base::computeRestarts
[08:29:03.198]                           grepl <- base::grepl
[08:29:03.198]                           restarts <- computeRestarts(cond)
[08:29:03.198]                           for (restart in restarts) {
[08:29:03.198]                             name <- restart$name
[08:29:03.198]                             if (is.null(name)) 
[08:29:03.198]                               next
[08:29:03.198]                             if (!grepl(pattern, name)) 
[08:29:03.198]                               next
[08:29:03.198]                             invokeRestart(restart)
[08:29:03.198]                             muffled <- TRUE
[08:29:03.198]                             break
[08:29:03.198]                           }
[08:29:03.198]                         }
[08:29:03.198]                       }
[08:29:03.198]                       invisible(muffled)
[08:29:03.198]                     }
[08:29:03.198]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.198]                   }
[08:29:03.198]                 }
[08:29:03.198]                 else {
[08:29:03.198]                   if (TRUE) {
[08:29:03.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.198]                     {
[08:29:03.198]                       inherits <- base::inherits
[08:29:03.198]                       invokeRestart <- base::invokeRestart
[08:29:03.198]                       is.null <- base::is.null
[08:29:03.198]                       muffled <- FALSE
[08:29:03.198]                       if (inherits(cond, "message")) {
[08:29:03.198]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.198]                         if (muffled) 
[08:29:03.198]                           invokeRestart("muffleMessage")
[08:29:03.198]                       }
[08:29:03.198]                       else if (inherits(cond, "warning")) {
[08:29:03.198]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.198]                         if (muffled) 
[08:29:03.198]                           invokeRestart("muffleWarning")
[08:29:03.198]                       }
[08:29:03.198]                       else if (inherits(cond, "condition")) {
[08:29:03.198]                         if (!is.null(pattern)) {
[08:29:03.198]                           computeRestarts <- base::computeRestarts
[08:29:03.198]                           grepl <- base::grepl
[08:29:03.198]                           restarts <- computeRestarts(cond)
[08:29:03.198]                           for (restart in restarts) {
[08:29:03.198]                             name <- restart$name
[08:29:03.198]                             if (is.null(name)) 
[08:29:03.198]                               next
[08:29:03.198]                             if (!grepl(pattern, name)) 
[08:29:03.198]                               next
[08:29:03.198]                             invokeRestart(restart)
[08:29:03.198]                             muffled <- TRUE
[08:29:03.198]                             break
[08:29:03.198]                           }
[08:29:03.198]                         }
[08:29:03.198]                       }
[08:29:03.198]                       invisible(muffled)
[08:29:03.198]                     }
[08:29:03.198]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.198]                   }
[08:29:03.198]                 }
[08:29:03.198]             }
[08:29:03.198]         }))
[08:29:03.198]     }, error = function(ex) {
[08:29:03.198]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.198]                 ...future.rng), started = ...future.startTime, 
[08:29:03.198]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.198]             version = "1.8"), class = "FutureResult")
[08:29:03.198]     }, finally = {
[08:29:03.198]         if (!identical(...future.workdir, getwd())) 
[08:29:03.198]             setwd(...future.workdir)
[08:29:03.198]         {
[08:29:03.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.198]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.198]             }
[08:29:03.198]             base::options(...future.oldOptions)
[08:29:03.198]             if (.Platform$OS.type == "windows") {
[08:29:03.198]                 old_names <- names(...future.oldEnvVars)
[08:29:03.198]                 envs <- base::Sys.getenv()
[08:29:03.198]                 names <- names(envs)
[08:29:03.198]                 common <- intersect(names, old_names)
[08:29:03.198]                 added <- setdiff(names, old_names)
[08:29:03.198]                 removed <- setdiff(old_names, names)
[08:29:03.198]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.198]                   envs[common]]
[08:29:03.198]                 NAMES <- toupper(changed)
[08:29:03.198]                 args <- list()
[08:29:03.198]                 for (kk in seq_along(NAMES)) {
[08:29:03.198]                   name <- changed[[kk]]
[08:29:03.198]                   NAME <- NAMES[[kk]]
[08:29:03.198]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.198]                     next
[08:29:03.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.198]                 }
[08:29:03.198]                 NAMES <- toupper(added)
[08:29:03.198]                 for (kk in seq_along(NAMES)) {
[08:29:03.198]                   name <- added[[kk]]
[08:29:03.198]                   NAME <- NAMES[[kk]]
[08:29:03.198]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.198]                     next
[08:29:03.198]                   args[[name]] <- ""
[08:29:03.198]                 }
[08:29:03.198]                 NAMES <- toupper(removed)
[08:29:03.198]                 for (kk in seq_along(NAMES)) {
[08:29:03.198]                   name <- removed[[kk]]
[08:29:03.198]                   NAME <- NAMES[[kk]]
[08:29:03.198]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.198]                     next
[08:29:03.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.198]                 }
[08:29:03.198]                 if (length(args) > 0) 
[08:29:03.198]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.198]             }
[08:29:03.198]             else {
[08:29:03.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.198]             }
[08:29:03.198]             {
[08:29:03.198]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.198]                   0L) {
[08:29:03.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.198]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.198]                   base::options(opts)
[08:29:03.198]                 }
[08:29:03.198]                 {
[08:29:03.198]                   {
[08:29:03.198]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.198]                     NULL
[08:29:03.198]                   }
[08:29:03.198]                   options(future.plan = NULL)
[08:29:03.198]                   if (is.na(NA_character_)) 
[08:29:03.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.198]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.198]                     .init = FALSE)
[08:29:03.198]                 }
[08:29:03.198]             }
[08:29:03.198]         }
[08:29:03.198]     })
[08:29:03.198]     if (TRUE) {
[08:29:03.198]         base::sink(type = "output", split = FALSE)
[08:29:03.198]         if (TRUE) {
[08:29:03.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.198]         }
[08:29:03.198]         else {
[08:29:03.198]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.198]         }
[08:29:03.198]         base::close(...future.stdout)
[08:29:03.198]         ...future.stdout <- NULL
[08:29:03.198]     }
[08:29:03.198]     ...future.result$conditions <- ...future.conditions
[08:29:03.198]     ...future.result$finished <- base::Sys.time()
[08:29:03.198]     ...future.result
[08:29:03.198] }
[08:29:03.201] requestCore(): workers = 2
[08:29:03.202] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.212] result() for MulticoreFuture ...
[08:29:03.213] result() for MulticoreFuture ...
[08:29:03.213] result() for MulticoreFuture ... done
[08:29:03.213] result() for MulticoreFuture ... done
[08:29:03.214] result() for MulticoreFuture ...
[08:29:03.214] result() for MulticoreFuture ... done
[08:29:03.216] MulticoreFuture started
[08:29:03.216] - Launch lazy future ... done
[08:29:03.216] run() for ‘MulticoreFuture’ ... done
[08:29:03.217] plan(): Setting new future strategy stack:
[08:29:03.218] getGlobalsAndPackages() ...
[08:29:03.218] Searching for globals...
[08:29:03.217] List of future strategies:
[08:29:03.217] 1. sequential:
[08:29:03.217]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.217]    - tweaked: FALSE
[08:29:03.217]    - call: NULL
[08:29:03.219] plan(): nbrOfWorkers() = 1
[08:29:03.220] - globals found: [1] ‘{’
[08:29:03.220] Searching for globals ... DONE
[08:29:03.220] Resolving globals: FALSE
[08:29:03.221] 
[08:29:03.221] 
[08:29:03.221] getGlobalsAndPackages() ... DONE
[08:29:03.222] plan(): Setting new future strategy stack:
[08:29:03.222] run() for ‘Future’ ...
[08:29:03.222] List of future strategies:
[08:29:03.222] 1. multicore:
[08:29:03.222]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.222]    - tweaked: FALSE
[08:29:03.222]    - call: plan(strategy)
[08:29:03.222] - state: ‘created’
[08:29:03.229] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.231] plan(): nbrOfWorkers() = 2
[08:29:03.234] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.234] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.235]   - Field: ‘label’
[08:29:03.235]   - Field: ‘local’
[08:29:03.235]   - Field: ‘owner’
[08:29:03.235]   - Field: ‘envir’
[08:29:03.235]   - Field: ‘workers’
[08:29:03.235]   - Field: ‘packages’
[08:29:03.236]   - Field: ‘gc’
[08:29:03.236]   - Field: ‘job’
[08:29:03.236]   - Field: ‘conditions’
[08:29:03.236]   - Field: ‘expr’
[08:29:03.236]   - Field: ‘uuid’
[08:29:03.236]   - Field: ‘seed’
[08:29:03.237]   - Field: ‘version’
[08:29:03.237]   - Field: ‘result’
[08:29:03.237]   - Field: ‘asynchronous’
[08:29:03.237]   - Field: ‘calls’
[08:29:03.237]   - Field: ‘globals’
[08:29:03.238]   - Field: ‘stdout’
[08:29:03.238]   - Field: ‘earlySignal’
[08:29:03.238]   - Field: ‘lazy’
[08:29:03.238]   - Field: ‘state’
[08:29:03.238] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.239] - Launch lazy future ...
[08:29:03.239] Packages needed by the future expression (n = 0): <none>
[08:29:03.239] Packages needed by future strategies (n = 0): <none>
[08:29:03.240] {
[08:29:03.240]     {
[08:29:03.240]         {
[08:29:03.240]             ...future.startTime <- base::Sys.time()
[08:29:03.240]             {
[08:29:03.240]                 {
[08:29:03.240]                   {
[08:29:03.240]                     {
[08:29:03.240]                       base::local({
[08:29:03.240]                         has_future <- base::requireNamespace("future", 
[08:29:03.240]                           quietly = TRUE)
[08:29:03.240]                         if (has_future) {
[08:29:03.240]                           ns <- base::getNamespace("future")
[08:29:03.240]                           version <- ns[[".package"]][["version"]]
[08:29:03.240]                           if (is.null(version)) 
[08:29:03.240]                             version <- utils::packageVersion("future")
[08:29:03.240]                         }
[08:29:03.240]                         else {
[08:29:03.240]                           version <- NULL
[08:29:03.240]                         }
[08:29:03.240]                         if (!has_future || version < "1.8.0") {
[08:29:03.240]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.240]                             "", base::R.version$version.string), 
[08:29:03.240]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.240]                               "release", "version")], collapse = " "), 
[08:29:03.240]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.240]                             info)
[08:29:03.240]                           info <- base::paste(info, collapse = "; ")
[08:29:03.240]                           if (!has_future) {
[08:29:03.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.240]                               info)
[08:29:03.240]                           }
[08:29:03.240]                           else {
[08:29:03.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.240]                               info, version)
[08:29:03.240]                           }
[08:29:03.240]                           base::stop(msg)
[08:29:03.240]                         }
[08:29:03.240]                       })
[08:29:03.240]                     }
[08:29:03.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.240]                     base::options(mc.cores = 1L)
[08:29:03.240]                   }
[08:29:03.240]                   ...future.strategy.old <- future::plan("list")
[08:29:03.240]                   options(future.plan = NULL)
[08:29:03.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.240]                 }
[08:29:03.240]                 ...future.workdir <- getwd()
[08:29:03.240]             }
[08:29:03.240]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.240]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.240]         }
[08:29:03.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.240]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.240]             base::names(...future.oldOptions))
[08:29:03.240]     }
[08:29:03.240]     if (FALSE) {
[08:29:03.240]     }
[08:29:03.240]     else {
[08:29:03.240]         if (TRUE) {
[08:29:03.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.240]                 open = "w")
[08:29:03.240]         }
[08:29:03.240]         else {
[08:29:03.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.240]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.240]         }
[08:29:03.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.240]             base::sink(type = "output", split = FALSE)
[08:29:03.240]             base::close(...future.stdout)
[08:29:03.240]         }, add = TRUE)
[08:29:03.240]     }
[08:29:03.240]     ...future.frame <- base::sys.nframe()
[08:29:03.240]     ...future.conditions <- base::list()
[08:29:03.240]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.240]     if (FALSE) {
[08:29:03.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.240]     }
[08:29:03.240]     ...future.result <- base::tryCatch({
[08:29:03.240]         base::withCallingHandlers({
[08:29:03.240]             ...future.value <- base::withVisible(base::local({
[08:29:03.240]                 withCallingHandlers({
[08:29:03.240]                   {
[08:29:03.240]                     2
[08:29:03.240]                   }
[08:29:03.240]                 }, immediateCondition = function(cond) {
[08:29:03.240]                   save_rds <- function (object, pathname, ...) 
[08:29:03.240]                   {
[08:29:03.240]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.240]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.240]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.240]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.240]                         fi_tmp[["mtime"]])
[08:29:03.240]                     }
[08:29:03.240]                     tryCatch({
[08:29:03.240]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.240]                     }, error = function(ex) {
[08:29:03.240]                       msg <- conditionMessage(ex)
[08:29:03.240]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.240]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.240]                         fi_tmp[["mtime"]], msg)
[08:29:03.240]                       ex$message <- msg
[08:29:03.240]                       stop(ex)
[08:29:03.240]                     })
[08:29:03.240]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.240]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.240]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.240]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.240]                       fi <- file.info(pathname)
[08:29:03.240]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.240]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.240]                         fi[["size"]], fi[["mtime"]])
[08:29:03.240]                       stop(msg)
[08:29:03.240]                     }
[08:29:03.240]                     invisible(pathname)
[08:29:03.240]                   }
[08:29:03.240]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.240]                     rootPath = tempdir()) 
[08:29:03.240]                   {
[08:29:03.240]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.240]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.240]                       tmpdir = path, fileext = ".rds")
[08:29:03.240]                     save_rds(obj, file)
[08:29:03.240]                   }
[08:29:03.240]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.240]                   {
[08:29:03.240]                     inherits <- base::inherits
[08:29:03.240]                     invokeRestart <- base::invokeRestart
[08:29:03.240]                     is.null <- base::is.null
[08:29:03.240]                     muffled <- FALSE
[08:29:03.240]                     if (inherits(cond, "message")) {
[08:29:03.240]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.240]                       if (muffled) 
[08:29:03.240]                         invokeRestart("muffleMessage")
[08:29:03.240]                     }
[08:29:03.240]                     else if (inherits(cond, "warning")) {
[08:29:03.240]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.240]                       if (muffled) 
[08:29:03.240]                         invokeRestart("muffleWarning")
[08:29:03.240]                     }
[08:29:03.240]                     else if (inherits(cond, "condition")) {
[08:29:03.240]                       if (!is.null(pattern)) {
[08:29:03.240]                         computeRestarts <- base::computeRestarts
[08:29:03.240]                         grepl <- base::grepl
[08:29:03.240]                         restarts <- computeRestarts(cond)
[08:29:03.240]                         for (restart in restarts) {
[08:29:03.240]                           name <- restart$name
[08:29:03.240]                           if (is.null(name)) 
[08:29:03.240]                             next
[08:29:03.240]                           if (!grepl(pattern, name)) 
[08:29:03.240]                             next
[08:29:03.240]                           invokeRestart(restart)
[08:29:03.240]                           muffled <- TRUE
[08:29:03.240]                           break
[08:29:03.240]                         }
[08:29:03.240]                       }
[08:29:03.240]                     }
[08:29:03.240]                     invisible(muffled)
[08:29:03.240]                   }
[08:29:03.240]                   muffleCondition(cond)
[08:29:03.240]                 })
[08:29:03.240]             }))
[08:29:03.240]             future::FutureResult(value = ...future.value$value, 
[08:29:03.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.240]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.240]                     ...future.globalenv.names))
[08:29:03.240]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.240]         }, condition = base::local({
[08:29:03.240]             c <- base::c
[08:29:03.240]             inherits <- base::inherits
[08:29:03.240]             invokeRestart <- base::invokeRestart
[08:29:03.240]             length <- base::length
[08:29:03.240]             list <- base::list
[08:29:03.240]             seq.int <- base::seq.int
[08:29:03.240]             signalCondition <- base::signalCondition
[08:29:03.240]             sys.calls <- base::sys.calls
[08:29:03.240]             `[[` <- base::`[[`
[08:29:03.240]             `+` <- base::`+`
[08:29:03.240]             `<<-` <- base::`<<-`
[08:29:03.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.240]                   3L)]
[08:29:03.240]             }
[08:29:03.240]             function(cond) {
[08:29:03.240]                 is_error <- inherits(cond, "error")
[08:29:03.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.240]                   NULL)
[08:29:03.240]                 if (is_error) {
[08:29:03.240]                   sessionInformation <- function() {
[08:29:03.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.240]                       search = base::search(), system = base::Sys.info())
[08:29:03.240]                   }
[08:29:03.240]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.240]                     cond$call), session = sessionInformation(), 
[08:29:03.240]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.240]                   signalCondition(cond)
[08:29:03.240]                 }
[08:29:03.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.240]                 "immediateCondition"))) {
[08:29:03.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.240]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.240]                   if (TRUE && !signal) {
[08:29:03.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.240]                     {
[08:29:03.240]                       inherits <- base::inherits
[08:29:03.240]                       invokeRestart <- base::invokeRestart
[08:29:03.240]                       is.null <- base::is.null
[08:29:03.240]                       muffled <- FALSE
[08:29:03.240]                       if (inherits(cond, "message")) {
[08:29:03.240]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.240]                         if (muffled) 
[08:29:03.240]                           invokeRestart("muffleMessage")
[08:29:03.240]                       }
[08:29:03.240]                       else if (inherits(cond, "warning")) {
[08:29:03.240]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.240]                         if (muffled) 
[08:29:03.240]                           invokeRestart("muffleWarning")
[08:29:03.240]                       }
[08:29:03.240]                       else if (inherits(cond, "condition")) {
[08:29:03.240]                         if (!is.null(pattern)) {
[08:29:03.240]                           computeRestarts <- base::computeRestarts
[08:29:03.240]                           grepl <- base::grepl
[08:29:03.240]                           restarts <- computeRestarts(cond)
[08:29:03.240]                           for (restart in restarts) {
[08:29:03.240]                             name <- restart$name
[08:29:03.240]                             if (is.null(name)) 
[08:29:03.240]                               next
[08:29:03.240]                             if (!grepl(pattern, name)) 
[08:29:03.240]                               next
[08:29:03.240]                             invokeRestart(restart)
[08:29:03.240]                             muffled <- TRUE
[08:29:03.240]                             break
[08:29:03.240]                           }
[08:29:03.240]                         }
[08:29:03.240]                       }
[08:29:03.240]                       invisible(muffled)
[08:29:03.240]                     }
[08:29:03.240]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.240]                   }
[08:29:03.240]                 }
[08:29:03.240]                 else {
[08:29:03.240]                   if (TRUE) {
[08:29:03.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.240]                     {
[08:29:03.240]                       inherits <- base::inherits
[08:29:03.240]                       invokeRestart <- base::invokeRestart
[08:29:03.240]                       is.null <- base::is.null
[08:29:03.240]                       muffled <- FALSE
[08:29:03.240]                       if (inherits(cond, "message")) {
[08:29:03.240]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.240]                         if (muffled) 
[08:29:03.240]                           invokeRestart("muffleMessage")
[08:29:03.240]                       }
[08:29:03.240]                       else if (inherits(cond, "warning")) {
[08:29:03.240]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.240]                         if (muffled) 
[08:29:03.240]                           invokeRestart("muffleWarning")
[08:29:03.240]                       }
[08:29:03.240]                       else if (inherits(cond, "condition")) {
[08:29:03.240]                         if (!is.null(pattern)) {
[08:29:03.240]                           computeRestarts <- base::computeRestarts
[08:29:03.240]                           grepl <- base::grepl
[08:29:03.240]                           restarts <- computeRestarts(cond)
[08:29:03.240]                           for (restart in restarts) {
[08:29:03.240]                             name <- restart$name
[08:29:03.240]                             if (is.null(name)) 
[08:29:03.240]                               next
[08:29:03.240]                             if (!grepl(pattern, name)) 
[08:29:03.240]                               next
[08:29:03.240]                             invokeRestart(restart)
[08:29:03.240]                             muffled <- TRUE
[08:29:03.240]                             break
[08:29:03.240]                           }
[08:29:03.240]                         }
[08:29:03.240]                       }
[08:29:03.240]                       invisible(muffled)
[08:29:03.240]                     }
[08:29:03.240]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.240]                   }
[08:29:03.240]                 }
[08:29:03.240]             }
[08:29:03.240]         }))
[08:29:03.240]     }, error = function(ex) {
[08:29:03.240]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.240]                 ...future.rng), started = ...future.startTime, 
[08:29:03.240]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.240]             version = "1.8"), class = "FutureResult")
[08:29:03.240]     }, finally = {
[08:29:03.240]         if (!identical(...future.workdir, getwd())) 
[08:29:03.240]             setwd(...future.workdir)
[08:29:03.240]         {
[08:29:03.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.240]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.240]             }
[08:29:03.240]             base::options(...future.oldOptions)
[08:29:03.240]             if (.Platform$OS.type == "windows") {
[08:29:03.240]                 old_names <- names(...future.oldEnvVars)
[08:29:03.240]                 envs <- base::Sys.getenv()
[08:29:03.240]                 names <- names(envs)
[08:29:03.240]                 common <- intersect(names, old_names)
[08:29:03.240]                 added <- setdiff(names, old_names)
[08:29:03.240]                 removed <- setdiff(old_names, names)
[08:29:03.240]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.240]                   envs[common]]
[08:29:03.240]                 NAMES <- toupper(changed)
[08:29:03.240]                 args <- list()
[08:29:03.240]                 for (kk in seq_along(NAMES)) {
[08:29:03.240]                   name <- changed[[kk]]
[08:29:03.240]                   NAME <- NAMES[[kk]]
[08:29:03.240]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.240]                     next
[08:29:03.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.240]                 }
[08:29:03.240]                 NAMES <- toupper(added)
[08:29:03.240]                 for (kk in seq_along(NAMES)) {
[08:29:03.240]                   name <- added[[kk]]
[08:29:03.240]                   NAME <- NAMES[[kk]]
[08:29:03.240]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.240]                     next
[08:29:03.240]                   args[[name]] <- ""
[08:29:03.240]                 }
[08:29:03.240]                 NAMES <- toupper(removed)
[08:29:03.240]                 for (kk in seq_along(NAMES)) {
[08:29:03.240]                   name <- removed[[kk]]
[08:29:03.240]                   NAME <- NAMES[[kk]]
[08:29:03.240]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.240]                     next
[08:29:03.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.240]                 }
[08:29:03.240]                 if (length(args) > 0) 
[08:29:03.240]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.240]             }
[08:29:03.240]             else {
[08:29:03.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.240]             }
[08:29:03.240]             {
[08:29:03.240]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.240]                   0L) {
[08:29:03.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.240]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.240]                   base::options(opts)
[08:29:03.240]                 }
[08:29:03.240]                 {
[08:29:03.240]                   {
[08:29:03.240]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.240]                     NULL
[08:29:03.240]                   }
[08:29:03.240]                   options(future.plan = NULL)
[08:29:03.240]                   if (is.na(NA_character_)) 
[08:29:03.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.240]                     .init = FALSE)
[08:29:03.240]                 }
[08:29:03.240]             }
[08:29:03.240]         }
[08:29:03.240]     })
[08:29:03.240]     if (TRUE) {
[08:29:03.240]         base::sink(type = "output", split = FALSE)
[08:29:03.240]         if (TRUE) {
[08:29:03.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.240]         }
[08:29:03.240]         else {
[08:29:03.240]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.240]         }
[08:29:03.240]         base::close(...future.stdout)
[08:29:03.240]         ...future.stdout <- NULL
[08:29:03.240]     }
[08:29:03.240]     ...future.result$conditions <- ...future.conditions
[08:29:03.240]     ...future.result$finished <- base::Sys.time()
[08:29:03.240]     ...future.result
[08:29:03.240] }
[08:29:03.243] requestCore(): workers = 2
[08:29:03.243] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.254] result() for MulticoreFuture ...
[08:29:03.255] result() for MulticoreFuture ...
[08:29:03.255] result() for MulticoreFuture ... done
[08:29:03.255] result() for MulticoreFuture ... done
[08:29:03.255] result() for MulticoreFuture ...
[08:29:03.255] result() for MulticoreFuture ... done
[08:29:03.258] MulticoreFuture started
[08:29:03.259] - Launch lazy future ... done
[08:29:03.259] run() for ‘MulticoreFuture’ ... done
[08:29:03.259] plan(): Setting new future strategy stack:
[08:29:03.260] List of future strategies:
[08:29:03.260] 1. sequential:
[08:29:03.260]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.260]    - tweaked: FALSE
[08:29:03.260]    - call: NULL
[08:29:03.261] resolve() on environment ...
[08:29:03.261] plan(): nbrOfWorkers() = 1
[08:29:03.261]  recursive: 0
[08:29:03.262]  elements: [3] ‘a’
[08:29:03.262] Future #1
[08:29:03.262]  length: 2 (resolved future 1)
[08:29:03.263] plan(): Setting new future strategy stack:
[08:29:03.263] List of future strategies:
[08:29:03.263] 1. multicore:
[08:29:03.263]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.263]    - tweaked: FALSE
[08:29:03.263]    - call: plan(strategy)
[08:29:03.266] plan(): nbrOfWorkers() = 2
[08:29:03.267] Future #2
[08:29:03.267]  length: 1 (resolved future 2)
[08:29:03.267]  length: 0 (resolved future 3)
[08:29:03.267] resolve() on environment ... DONE
[08:29:03.268] resolve() on environment ...
[08:29:03.268]  recursive: 0
[08:29:03.269]  elements: [3] ‘b’
[08:29:03.269] Future #1
[08:29:03.269]  length: 2 (resolved future 1)
[08:29:03.269] Future #2
[08:29:03.270]  length: 1 (resolved future 2)
[08:29:03.270]  length: 0 (resolved future 3)
[08:29:03.270] resolve() on environment ... DONE
[08:29:03.271] resolve() on environment ...
[08:29:03.271]  recursive: 0
[08:29:03.272]  elements: [3] ‘c’
[08:29:03.272] Future #1
[08:29:03.272]  length: 2 (resolved future 1)
[08:29:03.272] Future #2
[08:29:03.273]  length: 1 (resolved future 2)
[08:29:03.273]  length: 0 (resolved future 3)
[08:29:03.273] resolve() on environment ... DONE
[08:29:03.274] resolve() on environment ...
[08:29:03.274]  recursive: 0
[08:29:03.274]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[08:29:03.275] Future #1
[08:29:03.275] result() for MulticoreFuture ...
[08:29:03.276] result() for MulticoreFuture ...
[08:29:03.276] result() for MulticoreFuture ... done
[08:29:03.276] result() for MulticoreFuture ... done
[08:29:03.276] result() for MulticoreFuture ...
[08:29:03.276] result() for MulticoreFuture ... done
[08:29:03.277]  length: 2 (resolved future 1)
[08:29:03.277] Future #2
[08:29:03.277] result() for MulticoreFuture ...
[08:29:03.278] result() for MulticoreFuture ...
[08:29:03.278] result() for MulticoreFuture ... done
[08:29:03.278] result() for MulticoreFuture ... done
[08:29:03.278] result() for MulticoreFuture ...
[08:29:03.278] result() for MulticoreFuture ... done
[08:29:03.278]  length: 1 (resolved future 2)
[08:29:03.279]  length: 0 (resolved future 3)
[08:29:03.279] resolve() on environment ... DONE
[08:29:03.279] resolve() on environment ...
[08:29:03.279]  recursive: 99
[08:29:03.280]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[08:29:03.280] Future #1
[08:29:03.280] result() for MulticoreFuture ...
[08:29:03.281] result() for MulticoreFuture ... done
[08:29:03.281] result() for MulticoreFuture ...
[08:29:03.281] result() for MulticoreFuture ... done
[08:29:03.281] A MulticoreFuture was resolved
[08:29:03.281]  length: 2 (resolved future 1)
[08:29:03.281] Future #2
[08:29:03.281] result() for MulticoreFuture ...
[08:29:03.281] result() for MulticoreFuture ... done
[08:29:03.282] result() for MulticoreFuture ...
[08:29:03.282] result() for MulticoreFuture ... done
[08:29:03.282] A MulticoreFuture was resolved
[08:29:03.282]  length: 1 (resolved future 2)
[08:29:03.282]  length: 0 (resolved future 3)
[08:29:03.282] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[08:29:03.283] resolve() on list environment ...
[08:29:03.283]  recursive: 0
[08:29:03.284]  length: 2
[08:29:03.284]  elements: ‘a’, ‘b’
[08:29:03.284]  length: 1 (resolved future 1)
[08:29:03.284]  length: 0 (resolved future 2)
[08:29:03.284] resolve() on list environment ... DONE
[08:29:03.284] getGlobalsAndPackages() ...
[08:29:03.285] Searching for globals...
[08:29:03.285] 
[08:29:03.285] Searching for globals ... DONE
[08:29:03.285] - globals: [0] <none>
[08:29:03.285] getGlobalsAndPackages() ... DONE
[08:29:03.286] run() for ‘Future’ ...
[08:29:03.286] - state: ‘created’
[08:29:03.286] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.290] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.291]   - Field: ‘label’
[08:29:03.291]   - Field: ‘local’
[08:29:03.291]   - Field: ‘owner’
[08:29:03.291]   - Field: ‘envir’
[08:29:03.291]   - Field: ‘workers’
[08:29:03.292]   - Field: ‘packages’
[08:29:03.292]   - Field: ‘gc’
[08:29:03.292]   - Field: ‘job’
[08:29:03.292]   - Field: ‘conditions’
[08:29:03.292]   - Field: ‘expr’
[08:29:03.292]   - Field: ‘uuid’
[08:29:03.292]   - Field: ‘seed’
[08:29:03.293]   - Field: ‘version’
[08:29:03.293]   - Field: ‘result’
[08:29:03.293]   - Field: ‘asynchronous’
[08:29:03.293]   - Field: ‘calls’
[08:29:03.293]   - Field: ‘globals’
[08:29:03.293]   - Field: ‘stdout’
[08:29:03.293]   - Field: ‘earlySignal’
[08:29:03.293]   - Field: ‘lazy’
[08:29:03.294]   - Field: ‘state’
[08:29:03.294] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.294] - Launch lazy future ...
[08:29:03.294] Packages needed by the future expression (n = 0): <none>
[08:29:03.294] Packages needed by future strategies (n = 0): <none>
[08:29:03.295] {
[08:29:03.295]     {
[08:29:03.295]         {
[08:29:03.295]             ...future.startTime <- base::Sys.time()
[08:29:03.295]             {
[08:29:03.295]                 {
[08:29:03.295]                   {
[08:29:03.295]                     {
[08:29:03.295]                       base::local({
[08:29:03.295]                         has_future <- base::requireNamespace("future", 
[08:29:03.295]                           quietly = TRUE)
[08:29:03.295]                         if (has_future) {
[08:29:03.295]                           ns <- base::getNamespace("future")
[08:29:03.295]                           version <- ns[[".package"]][["version"]]
[08:29:03.295]                           if (is.null(version)) 
[08:29:03.295]                             version <- utils::packageVersion("future")
[08:29:03.295]                         }
[08:29:03.295]                         else {
[08:29:03.295]                           version <- NULL
[08:29:03.295]                         }
[08:29:03.295]                         if (!has_future || version < "1.8.0") {
[08:29:03.295]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.295]                             "", base::R.version$version.string), 
[08:29:03.295]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.295]                               "release", "version")], collapse = " "), 
[08:29:03.295]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.295]                             info)
[08:29:03.295]                           info <- base::paste(info, collapse = "; ")
[08:29:03.295]                           if (!has_future) {
[08:29:03.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.295]                               info)
[08:29:03.295]                           }
[08:29:03.295]                           else {
[08:29:03.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.295]                               info, version)
[08:29:03.295]                           }
[08:29:03.295]                           base::stop(msg)
[08:29:03.295]                         }
[08:29:03.295]                       })
[08:29:03.295]                     }
[08:29:03.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.295]                     base::options(mc.cores = 1L)
[08:29:03.295]                   }
[08:29:03.295]                   ...future.strategy.old <- future::plan("list")
[08:29:03.295]                   options(future.plan = NULL)
[08:29:03.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.295]                 }
[08:29:03.295]                 ...future.workdir <- getwd()
[08:29:03.295]             }
[08:29:03.295]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.295]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.295]         }
[08:29:03.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.295]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.295]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.295]             base::names(...future.oldOptions))
[08:29:03.295]     }
[08:29:03.295]     if (FALSE) {
[08:29:03.295]     }
[08:29:03.295]     else {
[08:29:03.295]         if (TRUE) {
[08:29:03.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.295]                 open = "w")
[08:29:03.295]         }
[08:29:03.295]         else {
[08:29:03.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.295]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.295]         }
[08:29:03.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.295]             base::sink(type = "output", split = FALSE)
[08:29:03.295]             base::close(...future.stdout)
[08:29:03.295]         }, add = TRUE)
[08:29:03.295]     }
[08:29:03.295]     ...future.frame <- base::sys.nframe()
[08:29:03.295]     ...future.conditions <- base::list()
[08:29:03.295]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.295]     if (FALSE) {
[08:29:03.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.295]     }
[08:29:03.295]     ...future.result <- base::tryCatch({
[08:29:03.295]         base::withCallingHandlers({
[08:29:03.295]             ...future.value <- base::withVisible(base::local({
[08:29:03.295]                 withCallingHandlers({
[08:29:03.295]                   1
[08:29:03.295]                 }, immediateCondition = function(cond) {
[08:29:03.295]                   save_rds <- function (object, pathname, ...) 
[08:29:03.295]                   {
[08:29:03.295]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.295]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.295]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.295]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.295]                         fi_tmp[["mtime"]])
[08:29:03.295]                     }
[08:29:03.295]                     tryCatch({
[08:29:03.295]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.295]                     }, error = function(ex) {
[08:29:03.295]                       msg <- conditionMessage(ex)
[08:29:03.295]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.295]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.295]                         fi_tmp[["mtime"]], msg)
[08:29:03.295]                       ex$message <- msg
[08:29:03.295]                       stop(ex)
[08:29:03.295]                     })
[08:29:03.295]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.295]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.295]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.295]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.295]                       fi <- file.info(pathname)
[08:29:03.295]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.295]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.295]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.295]                         fi[["size"]], fi[["mtime"]])
[08:29:03.295]                       stop(msg)
[08:29:03.295]                     }
[08:29:03.295]                     invisible(pathname)
[08:29:03.295]                   }
[08:29:03.295]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.295]                     rootPath = tempdir()) 
[08:29:03.295]                   {
[08:29:03.295]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.295]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.295]                       tmpdir = path, fileext = ".rds")
[08:29:03.295]                     save_rds(obj, file)
[08:29:03.295]                   }
[08:29:03.295]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.295]                   {
[08:29:03.295]                     inherits <- base::inherits
[08:29:03.295]                     invokeRestart <- base::invokeRestart
[08:29:03.295]                     is.null <- base::is.null
[08:29:03.295]                     muffled <- FALSE
[08:29:03.295]                     if (inherits(cond, "message")) {
[08:29:03.295]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.295]                       if (muffled) 
[08:29:03.295]                         invokeRestart("muffleMessage")
[08:29:03.295]                     }
[08:29:03.295]                     else if (inherits(cond, "warning")) {
[08:29:03.295]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.295]                       if (muffled) 
[08:29:03.295]                         invokeRestart("muffleWarning")
[08:29:03.295]                     }
[08:29:03.295]                     else if (inherits(cond, "condition")) {
[08:29:03.295]                       if (!is.null(pattern)) {
[08:29:03.295]                         computeRestarts <- base::computeRestarts
[08:29:03.295]                         grepl <- base::grepl
[08:29:03.295]                         restarts <- computeRestarts(cond)
[08:29:03.295]                         for (restart in restarts) {
[08:29:03.295]                           name <- restart$name
[08:29:03.295]                           if (is.null(name)) 
[08:29:03.295]                             next
[08:29:03.295]                           if (!grepl(pattern, name)) 
[08:29:03.295]                             next
[08:29:03.295]                           invokeRestart(restart)
[08:29:03.295]                           muffled <- TRUE
[08:29:03.295]                           break
[08:29:03.295]                         }
[08:29:03.295]                       }
[08:29:03.295]                     }
[08:29:03.295]                     invisible(muffled)
[08:29:03.295]                   }
[08:29:03.295]                   muffleCondition(cond)
[08:29:03.295]                 })
[08:29:03.295]             }))
[08:29:03.295]             future::FutureResult(value = ...future.value$value, 
[08:29:03.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.295]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.295]                     ...future.globalenv.names))
[08:29:03.295]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.295]         }, condition = base::local({
[08:29:03.295]             c <- base::c
[08:29:03.295]             inherits <- base::inherits
[08:29:03.295]             invokeRestart <- base::invokeRestart
[08:29:03.295]             length <- base::length
[08:29:03.295]             list <- base::list
[08:29:03.295]             seq.int <- base::seq.int
[08:29:03.295]             signalCondition <- base::signalCondition
[08:29:03.295]             sys.calls <- base::sys.calls
[08:29:03.295]             `[[` <- base::`[[`
[08:29:03.295]             `+` <- base::`+`
[08:29:03.295]             `<<-` <- base::`<<-`
[08:29:03.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.295]                   3L)]
[08:29:03.295]             }
[08:29:03.295]             function(cond) {
[08:29:03.295]                 is_error <- inherits(cond, "error")
[08:29:03.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.295]                   NULL)
[08:29:03.295]                 if (is_error) {
[08:29:03.295]                   sessionInformation <- function() {
[08:29:03.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.295]                       search = base::search(), system = base::Sys.info())
[08:29:03.295]                   }
[08:29:03.295]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.295]                     cond$call), session = sessionInformation(), 
[08:29:03.295]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.295]                   signalCondition(cond)
[08:29:03.295]                 }
[08:29:03.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.295]                 "immediateCondition"))) {
[08:29:03.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.295]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.295]                   if (TRUE && !signal) {
[08:29:03.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.295]                     {
[08:29:03.295]                       inherits <- base::inherits
[08:29:03.295]                       invokeRestart <- base::invokeRestart
[08:29:03.295]                       is.null <- base::is.null
[08:29:03.295]                       muffled <- FALSE
[08:29:03.295]                       if (inherits(cond, "message")) {
[08:29:03.295]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.295]                         if (muffled) 
[08:29:03.295]                           invokeRestart("muffleMessage")
[08:29:03.295]                       }
[08:29:03.295]                       else if (inherits(cond, "warning")) {
[08:29:03.295]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.295]                         if (muffled) 
[08:29:03.295]                           invokeRestart("muffleWarning")
[08:29:03.295]                       }
[08:29:03.295]                       else if (inherits(cond, "condition")) {
[08:29:03.295]                         if (!is.null(pattern)) {
[08:29:03.295]                           computeRestarts <- base::computeRestarts
[08:29:03.295]                           grepl <- base::grepl
[08:29:03.295]                           restarts <- computeRestarts(cond)
[08:29:03.295]                           for (restart in restarts) {
[08:29:03.295]                             name <- restart$name
[08:29:03.295]                             if (is.null(name)) 
[08:29:03.295]                               next
[08:29:03.295]                             if (!grepl(pattern, name)) 
[08:29:03.295]                               next
[08:29:03.295]                             invokeRestart(restart)
[08:29:03.295]                             muffled <- TRUE
[08:29:03.295]                             break
[08:29:03.295]                           }
[08:29:03.295]                         }
[08:29:03.295]                       }
[08:29:03.295]                       invisible(muffled)
[08:29:03.295]                     }
[08:29:03.295]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.295]                   }
[08:29:03.295]                 }
[08:29:03.295]                 else {
[08:29:03.295]                   if (TRUE) {
[08:29:03.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.295]                     {
[08:29:03.295]                       inherits <- base::inherits
[08:29:03.295]                       invokeRestart <- base::invokeRestart
[08:29:03.295]                       is.null <- base::is.null
[08:29:03.295]                       muffled <- FALSE
[08:29:03.295]                       if (inherits(cond, "message")) {
[08:29:03.295]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.295]                         if (muffled) 
[08:29:03.295]                           invokeRestart("muffleMessage")
[08:29:03.295]                       }
[08:29:03.295]                       else if (inherits(cond, "warning")) {
[08:29:03.295]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.295]                         if (muffled) 
[08:29:03.295]                           invokeRestart("muffleWarning")
[08:29:03.295]                       }
[08:29:03.295]                       else if (inherits(cond, "condition")) {
[08:29:03.295]                         if (!is.null(pattern)) {
[08:29:03.295]                           computeRestarts <- base::computeRestarts
[08:29:03.295]                           grepl <- base::grepl
[08:29:03.295]                           restarts <- computeRestarts(cond)
[08:29:03.295]                           for (restart in restarts) {
[08:29:03.295]                             name <- restart$name
[08:29:03.295]                             if (is.null(name)) 
[08:29:03.295]                               next
[08:29:03.295]                             if (!grepl(pattern, name)) 
[08:29:03.295]                               next
[08:29:03.295]                             invokeRestart(restart)
[08:29:03.295]                             muffled <- TRUE
[08:29:03.295]                             break
[08:29:03.295]                           }
[08:29:03.295]                         }
[08:29:03.295]                       }
[08:29:03.295]                       invisible(muffled)
[08:29:03.295]                     }
[08:29:03.295]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.295]                   }
[08:29:03.295]                 }
[08:29:03.295]             }
[08:29:03.295]         }))
[08:29:03.295]     }, error = function(ex) {
[08:29:03.295]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.295]                 ...future.rng), started = ...future.startTime, 
[08:29:03.295]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.295]             version = "1.8"), class = "FutureResult")
[08:29:03.295]     }, finally = {
[08:29:03.295]         if (!identical(...future.workdir, getwd())) 
[08:29:03.295]             setwd(...future.workdir)
[08:29:03.295]         {
[08:29:03.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.295]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.295]             }
[08:29:03.295]             base::options(...future.oldOptions)
[08:29:03.295]             if (.Platform$OS.type == "windows") {
[08:29:03.295]                 old_names <- names(...future.oldEnvVars)
[08:29:03.295]                 envs <- base::Sys.getenv()
[08:29:03.295]                 names <- names(envs)
[08:29:03.295]                 common <- intersect(names, old_names)
[08:29:03.295]                 added <- setdiff(names, old_names)
[08:29:03.295]                 removed <- setdiff(old_names, names)
[08:29:03.295]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.295]                   envs[common]]
[08:29:03.295]                 NAMES <- toupper(changed)
[08:29:03.295]                 args <- list()
[08:29:03.295]                 for (kk in seq_along(NAMES)) {
[08:29:03.295]                   name <- changed[[kk]]
[08:29:03.295]                   NAME <- NAMES[[kk]]
[08:29:03.295]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.295]                     next
[08:29:03.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.295]                 }
[08:29:03.295]                 NAMES <- toupper(added)
[08:29:03.295]                 for (kk in seq_along(NAMES)) {
[08:29:03.295]                   name <- added[[kk]]
[08:29:03.295]                   NAME <- NAMES[[kk]]
[08:29:03.295]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.295]                     next
[08:29:03.295]                   args[[name]] <- ""
[08:29:03.295]                 }
[08:29:03.295]                 NAMES <- toupper(removed)
[08:29:03.295]                 for (kk in seq_along(NAMES)) {
[08:29:03.295]                   name <- removed[[kk]]
[08:29:03.295]                   NAME <- NAMES[[kk]]
[08:29:03.295]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.295]                     next
[08:29:03.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.295]                 }
[08:29:03.295]                 if (length(args) > 0) 
[08:29:03.295]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.295]             }
[08:29:03.295]             else {
[08:29:03.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.295]             }
[08:29:03.295]             {
[08:29:03.295]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.295]                   0L) {
[08:29:03.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.295]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.295]                   base::options(opts)
[08:29:03.295]                 }
[08:29:03.295]                 {
[08:29:03.295]                   {
[08:29:03.295]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.295]                     NULL
[08:29:03.295]                   }
[08:29:03.295]                   options(future.plan = NULL)
[08:29:03.295]                   if (is.na(NA_character_)) 
[08:29:03.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.295]                     .init = FALSE)
[08:29:03.295]                 }
[08:29:03.295]             }
[08:29:03.295]         }
[08:29:03.295]     })
[08:29:03.295]     if (TRUE) {
[08:29:03.295]         base::sink(type = "output", split = FALSE)
[08:29:03.295]         if (TRUE) {
[08:29:03.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.295]         }
[08:29:03.295]         else {
[08:29:03.295]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.295]         }
[08:29:03.295]         base::close(...future.stdout)
[08:29:03.295]         ...future.stdout <- NULL
[08:29:03.295]     }
[08:29:03.295]     ...future.result$conditions <- ...future.conditions
[08:29:03.295]     ...future.result$finished <- base::Sys.time()
[08:29:03.295]     ...future.result
[08:29:03.295] }
[08:29:03.297] requestCore(): workers = 2
[08:29:03.299] MulticoreFuture started
[08:29:03.299] - Launch lazy future ... done
[08:29:03.300] run() for ‘MulticoreFuture’ ... done
[08:29:03.300] getGlobalsAndPackages() ...
[08:29:03.300] plan(): Setting new future strategy stack:
[08:29:03.300] Searching for globals...
[08:29:03.300] List of future strategies:
[08:29:03.300] 1. sequential:
[08:29:03.300]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.300]    - tweaked: FALSE
[08:29:03.300]    - call: NULL
[08:29:03.301] 
[08:29:03.301] plan(): nbrOfWorkers() = 1
[08:29:03.302] Searching for globals ... DONE
[08:29:03.302] - globals: [0] <none>
[08:29:03.302] getGlobalsAndPackages() ... DONE
[08:29:03.302] run() for ‘Future’ ...
[08:29:03.303] - state: ‘created’
[08:29:03.303] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.304] plan(): Setting new future strategy stack:
[08:29:03.304] List of future strategies:
[08:29:03.304] 1. multicore:
[08:29:03.304]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.304]    - tweaked: FALSE
[08:29:03.304]    - call: plan(strategy)
[08:29:03.306] plan(): nbrOfWorkers() = 2
[08:29:03.306] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.307]   - Field: ‘label’
[08:29:03.307]   - Field: ‘local’
[08:29:03.307]   - Field: ‘owner’
[08:29:03.307]   - Field: ‘envir’
[08:29:03.307]   - Field: ‘workers’
[08:29:03.307]   - Field: ‘packages’
[08:29:03.307]   - Field: ‘gc’
[08:29:03.308]   - Field: ‘job’
[08:29:03.308]   - Field: ‘conditions’
[08:29:03.308]   - Field: ‘expr’
[08:29:03.308]   - Field: ‘uuid’
[08:29:03.308]   - Field: ‘seed’
[08:29:03.308]   - Field: ‘version’
[08:29:03.308]   - Field: ‘result’
[08:29:03.309]   - Field: ‘asynchronous’
[08:29:03.309]   - Field: ‘calls’
[08:29:03.309]   - Field: ‘globals’
[08:29:03.309]   - Field: ‘stdout’
[08:29:03.309]   - Field: ‘earlySignal’
[08:29:03.309]   - Field: ‘lazy’
[08:29:03.309]   - Field: ‘state’
[08:29:03.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.310] - Launch lazy future ...
[08:29:03.310] Packages needed by the future expression (n = 0): <none>
[08:29:03.310] Packages needed by future strategies (n = 0): <none>
[08:29:03.311] {
[08:29:03.311]     {
[08:29:03.311]         {
[08:29:03.311]             ...future.startTime <- base::Sys.time()
[08:29:03.311]             {
[08:29:03.311]                 {
[08:29:03.311]                   {
[08:29:03.311]                     {
[08:29:03.311]                       base::local({
[08:29:03.311]                         has_future <- base::requireNamespace("future", 
[08:29:03.311]                           quietly = TRUE)
[08:29:03.311]                         if (has_future) {
[08:29:03.311]                           ns <- base::getNamespace("future")
[08:29:03.311]                           version <- ns[[".package"]][["version"]]
[08:29:03.311]                           if (is.null(version)) 
[08:29:03.311]                             version <- utils::packageVersion("future")
[08:29:03.311]                         }
[08:29:03.311]                         else {
[08:29:03.311]                           version <- NULL
[08:29:03.311]                         }
[08:29:03.311]                         if (!has_future || version < "1.8.0") {
[08:29:03.311]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.311]                             "", base::R.version$version.string), 
[08:29:03.311]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.311]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.311]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.311]                               "release", "version")], collapse = " "), 
[08:29:03.311]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.311]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.311]                             info)
[08:29:03.311]                           info <- base::paste(info, collapse = "; ")
[08:29:03.311]                           if (!has_future) {
[08:29:03.311]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.311]                               info)
[08:29:03.311]                           }
[08:29:03.311]                           else {
[08:29:03.311]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.311]                               info, version)
[08:29:03.311]                           }
[08:29:03.311]                           base::stop(msg)
[08:29:03.311]                         }
[08:29:03.311]                       })
[08:29:03.311]                     }
[08:29:03.311]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.311]                     base::options(mc.cores = 1L)
[08:29:03.311]                   }
[08:29:03.311]                   ...future.strategy.old <- future::plan("list")
[08:29:03.311]                   options(future.plan = NULL)
[08:29:03.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.311]                 }
[08:29:03.311]                 ...future.workdir <- getwd()
[08:29:03.311]             }
[08:29:03.311]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.311]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.311]         }
[08:29:03.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.311]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.311]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.311]             base::names(...future.oldOptions))
[08:29:03.311]     }
[08:29:03.311]     if (FALSE) {
[08:29:03.311]     }
[08:29:03.311]     else {
[08:29:03.311]         if (TRUE) {
[08:29:03.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.311]                 open = "w")
[08:29:03.311]         }
[08:29:03.311]         else {
[08:29:03.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.311]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.311]         }
[08:29:03.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.311]             base::sink(type = "output", split = FALSE)
[08:29:03.311]             base::close(...future.stdout)
[08:29:03.311]         }, add = TRUE)
[08:29:03.311]     }
[08:29:03.311]     ...future.frame <- base::sys.nframe()
[08:29:03.311]     ...future.conditions <- base::list()
[08:29:03.311]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.311]     if (FALSE) {
[08:29:03.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.311]     }
[08:29:03.311]     ...future.result <- base::tryCatch({
[08:29:03.311]         base::withCallingHandlers({
[08:29:03.311]             ...future.value <- base::withVisible(base::local({
[08:29:03.311]                 withCallingHandlers({
[08:29:03.311]                   2
[08:29:03.311]                 }, immediateCondition = function(cond) {
[08:29:03.311]                   save_rds <- function (object, pathname, ...) 
[08:29:03.311]                   {
[08:29:03.311]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.311]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.311]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.311]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.311]                         fi_tmp[["mtime"]])
[08:29:03.311]                     }
[08:29:03.311]                     tryCatch({
[08:29:03.311]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.311]                     }, error = function(ex) {
[08:29:03.311]                       msg <- conditionMessage(ex)
[08:29:03.311]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.311]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.311]                         fi_tmp[["mtime"]], msg)
[08:29:03.311]                       ex$message <- msg
[08:29:03.311]                       stop(ex)
[08:29:03.311]                     })
[08:29:03.311]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.311]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.311]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.311]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.311]                       fi <- file.info(pathname)
[08:29:03.311]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.311]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.311]                         fi[["size"]], fi[["mtime"]])
[08:29:03.311]                       stop(msg)
[08:29:03.311]                     }
[08:29:03.311]                     invisible(pathname)
[08:29:03.311]                   }
[08:29:03.311]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.311]                     rootPath = tempdir()) 
[08:29:03.311]                   {
[08:29:03.311]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.311]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.311]                       tmpdir = path, fileext = ".rds")
[08:29:03.311]                     save_rds(obj, file)
[08:29:03.311]                   }
[08:29:03.311]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.311]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.311]                   {
[08:29:03.311]                     inherits <- base::inherits
[08:29:03.311]                     invokeRestart <- base::invokeRestart
[08:29:03.311]                     is.null <- base::is.null
[08:29:03.311]                     muffled <- FALSE
[08:29:03.311]                     if (inherits(cond, "message")) {
[08:29:03.311]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.311]                       if (muffled) 
[08:29:03.311]                         invokeRestart("muffleMessage")
[08:29:03.311]                     }
[08:29:03.311]                     else if (inherits(cond, "warning")) {
[08:29:03.311]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.311]                       if (muffled) 
[08:29:03.311]                         invokeRestart("muffleWarning")
[08:29:03.311]                     }
[08:29:03.311]                     else if (inherits(cond, "condition")) {
[08:29:03.311]                       if (!is.null(pattern)) {
[08:29:03.311]                         computeRestarts <- base::computeRestarts
[08:29:03.311]                         grepl <- base::grepl
[08:29:03.311]                         restarts <- computeRestarts(cond)
[08:29:03.311]                         for (restart in restarts) {
[08:29:03.311]                           name <- restart$name
[08:29:03.311]                           if (is.null(name)) 
[08:29:03.311]                             next
[08:29:03.311]                           if (!grepl(pattern, name)) 
[08:29:03.311]                             next
[08:29:03.311]                           invokeRestart(restart)
[08:29:03.311]                           muffled <- TRUE
[08:29:03.311]                           break
[08:29:03.311]                         }
[08:29:03.311]                       }
[08:29:03.311]                     }
[08:29:03.311]                     invisible(muffled)
[08:29:03.311]                   }
[08:29:03.311]                   muffleCondition(cond)
[08:29:03.311]                 })
[08:29:03.311]             }))
[08:29:03.311]             future::FutureResult(value = ...future.value$value, 
[08:29:03.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.311]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.311]                     ...future.globalenv.names))
[08:29:03.311]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.311]         }, condition = base::local({
[08:29:03.311]             c <- base::c
[08:29:03.311]             inherits <- base::inherits
[08:29:03.311]             invokeRestart <- base::invokeRestart
[08:29:03.311]             length <- base::length
[08:29:03.311]             list <- base::list
[08:29:03.311]             seq.int <- base::seq.int
[08:29:03.311]             signalCondition <- base::signalCondition
[08:29:03.311]             sys.calls <- base::sys.calls
[08:29:03.311]             `[[` <- base::`[[`
[08:29:03.311]             `+` <- base::`+`
[08:29:03.311]             `<<-` <- base::`<<-`
[08:29:03.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.311]                   3L)]
[08:29:03.311]             }
[08:29:03.311]             function(cond) {
[08:29:03.311]                 is_error <- inherits(cond, "error")
[08:29:03.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.311]                   NULL)
[08:29:03.311]                 if (is_error) {
[08:29:03.311]                   sessionInformation <- function() {
[08:29:03.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.311]                       search = base::search(), system = base::Sys.info())
[08:29:03.311]                   }
[08:29:03.311]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.311]                     cond$call), session = sessionInformation(), 
[08:29:03.311]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.311]                   signalCondition(cond)
[08:29:03.311]                 }
[08:29:03.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.311]                 "immediateCondition"))) {
[08:29:03.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.311]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.311]                   if (TRUE && !signal) {
[08:29:03.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.311]                     {
[08:29:03.311]                       inherits <- base::inherits
[08:29:03.311]                       invokeRestart <- base::invokeRestart
[08:29:03.311]                       is.null <- base::is.null
[08:29:03.311]                       muffled <- FALSE
[08:29:03.311]                       if (inherits(cond, "message")) {
[08:29:03.311]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.311]                         if (muffled) 
[08:29:03.311]                           invokeRestart("muffleMessage")
[08:29:03.311]                       }
[08:29:03.311]                       else if (inherits(cond, "warning")) {
[08:29:03.311]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.311]                         if (muffled) 
[08:29:03.311]                           invokeRestart("muffleWarning")
[08:29:03.311]                       }
[08:29:03.311]                       else if (inherits(cond, "condition")) {
[08:29:03.311]                         if (!is.null(pattern)) {
[08:29:03.311]                           computeRestarts <- base::computeRestarts
[08:29:03.311]                           grepl <- base::grepl
[08:29:03.311]                           restarts <- computeRestarts(cond)
[08:29:03.311]                           for (restart in restarts) {
[08:29:03.311]                             name <- restart$name
[08:29:03.311]                             if (is.null(name)) 
[08:29:03.311]                               next
[08:29:03.311]                             if (!grepl(pattern, name)) 
[08:29:03.311]                               next
[08:29:03.311]                             invokeRestart(restart)
[08:29:03.311]                             muffled <- TRUE
[08:29:03.311]                             break
[08:29:03.311]                           }
[08:29:03.311]                         }
[08:29:03.311]                       }
[08:29:03.311]                       invisible(muffled)
[08:29:03.311]                     }
[08:29:03.311]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.311]                   }
[08:29:03.311]                 }
[08:29:03.311]                 else {
[08:29:03.311]                   if (TRUE) {
[08:29:03.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.311]                     {
[08:29:03.311]                       inherits <- base::inherits
[08:29:03.311]                       invokeRestart <- base::invokeRestart
[08:29:03.311]                       is.null <- base::is.null
[08:29:03.311]                       muffled <- FALSE
[08:29:03.311]                       if (inherits(cond, "message")) {
[08:29:03.311]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.311]                         if (muffled) 
[08:29:03.311]                           invokeRestart("muffleMessage")
[08:29:03.311]                       }
[08:29:03.311]                       else if (inherits(cond, "warning")) {
[08:29:03.311]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.311]                         if (muffled) 
[08:29:03.311]                           invokeRestart("muffleWarning")
[08:29:03.311]                       }
[08:29:03.311]                       else if (inherits(cond, "condition")) {
[08:29:03.311]                         if (!is.null(pattern)) {
[08:29:03.311]                           computeRestarts <- base::computeRestarts
[08:29:03.311]                           grepl <- base::grepl
[08:29:03.311]                           restarts <- computeRestarts(cond)
[08:29:03.311]                           for (restart in restarts) {
[08:29:03.311]                             name <- restart$name
[08:29:03.311]                             if (is.null(name)) 
[08:29:03.311]                               next
[08:29:03.311]                             if (!grepl(pattern, name)) 
[08:29:03.311]                               next
[08:29:03.311]                             invokeRestart(restart)
[08:29:03.311]                             muffled <- TRUE
[08:29:03.311]                             break
[08:29:03.311]                           }
[08:29:03.311]                         }
[08:29:03.311]                       }
[08:29:03.311]                       invisible(muffled)
[08:29:03.311]                     }
[08:29:03.311]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.311]                   }
[08:29:03.311]                 }
[08:29:03.311]             }
[08:29:03.311]         }))
[08:29:03.311]     }, error = function(ex) {
[08:29:03.311]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.311]                 ...future.rng), started = ...future.startTime, 
[08:29:03.311]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.311]             version = "1.8"), class = "FutureResult")
[08:29:03.311]     }, finally = {
[08:29:03.311]         if (!identical(...future.workdir, getwd())) 
[08:29:03.311]             setwd(...future.workdir)
[08:29:03.311]         {
[08:29:03.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.311]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.311]             }
[08:29:03.311]             base::options(...future.oldOptions)
[08:29:03.311]             if (.Platform$OS.type == "windows") {
[08:29:03.311]                 old_names <- names(...future.oldEnvVars)
[08:29:03.311]                 envs <- base::Sys.getenv()
[08:29:03.311]                 names <- names(envs)
[08:29:03.311]                 common <- intersect(names, old_names)
[08:29:03.311]                 added <- setdiff(names, old_names)
[08:29:03.311]                 removed <- setdiff(old_names, names)
[08:29:03.311]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.311]                   envs[common]]
[08:29:03.311]                 NAMES <- toupper(changed)
[08:29:03.311]                 args <- list()
[08:29:03.311]                 for (kk in seq_along(NAMES)) {
[08:29:03.311]                   name <- changed[[kk]]
[08:29:03.311]                   NAME <- NAMES[[kk]]
[08:29:03.311]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.311]                     next
[08:29:03.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.311]                 }
[08:29:03.311]                 NAMES <- toupper(added)
[08:29:03.311]                 for (kk in seq_along(NAMES)) {
[08:29:03.311]                   name <- added[[kk]]
[08:29:03.311]                   NAME <- NAMES[[kk]]
[08:29:03.311]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.311]                     next
[08:29:03.311]                   args[[name]] <- ""
[08:29:03.311]                 }
[08:29:03.311]                 NAMES <- toupper(removed)
[08:29:03.311]                 for (kk in seq_along(NAMES)) {
[08:29:03.311]                   name <- removed[[kk]]
[08:29:03.311]                   NAME <- NAMES[[kk]]
[08:29:03.311]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.311]                     next
[08:29:03.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.311]                 }
[08:29:03.311]                 if (length(args) > 0) 
[08:29:03.311]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.311]             }
[08:29:03.311]             else {
[08:29:03.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.311]             }
[08:29:03.311]             {
[08:29:03.311]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.311]                   0L) {
[08:29:03.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.311]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.311]                   base::options(opts)
[08:29:03.311]                 }
[08:29:03.311]                 {
[08:29:03.311]                   {
[08:29:03.311]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.311]                     NULL
[08:29:03.311]                   }
[08:29:03.311]                   options(future.plan = NULL)
[08:29:03.311]                   if (is.na(NA_character_)) 
[08:29:03.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.311]                     .init = FALSE)
[08:29:03.311]                 }
[08:29:03.311]             }
[08:29:03.311]         }
[08:29:03.311]     })
[08:29:03.311]     if (TRUE) {
[08:29:03.311]         base::sink(type = "output", split = FALSE)
[08:29:03.311]         if (TRUE) {
[08:29:03.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.311]         }
[08:29:03.311]         else {
[08:29:03.311]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.311]         }
[08:29:03.311]         base::close(...future.stdout)
[08:29:03.311]         ...future.stdout <- NULL
[08:29:03.311]     }
[08:29:03.311]     ...future.result$conditions <- ...future.conditions
[08:29:03.311]     ...future.result$finished <- base::Sys.time()
[08:29:03.311]     ...future.result
[08:29:03.311] }
[08:29:03.314] requestCore(): workers = 2
[08:29:03.316] MulticoreFuture started
[08:29:03.317] - Launch lazy future ... done
[08:29:03.317] run() for ‘MulticoreFuture’ ... done
[08:29:03.317] plan(): Setting new future strategy stack:
[08:29:03.318] resolve() on list environment ...
[08:29:03.318] List of future strategies:
[08:29:03.318] 1. sequential:
[08:29:03.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.318]    - tweaked: FALSE
[08:29:03.318]    - call: NULL
[08:29:03.318]  recursive: 0
[08:29:03.319] plan(): nbrOfWorkers() = 1
[08:29:03.319]  length: 3
[08:29:03.320]  elements: ‘a’, ‘b’, ‘c’
[08:29:03.320] Future #1
[08:29:03.320]  length: 2 (resolved future 1)
[08:29:03.321] plan(): Setting new future strategy stack:
[08:29:03.321] List of future strategies:
[08:29:03.321] 1. multicore:
[08:29:03.321]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.321]    - tweaked: FALSE
[08:29:03.321]    - call: plan(strategy)
[08:29:03.324] plan(): nbrOfWorkers() = 2
[08:29:03.324] Future #2
[08:29:03.325]  length: 1 (resolved future 2)
[08:29:03.325]  length: 0 (resolved future 3)
[08:29:03.325] resolve() on list environment ... DONE
[08:29:03.326] getGlobalsAndPackages() ...
[08:29:03.326] Searching for globals...
[08:29:03.327] - globals found: [1] ‘{’
[08:29:03.328] Searching for globals ... DONE
[08:29:03.328] Resolving globals: FALSE
[08:29:03.328] 
[08:29:03.328] 
[08:29:03.328] getGlobalsAndPackages() ... DONE
[08:29:03.329] run() for ‘Future’ ...
[08:29:03.329] - state: ‘created’
[08:29:03.329] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.332] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.332] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.332]   - Field: ‘label’
[08:29:03.332]   - Field: ‘local’
[08:29:03.332]   - Field: ‘owner’
[08:29:03.332]   - Field: ‘envir’
[08:29:03.333]   - Field: ‘workers’
[08:29:03.333]   - Field: ‘packages’
[08:29:03.333]   - Field: ‘gc’
[08:29:03.333]   - Field: ‘job’
[08:29:03.333]   - Field: ‘conditions’
[08:29:03.333]   - Field: ‘expr’
[08:29:03.333]   - Field: ‘uuid’
[08:29:03.334]   - Field: ‘seed’
[08:29:03.334]   - Field: ‘version’
[08:29:03.334]   - Field: ‘result’
[08:29:03.334]   - Field: ‘asynchronous’
[08:29:03.334]   - Field: ‘calls’
[08:29:03.334]   - Field: ‘globals’
[08:29:03.334]   - Field: ‘stdout’
[08:29:03.334]   - Field: ‘earlySignal’
[08:29:03.335]   - Field: ‘lazy’
[08:29:03.335]   - Field: ‘state’
[08:29:03.335] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.335] - Launch lazy future ...
[08:29:03.335] Packages needed by the future expression (n = 0): <none>
[08:29:03.336] Packages needed by future strategies (n = 0): <none>
[08:29:03.336] {
[08:29:03.336]     {
[08:29:03.336]         {
[08:29:03.336]             ...future.startTime <- base::Sys.time()
[08:29:03.336]             {
[08:29:03.336]                 {
[08:29:03.336]                   {
[08:29:03.336]                     {
[08:29:03.336]                       base::local({
[08:29:03.336]                         has_future <- base::requireNamespace("future", 
[08:29:03.336]                           quietly = TRUE)
[08:29:03.336]                         if (has_future) {
[08:29:03.336]                           ns <- base::getNamespace("future")
[08:29:03.336]                           version <- ns[[".package"]][["version"]]
[08:29:03.336]                           if (is.null(version)) 
[08:29:03.336]                             version <- utils::packageVersion("future")
[08:29:03.336]                         }
[08:29:03.336]                         else {
[08:29:03.336]                           version <- NULL
[08:29:03.336]                         }
[08:29:03.336]                         if (!has_future || version < "1.8.0") {
[08:29:03.336]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.336]                             "", base::R.version$version.string), 
[08:29:03.336]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.336]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.336]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.336]                               "release", "version")], collapse = " "), 
[08:29:03.336]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.336]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.336]                             info)
[08:29:03.336]                           info <- base::paste(info, collapse = "; ")
[08:29:03.336]                           if (!has_future) {
[08:29:03.336]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.336]                               info)
[08:29:03.336]                           }
[08:29:03.336]                           else {
[08:29:03.336]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.336]                               info, version)
[08:29:03.336]                           }
[08:29:03.336]                           base::stop(msg)
[08:29:03.336]                         }
[08:29:03.336]                       })
[08:29:03.336]                     }
[08:29:03.336]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.336]                     base::options(mc.cores = 1L)
[08:29:03.336]                   }
[08:29:03.336]                   ...future.strategy.old <- future::plan("list")
[08:29:03.336]                   options(future.plan = NULL)
[08:29:03.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.336]                 }
[08:29:03.336]                 ...future.workdir <- getwd()
[08:29:03.336]             }
[08:29:03.336]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.336]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.336]         }
[08:29:03.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.336]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.336]             base::names(...future.oldOptions))
[08:29:03.336]     }
[08:29:03.336]     if (FALSE) {
[08:29:03.336]     }
[08:29:03.336]     else {
[08:29:03.336]         if (TRUE) {
[08:29:03.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.336]                 open = "w")
[08:29:03.336]         }
[08:29:03.336]         else {
[08:29:03.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.336]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.336]         }
[08:29:03.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.336]             base::sink(type = "output", split = FALSE)
[08:29:03.336]             base::close(...future.stdout)
[08:29:03.336]         }, add = TRUE)
[08:29:03.336]     }
[08:29:03.336]     ...future.frame <- base::sys.nframe()
[08:29:03.336]     ...future.conditions <- base::list()
[08:29:03.336]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.336]     if (FALSE) {
[08:29:03.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.336]     }
[08:29:03.336]     ...future.result <- base::tryCatch({
[08:29:03.336]         base::withCallingHandlers({
[08:29:03.336]             ...future.value <- base::withVisible(base::local({
[08:29:03.336]                 withCallingHandlers({
[08:29:03.336]                   {
[08:29:03.336]                     1
[08:29:03.336]                   }
[08:29:03.336]                 }, immediateCondition = function(cond) {
[08:29:03.336]                   save_rds <- function (object, pathname, ...) 
[08:29:03.336]                   {
[08:29:03.336]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.336]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.336]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.336]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.336]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.336]                         fi_tmp[["mtime"]])
[08:29:03.336]                     }
[08:29:03.336]                     tryCatch({
[08:29:03.336]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.336]                     }, error = function(ex) {
[08:29:03.336]                       msg <- conditionMessage(ex)
[08:29:03.336]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.336]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.336]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.336]                         fi_tmp[["mtime"]], msg)
[08:29:03.336]                       ex$message <- msg
[08:29:03.336]                       stop(ex)
[08:29:03.336]                     })
[08:29:03.336]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.336]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.336]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.336]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.336]                       fi <- file.info(pathname)
[08:29:03.336]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.336]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.336]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.336]                         fi[["size"]], fi[["mtime"]])
[08:29:03.336]                       stop(msg)
[08:29:03.336]                     }
[08:29:03.336]                     invisible(pathname)
[08:29:03.336]                   }
[08:29:03.336]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.336]                     rootPath = tempdir()) 
[08:29:03.336]                   {
[08:29:03.336]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.336]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.336]                       tmpdir = path, fileext = ".rds")
[08:29:03.336]                     save_rds(obj, file)
[08:29:03.336]                   }
[08:29:03.336]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.336]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.336]                   {
[08:29:03.336]                     inherits <- base::inherits
[08:29:03.336]                     invokeRestart <- base::invokeRestart
[08:29:03.336]                     is.null <- base::is.null
[08:29:03.336]                     muffled <- FALSE
[08:29:03.336]                     if (inherits(cond, "message")) {
[08:29:03.336]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.336]                       if (muffled) 
[08:29:03.336]                         invokeRestart("muffleMessage")
[08:29:03.336]                     }
[08:29:03.336]                     else if (inherits(cond, "warning")) {
[08:29:03.336]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.336]                       if (muffled) 
[08:29:03.336]                         invokeRestart("muffleWarning")
[08:29:03.336]                     }
[08:29:03.336]                     else if (inherits(cond, "condition")) {
[08:29:03.336]                       if (!is.null(pattern)) {
[08:29:03.336]                         computeRestarts <- base::computeRestarts
[08:29:03.336]                         grepl <- base::grepl
[08:29:03.336]                         restarts <- computeRestarts(cond)
[08:29:03.336]                         for (restart in restarts) {
[08:29:03.336]                           name <- restart$name
[08:29:03.336]                           if (is.null(name)) 
[08:29:03.336]                             next
[08:29:03.336]                           if (!grepl(pattern, name)) 
[08:29:03.336]                             next
[08:29:03.336]                           invokeRestart(restart)
[08:29:03.336]                           muffled <- TRUE
[08:29:03.336]                           break
[08:29:03.336]                         }
[08:29:03.336]                       }
[08:29:03.336]                     }
[08:29:03.336]                     invisible(muffled)
[08:29:03.336]                   }
[08:29:03.336]                   muffleCondition(cond)
[08:29:03.336]                 })
[08:29:03.336]             }))
[08:29:03.336]             future::FutureResult(value = ...future.value$value, 
[08:29:03.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.336]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.336]                     ...future.globalenv.names))
[08:29:03.336]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.336]         }, condition = base::local({
[08:29:03.336]             c <- base::c
[08:29:03.336]             inherits <- base::inherits
[08:29:03.336]             invokeRestart <- base::invokeRestart
[08:29:03.336]             length <- base::length
[08:29:03.336]             list <- base::list
[08:29:03.336]             seq.int <- base::seq.int
[08:29:03.336]             signalCondition <- base::signalCondition
[08:29:03.336]             sys.calls <- base::sys.calls
[08:29:03.336]             `[[` <- base::`[[`
[08:29:03.336]             `+` <- base::`+`
[08:29:03.336]             `<<-` <- base::`<<-`
[08:29:03.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.336]                   3L)]
[08:29:03.336]             }
[08:29:03.336]             function(cond) {
[08:29:03.336]                 is_error <- inherits(cond, "error")
[08:29:03.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.336]                   NULL)
[08:29:03.336]                 if (is_error) {
[08:29:03.336]                   sessionInformation <- function() {
[08:29:03.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.336]                       search = base::search(), system = base::Sys.info())
[08:29:03.336]                   }
[08:29:03.336]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.336]                     cond$call), session = sessionInformation(), 
[08:29:03.336]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.336]                   signalCondition(cond)
[08:29:03.336]                 }
[08:29:03.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.336]                 "immediateCondition"))) {
[08:29:03.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.336]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.336]                   if (TRUE && !signal) {
[08:29:03.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.336]                     {
[08:29:03.336]                       inherits <- base::inherits
[08:29:03.336]                       invokeRestart <- base::invokeRestart
[08:29:03.336]                       is.null <- base::is.null
[08:29:03.336]                       muffled <- FALSE
[08:29:03.336]                       if (inherits(cond, "message")) {
[08:29:03.336]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.336]                         if (muffled) 
[08:29:03.336]                           invokeRestart("muffleMessage")
[08:29:03.336]                       }
[08:29:03.336]                       else if (inherits(cond, "warning")) {
[08:29:03.336]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.336]                         if (muffled) 
[08:29:03.336]                           invokeRestart("muffleWarning")
[08:29:03.336]                       }
[08:29:03.336]                       else if (inherits(cond, "condition")) {
[08:29:03.336]                         if (!is.null(pattern)) {
[08:29:03.336]                           computeRestarts <- base::computeRestarts
[08:29:03.336]                           grepl <- base::grepl
[08:29:03.336]                           restarts <- computeRestarts(cond)
[08:29:03.336]                           for (restart in restarts) {
[08:29:03.336]                             name <- restart$name
[08:29:03.336]                             if (is.null(name)) 
[08:29:03.336]                               next
[08:29:03.336]                             if (!grepl(pattern, name)) 
[08:29:03.336]                               next
[08:29:03.336]                             invokeRestart(restart)
[08:29:03.336]                             muffled <- TRUE
[08:29:03.336]                             break
[08:29:03.336]                           }
[08:29:03.336]                         }
[08:29:03.336]                       }
[08:29:03.336]                       invisible(muffled)
[08:29:03.336]                     }
[08:29:03.336]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.336]                   }
[08:29:03.336]                 }
[08:29:03.336]                 else {
[08:29:03.336]                   if (TRUE) {
[08:29:03.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.336]                     {
[08:29:03.336]                       inherits <- base::inherits
[08:29:03.336]                       invokeRestart <- base::invokeRestart
[08:29:03.336]                       is.null <- base::is.null
[08:29:03.336]                       muffled <- FALSE
[08:29:03.336]                       if (inherits(cond, "message")) {
[08:29:03.336]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.336]                         if (muffled) 
[08:29:03.336]                           invokeRestart("muffleMessage")
[08:29:03.336]                       }
[08:29:03.336]                       else if (inherits(cond, "warning")) {
[08:29:03.336]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.336]                         if (muffled) 
[08:29:03.336]                           invokeRestart("muffleWarning")
[08:29:03.336]                       }
[08:29:03.336]                       else if (inherits(cond, "condition")) {
[08:29:03.336]                         if (!is.null(pattern)) {
[08:29:03.336]                           computeRestarts <- base::computeRestarts
[08:29:03.336]                           grepl <- base::grepl
[08:29:03.336]                           restarts <- computeRestarts(cond)
[08:29:03.336]                           for (restart in restarts) {
[08:29:03.336]                             name <- restart$name
[08:29:03.336]                             if (is.null(name)) 
[08:29:03.336]                               next
[08:29:03.336]                             if (!grepl(pattern, name)) 
[08:29:03.336]                               next
[08:29:03.336]                             invokeRestart(restart)
[08:29:03.336]                             muffled <- TRUE
[08:29:03.336]                             break
[08:29:03.336]                           }
[08:29:03.336]                         }
[08:29:03.336]                       }
[08:29:03.336]                       invisible(muffled)
[08:29:03.336]                     }
[08:29:03.336]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.336]                   }
[08:29:03.336]                 }
[08:29:03.336]             }
[08:29:03.336]         }))
[08:29:03.336]     }, error = function(ex) {
[08:29:03.336]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.336]                 ...future.rng), started = ...future.startTime, 
[08:29:03.336]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.336]             version = "1.8"), class = "FutureResult")
[08:29:03.336]     }, finally = {
[08:29:03.336]         if (!identical(...future.workdir, getwd())) 
[08:29:03.336]             setwd(...future.workdir)
[08:29:03.336]         {
[08:29:03.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.336]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.336]             }
[08:29:03.336]             base::options(...future.oldOptions)
[08:29:03.336]             if (.Platform$OS.type == "windows") {
[08:29:03.336]                 old_names <- names(...future.oldEnvVars)
[08:29:03.336]                 envs <- base::Sys.getenv()
[08:29:03.336]                 names <- names(envs)
[08:29:03.336]                 common <- intersect(names, old_names)
[08:29:03.336]                 added <- setdiff(names, old_names)
[08:29:03.336]                 removed <- setdiff(old_names, names)
[08:29:03.336]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.336]                   envs[common]]
[08:29:03.336]                 NAMES <- toupper(changed)
[08:29:03.336]                 args <- list()
[08:29:03.336]                 for (kk in seq_along(NAMES)) {
[08:29:03.336]                   name <- changed[[kk]]
[08:29:03.336]                   NAME <- NAMES[[kk]]
[08:29:03.336]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.336]                     next
[08:29:03.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.336]                 }
[08:29:03.336]                 NAMES <- toupper(added)
[08:29:03.336]                 for (kk in seq_along(NAMES)) {
[08:29:03.336]                   name <- added[[kk]]
[08:29:03.336]                   NAME <- NAMES[[kk]]
[08:29:03.336]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.336]                     next
[08:29:03.336]                   args[[name]] <- ""
[08:29:03.336]                 }
[08:29:03.336]                 NAMES <- toupper(removed)
[08:29:03.336]                 for (kk in seq_along(NAMES)) {
[08:29:03.336]                   name <- removed[[kk]]
[08:29:03.336]                   NAME <- NAMES[[kk]]
[08:29:03.336]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.336]                     next
[08:29:03.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.336]                 }
[08:29:03.336]                 if (length(args) > 0) 
[08:29:03.336]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.336]             }
[08:29:03.336]             else {
[08:29:03.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.336]             }
[08:29:03.336]             {
[08:29:03.336]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.336]                   0L) {
[08:29:03.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.336]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.336]                   base::options(opts)
[08:29:03.336]                 }
[08:29:03.336]                 {
[08:29:03.336]                   {
[08:29:03.336]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.336]                     NULL
[08:29:03.336]                   }
[08:29:03.336]                   options(future.plan = NULL)
[08:29:03.336]                   if (is.na(NA_character_)) 
[08:29:03.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.336]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.336]                     .init = FALSE)
[08:29:03.336]                 }
[08:29:03.336]             }
[08:29:03.336]         }
[08:29:03.336]     })
[08:29:03.336]     if (TRUE) {
[08:29:03.336]         base::sink(type = "output", split = FALSE)
[08:29:03.336]         if (TRUE) {
[08:29:03.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.336]         }
[08:29:03.336]         else {
[08:29:03.336]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.336]         }
[08:29:03.336]         base::close(...future.stdout)
[08:29:03.336]         ...future.stdout <- NULL
[08:29:03.336]     }
[08:29:03.336]     ...future.result$conditions <- ...future.conditions
[08:29:03.336]     ...future.result$finished <- base::Sys.time()
[08:29:03.336]     ...future.result
[08:29:03.336] }
[08:29:03.339] requestCore(): workers = 2
[08:29:03.340] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.350] result() for MulticoreFuture ...
[08:29:03.351] result() for MulticoreFuture ...
[08:29:03.351] result() for MulticoreFuture ... done
[08:29:03.352] result() for MulticoreFuture ... done
[08:29:03.352] result() for MulticoreFuture ...
[08:29:03.352] result() for MulticoreFuture ... done
[08:29:03.354] MulticoreFuture started
[08:29:03.354] - Launch lazy future ... done
[08:29:03.355] run() for ‘MulticoreFuture’ ... done
[08:29:03.355] plan(): Setting new future strategy stack:
[08:29:03.356] getGlobalsAndPackages() ...
[08:29:03.356] Searching for globals...
[08:29:03.355] List of future strategies:
[08:29:03.355] 1. sequential:
[08:29:03.355]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.355]    - tweaked: FALSE
[08:29:03.355]    - call: NULL
[08:29:03.357] plan(): nbrOfWorkers() = 1
[08:29:03.366] plan(): Setting new future strategy stack:
[08:29:03.366] - globals found: [1] ‘{’
[08:29:03.366] Searching for globals ... DONE
[08:29:03.367] Resolving globals: FALSE
[08:29:03.366] List of future strategies:
[08:29:03.366] 1. multicore:
[08:29:03.366]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.366]    - tweaked: FALSE
[08:29:03.366]    - call: plan(strategy)
[08:29:03.368] 
[08:29:03.369] 
[08:29:03.369] getGlobalsAndPackages() ... DONE
[08:29:03.370] run() for ‘Future’ ...
[08:29:03.371] - state: ‘created’
[08:29:03.371] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.372] plan(): nbrOfWorkers() = 2
[08:29:03.374] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.374] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.375]   - Field: ‘label’
[08:29:03.375]   - Field: ‘local’
[08:29:03.375]   - Field: ‘owner’
[08:29:03.375]   - Field: ‘envir’
[08:29:03.375]   - Field: ‘workers’
[08:29:03.375]   - Field: ‘packages’
[08:29:03.376]   - Field: ‘gc’
[08:29:03.376]   - Field: ‘job’
[08:29:03.376]   - Field: ‘conditions’
[08:29:03.376]   - Field: ‘expr’
[08:29:03.376]   - Field: ‘uuid’
[08:29:03.376]   - Field: ‘seed’
[08:29:03.377]   - Field: ‘version’
[08:29:03.377]   - Field: ‘result’
[08:29:03.377]   - Field: ‘asynchronous’
[08:29:03.377]   - Field: ‘calls’
[08:29:03.377]   - Field: ‘globals’
[08:29:03.377]   - Field: ‘stdout’
[08:29:03.377]   - Field: ‘earlySignal’
[08:29:03.377]   - Field: ‘lazy’
[08:29:03.378]   - Field: ‘state’
[08:29:03.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.378] - Launch lazy future ...
[08:29:03.378] Packages needed by the future expression (n = 0): <none>
[08:29:03.378] Packages needed by future strategies (n = 0): <none>
[08:29:03.379] {
[08:29:03.379]     {
[08:29:03.379]         {
[08:29:03.379]             ...future.startTime <- base::Sys.time()
[08:29:03.379]             {
[08:29:03.379]                 {
[08:29:03.379]                   {
[08:29:03.379]                     {
[08:29:03.379]                       base::local({
[08:29:03.379]                         has_future <- base::requireNamespace("future", 
[08:29:03.379]                           quietly = TRUE)
[08:29:03.379]                         if (has_future) {
[08:29:03.379]                           ns <- base::getNamespace("future")
[08:29:03.379]                           version <- ns[[".package"]][["version"]]
[08:29:03.379]                           if (is.null(version)) 
[08:29:03.379]                             version <- utils::packageVersion("future")
[08:29:03.379]                         }
[08:29:03.379]                         else {
[08:29:03.379]                           version <- NULL
[08:29:03.379]                         }
[08:29:03.379]                         if (!has_future || version < "1.8.0") {
[08:29:03.379]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.379]                             "", base::R.version$version.string), 
[08:29:03.379]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.379]                               "release", "version")], collapse = " "), 
[08:29:03.379]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.379]                             info)
[08:29:03.379]                           info <- base::paste(info, collapse = "; ")
[08:29:03.379]                           if (!has_future) {
[08:29:03.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.379]                               info)
[08:29:03.379]                           }
[08:29:03.379]                           else {
[08:29:03.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.379]                               info, version)
[08:29:03.379]                           }
[08:29:03.379]                           base::stop(msg)
[08:29:03.379]                         }
[08:29:03.379]                       })
[08:29:03.379]                     }
[08:29:03.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.379]                     base::options(mc.cores = 1L)
[08:29:03.379]                   }
[08:29:03.379]                   ...future.strategy.old <- future::plan("list")
[08:29:03.379]                   options(future.plan = NULL)
[08:29:03.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.379]                 }
[08:29:03.379]                 ...future.workdir <- getwd()
[08:29:03.379]             }
[08:29:03.379]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.379]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.379]         }
[08:29:03.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.379]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.379]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.379]             base::names(...future.oldOptions))
[08:29:03.379]     }
[08:29:03.379]     if (FALSE) {
[08:29:03.379]     }
[08:29:03.379]     else {
[08:29:03.379]         if (TRUE) {
[08:29:03.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.379]                 open = "w")
[08:29:03.379]         }
[08:29:03.379]         else {
[08:29:03.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.379]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.379]         }
[08:29:03.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.379]             base::sink(type = "output", split = FALSE)
[08:29:03.379]             base::close(...future.stdout)
[08:29:03.379]         }, add = TRUE)
[08:29:03.379]     }
[08:29:03.379]     ...future.frame <- base::sys.nframe()
[08:29:03.379]     ...future.conditions <- base::list()
[08:29:03.379]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.379]     if (FALSE) {
[08:29:03.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.379]     }
[08:29:03.379]     ...future.result <- base::tryCatch({
[08:29:03.379]         base::withCallingHandlers({
[08:29:03.379]             ...future.value <- base::withVisible(base::local({
[08:29:03.379]                 withCallingHandlers({
[08:29:03.379]                   {
[08:29:03.379]                     2
[08:29:03.379]                   }
[08:29:03.379]                 }, immediateCondition = function(cond) {
[08:29:03.379]                   save_rds <- function (object, pathname, ...) 
[08:29:03.379]                   {
[08:29:03.379]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.379]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.379]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.379]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.379]                         fi_tmp[["mtime"]])
[08:29:03.379]                     }
[08:29:03.379]                     tryCatch({
[08:29:03.379]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.379]                     }, error = function(ex) {
[08:29:03.379]                       msg <- conditionMessage(ex)
[08:29:03.379]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.379]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.379]                         fi_tmp[["mtime"]], msg)
[08:29:03.379]                       ex$message <- msg
[08:29:03.379]                       stop(ex)
[08:29:03.379]                     })
[08:29:03.379]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.379]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.379]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.379]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.379]                       fi <- file.info(pathname)
[08:29:03.379]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.379]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.379]                         fi[["size"]], fi[["mtime"]])
[08:29:03.379]                       stop(msg)
[08:29:03.379]                     }
[08:29:03.379]                     invisible(pathname)
[08:29:03.379]                   }
[08:29:03.379]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.379]                     rootPath = tempdir()) 
[08:29:03.379]                   {
[08:29:03.379]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.379]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.379]                       tmpdir = path, fileext = ".rds")
[08:29:03.379]                     save_rds(obj, file)
[08:29:03.379]                   }
[08:29:03.379]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.379]                   {
[08:29:03.379]                     inherits <- base::inherits
[08:29:03.379]                     invokeRestart <- base::invokeRestart
[08:29:03.379]                     is.null <- base::is.null
[08:29:03.379]                     muffled <- FALSE
[08:29:03.379]                     if (inherits(cond, "message")) {
[08:29:03.379]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.379]                       if (muffled) 
[08:29:03.379]                         invokeRestart("muffleMessage")
[08:29:03.379]                     }
[08:29:03.379]                     else if (inherits(cond, "warning")) {
[08:29:03.379]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.379]                       if (muffled) 
[08:29:03.379]                         invokeRestart("muffleWarning")
[08:29:03.379]                     }
[08:29:03.379]                     else if (inherits(cond, "condition")) {
[08:29:03.379]                       if (!is.null(pattern)) {
[08:29:03.379]                         computeRestarts <- base::computeRestarts
[08:29:03.379]                         grepl <- base::grepl
[08:29:03.379]                         restarts <- computeRestarts(cond)
[08:29:03.379]                         for (restart in restarts) {
[08:29:03.379]                           name <- restart$name
[08:29:03.379]                           if (is.null(name)) 
[08:29:03.379]                             next
[08:29:03.379]                           if (!grepl(pattern, name)) 
[08:29:03.379]                             next
[08:29:03.379]                           invokeRestart(restart)
[08:29:03.379]                           muffled <- TRUE
[08:29:03.379]                           break
[08:29:03.379]                         }
[08:29:03.379]                       }
[08:29:03.379]                     }
[08:29:03.379]                     invisible(muffled)
[08:29:03.379]                   }
[08:29:03.379]                   muffleCondition(cond)
[08:29:03.379]                 })
[08:29:03.379]             }))
[08:29:03.379]             future::FutureResult(value = ...future.value$value, 
[08:29:03.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.379]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.379]                     ...future.globalenv.names))
[08:29:03.379]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.379]         }, condition = base::local({
[08:29:03.379]             c <- base::c
[08:29:03.379]             inherits <- base::inherits
[08:29:03.379]             invokeRestart <- base::invokeRestart
[08:29:03.379]             length <- base::length
[08:29:03.379]             list <- base::list
[08:29:03.379]             seq.int <- base::seq.int
[08:29:03.379]             signalCondition <- base::signalCondition
[08:29:03.379]             sys.calls <- base::sys.calls
[08:29:03.379]             `[[` <- base::`[[`
[08:29:03.379]             `+` <- base::`+`
[08:29:03.379]             `<<-` <- base::`<<-`
[08:29:03.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.379]                   3L)]
[08:29:03.379]             }
[08:29:03.379]             function(cond) {
[08:29:03.379]                 is_error <- inherits(cond, "error")
[08:29:03.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.379]                   NULL)
[08:29:03.379]                 if (is_error) {
[08:29:03.379]                   sessionInformation <- function() {
[08:29:03.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.379]                       search = base::search(), system = base::Sys.info())
[08:29:03.379]                   }
[08:29:03.379]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.379]                     cond$call), session = sessionInformation(), 
[08:29:03.379]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.379]                   signalCondition(cond)
[08:29:03.379]                 }
[08:29:03.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.379]                 "immediateCondition"))) {
[08:29:03.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.379]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.379]                   if (TRUE && !signal) {
[08:29:03.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.379]                     {
[08:29:03.379]                       inherits <- base::inherits
[08:29:03.379]                       invokeRestart <- base::invokeRestart
[08:29:03.379]                       is.null <- base::is.null
[08:29:03.379]                       muffled <- FALSE
[08:29:03.379]                       if (inherits(cond, "message")) {
[08:29:03.379]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.379]                         if (muffled) 
[08:29:03.379]                           invokeRestart("muffleMessage")
[08:29:03.379]                       }
[08:29:03.379]                       else if (inherits(cond, "warning")) {
[08:29:03.379]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.379]                         if (muffled) 
[08:29:03.379]                           invokeRestart("muffleWarning")
[08:29:03.379]                       }
[08:29:03.379]                       else if (inherits(cond, "condition")) {
[08:29:03.379]                         if (!is.null(pattern)) {
[08:29:03.379]                           computeRestarts <- base::computeRestarts
[08:29:03.379]                           grepl <- base::grepl
[08:29:03.379]                           restarts <- computeRestarts(cond)
[08:29:03.379]                           for (restart in restarts) {
[08:29:03.379]                             name <- restart$name
[08:29:03.379]                             if (is.null(name)) 
[08:29:03.379]                               next
[08:29:03.379]                             if (!grepl(pattern, name)) 
[08:29:03.379]                               next
[08:29:03.379]                             invokeRestart(restart)
[08:29:03.379]                             muffled <- TRUE
[08:29:03.379]                             break
[08:29:03.379]                           }
[08:29:03.379]                         }
[08:29:03.379]                       }
[08:29:03.379]                       invisible(muffled)
[08:29:03.379]                     }
[08:29:03.379]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.379]                   }
[08:29:03.379]                 }
[08:29:03.379]                 else {
[08:29:03.379]                   if (TRUE) {
[08:29:03.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.379]                     {
[08:29:03.379]                       inherits <- base::inherits
[08:29:03.379]                       invokeRestart <- base::invokeRestart
[08:29:03.379]                       is.null <- base::is.null
[08:29:03.379]                       muffled <- FALSE
[08:29:03.379]                       if (inherits(cond, "message")) {
[08:29:03.379]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.379]                         if (muffled) 
[08:29:03.379]                           invokeRestart("muffleMessage")
[08:29:03.379]                       }
[08:29:03.379]                       else if (inherits(cond, "warning")) {
[08:29:03.379]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.379]                         if (muffled) 
[08:29:03.379]                           invokeRestart("muffleWarning")
[08:29:03.379]                       }
[08:29:03.379]                       else if (inherits(cond, "condition")) {
[08:29:03.379]                         if (!is.null(pattern)) {
[08:29:03.379]                           computeRestarts <- base::computeRestarts
[08:29:03.379]                           grepl <- base::grepl
[08:29:03.379]                           restarts <- computeRestarts(cond)
[08:29:03.379]                           for (restart in restarts) {
[08:29:03.379]                             name <- restart$name
[08:29:03.379]                             if (is.null(name)) 
[08:29:03.379]                               next
[08:29:03.379]                             if (!grepl(pattern, name)) 
[08:29:03.379]                               next
[08:29:03.379]                             invokeRestart(restart)
[08:29:03.379]                             muffled <- TRUE
[08:29:03.379]                             break
[08:29:03.379]                           }
[08:29:03.379]                         }
[08:29:03.379]                       }
[08:29:03.379]                       invisible(muffled)
[08:29:03.379]                     }
[08:29:03.379]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.379]                   }
[08:29:03.379]                 }
[08:29:03.379]             }
[08:29:03.379]         }))
[08:29:03.379]     }, error = function(ex) {
[08:29:03.379]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.379]                 ...future.rng), started = ...future.startTime, 
[08:29:03.379]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.379]             version = "1.8"), class = "FutureResult")
[08:29:03.379]     }, finally = {
[08:29:03.379]         if (!identical(...future.workdir, getwd())) 
[08:29:03.379]             setwd(...future.workdir)
[08:29:03.379]         {
[08:29:03.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.379]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.379]             }
[08:29:03.379]             base::options(...future.oldOptions)
[08:29:03.379]             if (.Platform$OS.type == "windows") {
[08:29:03.379]                 old_names <- names(...future.oldEnvVars)
[08:29:03.379]                 envs <- base::Sys.getenv()
[08:29:03.379]                 names <- names(envs)
[08:29:03.379]                 common <- intersect(names, old_names)
[08:29:03.379]                 added <- setdiff(names, old_names)
[08:29:03.379]                 removed <- setdiff(old_names, names)
[08:29:03.379]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.379]                   envs[common]]
[08:29:03.379]                 NAMES <- toupper(changed)
[08:29:03.379]                 args <- list()
[08:29:03.379]                 for (kk in seq_along(NAMES)) {
[08:29:03.379]                   name <- changed[[kk]]
[08:29:03.379]                   NAME <- NAMES[[kk]]
[08:29:03.379]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.379]                     next
[08:29:03.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.379]                 }
[08:29:03.379]                 NAMES <- toupper(added)
[08:29:03.379]                 for (kk in seq_along(NAMES)) {
[08:29:03.379]                   name <- added[[kk]]
[08:29:03.379]                   NAME <- NAMES[[kk]]
[08:29:03.379]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.379]                     next
[08:29:03.379]                   args[[name]] <- ""
[08:29:03.379]                 }
[08:29:03.379]                 NAMES <- toupper(removed)
[08:29:03.379]                 for (kk in seq_along(NAMES)) {
[08:29:03.379]                   name <- removed[[kk]]
[08:29:03.379]                   NAME <- NAMES[[kk]]
[08:29:03.379]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.379]                     next
[08:29:03.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.379]                 }
[08:29:03.379]                 if (length(args) > 0) 
[08:29:03.379]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.379]             }
[08:29:03.379]             else {
[08:29:03.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.379]             }
[08:29:03.379]             {
[08:29:03.379]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.379]                   0L) {
[08:29:03.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.379]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.379]                   base::options(opts)
[08:29:03.379]                 }
[08:29:03.379]                 {
[08:29:03.379]                   {
[08:29:03.379]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.379]                     NULL
[08:29:03.379]                   }
[08:29:03.379]                   options(future.plan = NULL)
[08:29:03.379]                   if (is.na(NA_character_)) 
[08:29:03.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.379]                     .init = FALSE)
[08:29:03.379]                 }
[08:29:03.379]             }
[08:29:03.379]         }
[08:29:03.379]     })
[08:29:03.379]     if (TRUE) {
[08:29:03.379]         base::sink(type = "output", split = FALSE)
[08:29:03.379]         if (TRUE) {
[08:29:03.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.379]         }
[08:29:03.379]         else {
[08:29:03.379]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.379]         }
[08:29:03.379]         base::close(...future.stdout)
[08:29:03.379]         ...future.stdout <- NULL
[08:29:03.379]     }
[08:29:03.379]     ...future.result$conditions <- ...future.conditions
[08:29:03.379]     ...future.result$finished <- base::Sys.time()
[08:29:03.379]     ...future.result
[08:29:03.379] }
[08:29:03.382] requestCore(): workers = 2
[08:29:03.382] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.393] result() for MulticoreFuture ...
[08:29:03.393] result() for MulticoreFuture ...
[08:29:03.394] result() for MulticoreFuture ... done
[08:29:03.394] result() for MulticoreFuture ... done
[08:29:03.394] result() for MulticoreFuture ...
[08:29:03.394] result() for MulticoreFuture ... done
[08:29:03.396] MulticoreFuture started
[08:29:03.397] - Launch lazy future ... done
[08:29:03.397] run() for ‘MulticoreFuture’ ... done
[08:29:03.398] plan(): Setting new future strategy stack:
[08:29:03.399] resolve() on list environment ...
[08:29:03.398] List of future strategies:
[08:29:03.398] 1. sequential:
[08:29:03.398]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.398]    - tweaked: FALSE
[08:29:03.398]    - call: NULL
[08:29:03.399]  recursive: 0
[08:29:03.399] plan(): nbrOfWorkers() = 1
[08:29:03.400]  length: 3
[08:29:03.401]  elements: ‘a’, ‘b’, ‘c’
[08:29:03.401] Future #1
[08:29:03.402]  length: 2 (resolved future 1)
[08:29:03.402] plan(): Setting new future strategy stack:
[08:29:03.402] List of future strategies:
[08:29:03.402] 1. multicore:
[08:29:03.402]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.402]    - tweaked: FALSE
[08:29:03.402]    - call: plan(strategy)
[08:29:03.405] plan(): nbrOfWorkers() = 2
[08:29:03.406] Future #2
[08:29:03.406]  length: 1 (resolved future 2)
[08:29:03.406]  length: 0 (resolved future 3)
[08:29:03.406] resolve() on list environment ... DONE
[08:29:03.407] getGlobalsAndPackages() ...
[08:29:03.407] Searching for globals...
[08:29:03.408] - globals found: [1] ‘{’
[08:29:03.409] Searching for globals ... DONE
[08:29:03.409] Resolving globals: FALSE
[08:29:03.409] 
[08:29:03.410] 
[08:29:03.410] getGlobalsAndPackages() ... DONE
[08:29:03.410] run() for ‘Future’ ...
[08:29:03.410] - state: ‘created’
[08:29:03.411] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.413] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.413] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.413]   - Field: ‘label’
[08:29:03.413]   - Field: ‘local’
[08:29:03.414]   - Field: ‘owner’
[08:29:03.414]   - Field: ‘envir’
[08:29:03.414]   - Field: ‘workers’
[08:29:03.414]   - Field: ‘packages’
[08:29:03.414]   - Field: ‘gc’
[08:29:03.414]   - Field: ‘job’
[08:29:03.414]   - Field: ‘conditions’
[08:29:03.415]   - Field: ‘expr’
[08:29:03.415]   - Field: ‘uuid’
[08:29:03.415]   - Field: ‘seed’
[08:29:03.415]   - Field: ‘version’
[08:29:03.415]   - Field: ‘result’
[08:29:03.415]   - Field: ‘asynchronous’
[08:29:03.415]   - Field: ‘calls’
[08:29:03.415]   - Field: ‘globals’
[08:29:03.416]   - Field: ‘stdout’
[08:29:03.416]   - Field: ‘earlySignal’
[08:29:03.416]   - Field: ‘lazy’
[08:29:03.416]   - Field: ‘state’
[08:29:03.416] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.416] - Launch lazy future ...
[08:29:03.417] Packages needed by the future expression (n = 0): <none>
[08:29:03.417] Packages needed by future strategies (n = 0): <none>
[08:29:03.417] {
[08:29:03.417]     {
[08:29:03.417]         {
[08:29:03.417]             ...future.startTime <- base::Sys.time()
[08:29:03.417]             {
[08:29:03.417]                 {
[08:29:03.417]                   {
[08:29:03.417]                     {
[08:29:03.417]                       base::local({
[08:29:03.417]                         has_future <- base::requireNamespace("future", 
[08:29:03.417]                           quietly = TRUE)
[08:29:03.417]                         if (has_future) {
[08:29:03.417]                           ns <- base::getNamespace("future")
[08:29:03.417]                           version <- ns[[".package"]][["version"]]
[08:29:03.417]                           if (is.null(version)) 
[08:29:03.417]                             version <- utils::packageVersion("future")
[08:29:03.417]                         }
[08:29:03.417]                         else {
[08:29:03.417]                           version <- NULL
[08:29:03.417]                         }
[08:29:03.417]                         if (!has_future || version < "1.8.0") {
[08:29:03.417]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.417]                             "", base::R.version$version.string), 
[08:29:03.417]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.417]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.417]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.417]                               "release", "version")], collapse = " "), 
[08:29:03.417]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.417]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.417]                             info)
[08:29:03.417]                           info <- base::paste(info, collapse = "; ")
[08:29:03.417]                           if (!has_future) {
[08:29:03.417]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.417]                               info)
[08:29:03.417]                           }
[08:29:03.417]                           else {
[08:29:03.417]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.417]                               info, version)
[08:29:03.417]                           }
[08:29:03.417]                           base::stop(msg)
[08:29:03.417]                         }
[08:29:03.417]                       })
[08:29:03.417]                     }
[08:29:03.417]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.417]                     base::options(mc.cores = 1L)
[08:29:03.417]                   }
[08:29:03.417]                   ...future.strategy.old <- future::plan("list")
[08:29:03.417]                   options(future.plan = NULL)
[08:29:03.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.417]                 }
[08:29:03.417]                 ...future.workdir <- getwd()
[08:29:03.417]             }
[08:29:03.417]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.417]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.417]         }
[08:29:03.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.417]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.417]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.417]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.417]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.417]             base::names(...future.oldOptions))
[08:29:03.417]     }
[08:29:03.417]     if (FALSE) {
[08:29:03.417]     }
[08:29:03.417]     else {
[08:29:03.417]         if (TRUE) {
[08:29:03.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.417]                 open = "w")
[08:29:03.417]         }
[08:29:03.417]         else {
[08:29:03.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.417]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.417]         }
[08:29:03.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.417]             base::sink(type = "output", split = FALSE)
[08:29:03.417]             base::close(...future.stdout)
[08:29:03.417]         }, add = TRUE)
[08:29:03.417]     }
[08:29:03.417]     ...future.frame <- base::sys.nframe()
[08:29:03.417]     ...future.conditions <- base::list()
[08:29:03.417]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.417]     if (FALSE) {
[08:29:03.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.417]     }
[08:29:03.417]     ...future.result <- base::tryCatch({
[08:29:03.417]         base::withCallingHandlers({
[08:29:03.417]             ...future.value <- base::withVisible(base::local({
[08:29:03.417]                 withCallingHandlers({
[08:29:03.417]                   {
[08:29:03.417]                     1
[08:29:03.417]                   }
[08:29:03.417]                 }, immediateCondition = function(cond) {
[08:29:03.417]                   save_rds <- function (object, pathname, ...) 
[08:29:03.417]                   {
[08:29:03.417]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.417]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.417]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.417]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.417]                         fi_tmp[["mtime"]])
[08:29:03.417]                     }
[08:29:03.417]                     tryCatch({
[08:29:03.417]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.417]                     }, error = function(ex) {
[08:29:03.417]                       msg <- conditionMessage(ex)
[08:29:03.417]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.417]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.417]                         fi_tmp[["mtime"]], msg)
[08:29:03.417]                       ex$message <- msg
[08:29:03.417]                       stop(ex)
[08:29:03.417]                     })
[08:29:03.417]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.417]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.417]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.417]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.417]                       fi <- file.info(pathname)
[08:29:03.417]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.417]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.417]                         fi[["size"]], fi[["mtime"]])
[08:29:03.417]                       stop(msg)
[08:29:03.417]                     }
[08:29:03.417]                     invisible(pathname)
[08:29:03.417]                   }
[08:29:03.417]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.417]                     rootPath = tempdir()) 
[08:29:03.417]                   {
[08:29:03.417]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.417]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.417]                       tmpdir = path, fileext = ".rds")
[08:29:03.417]                     save_rds(obj, file)
[08:29:03.417]                   }
[08:29:03.417]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.417]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.417]                   {
[08:29:03.417]                     inherits <- base::inherits
[08:29:03.417]                     invokeRestart <- base::invokeRestart
[08:29:03.417]                     is.null <- base::is.null
[08:29:03.417]                     muffled <- FALSE
[08:29:03.417]                     if (inherits(cond, "message")) {
[08:29:03.417]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.417]                       if (muffled) 
[08:29:03.417]                         invokeRestart("muffleMessage")
[08:29:03.417]                     }
[08:29:03.417]                     else if (inherits(cond, "warning")) {
[08:29:03.417]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.417]                       if (muffled) 
[08:29:03.417]                         invokeRestart("muffleWarning")
[08:29:03.417]                     }
[08:29:03.417]                     else if (inherits(cond, "condition")) {
[08:29:03.417]                       if (!is.null(pattern)) {
[08:29:03.417]                         computeRestarts <- base::computeRestarts
[08:29:03.417]                         grepl <- base::grepl
[08:29:03.417]                         restarts <- computeRestarts(cond)
[08:29:03.417]                         for (restart in restarts) {
[08:29:03.417]                           name <- restart$name
[08:29:03.417]                           if (is.null(name)) 
[08:29:03.417]                             next
[08:29:03.417]                           if (!grepl(pattern, name)) 
[08:29:03.417]                             next
[08:29:03.417]                           invokeRestart(restart)
[08:29:03.417]                           muffled <- TRUE
[08:29:03.417]                           break
[08:29:03.417]                         }
[08:29:03.417]                       }
[08:29:03.417]                     }
[08:29:03.417]                     invisible(muffled)
[08:29:03.417]                   }
[08:29:03.417]                   muffleCondition(cond)
[08:29:03.417]                 })
[08:29:03.417]             }))
[08:29:03.417]             future::FutureResult(value = ...future.value$value, 
[08:29:03.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.417]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.417]                     ...future.globalenv.names))
[08:29:03.417]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.417]         }, condition = base::local({
[08:29:03.417]             c <- base::c
[08:29:03.417]             inherits <- base::inherits
[08:29:03.417]             invokeRestart <- base::invokeRestart
[08:29:03.417]             length <- base::length
[08:29:03.417]             list <- base::list
[08:29:03.417]             seq.int <- base::seq.int
[08:29:03.417]             signalCondition <- base::signalCondition
[08:29:03.417]             sys.calls <- base::sys.calls
[08:29:03.417]             `[[` <- base::`[[`
[08:29:03.417]             `+` <- base::`+`
[08:29:03.417]             `<<-` <- base::`<<-`
[08:29:03.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.417]                   3L)]
[08:29:03.417]             }
[08:29:03.417]             function(cond) {
[08:29:03.417]                 is_error <- inherits(cond, "error")
[08:29:03.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.417]                   NULL)
[08:29:03.417]                 if (is_error) {
[08:29:03.417]                   sessionInformation <- function() {
[08:29:03.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.417]                       search = base::search(), system = base::Sys.info())
[08:29:03.417]                   }
[08:29:03.417]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.417]                     cond$call), session = sessionInformation(), 
[08:29:03.417]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.417]                   signalCondition(cond)
[08:29:03.417]                 }
[08:29:03.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.417]                 "immediateCondition"))) {
[08:29:03.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.417]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.417]                   if (TRUE && !signal) {
[08:29:03.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.417]                     {
[08:29:03.417]                       inherits <- base::inherits
[08:29:03.417]                       invokeRestart <- base::invokeRestart
[08:29:03.417]                       is.null <- base::is.null
[08:29:03.417]                       muffled <- FALSE
[08:29:03.417]                       if (inherits(cond, "message")) {
[08:29:03.417]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.417]                         if (muffled) 
[08:29:03.417]                           invokeRestart("muffleMessage")
[08:29:03.417]                       }
[08:29:03.417]                       else if (inherits(cond, "warning")) {
[08:29:03.417]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.417]                         if (muffled) 
[08:29:03.417]                           invokeRestart("muffleWarning")
[08:29:03.417]                       }
[08:29:03.417]                       else if (inherits(cond, "condition")) {
[08:29:03.417]                         if (!is.null(pattern)) {
[08:29:03.417]                           computeRestarts <- base::computeRestarts
[08:29:03.417]                           grepl <- base::grepl
[08:29:03.417]                           restarts <- computeRestarts(cond)
[08:29:03.417]                           for (restart in restarts) {
[08:29:03.417]                             name <- restart$name
[08:29:03.417]                             if (is.null(name)) 
[08:29:03.417]                               next
[08:29:03.417]                             if (!grepl(pattern, name)) 
[08:29:03.417]                               next
[08:29:03.417]                             invokeRestart(restart)
[08:29:03.417]                             muffled <- TRUE
[08:29:03.417]                             break
[08:29:03.417]                           }
[08:29:03.417]                         }
[08:29:03.417]                       }
[08:29:03.417]                       invisible(muffled)
[08:29:03.417]                     }
[08:29:03.417]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.417]                   }
[08:29:03.417]                 }
[08:29:03.417]                 else {
[08:29:03.417]                   if (TRUE) {
[08:29:03.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.417]                     {
[08:29:03.417]                       inherits <- base::inherits
[08:29:03.417]                       invokeRestart <- base::invokeRestart
[08:29:03.417]                       is.null <- base::is.null
[08:29:03.417]                       muffled <- FALSE
[08:29:03.417]                       if (inherits(cond, "message")) {
[08:29:03.417]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.417]                         if (muffled) 
[08:29:03.417]                           invokeRestart("muffleMessage")
[08:29:03.417]                       }
[08:29:03.417]                       else if (inherits(cond, "warning")) {
[08:29:03.417]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.417]                         if (muffled) 
[08:29:03.417]                           invokeRestart("muffleWarning")
[08:29:03.417]                       }
[08:29:03.417]                       else if (inherits(cond, "condition")) {
[08:29:03.417]                         if (!is.null(pattern)) {
[08:29:03.417]                           computeRestarts <- base::computeRestarts
[08:29:03.417]                           grepl <- base::grepl
[08:29:03.417]                           restarts <- computeRestarts(cond)
[08:29:03.417]                           for (restart in restarts) {
[08:29:03.417]                             name <- restart$name
[08:29:03.417]                             if (is.null(name)) 
[08:29:03.417]                               next
[08:29:03.417]                             if (!grepl(pattern, name)) 
[08:29:03.417]                               next
[08:29:03.417]                             invokeRestart(restart)
[08:29:03.417]                             muffled <- TRUE
[08:29:03.417]                             break
[08:29:03.417]                           }
[08:29:03.417]                         }
[08:29:03.417]                       }
[08:29:03.417]                       invisible(muffled)
[08:29:03.417]                     }
[08:29:03.417]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.417]                   }
[08:29:03.417]                 }
[08:29:03.417]             }
[08:29:03.417]         }))
[08:29:03.417]     }, error = function(ex) {
[08:29:03.417]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.417]                 ...future.rng), started = ...future.startTime, 
[08:29:03.417]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.417]             version = "1.8"), class = "FutureResult")
[08:29:03.417]     }, finally = {
[08:29:03.417]         if (!identical(...future.workdir, getwd())) 
[08:29:03.417]             setwd(...future.workdir)
[08:29:03.417]         {
[08:29:03.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.417]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.417]             }
[08:29:03.417]             base::options(...future.oldOptions)
[08:29:03.417]             if (.Platform$OS.type == "windows") {
[08:29:03.417]                 old_names <- names(...future.oldEnvVars)
[08:29:03.417]                 envs <- base::Sys.getenv()
[08:29:03.417]                 names <- names(envs)
[08:29:03.417]                 common <- intersect(names, old_names)
[08:29:03.417]                 added <- setdiff(names, old_names)
[08:29:03.417]                 removed <- setdiff(old_names, names)
[08:29:03.417]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.417]                   envs[common]]
[08:29:03.417]                 NAMES <- toupper(changed)
[08:29:03.417]                 args <- list()
[08:29:03.417]                 for (kk in seq_along(NAMES)) {
[08:29:03.417]                   name <- changed[[kk]]
[08:29:03.417]                   NAME <- NAMES[[kk]]
[08:29:03.417]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.417]                     next
[08:29:03.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.417]                 }
[08:29:03.417]                 NAMES <- toupper(added)
[08:29:03.417]                 for (kk in seq_along(NAMES)) {
[08:29:03.417]                   name <- added[[kk]]
[08:29:03.417]                   NAME <- NAMES[[kk]]
[08:29:03.417]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.417]                     next
[08:29:03.417]                   args[[name]] <- ""
[08:29:03.417]                 }
[08:29:03.417]                 NAMES <- toupper(removed)
[08:29:03.417]                 for (kk in seq_along(NAMES)) {
[08:29:03.417]                   name <- removed[[kk]]
[08:29:03.417]                   NAME <- NAMES[[kk]]
[08:29:03.417]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.417]                     next
[08:29:03.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.417]                 }
[08:29:03.417]                 if (length(args) > 0) 
[08:29:03.417]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.417]             }
[08:29:03.417]             else {
[08:29:03.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.417]             }
[08:29:03.417]             {
[08:29:03.417]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.417]                   0L) {
[08:29:03.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.417]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.417]                   base::options(opts)
[08:29:03.417]                 }
[08:29:03.417]                 {
[08:29:03.417]                   {
[08:29:03.417]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.417]                     NULL
[08:29:03.417]                   }
[08:29:03.417]                   options(future.plan = NULL)
[08:29:03.417]                   if (is.na(NA_character_)) 
[08:29:03.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.417]                     .init = FALSE)
[08:29:03.417]                 }
[08:29:03.417]             }
[08:29:03.417]         }
[08:29:03.417]     })
[08:29:03.417]     if (TRUE) {
[08:29:03.417]         base::sink(type = "output", split = FALSE)
[08:29:03.417]         if (TRUE) {
[08:29:03.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.417]         }
[08:29:03.417]         else {
[08:29:03.417]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.417]         }
[08:29:03.417]         base::close(...future.stdout)
[08:29:03.417]         ...future.stdout <- NULL
[08:29:03.417]     }
[08:29:03.417]     ...future.result$conditions <- ...future.conditions
[08:29:03.417]     ...future.result$finished <- base::Sys.time()
[08:29:03.417]     ...future.result
[08:29:03.417] }
[08:29:03.421] requestCore(): workers = 2
[08:29:03.421] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.432] result() for MulticoreFuture ...
[08:29:03.433] result() for MulticoreFuture ...
[08:29:03.433] result() for MulticoreFuture ... done
[08:29:03.433] result() for MulticoreFuture ... done
[08:29:03.434] result() for MulticoreFuture ...
[08:29:03.434] result() for MulticoreFuture ... done
[08:29:03.436] MulticoreFuture started
[08:29:03.437] - Launch lazy future ... done
[08:29:03.437] run() for ‘MulticoreFuture’ ... done
[08:29:03.437] plan(): Setting new future strategy stack:
[08:29:03.438] getGlobalsAndPackages() ...
[08:29:03.438] Searching for globals...
[08:29:03.438] List of future strategies:
[08:29:03.438] 1. sequential:
[08:29:03.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.438]    - tweaked: FALSE
[08:29:03.438]    - call: NULL
[08:29:03.439] plan(): nbrOfWorkers() = 1
[08:29:03.440] - globals found: [2] ‘{’, ‘Sys.sleep’
[08:29:03.440] Searching for globals ... DONE
[08:29:03.441] Resolving globals: FALSE
[08:29:03.441] plan(): Setting new future strategy stack:
[08:29:03.441] 
[08:29:03.441] List of future strategies:
[08:29:03.441] 1. multicore:
[08:29:03.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.441]    - tweaked: FALSE
[08:29:03.441]    - call: plan(strategy)
[08:29:03.441] 
[08:29:03.441] getGlobalsAndPackages() ... DONE
[08:29:03.442] run() for ‘Future’ ...
[08:29:03.442] - state: ‘created’
[08:29:03.442] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.444] plan(): nbrOfWorkers() = 2
[08:29:03.450] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.450] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.450]   - Field: ‘label’
[08:29:03.451]   - Field: ‘local’
[08:29:03.451]   - Field: ‘owner’
[08:29:03.452]   - Field: ‘envir’
[08:29:03.452]   - Field: ‘workers’
[08:29:03.452]   - Field: ‘packages’
[08:29:03.453]   - Field: ‘gc’
[08:29:03.453]   - Field: ‘job’
[08:29:03.453]   - Field: ‘conditions’
[08:29:03.453]   - Field: ‘expr’
[08:29:03.453]   - Field: ‘uuid’
[08:29:03.454]   - Field: ‘seed’
[08:29:03.454]   - Field: ‘version’
[08:29:03.454]   - Field: ‘result’
[08:29:03.454]   - Field: ‘asynchronous’
[08:29:03.454]   - Field: ‘calls’
[08:29:03.454]   - Field: ‘globals’
[08:29:03.455]   - Field: ‘stdout’
[08:29:03.455]   - Field: ‘earlySignal’
[08:29:03.455]   - Field: ‘lazy’
[08:29:03.455]   - Field: ‘state’
[08:29:03.455] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.455] - Launch lazy future ...
[08:29:03.456] Packages needed by the future expression (n = 0): <none>
[08:29:03.456] Packages needed by future strategies (n = 0): <none>
[08:29:03.457] {
[08:29:03.457]     {
[08:29:03.457]         {
[08:29:03.457]             ...future.startTime <- base::Sys.time()
[08:29:03.457]             {
[08:29:03.457]                 {
[08:29:03.457]                   {
[08:29:03.457]                     {
[08:29:03.457]                       base::local({
[08:29:03.457]                         has_future <- base::requireNamespace("future", 
[08:29:03.457]                           quietly = TRUE)
[08:29:03.457]                         if (has_future) {
[08:29:03.457]                           ns <- base::getNamespace("future")
[08:29:03.457]                           version <- ns[[".package"]][["version"]]
[08:29:03.457]                           if (is.null(version)) 
[08:29:03.457]                             version <- utils::packageVersion("future")
[08:29:03.457]                         }
[08:29:03.457]                         else {
[08:29:03.457]                           version <- NULL
[08:29:03.457]                         }
[08:29:03.457]                         if (!has_future || version < "1.8.0") {
[08:29:03.457]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.457]                             "", base::R.version$version.string), 
[08:29:03.457]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.457]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.457]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.457]                               "release", "version")], collapse = " "), 
[08:29:03.457]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.457]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.457]                             info)
[08:29:03.457]                           info <- base::paste(info, collapse = "; ")
[08:29:03.457]                           if (!has_future) {
[08:29:03.457]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.457]                               info)
[08:29:03.457]                           }
[08:29:03.457]                           else {
[08:29:03.457]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.457]                               info, version)
[08:29:03.457]                           }
[08:29:03.457]                           base::stop(msg)
[08:29:03.457]                         }
[08:29:03.457]                       })
[08:29:03.457]                     }
[08:29:03.457]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.457]                     base::options(mc.cores = 1L)
[08:29:03.457]                   }
[08:29:03.457]                   ...future.strategy.old <- future::plan("list")
[08:29:03.457]                   options(future.plan = NULL)
[08:29:03.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.457]                 }
[08:29:03.457]                 ...future.workdir <- getwd()
[08:29:03.457]             }
[08:29:03.457]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.457]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.457]         }
[08:29:03.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.457]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.457]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.457]             base::names(...future.oldOptions))
[08:29:03.457]     }
[08:29:03.457]     if (FALSE) {
[08:29:03.457]     }
[08:29:03.457]     else {
[08:29:03.457]         if (TRUE) {
[08:29:03.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.457]                 open = "w")
[08:29:03.457]         }
[08:29:03.457]         else {
[08:29:03.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.457]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.457]         }
[08:29:03.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.457]             base::sink(type = "output", split = FALSE)
[08:29:03.457]             base::close(...future.stdout)
[08:29:03.457]         }, add = TRUE)
[08:29:03.457]     }
[08:29:03.457]     ...future.frame <- base::sys.nframe()
[08:29:03.457]     ...future.conditions <- base::list()
[08:29:03.457]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.457]     if (FALSE) {
[08:29:03.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.457]     }
[08:29:03.457]     ...future.result <- base::tryCatch({
[08:29:03.457]         base::withCallingHandlers({
[08:29:03.457]             ...future.value <- base::withVisible(base::local({
[08:29:03.457]                 withCallingHandlers({
[08:29:03.457]                   {
[08:29:03.457]                     Sys.sleep(0.5)
[08:29:03.457]                     2
[08:29:03.457]                   }
[08:29:03.457]                 }, immediateCondition = function(cond) {
[08:29:03.457]                   save_rds <- function (object, pathname, ...) 
[08:29:03.457]                   {
[08:29:03.457]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.457]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.457]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.457]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.457]                         fi_tmp[["mtime"]])
[08:29:03.457]                     }
[08:29:03.457]                     tryCatch({
[08:29:03.457]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.457]                     }, error = function(ex) {
[08:29:03.457]                       msg <- conditionMessage(ex)
[08:29:03.457]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.457]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.457]                         fi_tmp[["mtime"]], msg)
[08:29:03.457]                       ex$message <- msg
[08:29:03.457]                       stop(ex)
[08:29:03.457]                     })
[08:29:03.457]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.457]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.457]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.457]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.457]                       fi <- file.info(pathname)
[08:29:03.457]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.457]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.457]                         fi[["size"]], fi[["mtime"]])
[08:29:03.457]                       stop(msg)
[08:29:03.457]                     }
[08:29:03.457]                     invisible(pathname)
[08:29:03.457]                   }
[08:29:03.457]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.457]                     rootPath = tempdir()) 
[08:29:03.457]                   {
[08:29:03.457]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.457]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.457]                       tmpdir = path, fileext = ".rds")
[08:29:03.457]                     save_rds(obj, file)
[08:29:03.457]                   }
[08:29:03.457]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.457]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.457]                   {
[08:29:03.457]                     inherits <- base::inherits
[08:29:03.457]                     invokeRestart <- base::invokeRestart
[08:29:03.457]                     is.null <- base::is.null
[08:29:03.457]                     muffled <- FALSE
[08:29:03.457]                     if (inherits(cond, "message")) {
[08:29:03.457]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.457]                       if (muffled) 
[08:29:03.457]                         invokeRestart("muffleMessage")
[08:29:03.457]                     }
[08:29:03.457]                     else if (inherits(cond, "warning")) {
[08:29:03.457]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.457]                       if (muffled) 
[08:29:03.457]                         invokeRestart("muffleWarning")
[08:29:03.457]                     }
[08:29:03.457]                     else if (inherits(cond, "condition")) {
[08:29:03.457]                       if (!is.null(pattern)) {
[08:29:03.457]                         computeRestarts <- base::computeRestarts
[08:29:03.457]                         grepl <- base::grepl
[08:29:03.457]                         restarts <- computeRestarts(cond)
[08:29:03.457]                         for (restart in restarts) {
[08:29:03.457]                           name <- restart$name
[08:29:03.457]                           if (is.null(name)) 
[08:29:03.457]                             next
[08:29:03.457]                           if (!grepl(pattern, name)) 
[08:29:03.457]                             next
[08:29:03.457]                           invokeRestart(restart)
[08:29:03.457]                           muffled <- TRUE
[08:29:03.457]                           break
[08:29:03.457]                         }
[08:29:03.457]                       }
[08:29:03.457]                     }
[08:29:03.457]                     invisible(muffled)
[08:29:03.457]                   }
[08:29:03.457]                   muffleCondition(cond)
[08:29:03.457]                 })
[08:29:03.457]             }))
[08:29:03.457]             future::FutureResult(value = ...future.value$value, 
[08:29:03.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.457]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.457]                     ...future.globalenv.names))
[08:29:03.457]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.457]         }, condition = base::local({
[08:29:03.457]             c <- base::c
[08:29:03.457]             inherits <- base::inherits
[08:29:03.457]             invokeRestart <- base::invokeRestart
[08:29:03.457]             length <- base::length
[08:29:03.457]             list <- base::list
[08:29:03.457]             seq.int <- base::seq.int
[08:29:03.457]             signalCondition <- base::signalCondition
[08:29:03.457]             sys.calls <- base::sys.calls
[08:29:03.457]             `[[` <- base::`[[`
[08:29:03.457]             `+` <- base::`+`
[08:29:03.457]             `<<-` <- base::`<<-`
[08:29:03.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.457]                   3L)]
[08:29:03.457]             }
[08:29:03.457]             function(cond) {
[08:29:03.457]                 is_error <- inherits(cond, "error")
[08:29:03.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.457]                   NULL)
[08:29:03.457]                 if (is_error) {
[08:29:03.457]                   sessionInformation <- function() {
[08:29:03.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.457]                       search = base::search(), system = base::Sys.info())
[08:29:03.457]                   }
[08:29:03.457]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.457]                     cond$call), session = sessionInformation(), 
[08:29:03.457]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.457]                   signalCondition(cond)
[08:29:03.457]                 }
[08:29:03.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.457]                 "immediateCondition"))) {
[08:29:03.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.457]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.457]                   if (TRUE && !signal) {
[08:29:03.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.457]                     {
[08:29:03.457]                       inherits <- base::inherits
[08:29:03.457]                       invokeRestart <- base::invokeRestart
[08:29:03.457]                       is.null <- base::is.null
[08:29:03.457]                       muffled <- FALSE
[08:29:03.457]                       if (inherits(cond, "message")) {
[08:29:03.457]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.457]                         if (muffled) 
[08:29:03.457]                           invokeRestart("muffleMessage")
[08:29:03.457]                       }
[08:29:03.457]                       else if (inherits(cond, "warning")) {
[08:29:03.457]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.457]                         if (muffled) 
[08:29:03.457]                           invokeRestart("muffleWarning")
[08:29:03.457]                       }
[08:29:03.457]                       else if (inherits(cond, "condition")) {
[08:29:03.457]                         if (!is.null(pattern)) {
[08:29:03.457]                           computeRestarts <- base::computeRestarts
[08:29:03.457]                           grepl <- base::grepl
[08:29:03.457]                           restarts <- computeRestarts(cond)
[08:29:03.457]                           for (restart in restarts) {
[08:29:03.457]                             name <- restart$name
[08:29:03.457]                             if (is.null(name)) 
[08:29:03.457]                               next
[08:29:03.457]                             if (!grepl(pattern, name)) 
[08:29:03.457]                               next
[08:29:03.457]                             invokeRestart(restart)
[08:29:03.457]                             muffled <- TRUE
[08:29:03.457]                             break
[08:29:03.457]                           }
[08:29:03.457]                         }
[08:29:03.457]                       }
[08:29:03.457]                       invisible(muffled)
[08:29:03.457]                     }
[08:29:03.457]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.457]                   }
[08:29:03.457]                 }
[08:29:03.457]                 else {
[08:29:03.457]                   if (TRUE) {
[08:29:03.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.457]                     {
[08:29:03.457]                       inherits <- base::inherits
[08:29:03.457]                       invokeRestart <- base::invokeRestart
[08:29:03.457]                       is.null <- base::is.null
[08:29:03.457]                       muffled <- FALSE
[08:29:03.457]                       if (inherits(cond, "message")) {
[08:29:03.457]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.457]                         if (muffled) 
[08:29:03.457]                           invokeRestart("muffleMessage")
[08:29:03.457]                       }
[08:29:03.457]                       else if (inherits(cond, "warning")) {
[08:29:03.457]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.457]                         if (muffled) 
[08:29:03.457]                           invokeRestart("muffleWarning")
[08:29:03.457]                       }
[08:29:03.457]                       else if (inherits(cond, "condition")) {
[08:29:03.457]                         if (!is.null(pattern)) {
[08:29:03.457]                           computeRestarts <- base::computeRestarts
[08:29:03.457]                           grepl <- base::grepl
[08:29:03.457]                           restarts <- computeRestarts(cond)
[08:29:03.457]                           for (restart in restarts) {
[08:29:03.457]                             name <- restart$name
[08:29:03.457]                             if (is.null(name)) 
[08:29:03.457]                               next
[08:29:03.457]                             if (!grepl(pattern, name)) 
[08:29:03.457]                               next
[08:29:03.457]                             invokeRestart(restart)
[08:29:03.457]                             muffled <- TRUE
[08:29:03.457]                             break
[08:29:03.457]                           }
[08:29:03.457]                         }
[08:29:03.457]                       }
[08:29:03.457]                       invisible(muffled)
[08:29:03.457]                     }
[08:29:03.457]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.457]                   }
[08:29:03.457]                 }
[08:29:03.457]             }
[08:29:03.457]         }))
[08:29:03.457]     }, error = function(ex) {
[08:29:03.457]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.457]                 ...future.rng), started = ...future.startTime, 
[08:29:03.457]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.457]             version = "1.8"), class = "FutureResult")
[08:29:03.457]     }, finally = {
[08:29:03.457]         if (!identical(...future.workdir, getwd())) 
[08:29:03.457]             setwd(...future.workdir)
[08:29:03.457]         {
[08:29:03.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.457]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.457]             }
[08:29:03.457]             base::options(...future.oldOptions)
[08:29:03.457]             if (.Platform$OS.type == "windows") {
[08:29:03.457]                 old_names <- names(...future.oldEnvVars)
[08:29:03.457]                 envs <- base::Sys.getenv()
[08:29:03.457]                 names <- names(envs)
[08:29:03.457]                 common <- intersect(names, old_names)
[08:29:03.457]                 added <- setdiff(names, old_names)
[08:29:03.457]                 removed <- setdiff(old_names, names)
[08:29:03.457]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.457]                   envs[common]]
[08:29:03.457]                 NAMES <- toupper(changed)
[08:29:03.457]                 args <- list()
[08:29:03.457]                 for (kk in seq_along(NAMES)) {
[08:29:03.457]                   name <- changed[[kk]]
[08:29:03.457]                   NAME <- NAMES[[kk]]
[08:29:03.457]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.457]                     next
[08:29:03.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.457]                 }
[08:29:03.457]                 NAMES <- toupper(added)
[08:29:03.457]                 for (kk in seq_along(NAMES)) {
[08:29:03.457]                   name <- added[[kk]]
[08:29:03.457]                   NAME <- NAMES[[kk]]
[08:29:03.457]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.457]                     next
[08:29:03.457]                   args[[name]] <- ""
[08:29:03.457]                 }
[08:29:03.457]                 NAMES <- toupper(removed)
[08:29:03.457]                 for (kk in seq_along(NAMES)) {
[08:29:03.457]                   name <- removed[[kk]]
[08:29:03.457]                   NAME <- NAMES[[kk]]
[08:29:03.457]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.457]                     next
[08:29:03.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.457]                 }
[08:29:03.457]                 if (length(args) > 0) 
[08:29:03.457]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.457]             }
[08:29:03.457]             else {
[08:29:03.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.457]             }
[08:29:03.457]             {
[08:29:03.457]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.457]                   0L) {
[08:29:03.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.457]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.457]                   base::options(opts)
[08:29:03.457]                 }
[08:29:03.457]                 {
[08:29:03.457]                   {
[08:29:03.457]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.457]                     NULL
[08:29:03.457]                   }
[08:29:03.457]                   options(future.plan = NULL)
[08:29:03.457]                   if (is.na(NA_character_)) 
[08:29:03.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.457]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.457]                     .init = FALSE)
[08:29:03.457]                 }
[08:29:03.457]             }
[08:29:03.457]         }
[08:29:03.457]     })
[08:29:03.457]     if (TRUE) {
[08:29:03.457]         base::sink(type = "output", split = FALSE)
[08:29:03.457]         if (TRUE) {
[08:29:03.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.457]         }
[08:29:03.457]         else {
[08:29:03.457]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.457]         }
[08:29:03.457]         base::close(...future.stdout)
[08:29:03.457]         ...future.stdout <- NULL
[08:29:03.457]     }
[08:29:03.457]     ...future.result$conditions <- ...future.conditions
[08:29:03.457]     ...future.result$finished <- base::Sys.time()
[08:29:03.457]     ...future.result
[08:29:03.457] }
[08:29:03.460] requestCore(): workers = 2
[08:29:03.460] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.471] result() for MulticoreFuture ...
[08:29:03.472] result() for MulticoreFuture ...
[08:29:03.472] result() for MulticoreFuture ... done
[08:29:03.472] result() for MulticoreFuture ... done
[08:29:03.472] result() for MulticoreFuture ...
[08:29:03.472] result() for MulticoreFuture ... done
[08:29:03.475] MulticoreFuture started
[08:29:03.476] - Launch lazy future ... done
[08:29:03.476] run() for ‘MulticoreFuture’ ... done
[08:29:03.476] plan(): Setting new future strategy stack:
[08:29:03.477] getGlobalsAndPackages() ...
[08:29:03.476] List of future strategies:
[08:29:03.476] 1. sequential:
[08:29:03.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:03.476]    - tweaked: FALSE
[08:29:03.476]    - call: NULL
[08:29:03.477] Searching for globals...
[08:29:03.477] plan(): nbrOfWorkers() = 1
[08:29:03.479] - globals found: [1] ‘{’
[08:29:03.479] Searching for globals ... DONE
[08:29:03.479] Resolving globals: FALSE
[08:29:03.480] 
[08:29:03.480] 
[08:29:03.480] getGlobalsAndPackages() ... DONE
[08:29:03.481] run() for ‘Future’ ...
[08:29:03.481] - state: ‘created’
[08:29:03.481] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:29:03.484] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:03.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:29:03.484]   - Field: ‘label’
[08:29:03.485]   - Field: ‘local’
[08:29:03.485]   - Field: ‘owner’
[08:29:03.485]   - Field: ‘envir’
[08:29:03.485]   - Field: ‘workers’
[08:29:03.485]   - Field: ‘packages’
[08:29:03.485]   - Field: ‘gc’
[08:29:03.486]   - Field: ‘job’
[08:29:03.486]   - Field: ‘conditions’
[08:29:03.486]   - Field: ‘expr’
[08:29:03.486]   - Field: ‘uuid’
[08:29:03.486]   - Field: ‘seed’
[08:29:03.486]   - Field: ‘version’
[08:29:03.486]   - Field: ‘result’
[08:29:03.487]   - Field: ‘asynchronous’
[08:29:03.487]   - Field: ‘calls’
[08:29:03.487]   - Field: ‘globals’
[08:29:03.487]   - Field: ‘stdout’
[08:29:03.487]   - Field: ‘earlySignal’
[08:29:03.487]   - Field: ‘lazy’
[08:29:03.487]   - Field: ‘state’
[08:29:03.488] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:29:03.488] - Launch lazy future ...
[08:29:03.488] Packages needed by the future expression (n = 0): <none>
[08:29:03.488] Packages needed by future strategies (n = 0): <none>
[08:29:03.489] {
[08:29:03.489]     {
[08:29:03.489]         {
[08:29:03.489]             ...future.startTime <- base::Sys.time()
[08:29:03.489]             {
[08:29:03.489]                 {
[08:29:03.489]                   {
[08:29:03.489]                     {
[08:29:03.489]                       base::local({
[08:29:03.489]                         has_future <- base::requireNamespace("future", 
[08:29:03.489]                           quietly = TRUE)
[08:29:03.489]                         if (has_future) {
[08:29:03.489]                           ns <- base::getNamespace("future")
[08:29:03.489]                           version <- ns[[".package"]][["version"]]
[08:29:03.489]                           if (is.null(version)) 
[08:29:03.489]                             version <- utils::packageVersion("future")
[08:29:03.489]                         }
[08:29:03.489]                         else {
[08:29:03.489]                           version <- NULL
[08:29:03.489]                         }
[08:29:03.489]                         if (!has_future || version < "1.8.0") {
[08:29:03.489]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:03.489]                             "", base::R.version$version.string), 
[08:29:03.489]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:03.489]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:03.489]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:03.489]                               "release", "version")], collapse = " "), 
[08:29:03.489]                             hostname = base::Sys.info()[["nodename"]])
[08:29:03.489]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:03.489]                             info)
[08:29:03.489]                           info <- base::paste(info, collapse = "; ")
[08:29:03.489]                           if (!has_future) {
[08:29:03.489]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:03.489]                               info)
[08:29:03.489]                           }
[08:29:03.489]                           else {
[08:29:03.489]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:03.489]                               info, version)
[08:29:03.489]                           }
[08:29:03.489]                           base::stop(msg)
[08:29:03.489]                         }
[08:29:03.489]                       })
[08:29:03.489]                     }
[08:29:03.489]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:03.489]                     base::options(mc.cores = 1L)
[08:29:03.489]                   }
[08:29:03.489]                   ...future.strategy.old <- future::plan("list")
[08:29:03.489]                   options(future.plan = NULL)
[08:29:03.489]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.489]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:03.489]                 }
[08:29:03.489]                 ...future.workdir <- getwd()
[08:29:03.489]             }
[08:29:03.489]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:03.489]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:03.489]         }
[08:29:03.489]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:03.489]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:03.489]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:03.489]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:03.489]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:03.489]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:03.489]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:03.489]             base::names(...future.oldOptions))
[08:29:03.489]     }
[08:29:03.489]     if (FALSE) {
[08:29:03.489]     }
[08:29:03.489]     else {
[08:29:03.489]         if (TRUE) {
[08:29:03.489]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:03.489]                 open = "w")
[08:29:03.489]         }
[08:29:03.489]         else {
[08:29:03.489]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:03.489]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:03.489]         }
[08:29:03.489]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:03.489]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:03.489]             base::sink(type = "output", split = FALSE)
[08:29:03.489]             base::close(...future.stdout)
[08:29:03.489]         }, add = TRUE)
[08:29:03.489]     }
[08:29:03.489]     ...future.frame <- base::sys.nframe()
[08:29:03.489]     ...future.conditions <- base::list()
[08:29:03.489]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:03.489]     if (FALSE) {
[08:29:03.489]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:03.489]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:03.489]     }
[08:29:03.489]     ...future.result <- base::tryCatch({
[08:29:03.489]         base::withCallingHandlers({
[08:29:03.489]             ...future.value <- base::withVisible(base::local({
[08:29:03.489]                 withCallingHandlers({
[08:29:03.489]                   {
[08:29:03.489]                     3
[08:29:03.489]                   }
[08:29:03.489]                 }, immediateCondition = function(cond) {
[08:29:03.489]                   save_rds <- function (object, pathname, ...) 
[08:29:03.489]                   {
[08:29:03.489]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:29:03.489]                     if (file_test("-f", pathname_tmp)) {
[08:29:03.489]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.489]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:29:03.489]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.489]                         fi_tmp[["mtime"]])
[08:29:03.489]                     }
[08:29:03.489]                     tryCatch({
[08:29:03.489]                       saveRDS(object, file = pathname_tmp, ...)
[08:29:03.489]                     }, error = function(ex) {
[08:29:03.489]                       msg <- conditionMessage(ex)
[08:29:03.489]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.489]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:29:03.489]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.489]                         fi_tmp[["mtime"]], msg)
[08:29:03.489]                       ex$message <- msg
[08:29:03.489]                       stop(ex)
[08:29:03.489]                     })
[08:29:03.489]                     stopifnot(file_test("-f", pathname_tmp))
[08:29:03.489]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:29:03.489]                     if (!res || file_test("-f", pathname_tmp)) {
[08:29:03.489]                       fi_tmp <- file.info(pathname_tmp)
[08:29:03.489]                       fi <- file.info(pathname)
[08:29:03.489]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:29:03.489]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:29:03.489]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:29:03.489]                         fi[["size"]], fi[["mtime"]])
[08:29:03.489]                       stop(msg)
[08:29:03.489]                     }
[08:29:03.489]                     invisible(pathname)
[08:29:03.489]                   }
[08:29:03.489]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:29:03.489]                     rootPath = tempdir()) 
[08:29:03.489]                   {
[08:29:03.489]                     obj <- list(time = Sys.time(), condition = cond)
[08:29:03.489]                     file <- tempfile(pattern = class(cond)[1], 
[08:29:03.489]                       tmpdir = path, fileext = ".rds")
[08:29:03.489]                     save_rds(obj, file)
[08:29:03.489]                   }
[08:29:03.489]                   saveImmediateCondition(cond, path = "/tmp/RtmpNrBy4e/.future/immediateConditions")
[08:29:03.489]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.489]                   {
[08:29:03.489]                     inherits <- base::inherits
[08:29:03.489]                     invokeRestart <- base::invokeRestart
[08:29:03.489]                     is.null <- base::is.null
[08:29:03.489]                     muffled <- FALSE
[08:29:03.489]                     if (inherits(cond, "message")) {
[08:29:03.489]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:03.489]                       if (muffled) 
[08:29:03.489]                         invokeRestart("muffleMessage")
[08:29:03.489]                     }
[08:29:03.489]                     else if (inherits(cond, "warning")) {
[08:29:03.489]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:03.489]                       if (muffled) 
[08:29:03.489]                         invokeRestart("muffleWarning")
[08:29:03.489]                     }
[08:29:03.489]                     else if (inherits(cond, "condition")) {
[08:29:03.489]                       if (!is.null(pattern)) {
[08:29:03.489]                         computeRestarts <- base::computeRestarts
[08:29:03.489]                         grepl <- base::grepl
[08:29:03.489]                         restarts <- computeRestarts(cond)
[08:29:03.489]                         for (restart in restarts) {
[08:29:03.489]                           name <- restart$name
[08:29:03.489]                           if (is.null(name)) 
[08:29:03.489]                             next
[08:29:03.489]                           if (!grepl(pattern, name)) 
[08:29:03.489]                             next
[08:29:03.489]                           invokeRestart(restart)
[08:29:03.489]                           muffled <- TRUE
[08:29:03.489]                           break
[08:29:03.489]                         }
[08:29:03.489]                       }
[08:29:03.489]                     }
[08:29:03.489]                     invisible(muffled)
[08:29:03.489]                   }
[08:29:03.489]                   muffleCondition(cond)
[08:29:03.489]                 })
[08:29:03.489]             }))
[08:29:03.489]             future::FutureResult(value = ...future.value$value, 
[08:29:03.489]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.489]                   ...future.rng), globalenv = if (FALSE) 
[08:29:03.489]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:03.489]                     ...future.globalenv.names))
[08:29:03.489]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:03.489]         }, condition = base::local({
[08:29:03.489]             c <- base::c
[08:29:03.489]             inherits <- base::inherits
[08:29:03.489]             invokeRestart <- base::invokeRestart
[08:29:03.489]             length <- base::length
[08:29:03.489]             list <- base::list
[08:29:03.489]             seq.int <- base::seq.int
[08:29:03.489]             signalCondition <- base::signalCondition
[08:29:03.489]             sys.calls <- base::sys.calls
[08:29:03.489]             `[[` <- base::`[[`
[08:29:03.489]             `+` <- base::`+`
[08:29:03.489]             `<<-` <- base::`<<-`
[08:29:03.489]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:03.489]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:03.489]                   3L)]
[08:29:03.489]             }
[08:29:03.489]             function(cond) {
[08:29:03.489]                 is_error <- inherits(cond, "error")
[08:29:03.489]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:03.489]                   NULL)
[08:29:03.489]                 if (is_error) {
[08:29:03.489]                   sessionInformation <- function() {
[08:29:03.489]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:03.489]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:03.489]                       search = base::search(), system = base::Sys.info())
[08:29:03.489]                   }
[08:29:03.489]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.489]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:03.489]                     cond$call), session = sessionInformation(), 
[08:29:03.489]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:03.489]                   signalCondition(cond)
[08:29:03.489]                 }
[08:29:03.489]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:03.489]                 "immediateCondition"))) {
[08:29:03.489]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:03.489]                   ...future.conditions[[length(...future.conditions) + 
[08:29:03.489]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:03.489]                   if (TRUE && !signal) {
[08:29:03.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.489]                     {
[08:29:03.489]                       inherits <- base::inherits
[08:29:03.489]                       invokeRestart <- base::invokeRestart
[08:29:03.489]                       is.null <- base::is.null
[08:29:03.489]                       muffled <- FALSE
[08:29:03.489]                       if (inherits(cond, "message")) {
[08:29:03.489]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.489]                         if (muffled) 
[08:29:03.489]                           invokeRestart("muffleMessage")
[08:29:03.489]                       }
[08:29:03.489]                       else if (inherits(cond, "warning")) {
[08:29:03.489]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.489]                         if (muffled) 
[08:29:03.489]                           invokeRestart("muffleWarning")
[08:29:03.489]                       }
[08:29:03.489]                       else if (inherits(cond, "condition")) {
[08:29:03.489]                         if (!is.null(pattern)) {
[08:29:03.489]                           computeRestarts <- base::computeRestarts
[08:29:03.489]                           grepl <- base::grepl
[08:29:03.489]                           restarts <- computeRestarts(cond)
[08:29:03.489]                           for (restart in restarts) {
[08:29:03.489]                             name <- restart$name
[08:29:03.489]                             if (is.null(name)) 
[08:29:03.489]                               next
[08:29:03.489]                             if (!grepl(pattern, name)) 
[08:29:03.489]                               next
[08:29:03.489]                             invokeRestart(restart)
[08:29:03.489]                             muffled <- TRUE
[08:29:03.489]                             break
[08:29:03.489]                           }
[08:29:03.489]                         }
[08:29:03.489]                       }
[08:29:03.489]                       invisible(muffled)
[08:29:03.489]                     }
[08:29:03.489]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.489]                   }
[08:29:03.489]                 }
[08:29:03.489]                 else {
[08:29:03.489]                   if (TRUE) {
[08:29:03.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:03.489]                     {
[08:29:03.489]                       inherits <- base::inherits
[08:29:03.489]                       invokeRestart <- base::invokeRestart
[08:29:03.489]                       is.null <- base::is.null
[08:29:03.489]                       muffled <- FALSE
[08:29:03.489]                       if (inherits(cond, "message")) {
[08:29:03.489]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:03.489]                         if (muffled) 
[08:29:03.489]                           invokeRestart("muffleMessage")
[08:29:03.489]                       }
[08:29:03.489]                       else if (inherits(cond, "warning")) {
[08:29:03.489]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:03.489]                         if (muffled) 
[08:29:03.489]                           invokeRestart("muffleWarning")
[08:29:03.489]                       }
[08:29:03.489]                       else if (inherits(cond, "condition")) {
[08:29:03.489]                         if (!is.null(pattern)) {
[08:29:03.489]                           computeRestarts <- base::computeRestarts
[08:29:03.489]                           grepl <- base::grepl
[08:29:03.489]                           restarts <- computeRestarts(cond)
[08:29:03.489]                           for (restart in restarts) {
[08:29:03.489]                             name <- restart$name
[08:29:03.489]                             if (is.null(name)) 
[08:29:03.489]                               next
[08:29:03.489]                             if (!grepl(pattern, name)) 
[08:29:03.489]                               next
[08:29:03.489]                             invokeRestart(restart)
[08:29:03.489]                             muffled <- TRUE
[08:29:03.489]                             break
[08:29:03.489]                           }
[08:29:03.489]                         }
[08:29:03.489]                       }
[08:29:03.489]                       invisible(muffled)
[08:29:03.489]                     }
[08:29:03.489]                     muffleCondition(cond, pattern = "^muffle")
[08:29:03.489]                   }
[08:29:03.489]                 }
[08:29:03.489]             }
[08:29:03.489]         }))
[08:29:03.489]     }, error = function(ex) {
[08:29:03.489]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:03.489]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:03.489]                 ...future.rng), started = ...future.startTime, 
[08:29:03.489]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:03.489]             version = "1.8"), class = "FutureResult")
[08:29:03.489]     }, finally = {
[08:29:03.489]         if (!identical(...future.workdir, getwd())) 
[08:29:03.489]             setwd(...future.workdir)
[08:29:03.489]         {
[08:29:03.489]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:03.489]                 ...future.oldOptions$nwarnings <- NULL
[08:29:03.489]             }
[08:29:03.489]             base::options(...future.oldOptions)
[08:29:03.489]             if (.Platform$OS.type == "windows") {
[08:29:03.489]                 old_names <- names(...future.oldEnvVars)
[08:29:03.489]                 envs <- base::Sys.getenv()
[08:29:03.489]                 names <- names(envs)
[08:29:03.489]                 common <- intersect(names, old_names)
[08:29:03.489]                 added <- setdiff(names, old_names)
[08:29:03.489]                 removed <- setdiff(old_names, names)
[08:29:03.489]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:03.489]                   envs[common]]
[08:29:03.489]                 NAMES <- toupper(changed)
[08:29:03.489]                 args <- list()
[08:29:03.489]                 for (kk in seq_along(NAMES)) {
[08:29:03.489]                   name <- changed[[kk]]
[08:29:03.489]                   NAME <- NAMES[[kk]]
[08:29:03.489]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.489]                     next
[08:29:03.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.489]                 }
[08:29:03.489]                 NAMES <- toupper(added)
[08:29:03.489]                 for (kk in seq_along(NAMES)) {
[08:29:03.489]                   name <- added[[kk]]
[08:29:03.489]                   NAME <- NAMES[[kk]]
[08:29:03.489]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.489]                     next
[08:29:03.489]                   args[[name]] <- ""
[08:29:03.489]                 }
[08:29:03.489]                 NAMES <- toupper(removed)
[08:29:03.489]                 for (kk in seq_along(NAMES)) {
[08:29:03.489]                   name <- removed[[kk]]
[08:29:03.489]                   NAME <- NAMES[[kk]]
[08:29:03.489]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:03.489]                     next
[08:29:03.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:03.489]                 }
[08:29:03.489]                 if (length(args) > 0) 
[08:29:03.489]                   base::do.call(base::Sys.setenv, args = args)
[08:29:03.489]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:03.489]             }
[08:29:03.489]             else {
[08:29:03.489]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:03.489]             }
[08:29:03.489]             {
[08:29:03.489]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:03.489]                   0L) {
[08:29:03.489]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:03.489]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:03.489]                   base::options(opts)
[08:29:03.489]                 }
[08:29:03.489]                 {
[08:29:03.489]                   {
[08:29:03.489]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:03.489]                     NULL
[08:29:03.489]                   }
[08:29:03.489]                   options(future.plan = NULL)
[08:29:03.489]                   if (is.na(NA_character_)) 
[08:29:03.489]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:03.489]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:03.489]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:03.489]                     .init = FALSE)
[08:29:03.489]                 }
[08:29:03.489]             }
[08:29:03.489]         }
[08:29:03.489]     })
[08:29:03.489]     if (TRUE) {
[08:29:03.489]         base::sink(type = "output", split = FALSE)
[08:29:03.489]         if (TRUE) {
[08:29:03.489]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:03.489]         }
[08:29:03.489]         else {
[08:29:03.489]             ...future.result["stdout"] <- base::list(NULL)
[08:29:03.489]         }
[08:29:03.489]         base::close(...future.stdout)
[08:29:03.489]         ...future.stdout <- NULL
[08:29:03.489]     }
[08:29:03.489]     ...future.result$conditions <- ...future.conditions
[08:29:03.489]     ...future.result$finished <- base::Sys.time()
[08:29:03.489]     ...future.result
[08:29:03.489] }
[08:29:03.492] requestCore(): workers = 2
[08:29:03.493] Poll #1 (0): usedCores() = 2, workers = 2
[08:29:03.503] result() for MulticoreFuture ...
[08:29:03.504] result() for MulticoreFuture ...
[08:29:03.504] result() for MulticoreFuture ... done
[08:29:03.505] result() for MulticoreFuture ... done
[08:29:03.505] result() for MulticoreFuture ...
[08:29:03.505] result() for MulticoreFuture ... done
[08:29:03.507] MulticoreFuture started
[08:29:03.507] - Launch lazy future ... done
[08:29:03.508] run() for ‘MulticoreFuture’ ... done
[08:29:03.508] plan(): Setting new future strategy stack:
[08:29:03.509] resolve() on list environment ...
[08:29:03.508] List of future strategies:
[08:29:03.508] 1. sequential:
[08:29:03.508]    - args: function (..., envir = parent.[08:29:03.509]  recursive: 0
frame(), workers = "<NULL>")
[08:29:03.508]    - tweaked: FALSE
[08:29:03.508]    - call: NULL
[08:29:03.510] plan(): nbrOfWorkers() = 1
[08:29:03.511]  length: 4
[08:29:03.511]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:03.511] Future #1
[08:29:03.511]  length: 3 (resolved future 1)
[08:29:03.512] plan(): Setting new future strategy stack:
[08:29:03.512] List of future strategies:
[08:29:03.512] 1. multicore:
[08:29:03.512]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.512]    - tweaked: FALSE
[08:29:03.512]    - call: plan(strategy)
[08:29:03.515] plan(): nbrOfWorkers() = 2
[08:29:03.522] Future #3
[08:29:03.522]  length: 2 (resolved future 3)
[08:29:03.522]  length: 1 (resolved future 4)
[08:29:03.980] plan(): Setting new future strategy stack:
[08:29:03.981] List of future strategies:
[08:29:03.981] 1. multicore:
[08:29:03.981]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:29:03.981]    - tweaked: FALSE
[08:29:03.981]    - call: plan(strategy)
[08:29:03.983] plan(): nbrOfWorkers() = 2
[08:29:03.984] Future #2
[08:29:03.984]  length: 0 (resolved future 2)
[08:29:03.984] resolve() on list environment ... DONE
[08:29:03.985] resolve() on list environment ...
[08:29:03.985]  recursive: 0
[08:29:03.986]  length: 4
[08:29:03.986]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:03.986] Future #1
[08:29:03.986]  length: 3 (resolved future 1)
[08:29:03.987] Future #2
[08:29:03.987]  length: 2 (resolved future 2)
[08:29:03.987] Future #3
[08:29:03.987]  length: 1 (resolved future 3)
[08:29:03.987]  length: 0 (resolved future 4)
[08:29:03.988] resolve() on list environment ... DONE
[08:29:03.988] resolve() on list environment ...
[08:29:03.988]  recursive: 0
[08:29:03.995]  length: 4
[08:29:03.995]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:03.995] Future #1
[08:29:03.996]  length: 3 (resolved future 1)
[08:29:03.996] Future #2
[08:29:03.997]  length: 2 (resolved future 2)
[08:29:03.997] Future #3
[08:29:03.997]  length: 1 (resolved future 3)
[08:29:03.997]  length: 0 (resolved future 4)
[08:29:03.998] resolve() on list environment ... DONE
[08:29:03.998] resolve() on list environment ...
[08:29:03.999]  recursive: 0
[08:29:04.000]  length: 4
[08:29:04.000]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:04.000] Future #1
[08:29:04.000]  length: 3 (resolved future 1)
[08:29:04.001] Future #2
[08:29:04.001]  length: 2 (resolved future 2)
[08:29:04.001] Future #3
[08:29:04.001]  length: 1 (resolved future 3)
[08:29:04.001]  length: 0 (resolved future 4)
[08:29:04.002] resolve() on list environment ... DONE
[08:29:04.002] resolve() on list environment ...
[08:29:04.002]  recursive: 0
[08:29:04.003]  length: 4
[08:29:04.003]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:04.004] Future #1
[08:29:04.004] result() for MulticoreFuture ...
[08:29:04.004] result() for MulticoreFuture ... done
[08:29:04.004] result() for MulticoreFuture ...
[08:29:04.004] result() for MulticoreFuture ... done
[08:29:04.004]  length: 3 (resolved future 1)
[08:29:04.005] Future #2
[08:29:04.005] result() for MulticoreFuture ...
[08:29:04.006] result() for MulticoreFuture ...
[08:29:04.006] result() for MulticoreFuture ... done
[08:29:04.006] result() for MulticoreFuture ... done
[08:29:04.006] result() for MulticoreFuture ...
[08:29:04.006] result() for MulticoreFuture ... done
[08:29:04.006]  length: 2 (resolved future 2)
[08:29:04.007] Future #3
[08:29:04.007] result() for MulticoreFuture ...
[08:29:04.007] result() for MulticoreFuture ...
[08:29:04.008] result() for MulticoreFuture ... done
[08:29:04.008] result() for MulticoreFuture ... done
[08:29:04.008] result() for MulticoreFuture ...
[08:29:04.008] result() for MulticoreFuture ... done
[08:29:04.008]  length: 1 (resolved future 3)
[08:29:04.008]  length: 0 (resolved future 4)
[08:29:04.008] resolve() on list environment ... DONE
[08:29:04.009] resolve() on list environment ...
[08:29:04.009]  recursive: 99
[08:29:04.010]  length: 4
[08:29:04.010]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:04.010] Future #1
[08:29:04.010] result() for MulticoreFuture ...
[08:29:04.011] result() for MulticoreFuture ... done
[08:29:04.011] result() for MulticoreFuture ...
[08:29:04.011] result() for MulticoreFuture ... done
[08:29:04.011] A MulticoreFuture was resolved
[08:29:04.011]  length: 3 (resolved future 1)
[08:29:04.011] Future #2
[08:29:04.011] result() for MulticoreFuture ...
[08:29:04.011] result() for MulticoreFuture ... done
[08:29:04.012] result() for MulticoreFuture ...
[08:29:04.012] result() for MulticoreFuture ... done
[08:29:04.012] A MulticoreFuture was resolved
[08:29:04.012]  length: 2 (resolved future 2)
[08:29:04.012] Future #3
[08:29:04.012] result() for MulticoreFuture ...
[08:29:04.012] result() for MulticoreFuture ... done
[08:29:04.012] result() for MulticoreFuture ...
[08:29:04.012] result() for MulticoreFuture ... done
[08:29:04.013] A MulticoreFuture was resolved
[08:29:04.013]  length: 1 (resolved future 3)
[08:29:04.013]  length: 0 (resolved future 4)
[08:29:04.013] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[08:29:04.014] plan(): Setting new future strategy stack:
[08:29:04.014] List of future strategies:
[08:29:04.014] 1. multisession:
[08:29:04.014]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:29:04.014]    - tweaked: FALSE
[08:29:04.014]    - call: plan(strategy)
[08:29:04.014] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:29:04.014] multisession:
[08:29:04.014] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:29:04.014] - tweaked: FALSE
[08:29:04.014] - call: plan(strategy)
[08:29:04.018] getGlobalsAndPackages() ...
[08:29:04.018] Not searching for globals
[08:29:04.018] - globals: [0] <none>
[08:29:04.019] getGlobalsAndPackages() ... DONE
[08:29:04.515] Packages needed by the future expression (n = 0): <none>
[08:29:04.515] Packages needed by future strategies (n = 0): <none>
[08:29:04.516] {
[08:29:04.516]     {
[08:29:04.516]         {
[08:29:04.516]             ...future.startTime <- base::Sys.time()
[08:29:04.516]             {
[08:29:04.516]                 {
[08:29:04.516]                   {
[08:29:04.516]                     {
[08:29:04.516]                       base::local({
[08:29:04.516]                         has_future <- base::requireNamespace("future", 
[08:29:04.516]                           quietly = TRUE)
[08:29:04.516]                         if (has_future) {
[08:29:04.516]                           ns <- base::getNamespace("future")
[08:29:04.516]                           version <- ns[[".package"]][["version"]]
[08:29:04.516]                           if (is.null(version)) 
[08:29:04.516]                             version <- utils::packageVersion("future")
[08:29:04.516]                         }
[08:29:04.516]                         else {
[08:29:04.516]                           version <- NULL
[08:29:04.516]                         }
[08:29:04.516]                         if (!has_future || version < "1.8.0") {
[08:29:04.516]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:04.516]                             "", base::R.version$version.string), 
[08:29:04.516]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:04.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:04.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:04.516]                               "release", "version")], collapse = " "), 
[08:29:04.516]                             hostname = base::Sys.info()[["nodename"]])
[08:29:04.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:04.516]                             info)
[08:29:04.516]                           info <- base::paste(info, collapse = "; ")
[08:29:04.516]                           if (!has_future) {
[08:29:04.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:04.516]                               info)
[08:29:04.516]                           }
[08:29:04.516]                           else {
[08:29:04.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:04.516]                               info, version)
[08:29:04.516]                           }
[08:29:04.516]                           base::stop(msg)
[08:29:04.516]                         }
[08:29:04.516]                       })
[08:29:04.516]                     }
[08:29:04.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:04.516]                     base::options(mc.cores = 1L)
[08:29:04.516]                   }
[08:29:04.516]                   ...future.strategy.old <- future::plan("list")
[08:29:04.516]                   options(future.plan = NULL)
[08:29:04.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:04.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:04.516]                 }
[08:29:04.516]                 ...future.workdir <- getwd()
[08:29:04.516]             }
[08:29:04.516]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:04.516]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:04.516]         }
[08:29:04.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:04.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:04.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:04.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:04.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:04.516]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:04.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:04.516]             base::names(...future.oldOptions))
[08:29:04.516]     }
[08:29:04.516]     if (FALSE) {
[08:29:04.516]     }
[08:29:04.516]     else {
[08:29:04.516]         if (TRUE) {
[08:29:04.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:04.516]                 open = "w")
[08:29:04.516]         }
[08:29:04.516]         else {
[08:29:04.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:04.516]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:04.516]         }
[08:29:04.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:04.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:04.516]             base::sink(type = "output", split = FALSE)
[08:29:04.516]             base::close(...future.stdout)
[08:29:04.516]         }, add = TRUE)
[08:29:04.516]     }
[08:29:04.516]     ...future.frame <- base::sys.nframe()
[08:29:04.516]     ...future.conditions <- base::list()
[08:29:04.516]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:04.516]     if (FALSE) {
[08:29:04.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:04.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:04.516]     }
[08:29:04.516]     ...future.result <- base::tryCatch({
[08:29:04.516]         base::withCallingHandlers({
[08:29:04.516]             ...future.value <- base::withVisible(base::local({
[08:29:04.516]                 ...future.makeSendCondition <- base::local({
[08:29:04.516]                   sendCondition <- NULL
[08:29:04.516]                   function(frame = 1L) {
[08:29:04.516]                     if (is.function(sendCondition)) 
[08:29:04.516]                       return(sendCondition)
[08:29:04.516]                     ns <- getNamespace("parallel")
[08:29:04.516]                     if (exists("sendData", mode = "function", 
[08:29:04.516]                       envir = ns)) {
[08:29:04.516]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:04.516]                         envir = ns)
[08:29:04.516]                       envir <- sys.frame(frame)
[08:29:04.516]                       master <- NULL
[08:29:04.516]                       while (!identical(envir, .GlobalEnv) && 
[08:29:04.516]                         !identical(envir, emptyenv())) {
[08:29:04.516]                         if (exists("master", mode = "list", envir = envir, 
[08:29:04.516]                           inherits = FALSE)) {
[08:29:04.516]                           master <- get("master", mode = "list", 
[08:29:04.516]                             envir = envir, inherits = FALSE)
[08:29:04.516]                           if (inherits(master, c("SOCKnode", 
[08:29:04.516]                             "SOCK0node"))) {
[08:29:04.516]                             sendCondition <<- function(cond) {
[08:29:04.516]                               data <- list(type = "VALUE", value = cond, 
[08:29:04.516]                                 success = TRUE)
[08:29:04.516]                               parallel_sendData(master, data)
[08:29:04.516]                             }
[08:29:04.516]                             return(sendCondition)
[08:29:04.516]                           }
[08:29:04.516]                         }
[08:29:04.516]                         frame <- frame + 1L
[08:29:04.516]                         envir <- sys.frame(frame)
[08:29:04.516]                       }
[08:29:04.516]                     }
[08:29:04.516]                     sendCondition <<- function(cond) NULL
[08:29:04.516]                   }
[08:29:04.516]                 })
[08:29:04.516]                 withCallingHandlers({
[08:29:04.516]                   NA
[08:29:04.516]                 }, immediateCondition = function(cond) {
[08:29:04.516]                   sendCondition <- ...future.makeSendCondition()
[08:29:04.516]                   sendCondition(cond)
[08:29:04.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:04.516]                   {
[08:29:04.516]                     inherits <- base::inherits
[08:29:04.516]                     invokeRestart <- base::invokeRestart
[08:29:04.516]                     is.null <- base::is.null
[08:29:04.516]                     muffled <- FALSE
[08:29:04.516]                     if (inherits(cond, "message")) {
[08:29:04.516]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:04.516]                       if (muffled) 
[08:29:04.516]                         invokeRestart("muffleMessage")
[08:29:04.516]                     }
[08:29:04.516]                     else if (inherits(cond, "warning")) {
[08:29:04.516]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:04.516]                       if (muffled) 
[08:29:04.516]                         invokeRestart("muffleWarning")
[08:29:04.516]                     }
[08:29:04.516]                     else if (inherits(cond, "condition")) {
[08:29:04.516]                       if (!is.null(pattern)) {
[08:29:04.516]                         computeRestarts <- base::computeRestarts
[08:29:04.516]                         grepl <- base::grepl
[08:29:04.516]                         restarts <- computeRestarts(cond)
[08:29:04.516]                         for (restart in restarts) {
[08:29:04.516]                           name <- restart$name
[08:29:04.516]                           if (is.null(name)) 
[08:29:04.516]                             next
[08:29:04.516]                           if (!grepl(pattern, name)) 
[08:29:04.516]                             next
[08:29:04.516]                           invokeRestart(restart)
[08:29:04.516]                           muffled <- TRUE
[08:29:04.516]                           break
[08:29:04.516]                         }
[08:29:04.516]                       }
[08:29:04.516]                     }
[08:29:04.516]                     invisible(muffled)
[08:29:04.516]                   }
[08:29:04.516]                   muffleCondition(cond)
[08:29:04.516]                 })
[08:29:04.516]             }))
[08:29:04.516]             future::FutureResult(value = ...future.value$value, 
[08:29:04.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:04.516]                   ...future.rng), globalenv = if (FALSE) 
[08:29:04.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:04.516]                     ...future.globalenv.names))
[08:29:04.516]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:04.516]         }, condition = base::local({
[08:29:04.516]             c <- base::c
[08:29:04.516]             inherits <- base::inherits
[08:29:04.516]             invokeRestart <- base::invokeRestart
[08:29:04.516]             length <- base::length
[08:29:04.516]             list <- base::list
[08:29:04.516]             seq.int <- base::seq.int
[08:29:04.516]             signalCondition <- base::signalCondition
[08:29:04.516]             sys.calls <- base::sys.calls
[08:29:04.516]             `[[` <- base::`[[`
[08:29:04.516]             `+` <- base::`+`
[08:29:04.516]             `<<-` <- base::`<<-`
[08:29:04.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:04.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:04.516]                   3L)]
[08:29:04.516]             }
[08:29:04.516]             function(cond) {
[08:29:04.516]                 is_error <- inherits(cond, "error")
[08:29:04.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:04.516]                   NULL)
[08:29:04.516]                 if (is_error) {
[08:29:04.516]                   sessionInformation <- function() {
[08:29:04.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:04.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:04.516]                       search = base::search(), system = base::Sys.info())
[08:29:04.516]                   }
[08:29:04.516]                   ...future.conditions[[length(...future.conditions) + 
[08:29:04.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:04.516]                     cond$call), session = sessionInformation(), 
[08:29:04.516]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:04.516]                   signalCondition(cond)
[08:29:04.516]                 }
[08:29:04.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:04.516]                 "immediateCondition"))) {
[08:29:04.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:04.516]                   ...future.conditions[[length(...future.conditions) + 
[08:29:04.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:04.516]                   if (TRUE && !signal) {
[08:29:04.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:04.516]                     {
[08:29:04.516]                       inherits <- base::inherits
[08:29:04.516]                       invokeRestart <- base::invokeRestart
[08:29:04.516]                       is.null <- base::is.null
[08:29:04.516]                       muffled <- FALSE
[08:29:04.516]                       if (inherits(cond, "message")) {
[08:29:04.516]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:04.516]                         if (muffled) 
[08:29:04.516]                           invokeRestart("muffleMessage")
[08:29:04.516]                       }
[08:29:04.516]                       else if (inherits(cond, "warning")) {
[08:29:04.516]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:04.516]                         if (muffled) 
[08:29:04.516]                           invokeRestart("muffleWarning")
[08:29:04.516]                       }
[08:29:04.516]                       else if (inherits(cond, "condition")) {
[08:29:04.516]                         if (!is.null(pattern)) {
[08:29:04.516]                           computeRestarts <- base::computeRestarts
[08:29:04.516]                           grepl <- base::grepl
[08:29:04.516]                           restarts <- computeRestarts(cond)
[08:29:04.516]                           for (restart in restarts) {
[08:29:04.516]                             name <- restart$name
[08:29:04.516]                             if (is.null(name)) 
[08:29:04.516]                               next
[08:29:04.516]                             if (!grepl(pattern, name)) 
[08:29:04.516]                               next
[08:29:04.516]                             invokeRestart(restart)
[08:29:04.516]                             muffled <- TRUE
[08:29:04.516]                             break
[08:29:04.516]                           }
[08:29:04.516]                         }
[08:29:04.516]                       }
[08:29:04.516]                       invisible(muffled)
[08:29:04.516]                     }
[08:29:04.516]                     muffleCondition(cond, pattern = "^muffle")
[08:29:04.516]                   }
[08:29:04.516]                 }
[08:29:04.516]                 else {
[08:29:04.516]                   if (TRUE) {
[08:29:04.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:04.516]                     {
[08:29:04.516]                       inherits <- base::inherits
[08:29:04.516]                       invokeRestart <- base::invokeRestart
[08:29:04.516]                       is.null <- base::is.null
[08:29:04.516]                       muffled <- FALSE
[08:29:04.516]                       if (inherits(cond, "message")) {
[08:29:04.516]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:04.516]                         if (muffled) 
[08:29:04.516]                           invokeRestart("muffleMessage")
[08:29:04.516]                       }
[08:29:04.516]                       else if (inherits(cond, "warning")) {
[08:29:04.516]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:04.516]                         if (muffled) 
[08:29:04.516]                           invokeRestart("muffleWarning")
[08:29:04.516]                       }
[08:29:04.516]                       else if (inherits(cond, "condition")) {
[08:29:04.516]                         if (!is.null(pattern)) {
[08:29:04.516]                           computeRestarts <- base::computeRestarts
[08:29:04.516]                           grepl <- base::grepl
[08:29:04.516]                           restarts <- computeRestarts(cond)
[08:29:04.516]                           for (restart in restarts) {
[08:29:04.516]                             name <- restart$name
[08:29:04.516]                             if (is.null(name)) 
[08:29:04.516]                               next
[08:29:04.516]                             if (!grepl(pattern, name)) 
[08:29:04.516]                               next
[08:29:04.516]                             invokeRestart(restart)
[08:29:04.516]                             muffled <- TRUE
[08:29:04.516]                             break
[08:29:04.516]                           }
[08:29:04.516]                         }
[08:29:04.516]                       }
[08:29:04.516]                       invisible(muffled)
[08:29:04.516]                     }
[08:29:04.516]                     muffleCondition(cond, pattern = "^muffle")
[08:29:04.516]                   }
[08:29:04.516]                 }
[08:29:04.516]             }
[08:29:04.516]         }))
[08:29:04.516]     }, error = function(ex) {
[08:29:04.516]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:04.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:04.516]                 ...future.rng), started = ...future.startTime, 
[08:29:04.516]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:04.516]             version = "1.8"), class = "FutureResult")
[08:29:04.516]     }, finally = {
[08:29:04.516]         if (!identical(...future.workdir, getwd())) 
[08:29:04.516]             setwd(...future.workdir)
[08:29:04.516]         {
[08:29:04.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:04.516]                 ...future.oldOptions$nwarnings <- NULL
[08:29:04.516]             }
[08:29:04.516]             base::options(...future.oldOptions)
[08:29:04.516]             if (.Platform$OS.type == "windows") {
[08:29:04.516]                 old_names <- names(...future.oldEnvVars)
[08:29:04.516]                 envs <- base::Sys.getenv()
[08:29:04.516]                 names <- names(envs)
[08:29:04.516]                 common <- intersect(names, old_names)
[08:29:04.516]                 added <- setdiff(names, old_names)
[08:29:04.516]                 removed <- setdiff(old_names, names)
[08:29:04.516]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:04.516]                   envs[common]]
[08:29:04.516]                 NAMES <- toupper(changed)
[08:29:04.516]                 args <- list()
[08:29:04.516]                 for (kk in seq_along(NAMES)) {
[08:29:04.516]                   name <- changed[[kk]]
[08:29:04.516]                   NAME <- NAMES[[kk]]
[08:29:04.516]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:04.516]                     next
[08:29:04.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:04.516]                 }
[08:29:04.516]                 NAMES <- toupper(added)
[08:29:04.516]                 for (kk in seq_along(NAMES)) {
[08:29:04.516]                   name <- added[[kk]]
[08:29:04.516]                   NAME <- NAMES[[kk]]
[08:29:04.516]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:04.516]                     next
[08:29:04.516]                   args[[name]] <- ""
[08:29:04.516]                 }
[08:29:04.516]                 NAMES <- toupper(removed)
[08:29:04.516]                 for (kk in seq_along(NAMES)) {
[08:29:04.516]                   name <- removed[[kk]]
[08:29:04.516]                   NAME <- NAMES[[kk]]
[08:29:04.516]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:04.516]                     next
[08:29:04.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:04.516]                 }
[08:29:04.516]                 if (length(args) > 0) 
[08:29:04.516]                   base::do.call(base::Sys.setenv, args = args)
[08:29:04.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:04.516]             }
[08:29:04.516]             else {
[08:29:04.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:04.516]             }
[08:29:04.516]             {
[08:29:04.516]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:04.516]                   0L) {
[08:29:04.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:04.516]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:04.516]                   base::options(opts)
[08:29:04.516]                 }
[08:29:04.516]                 {
[08:29:04.516]                   {
[08:29:04.516]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:04.516]                     NULL
[08:29:04.516]                   }
[08:29:04.516]                   options(future.plan = NULL)
[08:29:04.516]                   if (is.na(NA_character_)) 
[08:29:04.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:04.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:04.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:04.516]                     .init = FALSE)
[08:29:04.516]                 }
[08:29:04.516]             }
[08:29:04.516]         }
[08:29:04.516]     })
[08:29:04.516]     if (TRUE) {
[08:29:04.516]         base::sink(type = "output", split = FALSE)
[08:29:04.516]         if (TRUE) {
[08:29:04.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:04.516]         }
[08:29:04.516]         else {
[08:29:04.516]             ...future.result["stdout"] <- base::list(NULL)
[08:29:04.516]         }
[08:29:04.516]         base::close(...future.stdout)
[08:29:04.516]         ...future.stdout <- NULL
[08:29:04.516]     }
[08:29:04.516]     ...future.result$conditions <- ...future.conditions
[08:29:04.516]     ...future.result$finished <- base::Sys.time()
[08:29:04.516]     ...future.result
[08:29:04.516] }
[08:29:04.570] MultisessionFuture started
[08:29:04.570] result() for ClusterFuture ...
[08:29:04.571] receiveMessageFromWorker() for ClusterFuture ...
[08:29:04.571] - Validating connection of MultisessionFuture
[08:29:04.601] - received message: FutureResult
[08:29:04.601] - Received FutureResult
[08:29:04.601] - Erased future from FutureRegistry
[08:29:04.601] result() for ClusterFuture ...
[08:29:04.602] - result already collected: FutureResult
[08:29:04.602] result() for ClusterFuture ... done
[08:29:04.602] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:04.602] result() for ClusterFuture ... done
[08:29:04.602] result() for ClusterFuture ...
[08:29:04.602] - result already collected: FutureResult
[08:29:04.602] result() for ClusterFuture ... done
[08:29:04.602] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:29:04.604] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[08:29:04.605] getGlobalsAndPackages() ...
[08:29:04.605] Searching for globals...
[08:29:04.606] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:04.606] Searching for globals ... DONE
[08:29:04.606] Resolving globals: FALSE
[08:29:04.607] 
[08:29:04.607] 
[08:29:04.607] getGlobalsAndPackages() ... DONE
[08:29:04.607] run() for ‘Future’ ...
[08:29:04.607] - state: ‘created’
[08:29:04.607] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:04.621] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:04.621] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:04.621]   - Field: ‘node’
[08:29:04.621]   - Field: ‘label’
[08:29:04.621]   - Field: ‘local’
[08:29:04.621]   - Field: ‘owner’
[08:29:04.622]   - Field: ‘envir’
[08:29:04.622]   - Field: ‘workers’
[08:29:04.622]   - Field: ‘packages’
[08:29:04.622]   - Field: ‘gc’
[08:29:04.622]   - Field: ‘conditions’
[08:29:04.622]   - Field: ‘persistent’
[08:29:04.622]   - Field: ‘expr’
[08:29:04.622]   - Field: ‘uuid’
[08:29:04.622]   - Field: ‘seed’
[08:29:04.622]   - Field: ‘version’
[08:29:04.622]   - Field: ‘result’
[08:29:04.622]   - Field: ‘asynchronous’
[08:29:04.623]   - Field: ‘calls’
[08:29:04.623]   - Field: ‘globals’
[08:29:04.623]   - Field: ‘stdout’
[08:29:04.623]   - Field: ‘earlySignal’
[08:29:04.623]   - Field: ‘lazy’
[08:29:04.623]   - Field: ‘state’
[08:29:04.623] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:04.623] - Launch lazy future ...
[08:29:04.623] Packages needed by the future expression (n = 0): <none>
[08:29:04.624] Packages needed by future strategies (n = 0): <none>
[08:29:04.624] {
[08:29:04.624]     {
[08:29:04.624]         {
[08:29:04.624]             ...future.startTime <- base::Sys.time()
[08:29:04.624]             {
[08:29:04.624]                 {
[08:29:04.624]                   {
[08:29:04.624]                     {
[08:29:04.624]                       base::local({
[08:29:04.624]                         has_future <- base::requireNamespace("future", 
[08:29:04.624]                           quietly = TRUE)
[08:29:04.624]                         if (has_future) {
[08:29:04.624]                           ns <- base::getNamespace("future")
[08:29:04.624]                           version <- ns[[".package"]][["version"]]
[08:29:04.624]                           if (is.null(version)) 
[08:29:04.624]                             version <- utils::packageVersion("future")
[08:29:04.624]                         }
[08:29:04.624]                         else {
[08:29:04.624]                           version <- NULL
[08:29:04.624]                         }
[08:29:04.624]                         if (!has_future || version < "1.8.0") {
[08:29:04.624]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:04.624]                             "", base::R.version$version.string), 
[08:29:04.624]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:04.624]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:04.624]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:04.624]                               "release", "version")], collapse = " "), 
[08:29:04.624]                             hostname = base::Sys.info()[["nodename"]])
[08:29:04.624]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:04.624]                             info)
[08:29:04.624]                           info <- base::paste(info, collapse = "; ")
[08:29:04.624]                           if (!has_future) {
[08:29:04.624]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:04.624]                               info)
[08:29:04.624]                           }
[08:29:04.624]                           else {
[08:29:04.624]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:04.624]                               info, version)
[08:29:04.624]                           }
[08:29:04.624]                           base::stop(msg)
[08:29:04.624]                         }
[08:29:04.624]                       })
[08:29:04.624]                     }
[08:29:04.624]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:04.624]                     base::options(mc.cores = 1L)
[08:29:04.624]                   }
[08:29:04.624]                   ...future.strategy.old <- future::plan("list")
[08:29:04.624]                   options(future.plan = NULL)
[08:29:04.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:04.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:04.624]                 }
[08:29:04.624]                 ...future.workdir <- getwd()
[08:29:04.624]             }
[08:29:04.624]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:04.624]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:04.624]         }
[08:29:04.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:04.624]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:04.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:04.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:04.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:04.624]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:04.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:04.624]             base::names(...future.oldOptions))
[08:29:04.624]     }
[08:29:04.624]     if (FALSE) {
[08:29:04.624]     }
[08:29:04.624]     else {
[08:29:04.624]         if (TRUE) {
[08:29:04.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:04.624]                 open = "w")
[08:29:04.624]         }
[08:29:04.624]         else {
[08:29:04.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:04.624]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:04.624]         }
[08:29:04.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:04.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:04.624]             base::sink(type = "output", split = FALSE)
[08:29:04.624]             base::close(...future.stdout)
[08:29:04.624]         }, add = TRUE)
[08:29:04.624]     }
[08:29:04.624]     ...future.frame <- base::sys.nframe()
[08:29:04.624]     ...future.conditions <- base::list()
[08:29:04.624]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:04.624]     if (FALSE) {
[08:29:04.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:04.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:04.624]     }
[08:29:04.624]     ...future.result <- base::tryCatch({
[08:29:04.624]         base::withCallingHandlers({
[08:29:04.624]             ...future.value <- base::withVisible(base::local({
[08:29:04.624]                 ...future.makeSendCondition <- base::local({
[08:29:04.624]                   sendCondition <- NULL
[08:29:04.624]                   function(frame = 1L) {
[08:29:04.624]                     if (is.function(sendCondition)) 
[08:29:04.624]                       return(sendCondition)
[08:29:04.624]                     ns <- getNamespace("parallel")
[08:29:04.624]                     if (exists("sendData", mode = "function", 
[08:29:04.624]                       envir = ns)) {
[08:29:04.624]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:04.624]                         envir = ns)
[08:29:04.624]                       envir <- sys.frame(frame)
[08:29:04.624]                       master <- NULL
[08:29:04.624]                       while (!identical(envir, .GlobalEnv) && 
[08:29:04.624]                         !identical(envir, emptyenv())) {
[08:29:04.624]                         if (exists("master", mode = "list", envir = envir, 
[08:29:04.624]                           inherits = FALSE)) {
[08:29:04.624]                           master <- get("master", mode = "list", 
[08:29:04.624]                             envir = envir, inherits = FALSE)
[08:29:04.624]                           if (inherits(master, c("SOCKnode", 
[08:29:04.624]                             "SOCK0node"))) {
[08:29:04.624]                             sendCondition <<- function(cond) {
[08:29:04.624]                               data <- list(type = "VALUE", value = cond, 
[08:29:04.624]                                 success = TRUE)
[08:29:04.624]                               parallel_sendData(master, data)
[08:29:04.624]                             }
[08:29:04.624]                             return(sendCondition)
[08:29:04.624]                           }
[08:29:04.624]                         }
[08:29:04.624]                         frame <- frame + 1L
[08:29:04.624]                         envir <- sys.frame(frame)
[08:29:04.624]                       }
[08:29:04.624]                     }
[08:29:04.624]                     sendCondition <<- function(cond) NULL
[08:29:04.624]                   }
[08:29:04.624]                 })
[08:29:04.624]                 withCallingHandlers({
[08:29:04.624]                   {
[08:29:04.624]                     Sys.sleep(0.5)
[08:29:04.624]                     list(a = 1, b = 42L)
[08:29:04.624]                   }
[08:29:04.624]                 }, immediateCondition = function(cond) {
[08:29:04.624]                   sendCondition <- ...future.makeSendCondition()
[08:29:04.624]                   sendCondition(cond)
[08:29:04.624]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:04.624]                   {
[08:29:04.624]                     inherits <- base::inherits
[08:29:04.624]                     invokeRestart <- base::invokeRestart
[08:29:04.624]                     is.null <- base::is.null
[08:29:04.624]                     muffled <- FALSE
[08:29:04.624]                     if (inherits(cond, "message")) {
[08:29:04.624]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:04.624]                       if (muffled) 
[08:29:04.624]                         invokeRestart("muffleMessage")
[08:29:04.624]                     }
[08:29:04.624]                     else if (inherits(cond, "warning")) {
[08:29:04.624]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:04.624]                       if (muffled) 
[08:29:04.624]                         invokeRestart("muffleWarning")
[08:29:04.624]                     }
[08:29:04.624]                     else if (inherits(cond, "condition")) {
[08:29:04.624]                       if (!is.null(pattern)) {
[08:29:04.624]                         computeRestarts <- base::computeRestarts
[08:29:04.624]                         grepl <- base::grepl
[08:29:04.624]                         restarts <- computeRestarts(cond)
[08:29:04.624]                         for (restart in restarts) {
[08:29:04.624]                           name <- restart$name
[08:29:04.624]                           if (is.null(name)) 
[08:29:04.624]                             next
[08:29:04.624]                           if (!grepl(pattern, name)) 
[08:29:04.624]                             next
[08:29:04.624]                           invokeRestart(restart)
[08:29:04.624]                           muffled <- TRUE
[08:29:04.624]                           break
[08:29:04.624]                         }
[08:29:04.624]                       }
[08:29:04.624]                     }
[08:29:04.624]                     invisible(muffled)
[08:29:04.624]                   }
[08:29:04.624]                   muffleCondition(cond)
[08:29:04.624]                 })
[08:29:04.624]             }))
[08:29:04.624]             future::FutureResult(value = ...future.value$value, 
[08:29:04.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:04.624]                   ...future.rng), globalenv = if (FALSE) 
[08:29:04.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:04.624]                     ...future.globalenv.names))
[08:29:04.624]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:04.624]         }, condition = base::local({
[08:29:04.624]             c <- base::c
[08:29:04.624]             inherits <- base::inherits
[08:29:04.624]             invokeRestart <- base::invokeRestart
[08:29:04.624]             length <- base::length
[08:29:04.624]             list <- base::list
[08:29:04.624]             seq.int <- base::seq.int
[08:29:04.624]             signalCondition <- base::signalCondition
[08:29:04.624]             sys.calls <- base::sys.calls
[08:29:04.624]             `[[` <- base::`[[`
[08:29:04.624]             `+` <- base::`+`
[08:29:04.624]             `<<-` <- base::`<<-`
[08:29:04.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:04.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:04.624]                   3L)]
[08:29:04.624]             }
[08:29:04.624]             function(cond) {
[08:29:04.624]                 is_error <- inherits(cond, "error")
[08:29:04.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:04.624]                   NULL)
[08:29:04.624]                 if (is_error) {
[08:29:04.624]                   sessionInformation <- function() {
[08:29:04.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:04.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:04.624]                       search = base::search(), system = base::Sys.info())
[08:29:04.624]                   }
[08:29:04.624]                   ...future.conditions[[length(...future.conditions) + 
[08:29:04.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:04.624]                     cond$call), session = sessionInformation(), 
[08:29:04.624]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:04.624]                   signalCondition(cond)
[08:29:04.624]                 }
[08:29:04.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:04.624]                 "immediateCondition"))) {
[08:29:04.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:04.624]                   ...future.conditions[[length(...future.conditions) + 
[08:29:04.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:04.624]                   if (TRUE && !signal) {
[08:29:04.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:04.624]                     {
[08:29:04.624]                       inherits <- base::inherits
[08:29:04.624]                       invokeRestart <- base::invokeRestart
[08:29:04.624]                       is.null <- base::is.null
[08:29:04.624]                       muffled <- FALSE
[08:29:04.624]                       if (inherits(cond, "message")) {
[08:29:04.624]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:04.624]                         if (muffled) 
[08:29:04.624]                           invokeRestart("muffleMessage")
[08:29:04.624]                       }
[08:29:04.624]                       else if (inherits(cond, "warning")) {
[08:29:04.624]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:04.624]                         if (muffled) 
[08:29:04.624]                           invokeRestart("muffleWarning")
[08:29:04.624]                       }
[08:29:04.624]                       else if (inherits(cond, "condition")) {
[08:29:04.624]                         if (!is.null(pattern)) {
[08:29:04.624]                           computeRestarts <- base::computeRestarts
[08:29:04.624]                           grepl <- base::grepl
[08:29:04.624]                           restarts <- computeRestarts(cond)
[08:29:04.624]                           for (restart in restarts) {
[08:29:04.624]                             name <- restart$name
[08:29:04.624]                             if (is.null(name)) 
[08:29:04.624]                               next
[08:29:04.624]                             if (!grepl(pattern, name)) 
[08:29:04.624]                               next
[08:29:04.624]                             invokeRestart(restart)
[08:29:04.624]                             muffled <- TRUE
[08:29:04.624]                             break
[08:29:04.624]                           }
[08:29:04.624]                         }
[08:29:04.624]                       }
[08:29:04.624]                       invisible(muffled)
[08:29:04.624]                     }
[08:29:04.624]                     muffleCondition(cond, pattern = "^muffle")
[08:29:04.624]                   }
[08:29:04.624]                 }
[08:29:04.624]                 else {
[08:29:04.624]                   if (TRUE) {
[08:29:04.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:04.624]                     {
[08:29:04.624]                       inherits <- base::inherits
[08:29:04.624]                       invokeRestart <- base::invokeRestart
[08:29:04.624]                       is.null <- base::is.null
[08:29:04.624]                       muffled <- FALSE
[08:29:04.624]                       if (inherits(cond, "message")) {
[08:29:04.624]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:04.624]                         if (muffled) 
[08:29:04.624]                           invokeRestart("muffleMessage")
[08:29:04.624]                       }
[08:29:04.624]                       else if (inherits(cond, "warning")) {
[08:29:04.624]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:04.624]                         if (muffled) 
[08:29:04.624]                           invokeRestart("muffleWarning")
[08:29:04.624]                       }
[08:29:04.624]                       else if (inherits(cond, "condition")) {
[08:29:04.624]                         if (!is.null(pattern)) {
[08:29:04.624]                           computeRestarts <- base::computeRestarts
[08:29:04.624]                           grepl <- base::grepl
[08:29:04.624]                           restarts <- computeRestarts(cond)
[08:29:04.624]                           for (restart in restarts) {
[08:29:04.624]                             name <- restart$name
[08:29:04.624]                             if (is.null(name)) 
[08:29:04.624]                               next
[08:29:04.624]                             if (!grepl(pattern, name)) 
[08:29:04.624]                               next
[08:29:04.624]                             invokeRestart(restart)
[08:29:04.624]                             muffled <- TRUE
[08:29:04.624]                             break
[08:29:04.624]                           }
[08:29:04.624]                         }
[08:29:04.624]                       }
[08:29:04.624]                       invisible(muffled)
[08:29:04.624]                     }
[08:29:04.624]                     muffleCondition(cond, pattern = "^muffle")
[08:29:04.624]                   }
[08:29:04.624]                 }
[08:29:04.624]             }
[08:29:04.624]         }))
[08:29:04.624]     }, error = function(ex) {
[08:29:04.624]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:04.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:04.624]                 ...future.rng), started = ...future.startTime, 
[08:29:04.624]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:04.624]             version = "1.8"), class = "FutureResult")
[08:29:04.624]     }, finally = {
[08:29:04.624]         if (!identical(...future.workdir, getwd())) 
[08:29:04.624]             setwd(...future.workdir)
[08:29:04.624]         {
[08:29:04.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:04.624]                 ...future.oldOptions$nwarnings <- NULL
[08:29:04.624]             }
[08:29:04.624]             base::options(...future.oldOptions)
[08:29:04.624]             if (.Platform$OS.type == "windows") {
[08:29:04.624]                 old_names <- names(...future.oldEnvVars)
[08:29:04.624]                 envs <- base::Sys.getenv()
[08:29:04.624]                 names <- names(envs)
[08:29:04.624]                 common <- intersect(names, old_names)
[08:29:04.624]                 added <- setdiff(names, old_names)
[08:29:04.624]                 removed <- setdiff(old_names, names)
[08:29:04.624]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:04.624]                   envs[common]]
[08:29:04.624]                 NAMES <- toupper(changed)
[08:29:04.624]                 args <- list()
[08:29:04.624]                 for (kk in seq_along(NAMES)) {
[08:29:04.624]                   name <- changed[[kk]]
[08:29:04.624]                   NAME <- NAMES[[kk]]
[08:29:04.624]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:04.624]                     next
[08:29:04.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:04.624]                 }
[08:29:04.624]                 NAMES <- toupper(added)
[08:29:04.624]                 for (kk in seq_along(NAMES)) {
[08:29:04.624]                   name <- added[[kk]]
[08:29:04.624]                   NAME <- NAMES[[kk]]
[08:29:04.624]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:04.624]                     next
[08:29:04.624]                   args[[name]] <- ""
[08:29:04.624]                 }
[08:29:04.624]                 NAMES <- toupper(removed)
[08:29:04.624]                 for (kk in seq_along(NAMES)) {
[08:29:04.624]                   name <- removed[[kk]]
[08:29:04.624]                   NAME <- NAMES[[kk]]
[08:29:04.624]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:04.624]                     next
[08:29:04.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:04.624]                 }
[08:29:04.624]                 if (length(args) > 0) 
[08:29:04.624]                   base::do.call(base::Sys.setenv, args = args)
[08:29:04.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:04.624]             }
[08:29:04.624]             else {
[08:29:04.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:04.624]             }
[08:29:04.624]             {
[08:29:04.624]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:04.624]                   0L) {
[08:29:04.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:04.624]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:04.624]                   base::options(opts)
[08:29:04.624]                 }
[08:29:04.624]                 {
[08:29:04.624]                   {
[08:29:04.624]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:04.624]                     NULL
[08:29:04.624]                   }
[08:29:04.624]                   options(future.plan = NULL)
[08:29:04.624]                   if (is.na(NA_character_)) 
[08:29:04.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:04.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:04.624]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:04.624]                     .init = FALSE)
[08:29:04.624]                 }
[08:29:04.624]             }
[08:29:04.624]         }
[08:29:04.624]     })
[08:29:04.624]     if (TRUE) {
[08:29:04.624]         base::sink(type = "output", split = FALSE)
[08:29:04.624]         if (TRUE) {
[08:29:04.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:04.624]         }
[08:29:04.624]         else {
[08:29:04.624]             ...future.result["stdout"] <- base::list(NULL)
[08:29:04.624]         }
[08:29:04.624]         base::close(...future.stdout)
[08:29:04.624]         ...future.stdout <- NULL
[08:29:04.624]     }
[08:29:04.624]     ...future.result$conditions <- ...future.conditions
[08:29:04.624]     ...future.result$finished <- base::Sys.time()
[08:29:04.624]     ...future.result
[08:29:04.624] }
[08:29:04.627] MultisessionFuture started
[08:29:04.627] - Launch lazy future ... done
[08:29:04.628] run() for ‘MultisessionFuture’ ... done
[08:29:05.170] receiveMessageFromWorker() for ClusterFuture ...
[08:29:05.170] - Validating connection of MultisessionFuture
[08:29:05.171] - received message: FutureResult
[08:29:05.171] - Received FutureResult
[08:29:05.171] - Erased future from FutureRegistry
[08:29:05.171] result() for ClusterFuture ...
[08:29:05.171] - result already collected: FutureResult
[08:29:05.171] result() for ClusterFuture ... done
[08:29:05.171] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:05.171] A MultisessionFuture was resolved (result was not collected)
[08:29:05.172] getGlobalsAndPackages() ...
[08:29:05.172] Searching for globals...
[08:29:05.173] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:05.173] Searching for globals ... DONE
[08:29:05.173] Resolving globals: FALSE
[08:29:05.174] 
[08:29:05.174] 
[08:29:05.174] getGlobalsAndPackages() ... DONE
[08:29:05.174] run() for ‘Future’ ...
[08:29:05.174] - state: ‘created’
[08:29:05.175] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:05.189] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:05.190] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:05.190]   - Field: ‘node’
[08:29:05.190]   - Field: ‘label’
[08:29:05.190]   - Field: ‘local’
[08:29:05.190]   - Field: ‘owner’
[08:29:05.190]   - Field: ‘envir’
[08:29:05.190]   - Field: ‘workers’
[08:29:05.190]   - Field: ‘packages’
[08:29:05.190]   - Field: ‘gc’
[08:29:05.190]   - Field: ‘conditions’
[08:29:05.191]   - Field: ‘persistent’
[08:29:05.191]   - Field: ‘expr’
[08:29:05.191]   - Field: ‘uuid’
[08:29:05.191]   - Field: ‘seed’
[08:29:05.191]   - Field: ‘version’
[08:29:05.191]   - Field: ‘result’
[08:29:05.191]   - Field: ‘asynchronous’
[08:29:05.191]   - Field: ‘calls’
[08:29:05.191]   - Field: ‘globals’
[08:29:05.191]   - Field: ‘stdout’
[08:29:05.192]   - Field: ‘earlySignal’
[08:29:05.192]   - Field: ‘lazy’
[08:29:05.192]   - Field: ‘state’
[08:29:05.192] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:05.192] - Launch lazy future ...
[08:29:05.192] Packages needed by the future expression (n = 0): <none>
[08:29:05.193] Packages needed by future strategies (n = 0): <none>
[08:29:05.193] {
[08:29:05.193]     {
[08:29:05.193]         {
[08:29:05.193]             ...future.startTime <- base::Sys.time()
[08:29:05.193]             {
[08:29:05.193]                 {
[08:29:05.193]                   {
[08:29:05.193]                     {
[08:29:05.193]                       base::local({
[08:29:05.193]                         has_future <- base::requireNamespace("future", 
[08:29:05.193]                           quietly = TRUE)
[08:29:05.193]                         if (has_future) {
[08:29:05.193]                           ns <- base::getNamespace("future")
[08:29:05.193]                           version <- ns[[".package"]][["version"]]
[08:29:05.193]                           if (is.null(version)) 
[08:29:05.193]                             version <- utils::packageVersion("future")
[08:29:05.193]                         }
[08:29:05.193]                         else {
[08:29:05.193]                           version <- NULL
[08:29:05.193]                         }
[08:29:05.193]                         if (!has_future || version < "1.8.0") {
[08:29:05.193]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:05.193]                             "", base::R.version$version.string), 
[08:29:05.193]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:05.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:05.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:05.193]                               "release", "version")], collapse = " "), 
[08:29:05.193]                             hostname = base::Sys.info()[["nodename"]])
[08:29:05.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:05.193]                             info)
[08:29:05.193]                           info <- base::paste(info, collapse = "; ")
[08:29:05.193]                           if (!has_future) {
[08:29:05.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:05.193]                               info)
[08:29:05.193]                           }
[08:29:05.193]                           else {
[08:29:05.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:05.193]                               info, version)
[08:29:05.193]                           }
[08:29:05.193]                           base::stop(msg)
[08:29:05.193]                         }
[08:29:05.193]                       })
[08:29:05.193]                     }
[08:29:05.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:05.193]                     base::options(mc.cores = 1L)
[08:29:05.193]                   }
[08:29:05.193]                   ...future.strategy.old <- future::plan("list")
[08:29:05.193]                   options(future.plan = NULL)
[08:29:05.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:05.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:05.193]                 }
[08:29:05.193]                 ...future.workdir <- getwd()
[08:29:05.193]             }
[08:29:05.193]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:05.193]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:05.193]         }
[08:29:05.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:05.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:05.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:05.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:05.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:05.193]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:05.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:05.193]             base::names(...future.oldOptions))
[08:29:05.193]     }
[08:29:05.193]     if (FALSE) {
[08:29:05.193]     }
[08:29:05.193]     else {
[08:29:05.193]         if (TRUE) {
[08:29:05.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:05.193]                 open = "w")
[08:29:05.193]         }
[08:29:05.193]         else {
[08:29:05.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:05.193]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:05.193]         }
[08:29:05.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:05.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:05.193]             base::sink(type = "output", split = FALSE)
[08:29:05.193]             base::close(...future.stdout)
[08:29:05.193]         }, add = TRUE)
[08:29:05.193]     }
[08:29:05.193]     ...future.frame <- base::sys.nframe()
[08:29:05.193]     ...future.conditions <- base::list()
[08:29:05.193]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:05.193]     if (FALSE) {
[08:29:05.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:05.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:05.193]     }
[08:29:05.193]     ...future.result <- base::tryCatch({
[08:29:05.193]         base::withCallingHandlers({
[08:29:05.193]             ...future.value <- base::withVisible(base::local({
[08:29:05.193]                 ...future.makeSendCondition <- base::local({
[08:29:05.193]                   sendCondition <- NULL
[08:29:05.193]                   function(frame = 1L) {
[08:29:05.193]                     if (is.function(sendCondition)) 
[08:29:05.193]                       return(sendCondition)
[08:29:05.193]                     ns <- getNamespace("parallel")
[08:29:05.193]                     if (exists("sendData", mode = "function", 
[08:29:05.193]                       envir = ns)) {
[08:29:05.193]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:05.193]                         envir = ns)
[08:29:05.193]                       envir <- sys.frame(frame)
[08:29:05.193]                       master <- NULL
[08:29:05.193]                       while (!identical(envir, .GlobalEnv) && 
[08:29:05.193]                         !identical(envir, emptyenv())) {
[08:29:05.193]                         if (exists("master", mode = "list", envir = envir, 
[08:29:05.193]                           inherits = FALSE)) {
[08:29:05.193]                           master <- get("master", mode = "list", 
[08:29:05.193]                             envir = envir, inherits = FALSE)
[08:29:05.193]                           if (inherits(master, c("SOCKnode", 
[08:29:05.193]                             "SOCK0node"))) {
[08:29:05.193]                             sendCondition <<- function(cond) {
[08:29:05.193]                               data <- list(type = "VALUE", value = cond, 
[08:29:05.193]                                 success = TRUE)
[08:29:05.193]                               parallel_sendData(master, data)
[08:29:05.193]                             }
[08:29:05.193]                             return(sendCondition)
[08:29:05.193]                           }
[08:29:05.193]                         }
[08:29:05.193]                         frame <- frame + 1L
[08:29:05.193]                         envir <- sys.frame(frame)
[08:29:05.193]                       }
[08:29:05.193]                     }
[08:29:05.193]                     sendCondition <<- function(cond) NULL
[08:29:05.193]                   }
[08:29:05.193]                 })
[08:29:05.193]                 withCallingHandlers({
[08:29:05.193]                   {
[08:29:05.193]                     Sys.sleep(0.5)
[08:29:05.193]                     list(a = 1, b = 42L)
[08:29:05.193]                   }
[08:29:05.193]                 }, immediateCondition = function(cond) {
[08:29:05.193]                   sendCondition <- ...future.makeSendCondition()
[08:29:05.193]                   sendCondition(cond)
[08:29:05.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.193]                   {
[08:29:05.193]                     inherits <- base::inherits
[08:29:05.193]                     invokeRestart <- base::invokeRestart
[08:29:05.193]                     is.null <- base::is.null
[08:29:05.193]                     muffled <- FALSE
[08:29:05.193]                     if (inherits(cond, "message")) {
[08:29:05.193]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:05.193]                       if (muffled) 
[08:29:05.193]                         invokeRestart("muffleMessage")
[08:29:05.193]                     }
[08:29:05.193]                     else if (inherits(cond, "warning")) {
[08:29:05.193]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:05.193]                       if (muffled) 
[08:29:05.193]                         invokeRestart("muffleWarning")
[08:29:05.193]                     }
[08:29:05.193]                     else if (inherits(cond, "condition")) {
[08:29:05.193]                       if (!is.null(pattern)) {
[08:29:05.193]                         computeRestarts <- base::computeRestarts
[08:29:05.193]                         grepl <- base::grepl
[08:29:05.193]                         restarts <- computeRestarts(cond)
[08:29:05.193]                         for (restart in restarts) {
[08:29:05.193]                           name <- restart$name
[08:29:05.193]                           if (is.null(name)) 
[08:29:05.193]                             next
[08:29:05.193]                           if (!grepl(pattern, name)) 
[08:29:05.193]                             next
[08:29:05.193]                           invokeRestart(restart)
[08:29:05.193]                           muffled <- TRUE
[08:29:05.193]                           break
[08:29:05.193]                         }
[08:29:05.193]                       }
[08:29:05.193]                     }
[08:29:05.193]                     invisible(muffled)
[08:29:05.193]                   }
[08:29:05.193]                   muffleCondition(cond)
[08:29:05.193]                 })
[08:29:05.193]             }))
[08:29:05.193]             future::FutureResult(value = ...future.value$value, 
[08:29:05.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:05.193]                   ...future.rng), globalenv = if (FALSE) 
[08:29:05.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:05.193]                     ...future.globalenv.names))
[08:29:05.193]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:05.193]         }, condition = base::local({
[08:29:05.193]             c <- base::c
[08:29:05.193]             inherits <- base::inherits
[08:29:05.193]             invokeRestart <- base::invokeRestart
[08:29:05.193]             length <- base::length
[08:29:05.193]             list <- base::list
[08:29:05.193]             seq.int <- base::seq.int
[08:29:05.193]             signalCondition <- base::signalCondition
[08:29:05.193]             sys.calls <- base::sys.calls
[08:29:05.193]             `[[` <- base::`[[`
[08:29:05.193]             `+` <- base::`+`
[08:29:05.193]             `<<-` <- base::`<<-`
[08:29:05.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:05.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:05.193]                   3L)]
[08:29:05.193]             }
[08:29:05.193]             function(cond) {
[08:29:05.193]                 is_error <- inherits(cond, "error")
[08:29:05.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:05.193]                   NULL)
[08:29:05.193]                 if (is_error) {
[08:29:05.193]                   sessionInformation <- function() {
[08:29:05.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:05.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:05.193]                       search = base::search(), system = base::Sys.info())
[08:29:05.193]                   }
[08:29:05.193]                   ...future.conditions[[length(...future.conditions) + 
[08:29:05.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:05.193]                     cond$call), session = sessionInformation(), 
[08:29:05.193]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:05.193]                   signalCondition(cond)
[08:29:05.193]                 }
[08:29:05.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:05.193]                 "immediateCondition"))) {
[08:29:05.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:05.193]                   ...future.conditions[[length(...future.conditions) + 
[08:29:05.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:05.193]                   if (TRUE && !signal) {
[08:29:05.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.193]                     {
[08:29:05.193]                       inherits <- base::inherits
[08:29:05.193]                       invokeRestart <- base::invokeRestart
[08:29:05.193]                       is.null <- base::is.null
[08:29:05.193]                       muffled <- FALSE
[08:29:05.193]                       if (inherits(cond, "message")) {
[08:29:05.193]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:05.193]                         if (muffled) 
[08:29:05.193]                           invokeRestart("muffleMessage")
[08:29:05.193]                       }
[08:29:05.193]                       else if (inherits(cond, "warning")) {
[08:29:05.193]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:05.193]                         if (muffled) 
[08:29:05.193]                           invokeRestart("muffleWarning")
[08:29:05.193]                       }
[08:29:05.193]                       else if (inherits(cond, "condition")) {
[08:29:05.193]                         if (!is.null(pattern)) {
[08:29:05.193]                           computeRestarts <- base::computeRestarts
[08:29:05.193]                           grepl <- base::grepl
[08:29:05.193]                           restarts <- computeRestarts(cond)
[08:29:05.193]                           for (restart in restarts) {
[08:29:05.193]                             name <- restart$name
[08:29:05.193]                             if (is.null(name)) 
[08:29:05.193]                               next
[08:29:05.193]                             if (!grepl(pattern, name)) 
[08:29:05.193]                               next
[08:29:05.193]                             invokeRestart(restart)
[08:29:05.193]                             muffled <- TRUE
[08:29:05.193]                             break
[08:29:05.193]                           }
[08:29:05.193]                         }
[08:29:05.193]                       }
[08:29:05.193]                       invisible(muffled)
[08:29:05.193]                     }
[08:29:05.193]                     muffleCondition(cond, pattern = "^muffle")
[08:29:05.193]                   }
[08:29:05.193]                 }
[08:29:05.193]                 else {
[08:29:05.193]                   if (TRUE) {
[08:29:05.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.193]                     {
[08:29:05.193]                       inherits <- base::inherits
[08:29:05.193]                       invokeRestart <- base::invokeRestart
[08:29:05.193]                       is.null <- base::is.null
[08:29:05.193]                       muffled <- FALSE
[08:29:05.193]                       if (inherits(cond, "message")) {
[08:29:05.193]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:05.193]                         if (muffled) 
[08:29:05.193]                           invokeRestart("muffleMessage")
[08:29:05.193]                       }
[08:29:05.193]                       else if (inherits(cond, "warning")) {
[08:29:05.193]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:05.193]                         if (muffled) 
[08:29:05.193]                           invokeRestart("muffleWarning")
[08:29:05.193]                       }
[08:29:05.193]                       else if (inherits(cond, "condition")) {
[08:29:05.193]                         if (!is.null(pattern)) {
[08:29:05.193]                           computeRestarts <- base::computeRestarts
[08:29:05.193]                           grepl <- base::grepl
[08:29:05.193]                           restarts <- computeRestarts(cond)
[08:29:05.193]                           for (restart in restarts) {
[08:29:05.193]                             name <- restart$name
[08:29:05.193]                             if (is.null(name)) 
[08:29:05.193]                               next
[08:29:05.193]                             if (!grepl(pattern, name)) 
[08:29:05.193]                               next
[08:29:05.193]                             invokeRestart(restart)
[08:29:05.193]                             muffled <- TRUE
[08:29:05.193]                             break
[08:29:05.193]                           }
[08:29:05.193]                         }
[08:29:05.193]                       }
[08:29:05.193]                       invisible(muffled)
[08:29:05.193]                     }
[08:29:05.193]                     muffleCondition(cond, pattern = "^muffle")
[08:29:05.193]                   }
[08:29:05.193]                 }
[08:29:05.193]             }
[08:29:05.193]         }))
[08:29:05.193]     }, error = function(ex) {
[08:29:05.193]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:05.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:05.193]                 ...future.rng), started = ...future.startTime, 
[08:29:05.193]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:05.193]             version = "1.8"), class = "FutureResult")
[08:29:05.193]     }, finally = {
[08:29:05.193]         if (!identical(...future.workdir, getwd())) 
[08:29:05.193]             setwd(...future.workdir)
[08:29:05.193]         {
[08:29:05.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:05.193]                 ...future.oldOptions$nwarnings <- NULL
[08:29:05.193]             }
[08:29:05.193]             base::options(...future.oldOptions)
[08:29:05.193]             if (.Platform$OS.type == "windows") {
[08:29:05.193]                 old_names <- names(...future.oldEnvVars)
[08:29:05.193]                 envs <- base::Sys.getenv()
[08:29:05.193]                 names <- names(envs)
[08:29:05.193]                 common <- intersect(names, old_names)
[08:29:05.193]                 added <- setdiff(names, old_names)
[08:29:05.193]                 removed <- setdiff(old_names, names)
[08:29:05.193]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:05.193]                   envs[common]]
[08:29:05.193]                 NAMES <- toupper(changed)
[08:29:05.193]                 args <- list()
[08:29:05.193]                 for (kk in seq_along(NAMES)) {
[08:29:05.193]                   name <- changed[[kk]]
[08:29:05.193]                   NAME <- NAMES[[kk]]
[08:29:05.193]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.193]                     next
[08:29:05.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:05.193]                 }
[08:29:05.193]                 NAMES <- toupper(added)
[08:29:05.193]                 for (kk in seq_along(NAMES)) {
[08:29:05.193]                   name <- added[[kk]]
[08:29:05.193]                   NAME <- NAMES[[kk]]
[08:29:05.193]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.193]                     next
[08:29:05.193]                   args[[name]] <- ""
[08:29:05.193]                 }
[08:29:05.193]                 NAMES <- toupper(removed)
[08:29:05.193]                 for (kk in seq_along(NAMES)) {
[08:29:05.193]                   name <- removed[[kk]]
[08:29:05.193]                   NAME <- NAMES[[kk]]
[08:29:05.193]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.193]                     next
[08:29:05.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:05.193]                 }
[08:29:05.193]                 if (length(args) > 0) 
[08:29:05.193]                   base::do.call(base::Sys.setenv, args = args)
[08:29:05.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:05.193]             }
[08:29:05.193]             else {
[08:29:05.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:05.193]             }
[08:29:05.193]             {
[08:29:05.193]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:05.193]                   0L) {
[08:29:05.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:05.193]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:05.193]                   base::options(opts)
[08:29:05.193]                 }
[08:29:05.193]                 {
[08:29:05.193]                   {
[08:29:05.193]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:05.193]                     NULL
[08:29:05.193]                   }
[08:29:05.193]                   options(future.plan = NULL)
[08:29:05.193]                   if (is.na(NA_character_)) 
[08:29:05.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:05.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:05.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:05.193]                     .init = FALSE)
[08:29:05.193]                 }
[08:29:05.193]             }
[08:29:05.193]         }
[08:29:05.193]     })
[08:29:05.193]     if (TRUE) {
[08:29:05.193]         base::sink(type = "output", split = FALSE)
[08:29:05.193]         if (TRUE) {
[08:29:05.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:05.193]         }
[08:29:05.193]         else {
[08:29:05.193]             ...future.result["stdout"] <- base::list(NULL)
[08:29:05.193]         }
[08:29:05.193]         base::close(...future.stdout)
[08:29:05.193]         ...future.stdout <- NULL
[08:29:05.193]     }
[08:29:05.193]     ...future.result$conditions <- ...future.conditions
[08:29:05.193]     ...future.result$finished <- base::Sys.time()
[08:29:05.193]     ...future.result
[08:29:05.193] }
[08:29:05.197] MultisessionFuture started
[08:29:05.197] - Launch lazy future ... done
[08:29:05.197] run() for ‘MultisessionFuture’ ... done
[08:29:05.740] receiveMessageFromWorker() for ClusterFuture ...
[08:29:05.740] - Validating connection of MultisessionFuture
[08:29:05.741] - received message: FutureResult
[08:29:05.741] - Received FutureResult
[08:29:05.741] - Erased future from FutureRegistry
[08:29:05.741] result() for ClusterFuture ...
[08:29:05.741] - result already collected: FutureResult
[08:29:05.741] result() for ClusterFuture ... done
[08:29:05.741] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:05.741] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[08:29:05.742] getGlobalsAndPackages() ...
[08:29:05.742] Searching for globals...
[08:29:05.743] - globals found: [2] ‘list’, ‘stop’
[08:29:05.743] Searching for globals ... DONE
[08:29:05.743] Resolving globals: FALSE
[08:29:05.743] 
[08:29:05.743] 
[08:29:05.743] getGlobalsAndPackages() ... DONE
[08:29:05.744] run() for ‘Future’ ...
[08:29:05.744] - state: ‘created’
[08:29:05.744] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:05.759] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:05.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:05.759]   - Field: ‘node’
[08:29:05.759]   - Field: ‘label’
[08:29:05.759]   - Field: ‘local’
[08:29:05.759]   - Field: ‘owner’
[08:29:05.759]   - Field: ‘envir’
[08:29:05.759]   - Field: ‘workers’
[08:29:05.760]   - Field: ‘packages’
[08:29:05.760]   - Field: ‘gc’
[08:29:05.760]   - Field: ‘conditions’
[08:29:05.760]   - Field: ‘persistent’
[08:29:05.760]   - Field: ‘expr’
[08:29:05.760]   - Field: ‘uuid’
[08:29:05.760]   - Field: ‘seed’
[08:29:05.760]   - Field: ‘version’
[08:29:05.760]   - Field: ‘result’
[08:29:05.760]   - Field: ‘asynchronous’
[08:29:05.761]   - Field: ‘calls’
[08:29:05.761]   - Field: ‘globals’
[08:29:05.761]   - Field: ‘stdout’
[08:29:05.761]   - Field: ‘earlySignal’
[08:29:05.761]   - Field: ‘lazy’
[08:29:05.761]   - Field: ‘state’
[08:29:05.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:05.761] - Launch lazy future ...
[08:29:05.762] Packages needed by the future expression (n = 0): <none>
[08:29:05.762] Packages needed by future strategies (n = 0): <none>
[08:29:05.762] {
[08:29:05.762]     {
[08:29:05.762]         {
[08:29:05.762]             ...future.startTime <- base::Sys.time()
[08:29:05.762]             {
[08:29:05.762]                 {
[08:29:05.762]                   {
[08:29:05.762]                     {
[08:29:05.762]                       base::local({
[08:29:05.762]                         has_future <- base::requireNamespace("future", 
[08:29:05.762]                           quietly = TRUE)
[08:29:05.762]                         if (has_future) {
[08:29:05.762]                           ns <- base::getNamespace("future")
[08:29:05.762]                           version <- ns[[".package"]][["version"]]
[08:29:05.762]                           if (is.null(version)) 
[08:29:05.762]                             version <- utils::packageVersion("future")
[08:29:05.762]                         }
[08:29:05.762]                         else {
[08:29:05.762]                           version <- NULL
[08:29:05.762]                         }
[08:29:05.762]                         if (!has_future || version < "1.8.0") {
[08:29:05.762]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:05.762]                             "", base::R.version$version.string), 
[08:29:05.762]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:05.762]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:05.762]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:05.762]                               "release", "version")], collapse = " "), 
[08:29:05.762]                             hostname = base::Sys.info()[["nodename"]])
[08:29:05.762]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:05.762]                             info)
[08:29:05.762]                           info <- base::paste(info, collapse = "; ")
[08:29:05.762]                           if (!has_future) {
[08:29:05.762]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:05.762]                               info)
[08:29:05.762]                           }
[08:29:05.762]                           else {
[08:29:05.762]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:05.762]                               info, version)
[08:29:05.762]                           }
[08:29:05.762]                           base::stop(msg)
[08:29:05.762]                         }
[08:29:05.762]                       })
[08:29:05.762]                     }
[08:29:05.762]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:05.762]                     base::options(mc.cores = 1L)
[08:29:05.762]                   }
[08:29:05.762]                   ...future.strategy.old <- future::plan("list")
[08:29:05.762]                   options(future.plan = NULL)
[08:29:05.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:05.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:05.762]                 }
[08:29:05.762]                 ...future.workdir <- getwd()
[08:29:05.762]             }
[08:29:05.762]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:05.762]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:05.762]         }
[08:29:05.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:05.762]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:05.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:05.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:05.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:05.762]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:05.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:05.762]             base::names(...future.oldOptions))
[08:29:05.762]     }
[08:29:05.762]     if (FALSE) {
[08:29:05.762]     }
[08:29:05.762]     else {
[08:29:05.762]         if (TRUE) {
[08:29:05.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:05.762]                 open = "w")
[08:29:05.762]         }
[08:29:05.762]         else {
[08:29:05.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:05.762]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:05.762]         }
[08:29:05.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:05.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:05.762]             base::sink(type = "output", split = FALSE)
[08:29:05.762]             base::close(...future.stdout)
[08:29:05.762]         }, add = TRUE)
[08:29:05.762]     }
[08:29:05.762]     ...future.frame <- base::sys.nframe()
[08:29:05.762]     ...future.conditions <- base::list()
[08:29:05.762]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:05.762]     if (FALSE) {
[08:29:05.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:05.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:05.762]     }
[08:29:05.762]     ...future.result <- base::tryCatch({
[08:29:05.762]         base::withCallingHandlers({
[08:29:05.762]             ...future.value <- base::withVisible(base::local({
[08:29:05.762]                 ...future.makeSendCondition <- base::local({
[08:29:05.762]                   sendCondition <- NULL
[08:29:05.762]                   function(frame = 1L) {
[08:29:05.762]                     if (is.function(sendCondition)) 
[08:29:05.762]                       return(sendCondition)
[08:29:05.762]                     ns <- getNamespace("parallel")
[08:29:05.762]                     if (exists("sendData", mode = "function", 
[08:29:05.762]                       envir = ns)) {
[08:29:05.762]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:05.762]                         envir = ns)
[08:29:05.762]                       envir <- sys.frame(frame)
[08:29:05.762]                       master <- NULL
[08:29:05.762]                       while (!identical(envir, .GlobalEnv) && 
[08:29:05.762]                         !identical(envir, emptyenv())) {
[08:29:05.762]                         if (exists("master", mode = "list", envir = envir, 
[08:29:05.762]                           inherits = FALSE)) {
[08:29:05.762]                           master <- get("master", mode = "list", 
[08:29:05.762]                             envir = envir, inherits = FALSE)
[08:29:05.762]                           if (inherits(master, c("SOCKnode", 
[08:29:05.762]                             "SOCK0node"))) {
[08:29:05.762]                             sendCondition <<- function(cond) {
[08:29:05.762]                               data <- list(type = "VALUE", value = cond, 
[08:29:05.762]                                 success = TRUE)
[08:29:05.762]                               parallel_sendData(master, data)
[08:29:05.762]                             }
[08:29:05.762]                             return(sendCondition)
[08:29:05.762]                           }
[08:29:05.762]                         }
[08:29:05.762]                         frame <- frame + 1L
[08:29:05.762]                         envir <- sys.frame(frame)
[08:29:05.762]                       }
[08:29:05.762]                     }
[08:29:05.762]                     sendCondition <<- function(cond) NULL
[08:29:05.762]                   }
[08:29:05.762]                 })
[08:29:05.762]                 withCallingHandlers({
[08:29:05.762]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:05.762]                 }, immediateCondition = function(cond) {
[08:29:05.762]                   sendCondition <- ...future.makeSendCondition()
[08:29:05.762]                   sendCondition(cond)
[08:29:05.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.762]                   {
[08:29:05.762]                     inherits <- base::inherits
[08:29:05.762]                     invokeRestart <- base::invokeRestart
[08:29:05.762]                     is.null <- base::is.null
[08:29:05.762]                     muffled <- FALSE
[08:29:05.762]                     if (inherits(cond, "message")) {
[08:29:05.762]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:05.762]                       if (muffled) 
[08:29:05.762]                         invokeRestart("muffleMessage")
[08:29:05.762]                     }
[08:29:05.762]                     else if (inherits(cond, "warning")) {
[08:29:05.762]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:05.762]                       if (muffled) 
[08:29:05.762]                         invokeRestart("muffleWarning")
[08:29:05.762]                     }
[08:29:05.762]                     else if (inherits(cond, "condition")) {
[08:29:05.762]                       if (!is.null(pattern)) {
[08:29:05.762]                         computeRestarts <- base::computeRestarts
[08:29:05.762]                         grepl <- base::grepl
[08:29:05.762]                         restarts <- computeRestarts(cond)
[08:29:05.762]                         for (restart in restarts) {
[08:29:05.762]                           name <- restart$name
[08:29:05.762]                           if (is.null(name)) 
[08:29:05.762]                             next
[08:29:05.762]                           if (!grepl(pattern, name)) 
[08:29:05.762]                             next
[08:29:05.762]                           invokeRestart(restart)
[08:29:05.762]                           muffled <- TRUE
[08:29:05.762]                           break
[08:29:05.762]                         }
[08:29:05.762]                       }
[08:29:05.762]                     }
[08:29:05.762]                     invisible(muffled)
[08:29:05.762]                   }
[08:29:05.762]                   muffleCondition(cond)
[08:29:05.762]                 })
[08:29:05.762]             }))
[08:29:05.762]             future::FutureResult(value = ...future.value$value, 
[08:29:05.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:05.762]                   ...future.rng), globalenv = if (FALSE) 
[08:29:05.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:05.762]                     ...future.globalenv.names))
[08:29:05.762]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:05.762]         }, condition = base::local({
[08:29:05.762]             c <- base::c
[08:29:05.762]             inherits <- base::inherits
[08:29:05.762]             invokeRestart <- base::invokeRestart
[08:29:05.762]             length <- base::length
[08:29:05.762]             list <- base::list
[08:29:05.762]             seq.int <- base::seq.int
[08:29:05.762]             signalCondition <- base::signalCondition
[08:29:05.762]             sys.calls <- base::sys.calls
[08:29:05.762]             `[[` <- base::`[[`
[08:29:05.762]             `+` <- base::`+`
[08:29:05.762]             `<<-` <- base::`<<-`
[08:29:05.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:05.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:05.762]                   3L)]
[08:29:05.762]             }
[08:29:05.762]             function(cond) {
[08:29:05.762]                 is_error <- inherits(cond, "error")
[08:29:05.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:05.762]                   NULL)
[08:29:05.762]                 if (is_error) {
[08:29:05.762]                   sessionInformation <- function() {
[08:29:05.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:05.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:05.762]                       search = base::search(), system = base::Sys.info())
[08:29:05.762]                   }
[08:29:05.762]                   ...future.conditions[[length(...future.conditions) + 
[08:29:05.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:05.762]                     cond$call), session = sessionInformation(), 
[08:29:05.762]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:05.762]                   signalCondition(cond)
[08:29:05.762]                 }
[08:29:05.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:05.762]                 "immediateCondition"))) {
[08:29:05.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:05.762]                   ...future.conditions[[length(...future.conditions) + 
[08:29:05.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:05.762]                   if (TRUE && !signal) {
[08:29:05.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.762]                     {
[08:29:05.762]                       inherits <- base::inherits
[08:29:05.762]                       invokeRestart <- base::invokeRestart
[08:29:05.762]                       is.null <- base::is.null
[08:29:05.762]                       muffled <- FALSE
[08:29:05.762]                       if (inherits(cond, "message")) {
[08:29:05.762]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:05.762]                         if (muffled) 
[08:29:05.762]                           invokeRestart("muffleMessage")
[08:29:05.762]                       }
[08:29:05.762]                       else if (inherits(cond, "warning")) {
[08:29:05.762]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:05.762]                         if (muffled) 
[08:29:05.762]                           invokeRestart("muffleWarning")
[08:29:05.762]                       }
[08:29:05.762]                       else if (inherits(cond, "condition")) {
[08:29:05.762]                         if (!is.null(pattern)) {
[08:29:05.762]                           computeRestarts <- base::computeRestarts
[08:29:05.762]                           grepl <- base::grepl
[08:29:05.762]                           restarts <- computeRestarts(cond)
[08:29:05.762]                           for (restart in restarts) {
[08:29:05.762]                             name <- restart$name
[08:29:05.762]                             if (is.null(name)) 
[08:29:05.762]                               next
[08:29:05.762]                             if (!grepl(pattern, name)) 
[08:29:05.762]                               next
[08:29:05.762]                             invokeRestart(restart)
[08:29:05.762]                             muffled <- TRUE
[08:29:05.762]                             break
[08:29:05.762]                           }
[08:29:05.762]                         }
[08:29:05.762]                       }
[08:29:05.762]                       invisible(muffled)
[08:29:05.762]                     }
[08:29:05.762]                     muffleCondition(cond, pattern = "^muffle")
[08:29:05.762]                   }
[08:29:05.762]                 }
[08:29:05.762]                 else {
[08:29:05.762]                   if (TRUE) {
[08:29:05.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.762]                     {
[08:29:05.762]                       inherits <- base::inherits
[08:29:05.762]                       invokeRestart <- base::invokeRestart
[08:29:05.762]                       is.null <- base::is.null
[08:29:05.762]                       muffled <- FALSE
[08:29:05.762]                       if (inherits(cond, "message")) {
[08:29:05.762]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:05.762]                         if (muffled) 
[08:29:05.762]                           invokeRestart("muffleMessage")
[08:29:05.762]                       }
[08:29:05.762]                       else if (inherits(cond, "warning")) {
[08:29:05.762]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:05.762]                         if (muffled) 
[08:29:05.762]                           invokeRestart("muffleWarning")
[08:29:05.762]                       }
[08:29:05.762]                       else if (inherits(cond, "condition")) {
[08:29:05.762]                         if (!is.null(pattern)) {
[08:29:05.762]                           computeRestarts <- base::computeRestarts
[08:29:05.762]                           grepl <- base::grepl
[08:29:05.762]                           restarts <- computeRestarts(cond)
[08:29:05.762]                           for (restart in restarts) {
[08:29:05.762]                             name <- restart$name
[08:29:05.762]                             if (is.null(name)) 
[08:29:05.762]                               next
[08:29:05.762]                             if (!grepl(pattern, name)) 
[08:29:05.762]                               next
[08:29:05.762]                             invokeRestart(restart)
[08:29:05.762]                             muffled <- TRUE
[08:29:05.762]                             break
[08:29:05.762]                           }
[08:29:05.762]                         }
[08:29:05.762]                       }
[08:29:05.762]                       invisible(muffled)
[08:29:05.762]                     }
[08:29:05.762]                     muffleCondition(cond, pattern = "^muffle")
[08:29:05.762]                   }
[08:29:05.762]                 }
[08:29:05.762]             }
[08:29:05.762]         }))
[08:29:05.762]     }, error = function(ex) {
[08:29:05.762]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:05.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:05.762]                 ...future.rng), started = ...future.startTime, 
[08:29:05.762]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:05.762]             version = "1.8"), class = "FutureResult")
[08:29:05.762]     }, finally = {
[08:29:05.762]         if (!identical(...future.workdir, getwd())) 
[08:29:05.762]             setwd(...future.workdir)
[08:29:05.762]         {
[08:29:05.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:05.762]                 ...future.oldOptions$nwarnings <- NULL
[08:29:05.762]             }
[08:29:05.762]             base::options(...future.oldOptions)
[08:29:05.762]             if (.Platform$OS.type == "windows") {
[08:29:05.762]                 old_names <- names(...future.oldEnvVars)
[08:29:05.762]                 envs <- base::Sys.getenv()
[08:29:05.762]                 names <- names(envs)
[08:29:05.762]                 common <- intersect(names, old_names)
[08:29:05.762]                 added <- setdiff(names, old_names)
[08:29:05.762]                 removed <- setdiff(old_names, names)
[08:29:05.762]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:05.762]                   envs[common]]
[08:29:05.762]                 NAMES <- toupper(changed)
[08:29:05.762]                 args <- list()
[08:29:05.762]                 for (kk in seq_along(NAMES)) {
[08:29:05.762]                   name <- changed[[kk]]
[08:29:05.762]                   NAME <- NAMES[[kk]]
[08:29:05.762]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.762]                     next
[08:29:05.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:05.762]                 }
[08:29:05.762]                 NAMES <- toupper(added)
[08:29:05.762]                 for (kk in seq_along(NAMES)) {
[08:29:05.762]                   name <- added[[kk]]
[08:29:05.762]                   NAME <- NAMES[[kk]]
[08:29:05.762]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.762]                     next
[08:29:05.762]                   args[[name]] <- ""
[08:29:05.762]                 }
[08:29:05.762]                 NAMES <- toupper(removed)
[08:29:05.762]                 for (kk in seq_along(NAMES)) {
[08:29:05.762]                   name <- removed[[kk]]
[08:29:05.762]                   NAME <- NAMES[[kk]]
[08:29:05.762]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.762]                     next
[08:29:05.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:05.762]                 }
[08:29:05.762]                 if (length(args) > 0) 
[08:29:05.762]                   base::do.call(base::Sys.setenv, args = args)
[08:29:05.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:05.762]             }
[08:29:05.762]             else {
[08:29:05.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:05.762]             }
[08:29:05.762]             {
[08:29:05.762]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:05.762]                   0L) {
[08:29:05.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:05.762]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:05.762]                   base::options(opts)
[08:29:05.762]                 }
[08:29:05.762]                 {
[08:29:05.762]                   {
[08:29:05.762]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:05.762]                     NULL
[08:29:05.762]                   }
[08:29:05.762]                   options(future.plan = NULL)
[08:29:05.762]                   if (is.na(NA_character_)) 
[08:29:05.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:05.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:05.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:05.762]                     .init = FALSE)
[08:29:05.762]                 }
[08:29:05.762]             }
[08:29:05.762]         }
[08:29:05.762]     })
[08:29:05.762]     if (TRUE) {
[08:29:05.762]         base::sink(type = "output", split = FALSE)
[08:29:05.762]         if (TRUE) {
[08:29:05.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:05.762]         }
[08:29:05.762]         else {
[08:29:05.762]             ...future.result["stdout"] <- base::list(NULL)
[08:29:05.762]         }
[08:29:05.762]         base::close(...future.stdout)
[08:29:05.762]         ...future.stdout <- NULL
[08:29:05.762]     }
[08:29:05.762]     ...future.result$conditions <- ...future.conditions
[08:29:05.762]     ...future.result$finished <- base::Sys.time()
[08:29:05.762]     ...future.result
[08:29:05.762] }
[08:29:05.766] MultisessionFuture started
[08:29:05.766] - Launch lazy future ... done
[08:29:05.766] run() for ‘MultisessionFuture’ ... done
[08:29:05.809] receiveMessageFromWorker() for ClusterFuture ...
[08:29:05.809] - Validating connection of MultisessionFuture
[08:29:05.809] - received message: FutureResult
[08:29:05.810] - Received FutureResult
[08:29:05.810] - Erased future from FutureRegistry
[08:29:05.810] result() for ClusterFuture ...
[08:29:05.810] - result already collected: FutureResult
[08:29:05.810] result() for ClusterFuture ... done
[08:29:05.810] signalConditions() ...
[08:29:05.811]  - include = ‘immediateCondition’
[08:29:05.811]  - exclude = 
[08:29:05.811]  - resignal = FALSE
[08:29:05.811]  - Number of conditions: 1
[08:29:05.811] signalConditions() ... done
[08:29:05.811] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:05.811] A MultisessionFuture was resolved (result was not collected)
[08:29:05.811] getGlobalsAndPackages() ...
[08:29:05.812] Searching for globals...
[08:29:05.812] - globals found: [2] ‘list’, ‘stop’
[08:29:05.812] Searching for globals ... DONE
[08:29:05.813] Resolving globals: FALSE
[08:29:05.813] 
[08:29:05.813] 
[08:29:05.813] getGlobalsAndPackages() ... DONE
[08:29:05.814] run() for ‘Future’ ...
[08:29:05.814] - state: ‘created’
[08:29:05.814] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:05.828] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:05.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:05.829]   - Field: ‘node’
[08:29:05.829]   - Field: ‘label’
[08:29:05.829]   - Field: ‘local’
[08:29:05.829]   - Field: ‘owner’
[08:29:05.829]   - Field: ‘envir’
[08:29:05.829]   - Field: ‘workers’
[08:29:05.829]   - Field: ‘packages’
[08:29:05.829]   - Field: ‘gc’
[08:29:05.829]   - Field: ‘conditions’
[08:29:05.829]   - Field: ‘persistent’
[08:29:05.830]   - Field: ‘expr’
[08:29:05.830]   - Field: ‘uuid’
[08:29:05.830]   - Field: ‘seed’
[08:29:05.830]   - Field: ‘version’
[08:29:05.830]   - Field: ‘result’
[08:29:05.830]   - Field: ‘asynchronous’
[08:29:05.830]   - Field: ‘calls’
[08:29:05.830]   - Field: ‘globals’
[08:29:05.830]   - Field: ‘stdout’
[08:29:05.831]   - Field: ‘earlySignal’
[08:29:05.831]   - Field: ‘lazy’
[08:29:05.831]   - Field: ‘state’
[08:29:05.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:05.831] - Launch lazy future ...
[08:29:05.831] Packages needed by the future expression (n = 0): <none>
[08:29:05.831] Packages needed by future strategies (n = 0): <none>
[08:29:05.832] {
[08:29:05.832]     {
[08:29:05.832]         {
[08:29:05.832]             ...future.startTime <- base::Sys.time()
[08:29:05.832]             {
[08:29:05.832]                 {
[08:29:05.832]                   {
[08:29:05.832]                     {
[08:29:05.832]                       base::local({
[08:29:05.832]                         has_future <- base::requireNamespace("future", 
[08:29:05.832]                           quietly = TRUE)
[08:29:05.832]                         if (has_future) {
[08:29:05.832]                           ns <- base::getNamespace("future")
[08:29:05.832]                           version <- ns[[".package"]][["version"]]
[08:29:05.832]                           if (is.null(version)) 
[08:29:05.832]                             version <- utils::packageVersion("future")
[08:29:05.832]                         }
[08:29:05.832]                         else {
[08:29:05.832]                           version <- NULL
[08:29:05.832]                         }
[08:29:05.832]                         if (!has_future || version < "1.8.0") {
[08:29:05.832]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:05.832]                             "", base::R.version$version.string), 
[08:29:05.832]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:05.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:05.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:05.832]                               "release", "version")], collapse = " "), 
[08:29:05.832]                             hostname = base::Sys.info()[["nodename"]])
[08:29:05.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:05.832]                             info)
[08:29:05.832]                           info <- base::paste(info, collapse = "; ")
[08:29:05.832]                           if (!has_future) {
[08:29:05.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:05.832]                               info)
[08:29:05.832]                           }
[08:29:05.832]                           else {
[08:29:05.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:05.832]                               info, version)
[08:29:05.832]                           }
[08:29:05.832]                           base::stop(msg)
[08:29:05.832]                         }
[08:29:05.832]                       })
[08:29:05.832]                     }
[08:29:05.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:05.832]                     base::options(mc.cores = 1L)
[08:29:05.832]                   }
[08:29:05.832]                   ...future.strategy.old <- future::plan("list")
[08:29:05.832]                   options(future.plan = NULL)
[08:29:05.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:05.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:05.832]                 }
[08:29:05.832]                 ...future.workdir <- getwd()
[08:29:05.832]             }
[08:29:05.832]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:05.832]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:05.832]         }
[08:29:05.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:05.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:05.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:05.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:05.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:05.832]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:05.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:05.832]             base::names(...future.oldOptions))
[08:29:05.832]     }
[08:29:05.832]     if (FALSE) {
[08:29:05.832]     }
[08:29:05.832]     else {
[08:29:05.832]         if (TRUE) {
[08:29:05.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:05.832]                 open = "w")
[08:29:05.832]         }
[08:29:05.832]         else {
[08:29:05.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:05.832]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:05.832]         }
[08:29:05.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:05.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:05.832]             base::sink(type = "output", split = FALSE)
[08:29:05.832]             base::close(...future.stdout)
[08:29:05.832]         }, add = TRUE)
[08:29:05.832]     }
[08:29:05.832]     ...future.frame <- base::sys.nframe()
[08:29:05.832]     ...future.conditions <- base::list()
[08:29:05.832]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:05.832]     if (FALSE) {
[08:29:05.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:05.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:05.832]     }
[08:29:05.832]     ...future.result <- base::tryCatch({
[08:29:05.832]         base::withCallingHandlers({
[08:29:05.832]             ...future.value <- base::withVisible(base::local({
[08:29:05.832]                 ...future.makeSendCondition <- base::local({
[08:29:05.832]                   sendCondition <- NULL
[08:29:05.832]                   function(frame = 1L) {
[08:29:05.832]                     if (is.function(sendCondition)) 
[08:29:05.832]                       return(sendCondition)
[08:29:05.832]                     ns <- getNamespace("parallel")
[08:29:05.832]                     if (exists("sendData", mode = "function", 
[08:29:05.832]                       envir = ns)) {
[08:29:05.832]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:05.832]                         envir = ns)
[08:29:05.832]                       envir <- sys.frame(frame)
[08:29:05.832]                       master <- NULL
[08:29:05.832]                       while (!identical(envir, .GlobalEnv) && 
[08:29:05.832]                         !identical(envir, emptyenv())) {
[08:29:05.832]                         if (exists("master", mode = "list", envir = envir, 
[08:29:05.832]                           inherits = FALSE)) {
[08:29:05.832]                           master <- get("master", mode = "list", 
[08:29:05.832]                             envir = envir, inherits = FALSE)
[08:29:05.832]                           if (inherits(master, c("SOCKnode", 
[08:29:05.832]                             "SOCK0node"))) {
[08:29:05.832]                             sendCondition <<- function(cond) {
[08:29:05.832]                               data <- list(type = "VALUE", value = cond, 
[08:29:05.832]                                 success = TRUE)
[08:29:05.832]                               parallel_sendData(master, data)
[08:29:05.832]                             }
[08:29:05.832]                             return(sendCondition)
[08:29:05.832]                           }
[08:29:05.832]                         }
[08:29:05.832]                         frame <- frame + 1L
[08:29:05.832]                         envir <- sys.frame(frame)
[08:29:05.832]                       }
[08:29:05.832]                     }
[08:29:05.832]                     sendCondition <<- function(cond) NULL
[08:29:05.832]                   }
[08:29:05.832]                 })
[08:29:05.832]                 withCallingHandlers({
[08:29:05.832]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:05.832]                 }, immediateCondition = function(cond) {
[08:29:05.832]                   sendCondition <- ...future.makeSendCondition()
[08:29:05.832]                   sendCondition(cond)
[08:29:05.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.832]                   {
[08:29:05.832]                     inherits <- base::inherits
[08:29:05.832]                     invokeRestart <- base::invokeRestart
[08:29:05.832]                     is.null <- base::is.null
[08:29:05.832]                     muffled <- FALSE
[08:29:05.832]                     if (inherits(cond, "message")) {
[08:29:05.832]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:05.832]                       if (muffled) 
[08:29:05.832]                         invokeRestart("muffleMessage")
[08:29:05.832]                     }
[08:29:05.832]                     else if (inherits(cond, "warning")) {
[08:29:05.832]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:05.832]                       if (muffled) 
[08:29:05.832]                         invokeRestart("muffleWarning")
[08:29:05.832]                     }
[08:29:05.832]                     else if (inherits(cond, "condition")) {
[08:29:05.832]                       if (!is.null(pattern)) {
[08:29:05.832]                         computeRestarts <- base::computeRestarts
[08:29:05.832]                         grepl <- base::grepl
[08:29:05.832]                         restarts <- computeRestarts(cond)
[08:29:05.832]                         for (restart in restarts) {
[08:29:05.832]                           name <- restart$name
[08:29:05.832]                           if (is.null(name)) 
[08:29:05.832]                             next
[08:29:05.832]                           if (!grepl(pattern, name)) 
[08:29:05.832]                             next
[08:29:05.832]                           invokeRestart(restart)
[08:29:05.832]                           muffled <- TRUE
[08:29:05.832]                           break
[08:29:05.832]                         }
[08:29:05.832]                       }
[08:29:05.832]                     }
[08:29:05.832]                     invisible(muffled)
[08:29:05.832]                   }
[08:29:05.832]                   muffleCondition(cond)
[08:29:05.832]                 })
[08:29:05.832]             }))
[08:29:05.832]             future::FutureResult(value = ...future.value$value, 
[08:29:05.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:05.832]                   ...future.rng), globalenv = if (FALSE) 
[08:29:05.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:05.832]                     ...future.globalenv.names))
[08:29:05.832]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:05.832]         }, condition = base::local({
[08:29:05.832]             c <- base::c
[08:29:05.832]             inherits <- base::inherits
[08:29:05.832]             invokeRestart <- base::invokeRestart
[08:29:05.832]             length <- base::length
[08:29:05.832]             list <- base::list
[08:29:05.832]             seq.int <- base::seq.int
[08:29:05.832]             signalCondition <- base::signalCondition
[08:29:05.832]             sys.calls <- base::sys.calls
[08:29:05.832]             `[[` <- base::`[[`
[08:29:05.832]             `+` <- base::`+`
[08:29:05.832]             `<<-` <- base::`<<-`
[08:29:05.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:05.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:05.832]                   3L)]
[08:29:05.832]             }
[08:29:05.832]             function(cond) {
[08:29:05.832]                 is_error <- inherits(cond, "error")
[08:29:05.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:05.832]                   NULL)
[08:29:05.832]                 if (is_error) {
[08:29:05.832]                   sessionInformation <- function() {
[08:29:05.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:05.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:05.832]                       search = base::search(), system = base::Sys.info())
[08:29:05.832]                   }
[08:29:05.832]                   ...future.conditions[[length(...future.conditions) + 
[08:29:05.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:05.832]                     cond$call), session = sessionInformation(), 
[08:29:05.832]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:05.832]                   signalCondition(cond)
[08:29:05.832]                 }
[08:29:05.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:05.832]                 "immediateCondition"))) {
[08:29:05.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:05.832]                   ...future.conditions[[length(...future.conditions) + 
[08:29:05.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:05.832]                   if (TRUE && !signal) {
[08:29:05.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.832]                     {
[08:29:05.832]                       inherits <- base::inherits
[08:29:05.832]                       invokeRestart <- base::invokeRestart
[08:29:05.832]                       is.null <- base::is.null
[08:29:05.832]                       muffled <- FALSE
[08:29:05.832]                       if (inherits(cond, "message")) {
[08:29:05.832]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:05.832]                         if (muffled) 
[08:29:05.832]                           invokeRestart("muffleMessage")
[08:29:05.832]                       }
[08:29:05.832]                       else if (inherits(cond, "warning")) {
[08:29:05.832]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:05.832]                         if (muffled) 
[08:29:05.832]                           invokeRestart("muffleWarning")
[08:29:05.832]                       }
[08:29:05.832]                       else if (inherits(cond, "condition")) {
[08:29:05.832]                         if (!is.null(pattern)) {
[08:29:05.832]                           computeRestarts <- base::computeRestarts
[08:29:05.832]                           grepl <- base::grepl
[08:29:05.832]                           restarts <- computeRestarts(cond)
[08:29:05.832]                           for (restart in restarts) {
[08:29:05.832]                             name <- restart$name
[08:29:05.832]                             if (is.null(name)) 
[08:29:05.832]                               next
[08:29:05.832]                             if (!grepl(pattern, name)) 
[08:29:05.832]                               next
[08:29:05.832]                             invokeRestart(restart)
[08:29:05.832]                             muffled <- TRUE
[08:29:05.832]                             break
[08:29:05.832]                           }
[08:29:05.832]                         }
[08:29:05.832]                       }
[08:29:05.832]                       invisible(muffled)
[08:29:05.832]                     }
[08:29:05.832]                     muffleCondition(cond, pattern = "^muffle")
[08:29:05.832]                   }
[08:29:05.832]                 }
[08:29:05.832]                 else {
[08:29:05.832]                   if (TRUE) {
[08:29:05.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.832]                     {
[08:29:05.832]                       inherits <- base::inherits
[08:29:05.832]                       invokeRestart <- base::invokeRestart
[08:29:05.832]                       is.null <- base::is.null
[08:29:05.832]                       muffled <- FALSE
[08:29:05.832]                       if (inherits(cond, "message")) {
[08:29:05.832]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:05.832]                         if (muffled) 
[08:29:05.832]                           invokeRestart("muffleMessage")
[08:29:05.832]                       }
[08:29:05.832]                       else if (inherits(cond, "warning")) {
[08:29:05.832]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:05.832]                         if (muffled) 
[08:29:05.832]                           invokeRestart("muffleWarning")
[08:29:05.832]                       }
[08:29:05.832]                       else if (inherits(cond, "condition")) {
[08:29:05.832]                         if (!is.null(pattern)) {
[08:29:05.832]                           computeRestarts <- base::computeRestarts
[08:29:05.832]                           grepl <- base::grepl
[08:29:05.832]                           restarts <- computeRestarts(cond)
[08:29:05.832]                           for (restart in restarts) {
[08:29:05.832]                             name <- restart$name
[08:29:05.832]                             if (is.null(name)) 
[08:29:05.832]                               next
[08:29:05.832]                             if (!grepl(pattern, name)) 
[08:29:05.832]                               next
[08:29:05.832]                             invokeRestart(restart)
[08:29:05.832]                             muffled <- TRUE
[08:29:05.832]                             break
[08:29:05.832]                           }
[08:29:05.832]                         }
[08:29:05.832]                       }
[08:29:05.832]                       invisible(muffled)
[08:29:05.832]                     }
[08:29:05.832]                     muffleCondition(cond, pattern = "^muffle")
[08:29:05.832]                   }
[08:29:05.832]                 }
[08:29:05.832]             }
[08:29:05.832]         }))
[08:29:05.832]     }, error = function(ex) {
[08:29:05.832]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:05.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:05.832]                 ...future.rng), started = ...future.startTime, 
[08:29:05.832]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:05.832]             version = "1.8"), class = "FutureResult")
[08:29:05.832]     }, finally = {
[08:29:05.832]         if (!identical(...future.workdir, getwd())) 
[08:29:05.832]             setwd(...future.workdir)
[08:29:05.832]         {
[08:29:05.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:05.832]                 ...future.oldOptions$nwarnings <- NULL
[08:29:05.832]             }
[08:29:05.832]             base::options(...future.oldOptions)
[08:29:05.832]             if (.Platform$OS.type == "windows") {
[08:29:05.832]                 old_names <- names(...future.oldEnvVars)
[08:29:05.832]                 envs <- base::Sys.getenv()
[08:29:05.832]                 names <- names(envs)
[08:29:05.832]                 common <- intersect(names, old_names)
[08:29:05.832]                 added <- setdiff(names, old_names)
[08:29:05.832]                 removed <- setdiff(old_names, names)
[08:29:05.832]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:05.832]                   envs[common]]
[08:29:05.832]                 NAMES <- toupper(changed)
[08:29:05.832]                 args <- list()
[08:29:05.832]                 for (kk in seq_along(NAMES)) {
[08:29:05.832]                   name <- changed[[kk]]
[08:29:05.832]                   NAME <- NAMES[[kk]]
[08:29:05.832]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.832]                     next
[08:29:05.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:05.832]                 }
[08:29:05.832]                 NAMES <- toupper(added)
[08:29:05.832]                 for (kk in seq_along(NAMES)) {
[08:29:05.832]                   name <- added[[kk]]
[08:29:05.832]                   NAME <- NAMES[[kk]]
[08:29:05.832]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.832]                     next
[08:29:05.832]                   args[[name]] <- ""
[08:29:05.832]                 }
[08:29:05.832]                 NAMES <- toupper(removed)
[08:29:05.832]                 for (kk in seq_along(NAMES)) {
[08:29:05.832]                   name <- removed[[kk]]
[08:29:05.832]                   NAME <- NAMES[[kk]]
[08:29:05.832]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.832]                     next
[08:29:05.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:05.832]                 }
[08:29:05.832]                 if (length(args) > 0) 
[08:29:05.832]                   base::do.call(base::Sys.setenv, args = args)
[08:29:05.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:05.832]             }
[08:29:05.832]             else {
[08:29:05.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:05.832]             }
[08:29:05.832]             {
[08:29:05.832]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:05.832]                   0L) {
[08:29:05.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:05.832]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:05.832]                   base::options(opts)
[08:29:05.832]                 }
[08:29:05.832]                 {
[08:29:05.832]                   {
[08:29:05.832]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:05.832]                     NULL
[08:29:05.832]                   }
[08:29:05.832]                   options(future.plan = NULL)
[08:29:05.832]                   if (is.na(NA_character_)) 
[08:29:05.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:05.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:05.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:05.832]                     .init = FALSE)
[08:29:05.832]                 }
[08:29:05.832]             }
[08:29:05.832]         }
[08:29:05.832]     })
[08:29:05.832]     if (TRUE) {
[08:29:05.832]         base::sink(type = "output", split = FALSE)
[08:29:05.832]         if (TRUE) {
[08:29:05.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:05.832]         }
[08:29:05.832]         else {
[08:29:05.832]             ...future.result["stdout"] <- base::list(NULL)
[08:29:05.832]         }
[08:29:05.832]         base::close(...future.stdout)
[08:29:05.832]         ...future.stdout <- NULL
[08:29:05.832]     }
[08:29:05.832]     ...future.result$conditions <- ...future.conditions
[08:29:05.832]     ...future.result$finished <- base::Sys.time()
[08:29:05.832]     ...future.result
[08:29:05.832] }
[08:29:05.835] MultisessionFuture started
[08:29:05.835] - Launch lazy future ... done
[08:29:05.835] run() for ‘MultisessionFuture’ ... done
[08:29:05.877] receiveMessageFromWorker() for ClusterFuture ...
[08:29:05.878] - Validating connection of MultisessionFuture
[08:29:05.878] - received message: FutureResult
[08:29:05.878] - Received FutureResult
[08:29:05.878] - Erased future from FutureRegistry
[08:29:05.878] result() for ClusterFuture ...
[08:29:05.879] - result already collected: FutureResult
[08:29:05.879] result() for ClusterFuture ... done
[08:29:05.879] signalConditions() ...
[08:29:05.879]  - include = ‘immediateCondition’
[08:29:05.879]  - exclude = 
[08:29:05.879]  - resignal = FALSE
[08:29:05.879]  - Number of conditions: 1
[08:29:05.879] signalConditions() ... done
[08:29:05.879] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:05.880] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[08:29:05.880] getGlobalsAndPackages() ...
[08:29:05.880] Searching for globals...
[08:29:05.881] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:05.881] Searching for globals ... DONE
[08:29:05.882] Resolving globals: FALSE
[08:29:05.882] 
[08:29:05.882] 
[08:29:05.882] getGlobalsAndPackages() ... DONE
[08:29:05.882] run() for ‘Future’ ...
[08:29:05.883] - state: ‘created’
[08:29:05.883] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:05.897] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:05.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:05.900]   - Field: ‘node’
[08:29:05.900]   - Field: ‘label’
[08:29:05.900]   - Field: ‘local’
[08:29:05.900]   - Field: ‘owner’
[08:29:05.900]   - Field: ‘envir’
[08:29:05.900]   - Field: ‘workers’
[08:29:05.900]   - Field: ‘packages’
[08:29:05.900]   - Field: ‘gc’
[08:29:05.900]   - Field: ‘conditions’
[08:29:05.900]   - Field: ‘persistent’
[08:29:05.900]   - Field: ‘expr’
[08:29:05.901]   - Field: ‘uuid’
[08:29:05.901]   - Field: ‘seed’
[08:29:05.901]   - Field: ‘version’
[08:29:05.901]   - Field: ‘result’
[08:29:05.901]   - Field: ‘asynchronous’
[08:29:05.901]   - Field: ‘calls’
[08:29:05.901]   - Field: ‘globals’
[08:29:05.901]   - Field: ‘stdout’
[08:29:05.901]   - Field: ‘earlySignal’
[08:29:05.901]   - Field: ‘lazy’
[08:29:05.901]   - Field: ‘state’
[08:29:05.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:05.902] - Launch lazy future ...
[08:29:05.902] Packages needed by the future expression (n = 0): <none>
[08:29:05.902] Packages needed by future strategies (n = 0): <none>
[08:29:05.902] {
[08:29:05.902]     {
[08:29:05.902]         {
[08:29:05.902]             ...future.startTime <- base::Sys.time()
[08:29:05.902]             {
[08:29:05.902]                 {
[08:29:05.902]                   {
[08:29:05.902]                     {
[08:29:05.902]                       base::local({
[08:29:05.902]                         has_future <- base::requireNamespace("future", 
[08:29:05.902]                           quietly = TRUE)
[08:29:05.902]                         if (has_future) {
[08:29:05.902]                           ns <- base::getNamespace("future")
[08:29:05.902]                           version <- ns[[".package"]][["version"]]
[08:29:05.902]                           if (is.null(version)) 
[08:29:05.902]                             version <- utils::packageVersion("future")
[08:29:05.902]                         }
[08:29:05.902]                         else {
[08:29:05.902]                           version <- NULL
[08:29:05.902]                         }
[08:29:05.902]                         if (!has_future || version < "1.8.0") {
[08:29:05.902]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:05.902]                             "", base::R.version$version.string), 
[08:29:05.902]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:05.902]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:05.902]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:05.902]                               "release", "version")], collapse = " "), 
[08:29:05.902]                             hostname = base::Sys.info()[["nodename"]])
[08:29:05.902]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:05.902]                             info)
[08:29:05.902]                           info <- base::paste(info, collapse = "; ")
[08:29:05.902]                           if (!has_future) {
[08:29:05.902]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:05.902]                               info)
[08:29:05.902]                           }
[08:29:05.902]                           else {
[08:29:05.902]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:05.902]                               info, version)
[08:29:05.902]                           }
[08:29:05.902]                           base::stop(msg)
[08:29:05.902]                         }
[08:29:05.902]                       })
[08:29:05.902]                     }
[08:29:05.902]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:05.902]                     base::options(mc.cores = 1L)
[08:29:05.902]                   }
[08:29:05.902]                   ...future.strategy.old <- future::plan("list")
[08:29:05.902]                   options(future.plan = NULL)
[08:29:05.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:05.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:05.902]                 }
[08:29:05.902]                 ...future.workdir <- getwd()
[08:29:05.902]             }
[08:29:05.902]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:05.902]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:05.902]         }
[08:29:05.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:05.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:05.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:05.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:05.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:05.902]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:05.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:05.902]             base::names(...future.oldOptions))
[08:29:05.902]     }
[08:29:05.902]     if (FALSE) {
[08:29:05.902]     }
[08:29:05.902]     else {
[08:29:05.902]         if (TRUE) {
[08:29:05.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:05.902]                 open = "w")
[08:29:05.902]         }
[08:29:05.902]         else {
[08:29:05.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:05.902]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:05.902]         }
[08:29:05.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:05.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:05.902]             base::sink(type = "output", split = FALSE)
[08:29:05.902]             base::close(...future.stdout)
[08:29:05.902]         }, add = TRUE)
[08:29:05.902]     }
[08:29:05.902]     ...future.frame <- base::sys.nframe()
[08:29:05.902]     ...future.conditions <- base::list()
[08:29:05.902]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:05.902]     if (FALSE) {
[08:29:05.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:05.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:05.902]     }
[08:29:05.902]     ...future.result <- base::tryCatch({
[08:29:05.902]         base::withCallingHandlers({
[08:29:05.902]             ...future.value <- base::withVisible(base::local({
[08:29:05.902]                 ...future.makeSendCondition <- base::local({
[08:29:05.902]                   sendCondition <- NULL
[08:29:05.902]                   function(frame = 1L) {
[08:29:05.902]                     if (is.function(sendCondition)) 
[08:29:05.902]                       return(sendCondition)
[08:29:05.902]                     ns <- getNamespace("parallel")
[08:29:05.902]                     if (exists("sendData", mode = "function", 
[08:29:05.902]                       envir = ns)) {
[08:29:05.902]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:05.902]                         envir = ns)
[08:29:05.902]                       envir <- sys.frame(frame)
[08:29:05.902]                       master <- NULL
[08:29:05.902]                       while (!identical(envir, .GlobalEnv) && 
[08:29:05.902]                         !identical(envir, emptyenv())) {
[08:29:05.902]                         if (exists("master", mode = "list", envir = envir, 
[08:29:05.902]                           inherits = FALSE)) {
[08:29:05.902]                           master <- get("master", mode = "list", 
[08:29:05.902]                             envir = envir, inherits = FALSE)
[08:29:05.902]                           if (inherits(master, c("SOCKnode", 
[08:29:05.902]                             "SOCK0node"))) {
[08:29:05.902]                             sendCondition <<- function(cond) {
[08:29:05.902]                               data <- list(type = "VALUE", value = cond, 
[08:29:05.902]                                 success = TRUE)
[08:29:05.902]                               parallel_sendData(master, data)
[08:29:05.902]                             }
[08:29:05.902]                             return(sendCondition)
[08:29:05.902]                           }
[08:29:05.902]                         }
[08:29:05.902]                         frame <- frame + 1L
[08:29:05.902]                         envir <- sys.frame(frame)
[08:29:05.902]                       }
[08:29:05.902]                     }
[08:29:05.902]                     sendCondition <<- function(cond) NULL
[08:29:05.902]                   }
[08:29:05.902]                 })
[08:29:05.902]                 withCallingHandlers({
[08:29:05.902]                   {
[08:29:05.902]                     Sys.sleep(0.5)
[08:29:05.902]                     list(a = 1, b = 42L)
[08:29:05.902]                   }
[08:29:05.902]                 }, immediateCondition = function(cond) {
[08:29:05.902]                   sendCondition <- ...future.makeSendCondition()
[08:29:05.902]                   sendCondition(cond)
[08:29:05.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.902]                   {
[08:29:05.902]                     inherits <- base::inherits
[08:29:05.902]                     invokeRestart <- base::invokeRestart
[08:29:05.902]                     is.null <- base::is.null
[08:29:05.902]                     muffled <- FALSE
[08:29:05.902]                     if (inherits(cond, "message")) {
[08:29:05.902]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:05.902]                       if (muffled) 
[08:29:05.902]                         invokeRestart("muffleMessage")
[08:29:05.902]                     }
[08:29:05.902]                     else if (inherits(cond, "warning")) {
[08:29:05.902]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:05.902]                       if (muffled) 
[08:29:05.902]                         invokeRestart("muffleWarning")
[08:29:05.902]                     }
[08:29:05.902]                     else if (inherits(cond, "condition")) {
[08:29:05.902]                       if (!is.null(pattern)) {
[08:29:05.902]                         computeRestarts <- base::computeRestarts
[08:29:05.902]                         grepl <- base::grepl
[08:29:05.902]                         restarts <- computeRestarts(cond)
[08:29:05.902]                         for (restart in restarts) {
[08:29:05.902]                           name <- restart$name
[08:29:05.902]                           if (is.null(name)) 
[08:29:05.902]                             next
[08:29:05.902]                           if (!grepl(pattern, name)) 
[08:29:05.902]                             next
[08:29:05.902]                           invokeRestart(restart)
[08:29:05.902]                           muffled <- TRUE
[08:29:05.902]                           break
[08:29:05.902]                         }
[08:29:05.902]                       }
[08:29:05.902]                     }
[08:29:05.902]                     invisible(muffled)
[08:29:05.902]                   }
[08:29:05.902]                   muffleCondition(cond)
[08:29:05.902]                 })
[08:29:05.902]             }))
[08:29:05.902]             future::FutureResult(value = ...future.value$value, 
[08:29:05.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:05.902]                   ...future.rng), globalenv = if (FALSE) 
[08:29:05.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:05.902]                     ...future.globalenv.names))
[08:29:05.902]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:05.902]         }, condition = base::local({
[08:29:05.902]             c <- base::c
[08:29:05.902]             inherits <- base::inherits
[08:29:05.902]             invokeRestart <- base::invokeRestart
[08:29:05.902]             length <- base::length
[08:29:05.902]             list <- base::list
[08:29:05.902]             seq.int <- base::seq.int
[08:29:05.902]             signalCondition <- base::signalCondition
[08:29:05.902]             sys.calls <- base::sys.calls
[08:29:05.902]             `[[` <- base::`[[`
[08:29:05.902]             `+` <- base::`+`
[08:29:05.902]             `<<-` <- base::`<<-`
[08:29:05.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:05.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:05.902]                   3L)]
[08:29:05.902]             }
[08:29:05.902]             function(cond) {
[08:29:05.902]                 is_error <- inherits(cond, "error")
[08:29:05.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:05.902]                   NULL)
[08:29:05.902]                 if (is_error) {
[08:29:05.902]                   sessionInformation <- function() {
[08:29:05.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:05.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:05.902]                       search = base::search(), system = base::Sys.info())
[08:29:05.902]                   }
[08:29:05.902]                   ...future.conditions[[length(...future.conditions) + 
[08:29:05.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:05.902]                     cond$call), session = sessionInformation(), 
[08:29:05.902]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:05.902]                   signalCondition(cond)
[08:29:05.902]                 }
[08:29:05.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:05.902]                 "immediateCondition"))) {
[08:29:05.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:05.902]                   ...future.conditions[[length(...future.conditions) + 
[08:29:05.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:05.902]                   if (TRUE && !signal) {
[08:29:05.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.902]                     {
[08:29:05.902]                       inherits <- base::inherits
[08:29:05.902]                       invokeRestart <- base::invokeRestart
[08:29:05.902]                       is.null <- base::is.null
[08:29:05.902]                       muffled <- FALSE
[08:29:05.902]                       if (inherits(cond, "message")) {
[08:29:05.902]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:05.902]                         if (muffled) 
[08:29:05.902]                           invokeRestart("muffleMessage")
[08:29:05.902]                       }
[08:29:05.902]                       else if (inherits(cond, "warning")) {
[08:29:05.902]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:05.902]                         if (muffled) 
[08:29:05.902]                           invokeRestart("muffleWarning")
[08:29:05.902]                       }
[08:29:05.902]                       else if (inherits(cond, "condition")) {
[08:29:05.902]                         if (!is.null(pattern)) {
[08:29:05.902]                           computeRestarts <- base::computeRestarts
[08:29:05.902]                           grepl <- base::grepl
[08:29:05.902]                           restarts <- computeRestarts(cond)
[08:29:05.902]                           for (restart in restarts) {
[08:29:05.902]                             name <- restart$name
[08:29:05.902]                             if (is.null(name)) 
[08:29:05.902]                               next
[08:29:05.902]                             if (!grepl(pattern, name)) 
[08:29:05.902]                               next
[08:29:05.902]                             invokeRestart(restart)
[08:29:05.902]                             muffled <- TRUE
[08:29:05.902]                             break
[08:29:05.902]                           }
[08:29:05.902]                         }
[08:29:05.902]                       }
[08:29:05.902]                       invisible(muffled)
[08:29:05.902]                     }
[08:29:05.902]                     muffleCondition(cond, pattern = "^muffle")
[08:29:05.902]                   }
[08:29:05.902]                 }
[08:29:05.902]                 else {
[08:29:05.902]                   if (TRUE) {
[08:29:05.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:05.902]                     {
[08:29:05.902]                       inherits <- base::inherits
[08:29:05.902]                       invokeRestart <- base::invokeRestart
[08:29:05.902]                       is.null <- base::is.null
[08:29:05.902]                       muffled <- FALSE
[08:29:05.902]                       if (inherits(cond, "message")) {
[08:29:05.902]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:05.902]                         if (muffled) 
[08:29:05.902]                           invokeRestart("muffleMessage")
[08:29:05.902]                       }
[08:29:05.902]                       else if (inherits(cond, "warning")) {
[08:29:05.902]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:05.902]                         if (muffled) 
[08:29:05.902]                           invokeRestart("muffleWarning")
[08:29:05.902]                       }
[08:29:05.902]                       else if (inherits(cond, "condition")) {
[08:29:05.902]                         if (!is.null(pattern)) {
[08:29:05.902]                           computeRestarts <- base::computeRestarts
[08:29:05.902]                           grepl <- base::grepl
[08:29:05.902]                           restarts <- computeRestarts(cond)
[08:29:05.902]                           for (restart in restarts) {
[08:29:05.902]                             name <- restart$name
[08:29:05.902]                             if (is.null(name)) 
[08:29:05.902]                               next
[08:29:05.902]                             if (!grepl(pattern, name)) 
[08:29:05.902]                               next
[08:29:05.902]                             invokeRestart(restart)
[08:29:05.902]                             muffled <- TRUE
[08:29:05.902]                             break
[08:29:05.902]                           }
[08:29:05.902]                         }
[08:29:05.902]                       }
[08:29:05.902]                       invisible(muffled)
[08:29:05.902]                     }
[08:29:05.902]                     muffleCondition(cond, pattern = "^muffle")
[08:29:05.902]                   }
[08:29:05.902]                 }
[08:29:05.902]             }
[08:29:05.902]         }))
[08:29:05.902]     }, error = function(ex) {
[08:29:05.902]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:05.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:05.902]                 ...future.rng), started = ...future.startTime, 
[08:29:05.902]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:05.902]             version = "1.8"), class = "FutureResult")
[08:29:05.902]     }, finally = {
[08:29:05.902]         if (!identical(...future.workdir, getwd())) 
[08:29:05.902]             setwd(...future.workdir)
[08:29:05.902]         {
[08:29:05.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:05.902]                 ...future.oldOptions$nwarnings <- NULL
[08:29:05.902]             }
[08:29:05.902]             base::options(...future.oldOptions)
[08:29:05.902]             if (.Platform$OS.type == "windows") {
[08:29:05.902]                 old_names <- names(...future.oldEnvVars)
[08:29:05.902]                 envs <- base::Sys.getenv()
[08:29:05.902]                 names <- names(envs)
[08:29:05.902]                 common <- intersect(names, old_names)
[08:29:05.902]                 added <- setdiff(names, old_names)
[08:29:05.902]                 removed <- setdiff(old_names, names)
[08:29:05.902]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:05.902]                   envs[common]]
[08:29:05.902]                 NAMES <- toupper(changed)
[08:29:05.902]                 args <- list()
[08:29:05.902]                 for (kk in seq_along(NAMES)) {
[08:29:05.902]                   name <- changed[[kk]]
[08:29:05.902]                   NAME <- NAMES[[kk]]
[08:29:05.902]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.902]                     next
[08:29:05.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:05.902]                 }
[08:29:05.902]                 NAMES <- toupper(added)
[08:29:05.902]                 for (kk in seq_along(NAMES)) {
[08:29:05.902]                   name <- added[[kk]]
[08:29:05.902]                   NAME <- NAMES[[kk]]
[08:29:05.902]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.902]                     next
[08:29:05.902]                   args[[name]] <- ""
[08:29:05.902]                 }
[08:29:05.902]                 NAMES <- toupper(removed)
[08:29:05.902]                 for (kk in seq_along(NAMES)) {
[08:29:05.902]                   name <- removed[[kk]]
[08:29:05.902]                   NAME <- NAMES[[kk]]
[08:29:05.902]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:05.902]                     next
[08:29:05.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:05.902]                 }
[08:29:05.902]                 if (length(args) > 0) 
[08:29:05.902]                   base::do.call(base::Sys.setenv, args = args)
[08:29:05.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:05.902]             }
[08:29:05.902]             else {
[08:29:05.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:05.902]             }
[08:29:05.902]             {
[08:29:05.902]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:05.902]                   0L) {
[08:29:05.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:05.902]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:05.902]                   base::options(opts)
[08:29:05.902]                 }
[08:29:05.902]                 {
[08:29:05.902]                   {
[08:29:05.902]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:05.902]                     NULL
[08:29:05.902]                   }
[08:29:05.902]                   options(future.plan = NULL)
[08:29:05.902]                   if (is.na(NA_character_)) 
[08:29:05.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:05.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:05.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:05.902]                     .init = FALSE)
[08:29:05.902]                 }
[08:29:05.902]             }
[08:29:05.902]         }
[08:29:05.902]     })
[08:29:05.902]     if (TRUE) {
[08:29:05.902]         base::sink(type = "output", split = FALSE)
[08:29:05.902]         if (TRUE) {
[08:29:05.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:05.902]         }
[08:29:05.902]         else {
[08:29:05.902]             ...future.result["stdout"] <- base::list(NULL)
[08:29:05.902]         }
[08:29:05.902]         base::close(...future.stdout)
[08:29:05.902]         ...future.stdout <- NULL
[08:29:05.902]     }
[08:29:05.902]     ...future.result$conditions <- ...future.conditions
[08:29:05.902]     ...future.result$finished <- base::Sys.time()
[08:29:05.902]     ...future.result
[08:29:05.902] }
[08:29:05.905] MultisessionFuture started
[08:29:05.905] - Launch lazy future ... done
[08:29:05.905] run() for ‘MultisessionFuture’ ... done
[08:29:06.448] receiveMessageFromWorker() for ClusterFuture ...
[08:29:06.448] - Validating connection of MultisessionFuture
[08:29:06.448] - received message: FutureResult
[08:29:06.448] - Received FutureResult
[08:29:06.448] - Erased future from FutureRegistry
[08:29:06.448] result() for ClusterFuture ...
[08:29:06.448] - result already collected: FutureResult
[08:29:06.449] result() for ClusterFuture ... done
[08:29:06.449] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:06.449] A MultisessionFuture was resolved (result was not collected)
[08:29:06.449] getGlobalsAndPackages() ...
[08:29:06.449] Searching for globals...
[08:29:06.450] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:06.450] Searching for globals ... DONE
[08:29:06.450] Resolving globals: FALSE
[08:29:06.451] 
[08:29:06.451] 
[08:29:06.451] getGlobalsAndPackages() ... DONE
[08:29:06.451] run() for ‘Future’ ...
[08:29:06.451] - state: ‘created’
[08:29:06.451] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:06.465] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:06.465] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:06.465]   - Field: ‘node’
[08:29:06.465]   - Field: ‘label’
[08:29:06.465]   - Field: ‘local’
[08:29:06.465]   - Field: ‘owner’
[08:29:06.466]   - Field: ‘envir’
[08:29:06.466]   - Field: ‘workers’
[08:29:06.466]   - Field: ‘packages’
[08:29:06.466]   - Field: ‘gc’
[08:29:06.466]   - Field: ‘conditions’
[08:29:06.466]   - Field: ‘persistent’
[08:29:06.466]   - Field: ‘expr’
[08:29:06.466]   - Field: ‘uuid’
[08:29:06.466]   - Field: ‘seed’
[08:29:06.466]   - Field: ‘version’
[08:29:06.466]   - Field: ‘result’
[08:29:06.466]   - Field: ‘asynchronous’
[08:29:06.467]   - Field: ‘calls’
[08:29:06.467]   - Field: ‘globals’
[08:29:06.467]   - Field: ‘stdout’
[08:29:06.467]   - Field: ‘earlySignal’
[08:29:06.467]   - Field: ‘lazy’
[08:29:06.467]   - Field: ‘state’
[08:29:06.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:06.467] - Launch lazy future ...
[08:29:06.467] Packages needed by the future expression (n = 0): <none>
[08:29:06.467] Packages needed by future strategies (n = 0): <none>
[08:29:06.468] {
[08:29:06.468]     {
[08:29:06.468]         {
[08:29:06.468]             ...future.startTime <- base::Sys.time()
[08:29:06.468]             {
[08:29:06.468]                 {
[08:29:06.468]                   {
[08:29:06.468]                     {
[08:29:06.468]                       base::local({
[08:29:06.468]                         has_future <- base::requireNamespace("future", 
[08:29:06.468]                           quietly = TRUE)
[08:29:06.468]                         if (has_future) {
[08:29:06.468]                           ns <- base::getNamespace("future")
[08:29:06.468]                           version <- ns[[".package"]][["version"]]
[08:29:06.468]                           if (is.null(version)) 
[08:29:06.468]                             version <- utils::packageVersion("future")
[08:29:06.468]                         }
[08:29:06.468]                         else {
[08:29:06.468]                           version <- NULL
[08:29:06.468]                         }
[08:29:06.468]                         if (!has_future || version < "1.8.0") {
[08:29:06.468]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:06.468]                             "", base::R.version$version.string), 
[08:29:06.468]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:06.468]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:06.468]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:06.468]                               "release", "version")], collapse = " "), 
[08:29:06.468]                             hostname = base::Sys.info()[["nodename"]])
[08:29:06.468]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:06.468]                             info)
[08:29:06.468]                           info <- base::paste(info, collapse = "; ")
[08:29:06.468]                           if (!has_future) {
[08:29:06.468]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:06.468]                               info)
[08:29:06.468]                           }
[08:29:06.468]                           else {
[08:29:06.468]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:06.468]                               info, version)
[08:29:06.468]                           }
[08:29:06.468]                           base::stop(msg)
[08:29:06.468]                         }
[08:29:06.468]                       })
[08:29:06.468]                     }
[08:29:06.468]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:06.468]                     base::options(mc.cores = 1L)
[08:29:06.468]                   }
[08:29:06.468]                   ...future.strategy.old <- future::plan("list")
[08:29:06.468]                   options(future.plan = NULL)
[08:29:06.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:06.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:06.468]                 }
[08:29:06.468]                 ...future.workdir <- getwd()
[08:29:06.468]             }
[08:29:06.468]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:06.468]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:06.468]         }
[08:29:06.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:06.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:06.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:06.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:06.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:06.468]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:06.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:06.468]             base::names(...future.oldOptions))
[08:29:06.468]     }
[08:29:06.468]     if (FALSE) {
[08:29:06.468]     }
[08:29:06.468]     else {
[08:29:06.468]         if (TRUE) {
[08:29:06.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:06.468]                 open = "w")
[08:29:06.468]         }
[08:29:06.468]         else {
[08:29:06.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:06.468]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:06.468]         }
[08:29:06.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:06.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:06.468]             base::sink(type = "output", split = FALSE)
[08:29:06.468]             base::close(...future.stdout)
[08:29:06.468]         }, add = TRUE)
[08:29:06.468]     }
[08:29:06.468]     ...future.frame <- base::sys.nframe()
[08:29:06.468]     ...future.conditions <- base::list()
[08:29:06.468]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:06.468]     if (FALSE) {
[08:29:06.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:06.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:06.468]     }
[08:29:06.468]     ...future.result <- base::tryCatch({
[08:29:06.468]         base::withCallingHandlers({
[08:29:06.468]             ...future.value <- base::withVisible(base::local({
[08:29:06.468]                 ...future.makeSendCondition <- base::local({
[08:29:06.468]                   sendCondition <- NULL
[08:29:06.468]                   function(frame = 1L) {
[08:29:06.468]                     if (is.function(sendCondition)) 
[08:29:06.468]                       return(sendCondition)
[08:29:06.468]                     ns <- getNamespace("parallel")
[08:29:06.468]                     if (exists("sendData", mode = "function", 
[08:29:06.468]                       envir = ns)) {
[08:29:06.468]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:06.468]                         envir = ns)
[08:29:06.468]                       envir <- sys.frame(frame)
[08:29:06.468]                       master <- NULL
[08:29:06.468]                       while (!identical(envir, .GlobalEnv) && 
[08:29:06.468]                         !identical(envir, emptyenv())) {
[08:29:06.468]                         if (exists("master", mode = "list", envir = envir, 
[08:29:06.468]                           inherits = FALSE)) {
[08:29:06.468]                           master <- get("master", mode = "list", 
[08:29:06.468]                             envir = envir, inherits = FALSE)
[08:29:06.468]                           if (inherits(master, c("SOCKnode", 
[08:29:06.468]                             "SOCK0node"))) {
[08:29:06.468]                             sendCondition <<- function(cond) {
[08:29:06.468]                               data <- list(type = "VALUE", value = cond, 
[08:29:06.468]                                 success = TRUE)
[08:29:06.468]                               parallel_sendData(master, data)
[08:29:06.468]                             }
[08:29:06.468]                             return(sendCondition)
[08:29:06.468]                           }
[08:29:06.468]                         }
[08:29:06.468]                         frame <- frame + 1L
[08:29:06.468]                         envir <- sys.frame(frame)
[08:29:06.468]                       }
[08:29:06.468]                     }
[08:29:06.468]                     sendCondition <<- function(cond) NULL
[08:29:06.468]                   }
[08:29:06.468]                 })
[08:29:06.468]                 withCallingHandlers({
[08:29:06.468]                   {
[08:29:06.468]                     Sys.sleep(0.5)
[08:29:06.468]                     list(a = 1, b = 42L)
[08:29:06.468]                   }
[08:29:06.468]                 }, immediateCondition = function(cond) {
[08:29:06.468]                   sendCondition <- ...future.makeSendCondition()
[08:29:06.468]                   sendCondition(cond)
[08:29:06.468]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:06.468]                   {
[08:29:06.468]                     inherits <- base::inherits
[08:29:06.468]                     invokeRestart <- base::invokeRestart
[08:29:06.468]                     is.null <- base::is.null
[08:29:06.468]                     muffled <- FALSE
[08:29:06.468]                     if (inherits(cond, "message")) {
[08:29:06.468]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:06.468]                       if (muffled) 
[08:29:06.468]                         invokeRestart("muffleMessage")
[08:29:06.468]                     }
[08:29:06.468]                     else if (inherits(cond, "warning")) {
[08:29:06.468]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:06.468]                       if (muffled) 
[08:29:06.468]                         invokeRestart("muffleWarning")
[08:29:06.468]                     }
[08:29:06.468]                     else if (inherits(cond, "condition")) {
[08:29:06.468]                       if (!is.null(pattern)) {
[08:29:06.468]                         computeRestarts <- base::computeRestarts
[08:29:06.468]                         grepl <- base::grepl
[08:29:06.468]                         restarts <- computeRestarts(cond)
[08:29:06.468]                         for (restart in restarts) {
[08:29:06.468]                           name <- restart$name
[08:29:06.468]                           if (is.null(name)) 
[08:29:06.468]                             next
[08:29:06.468]                           if (!grepl(pattern, name)) 
[08:29:06.468]                             next
[08:29:06.468]                           invokeRestart(restart)
[08:29:06.468]                           muffled <- TRUE
[08:29:06.468]                           break
[08:29:06.468]                         }
[08:29:06.468]                       }
[08:29:06.468]                     }
[08:29:06.468]                     invisible(muffled)
[08:29:06.468]                   }
[08:29:06.468]                   muffleCondition(cond)
[08:29:06.468]                 })
[08:29:06.468]             }))
[08:29:06.468]             future::FutureResult(value = ...future.value$value, 
[08:29:06.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:06.468]                   ...future.rng), globalenv = if (FALSE) 
[08:29:06.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:06.468]                     ...future.globalenv.names))
[08:29:06.468]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:06.468]         }, condition = base::local({
[08:29:06.468]             c <- base::c
[08:29:06.468]             inherits <- base::inherits
[08:29:06.468]             invokeRestart <- base::invokeRestart
[08:29:06.468]             length <- base::length
[08:29:06.468]             list <- base::list
[08:29:06.468]             seq.int <- base::seq.int
[08:29:06.468]             signalCondition <- base::signalCondition
[08:29:06.468]             sys.calls <- base::sys.calls
[08:29:06.468]             `[[` <- base::`[[`
[08:29:06.468]             `+` <- base::`+`
[08:29:06.468]             `<<-` <- base::`<<-`
[08:29:06.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:06.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:06.468]                   3L)]
[08:29:06.468]             }
[08:29:06.468]             function(cond) {
[08:29:06.468]                 is_error <- inherits(cond, "error")
[08:29:06.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:06.468]                   NULL)
[08:29:06.468]                 if (is_error) {
[08:29:06.468]                   sessionInformation <- function() {
[08:29:06.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:06.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:06.468]                       search = base::search(), system = base::Sys.info())
[08:29:06.468]                   }
[08:29:06.468]                   ...future.conditions[[length(...future.conditions) + 
[08:29:06.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:06.468]                     cond$call), session = sessionInformation(), 
[08:29:06.468]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:06.468]                   signalCondition(cond)
[08:29:06.468]                 }
[08:29:06.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:06.468]                 "immediateCondition"))) {
[08:29:06.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:06.468]                   ...future.conditions[[length(...future.conditions) + 
[08:29:06.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:06.468]                   if (TRUE && !signal) {
[08:29:06.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:06.468]                     {
[08:29:06.468]                       inherits <- base::inherits
[08:29:06.468]                       invokeRestart <- base::invokeRestart
[08:29:06.468]                       is.null <- base::is.null
[08:29:06.468]                       muffled <- FALSE
[08:29:06.468]                       if (inherits(cond, "message")) {
[08:29:06.468]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:06.468]                         if (muffled) 
[08:29:06.468]                           invokeRestart("muffleMessage")
[08:29:06.468]                       }
[08:29:06.468]                       else if (inherits(cond, "warning")) {
[08:29:06.468]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:06.468]                         if (muffled) 
[08:29:06.468]                           invokeRestart("muffleWarning")
[08:29:06.468]                       }
[08:29:06.468]                       else if (inherits(cond, "condition")) {
[08:29:06.468]                         if (!is.null(pattern)) {
[08:29:06.468]                           computeRestarts <- base::computeRestarts
[08:29:06.468]                           grepl <- base::grepl
[08:29:06.468]                           restarts <- computeRestarts(cond)
[08:29:06.468]                           for (restart in restarts) {
[08:29:06.468]                             name <- restart$name
[08:29:06.468]                             if (is.null(name)) 
[08:29:06.468]                               next
[08:29:06.468]                             if (!grepl(pattern, name)) 
[08:29:06.468]                               next
[08:29:06.468]                             invokeRestart(restart)
[08:29:06.468]                             muffled <- TRUE
[08:29:06.468]                             break
[08:29:06.468]                           }
[08:29:06.468]                         }
[08:29:06.468]                       }
[08:29:06.468]                       invisible(muffled)
[08:29:06.468]                     }
[08:29:06.468]                     muffleCondition(cond, pattern = "^muffle")
[08:29:06.468]                   }
[08:29:06.468]                 }
[08:29:06.468]                 else {
[08:29:06.468]                   if (TRUE) {
[08:29:06.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:06.468]                     {
[08:29:06.468]                       inherits <- base::inherits
[08:29:06.468]                       invokeRestart <- base::invokeRestart
[08:29:06.468]                       is.null <- base::is.null
[08:29:06.468]                       muffled <- FALSE
[08:29:06.468]                       if (inherits(cond, "message")) {
[08:29:06.468]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:06.468]                         if (muffled) 
[08:29:06.468]                           invokeRestart("muffleMessage")
[08:29:06.468]                       }
[08:29:06.468]                       else if (inherits(cond, "warning")) {
[08:29:06.468]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:06.468]                         if (muffled) 
[08:29:06.468]                           invokeRestart("muffleWarning")
[08:29:06.468]                       }
[08:29:06.468]                       else if (inherits(cond, "condition")) {
[08:29:06.468]                         if (!is.null(pattern)) {
[08:29:06.468]                           computeRestarts <- base::computeRestarts
[08:29:06.468]                           grepl <- base::grepl
[08:29:06.468]                           restarts <- computeRestarts(cond)
[08:29:06.468]                           for (restart in restarts) {
[08:29:06.468]                             name <- restart$name
[08:29:06.468]                             if (is.null(name)) 
[08:29:06.468]                               next
[08:29:06.468]                             if (!grepl(pattern, name)) 
[08:29:06.468]                               next
[08:29:06.468]                             invokeRestart(restart)
[08:29:06.468]                             muffled <- TRUE
[08:29:06.468]                             break
[08:29:06.468]                           }
[08:29:06.468]                         }
[08:29:06.468]                       }
[08:29:06.468]                       invisible(muffled)
[08:29:06.468]                     }
[08:29:06.468]                     muffleCondition(cond, pattern = "^muffle")
[08:29:06.468]                   }
[08:29:06.468]                 }
[08:29:06.468]             }
[08:29:06.468]         }))
[08:29:06.468]     }, error = function(ex) {
[08:29:06.468]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:06.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:06.468]                 ...future.rng), started = ...future.startTime, 
[08:29:06.468]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:06.468]             version = "1.8"), class = "FutureResult")
[08:29:06.468]     }, finally = {
[08:29:06.468]         if (!identical(...future.workdir, getwd())) 
[08:29:06.468]             setwd(...future.workdir)
[08:29:06.468]         {
[08:29:06.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:06.468]                 ...future.oldOptions$nwarnings <- NULL
[08:29:06.468]             }
[08:29:06.468]             base::options(...future.oldOptions)
[08:29:06.468]             if (.Platform$OS.type == "windows") {
[08:29:06.468]                 old_names <- names(...future.oldEnvVars)
[08:29:06.468]                 envs <- base::Sys.getenv()
[08:29:06.468]                 names <- names(envs)
[08:29:06.468]                 common <- intersect(names, old_names)
[08:29:06.468]                 added <- setdiff(names, old_names)
[08:29:06.468]                 removed <- setdiff(old_names, names)
[08:29:06.468]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:06.468]                   envs[common]]
[08:29:06.468]                 NAMES <- toupper(changed)
[08:29:06.468]                 args <- list()
[08:29:06.468]                 for (kk in seq_along(NAMES)) {
[08:29:06.468]                   name <- changed[[kk]]
[08:29:06.468]                   NAME <- NAMES[[kk]]
[08:29:06.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:06.468]                     next
[08:29:06.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:06.468]                 }
[08:29:06.468]                 NAMES <- toupper(added)
[08:29:06.468]                 for (kk in seq_along(NAMES)) {
[08:29:06.468]                   name <- added[[kk]]
[08:29:06.468]                   NAME <- NAMES[[kk]]
[08:29:06.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:06.468]                     next
[08:29:06.468]                   args[[name]] <- ""
[08:29:06.468]                 }
[08:29:06.468]                 NAMES <- toupper(removed)
[08:29:06.468]                 for (kk in seq_along(NAMES)) {
[08:29:06.468]                   name <- removed[[kk]]
[08:29:06.468]                   NAME <- NAMES[[kk]]
[08:29:06.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:06.468]                     next
[08:29:06.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:06.468]                 }
[08:29:06.468]                 if (length(args) > 0) 
[08:29:06.468]                   base::do.call(base::Sys.setenv, args = args)
[08:29:06.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:06.468]             }
[08:29:06.468]             else {
[08:29:06.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:06.468]             }
[08:29:06.468]             {
[08:29:06.468]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:06.468]                   0L) {
[08:29:06.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:06.468]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:06.468]                   base::options(opts)
[08:29:06.468]                 }
[08:29:06.468]                 {
[08:29:06.468]                   {
[08:29:06.468]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:06.468]                     NULL
[08:29:06.468]                   }
[08:29:06.468]                   options(future.plan = NULL)
[08:29:06.468]                   if (is.na(NA_character_)) 
[08:29:06.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:06.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:06.468]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:06.468]                     .init = FALSE)
[08:29:06.468]                 }
[08:29:06.468]             }
[08:29:06.468]         }
[08:29:06.468]     })
[08:29:06.468]     if (TRUE) {
[08:29:06.468]         base::sink(type = "output", split = FALSE)
[08:29:06.468]         if (TRUE) {
[08:29:06.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:06.468]         }
[08:29:06.468]         else {
[08:29:06.468]             ...future.result["stdout"] <- base::list(NULL)
[08:29:06.468]         }
[08:29:06.468]         base::close(...future.stdout)
[08:29:06.468]         ...future.stdout <- NULL
[08:29:06.468]     }
[08:29:06.468]     ...future.result$conditions <- ...future.conditions
[08:29:06.468]     ...future.result$finished <- base::Sys.time()
[08:29:06.468]     ...future.result
[08:29:06.468] }
[08:29:06.471] MultisessionFuture started
[08:29:06.471] - Launch lazy future ... done
[08:29:06.471] run() for ‘MultisessionFuture’ ... done
[08:29:07.014] receiveMessageFromWorker() for ClusterFuture ...
[08:29:07.014] - Validating connection of MultisessionFuture
[08:29:07.014] - received message: FutureResult
[08:29:07.014] - Received FutureResult
[08:29:07.014] - Erased future from FutureRegistry
[08:29:07.015] result() for ClusterFuture ...
[08:29:07.015] - result already collected: FutureResult
[08:29:07.015] result() for ClusterFuture ... done
[08:29:07.015] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:07.015] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[08:29:07.015] getGlobalsAndPackages() ...
[08:29:07.015] Searching for globals...
[08:29:07.016] - globals found: [2] ‘list’, ‘stop’
[08:29:07.016] Searching for globals ... DONE
[08:29:07.016] Resolving globals: FALSE
[08:29:07.016] 
[08:29:07.016] 
[08:29:07.017] getGlobalsAndPackages() ... DONE
[08:29:07.017] run() for ‘Future’ ...
[08:29:07.017] - state: ‘created’
[08:29:07.017] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:07.031] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:07.031] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:07.031]   - Field: ‘node’
[08:29:07.031]   - Field: ‘label’
[08:29:07.031]   - Field: ‘local’
[08:29:07.031]   - Field: ‘owner’
[08:29:07.031]   - Field: ‘envir’
[08:29:07.031]   - Field: ‘workers’
[08:29:07.031]   - Field: ‘packages’
[08:29:07.031]   - Field: ‘gc’
[08:29:07.032]   - Field: ‘conditions’
[08:29:07.032]   - Field: ‘persistent’
[08:29:07.032]   - Field: ‘expr’
[08:29:07.032]   - Field: ‘uuid’
[08:29:07.032]   - Field: ‘seed’
[08:29:07.032]   - Field: ‘version’
[08:29:07.032]   - Field: ‘result’
[08:29:07.032]   - Field: ‘asynchronous’
[08:29:07.032]   - Field: ‘calls’
[08:29:07.032]   - Field: ‘globals’
[08:29:07.032]   - Field: ‘stdout’
[08:29:07.032]   - Field: ‘earlySignal’
[08:29:07.032]   - Field: ‘lazy’
[08:29:07.033]   - Field: ‘state’
[08:29:07.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:07.033] - Launch lazy future ...
[08:29:07.033] Packages needed by the future expression (n = 0): <none>
[08:29:07.033] Packages needed by future strategies (n = 0): <none>
[08:29:07.034] {
[08:29:07.034]     {
[08:29:07.034]         {
[08:29:07.034]             ...future.startTime <- base::Sys.time()
[08:29:07.034]             {
[08:29:07.034]                 {
[08:29:07.034]                   {
[08:29:07.034]                     {
[08:29:07.034]                       base::local({
[08:29:07.034]                         has_future <- base::requireNamespace("future", 
[08:29:07.034]                           quietly = TRUE)
[08:29:07.034]                         if (has_future) {
[08:29:07.034]                           ns <- base::getNamespace("future")
[08:29:07.034]                           version <- ns[[".package"]][["version"]]
[08:29:07.034]                           if (is.null(version)) 
[08:29:07.034]                             version <- utils::packageVersion("future")
[08:29:07.034]                         }
[08:29:07.034]                         else {
[08:29:07.034]                           version <- NULL
[08:29:07.034]                         }
[08:29:07.034]                         if (!has_future || version < "1.8.0") {
[08:29:07.034]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:07.034]                             "", base::R.version$version.string), 
[08:29:07.034]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:07.034]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:07.034]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:07.034]                               "release", "version")], collapse = " "), 
[08:29:07.034]                             hostname = base::Sys.info()[["nodename"]])
[08:29:07.034]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:07.034]                             info)
[08:29:07.034]                           info <- base::paste(info, collapse = "; ")
[08:29:07.034]                           if (!has_future) {
[08:29:07.034]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:07.034]                               info)
[08:29:07.034]                           }
[08:29:07.034]                           else {
[08:29:07.034]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:07.034]                               info, version)
[08:29:07.034]                           }
[08:29:07.034]                           base::stop(msg)
[08:29:07.034]                         }
[08:29:07.034]                       })
[08:29:07.034]                     }
[08:29:07.034]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:07.034]                     base::options(mc.cores = 1L)
[08:29:07.034]                   }
[08:29:07.034]                   ...future.strategy.old <- future::plan("list")
[08:29:07.034]                   options(future.plan = NULL)
[08:29:07.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:07.034]                 }
[08:29:07.034]                 ...future.workdir <- getwd()
[08:29:07.034]             }
[08:29:07.034]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:07.034]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:07.034]         }
[08:29:07.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:07.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:07.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:07.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:07.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:07.034]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:07.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:07.034]             base::names(...future.oldOptions))
[08:29:07.034]     }
[08:29:07.034]     if (FALSE) {
[08:29:07.034]     }
[08:29:07.034]     else {
[08:29:07.034]         if (TRUE) {
[08:29:07.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:07.034]                 open = "w")
[08:29:07.034]         }
[08:29:07.034]         else {
[08:29:07.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:07.034]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:07.034]         }
[08:29:07.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:07.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:07.034]             base::sink(type = "output", split = FALSE)
[08:29:07.034]             base::close(...future.stdout)
[08:29:07.034]         }, add = TRUE)
[08:29:07.034]     }
[08:29:07.034]     ...future.frame <- base::sys.nframe()
[08:29:07.034]     ...future.conditions <- base::list()
[08:29:07.034]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:07.034]     if (FALSE) {
[08:29:07.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:07.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:07.034]     }
[08:29:07.034]     ...future.result <- base::tryCatch({
[08:29:07.034]         base::withCallingHandlers({
[08:29:07.034]             ...future.value <- base::withVisible(base::local({
[08:29:07.034]                 ...future.makeSendCondition <- base::local({
[08:29:07.034]                   sendCondition <- NULL
[08:29:07.034]                   function(frame = 1L) {
[08:29:07.034]                     if (is.function(sendCondition)) 
[08:29:07.034]                       return(sendCondition)
[08:29:07.034]                     ns <- getNamespace("parallel")
[08:29:07.034]                     if (exists("sendData", mode = "function", 
[08:29:07.034]                       envir = ns)) {
[08:29:07.034]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:07.034]                         envir = ns)
[08:29:07.034]                       envir <- sys.frame(frame)
[08:29:07.034]                       master <- NULL
[08:29:07.034]                       while (!identical(envir, .GlobalEnv) && 
[08:29:07.034]                         !identical(envir, emptyenv())) {
[08:29:07.034]                         if (exists("master", mode = "list", envir = envir, 
[08:29:07.034]                           inherits = FALSE)) {
[08:29:07.034]                           master <- get("master", mode = "list", 
[08:29:07.034]                             envir = envir, inherits = FALSE)
[08:29:07.034]                           if (inherits(master, c("SOCKnode", 
[08:29:07.034]                             "SOCK0node"))) {
[08:29:07.034]                             sendCondition <<- function(cond) {
[08:29:07.034]                               data <- list(type = "VALUE", value = cond, 
[08:29:07.034]                                 success = TRUE)
[08:29:07.034]                               parallel_sendData(master, data)
[08:29:07.034]                             }
[08:29:07.034]                             return(sendCondition)
[08:29:07.034]                           }
[08:29:07.034]                         }
[08:29:07.034]                         frame <- frame + 1L
[08:29:07.034]                         envir <- sys.frame(frame)
[08:29:07.034]                       }
[08:29:07.034]                     }
[08:29:07.034]                     sendCondition <<- function(cond) NULL
[08:29:07.034]                   }
[08:29:07.034]                 })
[08:29:07.034]                 withCallingHandlers({
[08:29:07.034]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:07.034]                 }, immediateCondition = function(cond) {
[08:29:07.034]                   sendCondition <- ...future.makeSendCondition()
[08:29:07.034]                   sendCondition(cond)
[08:29:07.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.034]                   {
[08:29:07.034]                     inherits <- base::inherits
[08:29:07.034]                     invokeRestart <- base::invokeRestart
[08:29:07.034]                     is.null <- base::is.null
[08:29:07.034]                     muffled <- FALSE
[08:29:07.034]                     if (inherits(cond, "message")) {
[08:29:07.034]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:07.034]                       if (muffled) 
[08:29:07.034]                         invokeRestart("muffleMessage")
[08:29:07.034]                     }
[08:29:07.034]                     else if (inherits(cond, "warning")) {
[08:29:07.034]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:07.034]                       if (muffled) 
[08:29:07.034]                         invokeRestart("muffleWarning")
[08:29:07.034]                     }
[08:29:07.034]                     else if (inherits(cond, "condition")) {
[08:29:07.034]                       if (!is.null(pattern)) {
[08:29:07.034]                         computeRestarts <- base::computeRestarts
[08:29:07.034]                         grepl <- base::grepl
[08:29:07.034]                         restarts <- computeRestarts(cond)
[08:29:07.034]                         for (restart in restarts) {
[08:29:07.034]                           name <- restart$name
[08:29:07.034]                           if (is.null(name)) 
[08:29:07.034]                             next
[08:29:07.034]                           if (!grepl(pattern, name)) 
[08:29:07.034]                             next
[08:29:07.034]                           invokeRestart(restart)
[08:29:07.034]                           muffled <- TRUE
[08:29:07.034]                           break
[08:29:07.034]                         }
[08:29:07.034]                       }
[08:29:07.034]                     }
[08:29:07.034]                     invisible(muffled)
[08:29:07.034]                   }
[08:29:07.034]                   muffleCondition(cond)
[08:29:07.034]                 })
[08:29:07.034]             }))
[08:29:07.034]             future::FutureResult(value = ...future.value$value, 
[08:29:07.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.034]                   ...future.rng), globalenv = if (FALSE) 
[08:29:07.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:07.034]                     ...future.globalenv.names))
[08:29:07.034]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:07.034]         }, condition = base::local({
[08:29:07.034]             c <- base::c
[08:29:07.034]             inherits <- base::inherits
[08:29:07.034]             invokeRestart <- base::invokeRestart
[08:29:07.034]             length <- base::length
[08:29:07.034]             list <- base::list
[08:29:07.034]             seq.int <- base::seq.int
[08:29:07.034]             signalCondition <- base::signalCondition
[08:29:07.034]             sys.calls <- base::sys.calls
[08:29:07.034]             `[[` <- base::`[[`
[08:29:07.034]             `+` <- base::`+`
[08:29:07.034]             `<<-` <- base::`<<-`
[08:29:07.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:07.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:07.034]                   3L)]
[08:29:07.034]             }
[08:29:07.034]             function(cond) {
[08:29:07.034]                 is_error <- inherits(cond, "error")
[08:29:07.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:07.034]                   NULL)
[08:29:07.034]                 if (is_error) {
[08:29:07.034]                   sessionInformation <- function() {
[08:29:07.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:07.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:07.034]                       search = base::search(), system = base::Sys.info())
[08:29:07.034]                   }
[08:29:07.034]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:07.034]                     cond$call), session = sessionInformation(), 
[08:29:07.034]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:07.034]                   signalCondition(cond)
[08:29:07.034]                 }
[08:29:07.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:07.034]                 "immediateCondition"))) {
[08:29:07.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:07.034]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:07.034]                   if (TRUE && !signal) {
[08:29:07.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.034]                     {
[08:29:07.034]                       inherits <- base::inherits
[08:29:07.034]                       invokeRestart <- base::invokeRestart
[08:29:07.034]                       is.null <- base::is.null
[08:29:07.034]                       muffled <- FALSE
[08:29:07.034]                       if (inherits(cond, "message")) {
[08:29:07.034]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.034]                         if (muffled) 
[08:29:07.034]                           invokeRestart("muffleMessage")
[08:29:07.034]                       }
[08:29:07.034]                       else if (inherits(cond, "warning")) {
[08:29:07.034]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.034]                         if (muffled) 
[08:29:07.034]                           invokeRestart("muffleWarning")
[08:29:07.034]                       }
[08:29:07.034]                       else if (inherits(cond, "condition")) {
[08:29:07.034]                         if (!is.null(pattern)) {
[08:29:07.034]                           computeRestarts <- base::computeRestarts
[08:29:07.034]                           grepl <- base::grepl
[08:29:07.034]                           restarts <- computeRestarts(cond)
[08:29:07.034]                           for (restart in restarts) {
[08:29:07.034]                             name <- restart$name
[08:29:07.034]                             if (is.null(name)) 
[08:29:07.034]                               next
[08:29:07.034]                             if (!grepl(pattern, name)) 
[08:29:07.034]                               next
[08:29:07.034]                             invokeRestart(restart)
[08:29:07.034]                             muffled <- TRUE
[08:29:07.034]                             break
[08:29:07.034]                           }
[08:29:07.034]                         }
[08:29:07.034]                       }
[08:29:07.034]                       invisible(muffled)
[08:29:07.034]                     }
[08:29:07.034]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.034]                   }
[08:29:07.034]                 }
[08:29:07.034]                 else {
[08:29:07.034]                   if (TRUE) {
[08:29:07.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.034]                     {
[08:29:07.034]                       inherits <- base::inherits
[08:29:07.034]                       invokeRestart <- base::invokeRestart
[08:29:07.034]                       is.null <- base::is.null
[08:29:07.034]                       muffled <- FALSE
[08:29:07.034]                       if (inherits(cond, "message")) {
[08:29:07.034]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.034]                         if (muffled) 
[08:29:07.034]                           invokeRestart("muffleMessage")
[08:29:07.034]                       }
[08:29:07.034]                       else if (inherits(cond, "warning")) {
[08:29:07.034]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.034]                         if (muffled) 
[08:29:07.034]                           invokeRestart("muffleWarning")
[08:29:07.034]                       }
[08:29:07.034]                       else if (inherits(cond, "condition")) {
[08:29:07.034]                         if (!is.null(pattern)) {
[08:29:07.034]                           computeRestarts <- base::computeRestarts
[08:29:07.034]                           grepl <- base::grepl
[08:29:07.034]                           restarts <- computeRestarts(cond)
[08:29:07.034]                           for (restart in restarts) {
[08:29:07.034]                             name <- restart$name
[08:29:07.034]                             if (is.null(name)) 
[08:29:07.034]                               next
[08:29:07.034]                             if (!grepl(pattern, name)) 
[08:29:07.034]                               next
[08:29:07.034]                             invokeRestart(restart)
[08:29:07.034]                             muffled <- TRUE
[08:29:07.034]                             break
[08:29:07.034]                           }
[08:29:07.034]                         }
[08:29:07.034]                       }
[08:29:07.034]                       invisible(muffled)
[08:29:07.034]                     }
[08:29:07.034]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.034]                   }
[08:29:07.034]                 }
[08:29:07.034]             }
[08:29:07.034]         }))
[08:29:07.034]     }, error = function(ex) {
[08:29:07.034]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:07.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.034]                 ...future.rng), started = ...future.startTime, 
[08:29:07.034]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:07.034]             version = "1.8"), class = "FutureResult")
[08:29:07.034]     }, finally = {
[08:29:07.034]         if (!identical(...future.workdir, getwd())) 
[08:29:07.034]             setwd(...future.workdir)
[08:29:07.034]         {
[08:29:07.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:07.034]                 ...future.oldOptions$nwarnings <- NULL
[08:29:07.034]             }
[08:29:07.034]             base::options(...future.oldOptions)
[08:29:07.034]             if (.Platform$OS.type == "windows") {
[08:29:07.034]                 old_names <- names(...future.oldEnvVars)
[08:29:07.034]                 envs <- base::Sys.getenv()
[08:29:07.034]                 names <- names(envs)
[08:29:07.034]                 common <- intersect(names, old_names)
[08:29:07.034]                 added <- setdiff(names, old_names)
[08:29:07.034]                 removed <- setdiff(old_names, names)
[08:29:07.034]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:07.034]                   envs[common]]
[08:29:07.034]                 NAMES <- toupper(changed)
[08:29:07.034]                 args <- list()
[08:29:07.034]                 for (kk in seq_along(NAMES)) {
[08:29:07.034]                   name <- changed[[kk]]
[08:29:07.034]                   NAME <- NAMES[[kk]]
[08:29:07.034]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.034]                     next
[08:29:07.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.034]                 }
[08:29:07.034]                 NAMES <- toupper(added)
[08:29:07.034]                 for (kk in seq_along(NAMES)) {
[08:29:07.034]                   name <- added[[kk]]
[08:29:07.034]                   NAME <- NAMES[[kk]]
[08:29:07.034]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.034]                     next
[08:29:07.034]                   args[[name]] <- ""
[08:29:07.034]                 }
[08:29:07.034]                 NAMES <- toupper(removed)
[08:29:07.034]                 for (kk in seq_along(NAMES)) {
[08:29:07.034]                   name <- removed[[kk]]
[08:29:07.034]                   NAME <- NAMES[[kk]]
[08:29:07.034]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.034]                     next
[08:29:07.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.034]                 }
[08:29:07.034]                 if (length(args) > 0) 
[08:29:07.034]                   base::do.call(base::Sys.setenv, args = args)
[08:29:07.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:07.034]             }
[08:29:07.034]             else {
[08:29:07.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:07.034]             }
[08:29:07.034]             {
[08:29:07.034]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:07.034]                   0L) {
[08:29:07.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:07.034]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:07.034]                   base::options(opts)
[08:29:07.034]                 }
[08:29:07.034]                 {
[08:29:07.034]                   {
[08:29:07.034]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:07.034]                     NULL
[08:29:07.034]                   }
[08:29:07.034]                   options(future.plan = NULL)
[08:29:07.034]                   if (is.na(NA_character_)) 
[08:29:07.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:07.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:07.034]                     .init = FALSE)
[08:29:07.034]                 }
[08:29:07.034]             }
[08:29:07.034]         }
[08:29:07.034]     })
[08:29:07.034]     if (TRUE) {
[08:29:07.034]         base::sink(type = "output", split = FALSE)
[08:29:07.034]         if (TRUE) {
[08:29:07.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:07.034]         }
[08:29:07.034]         else {
[08:29:07.034]             ...future.result["stdout"] <- base::list(NULL)
[08:29:07.034]         }
[08:29:07.034]         base::close(...future.stdout)
[08:29:07.034]         ...future.stdout <- NULL
[08:29:07.034]     }
[08:29:07.034]     ...future.result$conditions <- ...future.conditions
[08:29:07.034]     ...future.result$finished <- base::Sys.time()
[08:29:07.034]     ...future.result
[08:29:07.034] }
[08:29:07.036] MultisessionFuture started
[08:29:07.037] - Launch lazy future ... done
[08:29:07.037] run() for ‘MultisessionFuture’ ... done
[08:29:07.079] receiveMessageFromWorker() for ClusterFuture ...
[08:29:07.079] - Validating connection of MultisessionFuture
[08:29:07.080] - received message: FutureResult
[08:29:07.080] - Received FutureResult
[08:29:07.080] - Erased future from FutureRegistry
[08:29:07.080] result() for ClusterFuture ...
[08:29:07.080] - result already collected: FutureResult
[08:29:07.080] result() for ClusterFuture ... done
[08:29:07.081] signalConditions() ...
[08:29:07.081]  - include = ‘immediateCondition’
[08:29:07.081]  - exclude = 
[08:29:07.081]  - resignal = FALSE
[08:29:07.081]  - Number of conditions: 1
[08:29:07.081] signalConditions() ... done
[08:29:07.081] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:07.081] A MultisessionFuture was resolved (result was not collected)
[08:29:07.081] getGlobalsAndPackages() ...
[08:29:07.081] Searching for globals...
[08:29:07.082] - globals found: [2] ‘list’, ‘stop’
[08:29:07.082] Searching for globals ... DONE
[08:29:07.082] Resolving globals: FALSE
[08:29:07.082] 
[08:29:07.083] 
[08:29:07.083] getGlobalsAndPackages() ... DONE
[08:29:07.083] run() for ‘Future’ ...
[08:29:07.083] - state: ‘created’
[08:29:07.083] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:07.097] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:07.097] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:07.097]   - Field: ‘node’
[08:29:07.097]   - Field: ‘label’
[08:29:07.097]   - Field: ‘local’
[08:29:07.097]   - Field: ‘owner’
[08:29:07.097]   - Field: ‘envir’
[08:29:07.098]   - Field: ‘workers’
[08:29:07.098]   - Field: ‘packages’
[08:29:07.098]   - Field: ‘gc’
[08:29:07.098]   - Field: ‘conditions’
[08:29:07.098]   - Field: ‘persistent’
[08:29:07.098]   - Field: ‘expr’
[08:29:07.098]   - Field: ‘uuid’
[08:29:07.098]   - Field: ‘seed’
[08:29:07.098]   - Field: ‘version’
[08:29:07.098]   - Field: ‘result’
[08:29:07.098]   - Field: ‘asynchronous’
[08:29:07.098]   - Field: ‘calls’
[08:29:07.099]   - Field: ‘globals’
[08:29:07.099]   - Field: ‘stdout’
[08:29:07.099]   - Field: ‘earlySignal’
[08:29:07.099]   - Field: ‘lazy’
[08:29:07.099]   - Field: ‘state’
[08:29:07.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:07.099] - Launch lazy future ...
[08:29:07.099] Packages needed by the future expression (n = 0): <none>
[08:29:07.099] Packages needed by future strategies (n = 0): <none>
[08:29:07.100] {
[08:29:07.100]     {
[08:29:07.100]         {
[08:29:07.100]             ...future.startTime <- base::Sys.time()
[08:29:07.100]             {
[08:29:07.100]                 {
[08:29:07.100]                   {
[08:29:07.100]                     {
[08:29:07.100]                       base::local({
[08:29:07.100]                         has_future <- base::requireNamespace("future", 
[08:29:07.100]                           quietly = TRUE)
[08:29:07.100]                         if (has_future) {
[08:29:07.100]                           ns <- base::getNamespace("future")
[08:29:07.100]                           version <- ns[[".package"]][["version"]]
[08:29:07.100]                           if (is.null(version)) 
[08:29:07.100]                             version <- utils::packageVersion("future")
[08:29:07.100]                         }
[08:29:07.100]                         else {
[08:29:07.100]                           version <- NULL
[08:29:07.100]                         }
[08:29:07.100]                         if (!has_future || version < "1.8.0") {
[08:29:07.100]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:07.100]                             "", base::R.version$version.string), 
[08:29:07.100]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:07.100]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:07.100]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:07.100]                               "release", "version")], collapse = " "), 
[08:29:07.100]                             hostname = base::Sys.info()[["nodename"]])
[08:29:07.100]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:07.100]                             info)
[08:29:07.100]                           info <- base::paste(info, collapse = "; ")
[08:29:07.100]                           if (!has_future) {
[08:29:07.100]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:07.100]                               info)
[08:29:07.100]                           }
[08:29:07.100]                           else {
[08:29:07.100]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:07.100]                               info, version)
[08:29:07.100]                           }
[08:29:07.100]                           base::stop(msg)
[08:29:07.100]                         }
[08:29:07.100]                       })
[08:29:07.100]                     }
[08:29:07.100]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:07.100]                     base::options(mc.cores = 1L)
[08:29:07.100]                   }
[08:29:07.100]                   ...future.strategy.old <- future::plan("list")
[08:29:07.100]                   options(future.plan = NULL)
[08:29:07.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:07.100]                 }
[08:29:07.100]                 ...future.workdir <- getwd()
[08:29:07.100]             }
[08:29:07.100]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:07.100]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:07.100]         }
[08:29:07.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:07.100]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:07.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:07.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:07.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:07.100]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:07.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:07.100]             base::names(...future.oldOptions))
[08:29:07.100]     }
[08:29:07.100]     if (FALSE) {
[08:29:07.100]     }
[08:29:07.100]     else {
[08:29:07.100]         if (TRUE) {
[08:29:07.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:07.100]                 open = "w")
[08:29:07.100]         }
[08:29:07.100]         else {
[08:29:07.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:07.100]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:07.100]         }
[08:29:07.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:07.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:07.100]             base::sink(type = "output", split = FALSE)
[08:29:07.100]             base::close(...future.stdout)
[08:29:07.100]         }, add = TRUE)
[08:29:07.100]     }
[08:29:07.100]     ...future.frame <- base::sys.nframe()
[08:29:07.100]     ...future.conditions <- base::list()
[08:29:07.100]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:07.100]     if (FALSE) {
[08:29:07.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:07.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:07.100]     }
[08:29:07.100]     ...future.result <- base::tryCatch({
[08:29:07.100]         base::withCallingHandlers({
[08:29:07.100]             ...future.value <- base::withVisible(base::local({
[08:29:07.100]                 ...future.makeSendCondition <- base::local({
[08:29:07.100]                   sendCondition <- NULL
[08:29:07.100]                   function(frame = 1L) {
[08:29:07.100]                     if (is.function(sendCondition)) 
[08:29:07.100]                       return(sendCondition)
[08:29:07.100]                     ns <- getNamespace("parallel")
[08:29:07.100]                     if (exists("sendData", mode = "function", 
[08:29:07.100]                       envir = ns)) {
[08:29:07.100]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:07.100]                         envir = ns)
[08:29:07.100]                       envir <- sys.frame(frame)
[08:29:07.100]                       master <- NULL
[08:29:07.100]                       while (!identical(envir, .GlobalEnv) && 
[08:29:07.100]                         !identical(envir, emptyenv())) {
[08:29:07.100]                         if (exists("master", mode = "list", envir = envir, 
[08:29:07.100]                           inherits = FALSE)) {
[08:29:07.100]                           master <- get("master", mode = "list", 
[08:29:07.100]                             envir = envir, inherits = FALSE)
[08:29:07.100]                           if (inherits(master, c("SOCKnode", 
[08:29:07.100]                             "SOCK0node"))) {
[08:29:07.100]                             sendCondition <<- function(cond) {
[08:29:07.100]                               data <- list(type = "VALUE", value = cond, 
[08:29:07.100]                                 success = TRUE)
[08:29:07.100]                               parallel_sendData(master, data)
[08:29:07.100]                             }
[08:29:07.100]                             return(sendCondition)
[08:29:07.100]                           }
[08:29:07.100]                         }
[08:29:07.100]                         frame <- frame + 1L
[08:29:07.100]                         envir <- sys.frame(frame)
[08:29:07.100]                       }
[08:29:07.100]                     }
[08:29:07.100]                     sendCondition <<- function(cond) NULL
[08:29:07.100]                   }
[08:29:07.100]                 })
[08:29:07.100]                 withCallingHandlers({
[08:29:07.100]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:07.100]                 }, immediateCondition = function(cond) {
[08:29:07.100]                   sendCondition <- ...future.makeSendCondition()
[08:29:07.100]                   sendCondition(cond)
[08:29:07.100]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.100]                   {
[08:29:07.100]                     inherits <- base::inherits
[08:29:07.100]                     invokeRestart <- base::invokeRestart
[08:29:07.100]                     is.null <- base::is.null
[08:29:07.100]                     muffled <- FALSE
[08:29:07.100]                     if (inherits(cond, "message")) {
[08:29:07.100]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:07.100]                       if (muffled) 
[08:29:07.100]                         invokeRestart("muffleMessage")
[08:29:07.100]                     }
[08:29:07.100]                     else if (inherits(cond, "warning")) {
[08:29:07.100]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:07.100]                       if (muffled) 
[08:29:07.100]                         invokeRestart("muffleWarning")
[08:29:07.100]                     }
[08:29:07.100]                     else if (inherits(cond, "condition")) {
[08:29:07.100]                       if (!is.null(pattern)) {
[08:29:07.100]                         computeRestarts <- base::computeRestarts
[08:29:07.100]                         grepl <- base::grepl
[08:29:07.100]                         restarts <- computeRestarts(cond)
[08:29:07.100]                         for (restart in restarts) {
[08:29:07.100]                           name <- restart$name
[08:29:07.100]                           if (is.null(name)) 
[08:29:07.100]                             next
[08:29:07.100]                           if (!grepl(pattern, name)) 
[08:29:07.100]                             next
[08:29:07.100]                           invokeRestart(restart)
[08:29:07.100]                           muffled <- TRUE
[08:29:07.100]                           break
[08:29:07.100]                         }
[08:29:07.100]                       }
[08:29:07.100]                     }
[08:29:07.100]                     invisible(muffled)
[08:29:07.100]                   }
[08:29:07.100]                   muffleCondition(cond)
[08:29:07.100]                 })
[08:29:07.100]             }))
[08:29:07.100]             future::FutureResult(value = ...future.value$value, 
[08:29:07.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.100]                   ...future.rng), globalenv = if (FALSE) 
[08:29:07.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:07.100]                     ...future.globalenv.names))
[08:29:07.100]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:07.100]         }, condition = base::local({
[08:29:07.100]             c <- base::c
[08:29:07.100]             inherits <- base::inherits
[08:29:07.100]             invokeRestart <- base::invokeRestart
[08:29:07.100]             length <- base::length
[08:29:07.100]             list <- base::list
[08:29:07.100]             seq.int <- base::seq.int
[08:29:07.100]             signalCondition <- base::signalCondition
[08:29:07.100]             sys.calls <- base::sys.calls
[08:29:07.100]             `[[` <- base::`[[`
[08:29:07.100]             `+` <- base::`+`
[08:29:07.100]             `<<-` <- base::`<<-`
[08:29:07.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:07.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:07.100]                   3L)]
[08:29:07.100]             }
[08:29:07.100]             function(cond) {
[08:29:07.100]                 is_error <- inherits(cond, "error")
[08:29:07.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:07.100]                   NULL)
[08:29:07.100]                 if (is_error) {
[08:29:07.100]                   sessionInformation <- function() {
[08:29:07.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:07.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:07.100]                       search = base::search(), system = base::Sys.info())
[08:29:07.100]                   }
[08:29:07.100]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:07.100]                     cond$call), session = sessionInformation(), 
[08:29:07.100]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:07.100]                   signalCondition(cond)
[08:29:07.100]                 }
[08:29:07.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:07.100]                 "immediateCondition"))) {
[08:29:07.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:07.100]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:07.100]                   if (TRUE && !signal) {
[08:29:07.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.100]                     {
[08:29:07.100]                       inherits <- base::inherits
[08:29:07.100]                       invokeRestart <- base::invokeRestart
[08:29:07.100]                       is.null <- base::is.null
[08:29:07.100]                       muffled <- FALSE
[08:29:07.100]                       if (inherits(cond, "message")) {
[08:29:07.100]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.100]                         if (muffled) 
[08:29:07.100]                           invokeRestart("muffleMessage")
[08:29:07.100]                       }
[08:29:07.100]                       else if (inherits(cond, "warning")) {
[08:29:07.100]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.100]                         if (muffled) 
[08:29:07.100]                           invokeRestart("muffleWarning")
[08:29:07.100]                       }
[08:29:07.100]                       else if (inherits(cond, "condition")) {
[08:29:07.100]                         if (!is.null(pattern)) {
[08:29:07.100]                           computeRestarts <- base::computeRestarts
[08:29:07.100]                           grepl <- base::grepl
[08:29:07.100]                           restarts <- computeRestarts(cond)
[08:29:07.100]                           for (restart in restarts) {
[08:29:07.100]                             name <- restart$name
[08:29:07.100]                             if (is.null(name)) 
[08:29:07.100]                               next
[08:29:07.100]                             if (!grepl(pattern, name)) 
[08:29:07.100]                               next
[08:29:07.100]                             invokeRestart(restart)
[08:29:07.100]                             muffled <- TRUE
[08:29:07.100]                             break
[08:29:07.100]                           }
[08:29:07.100]                         }
[08:29:07.100]                       }
[08:29:07.100]                       invisible(muffled)
[08:29:07.100]                     }
[08:29:07.100]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.100]                   }
[08:29:07.100]                 }
[08:29:07.100]                 else {
[08:29:07.100]                   if (TRUE) {
[08:29:07.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.100]                     {
[08:29:07.100]                       inherits <- base::inherits
[08:29:07.100]                       invokeRestart <- base::invokeRestart
[08:29:07.100]                       is.null <- base::is.null
[08:29:07.100]                       muffled <- FALSE
[08:29:07.100]                       if (inherits(cond, "message")) {
[08:29:07.100]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.100]                         if (muffled) 
[08:29:07.100]                           invokeRestart("muffleMessage")
[08:29:07.100]                       }
[08:29:07.100]                       else if (inherits(cond, "warning")) {
[08:29:07.100]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.100]                         if (muffled) 
[08:29:07.100]                           invokeRestart("muffleWarning")
[08:29:07.100]                       }
[08:29:07.100]                       else if (inherits(cond, "condition")) {
[08:29:07.100]                         if (!is.null(pattern)) {
[08:29:07.100]                           computeRestarts <- base::computeRestarts
[08:29:07.100]                           grepl <- base::grepl
[08:29:07.100]                           restarts <- computeRestarts(cond)
[08:29:07.100]                           for (restart in restarts) {
[08:29:07.100]                             name <- restart$name
[08:29:07.100]                             if (is.null(name)) 
[08:29:07.100]                               next
[08:29:07.100]                             if (!grepl(pattern, name)) 
[08:29:07.100]                               next
[08:29:07.100]                             invokeRestart(restart)
[08:29:07.100]                             muffled <- TRUE
[08:29:07.100]                             break
[08:29:07.100]                           }
[08:29:07.100]                         }
[08:29:07.100]                       }
[08:29:07.100]                       invisible(muffled)
[08:29:07.100]                     }
[08:29:07.100]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.100]                   }
[08:29:07.100]                 }
[08:29:07.100]             }
[08:29:07.100]         }))
[08:29:07.100]     }, error = function(ex) {
[08:29:07.100]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:07.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.100]                 ...future.rng), started = ...future.startTime, 
[08:29:07.100]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:07.100]             version = "1.8"), class = "FutureResult")
[08:29:07.100]     }, finally = {
[08:29:07.100]         if (!identical(...future.workdir, getwd())) 
[08:29:07.100]             setwd(...future.workdir)
[08:29:07.100]         {
[08:29:07.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:07.100]                 ...future.oldOptions$nwarnings <- NULL
[08:29:07.100]             }
[08:29:07.100]             base::options(...future.oldOptions)
[08:29:07.100]             if (.Platform$OS.type == "windows") {
[08:29:07.100]                 old_names <- names(...future.oldEnvVars)
[08:29:07.100]                 envs <- base::Sys.getenv()
[08:29:07.100]                 names <- names(envs)
[08:29:07.100]                 common <- intersect(names, old_names)
[08:29:07.100]                 added <- setdiff(names, old_names)
[08:29:07.100]                 removed <- setdiff(old_names, names)
[08:29:07.100]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:07.100]                   envs[common]]
[08:29:07.100]                 NAMES <- toupper(changed)
[08:29:07.100]                 args <- list()
[08:29:07.100]                 for (kk in seq_along(NAMES)) {
[08:29:07.100]                   name <- changed[[kk]]
[08:29:07.100]                   NAME <- NAMES[[kk]]
[08:29:07.100]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.100]                     next
[08:29:07.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.100]                 }
[08:29:07.100]                 NAMES <- toupper(added)
[08:29:07.100]                 for (kk in seq_along(NAMES)) {
[08:29:07.100]                   name <- added[[kk]]
[08:29:07.100]                   NAME <- NAMES[[kk]]
[08:29:07.100]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.100]                     next
[08:29:07.100]                   args[[name]] <- ""
[08:29:07.100]                 }
[08:29:07.100]                 NAMES <- toupper(removed)
[08:29:07.100]                 for (kk in seq_along(NAMES)) {
[08:29:07.100]                   name <- removed[[kk]]
[08:29:07.100]                   NAME <- NAMES[[kk]]
[08:29:07.100]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.100]                     next
[08:29:07.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.100]                 }
[08:29:07.100]                 if (length(args) > 0) 
[08:29:07.100]                   base::do.call(base::Sys.setenv, args = args)
[08:29:07.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:07.100]             }
[08:29:07.100]             else {
[08:29:07.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:07.100]             }
[08:29:07.100]             {
[08:29:07.100]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:07.100]                   0L) {
[08:29:07.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:07.100]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:07.100]                   base::options(opts)
[08:29:07.100]                 }
[08:29:07.100]                 {
[08:29:07.100]                   {
[08:29:07.100]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:07.100]                     NULL
[08:29:07.100]                   }
[08:29:07.100]                   options(future.plan = NULL)
[08:29:07.100]                   if (is.na(NA_character_)) 
[08:29:07.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:07.100]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:07.100]                     .init = FALSE)
[08:29:07.100]                 }
[08:29:07.100]             }
[08:29:07.100]         }
[08:29:07.100]     })
[08:29:07.100]     if (TRUE) {
[08:29:07.100]         base::sink(type = "output", split = FALSE)
[08:29:07.100]         if (TRUE) {
[08:29:07.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:07.100]         }
[08:29:07.100]         else {
[08:29:07.100]             ...future.result["stdout"] <- base::list(NULL)
[08:29:07.100]         }
[08:29:07.100]         base::close(...future.stdout)
[08:29:07.100]         ...future.stdout <- NULL
[08:29:07.100]     }
[08:29:07.100]     ...future.result$conditions <- ...future.conditions
[08:29:07.100]     ...future.result$finished <- base::Sys.time()
[08:29:07.100]     ...future.result
[08:29:07.100] }
[08:29:07.103] MultisessionFuture started
[08:29:07.103] - Launch lazy future ... done
[08:29:07.103] run() for ‘MultisessionFuture’ ... done
[08:29:07.145] receiveMessageFromWorker() for ClusterFuture ...
[08:29:07.145] - Validating connection of MultisessionFuture
[08:29:07.146] - received message: FutureResult
[08:29:07.146] - Received FutureResult
[08:29:07.146] - Erased future from FutureRegistry
[08:29:07.146] result() for ClusterFuture ...
[08:29:07.146] - result already collected: FutureResult
[08:29:07.146] result() for ClusterFuture ... done
[08:29:07.146] signalConditions() ...
[08:29:07.147]  - include = ‘immediateCondition’
[08:29:07.147]  - exclude = 
[08:29:07.147]  - resignal = FALSE
[08:29:07.147]  - Number of conditions: 1
[08:29:07.147] signalConditions() ... done
[08:29:07.147] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:07.147] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[08:29:07.147] getGlobalsAndPackages() ...
[08:29:07.147] Searching for globals...
[08:29:07.148] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:07.149] Searching for globals ... DONE
[08:29:07.149] Resolving globals: FALSE
[08:29:07.149] 
[08:29:07.149] 
[08:29:07.149] getGlobalsAndPackages() ... DONE
[08:29:07.149] run() for ‘Future’ ...
[08:29:07.149] - state: ‘created’
[08:29:07.150] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:07.163] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:07.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:07.163]   - Field: ‘node’
[08:29:07.163]   - Field: ‘label’
[08:29:07.163]   - Field: ‘local’
[08:29:07.164]   - Field: ‘owner’
[08:29:07.164]   - Field: ‘envir’
[08:29:07.164]   - Field: ‘workers’
[08:29:07.164]   - Field: ‘packages’
[08:29:07.164]   - Field: ‘gc’
[08:29:07.164]   - Field: ‘conditions’
[08:29:07.164]   - Field: ‘persistent’
[08:29:07.164]   - Field: ‘expr’
[08:29:07.164]   - Field: ‘uuid’
[08:29:07.164]   - Field: ‘seed’
[08:29:07.164]   - Field: ‘version’
[08:29:07.164]   - Field: ‘result’
[08:29:07.165]   - Field: ‘asynchronous’
[08:29:07.165]   - Field: ‘calls’
[08:29:07.165]   - Field: ‘globals’
[08:29:07.165]   - Field: ‘stdout’
[08:29:07.165]   - Field: ‘earlySignal’
[08:29:07.165]   - Field: ‘lazy’
[08:29:07.165]   - Field: ‘state’
[08:29:07.165] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:07.165] - Launch lazy future ...
[08:29:07.165] Packages needed by the future expression (n = 0): <none>
[08:29:07.166] Packages needed by future strategies (n = 0): <none>
[08:29:07.166] {
[08:29:07.166]     {
[08:29:07.166]         {
[08:29:07.166]             ...future.startTime <- base::Sys.time()
[08:29:07.166]             {
[08:29:07.166]                 {
[08:29:07.166]                   {
[08:29:07.166]                     {
[08:29:07.166]                       base::local({
[08:29:07.166]                         has_future <- base::requireNamespace("future", 
[08:29:07.166]                           quietly = TRUE)
[08:29:07.166]                         if (has_future) {
[08:29:07.166]                           ns <- base::getNamespace("future")
[08:29:07.166]                           version <- ns[[".package"]][["version"]]
[08:29:07.166]                           if (is.null(version)) 
[08:29:07.166]                             version <- utils::packageVersion("future")
[08:29:07.166]                         }
[08:29:07.166]                         else {
[08:29:07.166]                           version <- NULL
[08:29:07.166]                         }
[08:29:07.166]                         if (!has_future || version < "1.8.0") {
[08:29:07.166]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:07.166]                             "", base::R.version$version.string), 
[08:29:07.166]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:07.166]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:07.166]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:07.166]                               "release", "version")], collapse = " "), 
[08:29:07.166]                             hostname = base::Sys.info()[["nodename"]])
[08:29:07.166]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:07.166]                             info)
[08:29:07.166]                           info <- base::paste(info, collapse = "; ")
[08:29:07.166]                           if (!has_future) {
[08:29:07.166]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:07.166]                               info)
[08:29:07.166]                           }
[08:29:07.166]                           else {
[08:29:07.166]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:07.166]                               info, version)
[08:29:07.166]                           }
[08:29:07.166]                           base::stop(msg)
[08:29:07.166]                         }
[08:29:07.166]                       })
[08:29:07.166]                     }
[08:29:07.166]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:07.166]                     base::options(mc.cores = 1L)
[08:29:07.166]                   }
[08:29:07.166]                   ...future.strategy.old <- future::plan("list")
[08:29:07.166]                   options(future.plan = NULL)
[08:29:07.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:07.166]                 }
[08:29:07.166]                 ...future.workdir <- getwd()
[08:29:07.166]             }
[08:29:07.166]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:07.166]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:07.166]         }
[08:29:07.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:07.166]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:07.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:07.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:07.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:07.166]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:07.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:07.166]             base::names(...future.oldOptions))
[08:29:07.166]     }
[08:29:07.166]     if (FALSE) {
[08:29:07.166]     }
[08:29:07.166]     else {
[08:29:07.166]         if (TRUE) {
[08:29:07.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:07.166]                 open = "w")
[08:29:07.166]         }
[08:29:07.166]         else {
[08:29:07.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:07.166]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:07.166]         }
[08:29:07.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:07.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:07.166]             base::sink(type = "output", split = FALSE)
[08:29:07.166]             base::close(...future.stdout)
[08:29:07.166]         }, add = TRUE)
[08:29:07.166]     }
[08:29:07.166]     ...future.frame <- base::sys.nframe()
[08:29:07.166]     ...future.conditions <- base::list()
[08:29:07.166]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:07.166]     if (FALSE) {
[08:29:07.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:07.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:07.166]     }
[08:29:07.166]     ...future.result <- base::tryCatch({
[08:29:07.166]         base::withCallingHandlers({
[08:29:07.166]             ...future.value <- base::withVisible(base::local({
[08:29:07.166]                 ...future.makeSendCondition <- base::local({
[08:29:07.166]                   sendCondition <- NULL
[08:29:07.166]                   function(frame = 1L) {
[08:29:07.166]                     if (is.function(sendCondition)) 
[08:29:07.166]                       return(sendCondition)
[08:29:07.166]                     ns <- getNamespace("parallel")
[08:29:07.166]                     if (exists("sendData", mode = "function", 
[08:29:07.166]                       envir = ns)) {
[08:29:07.166]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:07.166]                         envir = ns)
[08:29:07.166]                       envir <- sys.frame(frame)
[08:29:07.166]                       master <- NULL
[08:29:07.166]                       while (!identical(envir, .GlobalEnv) && 
[08:29:07.166]                         !identical(envir, emptyenv())) {
[08:29:07.166]                         if (exists("master", mode = "list", envir = envir, 
[08:29:07.166]                           inherits = FALSE)) {
[08:29:07.166]                           master <- get("master", mode = "list", 
[08:29:07.166]                             envir = envir, inherits = FALSE)
[08:29:07.166]                           if (inherits(master, c("SOCKnode", 
[08:29:07.166]                             "SOCK0node"))) {
[08:29:07.166]                             sendCondition <<- function(cond) {
[08:29:07.166]                               data <- list(type = "VALUE", value = cond, 
[08:29:07.166]                                 success = TRUE)
[08:29:07.166]                               parallel_sendData(master, data)
[08:29:07.166]                             }
[08:29:07.166]                             return(sendCondition)
[08:29:07.166]                           }
[08:29:07.166]                         }
[08:29:07.166]                         frame <- frame + 1L
[08:29:07.166]                         envir <- sys.frame(frame)
[08:29:07.166]                       }
[08:29:07.166]                     }
[08:29:07.166]                     sendCondition <<- function(cond) NULL
[08:29:07.166]                   }
[08:29:07.166]                 })
[08:29:07.166]                 withCallingHandlers({
[08:29:07.166]                   {
[08:29:07.166]                     Sys.sleep(0.5)
[08:29:07.166]                     list(a = 1, b = 42L)
[08:29:07.166]                   }
[08:29:07.166]                 }, immediateCondition = function(cond) {
[08:29:07.166]                   sendCondition <- ...future.makeSendCondition()
[08:29:07.166]                   sendCondition(cond)
[08:29:07.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.166]                   {
[08:29:07.166]                     inherits <- base::inherits
[08:29:07.166]                     invokeRestart <- base::invokeRestart
[08:29:07.166]                     is.null <- base::is.null
[08:29:07.166]                     muffled <- FALSE
[08:29:07.166]                     if (inherits(cond, "message")) {
[08:29:07.166]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:07.166]                       if (muffled) 
[08:29:07.166]                         invokeRestart("muffleMessage")
[08:29:07.166]                     }
[08:29:07.166]                     else if (inherits(cond, "warning")) {
[08:29:07.166]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:07.166]                       if (muffled) 
[08:29:07.166]                         invokeRestart("muffleWarning")
[08:29:07.166]                     }
[08:29:07.166]                     else if (inherits(cond, "condition")) {
[08:29:07.166]                       if (!is.null(pattern)) {
[08:29:07.166]                         computeRestarts <- base::computeRestarts
[08:29:07.166]                         grepl <- base::grepl
[08:29:07.166]                         restarts <- computeRestarts(cond)
[08:29:07.166]                         for (restart in restarts) {
[08:29:07.166]                           name <- restart$name
[08:29:07.166]                           if (is.null(name)) 
[08:29:07.166]                             next
[08:29:07.166]                           if (!grepl(pattern, name)) 
[08:29:07.166]                             next
[08:29:07.166]                           invokeRestart(restart)
[08:29:07.166]                           muffled <- TRUE
[08:29:07.166]                           break
[08:29:07.166]                         }
[08:29:07.166]                       }
[08:29:07.166]                     }
[08:29:07.166]                     invisible(muffled)
[08:29:07.166]                   }
[08:29:07.166]                   muffleCondition(cond)
[08:29:07.166]                 })
[08:29:07.166]             }))
[08:29:07.166]             future::FutureResult(value = ...future.value$value, 
[08:29:07.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.166]                   ...future.rng), globalenv = if (FALSE) 
[08:29:07.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:07.166]                     ...future.globalenv.names))
[08:29:07.166]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:07.166]         }, condition = base::local({
[08:29:07.166]             c <- base::c
[08:29:07.166]             inherits <- base::inherits
[08:29:07.166]             invokeRestart <- base::invokeRestart
[08:29:07.166]             length <- base::length
[08:29:07.166]             list <- base::list
[08:29:07.166]             seq.int <- base::seq.int
[08:29:07.166]             signalCondition <- base::signalCondition
[08:29:07.166]             sys.calls <- base::sys.calls
[08:29:07.166]             `[[` <- base::`[[`
[08:29:07.166]             `+` <- base::`+`
[08:29:07.166]             `<<-` <- base::`<<-`
[08:29:07.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:07.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:07.166]                   3L)]
[08:29:07.166]             }
[08:29:07.166]             function(cond) {
[08:29:07.166]                 is_error <- inherits(cond, "error")
[08:29:07.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:07.166]                   NULL)
[08:29:07.166]                 if (is_error) {
[08:29:07.166]                   sessionInformation <- function() {
[08:29:07.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:07.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:07.166]                       search = base::search(), system = base::Sys.info())
[08:29:07.166]                   }
[08:29:07.166]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:07.166]                     cond$call), session = sessionInformation(), 
[08:29:07.166]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:07.166]                   signalCondition(cond)
[08:29:07.166]                 }
[08:29:07.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:07.166]                 "immediateCondition"))) {
[08:29:07.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:07.166]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:07.166]                   if (TRUE && !signal) {
[08:29:07.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.166]                     {
[08:29:07.166]                       inherits <- base::inherits
[08:29:07.166]                       invokeRestart <- base::invokeRestart
[08:29:07.166]                       is.null <- base::is.null
[08:29:07.166]                       muffled <- FALSE
[08:29:07.166]                       if (inherits(cond, "message")) {
[08:29:07.166]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.166]                         if (muffled) 
[08:29:07.166]                           invokeRestart("muffleMessage")
[08:29:07.166]                       }
[08:29:07.166]                       else if (inherits(cond, "warning")) {
[08:29:07.166]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.166]                         if (muffled) 
[08:29:07.166]                           invokeRestart("muffleWarning")
[08:29:07.166]                       }
[08:29:07.166]                       else if (inherits(cond, "condition")) {
[08:29:07.166]                         if (!is.null(pattern)) {
[08:29:07.166]                           computeRestarts <- base::computeRestarts
[08:29:07.166]                           grepl <- base::grepl
[08:29:07.166]                           restarts <- computeRestarts(cond)
[08:29:07.166]                           for (restart in restarts) {
[08:29:07.166]                             name <- restart$name
[08:29:07.166]                             if (is.null(name)) 
[08:29:07.166]                               next
[08:29:07.166]                             if (!grepl(pattern, name)) 
[08:29:07.166]                               next
[08:29:07.166]                             invokeRestart(restart)
[08:29:07.166]                             muffled <- TRUE
[08:29:07.166]                             break
[08:29:07.166]                           }
[08:29:07.166]                         }
[08:29:07.166]                       }
[08:29:07.166]                       invisible(muffled)
[08:29:07.166]                     }
[08:29:07.166]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.166]                   }
[08:29:07.166]                 }
[08:29:07.166]                 else {
[08:29:07.166]                   if (TRUE) {
[08:29:07.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.166]                     {
[08:29:07.166]                       inherits <- base::inherits
[08:29:07.166]                       invokeRestart <- base::invokeRestart
[08:29:07.166]                       is.null <- base::is.null
[08:29:07.166]                       muffled <- FALSE
[08:29:07.166]                       if (inherits(cond, "message")) {
[08:29:07.166]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.166]                         if (muffled) 
[08:29:07.166]                           invokeRestart("muffleMessage")
[08:29:07.166]                       }
[08:29:07.166]                       else if (inherits(cond, "warning")) {
[08:29:07.166]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.166]                         if (muffled) 
[08:29:07.166]                           invokeRestart("muffleWarning")
[08:29:07.166]                       }
[08:29:07.166]                       else if (inherits(cond, "condition")) {
[08:29:07.166]                         if (!is.null(pattern)) {
[08:29:07.166]                           computeRestarts <- base::computeRestarts
[08:29:07.166]                           grepl <- base::grepl
[08:29:07.166]                           restarts <- computeRestarts(cond)
[08:29:07.166]                           for (restart in restarts) {
[08:29:07.166]                             name <- restart$name
[08:29:07.166]                             if (is.null(name)) 
[08:29:07.166]                               next
[08:29:07.166]                             if (!grepl(pattern, name)) 
[08:29:07.166]                               next
[08:29:07.166]                             invokeRestart(restart)
[08:29:07.166]                             muffled <- TRUE
[08:29:07.166]                             break
[08:29:07.166]                           }
[08:29:07.166]                         }
[08:29:07.166]                       }
[08:29:07.166]                       invisible(muffled)
[08:29:07.166]                     }
[08:29:07.166]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.166]                   }
[08:29:07.166]                 }
[08:29:07.166]             }
[08:29:07.166]         }))
[08:29:07.166]     }, error = function(ex) {
[08:29:07.166]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:07.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.166]                 ...future.rng), started = ...future.startTime, 
[08:29:07.166]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:07.166]             version = "1.8"), class = "FutureResult")
[08:29:07.166]     }, finally = {
[08:29:07.166]         if (!identical(...future.workdir, getwd())) 
[08:29:07.166]             setwd(...future.workdir)
[08:29:07.166]         {
[08:29:07.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:07.166]                 ...future.oldOptions$nwarnings <- NULL
[08:29:07.166]             }
[08:29:07.166]             base::options(...future.oldOptions)
[08:29:07.166]             if (.Platform$OS.type == "windows") {
[08:29:07.166]                 old_names <- names(...future.oldEnvVars)
[08:29:07.166]                 envs <- base::Sys.getenv()
[08:29:07.166]                 names <- names(envs)
[08:29:07.166]                 common <- intersect(names, old_names)
[08:29:07.166]                 added <- setdiff(names, old_names)
[08:29:07.166]                 removed <- setdiff(old_names, names)
[08:29:07.166]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:07.166]                   envs[common]]
[08:29:07.166]                 NAMES <- toupper(changed)
[08:29:07.166]                 args <- list()
[08:29:07.166]                 for (kk in seq_along(NAMES)) {
[08:29:07.166]                   name <- changed[[kk]]
[08:29:07.166]                   NAME <- NAMES[[kk]]
[08:29:07.166]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.166]                     next
[08:29:07.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.166]                 }
[08:29:07.166]                 NAMES <- toupper(added)
[08:29:07.166]                 for (kk in seq_along(NAMES)) {
[08:29:07.166]                   name <- added[[kk]]
[08:29:07.166]                   NAME <- NAMES[[kk]]
[08:29:07.166]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.166]                     next
[08:29:07.166]                   args[[name]] <- ""
[08:29:07.166]                 }
[08:29:07.166]                 NAMES <- toupper(removed)
[08:29:07.166]                 for (kk in seq_along(NAMES)) {
[08:29:07.166]                   name <- removed[[kk]]
[08:29:07.166]                   NAME <- NAMES[[kk]]
[08:29:07.166]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.166]                     next
[08:29:07.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.166]                 }
[08:29:07.166]                 if (length(args) > 0) 
[08:29:07.166]                   base::do.call(base::Sys.setenv, args = args)
[08:29:07.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:07.166]             }
[08:29:07.166]             else {
[08:29:07.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:07.166]             }
[08:29:07.166]             {
[08:29:07.166]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:07.166]                   0L) {
[08:29:07.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:07.166]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:07.166]                   base::options(opts)
[08:29:07.166]                 }
[08:29:07.166]                 {
[08:29:07.166]                   {
[08:29:07.166]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:07.166]                     NULL
[08:29:07.166]                   }
[08:29:07.166]                   options(future.plan = NULL)
[08:29:07.166]                   if (is.na(NA_character_)) 
[08:29:07.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:07.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:07.166]                     .init = FALSE)
[08:29:07.166]                 }
[08:29:07.166]             }
[08:29:07.166]         }
[08:29:07.166]     })
[08:29:07.166]     if (TRUE) {
[08:29:07.166]         base::sink(type = "output", split = FALSE)
[08:29:07.166]         if (TRUE) {
[08:29:07.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:07.166]         }
[08:29:07.166]         else {
[08:29:07.166]             ...future.result["stdout"] <- base::list(NULL)
[08:29:07.166]         }
[08:29:07.166]         base::close(...future.stdout)
[08:29:07.166]         ...future.stdout <- NULL
[08:29:07.166]     }
[08:29:07.166]     ...future.result$conditions <- ...future.conditions
[08:29:07.166]     ...future.result$finished <- base::Sys.time()
[08:29:07.166]     ...future.result
[08:29:07.166] }
[08:29:07.169] MultisessionFuture started
[08:29:07.169] - Launch lazy future ... done
[08:29:07.169] run() for ‘MultisessionFuture’ ... done
[08:29:07.169] getGlobalsAndPackages() ...
[08:29:07.169] Searching for globals...
[08:29:07.170] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:07.170] Searching for globals ... DONE
[08:29:07.171] Resolving globals: FALSE
[08:29:07.171] 
[08:29:07.171] 
[08:29:07.171] getGlobalsAndPackages() ... DONE
- w/ exception ...
[08:29:07.171] getGlobalsAndPackages() ...
[08:29:07.171] Searching for globals...
[08:29:07.172] - globals found: [2] ‘list’, ‘stop’
[08:29:07.172] Searching for globals ... DONE
[08:29:07.172] Resolving globals: FALSE
[08:29:07.172] 
[08:29:07.173] 
[08:29:07.173] getGlobalsAndPackages() ... DONE
[08:29:07.173] run() for ‘Future’ ...
[08:29:07.173] - state: ‘created’
[08:29:07.173] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:07.187] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:07.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:07.187]   - Field: ‘node’
[08:29:07.187]   - Field: ‘label’
[08:29:07.187]   - Field: ‘local’
[08:29:07.187]   - Field: ‘owner’
[08:29:07.187]   - Field: ‘envir’
[08:29:07.187]   - Field: ‘workers’
[08:29:07.187]   - Field: ‘packages’
[08:29:07.188]   - Field: ‘gc’
[08:29:07.188]   - Field: ‘conditions’
[08:29:07.188]   - Field: ‘persistent’
[08:29:07.188]   - Field: ‘expr’
[08:29:07.188]   - Field: ‘uuid’
[08:29:07.188]   - Field: ‘seed’
[08:29:07.188]   - Field: ‘version’
[08:29:07.188]   - Field: ‘result’
[08:29:07.188]   - Field: ‘asynchronous’
[08:29:07.188]   - Field: ‘calls’
[08:29:07.188]   - Field: ‘globals’
[08:29:07.188]   - Field: ‘stdout’
[08:29:07.189]   - Field: ‘earlySignal’
[08:29:07.189]   - Field: ‘lazy’
[08:29:07.189]   - Field: ‘state’
[08:29:07.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:07.189] - Launch lazy future ...
[08:29:07.189] Packages needed by the future expression (n = 0): <none>
[08:29:07.189] Packages needed by future strategies (n = 0): <none>
[08:29:07.190] {
[08:29:07.190]     {
[08:29:07.190]         {
[08:29:07.190]             ...future.startTime <- base::Sys.time()
[08:29:07.190]             {
[08:29:07.190]                 {
[08:29:07.190]                   {
[08:29:07.190]                     {
[08:29:07.190]                       base::local({
[08:29:07.190]                         has_future <- base::requireNamespace("future", 
[08:29:07.190]                           quietly = TRUE)
[08:29:07.190]                         if (has_future) {
[08:29:07.190]                           ns <- base::getNamespace("future")
[08:29:07.190]                           version <- ns[[".package"]][["version"]]
[08:29:07.190]                           if (is.null(version)) 
[08:29:07.190]                             version <- utils::packageVersion("future")
[08:29:07.190]                         }
[08:29:07.190]                         else {
[08:29:07.190]                           version <- NULL
[08:29:07.190]                         }
[08:29:07.190]                         if (!has_future || version < "1.8.0") {
[08:29:07.190]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:07.190]                             "", base::R.version$version.string), 
[08:29:07.190]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:07.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:07.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:07.190]                               "release", "version")], collapse = " "), 
[08:29:07.190]                             hostname = base::Sys.info()[["nodename"]])
[08:29:07.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:07.190]                             info)
[08:29:07.190]                           info <- base::paste(info, collapse = "; ")
[08:29:07.190]                           if (!has_future) {
[08:29:07.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:07.190]                               info)
[08:29:07.190]                           }
[08:29:07.190]                           else {
[08:29:07.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:07.190]                               info, version)
[08:29:07.190]                           }
[08:29:07.190]                           base::stop(msg)
[08:29:07.190]                         }
[08:29:07.190]                       })
[08:29:07.190]                     }
[08:29:07.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:07.190]                     base::options(mc.cores = 1L)
[08:29:07.190]                   }
[08:29:07.190]                   ...future.strategy.old <- future::plan("list")
[08:29:07.190]                   options(future.plan = NULL)
[08:29:07.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:07.190]                 }
[08:29:07.190]                 ...future.workdir <- getwd()
[08:29:07.190]             }
[08:29:07.190]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:07.190]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:07.190]         }
[08:29:07.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:07.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:07.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:07.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:07.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:07.190]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:07.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:07.190]             base::names(...future.oldOptions))
[08:29:07.190]     }
[08:29:07.190]     if (FALSE) {
[08:29:07.190]     }
[08:29:07.190]     else {
[08:29:07.190]         if (TRUE) {
[08:29:07.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:07.190]                 open = "w")
[08:29:07.190]         }
[08:29:07.190]         else {
[08:29:07.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:07.190]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:07.190]         }
[08:29:07.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:07.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:07.190]             base::sink(type = "output", split = FALSE)
[08:29:07.190]             base::close(...future.stdout)
[08:29:07.190]         }, add = TRUE)
[08:29:07.190]     }
[08:29:07.190]     ...future.frame <- base::sys.nframe()
[08:29:07.190]     ...future.conditions <- base::list()
[08:29:07.190]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:07.190]     if (FALSE) {
[08:29:07.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:07.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:07.190]     }
[08:29:07.190]     ...future.result <- base::tryCatch({
[08:29:07.190]         base::withCallingHandlers({
[08:29:07.190]             ...future.value <- base::withVisible(base::local({
[08:29:07.190]                 ...future.makeSendCondition <- base::local({
[08:29:07.190]                   sendCondition <- NULL
[08:29:07.190]                   function(frame = 1L) {
[08:29:07.190]                     if (is.function(sendCondition)) 
[08:29:07.190]                       return(sendCondition)
[08:29:07.190]                     ns <- getNamespace("parallel")
[08:29:07.190]                     if (exists("sendData", mode = "function", 
[08:29:07.190]                       envir = ns)) {
[08:29:07.190]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:07.190]                         envir = ns)
[08:29:07.190]                       envir <- sys.frame(frame)
[08:29:07.190]                       master <- NULL
[08:29:07.190]                       while (!identical(envir, .GlobalEnv) && 
[08:29:07.190]                         !identical(envir, emptyenv())) {
[08:29:07.190]                         if (exists("master", mode = "list", envir = envir, 
[08:29:07.190]                           inherits = FALSE)) {
[08:29:07.190]                           master <- get("master", mode = "list", 
[08:29:07.190]                             envir = envir, inherits = FALSE)
[08:29:07.190]                           if (inherits(master, c("SOCKnode", 
[08:29:07.190]                             "SOCK0node"))) {
[08:29:07.190]                             sendCondition <<- function(cond) {
[08:29:07.190]                               data <- list(type = "VALUE", value = cond, 
[08:29:07.190]                                 success = TRUE)
[08:29:07.190]                               parallel_sendData(master, data)
[08:29:07.190]                             }
[08:29:07.190]                             return(sendCondition)
[08:29:07.190]                           }
[08:29:07.190]                         }
[08:29:07.190]                         frame <- frame + 1L
[08:29:07.190]                         envir <- sys.frame(frame)
[08:29:07.190]                       }
[08:29:07.190]                     }
[08:29:07.190]                     sendCondition <<- function(cond) NULL
[08:29:07.190]                   }
[08:29:07.190]                 })
[08:29:07.190]                 withCallingHandlers({
[08:29:07.190]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:07.190]                 }, immediateCondition = function(cond) {
[08:29:07.190]                   sendCondition <- ...future.makeSendCondition()
[08:29:07.190]                   sendCondition(cond)
[08:29:07.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.190]                   {
[08:29:07.190]                     inherits <- base::inherits
[08:29:07.190]                     invokeRestart <- base::invokeRestart
[08:29:07.190]                     is.null <- base::is.null
[08:29:07.190]                     muffled <- FALSE
[08:29:07.190]                     if (inherits(cond, "message")) {
[08:29:07.190]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:07.190]                       if (muffled) 
[08:29:07.190]                         invokeRestart("muffleMessage")
[08:29:07.190]                     }
[08:29:07.190]                     else if (inherits(cond, "warning")) {
[08:29:07.190]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:07.190]                       if (muffled) 
[08:29:07.190]                         invokeRestart("muffleWarning")
[08:29:07.190]                     }
[08:29:07.190]                     else if (inherits(cond, "condition")) {
[08:29:07.190]                       if (!is.null(pattern)) {
[08:29:07.190]                         computeRestarts <- base::computeRestarts
[08:29:07.190]                         grepl <- base::grepl
[08:29:07.190]                         restarts <- computeRestarts(cond)
[08:29:07.190]                         for (restart in restarts) {
[08:29:07.190]                           name <- restart$name
[08:29:07.190]                           if (is.null(name)) 
[08:29:07.190]                             next
[08:29:07.190]                           if (!grepl(pattern, name)) 
[08:29:07.190]                             next
[08:29:07.190]                           invokeRestart(restart)
[08:29:07.190]                           muffled <- TRUE
[08:29:07.190]                           break
[08:29:07.190]                         }
[08:29:07.190]                       }
[08:29:07.190]                     }
[08:29:07.190]                     invisible(muffled)
[08:29:07.190]                   }
[08:29:07.190]                   muffleCondition(cond)
[08:29:07.190]                 })
[08:29:07.190]             }))
[08:29:07.190]             future::FutureResult(value = ...future.value$value, 
[08:29:07.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.190]                   ...future.rng), globalenv = if (FALSE) 
[08:29:07.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:07.190]                     ...future.globalenv.names))
[08:29:07.190]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:07.190]         }, condition = base::local({
[08:29:07.190]             c <- base::c
[08:29:07.190]             inherits <- base::inherits
[08:29:07.190]             invokeRestart <- base::invokeRestart
[08:29:07.190]             length <- base::length
[08:29:07.190]             list <- base::list
[08:29:07.190]             seq.int <- base::seq.int
[08:29:07.190]             signalCondition <- base::signalCondition
[08:29:07.190]             sys.calls <- base::sys.calls
[08:29:07.190]             `[[` <- base::`[[`
[08:29:07.190]             `+` <- base::`+`
[08:29:07.190]             `<<-` <- base::`<<-`
[08:29:07.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:07.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:07.190]                   3L)]
[08:29:07.190]             }
[08:29:07.190]             function(cond) {
[08:29:07.190]                 is_error <- inherits(cond, "error")
[08:29:07.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:07.190]                   NULL)
[08:29:07.190]                 if (is_error) {
[08:29:07.190]                   sessionInformation <- function() {
[08:29:07.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:07.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:07.190]                       search = base::search(), system = base::Sys.info())
[08:29:07.190]                   }
[08:29:07.190]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:07.190]                     cond$call), session = sessionInformation(), 
[08:29:07.190]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:07.190]                   signalCondition(cond)
[08:29:07.190]                 }
[08:29:07.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:07.190]                 "immediateCondition"))) {
[08:29:07.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:07.190]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:07.190]                   if (TRUE && !signal) {
[08:29:07.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.190]                     {
[08:29:07.190]                       inherits <- base::inherits
[08:29:07.190]                       invokeRestart <- base::invokeRestart
[08:29:07.190]                       is.null <- base::is.null
[08:29:07.190]                       muffled <- FALSE
[08:29:07.190]                       if (inherits(cond, "message")) {
[08:29:07.190]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.190]                         if (muffled) 
[08:29:07.190]                           invokeRestart("muffleMessage")
[08:29:07.190]                       }
[08:29:07.190]                       else if (inherits(cond, "warning")) {
[08:29:07.190]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.190]                         if (muffled) 
[08:29:07.190]                           invokeRestart("muffleWarning")
[08:29:07.190]                       }
[08:29:07.190]                       else if (inherits(cond, "condition")) {
[08:29:07.190]                         if (!is.null(pattern)) {
[08:29:07.190]                           computeRestarts <- base::computeRestarts
[08:29:07.190]                           grepl <- base::grepl
[08:29:07.190]                           restarts <- computeRestarts(cond)
[08:29:07.190]                           for (restart in restarts) {
[08:29:07.190]                             name <- restart$name
[08:29:07.190]                             if (is.null(name)) 
[08:29:07.190]                               next
[08:29:07.190]                             if (!grepl(pattern, name)) 
[08:29:07.190]                               next
[08:29:07.190]                             invokeRestart(restart)
[08:29:07.190]                             muffled <- TRUE
[08:29:07.190]                             break
[08:29:07.190]                           }
[08:29:07.190]                         }
[08:29:07.190]                       }
[08:29:07.190]                       invisible(muffled)
[08:29:07.190]                     }
[08:29:07.190]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.190]                   }
[08:29:07.190]                 }
[08:29:07.190]                 else {
[08:29:07.190]                   if (TRUE) {
[08:29:07.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.190]                     {
[08:29:07.190]                       inherits <- base::inherits
[08:29:07.190]                       invokeRestart <- base::invokeRestart
[08:29:07.190]                       is.null <- base::is.null
[08:29:07.190]                       muffled <- FALSE
[08:29:07.190]                       if (inherits(cond, "message")) {
[08:29:07.190]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.190]                         if (muffled) 
[08:29:07.190]                           invokeRestart("muffleMessage")
[08:29:07.190]                       }
[08:29:07.190]                       else if (inherits(cond, "warning")) {
[08:29:07.190]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.190]                         if (muffled) 
[08:29:07.190]                           invokeRestart("muffleWarning")
[08:29:07.190]                       }
[08:29:07.190]                       else if (inherits(cond, "condition")) {
[08:29:07.190]                         if (!is.null(pattern)) {
[08:29:07.190]                           computeRestarts <- base::computeRestarts
[08:29:07.190]                           grepl <- base::grepl
[08:29:07.190]                           restarts <- computeRestarts(cond)
[08:29:07.190]                           for (restart in restarts) {
[08:29:07.190]                             name <- restart$name
[08:29:07.190]                             if (is.null(name)) 
[08:29:07.190]                               next
[08:29:07.190]                             if (!grepl(pattern, name)) 
[08:29:07.190]                               next
[08:29:07.190]                             invokeRestart(restart)
[08:29:07.190]                             muffled <- TRUE
[08:29:07.190]                             break
[08:29:07.190]                           }
[08:29:07.190]                         }
[08:29:07.190]                       }
[08:29:07.190]                       invisible(muffled)
[08:29:07.190]                     }
[08:29:07.190]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.190]                   }
[08:29:07.190]                 }
[08:29:07.190]             }
[08:29:07.190]         }))
[08:29:07.190]     }, error = function(ex) {
[08:29:07.190]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:07.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.190]                 ...future.rng), started = ...future.startTime, 
[08:29:07.190]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:07.190]             version = "1.8"), class = "FutureResult")
[08:29:07.190]     }, finally = {
[08:29:07.190]         if (!identical(...future.workdir, getwd())) 
[08:29:07.190]             setwd(...future.workdir)
[08:29:07.190]         {
[08:29:07.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:07.190]                 ...future.oldOptions$nwarnings <- NULL
[08:29:07.190]             }
[08:29:07.190]             base::options(...future.oldOptions)
[08:29:07.190]             if (.Platform$OS.type == "windows") {
[08:29:07.190]                 old_names <- names(...future.oldEnvVars)
[08:29:07.190]                 envs <- base::Sys.getenv()
[08:29:07.190]                 names <- names(envs)
[08:29:07.190]                 common <- intersect(names, old_names)
[08:29:07.190]                 added <- setdiff(names, old_names)
[08:29:07.190]                 removed <- setdiff(old_names, names)
[08:29:07.190]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:07.190]                   envs[common]]
[08:29:07.190]                 NAMES <- toupper(changed)
[08:29:07.190]                 args <- list()
[08:29:07.190]                 for (kk in seq_along(NAMES)) {
[08:29:07.190]                   name <- changed[[kk]]
[08:29:07.190]                   NAME <- NAMES[[kk]]
[08:29:07.190]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.190]                     next
[08:29:07.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.190]                 }
[08:29:07.190]                 NAMES <- toupper(added)
[08:29:07.190]                 for (kk in seq_along(NAMES)) {
[08:29:07.190]                   name <- added[[kk]]
[08:29:07.190]                   NAME <- NAMES[[kk]]
[08:29:07.190]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.190]                     next
[08:29:07.190]                   args[[name]] <- ""
[08:29:07.190]                 }
[08:29:07.190]                 NAMES <- toupper(removed)
[08:29:07.190]                 for (kk in seq_along(NAMES)) {
[08:29:07.190]                   name <- removed[[kk]]
[08:29:07.190]                   NAME <- NAMES[[kk]]
[08:29:07.190]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.190]                     next
[08:29:07.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.190]                 }
[08:29:07.190]                 if (length(args) > 0) 
[08:29:07.190]                   base::do.call(base::Sys.setenv, args = args)
[08:29:07.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:07.190]             }
[08:29:07.190]             else {
[08:29:07.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:07.190]             }
[08:29:07.190]             {
[08:29:07.190]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:07.190]                   0L) {
[08:29:07.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:07.190]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:07.190]                   base::options(opts)
[08:29:07.190]                 }
[08:29:07.190]                 {
[08:29:07.190]                   {
[08:29:07.190]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:07.190]                     NULL
[08:29:07.190]                   }
[08:29:07.190]                   options(future.plan = NULL)
[08:29:07.190]                   if (is.na(NA_character_)) 
[08:29:07.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:07.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:07.190]                     .init = FALSE)
[08:29:07.190]                 }
[08:29:07.190]             }
[08:29:07.190]         }
[08:29:07.190]     })
[08:29:07.190]     if (TRUE) {
[08:29:07.190]         base::sink(type = "output", split = FALSE)
[08:29:07.190]         if (TRUE) {
[08:29:07.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:07.190]         }
[08:29:07.190]         else {
[08:29:07.190]             ...future.result["stdout"] <- base::list(NULL)
[08:29:07.190]         }
[08:29:07.190]         base::close(...future.stdout)
[08:29:07.190]         ...future.stdout <- NULL
[08:29:07.190]     }
[08:29:07.190]     ...future.result$conditions <- ...future.conditions
[08:29:07.190]     ...future.result$finished <- base::Sys.time()
[08:29:07.190]     ...future.result
[08:29:07.190] }
[08:29:07.241] MultisessionFuture started
[08:29:07.241] - Launch lazy future ... done
[08:29:07.242] run() for ‘MultisessionFuture’ ... done
[08:29:07.242] getGlobalsAndPackages() ...
[08:29:07.242] Searching for globals...
[08:29:07.245] - globals found: [2] ‘list’, ‘stop’
[08:29:07.245] Searching for globals ... DONE
[08:29:07.245] Resolving globals: FALSE
[08:29:07.246] 
[08:29:07.246] 
[08:29:07.246] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[08:29:07.246] getGlobalsAndPackages() ...
[08:29:07.246] Searching for globals...
[08:29:07.247] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:07.247] Searching for globals ... DONE
[08:29:07.247] Resolving globals: FALSE
[08:29:07.248] 
[08:29:07.248] 
[08:29:07.248] getGlobalsAndPackages() ... DONE
[08:29:07.248] run() for ‘Future’ ...
[08:29:07.248] - state: ‘created’
[08:29:07.248] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:07.262] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:07.262] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:07.263]   - Field: ‘node’
[08:29:07.263]   - Field: ‘label’
[08:29:07.263]   - Field: ‘local’
[08:29:07.263]   - Field: ‘owner’
[08:29:07.263]   - Field: ‘envir’
[08:29:07.263]   - Field: ‘workers’
[08:29:07.263]   - Field: ‘packages’
[08:29:07.263]   - Field: ‘gc’
[08:29:07.263]   - Field: ‘conditions’
[08:29:07.263]   - Field: ‘persistent’
[08:29:07.263]   - Field: ‘expr’
[08:29:07.263]   - Field: ‘uuid’
[08:29:07.264]   - Field: ‘seed’
[08:29:07.264]   - Field: ‘version’
[08:29:07.264]   - Field: ‘result’
[08:29:07.264]   - Field: ‘asynchronous’
[08:29:07.264]   - Field: ‘calls’
[08:29:07.264]   - Field: ‘globals’
[08:29:07.264]   - Field: ‘stdout’
[08:29:07.264]   - Field: ‘earlySignal’
[08:29:07.264]   - Field: ‘lazy’
[08:29:07.264]   - Field: ‘state’
[08:29:07.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:07.264] - Launch lazy future ...
[08:29:07.265] Packages needed by the future expression (n = 0): <none>
[08:29:07.265] Packages needed by future strategies (n = 0): <none>
[08:29:07.265] {
[08:29:07.265]     {
[08:29:07.265]         {
[08:29:07.265]             ...future.startTime <- base::Sys.time()
[08:29:07.265]             {
[08:29:07.265]                 {
[08:29:07.265]                   {
[08:29:07.265]                     {
[08:29:07.265]                       base::local({
[08:29:07.265]                         has_future <- base::requireNamespace("future", 
[08:29:07.265]                           quietly = TRUE)
[08:29:07.265]                         if (has_future) {
[08:29:07.265]                           ns <- base::getNamespace("future")
[08:29:07.265]                           version <- ns[[".package"]][["version"]]
[08:29:07.265]                           if (is.null(version)) 
[08:29:07.265]                             version <- utils::packageVersion("future")
[08:29:07.265]                         }
[08:29:07.265]                         else {
[08:29:07.265]                           version <- NULL
[08:29:07.265]                         }
[08:29:07.265]                         if (!has_future || version < "1.8.0") {
[08:29:07.265]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:07.265]                             "", base::R.version$version.string), 
[08:29:07.265]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:07.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:07.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:07.265]                               "release", "version")], collapse = " "), 
[08:29:07.265]                             hostname = base::Sys.info()[["nodename"]])
[08:29:07.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:07.265]                             info)
[08:29:07.265]                           info <- base::paste(info, collapse = "; ")
[08:29:07.265]                           if (!has_future) {
[08:29:07.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:07.265]                               info)
[08:29:07.265]                           }
[08:29:07.265]                           else {
[08:29:07.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:07.265]                               info, version)
[08:29:07.265]                           }
[08:29:07.265]                           base::stop(msg)
[08:29:07.265]                         }
[08:29:07.265]                       })
[08:29:07.265]                     }
[08:29:07.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:07.265]                     base::options(mc.cores = 1L)
[08:29:07.265]                   }
[08:29:07.265]                   ...future.strategy.old <- future::plan("list")
[08:29:07.265]                   options(future.plan = NULL)
[08:29:07.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:07.265]                 }
[08:29:07.265]                 ...future.workdir <- getwd()
[08:29:07.265]             }
[08:29:07.265]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:07.265]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:07.265]         }
[08:29:07.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:07.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:07.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:07.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:07.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:07.265]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:07.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:07.265]             base::names(...future.oldOptions))
[08:29:07.265]     }
[08:29:07.265]     if (FALSE) {
[08:29:07.265]     }
[08:29:07.265]     else {
[08:29:07.265]         if (TRUE) {
[08:29:07.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:07.265]                 open = "w")
[08:29:07.265]         }
[08:29:07.265]         else {
[08:29:07.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:07.265]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:07.265]         }
[08:29:07.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:07.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:07.265]             base::sink(type = "output", split = FALSE)
[08:29:07.265]             base::close(...future.stdout)
[08:29:07.265]         }, add = TRUE)
[08:29:07.265]     }
[08:29:07.265]     ...future.frame <- base::sys.nframe()
[08:29:07.265]     ...future.conditions <- base::list()
[08:29:07.265]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:07.265]     if (FALSE) {
[08:29:07.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:07.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:07.265]     }
[08:29:07.265]     ...future.result <- base::tryCatch({
[08:29:07.265]         base::withCallingHandlers({
[08:29:07.265]             ...future.value <- base::withVisible(base::local({
[08:29:07.265]                 ...future.makeSendCondition <- base::local({
[08:29:07.265]                   sendCondition <- NULL
[08:29:07.265]                   function(frame = 1L) {
[08:29:07.265]                     if (is.function(sendCondition)) 
[08:29:07.265]                       return(sendCondition)
[08:29:07.265]                     ns <- getNamespace("parallel")
[08:29:07.265]                     if (exists("sendData", mode = "function", 
[08:29:07.265]                       envir = ns)) {
[08:29:07.265]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:07.265]                         envir = ns)
[08:29:07.265]                       envir <- sys.frame(frame)
[08:29:07.265]                       master <- NULL
[08:29:07.265]                       while (!identical(envir, .GlobalEnv) && 
[08:29:07.265]                         !identical(envir, emptyenv())) {
[08:29:07.265]                         if (exists("master", mode = "list", envir = envir, 
[08:29:07.265]                           inherits = FALSE)) {
[08:29:07.265]                           master <- get("master", mode = "list", 
[08:29:07.265]                             envir = envir, inherits = FALSE)
[08:29:07.265]                           if (inherits(master, c("SOCKnode", 
[08:29:07.265]                             "SOCK0node"))) {
[08:29:07.265]                             sendCondition <<- function(cond) {
[08:29:07.265]                               data <- list(type = "VALUE", value = cond, 
[08:29:07.265]                                 success = TRUE)
[08:29:07.265]                               parallel_sendData(master, data)
[08:29:07.265]                             }
[08:29:07.265]                             return(sendCondition)
[08:29:07.265]                           }
[08:29:07.265]                         }
[08:29:07.265]                         frame <- frame + 1L
[08:29:07.265]                         envir <- sys.frame(frame)
[08:29:07.265]                       }
[08:29:07.265]                     }
[08:29:07.265]                     sendCondition <<- function(cond) NULL
[08:29:07.265]                   }
[08:29:07.265]                 })
[08:29:07.265]                 withCallingHandlers({
[08:29:07.265]                   {
[08:29:07.265]                     Sys.sleep(0.5)
[08:29:07.265]                     list(a = 1, b = 42L)
[08:29:07.265]                   }
[08:29:07.265]                 }, immediateCondition = function(cond) {
[08:29:07.265]                   sendCondition <- ...future.makeSendCondition()
[08:29:07.265]                   sendCondition(cond)
[08:29:07.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.265]                   {
[08:29:07.265]                     inherits <- base::inherits
[08:29:07.265]                     invokeRestart <- base::invokeRestart
[08:29:07.265]                     is.null <- base::is.null
[08:29:07.265]                     muffled <- FALSE
[08:29:07.265]                     if (inherits(cond, "message")) {
[08:29:07.265]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:07.265]                       if (muffled) 
[08:29:07.265]                         invokeRestart("muffleMessage")
[08:29:07.265]                     }
[08:29:07.265]                     else if (inherits(cond, "warning")) {
[08:29:07.265]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:07.265]                       if (muffled) 
[08:29:07.265]                         invokeRestart("muffleWarning")
[08:29:07.265]                     }
[08:29:07.265]                     else if (inherits(cond, "condition")) {
[08:29:07.265]                       if (!is.null(pattern)) {
[08:29:07.265]                         computeRestarts <- base::computeRestarts
[08:29:07.265]                         grepl <- base::grepl
[08:29:07.265]                         restarts <- computeRestarts(cond)
[08:29:07.265]                         for (restart in restarts) {
[08:29:07.265]                           name <- restart$name
[08:29:07.265]                           if (is.null(name)) 
[08:29:07.265]                             next
[08:29:07.265]                           if (!grepl(pattern, name)) 
[08:29:07.265]                             next
[08:29:07.265]                           invokeRestart(restart)
[08:29:07.265]                           muffled <- TRUE
[08:29:07.265]                           break
[08:29:07.265]                         }
[08:29:07.265]                       }
[08:29:07.265]                     }
[08:29:07.265]                     invisible(muffled)
[08:29:07.265]                   }
[08:29:07.265]                   muffleCondition(cond)
[08:29:07.265]                 })
[08:29:07.265]             }))
[08:29:07.265]             future::FutureResult(value = ...future.value$value, 
[08:29:07.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.265]                   ...future.rng), globalenv = if (FALSE) 
[08:29:07.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:07.265]                     ...future.globalenv.names))
[08:29:07.265]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:07.265]         }, condition = base::local({
[08:29:07.265]             c <- base::c
[08:29:07.265]             inherits <- base::inherits
[08:29:07.265]             invokeRestart <- base::invokeRestart
[08:29:07.265]             length <- base::length
[08:29:07.265]             list <- base::list
[08:29:07.265]             seq.int <- base::seq.int
[08:29:07.265]             signalCondition <- base::signalCondition
[08:29:07.265]             sys.calls <- base::sys.calls
[08:29:07.265]             `[[` <- base::`[[`
[08:29:07.265]             `+` <- base::`+`
[08:29:07.265]             `<<-` <- base::`<<-`
[08:29:07.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:07.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:07.265]                   3L)]
[08:29:07.265]             }
[08:29:07.265]             function(cond) {
[08:29:07.265]                 is_error <- inherits(cond, "error")
[08:29:07.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:07.265]                   NULL)
[08:29:07.265]                 if (is_error) {
[08:29:07.265]                   sessionInformation <- function() {
[08:29:07.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:07.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:07.265]                       search = base::search(), system = base::Sys.info())
[08:29:07.265]                   }
[08:29:07.265]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:07.265]                     cond$call), session = sessionInformation(), 
[08:29:07.265]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:07.265]                   signalCondition(cond)
[08:29:07.265]                 }
[08:29:07.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:07.265]                 "immediateCondition"))) {
[08:29:07.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:07.265]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:07.265]                   if (TRUE && !signal) {
[08:29:07.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.265]                     {
[08:29:07.265]                       inherits <- base::inherits
[08:29:07.265]                       invokeRestart <- base::invokeRestart
[08:29:07.265]                       is.null <- base::is.null
[08:29:07.265]                       muffled <- FALSE
[08:29:07.265]                       if (inherits(cond, "message")) {
[08:29:07.265]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.265]                         if (muffled) 
[08:29:07.265]                           invokeRestart("muffleMessage")
[08:29:07.265]                       }
[08:29:07.265]                       else if (inherits(cond, "warning")) {
[08:29:07.265]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.265]                         if (muffled) 
[08:29:07.265]                           invokeRestart("muffleWarning")
[08:29:07.265]                       }
[08:29:07.265]                       else if (inherits(cond, "condition")) {
[08:29:07.265]                         if (!is.null(pattern)) {
[08:29:07.265]                           computeRestarts <- base::computeRestarts
[08:29:07.265]                           grepl <- base::grepl
[08:29:07.265]                           restarts <- computeRestarts(cond)
[08:29:07.265]                           for (restart in restarts) {
[08:29:07.265]                             name <- restart$name
[08:29:07.265]                             if (is.null(name)) 
[08:29:07.265]                               next
[08:29:07.265]                             if (!grepl(pattern, name)) 
[08:29:07.265]                               next
[08:29:07.265]                             invokeRestart(restart)
[08:29:07.265]                             muffled <- TRUE
[08:29:07.265]                             break
[08:29:07.265]                           }
[08:29:07.265]                         }
[08:29:07.265]                       }
[08:29:07.265]                       invisible(muffled)
[08:29:07.265]                     }
[08:29:07.265]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.265]                   }
[08:29:07.265]                 }
[08:29:07.265]                 else {
[08:29:07.265]                   if (TRUE) {
[08:29:07.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.265]                     {
[08:29:07.265]                       inherits <- base::inherits
[08:29:07.265]                       invokeRestart <- base::invokeRestart
[08:29:07.265]                       is.null <- base::is.null
[08:29:07.265]                       muffled <- FALSE
[08:29:07.265]                       if (inherits(cond, "message")) {
[08:29:07.265]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.265]                         if (muffled) 
[08:29:07.265]                           invokeRestart("muffleMessage")
[08:29:07.265]                       }
[08:29:07.265]                       else if (inherits(cond, "warning")) {
[08:29:07.265]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.265]                         if (muffled) 
[08:29:07.265]                           invokeRestart("muffleWarning")
[08:29:07.265]                       }
[08:29:07.265]                       else if (inherits(cond, "condition")) {
[08:29:07.265]                         if (!is.null(pattern)) {
[08:29:07.265]                           computeRestarts <- base::computeRestarts
[08:29:07.265]                           grepl <- base::grepl
[08:29:07.265]                           restarts <- computeRestarts(cond)
[08:29:07.265]                           for (restart in restarts) {
[08:29:07.265]                             name <- restart$name
[08:29:07.265]                             if (is.null(name)) 
[08:29:07.265]                               next
[08:29:07.265]                             if (!grepl(pattern, name)) 
[08:29:07.265]                               next
[08:29:07.265]                             invokeRestart(restart)
[08:29:07.265]                             muffled <- TRUE
[08:29:07.265]                             break
[08:29:07.265]                           }
[08:29:07.265]                         }
[08:29:07.265]                       }
[08:29:07.265]                       invisible(muffled)
[08:29:07.265]                     }
[08:29:07.265]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.265]                   }
[08:29:07.265]                 }
[08:29:07.265]             }
[08:29:07.265]         }))
[08:29:07.265]     }, error = function(ex) {
[08:29:07.265]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:07.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.265]                 ...future.rng), started = ...future.startTime, 
[08:29:07.265]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:07.265]             version = "1.8"), class = "FutureResult")
[08:29:07.265]     }, finally = {
[08:29:07.265]         if (!identical(...future.workdir, getwd())) 
[08:29:07.265]             setwd(...future.workdir)
[08:29:07.265]         {
[08:29:07.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:07.265]                 ...future.oldOptions$nwarnings <- NULL
[08:29:07.265]             }
[08:29:07.265]             base::options(...future.oldOptions)
[08:29:07.265]             if (.Platform$OS.type == "windows") {
[08:29:07.265]                 old_names <- names(...future.oldEnvVars)
[08:29:07.265]                 envs <- base::Sys.getenv()
[08:29:07.265]                 names <- names(envs)
[08:29:07.265]                 common <- intersect(names, old_names)
[08:29:07.265]                 added <- setdiff(names, old_names)
[08:29:07.265]                 removed <- setdiff(old_names, names)
[08:29:07.265]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:07.265]                   envs[common]]
[08:29:07.265]                 NAMES <- toupper(changed)
[08:29:07.265]                 args <- list()
[08:29:07.265]                 for (kk in seq_along(NAMES)) {
[08:29:07.265]                   name <- changed[[kk]]
[08:29:07.265]                   NAME <- NAMES[[kk]]
[08:29:07.265]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.265]                     next
[08:29:07.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.265]                 }
[08:29:07.265]                 NAMES <- toupper(added)
[08:29:07.265]                 for (kk in seq_along(NAMES)) {
[08:29:07.265]                   name <- added[[kk]]
[08:29:07.265]                   NAME <- NAMES[[kk]]
[08:29:07.265]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.265]                     next
[08:29:07.265]                   args[[name]] <- ""
[08:29:07.265]                 }
[08:29:07.265]                 NAMES <- toupper(removed)
[08:29:07.265]                 for (kk in seq_along(NAMES)) {
[08:29:07.265]                   name <- removed[[kk]]
[08:29:07.265]                   NAME <- NAMES[[kk]]
[08:29:07.265]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.265]                     next
[08:29:07.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.265]                 }
[08:29:07.265]                 if (length(args) > 0) 
[08:29:07.265]                   base::do.call(base::Sys.setenv, args = args)
[08:29:07.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:07.265]             }
[08:29:07.265]             else {
[08:29:07.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:07.265]             }
[08:29:07.265]             {
[08:29:07.265]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:07.265]                   0L) {
[08:29:07.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:07.265]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:07.265]                   base::options(opts)
[08:29:07.265]                 }
[08:29:07.265]                 {
[08:29:07.265]                   {
[08:29:07.265]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:07.265]                     NULL
[08:29:07.265]                   }
[08:29:07.265]                   options(future.plan = NULL)
[08:29:07.265]                   if (is.na(NA_character_)) 
[08:29:07.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:07.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:07.265]                     .init = FALSE)
[08:29:07.265]                 }
[08:29:07.265]             }
[08:29:07.265]         }
[08:29:07.265]     })
[08:29:07.265]     if (TRUE) {
[08:29:07.265]         base::sink(type = "output", split = FALSE)
[08:29:07.265]         if (TRUE) {
[08:29:07.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:07.265]         }
[08:29:07.265]         else {
[08:29:07.265]             ...future.result["stdout"] <- base::list(NULL)
[08:29:07.265]         }
[08:29:07.265]         base::close(...future.stdout)
[08:29:07.265]         ...future.stdout <- NULL
[08:29:07.265]     }
[08:29:07.265]     ...future.result$conditions <- ...future.conditions
[08:29:07.265]     ...future.result$finished <- base::Sys.time()
[08:29:07.265]     ...future.result
[08:29:07.265] }
[08:29:07.267] Poll #1 (0): usedNodes() = 2, workers = 2
[08:29:07.289] receiveMessageFromWorker() for ClusterFuture ...
[08:29:07.289] - Validating connection of MultisessionFuture
[08:29:07.289] - received message: FutureResult
[08:29:07.289] - Received FutureResult
[08:29:07.290] - Erased future from FutureRegistry
[08:29:07.290] result() for ClusterFuture ...
[08:29:07.290] - result already collected: FutureResult
[08:29:07.290] result() for ClusterFuture ... done
[08:29:07.290] signalConditions() ...
[08:29:07.290]  - include = ‘immediateCondition’
[08:29:07.290]  - exclude = 
[08:29:07.290]  - resignal = FALSE
[08:29:07.290]  - Number of conditions: 1
[08:29:07.290] signalConditions() ... done
[08:29:07.290] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:07.291] result() for ClusterFuture ...
[08:29:07.291] - result already collected: FutureResult
[08:29:07.291] result() for ClusterFuture ... done
[08:29:07.291] result() for ClusterFuture ...
[08:29:07.291] - result already collected: FutureResult
[08:29:07.291] result() for ClusterFuture ... done
[08:29:07.291] signalConditions() ...
[08:29:07.291]  - include = ‘immediateCondition’
[08:29:07.291]  - exclude = 
[08:29:07.291]  - resignal = FALSE
[08:29:07.291]  - Number of conditions: 1
[08:29:07.291] signalConditions() ... done
[08:29:07.292] MultisessionFuture started
[08:29:07.292] - Launch lazy future ... done
[08:29:07.293] run() for ‘MultisessionFuture’ ... done
[08:29:07.849] receiveMessageFromWorker() for ClusterFuture ...
[08:29:07.849] - Validating connection of MultisessionFuture
[08:29:07.849] - received message: FutureResult
[08:29:07.849] - Received FutureResult
[08:29:07.849] - Erased future from FutureRegistry
[08:29:07.850] result() for ClusterFuture ...
[08:29:07.850] - result already collected: FutureResult
[08:29:07.850] result() for ClusterFuture ... done
[08:29:07.850] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:07.850] A MultisessionFuture was resolved (result was not collected)
[08:29:07.850] getGlobalsAndPackages() ...
[08:29:07.850] Searching for globals...
[08:29:07.851] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:07.851] Searching for globals ... DONE
[08:29:07.851] Resolving globals: FALSE
[08:29:07.852] 
[08:29:07.852] 
[08:29:07.852] getGlobalsAndPackages() ... DONE
[08:29:07.852] run() for ‘Future’ ...
[08:29:07.852] - state: ‘created’
[08:29:07.852] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:07.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:07.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:07.866]   - Field: ‘node’
[08:29:07.867]   - Field: ‘label’
[08:29:07.867]   - Field: ‘local’
[08:29:07.867]   - Field: ‘owner’
[08:29:07.867]   - Field: ‘envir’
[08:29:07.867]   - Field: ‘workers’
[08:29:07.867]   - Field: ‘packages’
[08:29:07.867]   - Field: ‘gc’
[08:29:07.867]   - Field: ‘conditions’
[08:29:07.867]   - Field: ‘persistent’
[08:29:07.867]   - Field: ‘expr’
[08:29:07.867]   - Field: ‘uuid’
[08:29:07.868]   - Field: ‘seed’
[08:29:07.868]   - Field: ‘version’
[08:29:07.868]   - Field: ‘result’
[08:29:07.868]   - Field: ‘asynchronous’
[08:29:07.868]   - Field: ‘calls’
[08:29:07.868]   - Field: ‘globals’
[08:29:07.868]   - Field: ‘stdout’
[08:29:07.868]   - Field: ‘earlySignal’
[08:29:07.868]   - Field: ‘lazy’
[08:29:07.868]   - Field: ‘state’
[08:29:07.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:07.868] - Launch lazy future ...
[08:29:07.869] Packages needed by the future expression (n = 0): <none>
[08:29:07.869] Packages needed by future strategies (n = 0): <none>
[08:29:07.869] {
[08:29:07.869]     {
[08:29:07.869]         {
[08:29:07.869]             ...future.startTime <- base::Sys.time()
[08:29:07.869]             {
[08:29:07.869]                 {
[08:29:07.869]                   {
[08:29:07.869]                     {
[08:29:07.869]                       base::local({
[08:29:07.869]                         has_future <- base::requireNamespace("future", 
[08:29:07.869]                           quietly = TRUE)
[08:29:07.869]                         if (has_future) {
[08:29:07.869]                           ns <- base::getNamespace("future")
[08:29:07.869]                           version <- ns[[".package"]][["version"]]
[08:29:07.869]                           if (is.null(version)) 
[08:29:07.869]                             version <- utils::packageVersion("future")
[08:29:07.869]                         }
[08:29:07.869]                         else {
[08:29:07.869]                           version <- NULL
[08:29:07.869]                         }
[08:29:07.869]                         if (!has_future || version < "1.8.0") {
[08:29:07.869]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:07.869]                             "", base::R.version$version.string), 
[08:29:07.869]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:07.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:07.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:07.869]                               "release", "version")], collapse = " "), 
[08:29:07.869]                             hostname = base::Sys.info()[["nodename"]])
[08:29:07.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:07.869]                             info)
[08:29:07.869]                           info <- base::paste(info, collapse = "; ")
[08:29:07.869]                           if (!has_future) {
[08:29:07.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:07.869]                               info)
[08:29:07.869]                           }
[08:29:07.869]                           else {
[08:29:07.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:07.869]                               info, version)
[08:29:07.869]                           }
[08:29:07.869]                           base::stop(msg)
[08:29:07.869]                         }
[08:29:07.869]                       })
[08:29:07.869]                     }
[08:29:07.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:07.869]                     base::options(mc.cores = 1L)
[08:29:07.869]                   }
[08:29:07.869]                   ...future.strategy.old <- future::plan("list")
[08:29:07.869]                   options(future.plan = NULL)
[08:29:07.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:07.869]                 }
[08:29:07.869]                 ...future.workdir <- getwd()
[08:29:07.869]             }
[08:29:07.869]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:07.869]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:07.869]         }
[08:29:07.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:07.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:07.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:07.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:07.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:07.869]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:07.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:07.869]             base::names(...future.oldOptions))
[08:29:07.869]     }
[08:29:07.869]     if (FALSE) {
[08:29:07.869]     }
[08:29:07.869]     else {
[08:29:07.869]         if (TRUE) {
[08:29:07.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:07.869]                 open = "w")
[08:29:07.869]         }
[08:29:07.869]         else {
[08:29:07.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:07.869]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:07.869]         }
[08:29:07.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:07.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:07.869]             base::sink(type = "output", split = FALSE)
[08:29:07.869]             base::close(...future.stdout)
[08:29:07.869]         }, add = TRUE)
[08:29:07.869]     }
[08:29:07.869]     ...future.frame <- base::sys.nframe()
[08:29:07.869]     ...future.conditions <- base::list()
[08:29:07.869]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:07.869]     if (FALSE) {
[08:29:07.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:07.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:07.869]     }
[08:29:07.869]     ...future.result <- base::tryCatch({
[08:29:07.869]         base::withCallingHandlers({
[08:29:07.869]             ...future.value <- base::withVisible(base::local({
[08:29:07.869]                 ...future.makeSendCondition <- base::local({
[08:29:07.869]                   sendCondition <- NULL
[08:29:07.869]                   function(frame = 1L) {
[08:29:07.869]                     if (is.function(sendCondition)) 
[08:29:07.869]                       return(sendCondition)
[08:29:07.869]                     ns <- getNamespace("parallel")
[08:29:07.869]                     if (exists("sendData", mode = "function", 
[08:29:07.869]                       envir = ns)) {
[08:29:07.869]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:07.869]                         envir = ns)
[08:29:07.869]                       envir <- sys.frame(frame)
[08:29:07.869]                       master <- NULL
[08:29:07.869]                       while (!identical(envir, .GlobalEnv) && 
[08:29:07.869]                         !identical(envir, emptyenv())) {
[08:29:07.869]                         if (exists("master", mode = "list", envir = envir, 
[08:29:07.869]                           inherits = FALSE)) {
[08:29:07.869]                           master <- get("master", mode = "list", 
[08:29:07.869]                             envir = envir, inherits = FALSE)
[08:29:07.869]                           if (inherits(master, c("SOCKnode", 
[08:29:07.869]                             "SOCK0node"))) {
[08:29:07.869]                             sendCondition <<- function(cond) {
[08:29:07.869]                               data <- list(type = "VALUE", value = cond, 
[08:29:07.869]                                 success = TRUE)
[08:29:07.869]                               parallel_sendData(master, data)
[08:29:07.869]                             }
[08:29:07.869]                             return(sendCondition)
[08:29:07.869]                           }
[08:29:07.869]                         }
[08:29:07.869]                         frame <- frame + 1L
[08:29:07.869]                         envir <- sys.frame(frame)
[08:29:07.869]                       }
[08:29:07.869]                     }
[08:29:07.869]                     sendCondition <<- function(cond) NULL
[08:29:07.869]                   }
[08:29:07.869]                 })
[08:29:07.869]                 withCallingHandlers({
[08:29:07.869]                   {
[08:29:07.869]                     Sys.sleep(0.5)
[08:29:07.869]                     list(a = 1, b = 42L)
[08:29:07.869]                   }
[08:29:07.869]                 }, immediateCondition = function(cond) {
[08:29:07.869]                   sendCondition <- ...future.makeSendCondition()
[08:29:07.869]                   sendCondition(cond)
[08:29:07.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.869]                   {
[08:29:07.869]                     inherits <- base::inherits
[08:29:07.869]                     invokeRestart <- base::invokeRestart
[08:29:07.869]                     is.null <- base::is.null
[08:29:07.869]                     muffled <- FALSE
[08:29:07.869]                     if (inherits(cond, "message")) {
[08:29:07.869]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:07.869]                       if (muffled) 
[08:29:07.869]                         invokeRestart("muffleMessage")
[08:29:07.869]                     }
[08:29:07.869]                     else if (inherits(cond, "warning")) {
[08:29:07.869]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:07.869]                       if (muffled) 
[08:29:07.869]                         invokeRestart("muffleWarning")
[08:29:07.869]                     }
[08:29:07.869]                     else if (inherits(cond, "condition")) {
[08:29:07.869]                       if (!is.null(pattern)) {
[08:29:07.869]                         computeRestarts <- base::computeRestarts
[08:29:07.869]                         grepl <- base::grepl
[08:29:07.869]                         restarts <- computeRestarts(cond)
[08:29:07.869]                         for (restart in restarts) {
[08:29:07.869]                           name <- restart$name
[08:29:07.869]                           if (is.null(name)) 
[08:29:07.869]                             next
[08:29:07.869]                           if (!grepl(pattern, name)) 
[08:29:07.869]                             next
[08:29:07.869]                           invokeRestart(restart)
[08:29:07.869]                           muffled <- TRUE
[08:29:07.869]                           break
[08:29:07.869]                         }
[08:29:07.869]                       }
[08:29:07.869]                     }
[08:29:07.869]                     invisible(muffled)
[08:29:07.869]                   }
[08:29:07.869]                   muffleCondition(cond)
[08:29:07.869]                 })
[08:29:07.869]             }))
[08:29:07.869]             future::FutureResult(value = ...future.value$value, 
[08:29:07.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.869]                   ...future.rng), globalenv = if (FALSE) 
[08:29:07.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:07.869]                     ...future.globalenv.names))
[08:29:07.869]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:07.869]         }, condition = base::local({
[08:29:07.869]             c <- base::c
[08:29:07.869]             inherits <- base::inherits
[08:29:07.869]             invokeRestart <- base::invokeRestart
[08:29:07.869]             length <- base::length
[08:29:07.869]             list <- base::list
[08:29:07.869]             seq.int <- base::seq.int
[08:29:07.869]             signalCondition <- base::signalCondition
[08:29:07.869]             sys.calls <- base::sys.calls
[08:29:07.869]             `[[` <- base::`[[`
[08:29:07.869]             `+` <- base::`+`
[08:29:07.869]             `<<-` <- base::`<<-`
[08:29:07.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:07.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:07.869]                   3L)]
[08:29:07.869]             }
[08:29:07.869]             function(cond) {
[08:29:07.869]                 is_error <- inherits(cond, "error")
[08:29:07.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:07.869]                   NULL)
[08:29:07.869]                 if (is_error) {
[08:29:07.869]                   sessionInformation <- function() {
[08:29:07.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:07.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:07.869]                       search = base::search(), system = base::Sys.info())
[08:29:07.869]                   }
[08:29:07.869]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:07.869]                     cond$call), session = sessionInformation(), 
[08:29:07.869]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:07.869]                   signalCondition(cond)
[08:29:07.869]                 }
[08:29:07.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:07.869]                 "immediateCondition"))) {
[08:29:07.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:07.869]                   ...future.conditions[[length(...future.conditions) + 
[08:29:07.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:07.869]                   if (TRUE && !signal) {
[08:29:07.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.869]                     {
[08:29:07.869]                       inherits <- base::inherits
[08:29:07.869]                       invokeRestart <- base::invokeRestart
[08:29:07.869]                       is.null <- base::is.null
[08:29:07.869]                       muffled <- FALSE
[08:29:07.869]                       if (inherits(cond, "message")) {
[08:29:07.869]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.869]                         if (muffled) 
[08:29:07.869]                           invokeRestart("muffleMessage")
[08:29:07.869]                       }
[08:29:07.869]                       else if (inherits(cond, "warning")) {
[08:29:07.869]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.869]                         if (muffled) 
[08:29:07.869]                           invokeRestart("muffleWarning")
[08:29:07.869]                       }
[08:29:07.869]                       else if (inherits(cond, "condition")) {
[08:29:07.869]                         if (!is.null(pattern)) {
[08:29:07.869]                           computeRestarts <- base::computeRestarts
[08:29:07.869]                           grepl <- base::grepl
[08:29:07.869]                           restarts <- computeRestarts(cond)
[08:29:07.869]                           for (restart in restarts) {
[08:29:07.869]                             name <- restart$name
[08:29:07.869]                             if (is.null(name)) 
[08:29:07.869]                               next
[08:29:07.869]                             if (!grepl(pattern, name)) 
[08:29:07.869]                               next
[08:29:07.869]                             invokeRestart(restart)
[08:29:07.869]                             muffled <- TRUE
[08:29:07.869]                             break
[08:29:07.869]                           }
[08:29:07.869]                         }
[08:29:07.869]                       }
[08:29:07.869]                       invisible(muffled)
[08:29:07.869]                     }
[08:29:07.869]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.869]                   }
[08:29:07.869]                 }
[08:29:07.869]                 else {
[08:29:07.869]                   if (TRUE) {
[08:29:07.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:07.869]                     {
[08:29:07.869]                       inherits <- base::inherits
[08:29:07.869]                       invokeRestart <- base::invokeRestart
[08:29:07.869]                       is.null <- base::is.null
[08:29:07.869]                       muffled <- FALSE
[08:29:07.869]                       if (inherits(cond, "message")) {
[08:29:07.869]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:07.869]                         if (muffled) 
[08:29:07.869]                           invokeRestart("muffleMessage")
[08:29:07.869]                       }
[08:29:07.869]                       else if (inherits(cond, "warning")) {
[08:29:07.869]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:07.869]                         if (muffled) 
[08:29:07.869]                           invokeRestart("muffleWarning")
[08:29:07.869]                       }
[08:29:07.869]                       else if (inherits(cond, "condition")) {
[08:29:07.869]                         if (!is.null(pattern)) {
[08:29:07.869]                           computeRestarts <- base::computeRestarts
[08:29:07.869]                           grepl <- base::grepl
[08:29:07.869]                           restarts <- computeRestarts(cond)
[08:29:07.869]                           for (restart in restarts) {
[08:29:07.869]                             name <- restart$name
[08:29:07.869]                             if (is.null(name)) 
[08:29:07.869]                               next
[08:29:07.869]                             if (!grepl(pattern, name)) 
[08:29:07.869]                               next
[08:29:07.869]                             invokeRestart(restart)
[08:29:07.869]                             muffled <- TRUE
[08:29:07.869]                             break
[08:29:07.869]                           }
[08:29:07.869]                         }
[08:29:07.869]                       }
[08:29:07.869]                       invisible(muffled)
[08:29:07.869]                     }
[08:29:07.869]                     muffleCondition(cond, pattern = "^muffle")
[08:29:07.869]                   }
[08:29:07.869]                 }
[08:29:07.869]             }
[08:29:07.869]         }))
[08:29:07.869]     }, error = function(ex) {
[08:29:07.869]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:07.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:07.869]                 ...future.rng), started = ...future.startTime, 
[08:29:07.869]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:07.869]             version = "1.8"), class = "FutureResult")
[08:29:07.869]     }, finally = {
[08:29:07.869]         if (!identical(...future.workdir, getwd())) 
[08:29:07.869]             setwd(...future.workdir)
[08:29:07.869]         {
[08:29:07.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:07.869]                 ...future.oldOptions$nwarnings <- NULL
[08:29:07.869]             }
[08:29:07.869]             base::options(...future.oldOptions)
[08:29:07.869]             if (.Platform$OS.type == "windows") {
[08:29:07.869]                 old_names <- names(...future.oldEnvVars)
[08:29:07.869]                 envs <- base::Sys.getenv()
[08:29:07.869]                 names <- names(envs)
[08:29:07.869]                 common <- intersect(names, old_names)
[08:29:07.869]                 added <- setdiff(names, old_names)
[08:29:07.869]                 removed <- setdiff(old_names, names)
[08:29:07.869]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:07.869]                   envs[common]]
[08:29:07.869]                 NAMES <- toupper(changed)
[08:29:07.869]                 args <- list()
[08:29:07.869]                 for (kk in seq_along(NAMES)) {
[08:29:07.869]                   name <- changed[[kk]]
[08:29:07.869]                   NAME <- NAMES[[kk]]
[08:29:07.869]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.869]                     next
[08:29:07.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.869]                 }
[08:29:07.869]                 NAMES <- toupper(added)
[08:29:07.869]                 for (kk in seq_along(NAMES)) {
[08:29:07.869]                   name <- added[[kk]]
[08:29:07.869]                   NAME <- NAMES[[kk]]
[08:29:07.869]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.869]                     next
[08:29:07.869]                   args[[name]] <- ""
[08:29:07.869]                 }
[08:29:07.869]                 NAMES <- toupper(removed)
[08:29:07.869]                 for (kk in seq_along(NAMES)) {
[08:29:07.869]                   name <- removed[[kk]]
[08:29:07.869]                   NAME <- NAMES[[kk]]
[08:29:07.869]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:07.869]                     next
[08:29:07.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:07.869]                 }
[08:29:07.869]                 if (length(args) > 0) 
[08:29:07.869]                   base::do.call(base::Sys.setenv, args = args)
[08:29:07.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:07.869]             }
[08:29:07.869]             else {
[08:29:07.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:07.869]             }
[08:29:07.869]             {
[08:29:07.869]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:07.869]                   0L) {
[08:29:07.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:07.869]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:07.869]                   base::options(opts)
[08:29:07.869]                 }
[08:29:07.869]                 {
[08:29:07.869]                   {
[08:29:07.869]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:07.869]                     NULL
[08:29:07.869]                   }
[08:29:07.869]                   options(future.plan = NULL)
[08:29:07.869]                   if (is.na(NA_character_)) 
[08:29:07.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:07.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:07.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:07.869]                     .init = FALSE)
[08:29:07.869]                 }
[08:29:07.869]             }
[08:29:07.869]         }
[08:29:07.869]     })
[08:29:07.869]     if (TRUE) {
[08:29:07.869]         base::sink(type = "output", split = FALSE)
[08:29:07.869]         if (TRUE) {
[08:29:07.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:07.869]         }
[08:29:07.869]         else {
[08:29:07.869]             ...future.result["stdout"] <- base::list(NULL)
[08:29:07.869]         }
[08:29:07.869]         base::close(...future.stdout)
[08:29:07.869]         ...future.stdout <- NULL
[08:29:07.869]     }
[08:29:07.869]     ...future.result$conditions <- ...future.conditions
[08:29:07.869]     ...future.result$finished <- base::Sys.time()
[08:29:07.869]     ...future.result
[08:29:07.869] }
[08:29:07.872] MultisessionFuture started
[08:29:07.872] - Launch lazy future ... done
[08:29:07.872] run() for ‘MultisessionFuture’ ... done
[08:29:08.415] receiveMessageFromWorker() for ClusterFuture ...
[08:29:08.415] - Validating connection of MultisessionFuture
[08:29:08.415] - received message: FutureResult
[08:29:08.416] - Received FutureResult
[08:29:08.416] - Erased future from FutureRegistry
[08:29:08.416] result() for ClusterFuture ...
[08:29:08.416] - result already collected: FutureResult
[08:29:08.416] result() for ClusterFuture ... done
[08:29:08.416] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:08.416] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[08:29:08.416] getGlobalsAndPackages() ...
[08:29:08.416] Searching for globals...
[08:29:08.417] - globals found: [2] ‘list’, ‘stop’
[08:29:08.417] Searching for globals ... DONE
[08:29:08.417] Resolving globals: FALSE
[08:29:08.418] 
[08:29:08.418] 
[08:29:08.418] getGlobalsAndPackages() ... DONE
[08:29:08.418] run() for ‘Future’ ...
[08:29:08.418] - state: ‘created’
[08:29:08.418] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:08.432] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:08.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:08.432]   - Field: ‘node’
[08:29:08.432]   - Field: ‘label’
[08:29:08.432]   - Field: ‘local’
[08:29:08.433]   - Field: ‘owner’
[08:29:08.433]   - Field: ‘envir’
[08:29:08.433]   - Field: ‘workers’
[08:29:08.433]   - Field: ‘packages’
[08:29:08.433]   - Field: ‘gc’
[08:29:08.433]   - Field: ‘conditions’
[08:29:08.433]   - Field: ‘persistent’
[08:29:08.433]   - Field: ‘expr’
[08:29:08.433]   - Field: ‘uuid’
[08:29:08.433]   - Field: ‘seed’
[08:29:08.433]   - Field: ‘version’
[08:29:08.433]   - Field: ‘result’
[08:29:08.434]   - Field: ‘asynchronous’
[08:29:08.434]   - Field: ‘calls’
[08:29:08.434]   - Field: ‘globals’
[08:29:08.434]   - Field: ‘stdout’
[08:29:08.434]   - Field: ‘earlySignal’
[08:29:08.434]   - Field: ‘lazy’
[08:29:08.434]   - Field: ‘state’
[08:29:08.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:08.434] - Launch lazy future ...
[08:29:08.434] Packages needed by the future expression (n = 0): <none>
[08:29:08.435] Packages needed by future strategies (n = 0): <none>
[08:29:08.435] {
[08:29:08.435]     {
[08:29:08.435]         {
[08:29:08.435]             ...future.startTime <- base::Sys.time()
[08:29:08.435]             {
[08:29:08.435]                 {
[08:29:08.435]                   {
[08:29:08.435]                     {
[08:29:08.435]                       base::local({
[08:29:08.435]                         has_future <- base::requireNamespace("future", 
[08:29:08.435]                           quietly = TRUE)
[08:29:08.435]                         if (has_future) {
[08:29:08.435]                           ns <- base::getNamespace("future")
[08:29:08.435]                           version <- ns[[".package"]][["version"]]
[08:29:08.435]                           if (is.null(version)) 
[08:29:08.435]                             version <- utils::packageVersion("future")
[08:29:08.435]                         }
[08:29:08.435]                         else {
[08:29:08.435]                           version <- NULL
[08:29:08.435]                         }
[08:29:08.435]                         if (!has_future || version < "1.8.0") {
[08:29:08.435]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:08.435]                             "", base::R.version$version.string), 
[08:29:08.435]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:08.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:08.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:08.435]                               "release", "version")], collapse = " "), 
[08:29:08.435]                             hostname = base::Sys.info()[["nodename"]])
[08:29:08.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:08.435]                             info)
[08:29:08.435]                           info <- base::paste(info, collapse = "; ")
[08:29:08.435]                           if (!has_future) {
[08:29:08.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:08.435]                               info)
[08:29:08.435]                           }
[08:29:08.435]                           else {
[08:29:08.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:08.435]                               info, version)
[08:29:08.435]                           }
[08:29:08.435]                           base::stop(msg)
[08:29:08.435]                         }
[08:29:08.435]                       })
[08:29:08.435]                     }
[08:29:08.435]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:08.435]                     base::options(mc.cores = 1L)
[08:29:08.435]                   }
[08:29:08.435]                   ...future.strategy.old <- future::plan("list")
[08:29:08.435]                   options(future.plan = NULL)
[08:29:08.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:08.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:08.435]                 }
[08:29:08.435]                 ...future.workdir <- getwd()
[08:29:08.435]             }
[08:29:08.435]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:08.435]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:08.435]         }
[08:29:08.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:08.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:08.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:08.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:08.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:08.435]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:08.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:08.435]             base::names(...future.oldOptions))
[08:29:08.435]     }
[08:29:08.435]     if (FALSE) {
[08:29:08.435]     }
[08:29:08.435]     else {
[08:29:08.435]         if (TRUE) {
[08:29:08.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:08.435]                 open = "w")
[08:29:08.435]         }
[08:29:08.435]         else {
[08:29:08.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:08.435]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:08.435]         }
[08:29:08.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:08.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:08.435]             base::sink(type = "output", split = FALSE)
[08:29:08.435]             base::close(...future.stdout)
[08:29:08.435]         }, add = TRUE)
[08:29:08.435]     }
[08:29:08.435]     ...future.frame <- base::sys.nframe()
[08:29:08.435]     ...future.conditions <- base::list()
[08:29:08.435]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:08.435]     if (FALSE) {
[08:29:08.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:08.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:08.435]     }
[08:29:08.435]     ...future.result <- base::tryCatch({
[08:29:08.435]         base::withCallingHandlers({
[08:29:08.435]             ...future.value <- base::withVisible(base::local({
[08:29:08.435]                 ...future.makeSendCondition <- base::local({
[08:29:08.435]                   sendCondition <- NULL
[08:29:08.435]                   function(frame = 1L) {
[08:29:08.435]                     if (is.function(sendCondition)) 
[08:29:08.435]                       return(sendCondition)
[08:29:08.435]                     ns <- getNamespace("parallel")
[08:29:08.435]                     if (exists("sendData", mode = "function", 
[08:29:08.435]                       envir = ns)) {
[08:29:08.435]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:08.435]                         envir = ns)
[08:29:08.435]                       envir <- sys.frame(frame)
[08:29:08.435]                       master <- NULL
[08:29:08.435]                       while (!identical(envir, .GlobalEnv) && 
[08:29:08.435]                         !identical(envir, emptyenv())) {
[08:29:08.435]                         if (exists("master", mode = "list", envir = envir, 
[08:29:08.435]                           inherits = FALSE)) {
[08:29:08.435]                           master <- get("master", mode = "list", 
[08:29:08.435]                             envir = envir, inherits = FALSE)
[08:29:08.435]                           if (inherits(master, c("SOCKnode", 
[08:29:08.435]                             "SOCK0node"))) {
[08:29:08.435]                             sendCondition <<- function(cond) {
[08:29:08.435]                               data <- list(type = "VALUE", value = cond, 
[08:29:08.435]                                 success = TRUE)
[08:29:08.435]                               parallel_sendData(master, data)
[08:29:08.435]                             }
[08:29:08.435]                             return(sendCondition)
[08:29:08.435]                           }
[08:29:08.435]                         }
[08:29:08.435]                         frame <- frame + 1L
[08:29:08.435]                         envir <- sys.frame(frame)
[08:29:08.435]                       }
[08:29:08.435]                     }
[08:29:08.435]                     sendCondition <<- function(cond) NULL
[08:29:08.435]                   }
[08:29:08.435]                 })
[08:29:08.435]                 withCallingHandlers({
[08:29:08.435]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:08.435]                 }, immediateCondition = function(cond) {
[08:29:08.435]                   sendCondition <- ...future.makeSendCondition()
[08:29:08.435]                   sendCondition(cond)
[08:29:08.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:08.435]                   {
[08:29:08.435]                     inherits <- base::inherits
[08:29:08.435]                     invokeRestart <- base::invokeRestart
[08:29:08.435]                     is.null <- base::is.null
[08:29:08.435]                     muffled <- FALSE
[08:29:08.435]                     if (inherits(cond, "message")) {
[08:29:08.435]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:08.435]                       if (muffled) 
[08:29:08.435]                         invokeRestart("muffleMessage")
[08:29:08.435]                     }
[08:29:08.435]                     else if (inherits(cond, "warning")) {
[08:29:08.435]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:08.435]                       if (muffled) 
[08:29:08.435]                         invokeRestart("muffleWarning")
[08:29:08.435]                     }
[08:29:08.435]                     else if (inherits(cond, "condition")) {
[08:29:08.435]                       if (!is.null(pattern)) {
[08:29:08.435]                         computeRestarts <- base::computeRestarts
[08:29:08.435]                         grepl <- base::grepl
[08:29:08.435]                         restarts <- computeRestarts(cond)
[08:29:08.435]                         for (restart in restarts) {
[08:29:08.435]                           name <- restart$name
[08:29:08.435]                           if (is.null(name)) 
[08:29:08.435]                             next
[08:29:08.435]                           if (!grepl(pattern, name)) 
[08:29:08.435]                             next
[08:29:08.435]                           invokeRestart(restart)
[08:29:08.435]                           muffled <- TRUE
[08:29:08.435]                           break
[08:29:08.435]                         }
[08:29:08.435]                       }
[08:29:08.435]                     }
[08:29:08.435]                     invisible(muffled)
[08:29:08.435]                   }
[08:29:08.435]                   muffleCondition(cond)
[08:29:08.435]                 })
[08:29:08.435]             }))
[08:29:08.435]             future::FutureResult(value = ...future.value$value, 
[08:29:08.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:08.435]                   ...future.rng), globalenv = if (FALSE) 
[08:29:08.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:08.435]                     ...future.globalenv.names))
[08:29:08.435]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:08.435]         }, condition = base::local({
[08:29:08.435]             c <- base::c
[08:29:08.435]             inherits <- base::inherits
[08:29:08.435]             invokeRestart <- base::invokeRestart
[08:29:08.435]             length <- base::length
[08:29:08.435]             list <- base::list
[08:29:08.435]             seq.int <- base::seq.int
[08:29:08.435]             signalCondition <- base::signalCondition
[08:29:08.435]             sys.calls <- base::sys.calls
[08:29:08.435]             `[[` <- base::`[[`
[08:29:08.435]             `+` <- base::`+`
[08:29:08.435]             `<<-` <- base::`<<-`
[08:29:08.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:08.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:08.435]                   3L)]
[08:29:08.435]             }
[08:29:08.435]             function(cond) {
[08:29:08.435]                 is_error <- inherits(cond, "error")
[08:29:08.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:08.435]                   NULL)
[08:29:08.435]                 if (is_error) {
[08:29:08.435]                   sessionInformation <- function() {
[08:29:08.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:08.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:08.435]                       search = base::search(), system = base::Sys.info())
[08:29:08.435]                   }
[08:29:08.435]                   ...future.conditions[[length(...future.conditions) + 
[08:29:08.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:08.435]                     cond$call), session = sessionInformation(), 
[08:29:08.435]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:08.435]                   signalCondition(cond)
[08:29:08.435]                 }
[08:29:08.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:08.435]                 "immediateCondition"))) {
[08:29:08.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:08.435]                   ...future.conditions[[length(...future.conditions) + 
[08:29:08.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:08.435]                   if (TRUE && !signal) {
[08:29:08.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:08.435]                     {
[08:29:08.435]                       inherits <- base::inherits
[08:29:08.435]                       invokeRestart <- base::invokeRestart
[08:29:08.435]                       is.null <- base::is.null
[08:29:08.435]                       muffled <- FALSE
[08:29:08.435]                       if (inherits(cond, "message")) {
[08:29:08.435]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:08.435]                         if (muffled) 
[08:29:08.435]                           invokeRestart("muffleMessage")
[08:29:08.435]                       }
[08:29:08.435]                       else if (inherits(cond, "warning")) {
[08:29:08.435]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:08.435]                         if (muffled) 
[08:29:08.435]                           invokeRestart("muffleWarning")
[08:29:08.435]                       }
[08:29:08.435]                       else if (inherits(cond, "condition")) {
[08:29:08.435]                         if (!is.null(pattern)) {
[08:29:08.435]                           computeRestarts <- base::computeRestarts
[08:29:08.435]                           grepl <- base::grepl
[08:29:08.435]                           restarts <- computeRestarts(cond)
[08:29:08.435]                           for (restart in restarts) {
[08:29:08.435]                             name <- restart$name
[08:29:08.435]                             if (is.null(name)) 
[08:29:08.435]                               next
[08:29:08.435]                             if (!grepl(pattern, name)) 
[08:29:08.435]                               next
[08:29:08.435]                             invokeRestart(restart)
[08:29:08.435]                             muffled <- TRUE
[08:29:08.435]                             break
[08:29:08.435]                           }
[08:29:08.435]                         }
[08:29:08.435]                       }
[08:29:08.435]                       invisible(muffled)
[08:29:08.435]                     }
[08:29:08.435]                     muffleCondition(cond, pattern = "^muffle")
[08:29:08.435]                   }
[08:29:08.435]                 }
[08:29:08.435]                 else {
[08:29:08.435]                   if (TRUE) {
[08:29:08.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:08.435]                     {
[08:29:08.435]                       inherits <- base::inherits
[08:29:08.435]                       invokeRestart <- base::invokeRestart
[08:29:08.435]                       is.null <- base::is.null
[08:29:08.435]                       muffled <- FALSE
[08:29:08.435]                       if (inherits(cond, "message")) {
[08:29:08.435]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:08.435]                         if (muffled) 
[08:29:08.435]                           invokeRestart("muffleMessage")
[08:29:08.435]                       }
[08:29:08.435]                       else if (inherits(cond, "warning")) {
[08:29:08.435]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:08.435]                         if (muffled) 
[08:29:08.435]                           invokeRestart("muffleWarning")
[08:29:08.435]                       }
[08:29:08.435]                       else if (inherits(cond, "condition")) {
[08:29:08.435]                         if (!is.null(pattern)) {
[08:29:08.435]                           computeRestarts <- base::computeRestarts
[08:29:08.435]                           grepl <- base::grepl
[08:29:08.435]                           restarts <- computeRestarts(cond)
[08:29:08.435]                           for (restart in restarts) {
[08:29:08.435]                             name <- restart$name
[08:29:08.435]                             if (is.null(name)) 
[08:29:08.435]                               next
[08:29:08.435]                             if (!grepl(pattern, name)) 
[08:29:08.435]                               next
[08:29:08.435]                             invokeRestart(restart)
[08:29:08.435]                             muffled <- TRUE
[08:29:08.435]                             break
[08:29:08.435]                           }
[08:29:08.435]                         }
[08:29:08.435]                       }
[08:29:08.435]                       invisible(muffled)
[08:29:08.435]                     }
[08:29:08.435]                     muffleCondition(cond, pattern = "^muffle")
[08:29:08.435]                   }
[08:29:08.435]                 }
[08:29:08.435]             }
[08:29:08.435]         }))
[08:29:08.435]     }, error = function(ex) {
[08:29:08.435]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:08.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:08.435]                 ...future.rng), started = ...future.startTime, 
[08:29:08.435]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:08.435]             version = "1.8"), class = "FutureResult")
[08:29:08.435]     }, finally = {
[08:29:08.435]         if (!identical(...future.workdir, getwd())) 
[08:29:08.435]             setwd(...future.workdir)
[08:29:08.435]         {
[08:29:08.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:08.435]                 ...future.oldOptions$nwarnings <- NULL
[08:29:08.435]             }
[08:29:08.435]             base::options(...future.oldOptions)
[08:29:08.435]             if (.Platform$OS.type == "windows") {
[08:29:08.435]                 old_names <- names(...future.oldEnvVars)
[08:29:08.435]                 envs <- base::Sys.getenv()
[08:29:08.435]                 names <- names(envs)
[08:29:08.435]                 common <- intersect(names, old_names)
[08:29:08.435]                 added <- setdiff(names, old_names)
[08:29:08.435]                 removed <- setdiff(old_names, names)
[08:29:08.435]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:08.435]                   envs[common]]
[08:29:08.435]                 NAMES <- toupper(changed)
[08:29:08.435]                 args <- list()
[08:29:08.435]                 for (kk in seq_along(NAMES)) {
[08:29:08.435]                   name <- changed[[kk]]
[08:29:08.435]                   NAME <- NAMES[[kk]]
[08:29:08.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:08.435]                     next
[08:29:08.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:08.435]                 }
[08:29:08.435]                 NAMES <- toupper(added)
[08:29:08.435]                 for (kk in seq_along(NAMES)) {
[08:29:08.435]                   name <- added[[kk]]
[08:29:08.435]                   NAME <- NAMES[[kk]]
[08:29:08.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:08.435]                     next
[08:29:08.435]                   args[[name]] <- ""
[08:29:08.435]                 }
[08:29:08.435]                 NAMES <- toupper(removed)
[08:29:08.435]                 for (kk in seq_along(NAMES)) {
[08:29:08.435]                   name <- removed[[kk]]
[08:29:08.435]                   NAME <- NAMES[[kk]]
[08:29:08.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:08.435]                     next
[08:29:08.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:08.435]                 }
[08:29:08.435]                 if (length(args) > 0) 
[08:29:08.435]                   base::do.call(base::Sys.setenv, args = args)
[08:29:08.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:08.435]             }
[08:29:08.435]             else {
[08:29:08.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:08.435]             }
[08:29:08.435]             {
[08:29:08.435]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:08.435]                   0L) {
[08:29:08.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:08.435]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:08.435]                   base::options(opts)
[08:29:08.435]                 }
[08:29:08.435]                 {
[08:29:08.435]                   {
[08:29:08.435]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:08.435]                     NULL
[08:29:08.435]                   }
[08:29:08.435]                   options(future.plan = NULL)
[08:29:08.435]                   if (is.na(NA_character_)) 
[08:29:08.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:08.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:08.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:08.435]                     .init = FALSE)
[08:29:08.435]                 }
[08:29:08.435]             }
[08:29:08.435]         }
[08:29:08.435]     })
[08:29:08.435]     if (TRUE) {
[08:29:08.435]         base::sink(type = "output", split = FALSE)
[08:29:08.435]         if (TRUE) {
[08:29:08.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:08.435]         }
[08:29:08.435]         else {
[08:29:08.435]             ...future.result["stdout"] <- base::list(NULL)
[08:29:08.435]         }
[08:29:08.435]         base::close(...future.stdout)
[08:29:08.435]         ...future.stdout <- NULL
[08:29:08.435]     }
[08:29:08.435]     ...future.result$conditions <- ...future.conditions
[08:29:08.435]     ...future.result$finished <- base::Sys.time()
[08:29:08.435]     ...future.result
[08:29:08.435] }
[08:29:08.438] MultisessionFuture started
[08:29:08.438] - Launch lazy future ... done
[08:29:08.438] run() for ‘MultisessionFuture’ ... done
[08:29:08.480] receiveMessageFromWorker() for ClusterFuture ...
[08:29:08.480] - Validating connection of MultisessionFuture
[08:29:08.481] - received message: FutureResult
[08:29:08.481] - Received FutureResult
[08:29:08.481] - Erased future from FutureRegistry
[08:29:08.481] result() for ClusterFuture ...
[08:29:08.481] - result already collected: FutureResult
[08:29:08.481] result() for ClusterFuture ... done
[08:29:08.481] signalConditions() ...
[08:29:08.481]  - include = ‘immediateCondition’
[08:29:08.482]  - exclude = 
[08:29:08.482]  - resignal = FALSE
[08:29:08.482]  - Number of conditions: 1
[08:29:08.482] signalConditions() ... done
[08:29:08.482] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:08.482] A MultisessionFuture was resolved (result was not collected)
[08:29:08.482] getGlobalsAndPackages() ...
[08:29:08.482] Searching for globals...
[08:29:08.483] - globals found: [2] ‘list’, ‘stop’
[08:29:08.483] Searching for globals ... DONE
[08:29:08.483] Resolving globals: FALSE
[08:29:08.483] 
[08:29:08.483] 
[08:29:08.483] getGlobalsAndPackages() ... DONE
[08:29:08.484] run() for ‘Future’ ...
[08:29:08.484] - state: ‘created’
[08:29:08.484] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:08.498] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:08.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:08.498]   - Field: ‘node’
[08:29:08.498]   - Field: ‘label’
[08:29:08.498]   - Field: ‘local’
[08:29:08.498]   - Field: ‘owner’
[08:29:08.498]   - Field: ‘envir’
[08:29:08.498]   - Field: ‘workers’
[08:29:08.498]   - Field: ‘packages’
[08:29:08.498]   - Field: ‘gc’
[08:29:08.498]   - Field: ‘conditions’
[08:29:08.499]   - Field: ‘persistent’
[08:29:08.499]   - Field: ‘expr’
[08:29:08.499]   - Field: ‘uuid’
[08:29:08.499]   - Field: ‘seed’
[08:29:08.499]   - Field: ‘version’
[08:29:08.499]   - Field: ‘result’
[08:29:08.499]   - Field: ‘asynchronous’
[08:29:08.499]   - Field: ‘calls’
[08:29:08.499]   - Field: ‘globals’
[08:29:08.499]   - Field: ‘stdout’
[08:29:08.499]   - Field: ‘earlySignal’
[08:29:08.499]   - Field: ‘lazy’
[08:29:08.500]   - Field: ‘state’
[08:29:08.500] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:08.500] - Launch lazy future ...
[08:29:08.500] Packages needed by the future expression (n = 0): <none>
[08:29:08.500] Packages needed by future strategies (n = 0): <none>
[08:29:08.501] {
[08:29:08.501]     {
[08:29:08.501]         {
[08:29:08.501]             ...future.startTime <- base::Sys.time()
[08:29:08.501]             {
[08:29:08.501]                 {
[08:29:08.501]                   {
[08:29:08.501]                     {
[08:29:08.501]                       base::local({
[08:29:08.501]                         has_future <- base::requireNamespace("future", 
[08:29:08.501]                           quietly = TRUE)
[08:29:08.501]                         if (has_future) {
[08:29:08.501]                           ns <- base::getNamespace("future")
[08:29:08.501]                           version <- ns[[".package"]][["version"]]
[08:29:08.501]                           if (is.null(version)) 
[08:29:08.501]                             version <- utils::packageVersion("future")
[08:29:08.501]                         }
[08:29:08.501]                         else {
[08:29:08.501]                           version <- NULL
[08:29:08.501]                         }
[08:29:08.501]                         if (!has_future || version < "1.8.0") {
[08:29:08.501]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:08.501]                             "", base::R.version$version.string), 
[08:29:08.501]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:08.501]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:08.501]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:08.501]                               "release", "version")], collapse = " "), 
[08:29:08.501]                             hostname = base::Sys.info()[["nodename"]])
[08:29:08.501]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:08.501]                             info)
[08:29:08.501]                           info <- base::paste(info, collapse = "; ")
[08:29:08.501]                           if (!has_future) {
[08:29:08.501]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:08.501]                               info)
[08:29:08.501]                           }
[08:29:08.501]                           else {
[08:29:08.501]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:08.501]                               info, version)
[08:29:08.501]                           }
[08:29:08.501]                           base::stop(msg)
[08:29:08.501]                         }
[08:29:08.501]                       })
[08:29:08.501]                     }
[08:29:08.501]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:08.501]                     base::options(mc.cores = 1L)
[08:29:08.501]                   }
[08:29:08.501]                   ...future.strategy.old <- future::plan("list")
[08:29:08.501]                   options(future.plan = NULL)
[08:29:08.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:08.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:08.501]                 }
[08:29:08.501]                 ...future.workdir <- getwd()
[08:29:08.501]             }
[08:29:08.501]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:08.501]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:08.501]         }
[08:29:08.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:08.501]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:08.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:08.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:08.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:08.501]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:08.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:08.501]             base::names(...future.oldOptions))
[08:29:08.501]     }
[08:29:08.501]     if (FALSE) {
[08:29:08.501]     }
[08:29:08.501]     else {
[08:29:08.501]         if (TRUE) {
[08:29:08.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:08.501]                 open = "w")
[08:29:08.501]         }
[08:29:08.501]         else {
[08:29:08.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:08.501]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:08.501]         }
[08:29:08.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:08.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:08.501]             base::sink(type = "output", split = FALSE)
[08:29:08.501]             base::close(...future.stdout)
[08:29:08.501]         }, add = TRUE)
[08:29:08.501]     }
[08:29:08.501]     ...future.frame <- base::sys.nframe()
[08:29:08.501]     ...future.conditions <- base::list()
[08:29:08.501]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:08.501]     if (FALSE) {
[08:29:08.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:08.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:08.501]     }
[08:29:08.501]     ...future.result <- base::tryCatch({
[08:29:08.501]         base::withCallingHandlers({
[08:29:08.501]             ...future.value <- base::withVisible(base::local({
[08:29:08.501]                 ...future.makeSendCondition <- base::local({
[08:29:08.501]                   sendCondition <- NULL
[08:29:08.501]                   function(frame = 1L) {
[08:29:08.501]                     if (is.function(sendCondition)) 
[08:29:08.501]                       return(sendCondition)
[08:29:08.501]                     ns <- getNamespace("parallel")
[08:29:08.501]                     if (exists("sendData", mode = "function", 
[08:29:08.501]                       envir = ns)) {
[08:29:08.501]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:08.501]                         envir = ns)
[08:29:08.501]                       envir <- sys.frame(frame)
[08:29:08.501]                       master <- NULL
[08:29:08.501]                       while (!identical(envir, .GlobalEnv) && 
[08:29:08.501]                         !identical(envir, emptyenv())) {
[08:29:08.501]                         if (exists("master", mode = "list", envir = envir, 
[08:29:08.501]                           inherits = FALSE)) {
[08:29:08.501]                           master <- get("master", mode = "list", 
[08:29:08.501]                             envir = envir, inherits = FALSE)
[08:29:08.501]                           if (inherits(master, c("SOCKnode", 
[08:29:08.501]                             "SOCK0node"))) {
[08:29:08.501]                             sendCondition <<- function(cond) {
[08:29:08.501]                               data <- list(type = "VALUE", value = cond, 
[08:29:08.501]                                 success = TRUE)
[08:29:08.501]                               parallel_sendData(master, data)
[08:29:08.501]                             }
[08:29:08.501]                             return(sendCondition)
[08:29:08.501]                           }
[08:29:08.501]                         }
[08:29:08.501]                         frame <- frame + 1L
[08:29:08.501]                         envir <- sys.frame(frame)
[08:29:08.501]                       }
[08:29:08.501]                     }
[08:29:08.501]                     sendCondition <<- function(cond) NULL
[08:29:08.501]                   }
[08:29:08.501]                 })
[08:29:08.501]                 withCallingHandlers({
[08:29:08.501]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:08.501]                 }, immediateCondition = function(cond) {
[08:29:08.501]                   sendCondition <- ...future.makeSendCondition()
[08:29:08.501]                   sendCondition(cond)
[08:29:08.501]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:08.501]                   {
[08:29:08.501]                     inherits <- base::inherits
[08:29:08.501]                     invokeRestart <- base::invokeRestart
[08:29:08.501]                     is.null <- base::is.null
[08:29:08.501]                     muffled <- FALSE
[08:29:08.501]                     if (inherits(cond, "message")) {
[08:29:08.501]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:08.501]                       if (muffled) 
[08:29:08.501]                         invokeRestart("muffleMessage")
[08:29:08.501]                     }
[08:29:08.501]                     else if (inherits(cond, "warning")) {
[08:29:08.501]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:08.501]                       if (muffled) 
[08:29:08.501]                         invokeRestart("muffleWarning")
[08:29:08.501]                     }
[08:29:08.501]                     else if (inherits(cond, "condition")) {
[08:29:08.501]                       if (!is.null(pattern)) {
[08:29:08.501]                         computeRestarts <- base::computeRestarts
[08:29:08.501]                         grepl <- base::grepl
[08:29:08.501]                         restarts <- computeRestarts(cond)
[08:29:08.501]                         for (restart in restarts) {
[08:29:08.501]                           name <- restart$name
[08:29:08.501]                           if (is.null(name)) 
[08:29:08.501]                             next
[08:29:08.501]                           if (!grepl(pattern, name)) 
[08:29:08.501]                             next
[08:29:08.501]                           invokeRestart(restart)
[08:29:08.501]                           muffled <- TRUE
[08:29:08.501]                           break
[08:29:08.501]                         }
[08:29:08.501]                       }
[08:29:08.501]                     }
[08:29:08.501]                     invisible(muffled)
[08:29:08.501]                   }
[08:29:08.501]                   muffleCondition(cond)
[08:29:08.501]                 })
[08:29:08.501]             }))
[08:29:08.501]             future::FutureResult(value = ...future.value$value, 
[08:29:08.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:08.501]                   ...future.rng), globalenv = if (FALSE) 
[08:29:08.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:08.501]                     ...future.globalenv.names))
[08:29:08.501]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:08.501]         }, condition = base::local({
[08:29:08.501]             c <- base::c
[08:29:08.501]             inherits <- base::inherits
[08:29:08.501]             invokeRestart <- base::invokeRestart
[08:29:08.501]             length <- base::length
[08:29:08.501]             list <- base::list
[08:29:08.501]             seq.int <- base::seq.int
[08:29:08.501]             signalCondition <- base::signalCondition
[08:29:08.501]             sys.calls <- base::sys.calls
[08:29:08.501]             `[[` <- base::`[[`
[08:29:08.501]             `+` <- base::`+`
[08:29:08.501]             `<<-` <- base::`<<-`
[08:29:08.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:08.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:08.501]                   3L)]
[08:29:08.501]             }
[08:29:08.501]             function(cond) {
[08:29:08.501]                 is_error <- inherits(cond, "error")
[08:29:08.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:08.501]                   NULL)
[08:29:08.501]                 if (is_error) {
[08:29:08.501]                   sessionInformation <- function() {
[08:29:08.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:08.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:08.501]                       search = base::search(), system = base::Sys.info())
[08:29:08.501]                   }
[08:29:08.501]                   ...future.conditions[[length(...future.conditions) + 
[08:29:08.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:08.501]                     cond$call), session = sessionInformation(), 
[08:29:08.501]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:08.501]                   signalCondition(cond)
[08:29:08.501]                 }
[08:29:08.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:08.501]                 "immediateCondition"))) {
[08:29:08.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:08.501]                   ...future.conditions[[length(...future.conditions) + 
[08:29:08.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:08.501]                   if (TRUE && !signal) {
[08:29:08.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:08.501]                     {
[08:29:08.501]                       inherits <- base::inherits
[08:29:08.501]                       invokeRestart <- base::invokeRestart
[08:29:08.501]                       is.null <- base::is.null
[08:29:08.501]                       muffled <- FALSE
[08:29:08.501]                       if (inherits(cond, "message")) {
[08:29:08.501]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:08.501]                         if (muffled) 
[08:29:08.501]                           invokeRestart("muffleMessage")
[08:29:08.501]                       }
[08:29:08.501]                       else if (inherits(cond, "warning")) {
[08:29:08.501]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:08.501]                         if (muffled) 
[08:29:08.501]                           invokeRestart("muffleWarning")
[08:29:08.501]                       }
[08:29:08.501]                       else if (inherits(cond, "condition")) {
[08:29:08.501]                         if (!is.null(pattern)) {
[08:29:08.501]                           computeRestarts <- base::computeRestarts
[08:29:08.501]                           grepl <- base::grepl
[08:29:08.501]                           restarts <- computeRestarts(cond)
[08:29:08.501]                           for (restart in restarts) {
[08:29:08.501]                             name <- restart$name
[08:29:08.501]                             if (is.null(name)) 
[08:29:08.501]                               next
[08:29:08.501]                             if (!grepl(pattern, name)) 
[08:29:08.501]                               next
[08:29:08.501]                             invokeRestart(restart)
[08:29:08.501]                             muffled <- TRUE
[08:29:08.501]                             break
[08:29:08.501]                           }
[08:29:08.501]                         }
[08:29:08.501]                       }
[08:29:08.501]                       invisible(muffled)
[08:29:08.501]                     }
[08:29:08.501]                     muffleCondition(cond, pattern = "^muffle")
[08:29:08.501]                   }
[08:29:08.501]                 }
[08:29:08.501]                 else {
[08:29:08.501]                   if (TRUE) {
[08:29:08.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:08.501]                     {
[08:29:08.501]                       inherits <- base::inherits
[08:29:08.501]                       invokeRestart <- base::invokeRestart
[08:29:08.501]                       is.null <- base::is.null
[08:29:08.501]                       muffled <- FALSE
[08:29:08.501]                       if (inherits(cond, "message")) {
[08:29:08.501]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:08.501]                         if (muffled) 
[08:29:08.501]                           invokeRestart("muffleMessage")
[08:29:08.501]                       }
[08:29:08.501]                       else if (inherits(cond, "warning")) {
[08:29:08.501]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:08.501]                         if (muffled) 
[08:29:08.501]                           invokeRestart("muffleWarning")
[08:29:08.501]                       }
[08:29:08.501]                       else if (inherits(cond, "condition")) {
[08:29:08.501]                         if (!is.null(pattern)) {
[08:29:08.501]                           computeRestarts <- base::computeRestarts
[08:29:08.501]                           grepl <- base::grepl
[08:29:08.501]                           restarts <- computeRestarts(cond)
[08:29:08.501]                           for (restart in restarts) {
[08:29:08.501]                             name <- restart$name
[08:29:08.501]                             if (is.null(name)) 
[08:29:08.501]                               next
[08:29:08.501]                             if (!grepl(pattern, name)) 
[08:29:08.501]                               next
[08:29:08.501]                             invokeRestart(restart)
[08:29:08.501]                             muffled <- TRUE
[08:29:08.501]                             break
[08:29:08.501]                           }
[08:29:08.501]                         }
[08:29:08.501]                       }
[08:29:08.501]                       invisible(muffled)
[08:29:08.501]                     }
[08:29:08.501]                     muffleCondition(cond, pattern = "^muffle")
[08:29:08.501]                   }
[08:29:08.501]                 }
[08:29:08.501]             }
[08:29:08.501]         }))
[08:29:08.501]     }, error = function(ex) {
[08:29:08.501]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:08.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:08.501]                 ...future.rng), started = ...future.startTime, 
[08:29:08.501]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:08.501]             version = "1.8"), class = "FutureResult")
[08:29:08.501]     }, finally = {
[08:29:08.501]         if (!identical(...future.workdir, getwd())) 
[08:29:08.501]             setwd(...future.workdir)
[08:29:08.501]         {
[08:29:08.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:08.501]                 ...future.oldOptions$nwarnings <- NULL
[08:29:08.501]             }
[08:29:08.501]             base::options(...future.oldOptions)
[08:29:08.501]             if (.Platform$OS.type == "windows") {
[08:29:08.501]                 old_names <- names(...future.oldEnvVars)
[08:29:08.501]                 envs <- base::Sys.getenv()
[08:29:08.501]                 names <- names(envs)
[08:29:08.501]                 common <- intersect(names, old_names)
[08:29:08.501]                 added <- setdiff(names, old_names)
[08:29:08.501]                 removed <- setdiff(old_names, names)
[08:29:08.501]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:08.501]                   envs[common]]
[08:29:08.501]                 NAMES <- toupper(changed)
[08:29:08.501]                 args <- list()
[08:29:08.501]                 for (kk in seq_along(NAMES)) {
[08:29:08.501]                   name <- changed[[kk]]
[08:29:08.501]                   NAME <- NAMES[[kk]]
[08:29:08.501]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:08.501]                     next
[08:29:08.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:08.501]                 }
[08:29:08.501]                 NAMES <- toupper(added)
[08:29:08.501]                 for (kk in seq_along(NAMES)) {
[08:29:08.501]                   name <- added[[kk]]
[08:29:08.501]                   NAME <- NAMES[[kk]]
[08:29:08.501]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:08.501]                     next
[08:29:08.501]                   args[[name]] <- ""
[08:29:08.501]                 }
[08:29:08.501]                 NAMES <- toupper(removed)
[08:29:08.501]                 for (kk in seq_along(NAMES)) {
[08:29:08.501]                   name <- removed[[kk]]
[08:29:08.501]                   NAME <- NAMES[[kk]]
[08:29:08.501]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:08.501]                     next
[08:29:08.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:08.501]                 }
[08:29:08.501]                 if (length(args) > 0) 
[08:29:08.501]                   base::do.call(base::Sys.setenv, args = args)
[08:29:08.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:08.501]             }
[08:29:08.501]             else {
[08:29:08.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:08.501]             }
[08:29:08.501]             {
[08:29:08.501]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:08.501]                   0L) {
[08:29:08.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:08.501]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:08.501]                   base::options(opts)
[08:29:08.501]                 }
[08:29:08.501]                 {
[08:29:08.501]                   {
[08:29:08.501]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:08.501]                     NULL
[08:29:08.501]                   }
[08:29:08.501]                   options(future.plan = NULL)
[08:29:08.501]                   if (is.na(NA_character_)) 
[08:29:08.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:08.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:08.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:08.501]                     .init = FALSE)
[08:29:08.501]                 }
[08:29:08.501]             }
[08:29:08.501]         }
[08:29:08.501]     })
[08:29:08.501]     if (TRUE) {
[08:29:08.501]         base::sink(type = "output", split = FALSE)
[08:29:08.501]         if (TRUE) {
[08:29:08.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:08.501]         }
[08:29:08.501]         else {
[08:29:08.501]             ...future.result["stdout"] <- base::list(NULL)
[08:29:08.501]         }
[08:29:08.501]         base::close(...future.stdout)
[08:29:08.501]         ...future.stdout <- NULL
[08:29:08.501]     }
[08:29:08.501]     ...future.result$conditions <- ...future.conditions
[08:29:08.501]     ...future.result$finished <- base::Sys.time()
[08:29:08.501]     ...future.result
[08:29:08.501] }
[08:29:08.503] MultisessionFuture started
[08:29:08.504] - Launch lazy future ... done
[08:29:08.504] run() for ‘MultisessionFuture’ ... done
[08:29:08.546] receiveMessageFromWorker() for ClusterFuture ...
[08:29:08.546] - Validating connection of MultisessionFuture
[08:29:08.546] - received message: FutureResult
[08:29:08.547] - Received FutureResult
[08:29:08.547] - Erased future from FutureRegistry
[08:29:08.547] result() for ClusterFuture ...
[08:29:08.547] - result already collected: FutureResult
[08:29:08.547] result() for ClusterFuture ... done
[08:29:08.547] signalConditions() ...
[08:29:08.547]  - include = ‘immediateCondition’
[08:29:08.547]  - exclude = 
[08:29:08.547]  - resignal = FALSE
[08:29:08.547]  - Number of conditions: 1
[08:29:08.547] signalConditions() ... done
[08:29:08.548] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:08.548] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[08:29:08.548] getGlobalsAndPackages() ...
[08:29:08.548] Searching for globals...
[08:29:08.549] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:08.549] Searching for globals ... DONE
[08:29:08.549] Resolving globals: FALSE
[08:29:08.550] 
[08:29:08.550] 
[08:29:08.550] getGlobalsAndPackages() ... DONE
[08:29:08.550] run() for ‘Future’ ...
[08:29:08.550] - state: ‘created’
[08:29:08.550] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:08.564] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:08.564] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:08.564]   - Field: ‘node’
[08:29:08.564]   - Field: ‘label’
[08:29:08.564]   - Field: ‘local’
[08:29:08.564]   - Field: ‘owner’
[08:29:08.564]   - Field: ‘envir’
[08:29:08.564]   - Field: ‘workers’
[08:29:08.565]   - Field: ‘packages’
[08:29:08.565]   - Field: ‘gc’
[08:29:08.565]   - Field: ‘conditions’
[08:29:08.565]   - Field: ‘persistent’
[08:29:08.565]   - Field: ‘expr’
[08:29:08.565]   - Field: ‘uuid’
[08:29:08.565]   - Field: ‘seed’
[08:29:08.565]   - Field: ‘version’
[08:29:08.565]   - Field: ‘result’
[08:29:08.565]   - Field: ‘asynchronous’
[08:29:08.565]   - Field: ‘calls’
[08:29:08.566]   - Field: ‘globals’
[08:29:08.566]   - Field: ‘stdout’
[08:29:08.566]   - Field: ‘earlySignal’
[08:29:08.566]   - Field: ‘lazy’
[08:29:08.566]   - Field: ‘state’
[08:29:08.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:08.566] - Launch lazy future ...
[08:29:08.566] Packages needed by the future expression (n = 0): <none>
[08:29:08.566] Packages needed by future strategies (n = 0): <none>
[08:29:08.567] {
[08:29:08.567]     {
[08:29:08.567]         {
[08:29:08.567]             ...future.startTime <- base::Sys.time()
[08:29:08.567]             {
[08:29:08.567]                 {
[08:29:08.567]                   {
[08:29:08.567]                     {
[08:29:08.567]                       base::local({
[08:29:08.567]                         has_future <- base::requireNamespace("future", 
[08:29:08.567]                           quietly = TRUE)
[08:29:08.567]                         if (has_future) {
[08:29:08.567]                           ns <- base::getNamespace("future")
[08:29:08.567]                           version <- ns[[".package"]][["version"]]
[08:29:08.567]                           if (is.null(version)) 
[08:29:08.567]                             version <- utils::packageVersion("future")
[08:29:08.567]                         }
[08:29:08.567]                         else {
[08:29:08.567]                           version <- NULL
[08:29:08.567]                         }
[08:29:08.567]                         if (!has_future || version < "1.8.0") {
[08:29:08.567]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:08.567]                             "", base::R.version$version.string), 
[08:29:08.567]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:08.567]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:08.567]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:08.567]                               "release", "version")], collapse = " "), 
[08:29:08.567]                             hostname = base::Sys.info()[["nodename"]])
[08:29:08.567]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:08.567]                             info)
[08:29:08.567]                           info <- base::paste(info, collapse = "; ")
[08:29:08.567]                           if (!has_future) {
[08:29:08.567]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:08.567]                               info)
[08:29:08.567]                           }
[08:29:08.567]                           else {
[08:29:08.567]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:08.567]                               info, version)
[08:29:08.567]                           }
[08:29:08.567]                           base::stop(msg)
[08:29:08.567]                         }
[08:29:08.567]                       })
[08:29:08.567]                     }
[08:29:08.567]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:08.567]                     base::options(mc.cores = 1L)
[08:29:08.567]                   }
[08:29:08.567]                   ...future.strategy.old <- future::plan("list")
[08:29:08.567]                   options(future.plan = NULL)
[08:29:08.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:08.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:08.567]                 }
[08:29:08.567]                 ...future.workdir <- getwd()
[08:29:08.567]             }
[08:29:08.567]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:08.567]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:08.567]         }
[08:29:08.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:08.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:08.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:08.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:08.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:08.567]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:08.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:08.567]             base::names(...future.oldOptions))
[08:29:08.567]     }
[08:29:08.567]     if (FALSE) {
[08:29:08.567]     }
[08:29:08.567]     else {
[08:29:08.567]         if (TRUE) {
[08:29:08.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:08.567]                 open = "w")
[08:29:08.567]         }
[08:29:08.567]         else {
[08:29:08.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:08.567]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:08.567]         }
[08:29:08.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:08.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:08.567]             base::sink(type = "output", split = FALSE)
[08:29:08.567]             base::close(...future.stdout)
[08:29:08.567]         }, add = TRUE)
[08:29:08.567]     }
[08:29:08.567]     ...future.frame <- base::sys.nframe()
[08:29:08.567]     ...future.conditions <- base::list()
[08:29:08.567]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:08.567]     if (FALSE) {
[08:29:08.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:08.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:08.567]     }
[08:29:08.567]     ...future.result <- base::tryCatch({
[08:29:08.567]         base::withCallingHandlers({
[08:29:08.567]             ...future.value <- base::withVisible(base::local({
[08:29:08.567]                 ...future.makeSendCondition <- base::local({
[08:29:08.567]                   sendCondition <- NULL
[08:29:08.567]                   function(frame = 1L) {
[08:29:08.567]                     if (is.function(sendCondition)) 
[08:29:08.567]                       return(sendCondition)
[08:29:08.567]                     ns <- getNamespace("parallel")
[08:29:08.567]                     if (exists("sendData", mode = "function", 
[08:29:08.567]                       envir = ns)) {
[08:29:08.567]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:08.567]                         envir = ns)
[08:29:08.567]                       envir <- sys.frame(frame)
[08:29:08.567]                       master <- NULL
[08:29:08.567]                       while (!identical(envir, .GlobalEnv) && 
[08:29:08.567]                         !identical(envir, emptyenv())) {
[08:29:08.567]                         if (exists("master", mode = "list", envir = envir, 
[08:29:08.567]                           inherits = FALSE)) {
[08:29:08.567]                           master <- get("master", mode = "list", 
[08:29:08.567]                             envir = envir, inherits = FALSE)
[08:29:08.567]                           if (inherits(master, c("SOCKnode", 
[08:29:08.567]                             "SOCK0node"))) {
[08:29:08.567]                             sendCondition <<- function(cond) {
[08:29:08.567]                               data <- list(type = "VALUE", value = cond, 
[08:29:08.567]                                 success = TRUE)
[08:29:08.567]                               parallel_sendData(master, data)
[08:29:08.567]                             }
[08:29:08.567]                             return(sendCondition)
[08:29:08.567]                           }
[08:29:08.567]                         }
[08:29:08.567]                         frame <- frame + 1L
[08:29:08.567]                         envir <- sys.frame(frame)
[08:29:08.567]                       }
[08:29:08.567]                     }
[08:29:08.567]                     sendCondition <<- function(cond) NULL
[08:29:08.567]                   }
[08:29:08.567]                 })
[08:29:08.567]                 withCallingHandlers({
[08:29:08.567]                   {
[08:29:08.567]                     Sys.sleep(0.5)
[08:29:08.567]                     list(a = 1, b = 42L)
[08:29:08.567]                   }
[08:29:08.567]                 }, immediateCondition = function(cond) {
[08:29:08.567]                   sendCondition <- ...future.makeSendCondition()
[08:29:08.567]                   sendCondition(cond)
[08:29:08.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:08.567]                   {
[08:29:08.567]                     inherits <- base::inherits
[08:29:08.567]                     invokeRestart <- base::invokeRestart
[08:29:08.567]                     is.null <- base::is.null
[08:29:08.567]                     muffled <- FALSE
[08:29:08.567]                     if (inherits(cond, "message")) {
[08:29:08.567]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:08.567]                       if (muffled) 
[08:29:08.567]                         invokeRestart("muffleMessage")
[08:29:08.567]                     }
[08:29:08.567]                     else if (inherits(cond, "warning")) {
[08:29:08.567]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:08.567]                       if (muffled) 
[08:29:08.567]                         invokeRestart("muffleWarning")
[08:29:08.567]                     }
[08:29:08.567]                     else if (inherits(cond, "condition")) {
[08:29:08.567]                       if (!is.null(pattern)) {
[08:29:08.567]                         computeRestarts <- base::computeRestarts
[08:29:08.567]                         grepl <- base::grepl
[08:29:08.567]                         restarts <- computeRestarts(cond)
[08:29:08.567]                         for (restart in restarts) {
[08:29:08.567]                           name <- restart$name
[08:29:08.567]                           if (is.null(name)) 
[08:29:08.567]                             next
[08:29:08.567]                           if (!grepl(pattern, name)) 
[08:29:08.567]                             next
[08:29:08.567]                           invokeRestart(restart)
[08:29:08.567]                           muffled <- TRUE
[08:29:08.567]                           break
[08:29:08.567]                         }
[08:29:08.567]                       }
[08:29:08.567]                     }
[08:29:08.567]                     invisible(muffled)
[08:29:08.567]                   }
[08:29:08.567]                   muffleCondition(cond)
[08:29:08.567]                 })
[08:29:08.567]             }))
[08:29:08.567]             future::FutureResult(value = ...future.value$value, 
[08:29:08.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:08.567]                   ...future.rng), globalenv = if (FALSE) 
[08:29:08.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:08.567]                     ...future.globalenv.names))
[08:29:08.567]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:08.567]         }, condition = base::local({
[08:29:08.567]             c <- base::c
[08:29:08.567]             inherits <- base::inherits
[08:29:08.567]             invokeRestart <- base::invokeRestart
[08:29:08.567]             length <- base::length
[08:29:08.567]             list <- base::list
[08:29:08.567]             seq.int <- base::seq.int
[08:29:08.567]             signalCondition <- base::signalCondition
[08:29:08.567]             sys.calls <- base::sys.calls
[08:29:08.567]             `[[` <- base::`[[`
[08:29:08.567]             `+` <- base::`+`
[08:29:08.567]             `<<-` <- base::`<<-`
[08:29:08.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:08.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:08.567]                   3L)]
[08:29:08.567]             }
[08:29:08.567]             function(cond) {
[08:29:08.567]                 is_error <- inherits(cond, "error")
[08:29:08.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:08.567]                   NULL)
[08:29:08.567]                 if (is_error) {
[08:29:08.567]                   sessionInformation <- function() {
[08:29:08.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:08.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:08.567]                       search = base::search(), system = base::Sys.info())
[08:29:08.567]                   }
[08:29:08.567]                   ...future.conditions[[length(...future.conditions) + 
[08:29:08.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:08.567]                     cond$call), session = sessionInformation(), 
[08:29:08.567]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:08.567]                   signalCondition(cond)
[08:29:08.567]                 }
[08:29:08.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:08.567]                 "immediateCondition"))) {
[08:29:08.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:08.567]                   ...future.conditions[[length(...future.conditions) + 
[08:29:08.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:08.567]                   if (TRUE && !signal) {
[08:29:08.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:08.567]                     {
[08:29:08.567]                       inherits <- base::inherits
[08:29:08.567]                       invokeRestart <- base::invokeRestart
[08:29:08.567]                       is.null <- base::is.null
[08:29:08.567]                       muffled <- FALSE
[08:29:08.567]                       if (inherits(cond, "message")) {
[08:29:08.567]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:08.567]                         if (muffled) 
[08:29:08.567]                           invokeRestart("muffleMessage")
[08:29:08.567]                       }
[08:29:08.567]                       else if (inherits(cond, "warning")) {
[08:29:08.567]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:08.567]                         if (muffled) 
[08:29:08.567]                           invokeRestart("muffleWarning")
[08:29:08.567]                       }
[08:29:08.567]                       else if (inherits(cond, "condition")) {
[08:29:08.567]                         if (!is.null(pattern)) {
[08:29:08.567]                           computeRestarts <- base::computeRestarts
[08:29:08.567]                           grepl <- base::grepl
[08:29:08.567]                           restarts <- computeRestarts(cond)
[08:29:08.567]                           for (restart in restarts) {
[08:29:08.567]                             name <- restart$name
[08:29:08.567]                             if (is.null(name)) 
[08:29:08.567]                               next
[08:29:08.567]                             if (!grepl(pattern, name)) 
[08:29:08.567]                               next
[08:29:08.567]                             invokeRestart(restart)
[08:29:08.567]                             muffled <- TRUE
[08:29:08.567]                             break
[08:29:08.567]                           }
[08:29:08.567]                         }
[08:29:08.567]                       }
[08:29:08.567]                       invisible(muffled)
[08:29:08.567]                     }
[08:29:08.567]                     muffleCondition(cond, pattern = "^muffle")
[08:29:08.567]                   }
[08:29:08.567]                 }
[08:29:08.567]                 else {
[08:29:08.567]                   if (TRUE) {
[08:29:08.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:08.567]                     {
[08:29:08.567]                       inherits <- base::inherits
[08:29:08.567]                       invokeRestart <- base::invokeRestart
[08:29:08.567]                       is.null <- base::is.null
[08:29:08.567]                       muffled <- FALSE
[08:29:08.567]                       if (inherits(cond, "message")) {
[08:29:08.567]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:08.567]                         if (muffled) 
[08:29:08.567]                           invokeRestart("muffleMessage")
[08:29:08.567]                       }
[08:29:08.567]                       else if (inherits(cond, "warning")) {
[08:29:08.567]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:08.567]                         if (muffled) 
[08:29:08.567]                           invokeRestart("muffleWarning")
[08:29:08.567]                       }
[08:29:08.567]                       else if (inherits(cond, "condition")) {
[08:29:08.567]                         if (!is.null(pattern)) {
[08:29:08.567]                           computeRestarts <- base::computeRestarts
[08:29:08.567]                           grepl <- base::grepl
[08:29:08.567]                           restarts <- computeRestarts(cond)
[08:29:08.567]                           for (restart in restarts) {
[08:29:08.567]                             name <- restart$name
[08:29:08.567]                             if (is.null(name)) 
[08:29:08.567]                               next
[08:29:08.567]                             if (!grepl(pattern, name)) 
[08:29:08.567]                               next
[08:29:08.567]                             invokeRestart(restart)
[08:29:08.567]                             muffled <- TRUE
[08:29:08.567]                             break
[08:29:08.567]                           }
[08:29:08.567]                         }
[08:29:08.567]                       }
[08:29:08.567]                       invisible(muffled)
[08:29:08.567]                     }
[08:29:08.567]                     muffleCondition(cond, pattern = "^muffle")
[08:29:08.567]                   }
[08:29:08.567]                 }
[08:29:08.567]             }
[08:29:08.567]         }))
[08:29:08.567]     }, error = function(ex) {
[08:29:08.567]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:08.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:08.567]                 ...future.rng), started = ...future.startTime, 
[08:29:08.567]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:08.567]             version = "1.8"), class = "FutureResult")
[08:29:08.567]     }, finally = {
[08:29:08.567]         if (!identical(...future.workdir, getwd())) 
[08:29:08.567]             setwd(...future.workdir)
[08:29:08.567]         {
[08:29:08.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:08.567]                 ...future.oldOptions$nwarnings <- NULL
[08:29:08.567]             }
[08:29:08.567]             base::options(...future.oldOptions)
[08:29:08.567]             if (.Platform$OS.type == "windows") {
[08:29:08.567]                 old_names <- names(...future.oldEnvVars)
[08:29:08.567]                 envs <- base::Sys.getenv()
[08:29:08.567]                 names <- names(envs)
[08:29:08.567]                 common <- intersect(names, old_names)
[08:29:08.567]                 added <- setdiff(names, old_names)
[08:29:08.567]                 removed <- setdiff(old_names, names)
[08:29:08.567]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:08.567]                   envs[common]]
[08:29:08.567]                 NAMES <- toupper(changed)
[08:29:08.567]                 args <- list()
[08:29:08.567]                 for (kk in seq_along(NAMES)) {
[08:29:08.567]                   name <- changed[[kk]]
[08:29:08.567]                   NAME <- NAMES[[kk]]
[08:29:08.567]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:08.567]                     next
[08:29:08.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:08.567]                 }
[08:29:08.567]                 NAMES <- toupper(added)
[08:29:08.567]                 for (kk in seq_along(NAMES)) {
[08:29:08.567]                   name <- added[[kk]]
[08:29:08.567]                   NAME <- NAMES[[kk]]
[08:29:08.567]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:08.567]                     next
[08:29:08.567]                   args[[name]] <- ""
[08:29:08.567]                 }
[08:29:08.567]                 NAMES <- toupper(removed)
[08:29:08.567]                 for (kk in seq_along(NAMES)) {
[08:29:08.567]                   name <- removed[[kk]]
[08:29:08.567]                   NAME <- NAMES[[kk]]
[08:29:08.567]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:08.567]                     next
[08:29:08.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:08.567]                 }
[08:29:08.567]                 if (length(args) > 0) 
[08:29:08.567]                   base::do.call(base::Sys.setenv, args = args)
[08:29:08.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:08.567]             }
[08:29:08.567]             else {
[08:29:08.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:08.567]             }
[08:29:08.567]             {
[08:29:08.567]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:08.567]                   0L) {
[08:29:08.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:08.567]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:08.567]                   base::options(opts)
[08:29:08.567]                 }
[08:29:08.567]                 {
[08:29:08.567]                   {
[08:29:08.567]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:08.567]                     NULL
[08:29:08.567]                   }
[08:29:08.567]                   options(future.plan = NULL)
[08:29:08.567]                   if (is.na(NA_character_)) 
[08:29:08.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:08.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:08.567]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:08.567]                     .init = FALSE)
[08:29:08.567]                 }
[08:29:08.567]             }
[08:29:08.567]         }
[08:29:08.567]     })
[08:29:08.567]     if (TRUE) {
[08:29:08.567]         base::sink(type = "output", split = FALSE)
[08:29:08.567]         if (TRUE) {
[08:29:08.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:08.567]         }
[08:29:08.567]         else {
[08:29:08.567]             ...future.result["stdout"] <- base::list(NULL)
[08:29:08.567]         }
[08:29:08.567]         base::close(...future.stdout)
[08:29:08.567]         ...future.stdout <- NULL
[08:29:08.567]     }
[08:29:08.567]     ...future.result$conditions <- ...future.conditions
[08:29:08.567]     ...future.result$finished <- base::Sys.time()
[08:29:08.567]     ...future.result
[08:29:08.567] }
[08:29:08.570] MultisessionFuture started
[08:29:08.570] - Launch lazy future ... done
[08:29:08.570] run() for ‘MultisessionFuture’ ... done
[08:29:09.113] receiveMessageFromWorker() for ClusterFuture ...
[08:29:09.113] - Validating connection of MultisessionFuture
[08:29:09.113] - received message: FutureResult
[08:29:09.114] - Received FutureResult
[08:29:09.114] - Erased future from FutureRegistry
[08:29:09.114] result() for ClusterFuture ...
[08:29:09.114] - result already collected: FutureResult
[08:29:09.114] result() for ClusterFuture ... done
[08:29:09.114] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:09.114] A MultisessionFuture was resolved (result was not collected)
[08:29:09.114] getGlobalsAndPackages() ...
[08:29:09.114] Searching for globals...
[08:29:09.115] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:09.116] Searching for globals ... DONE
[08:29:09.116] Resolving globals: FALSE
[08:29:09.116] 
[08:29:09.116] 
[08:29:09.116] getGlobalsAndPackages() ... DONE
[08:29:09.116] run() for ‘Future’ ...
[08:29:09.116] - state: ‘created’
[08:29:09.117] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:09.130] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:09.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:09.131]   - Field: ‘node’
[08:29:09.131]   - Field: ‘label’
[08:29:09.131]   - Field: ‘local’
[08:29:09.131]   - Field: ‘owner’
[08:29:09.131]   - Field: ‘envir’
[08:29:09.131]   - Field: ‘workers’
[08:29:09.131]   - Field: ‘packages’
[08:29:09.131]   - Field: ‘gc’
[08:29:09.131]   - Field: ‘conditions’
[08:29:09.131]   - Field: ‘persistent’
[08:29:09.131]   - Field: ‘expr’
[08:29:09.132]   - Field: ‘uuid’
[08:29:09.132]   - Field: ‘seed’
[08:29:09.132]   - Field: ‘version’
[08:29:09.132]   - Field: ‘result’
[08:29:09.132]   - Field: ‘asynchronous’
[08:29:09.132]   - Field: ‘calls’
[08:29:09.132]   - Field: ‘globals’
[08:29:09.132]   - Field: ‘stdout’
[08:29:09.132]   - Field: ‘earlySignal’
[08:29:09.132]   - Field: ‘lazy’
[08:29:09.132]   - Field: ‘state’
[08:29:09.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:09.133] - Launch lazy future ...
[08:29:09.133] Packages needed by the future expression (n = 0): <none>
[08:29:09.133] Packages needed by future strategies (n = 0): <none>
[08:29:09.133] {
[08:29:09.133]     {
[08:29:09.133]         {
[08:29:09.133]             ...future.startTime <- base::Sys.time()
[08:29:09.133]             {
[08:29:09.133]                 {
[08:29:09.133]                   {
[08:29:09.133]                     {
[08:29:09.133]                       base::local({
[08:29:09.133]                         has_future <- base::requireNamespace("future", 
[08:29:09.133]                           quietly = TRUE)
[08:29:09.133]                         if (has_future) {
[08:29:09.133]                           ns <- base::getNamespace("future")
[08:29:09.133]                           version <- ns[[".package"]][["version"]]
[08:29:09.133]                           if (is.null(version)) 
[08:29:09.133]                             version <- utils::packageVersion("future")
[08:29:09.133]                         }
[08:29:09.133]                         else {
[08:29:09.133]                           version <- NULL
[08:29:09.133]                         }
[08:29:09.133]                         if (!has_future || version < "1.8.0") {
[08:29:09.133]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:09.133]                             "", base::R.version$version.string), 
[08:29:09.133]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:09.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:09.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:09.133]                               "release", "version")], collapse = " "), 
[08:29:09.133]                             hostname = base::Sys.info()[["nodename"]])
[08:29:09.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:09.133]                             info)
[08:29:09.133]                           info <- base::paste(info, collapse = "; ")
[08:29:09.133]                           if (!has_future) {
[08:29:09.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:09.133]                               info)
[08:29:09.133]                           }
[08:29:09.133]                           else {
[08:29:09.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:09.133]                               info, version)
[08:29:09.133]                           }
[08:29:09.133]                           base::stop(msg)
[08:29:09.133]                         }
[08:29:09.133]                       })
[08:29:09.133]                     }
[08:29:09.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:09.133]                     base::options(mc.cores = 1L)
[08:29:09.133]                   }
[08:29:09.133]                   ...future.strategy.old <- future::plan("list")
[08:29:09.133]                   options(future.plan = NULL)
[08:29:09.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:09.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:09.133]                 }
[08:29:09.133]                 ...future.workdir <- getwd()
[08:29:09.133]             }
[08:29:09.133]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:09.133]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:09.133]         }
[08:29:09.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:09.133]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:09.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:09.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:09.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:09.133]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:09.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:09.133]             base::names(...future.oldOptions))
[08:29:09.133]     }
[08:29:09.133]     if (FALSE) {
[08:29:09.133]     }
[08:29:09.133]     else {
[08:29:09.133]         if (TRUE) {
[08:29:09.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:09.133]                 open = "w")
[08:29:09.133]         }
[08:29:09.133]         else {
[08:29:09.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:09.133]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:09.133]         }
[08:29:09.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:09.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:09.133]             base::sink(type = "output", split = FALSE)
[08:29:09.133]             base::close(...future.stdout)
[08:29:09.133]         }, add = TRUE)
[08:29:09.133]     }
[08:29:09.133]     ...future.frame <- base::sys.nframe()
[08:29:09.133]     ...future.conditions <- base::list()
[08:29:09.133]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:09.133]     if (FALSE) {
[08:29:09.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:09.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:09.133]     }
[08:29:09.133]     ...future.result <- base::tryCatch({
[08:29:09.133]         base::withCallingHandlers({
[08:29:09.133]             ...future.value <- base::withVisible(base::local({
[08:29:09.133]                 ...future.makeSendCondition <- base::local({
[08:29:09.133]                   sendCondition <- NULL
[08:29:09.133]                   function(frame = 1L) {
[08:29:09.133]                     if (is.function(sendCondition)) 
[08:29:09.133]                       return(sendCondition)
[08:29:09.133]                     ns <- getNamespace("parallel")
[08:29:09.133]                     if (exists("sendData", mode = "function", 
[08:29:09.133]                       envir = ns)) {
[08:29:09.133]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:09.133]                         envir = ns)
[08:29:09.133]                       envir <- sys.frame(frame)
[08:29:09.133]                       master <- NULL
[08:29:09.133]                       while (!identical(envir, .GlobalEnv) && 
[08:29:09.133]                         !identical(envir, emptyenv())) {
[08:29:09.133]                         if (exists("master", mode = "list", envir = envir, 
[08:29:09.133]                           inherits = FALSE)) {
[08:29:09.133]                           master <- get("master", mode = "list", 
[08:29:09.133]                             envir = envir, inherits = FALSE)
[08:29:09.133]                           if (inherits(master, c("SOCKnode", 
[08:29:09.133]                             "SOCK0node"))) {
[08:29:09.133]                             sendCondition <<- function(cond) {
[08:29:09.133]                               data <- list(type = "VALUE", value = cond, 
[08:29:09.133]                                 success = TRUE)
[08:29:09.133]                               parallel_sendData(master, data)
[08:29:09.133]                             }
[08:29:09.133]                             return(sendCondition)
[08:29:09.133]                           }
[08:29:09.133]                         }
[08:29:09.133]                         frame <- frame + 1L
[08:29:09.133]                         envir <- sys.frame(frame)
[08:29:09.133]                       }
[08:29:09.133]                     }
[08:29:09.133]                     sendCondition <<- function(cond) NULL
[08:29:09.133]                   }
[08:29:09.133]                 })
[08:29:09.133]                 withCallingHandlers({
[08:29:09.133]                   {
[08:29:09.133]                     Sys.sleep(0.5)
[08:29:09.133]                     list(a = 1, b = 42L)
[08:29:09.133]                   }
[08:29:09.133]                 }, immediateCondition = function(cond) {
[08:29:09.133]                   sendCondition <- ...future.makeSendCondition()
[08:29:09.133]                   sendCondition(cond)
[08:29:09.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.133]                   {
[08:29:09.133]                     inherits <- base::inherits
[08:29:09.133]                     invokeRestart <- base::invokeRestart
[08:29:09.133]                     is.null <- base::is.null
[08:29:09.133]                     muffled <- FALSE
[08:29:09.133]                     if (inherits(cond, "message")) {
[08:29:09.133]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:09.133]                       if (muffled) 
[08:29:09.133]                         invokeRestart("muffleMessage")
[08:29:09.133]                     }
[08:29:09.133]                     else if (inherits(cond, "warning")) {
[08:29:09.133]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:09.133]                       if (muffled) 
[08:29:09.133]                         invokeRestart("muffleWarning")
[08:29:09.133]                     }
[08:29:09.133]                     else if (inherits(cond, "condition")) {
[08:29:09.133]                       if (!is.null(pattern)) {
[08:29:09.133]                         computeRestarts <- base::computeRestarts
[08:29:09.133]                         grepl <- base::grepl
[08:29:09.133]                         restarts <- computeRestarts(cond)
[08:29:09.133]                         for (restart in restarts) {
[08:29:09.133]                           name <- restart$name
[08:29:09.133]                           if (is.null(name)) 
[08:29:09.133]                             next
[08:29:09.133]                           if (!grepl(pattern, name)) 
[08:29:09.133]                             next
[08:29:09.133]                           invokeRestart(restart)
[08:29:09.133]                           muffled <- TRUE
[08:29:09.133]                           break
[08:29:09.133]                         }
[08:29:09.133]                       }
[08:29:09.133]                     }
[08:29:09.133]                     invisible(muffled)
[08:29:09.133]                   }
[08:29:09.133]                   muffleCondition(cond)
[08:29:09.133]                 })
[08:29:09.133]             }))
[08:29:09.133]             future::FutureResult(value = ...future.value$value, 
[08:29:09.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:09.133]                   ...future.rng), globalenv = if (FALSE) 
[08:29:09.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:09.133]                     ...future.globalenv.names))
[08:29:09.133]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:09.133]         }, condition = base::local({
[08:29:09.133]             c <- base::c
[08:29:09.133]             inherits <- base::inherits
[08:29:09.133]             invokeRestart <- base::invokeRestart
[08:29:09.133]             length <- base::length
[08:29:09.133]             list <- base::list
[08:29:09.133]             seq.int <- base::seq.int
[08:29:09.133]             signalCondition <- base::signalCondition
[08:29:09.133]             sys.calls <- base::sys.calls
[08:29:09.133]             `[[` <- base::`[[`
[08:29:09.133]             `+` <- base::`+`
[08:29:09.133]             `<<-` <- base::`<<-`
[08:29:09.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:09.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:09.133]                   3L)]
[08:29:09.133]             }
[08:29:09.133]             function(cond) {
[08:29:09.133]                 is_error <- inherits(cond, "error")
[08:29:09.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:09.133]                   NULL)
[08:29:09.133]                 if (is_error) {
[08:29:09.133]                   sessionInformation <- function() {
[08:29:09.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:09.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:09.133]                       search = base::search(), system = base::Sys.info())
[08:29:09.133]                   }
[08:29:09.133]                   ...future.conditions[[length(...future.conditions) + 
[08:29:09.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:09.133]                     cond$call), session = sessionInformation(), 
[08:29:09.133]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:09.133]                   signalCondition(cond)
[08:29:09.133]                 }
[08:29:09.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:09.133]                 "immediateCondition"))) {
[08:29:09.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:09.133]                   ...future.conditions[[length(...future.conditions) + 
[08:29:09.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:09.133]                   if (TRUE && !signal) {
[08:29:09.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.133]                     {
[08:29:09.133]                       inherits <- base::inherits
[08:29:09.133]                       invokeRestart <- base::invokeRestart
[08:29:09.133]                       is.null <- base::is.null
[08:29:09.133]                       muffled <- FALSE
[08:29:09.133]                       if (inherits(cond, "message")) {
[08:29:09.133]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:09.133]                         if (muffled) 
[08:29:09.133]                           invokeRestart("muffleMessage")
[08:29:09.133]                       }
[08:29:09.133]                       else if (inherits(cond, "warning")) {
[08:29:09.133]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:09.133]                         if (muffled) 
[08:29:09.133]                           invokeRestart("muffleWarning")
[08:29:09.133]                       }
[08:29:09.133]                       else if (inherits(cond, "condition")) {
[08:29:09.133]                         if (!is.null(pattern)) {
[08:29:09.133]                           computeRestarts <- base::computeRestarts
[08:29:09.133]                           grepl <- base::grepl
[08:29:09.133]                           restarts <- computeRestarts(cond)
[08:29:09.133]                           for (restart in restarts) {
[08:29:09.133]                             name <- restart$name
[08:29:09.133]                             if (is.null(name)) 
[08:29:09.133]                               next
[08:29:09.133]                             if (!grepl(pattern, name)) 
[08:29:09.133]                               next
[08:29:09.133]                             invokeRestart(restart)
[08:29:09.133]                             muffled <- TRUE
[08:29:09.133]                             break
[08:29:09.133]                           }
[08:29:09.133]                         }
[08:29:09.133]                       }
[08:29:09.133]                       invisible(muffled)
[08:29:09.133]                     }
[08:29:09.133]                     muffleCondition(cond, pattern = "^muffle")
[08:29:09.133]                   }
[08:29:09.133]                 }
[08:29:09.133]                 else {
[08:29:09.133]                   if (TRUE) {
[08:29:09.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.133]                     {
[08:29:09.133]                       inherits <- base::inherits
[08:29:09.133]                       invokeRestart <- base::invokeRestart
[08:29:09.133]                       is.null <- base::is.null
[08:29:09.133]                       muffled <- FALSE
[08:29:09.133]                       if (inherits(cond, "message")) {
[08:29:09.133]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:09.133]                         if (muffled) 
[08:29:09.133]                           invokeRestart("muffleMessage")
[08:29:09.133]                       }
[08:29:09.133]                       else if (inherits(cond, "warning")) {
[08:29:09.133]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:09.133]                         if (muffled) 
[08:29:09.133]                           invokeRestart("muffleWarning")
[08:29:09.133]                       }
[08:29:09.133]                       else if (inherits(cond, "condition")) {
[08:29:09.133]                         if (!is.null(pattern)) {
[08:29:09.133]                           computeRestarts <- base::computeRestarts
[08:29:09.133]                           grepl <- base::grepl
[08:29:09.133]                           restarts <- computeRestarts(cond)
[08:29:09.133]                           for (restart in restarts) {
[08:29:09.133]                             name <- restart$name
[08:29:09.133]                             if (is.null(name)) 
[08:29:09.133]                               next
[08:29:09.133]                             if (!grepl(pattern, name)) 
[08:29:09.133]                               next
[08:29:09.133]                             invokeRestart(restart)
[08:29:09.133]                             muffled <- TRUE
[08:29:09.133]                             break
[08:29:09.133]                           }
[08:29:09.133]                         }
[08:29:09.133]                       }
[08:29:09.133]                       invisible(muffled)
[08:29:09.133]                     }
[08:29:09.133]                     muffleCondition(cond, pattern = "^muffle")
[08:29:09.133]                   }
[08:29:09.133]                 }
[08:29:09.133]             }
[08:29:09.133]         }))
[08:29:09.133]     }, error = function(ex) {
[08:29:09.133]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:09.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:09.133]                 ...future.rng), started = ...future.startTime, 
[08:29:09.133]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:09.133]             version = "1.8"), class = "FutureResult")
[08:29:09.133]     }, finally = {
[08:29:09.133]         if (!identical(...future.workdir, getwd())) 
[08:29:09.133]             setwd(...future.workdir)
[08:29:09.133]         {
[08:29:09.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:09.133]                 ...future.oldOptions$nwarnings <- NULL
[08:29:09.133]             }
[08:29:09.133]             base::options(...future.oldOptions)
[08:29:09.133]             if (.Platform$OS.type == "windows") {
[08:29:09.133]                 old_names <- names(...future.oldEnvVars)
[08:29:09.133]                 envs <- base::Sys.getenv()
[08:29:09.133]                 names <- names(envs)
[08:29:09.133]                 common <- intersect(names, old_names)
[08:29:09.133]                 added <- setdiff(names, old_names)
[08:29:09.133]                 removed <- setdiff(old_names, names)
[08:29:09.133]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:09.133]                   envs[common]]
[08:29:09.133]                 NAMES <- toupper(changed)
[08:29:09.133]                 args <- list()
[08:29:09.133]                 for (kk in seq_along(NAMES)) {
[08:29:09.133]                   name <- changed[[kk]]
[08:29:09.133]                   NAME <- NAMES[[kk]]
[08:29:09.133]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.133]                     next
[08:29:09.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:09.133]                 }
[08:29:09.133]                 NAMES <- toupper(added)
[08:29:09.133]                 for (kk in seq_along(NAMES)) {
[08:29:09.133]                   name <- added[[kk]]
[08:29:09.133]                   NAME <- NAMES[[kk]]
[08:29:09.133]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.133]                     next
[08:29:09.133]                   args[[name]] <- ""
[08:29:09.133]                 }
[08:29:09.133]                 NAMES <- toupper(removed)
[08:29:09.133]                 for (kk in seq_along(NAMES)) {
[08:29:09.133]                   name <- removed[[kk]]
[08:29:09.133]                   NAME <- NAMES[[kk]]
[08:29:09.133]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.133]                     next
[08:29:09.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:09.133]                 }
[08:29:09.133]                 if (length(args) > 0) 
[08:29:09.133]                   base::do.call(base::Sys.setenv, args = args)
[08:29:09.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:09.133]             }
[08:29:09.133]             else {
[08:29:09.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:09.133]             }
[08:29:09.133]             {
[08:29:09.133]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:09.133]                   0L) {
[08:29:09.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:09.133]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:09.133]                   base::options(opts)
[08:29:09.133]                 }
[08:29:09.133]                 {
[08:29:09.133]                   {
[08:29:09.133]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:09.133]                     NULL
[08:29:09.133]                   }
[08:29:09.133]                   options(future.plan = NULL)
[08:29:09.133]                   if (is.na(NA_character_)) 
[08:29:09.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:09.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:09.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:09.133]                     .init = FALSE)
[08:29:09.133]                 }
[08:29:09.133]             }
[08:29:09.133]         }
[08:29:09.133]     })
[08:29:09.133]     if (TRUE) {
[08:29:09.133]         base::sink(type = "output", split = FALSE)
[08:29:09.133]         if (TRUE) {
[08:29:09.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:09.133]         }
[08:29:09.133]         else {
[08:29:09.133]             ...future.result["stdout"] <- base::list(NULL)
[08:29:09.133]         }
[08:29:09.133]         base::close(...future.stdout)
[08:29:09.133]         ...future.stdout <- NULL
[08:29:09.133]     }
[08:29:09.133]     ...future.result$conditions <- ...future.conditions
[08:29:09.133]     ...future.result$finished <- base::Sys.time()
[08:29:09.133]     ...future.result
[08:29:09.133] }
[08:29:09.136] MultisessionFuture started
[08:29:09.136] - Launch lazy future ... done
[08:29:09.136] run() for ‘MultisessionFuture’ ... done
[08:29:09.679] receiveMessageFromWorker() for ClusterFuture ...
[08:29:09.679] - Validating connection of MultisessionFuture
[08:29:09.679] - received message: FutureResult
[08:29:09.679] - Received FutureResult
[08:29:09.679] - Erased future from FutureRegistry
[08:29:09.679] result() for ClusterFuture ...
[08:29:09.679] - result already collected: FutureResult
[08:29:09.679] result() for ClusterFuture ... done
[08:29:09.680] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:09.680] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[08:29:09.680] getGlobalsAndPackages() ...
[08:29:09.680] Searching for globals...
[08:29:09.681] - globals found: [2] ‘list’, ‘stop’
[08:29:09.681] Searching for globals ... DONE
[08:29:09.681] Resolving globals: FALSE
[08:29:09.681] 
[08:29:09.681] 
[08:29:09.681] getGlobalsAndPackages() ... DONE
[08:29:09.681] run() for ‘Future’ ...
[08:29:09.682] - state: ‘created’
[08:29:09.682] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:09.695] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:09.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:09.696]   - Field: ‘node’
[08:29:09.696]   - Field: ‘label’
[08:29:09.696]   - Field: ‘local’
[08:29:09.696]   - Field: ‘owner’
[08:29:09.696]   - Field: ‘envir’
[08:29:09.696]   - Field: ‘workers’
[08:29:09.696]   - Field: ‘packages’
[08:29:09.696]   - Field: ‘gc’
[08:29:09.696]   - Field: ‘conditions’
[08:29:09.697]   - Field: ‘persistent’
[08:29:09.697]   - Field: ‘expr’
[08:29:09.697]   - Field: ‘uuid’
[08:29:09.697]   - Field: ‘seed’
[08:29:09.697]   - Field: ‘version’
[08:29:09.697]   - Field: ‘result’
[08:29:09.697]   - Field: ‘asynchronous’
[08:29:09.697]   - Field: ‘calls’
[08:29:09.697]   - Field: ‘globals’
[08:29:09.697]   - Field: ‘stdout’
[08:29:09.697]   - Field: ‘earlySignal’
[08:29:09.697]   - Field: ‘lazy’
[08:29:09.698]   - Field: ‘state’
[08:29:09.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:09.698] - Launch lazy future ...
[08:29:09.698] Packages needed by the future expression (n = 0): <none>
[08:29:09.698] Packages needed by future strategies (n = 0): <none>
[08:29:09.698] {
[08:29:09.698]     {
[08:29:09.698]         {
[08:29:09.698]             ...future.startTime <- base::Sys.time()
[08:29:09.698]             {
[08:29:09.698]                 {
[08:29:09.698]                   {
[08:29:09.698]                     {
[08:29:09.698]                       base::local({
[08:29:09.698]                         has_future <- base::requireNamespace("future", 
[08:29:09.698]                           quietly = TRUE)
[08:29:09.698]                         if (has_future) {
[08:29:09.698]                           ns <- base::getNamespace("future")
[08:29:09.698]                           version <- ns[[".package"]][["version"]]
[08:29:09.698]                           if (is.null(version)) 
[08:29:09.698]                             version <- utils::packageVersion("future")
[08:29:09.698]                         }
[08:29:09.698]                         else {
[08:29:09.698]                           version <- NULL
[08:29:09.698]                         }
[08:29:09.698]                         if (!has_future || version < "1.8.0") {
[08:29:09.698]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:09.698]                             "", base::R.version$version.string), 
[08:29:09.698]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:09.698]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:09.698]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:09.698]                               "release", "version")], collapse = " "), 
[08:29:09.698]                             hostname = base::Sys.info()[["nodename"]])
[08:29:09.698]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:09.698]                             info)
[08:29:09.698]                           info <- base::paste(info, collapse = "; ")
[08:29:09.698]                           if (!has_future) {
[08:29:09.698]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:09.698]                               info)
[08:29:09.698]                           }
[08:29:09.698]                           else {
[08:29:09.698]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:09.698]                               info, version)
[08:29:09.698]                           }
[08:29:09.698]                           base::stop(msg)
[08:29:09.698]                         }
[08:29:09.698]                       })
[08:29:09.698]                     }
[08:29:09.698]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:09.698]                     base::options(mc.cores = 1L)
[08:29:09.698]                   }
[08:29:09.698]                   ...future.strategy.old <- future::plan("list")
[08:29:09.698]                   options(future.plan = NULL)
[08:29:09.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:09.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:09.698]                 }
[08:29:09.698]                 ...future.workdir <- getwd()
[08:29:09.698]             }
[08:29:09.698]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:09.698]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:09.698]         }
[08:29:09.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:09.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:09.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:09.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:09.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:09.698]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:09.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:09.698]             base::names(...future.oldOptions))
[08:29:09.698]     }
[08:29:09.698]     if (FALSE) {
[08:29:09.698]     }
[08:29:09.698]     else {
[08:29:09.698]         if (TRUE) {
[08:29:09.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:09.698]                 open = "w")
[08:29:09.698]         }
[08:29:09.698]         else {
[08:29:09.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:09.698]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:09.698]         }
[08:29:09.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:09.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:09.698]             base::sink(type = "output", split = FALSE)
[08:29:09.698]             base::close(...future.stdout)
[08:29:09.698]         }, add = TRUE)
[08:29:09.698]     }
[08:29:09.698]     ...future.frame <- base::sys.nframe()
[08:29:09.698]     ...future.conditions <- base::list()
[08:29:09.698]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:09.698]     if (FALSE) {
[08:29:09.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:09.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:09.698]     }
[08:29:09.698]     ...future.result <- base::tryCatch({
[08:29:09.698]         base::withCallingHandlers({
[08:29:09.698]             ...future.value <- base::withVisible(base::local({
[08:29:09.698]                 ...future.makeSendCondition <- base::local({
[08:29:09.698]                   sendCondition <- NULL
[08:29:09.698]                   function(frame = 1L) {
[08:29:09.698]                     if (is.function(sendCondition)) 
[08:29:09.698]                       return(sendCondition)
[08:29:09.698]                     ns <- getNamespace("parallel")
[08:29:09.698]                     if (exists("sendData", mode = "function", 
[08:29:09.698]                       envir = ns)) {
[08:29:09.698]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:09.698]                         envir = ns)
[08:29:09.698]                       envir <- sys.frame(frame)
[08:29:09.698]                       master <- NULL
[08:29:09.698]                       while (!identical(envir, .GlobalEnv) && 
[08:29:09.698]                         !identical(envir, emptyenv())) {
[08:29:09.698]                         if (exists("master", mode = "list", envir = envir, 
[08:29:09.698]                           inherits = FALSE)) {
[08:29:09.698]                           master <- get("master", mode = "list", 
[08:29:09.698]                             envir = envir, inherits = FALSE)
[08:29:09.698]                           if (inherits(master, c("SOCKnode", 
[08:29:09.698]                             "SOCK0node"))) {
[08:29:09.698]                             sendCondition <<- function(cond) {
[08:29:09.698]                               data <- list(type = "VALUE", value = cond, 
[08:29:09.698]                                 success = TRUE)
[08:29:09.698]                               parallel_sendData(master, data)
[08:29:09.698]                             }
[08:29:09.698]                             return(sendCondition)
[08:29:09.698]                           }
[08:29:09.698]                         }
[08:29:09.698]                         frame <- frame + 1L
[08:29:09.698]                         envir <- sys.frame(frame)
[08:29:09.698]                       }
[08:29:09.698]                     }
[08:29:09.698]                     sendCondition <<- function(cond) NULL
[08:29:09.698]                   }
[08:29:09.698]                 })
[08:29:09.698]                 withCallingHandlers({
[08:29:09.698]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:09.698]                 }, immediateCondition = function(cond) {
[08:29:09.698]                   sendCondition <- ...future.makeSendCondition()
[08:29:09.698]                   sendCondition(cond)
[08:29:09.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.698]                   {
[08:29:09.698]                     inherits <- base::inherits
[08:29:09.698]                     invokeRestart <- base::invokeRestart
[08:29:09.698]                     is.null <- base::is.null
[08:29:09.698]                     muffled <- FALSE
[08:29:09.698]                     if (inherits(cond, "message")) {
[08:29:09.698]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:09.698]                       if (muffled) 
[08:29:09.698]                         invokeRestart("muffleMessage")
[08:29:09.698]                     }
[08:29:09.698]                     else if (inherits(cond, "warning")) {
[08:29:09.698]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:09.698]                       if (muffled) 
[08:29:09.698]                         invokeRestart("muffleWarning")
[08:29:09.698]                     }
[08:29:09.698]                     else if (inherits(cond, "condition")) {
[08:29:09.698]                       if (!is.null(pattern)) {
[08:29:09.698]                         computeRestarts <- base::computeRestarts
[08:29:09.698]                         grepl <- base::grepl
[08:29:09.698]                         restarts <- computeRestarts(cond)
[08:29:09.698]                         for (restart in restarts) {
[08:29:09.698]                           name <- restart$name
[08:29:09.698]                           if (is.null(name)) 
[08:29:09.698]                             next
[08:29:09.698]                           if (!grepl(pattern, name)) 
[08:29:09.698]                             next
[08:29:09.698]                           invokeRestart(restart)
[08:29:09.698]                           muffled <- TRUE
[08:29:09.698]                           break
[08:29:09.698]                         }
[08:29:09.698]                       }
[08:29:09.698]                     }
[08:29:09.698]                     invisible(muffled)
[08:29:09.698]                   }
[08:29:09.698]                   muffleCondition(cond)
[08:29:09.698]                 })
[08:29:09.698]             }))
[08:29:09.698]             future::FutureResult(value = ...future.value$value, 
[08:29:09.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:09.698]                   ...future.rng), globalenv = if (FALSE) 
[08:29:09.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:09.698]                     ...future.globalenv.names))
[08:29:09.698]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:09.698]         }, condition = base::local({
[08:29:09.698]             c <- base::c
[08:29:09.698]             inherits <- base::inherits
[08:29:09.698]             invokeRestart <- base::invokeRestart
[08:29:09.698]             length <- base::length
[08:29:09.698]             list <- base::list
[08:29:09.698]             seq.int <- base::seq.int
[08:29:09.698]             signalCondition <- base::signalCondition
[08:29:09.698]             sys.calls <- base::sys.calls
[08:29:09.698]             `[[` <- base::`[[`
[08:29:09.698]             `+` <- base::`+`
[08:29:09.698]             `<<-` <- base::`<<-`
[08:29:09.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:09.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:09.698]                   3L)]
[08:29:09.698]             }
[08:29:09.698]             function(cond) {
[08:29:09.698]                 is_error <- inherits(cond, "error")
[08:29:09.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:09.698]                   NULL)
[08:29:09.698]                 if (is_error) {
[08:29:09.698]                   sessionInformation <- function() {
[08:29:09.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:09.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:09.698]                       search = base::search(), system = base::Sys.info())
[08:29:09.698]                   }
[08:29:09.698]                   ...future.conditions[[length(...future.conditions) + 
[08:29:09.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:09.698]                     cond$call), session = sessionInformation(), 
[08:29:09.698]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:09.698]                   signalCondition(cond)
[08:29:09.698]                 }
[08:29:09.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:09.698]                 "immediateCondition"))) {
[08:29:09.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:09.698]                   ...future.conditions[[length(...future.conditions) + 
[08:29:09.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:09.698]                   if (TRUE && !signal) {
[08:29:09.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.698]                     {
[08:29:09.698]                       inherits <- base::inherits
[08:29:09.698]                       invokeRestart <- base::invokeRestart
[08:29:09.698]                       is.null <- base::is.null
[08:29:09.698]                       muffled <- FALSE
[08:29:09.698]                       if (inherits(cond, "message")) {
[08:29:09.698]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:09.698]                         if (muffled) 
[08:29:09.698]                           invokeRestart("muffleMessage")
[08:29:09.698]                       }
[08:29:09.698]                       else if (inherits(cond, "warning")) {
[08:29:09.698]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:09.698]                         if (muffled) 
[08:29:09.698]                           invokeRestart("muffleWarning")
[08:29:09.698]                       }
[08:29:09.698]                       else if (inherits(cond, "condition")) {
[08:29:09.698]                         if (!is.null(pattern)) {
[08:29:09.698]                           computeRestarts <- base::computeRestarts
[08:29:09.698]                           grepl <- base::grepl
[08:29:09.698]                           restarts <- computeRestarts(cond)
[08:29:09.698]                           for (restart in restarts) {
[08:29:09.698]                             name <- restart$name
[08:29:09.698]                             if (is.null(name)) 
[08:29:09.698]                               next
[08:29:09.698]                             if (!grepl(pattern, name)) 
[08:29:09.698]                               next
[08:29:09.698]                             invokeRestart(restart)
[08:29:09.698]                             muffled <- TRUE
[08:29:09.698]                             break
[08:29:09.698]                           }
[08:29:09.698]                         }
[08:29:09.698]                       }
[08:29:09.698]                       invisible(muffled)
[08:29:09.698]                     }
[08:29:09.698]                     muffleCondition(cond, pattern = "^muffle")
[08:29:09.698]                   }
[08:29:09.698]                 }
[08:29:09.698]                 else {
[08:29:09.698]                   if (TRUE) {
[08:29:09.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.698]                     {
[08:29:09.698]                       inherits <- base::inherits
[08:29:09.698]                       invokeRestart <- base::invokeRestart
[08:29:09.698]                       is.null <- base::is.null
[08:29:09.698]                       muffled <- FALSE
[08:29:09.698]                       if (inherits(cond, "message")) {
[08:29:09.698]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:09.698]                         if (muffled) 
[08:29:09.698]                           invokeRestart("muffleMessage")
[08:29:09.698]                       }
[08:29:09.698]                       else if (inherits(cond, "warning")) {
[08:29:09.698]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:09.698]                         if (muffled) 
[08:29:09.698]                           invokeRestart("muffleWarning")
[08:29:09.698]                       }
[08:29:09.698]                       else if (inherits(cond, "condition")) {
[08:29:09.698]                         if (!is.null(pattern)) {
[08:29:09.698]                           computeRestarts <- base::computeRestarts
[08:29:09.698]                           grepl <- base::grepl
[08:29:09.698]                           restarts <- computeRestarts(cond)
[08:29:09.698]                           for (restart in restarts) {
[08:29:09.698]                             name <- restart$name
[08:29:09.698]                             if (is.null(name)) 
[08:29:09.698]                               next
[08:29:09.698]                             if (!grepl(pattern, name)) 
[08:29:09.698]                               next
[08:29:09.698]                             invokeRestart(restart)
[08:29:09.698]                             muffled <- TRUE
[08:29:09.698]                             break
[08:29:09.698]                           }
[08:29:09.698]                         }
[08:29:09.698]                       }
[08:29:09.698]                       invisible(muffled)
[08:29:09.698]                     }
[08:29:09.698]                     muffleCondition(cond, pattern = "^muffle")
[08:29:09.698]                   }
[08:29:09.698]                 }
[08:29:09.698]             }
[08:29:09.698]         }))
[08:29:09.698]     }, error = function(ex) {
[08:29:09.698]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:09.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:09.698]                 ...future.rng), started = ...future.startTime, 
[08:29:09.698]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:09.698]             version = "1.8"), class = "FutureResult")
[08:29:09.698]     }, finally = {
[08:29:09.698]         if (!identical(...future.workdir, getwd())) 
[08:29:09.698]             setwd(...future.workdir)
[08:29:09.698]         {
[08:29:09.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:09.698]                 ...future.oldOptions$nwarnings <- NULL
[08:29:09.698]             }
[08:29:09.698]             base::options(...future.oldOptions)
[08:29:09.698]             if (.Platform$OS.type == "windows") {
[08:29:09.698]                 old_names <- names(...future.oldEnvVars)
[08:29:09.698]                 envs <- base::Sys.getenv()
[08:29:09.698]                 names <- names(envs)
[08:29:09.698]                 common <- intersect(names, old_names)
[08:29:09.698]                 added <- setdiff(names, old_names)
[08:29:09.698]                 removed <- setdiff(old_names, names)
[08:29:09.698]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:09.698]                   envs[common]]
[08:29:09.698]                 NAMES <- toupper(changed)
[08:29:09.698]                 args <- list()
[08:29:09.698]                 for (kk in seq_along(NAMES)) {
[08:29:09.698]                   name <- changed[[kk]]
[08:29:09.698]                   NAME <- NAMES[[kk]]
[08:29:09.698]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.698]                     next
[08:29:09.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:09.698]                 }
[08:29:09.698]                 NAMES <- toupper(added)
[08:29:09.698]                 for (kk in seq_along(NAMES)) {
[08:29:09.698]                   name <- added[[kk]]
[08:29:09.698]                   NAME <- NAMES[[kk]]
[08:29:09.698]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.698]                     next
[08:29:09.698]                   args[[name]] <- ""
[08:29:09.698]                 }
[08:29:09.698]                 NAMES <- toupper(removed)
[08:29:09.698]                 for (kk in seq_along(NAMES)) {
[08:29:09.698]                   name <- removed[[kk]]
[08:29:09.698]                   NAME <- NAMES[[kk]]
[08:29:09.698]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.698]                     next
[08:29:09.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:09.698]                 }
[08:29:09.698]                 if (length(args) > 0) 
[08:29:09.698]                   base::do.call(base::Sys.setenv, args = args)
[08:29:09.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:09.698]             }
[08:29:09.698]             else {
[08:29:09.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:09.698]             }
[08:29:09.698]             {
[08:29:09.698]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:09.698]                   0L) {
[08:29:09.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:09.698]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:09.698]                   base::options(opts)
[08:29:09.698]                 }
[08:29:09.698]                 {
[08:29:09.698]                   {
[08:29:09.698]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:09.698]                     NULL
[08:29:09.698]                   }
[08:29:09.698]                   options(future.plan = NULL)
[08:29:09.698]                   if (is.na(NA_character_)) 
[08:29:09.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:09.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:09.698]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:09.698]                     .init = FALSE)
[08:29:09.698]                 }
[08:29:09.698]             }
[08:29:09.698]         }
[08:29:09.698]     })
[08:29:09.698]     if (TRUE) {
[08:29:09.698]         base::sink(type = "output", split = FALSE)
[08:29:09.698]         if (TRUE) {
[08:29:09.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:09.698]         }
[08:29:09.698]         else {
[08:29:09.698]             ...future.result["stdout"] <- base::list(NULL)
[08:29:09.698]         }
[08:29:09.698]         base::close(...future.stdout)
[08:29:09.698]         ...future.stdout <- NULL
[08:29:09.698]     }
[08:29:09.698]     ...future.result$conditions <- ...future.conditions
[08:29:09.698]     ...future.result$finished <- base::Sys.time()
[08:29:09.698]     ...future.result
[08:29:09.698] }
[08:29:09.701] MultisessionFuture started
[08:29:09.701] - Launch lazy future ... done
[08:29:09.702] run() for ‘MultisessionFuture’ ... done
[08:29:09.743] receiveMessageFromWorker() for ClusterFuture ...
[08:29:09.743] - Validating connection of MultisessionFuture
[08:29:09.744] - received message: FutureResult
[08:29:09.744] - Received FutureResult
[08:29:09.744] - Erased future from FutureRegistry
[08:29:09.744] result() for ClusterFuture ...
[08:29:09.744] - result already collected: FutureResult
[08:29:09.744] result() for ClusterFuture ... done
[08:29:09.744] signalConditions() ...
[08:29:09.744]  - include = ‘immediateCondition’
[08:29:09.744]  - exclude = 
[08:29:09.744]  - resignal = FALSE
[08:29:09.745]  - Number of conditions: 1
[08:29:09.745] signalConditions() ... done
[08:29:09.745] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:09.745] A MultisessionFuture was resolved (result was not collected)
[08:29:09.745] getGlobalsAndPackages() ...
[08:29:09.745] Searching for globals...
[08:29:09.746] - globals found: [2] ‘list’, ‘stop’
[08:29:09.746] Searching for globals ... DONE
[08:29:09.746] Resolving globals: FALSE
[08:29:09.746] 
[08:29:09.746] 
[08:29:09.746] getGlobalsAndPackages() ... DONE
[08:29:09.747] run() for ‘Future’ ...
[08:29:09.747] - state: ‘created’
[08:29:09.747] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:09.760] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:09.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:09.760]   - Field: ‘node’
[08:29:09.761]   - Field: ‘label’
[08:29:09.761]   - Field: ‘local’
[08:29:09.761]   - Field: ‘owner’
[08:29:09.761]   - Field: ‘envir’
[08:29:09.761]   - Field: ‘workers’
[08:29:09.761]   - Field: ‘packages’
[08:29:09.761]   - Field: ‘gc’
[08:29:09.761]   - Field: ‘conditions’
[08:29:09.761]   - Field: ‘persistent’
[08:29:09.761]   - Field: ‘expr’
[08:29:09.761]   - Field: ‘uuid’
[08:29:09.761]   - Field: ‘seed’
[08:29:09.762]   - Field: ‘version’
[08:29:09.762]   - Field: ‘result’
[08:29:09.762]   - Field: ‘asynchronous’
[08:29:09.762]   - Field: ‘calls’
[08:29:09.762]   - Field: ‘globals’
[08:29:09.762]   - Field: ‘stdout’
[08:29:09.762]   - Field: ‘earlySignal’
[08:29:09.762]   - Field: ‘lazy’
[08:29:09.762]   - Field: ‘state’
[08:29:09.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:09.762] - Launch lazy future ...
[08:29:09.763] Packages needed by the future expression (n = 0): <none>
[08:29:09.763] Packages needed by future strategies (n = 0): <none>
[08:29:09.763] {
[08:29:09.763]     {
[08:29:09.763]         {
[08:29:09.763]             ...future.startTime <- base::Sys.time()
[08:29:09.763]             {
[08:29:09.763]                 {
[08:29:09.763]                   {
[08:29:09.763]                     {
[08:29:09.763]                       base::local({
[08:29:09.763]                         has_future <- base::requireNamespace("future", 
[08:29:09.763]                           quietly = TRUE)
[08:29:09.763]                         if (has_future) {
[08:29:09.763]                           ns <- base::getNamespace("future")
[08:29:09.763]                           version <- ns[[".package"]][["version"]]
[08:29:09.763]                           if (is.null(version)) 
[08:29:09.763]                             version <- utils::packageVersion("future")
[08:29:09.763]                         }
[08:29:09.763]                         else {
[08:29:09.763]                           version <- NULL
[08:29:09.763]                         }
[08:29:09.763]                         if (!has_future || version < "1.8.0") {
[08:29:09.763]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:09.763]                             "", base::R.version$version.string), 
[08:29:09.763]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:09.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:09.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:09.763]                               "release", "version")], collapse = " "), 
[08:29:09.763]                             hostname = base::Sys.info()[["nodename"]])
[08:29:09.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:09.763]                             info)
[08:29:09.763]                           info <- base::paste(info, collapse = "; ")
[08:29:09.763]                           if (!has_future) {
[08:29:09.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:09.763]                               info)
[08:29:09.763]                           }
[08:29:09.763]                           else {
[08:29:09.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:09.763]                               info, version)
[08:29:09.763]                           }
[08:29:09.763]                           base::stop(msg)
[08:29:09.763]                         }
[08:29:09.763]                       })
[08:29:09.763]                     }
[08:29:09.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:09.763]                     base::options(mc.cores = 1L)
[08:29:09.763]                   }
[08:29:09.763]                   ...future.strategy.old <- future::plan("list")
[08:29:09.763]                   options(future.plan = NULL)
[08:29:09.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:09.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:09.763]                 }
[08:29:09.763]                 ...future.workdir <- getwd()
[08:29:09.763]             }
[08:29:09.763]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:09.763]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:09.763]         }
[08:29:09.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:09.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:09.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:09.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:09.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:09.763]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:09.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:09.763]             base::names(...future.oldOptions))
[08:29:09.763]     }
[08:29:09.763]     if (FALSE) {
[08:29:09.763]     }
[08:29:09.763]     else {
[08:29:09.763]         if (TRUE) {
[08:29:09.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:09.763]                 open = "w")
[08:29:09.763]         }
[08:29:09.763]         else {
[08:29:09.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:09.763]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:09.763]         }
[08:29:09.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:09.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:09.763]             base::sink(type = "output", split = FALSE)
[08:29:09.763]             base::close(...future.stdout)
[08:29:09.763]         }, add = TRUE)
[08:29:09.763]     }
[08:29:09.763]     ...future.frame <- base::sys.nframe()
[08:29:09.763]     ...future.conditions <- base::list()
[08:29:09.763]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:09.763]     if (FALSE) {
[08:29:09.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:09.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:09.763]     }
[08:29:09.763]     ...future.result <- base::tryCatch({
[08:29:09.763]         base::withCallingHandlers({
[08:29:09.763]             ...future.value <- base::withVisible(base::local({
[08:29:09.763]                 ...future.makeSendCondition <- base::local({
[08:29:09.763]                   sendCondition <- NULL
[08:29:09.763]                   function(frame = 1L) {
[08:29:09.763]                     if (is.function(sendCondition)) 
[08:29:09.763]                       return(sendCondition)
[08:29:09.763]                     ns <- getNamespace("parallel")
[08:29:09.763]                     if (exists("sendData", mode = "function", 
[08:29:09.763]                       envir = ns)) {
[08:29:09.763]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:09.763]                         envir = ns)
[08:29:09.763]                       envir <- sys.frame(frame)
[08:29:09.763]                       master <- NULL
[08:29:09.763]                       while (!identical(envir, .GlobalEnv) && 
[08:29:09.763]                         !identical(envir, emptyenv())) {
[08:29:09.763]                         if (exists("master", mode = "list", envir = envir, 
[08:29:09.763]                           inherits = FALSE)) {
[08:29:09.763]                           master <- get("master", mode = "list", 
[08:29:09.763]                             envir = envir, inherits = FALSE)
[08:29:09.763]                           if (inherits(master, c("SOCKnode", 
[08:29:09.763]                             "SOCK0node"))) {
[08:29:09.763]                             sendCondition <<- function(cond) {
[08:29:09.763]                               data <- list(type = "VALUE", value = cond, 
[08:29:09.763]                                 success = TRUE)
[08:29:09.763]                               parallel_sendData(master, data)
[08:29:09.763]                             }
[08:29:09.763]                             return(sendCondition)
[08:29:09.763]                           }
[08:29:09.763]                         }
[08:29:09.763]                         frame <- frame + 1L
[08:29:09.763]                         envir <- sys.frame(frame)
[08:29:09.763]                       }
[08:29:09.763]                     }
[08:29:09.763]                     sendCondition <<- function(cond) NULL
[08:29:09.763]                   }
[08:29:09.763]                 })
[08:29:09.763]                 withCallingHandlers({
[08:29:09.763]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:09.763]                 }, immediateCondition = function(cond) {
[08:29:09.763]                   sendCondition <- ...future.makeSendCondition()
[08:29:09.763]                   sendCondition(cond)
[08:29:09.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.763]                   {
[08:29:09.763]                     inherits <- base::inherits
[08:29:09.763]                     invokeRestart <- base::invokeRestart
[08:29:09.763]                     is.null <- base::is.null
[08:29:09.763]                     muffled <- FALSE
[08:29:09.763]                     if (inherits(cond, "message")) {
[08:29:09.763]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:09.763]                       if (muffled) 
[08:29:09.763]                         invokeRestart("muffleMessage")
[08:29:09.763]                     }
[08:29:09.763]                     else if (inherits(cond, "warning")) {
[08:29:09.763]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:09.763]                       if (muffled) 
[08:29:09.763]                         invokeRestart("muffleWarning")
[08:29:09.763]                     }
[08:29:09.763]                     else if (inherits(cond, "condition")) {
[08:29:09.763]                       if (!is.null(pattern)) {
[08:29:09.763]                         computeRestarts <- base::computeRestarts
[08:29:09.763]                         grepl <- base::grepl
[08:29:09.763]                         restarts <- computeRestarts(cond)
[08:29:09.763]                         for (restart in restarts) {
[08:29:09.763]                           name <- restart$name
[08:29:09.763]                           if (is.null(name)) 
[08:29:09.763]                             next
[08:29:09.763]                           if (!grepl(pattern, name)) 
[08:29:09.763]                             next
[08:29:09.763]                           invokeRestart(restart)
[08:29:09.763]                           muffled <- TRUE
[08:29:09.763]                           break
[08:29:09.763]                         }
[08:29:09.763]                       }
[08:29:09.763]                     }
[08:29:09.763]                     invisible(muffled)
[08:29:09.763]                   }
[08:29:09.763]                   muffleCondition(cond)
[08:29:09.763]                 })
[08:29:09.763]             }))
[08:29:09.763]             future::FutureResult(value = ...future.value$value, 
[08:29:09.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:09.763]                   ...future.rng), globalenv = if (FALSE) 
[08:29:09.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:09.763]                     ...future.globalenv.names))
[08:29:09.763]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:09.763]         }, condition = base::local({
[08:29:09.763]             c <- base::c
[08:29:09.763]             inherits <- base::inherits
[08:29:09.763]             invokeRestart <- base::invokeRestart
[08:29:09.763]             length <- base::length
[08:29:09.763]             list <- base::list
[08:29:09.763]             seq.int <- base::seq.int
[08:29:09.763]             signalCondition <- base::signalCondition
[08:29:09.763]             sys.calls <- base::sys.calls
[08:29:09.763]             `[[` <- base::`[[`
[08:29:09.763]             `+` <- base::`+`
[08:29:09.763]             `<<-` <- base::`<<-`
[08:29:09.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:09.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:09.763]                   3L)]
[08:29:09.763]             }
[08:29:09.763]             function(cond) {
[08:29:09.763]                 is_error <- inherits(cond, "error")
[08:29:09.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:09.763]                   NULL)
[08:29:09.763]                 if (is_error) {
[08:29:09.763]                   sessionInformation <- function() {
[08:29:09.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:09.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:09.763]                       search = base::search(), system = base::Sys.info())
[08:29:09.763]                   }
[08:29:09.763]                   ...future.conditions[[length(...future.conditions) + 
[08:29:09.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:09.763]                     cond$call), session = sessionInformation(), 
[08:29:09.763]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:09.763]                   signalCondition(cond)
[08:29:09.763]                 }
[08:29:09.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:09.763]                 "immediateCondition"))) {
[08:29:09.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:09.763]                   ...future.conditions[[length(...future.conditions) + 
[08:29:09.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:09.763]                   if (TRUE && !signal) {
[08:29:09.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.763]                     {
[08:29:09.763]                       inherits <- base::inherits
[08:29:09.763]                       invokeRestart <- base::invokeRestart
[08:29:09.763]                       is.null <- base::is.null
[08:29:09.763]                       muffled <- FALSE
[08:29:09.763]                       if (inherits(cond, "message")) {
[08:29:09.763]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:09.763]                         if (muffled) 
[08:29:09.763]                           invokeRestart("muffleMessage")
[08:29:09.763]                       }
[08:29:09.763]                       else if (inherits(cond, "warning")) {
[08:29:09.763]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:09.763]                         if (muffled) 
[08:29:09.763]                           invokeRestart("muffleWarning")
[08:29:09.763]                       }
[08:29:09.763]                       else if (inherits(cond, "condition")) {
[08:29:09.763]                         if (!is.null(pattern)) {
[08:29:09.763]                           computeRestarts <- base::computeRestarts
[08:29:09.763]                           grepl <- base::grepl
[08:29:09.763]                           restarts <- computeRestarts(cond)
[08:29:09.763]                           for (restart in restarts) {
[08:29:09.763]                             name <- restart$name
[08:29:09.763]                             if (is.null(name)) 
[08:29:09.763]                               next
[08:29:09.763]                             if (!grepl(pattern, name)) 
[08:29:09.763]                               next
[08:29:09.763]                             invokeRestart(restart)
[08:29:09.763]                             muffled <- TRUE
[08:29:09.763]                             break
[08:29:09.763]                           }
[08:29:09.763]                         }
[08:29:09.763]                       }
[08:29:09.763]                       invisible(muffled)
[08:29:09.763]                     }
[08:29:09.763]                     muffleCondition(cond, pattern = "^muffle")
[08:29:09.763]                   }
[08:29:09.763]                 }
[08:29:09.763]                 else {
[08:29:09.763]                   if (TRUE) {
[08:29:09.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.763]                     {
[08:29:09.763]                       inherits <- base::inherits
[08:29:09.763]                       invokeRestart <- base::invokeRestart
[08:29:09.763]                       is.null <- base::is.null
[08:29:09.763]                       muffled <- FALSE
[08:29:09.763]                       if (inherits(cond, "message")) {
[08:29:09.763]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:09.763]                         if (muffled) 
[08:29:09.763]                           invokeRestart("muffleMessage")
[08:29:09.763]                       }
[08:29:09.763]                       else if (inherits(cond, "warning")) {
[08:29:09.763]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:09.763]                         if (muffled) 
[08:29:09.763]                           invokeRestart("muffleWarning")
[08:29:09.763]                       }
[08:29:09.763]                       else if (inherits(cond, "condition")) {
[08:29:09.763]                         if (!is.null(pattern)) {
[08:29:09.763]                           computeRestarts <- base::computeRestarts
[08:29:09.763]                           grepl <- base::grepl
[08:29:09.763]                           restarts <- computeRestarts(cond)
[08:29:09.763]                           for (restart in restarts) {
[08:29:09.763]                             name <- restart$name
[08:29:09.763]                             if (is.null(name)) 
[08:29:09.763]                               next
[08:29:09.763]                             if (!grepl(pattern, name)) 
[08:29:09.763]                               next
[08:29:09.763]                             invokeRestart(restart)
[08:29:09.763]                             muffled <- TRUE
[08:29:09.763]                             break
[08:29:09.763]                           }
[08:29:09.763]                         }
[08:29:09.763]                       }
[08:29:09.763]                       invisible(muffled)
[08:29:09.763]                     }
[08:29:09.763]                     muffleCondition(cond, pattern = "^muffle")
[08:29:09.763]                   }
[08:29:09.763]                 }
[08:29:09.763]             }
[08:29:09.763]         }))
[08:29:09.763]     }, error = function(ex) {
[08:29:09.763]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:09.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:09.763]                 ...future.rng), started = ...future.startTime, 
[08:29:09.763]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:09.763]             version = "1.8"), class = "FutureResult")
[08:29:09.763]     }, finally = {
[08:29:09.763]         if (!identical(...future.workdir, getwd())) 
[08:29:09.763]             setwd(...future.workdir)
[08:29:09.763]         {
[08:29:09.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:09.763]                 ...future.oldOptions$nwarnings <- NULL
[08:29:09.763]             }
[08:29:09.763]             base::options(...future.oldOptions)
[08:29:09.763]             if (.Platform$OS.type == "windows") {
[08:29:09.763]                 old_names <- names(...future.oldEnvVars)
[08:29:09.763]                 envs <- base::Sys.getenv()
[08:29:09.763]                 names <- names(envs)
[08:29:09.763]                 common <- intersect(names, old_names)
[08:29:09.763]                 added <- setdiff(names, old_names)
[08:29:09.763]                 removed <- setdiff(old_names, names)
[08:29:09.763]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:09.763]                   envs[common]]
[08:29:09.763]                 NAMES <- toupper(changed)
[08:29:09.763]                 args <- list()
[08:29:09.763]                 for (kk in seq_along(NAMES)) {
[08:29:09.763]                   name <- changed[[kk]]
[08:29:09.763]                   NAME <- NAMES[[kk]]
[08:29:09.763]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.763]                     next
[08:29:09.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:09.763]                 }
[08:29:09.763]                 NAMES <- toupper(added)
[08:29:09.763]                 for (kk in seq_along(NAMES)) {
[08:29:09.763]                   name <- added[[kk]]
[08:29:09.763]                   NAME <- NAMES[[kk]]
[08:29:09.763]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.763]                     next
[08:29:09.763]                   args[[name]] <- ""
[08:29:09.763]                 }
[08:29:09.763]                 NAMES <- toupper(removed)
[08:29:09.763]                 for (kk in seq_along(NAMES)) {
[08:29:09.763]                   name <- removed[[kk]]
[08:29:09.763]                   NAME <- NAMES[[kk]]
[08:29:09.763]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.763]                     next
[08:29:09.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:09.763]                 }
[08:29:09.763]                 if (length(args) > 0) 
[08:29:09.763]                   base::do.call(base::Sys.setenv, args = args)
[08:29:09.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:09.763]             }
[08:29:09.763]             else {
[08:29:09.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:09.763]             }
[08:29:09.763]             {
[08:29:09.763]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:09.763]                   0L) {
[08:29:09.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:09.763]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:09.763]                   base::options(opts)
[08:29:09.763]                 }
[08:29:09.763]                 {
[08:29:09.763]                   {
[08:29:09.763]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:09.763]                     NULL
[08:29:09.763]                   }
[08:29:09.763]                   options(future.plan = NULL)
[08:29:09.763]                   if (is.na(NA_character_)) 
[08:29:09.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:09.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:09.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:09.763]                     .init = FALSE)
[08:29:09.763]                 }
[08:29:09.763]             }
[08:29:09.763]         }
[08:29:09.763]     })
[08:29:09.763]     if (TRUE) {
[08:29:09.763]         base::sink(type = "output", split = FALSE)
[08:29:09.763]         if (TRUE) {
[08:29:09.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:09.763]         }
[08:29:09.763]         else {
[08:29:09.763]             ...future.result["stdout"] <- base::list(NULL)
[08:29:09.763]         }
[08:29:09.763]         base::close(...future.stdout)
[08:29:09.763]         ...future.stdout <- NULL
[08:29:09.763]     }
[08:29:09.763]     ...future.result$conditions <- ...future.conditions
[08:29:09.763]     ...future.result$finished <- base::Sys.time()
[08:29:09.763]     ...future.result
[08:29:09.763] }
[08:29:09.766] MultisessionFuture started
[08:29:09.766] - Launch lazy future ... done
[08:29:09.766] run() for ‘MultisessionFuture’ ... done
[08:29:09.808] receiveMessageFromWorker() for ClusterFuture ...
[08:29:09.808] - Validating connection of MultisessionFuture
[08:29:09.809] - received message: FutureResult
[08:29:09.809] - Received FutureResult
[08:29:09.809] - Erased future from FutureRegistry
[08:29:09.809] result() for ClusterFuture ...
[08:29:09.809] - result already collected: FutureResult
[08:29:09.809] result() for ClusterFuture ... done
[08:29:09.809] signalConditions() ...
[08:29:09.809]  - include = ‘immediateCondition’
[08:29:09.809]  - exclude = 
[08:29:09.809]  - resignal = FALSE
[08:29:09.809]  - Number of conditions: 1
[08:29:09.810] signalConditions() ... done
[08:29:09.810] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:09.810] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[08:29:09.810] getGlobalsAndPackages() ...
[08:29:09.810] Searching for globals...
[08:29:09.811] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:09.811] Searching for globals ... DONE
[08:29:09.811] Resolving globals: FALSE
[08:29:09.811] 
[08:29:09.812] 
[08:29:09.812] getGlobalsAndPackages() ... DONE
[08:29:09.812] run() for ‘Future’ ...
[08:29:09.812] - state: ‘created’
[08:29:09.812] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:09.826] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:09.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:09.826]   - Field: ‘node’
[08:29:09.826]   - Field: ‘label’
[08:29:09.826]   - Field: ‘local’
[08:29:09.826]   - Field: ‘owner’
[08:29:09.826]   - Field: ‘envir’
[08:29:09.826]   - Field: ‘workers’
[08:29:09.826]   - Field: ‘packages’
[08:29:09.826]   - Field: ‘gc’
[08:29:09.827]   - Field: ‘conditions’
[08:29:09.827]   - Field: ‘persistent’
[08:29:09.827]   - Field: ‘expr’
[08:29:09.827]   - Field: ‘uuid’
[08:29:09.827]   - Field: ‘seed’
[08:29:09.827]   - Field: ‘version’
[08:29:09.827]   - Field: ‘result’
[08:29:09.827]   - Field: ‘asynchronous’
[08:29:09.827]   - Field: ‘calls’
[08:29:09.827]   - Field: ‘globals’
[08:29:09.827]   - Field: ‘stdout’
[08:29:09.827]   - Field: ‘earlySignal’
[08:29:09.828]   - Field: ‘lazy’
[08:29:09.828]   - Field: ‘state’
[08:29:09.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:09.828] - Launch lazy future ...
[08:29:09.828] Packages needed by the future expression (n = 0): <none>
[08:29:09.828] Packages needed by future strategies (n = 0): <none>
[08:29:09.829] {
[08:29:09.829]     {
[08:29:09.829]         {
[08:29:09.829]             ...future.startTime <- base::Sys.time()
[08:29:09.829]             {
[08:29:09.829]                 {
[08:29:09.829]                   {
[08:29:09.829]                     {
[08:29:09.829]                       base::local({
[08:29:09.829]                         has_future <- base::requireNamespace("future", 
[08:29:09.829]                           quietly = TRUE)
[08:29:09.829]                         if (has_future) {
[08:29:09.829]                           ns <- base::getNamespace("future")
[08:29:09.829]                           version <- ns[[".package"]][["version"]]
[08:29:09.829]                           if (is.null(version)) 
[08:29:09.829]                             version <- utils::packageVersion("future")
[08:29:09.829]                         }
[08:29:09.829]                         else {
[08:29:09.829]                           version <- NULL
[08:29:09.829]                         }
[08:29:09.829]                         if (!has_future || version < "1.8.0") {
[08:29:09.829]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:09.829]                             "", base::R.version$version.string), 
[08:29:09.829]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:09.829]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:09.829]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:09.829]                               "release", "version")], collapse = " "), 
[08:29:09.829]                             hostname = base::Sys.info()[["nodename"]])
[08:29:09.829]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:09.829]                             info)
[08:29:09.829]                           info <- base::paste(info, collapse = "; ")
[08:29:09.829]                           if (!has_future) {
[08:29:09.829]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:09.829]                               info)
[08:29:09.829]                           }
[08:29:09.829]                           else {
[08:29:09.829]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:09.829]                               info, version)
[08:29:09.829]                           }
[08:29:09.829]                           base::stop(msg)
[08:29:09.829]                         }
[08:29:09.829]                       })
[08:29:09.829]                     }
[08:29:09.829]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:09.829]                     base::options(mc.cores = 1L)
[08:29:09.829]                   }
[08:29:09.829]                   ...future.strategy.old <- future::plan("list")
[08:29:09.829]                   options(future.plan = NULL)
[08:29:09.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:09.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:09.829]                 }
[08:29:09.829]                 ...future.workdir <- getwd()
[08:29:09.829]             }
[08:29:09.829]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:09.829]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:09.829]         }
[08:29:09.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:09.829]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:09.829]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:09.829]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:09.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:09.829]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:09.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:09.829]             base::names(...future.oldOptions))
[08:29:09.829]     }
[08:29:09.829]     if (FALSE) {
[08:29:09.829]     }
[08:29:09.829]     else {
[08:29:09.829]         if (TRUE) {
[08:29:09.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:09.829]                 open = "w")
[08:29:09.829]         }
[08:29:09.829]         else {
[08:29:09.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:09.829]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:09.829]         }
[08:29:09.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:09.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:09.829]             base::sink(type = "output", split = FALSE)
[08:29:09.829]             base::close(...future.stdout)
[08:29:09.829]         }, add = TRUE)
[08:29:09.829]     }
[08:29:09.829]     ...future.frame <- base::sys.nframe()
[08:29:09.829]     ...future.conditions <- base::list()
[08:29:09.829]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:09.829]     if (FALSE) {
[08:29:09.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:09.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:09.829]     }
[08:29:09.829]     ...future.result <- base::tryCatch({
[08:29:09.829]         base::withCallingHandlers({
[08:29:09.829]             ...future.value <- base::withVisible(base::local({
[08:29:09.829]                 ...future.makeSendCondition <- base::local({
[08:29:09.829]                   sendCondition <- NULL
[08:29:09.829]                   function(frame = 1L) {
[08:29:09.829]                     if (is.function(sendCondition)) 
[08:29:09.829]                       return(sendCondition)
[08:29:09.829]                     ns <- getNamespace("parallel")
[08:29:09.829]                     if (exists("sendData", mode = "function", 
[08:29:09.829]                       envir = ns)) {
[08:29:09.829]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:09.829]                         envir = ns)
[08:29:09.829]                       envir <- sys.frame(frame)
[08:29:09.829]                       master <- NULL
[08:29:09.829]                       while (!identical(envir, .GlobalEnv) && 
[08:29:09.829]                         !identical(envir, emptyenv())) {
[08:29:09.829]                         if (exists("master", mode = "list", envir = envir, 
[08:29:09.829]                           inherits = FALSE)) {
[08:29:09.829]                           master <- get("master", mode = "list", 
[08:29:09.829]                             envir = envir, inherits = FALSE)
[08:29:09.829]                           if (inherits(master, c("SOCKnode", 
[08:29:09.829]                             "SOCK0node"))) {
[08:29:09.829]                             sendCondition <<- function(cond) {
[08:29:09.829]                               data <- list(type = "VALUE", value = cond, 
[08:29:09.829]                                 success = TRUE)
[08:29:09.829]                               parallel_sendData(master, data)
[08:29:09.829]                             }
[08:29:09.829]                             return(sendCondition)
[08:29:09.829]                           }
[08:29:09.829]                         }
[08:29:09.829]                         frame <- frame + 1L
[08:29:09.829]                         envir <- sys.frame(frame)
[08:29:09.829]                       }
[08:29:09.829]                     }
[08:29:09.829]                     sendCondition <<- function(cond) NULL
[08:29:09.829]                   }
[08:29:09.829]                 })
[08:29:09.829]                 withCallingHandlers({
[08:29:09.829]                   {
[08:29:09.829]                     Sys.sleep(0.5)
[08:29:09.829]                     list(a = 1, b = 42L)
[08:29:09.829]                   }
[08:29:09.829]                 }, immediateCondition = function(cond) {
[08:29:09.829]                   sendCondition <- ...future.makeSendCondition()
[08:29:09.829]                   sendCondition(cond)
[08:29:09.829]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.829]                   {
[08:29:09.829]                     inherits <- base::inherits
[08:29:09.829]                     invokeRestart <- base::invokeRestart
[08:29:09.829]                     is.null <- base::is.null
[08:29:09.829]                     muffled <- FALSE
[08:29:09.829]                     if (inherits(cond, "message")) {
[08:29:09.829]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:09.829]                       if (muffled) 
[08:29:09.829]                         invokeRestart("muffleMessage")
[08:29:09.829]                     }
[08:29:09.829]                     else if (inherits(cond, "warning")) {
[08:29:09.829]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:09.829]                       if (muffled) 
[08:29:09.829]                         invokeRestart("muffleWarning")
[08:29:09.829]                     }
[08:29:09.829]                     else if (inherits(cond, "condition")) {
[08:29:09.829]                       if (!is.null(pattern)) {
[08:29:09.829]                         computeRestarts <- base::computeRestarts
[08:29:09.829]                         grepl <- base::grepl
[08:29:09.829]                         restarts <- computeRestarts(cond)
[08:29:09.829]                         for (restart in restarts) {
[08:29:09.829]                           name <- restart$name
[08:29:09.829]                           if (is.null(name)) 
[08:29:09.829]                             next
[08:29:09.829]                           if (!grepl(pattern, name)) 
[08:29:09.829]                             next
[08:29:09.829]                           invokeRestart(restart)
[08:29:09.829]                           muffled <- TRUE
[08:29:09.829]                           break
[08:29:09.829]                         }
[08:29:09.829]                       }
[08:29:09.829]                     }
[08:29:09.829]                     invisible(muffled)
[08:29:09.829]                   }
[08:29:09.829]                   muffleCondition(cond)
[08:29:09.829]                 })
[08:29:09.829]             }))
[08:29:09.829]             future::FutureResult(value = ...future.value$value, 
[08:29:09.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:09.829]                   ...future.rng), globalenv = if (FALSE) 
[08:29:09.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:09.829]                     ...future.globalenv.names))
[08:29:09.829]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:09.829]         }, condition = base::local({
[08:29:09.829]             c <- base::c
[08:29:09.829]             inherits <- base::inherits
[08:29:09.829]             invokeRestart <- base::invokeRestart
[08:29:09.829]             length <- base::length
[08:29:09.829]             list <- base::list
[08:29:09.829]             seq.int <- base::seq.int
[08:29:09.829]             signalCondition <- base::signalCondition
[08:29:09.829]             sys.calls <- base::sys.calls
[08:29:09.829]             `[[` <- base::`[[`
[08:29:09.829]             `+` <- base::`+`
[08:29:09.829]             `<<-` <- base::`<<-`
[08:29:09.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:09.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:09.829]                   3L)]
[08:29:09.829]             }
[08:29:09.829]             function(cond) {
[08:29:09.829]                 is_error <- inherits(cond, "error")
[08:29:09.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:09.829]                   NULL)
[08:29:09.829]                 if (is_error) {
[08:29:09.829]                   sessionInformation <- function() {
[08:29:09.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:09.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:09.829]                       search = base::search(), system = base::Sys.info())
[08:29:09.829]                   }
[08:29:09.829]                   ...future.conditions[[length(...future.conditions) + 
[08:29:09.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:09.829]                     cond$call), session = sessionInformation(), 
[08:29:09.829]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:09.829]                   signalCondition(cond)
[08:29:09.829]                 }
[08:29:09.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:09.829]                 "immediateCondition"))) {
[08:29:09.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:09.829]                   ...future.conditions[[length(...future.conditions) + 
[08:29:09.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:09.829]                   if (TRUE && !signal) {
[08:29:09.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.829]                     {
[08:29:09.829]                       inherits <- base::inherits
[08:29:09.829]                       invokeRestart <- base::invokeRestart
[08:29:09.829]                       is.null <- base::is.null
[08:29:09.829]                       muffled <- FALSE
[08:29:09.829]                       if (inherits(cond, "message")) {
[08:29:09.829]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:09.829]                         if (muffled) 
[08:29:09.829]                           invokeRestart("muffleMessage")
[08:29:09.829]                       }
[08:29:09.829]                       else if (inherits(cond, "warning")) {
[08:29:09.829]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:09.829]                         if (muffled) 
[08:29:09.829]                           invokeRestart("muffleWarning")
[08:29:09.829]                       }
[08:29:09.829]                       else if (inherits(cond, "condition")) {
[08:29:09.829]                         if (!is.null(pattern)) {
[08:29:09.829]                           computeRestarts <- base::computeRestarts
[08:29:09.829]                           grepl <- base::grepl
[08:29:09.829]                           restarts <- computeRestarts(cond)
[08:29:09.829]                           for (restart in restarts) {
[08:29:09.829]                             name <- restart$name
[08:29:09.829]                             if (is.null(name)) 
[08:29:09.829]                               next
[08:29:09.829]                             if (!grepl(pattern, name)) 
[08:29:09.829]                               next
[08:29:09.829]                             invokeRestart(restart)
[08:29:09.829]                             muffled <- TRUE
[08:29:09.829]                             break
[08:29:09.829]                           }
[08:29:09.829]                         }
[08:29:09.829]                       }
[08:29:09.829]                       invisible(muffled)
[08:29:09.829]                     }
[08:29:09.829]                     muffleCondition(cond, pattern = "^muffle")
[08:29:09.829]                   }
[08:29:09.829]                 }
[08:29:09.829]                 else {
[08:29:09.829]                   if (TRUE) {
[08:29:09.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:09.829]                     {
[08:29:09.829]                       inherits <- base::inherits
[08:29:09.829]                       invokeRestart <- base::invokeRestart
[08:29:09.829]                       is.null <- base::is.null
[08:29:09.829]                       muffled <- FALSE
[08:29:09.829]                       if (inherits(cond, "message")) {
[08:29:09.829]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:09.829]                         if (muffled) 
[08:29:09.829]                           invokeRestart("muffleMessage")
[08:29:09.829]                       }
[08:29:09.829]                       else if (inherits(cond, "warning")) {
[08:29:09.829]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:09.829]                         if (muffled) 
[08:29:09.829]                           invokeRestart("muffleWarning")
[08:29:09.829]                       }
[08:29:09.829]                       else if (inherits(cond, "condition")) {
[08:29:09.829]                         if (!is.null(pattern)) {
[08:29:09.829]                           computeRestarts <- base::computeRestarts
[08:29:09.829]                           grepl <- base::grepl
[08:29:09.829]                           restarts <- computeRestarts(cond)
[08:29:09.829]                           for (restart in restarts) {
[08:29:09.829]                             name <- restart$name
[08:29:09.829]                             if (is.null(name)) 
[08:29:09.829]                               next
[08:29:09.829]                             if (!grepl(pattern, name)) 
[08:29:09.829]                               next
[08:29:09.829]                             invokeRestart(restart)
[08:29:09.829]                             muffled <- TRUE
[08:29:09.829]                             break
[08:29:09.829]                           }
[08:29:09.829]                         }
[08:29:09.829]                       }
[08:29:09.829]                       invisible(muffled)
[08:29:09.829]                     }
[08:29:09.829]                     muffleCondition(cond, pattern = "^muffle")
[08:29:09.829]                   }
[08:29:09.829]                 }
[08:29:09.829]             }
[08:29:09.829]         }))
[08:29:09.829]     }, error = function(ex) {
[08:29:09.829]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:09.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:09.829]                 ...future.rng), started = ...future.startTime, 
[08:29:09.829]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:09.829]             version = "1.8"), class = "FutureResult")
[08:29:09.829]     }, finally = {
[08:29:09.829]         if (!identical(...future.workdir, getwd())) 
[08:29:09.829]             setwd(...future.workdir)
[08:29:09.829]         {
[08:29:09.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:09.829]                 ...future.oldOptions$nwarnings <- NULL
[08:29:09.829]             }
[08:29:09.829]             base::options(...future.oldOptions)
[08:29:09.829]             if (.Platform$OS.type == "windows") {
[08:29:09.829]                 old_names <- names(...future.oldEnvVars)
[08:29:09.829]                 envs <- base::Sys.getenv()
[08:29:09.829]                 names <- names(envs)
[08:29:09.829]                 common <- intersect(names, old_names)
[08:29:09.829]                 added <- setdiff(names, old_names)
[08:29:09.829]                 removed <- setdiff(old_names, names)
[08:29:09.829]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:09.829]                   envs[common]]
[08:29:09.829]                 NAMES <- toupper(changed)
[08:29:09.829]                 args <- list()
[08:29:09.829]                 for (kk in seq_along(NAMES)) {
[08:29:09.829]                   name <- changed[[kk]]
[08:29:09.829]                   NAME <- NAMES[[kk]]
[08:29:09.829]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.829]                     next
[08:29:09.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:09.829]                 }
[08:29:09.829]                 NAMES <- toupper(added)
[08:29:09.829]                 for (kk in seq_along(NAMES)) {
[08:29:09.829]                   name <- added[[kk]]
[08:29:09.829]                   NAME <- NAMES[[kk]]
[08:29:09.829]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.829]                     next
[08:29:09.829]                   args[[name]] <- ""
[08:29:09.829]                 }
[08:29:09.829]                 NAMES <- toupper(removed)
[08:29:09.829]                 for (kk in seq_along(NAMES)) {
[08:29:09.829]                   name <- removed[[kk]]
[08:29:09.829]                   NAME <- NAMES[[kk]]
[08:29:09.829]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:09.829]                     next
[08:29:09.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:09.829]                 }
[08:29:09.829]                 if (length(args) > 0) 
[08:29:09.829]                   base::do.call(base::Sys.setenv, args = args)
[08:29:09.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:09.829]             }
[08:29:09.829]             else {
[08:29:09.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:09.829]             }
[08:29:09.829]             {
[08:29:09.829]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:09.829]                   0L) {
[08:29:09.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:09.829]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:09.829]                   base::options(opts)
[08:29:09.829]                 }
[08:29:09.829]                 {
[08:29:09.829]                   {
[08:29:09.829]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:09.829]                     NULL
[08:29:09.829]                   }
[08:29:09.829]                   options(future.plan = NULL)
[08:29:09.829]                   if (is.na(NA_character_)) 
[08:29:09.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:09.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:09.829]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:09.829]                     .init = FALSE)
[08:29:09.829]                 }
[08:29:09.829]             }
[08:29:09.829]         }
[08:29:09.829]     })
[08:29:09.829]     if (TRUE) {
[08:29:09.829]         base::sink(type = "output", split = FALSE)
[08:29:09.829]         if (TRUE) {
[08:29:09.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:09.829]         }
[08:29:09.829]         else {
[08:29:09.829]             ...future.result["stdout"] <- base::list(NULL)
[08:29:09.829]         }
[08:29:09.829]         base::close(...future.stdout)
[08:29:09.829]         ...future.stdout <- NULL
[08:29:09.829]     }
[08:29:09.829]     ...future.result$conditions <- ...future.conditions
[08:29:09.829]     ...future.result$finished <- base::Sys.time()
[08:29:09.829]     ...future.result
[08:29:09.829] }
[08:29:09.831] MultisessionFuture started
[08:29:09.831] - Launch lazy future ... done
[08:29:09.832] run() for ‘MultisessionFuture’ ... done
[08:29:10.374] receiveMessageFromWorker() for ClusterFuture ...
[08:29:10.374] - Validating connection of MultisessionFuture
[08:29:10.374] - received message: FutureResult
[08:29:10.374] - Received FutureResult
[08:29:10.375] - Erased future from FutureRegistry
[08:29:10.375] result() for ClusterFuture ...
[08:29:10.375] - result already collected: FutureResult
[08:29:10.375] result() for ClusterFuture ... done
[08:29:10.375] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:10.375] A MultisessionFuture was resolved (result was not collected)
[08:29:10.375] getGlobalsAndPackages() ...
[08:29:10.375] Searching for globals...
[08:29:10.376] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:10.377] Searching for globals ... DONE
[08:29:10.377] Resolving globals: FALSE
[08:29:10.377] 
[08:29:10.377] 
[08:29:10.377] getGlobalsAndPackages() ... DONE
[08:29:10.377] run() for ‘Future’ ...
[08:29:10.378] - state: ‘created’
[08:29:10.378] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:10.391] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:10.392] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:10.392]   - Field: ‘node’
[08:29:10.392]   - Field: ‘label’
[08:29:10.392]   - Field: ‘local’
[08:29:10.392]   - Field: ‘owner’
[08:29:10.392]   - Field: ‘envir’
[08:29:10.392]   - Field: ‘workers’
[08:29:10.392]   - Field: ‘packages’
[08:29:10.392]   - Field: ‘gc’
[08:29:10.392]   - Field: ‘conditions’
[08:29:10.392]   - Field: ‘persistent’
[08:29:10.393]   - Field: ‘expr’
[08:29:10.393]   - Field: ‘uuid’
[08:29:10.393]   - Field: ‘seed’
[08:29:10.393]   - Field: ‘version’
[08:29:10.393]   - Field: ‘result’
[08:29:10.393]   - Field: ‘asynchronous’
[08:29:10.393]   - Field: ‘calls’
[08:29:10.393]   - Field: ‘globals’
[08:29:10.393]   - Field: ‘stdout’
[08:29:10.393]   - Field: ‘earlySignal’
[08:29:10.393]   - Field: ‘lazy’
[08:29:10.393]   - Field: ‘state’
[08:29:10.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:10.394] - Launch lazy future ...
[08:29:10.394] Packages needed by the future expression (n = 0): <none>
[08:29:10.394] Packages needed by future strategies (n = 0): <none>
[08:29:10.396] {
[08:29:10.396]     {
[08:29:10.396]         {
[08:29:10.396]             ...future.startTime <- base::Sys.time()
[08:29:10.396]             {
[08:29:10.396]                 {
[08:29:10.396]                   {
[08:29:10.396]                     {
[08:29:10.396]                       base::local({
[08:29:10.396]                         has_future <- base::requireNamespace("future", 
[08:29:10.396]                           quietly = TRUE)
[08:29:10.396]                         if (has_future) {
[08:29:10.396]                           ns <- base::getNamespace("future")
[08:29:10.396]                           version <- ns[[".package"]][["version"]]
[08:29:10.396]                           if (is.null(version)) 
[08:29:10.396]                             version <- utils::packageVersion("future")
[08:29:10.396]                         }
[08:29:10.396]                         else {
[08:29:10.396]                           version <- NULL
[08:29:10.396]                         }
[08:29:10.396]                         if (!has_future || version < "1.8.0") {
[08:29:10.396]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:10.396]                             "", base::R.version$version.string), 
[08:29:10.396]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:10.396]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:10.396]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:10.396]                               "release", "version")], collapse = " "), 
[08:29:10.396]                             hostname = base::Sys.info()[["nodename"]])
[08:29:10.396]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:10.396]                             info)
[08:29:10.396]                           info <- base::paste(info, collapse = "; ")
[08:29:10.396]                           if (!has_future) {
[08:29:10.396]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:10.396]                               info)
[08:29:10.396]                           }
[08:29:10.396]                           else {
[08:29:10.396]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:10.396]                               info, version)
[08:29:10.396]                           }
[08:29:10.396]                           base::stop(msg)
[08:29:10.396]                         }
[08:29:10.396]                       })
[08:29:10.396]                     }
[08:29:10.396]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:10.396]                     base::options(mc.cores = 1L)
[08:29:10.396]                   }
[08:29:10.396]                   ...future.strategy.old <- future::plan("list")
[08:29:10.396]                   options(future.plan = NULL)
[08:29:10.396]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:10.396]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:10.396]                 }
[08:29:10.396]                 ...future.workdir <- getwd()
[08:29:10.396]             }
[08:29:10.396]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:10.396]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:10.396]         }
[08:29:10.396]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:10.396]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:10.396]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:10.396]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:10.396]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:10.396]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:10.396]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:10.396]             base::names(...future.oldOptions))
[08:29:10.396]     }
[08:29:10.396]     if (FALSE) {
[08:29:10.396]     }
[08:29:10.396]     else {
[08:29:10.396]         if (TRUE) {
[08:29:10.396]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:10.396]                 open = "w")
[08:29:10.396]         }
[08:29:10.396]         else {
[08:29:10.396]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:10.396]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:10.396]         }
[08:29:10.396]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:10.396]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:10.396]             base::sink(type = "output", split = FALSE)
[08:29:10.396]             base::close(...future.stdout)
[08:29:10.396]         }, add = TRUE)
[08:29:10.396]     }
[08:29:10.396]     ...future.frame <- base::sys.nframe()
[08:29:10.396]     ...future.conditions <- base::list()
[08:29:10.396]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:10.396]     if (FALSE) {
[08:29:10.396]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:10.396]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:10.396]     }
[08:29:10.396]     ...future.result <- base::tryCatch({
[08:29:10.396]         base::withCallingHandlers({
[08:29:10.396]             ...future.value <- base::withVisible(base::local({
[08:29:10.396]                 ...future.makeSendCondition <- base::local({
[08:29:10.396]                   sendCondition <- NULL
[08:29:10.396]                   function(frame = 1L) {
[08:29:10.396]                     if (is.function(sendCondition)) 
[08:29:10.396]                       return(sendCondition)
[08:29:10.396]                     ns <- getNamespace("parallel")
[08:29:10.396]                     if (exists("sendData", mode = "function", 
[08:29:10.396]                       envir = ns)) {
[08:29:10.396]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:10.396]                         envir = ns)
[08:29:10.396]                       envir <- sys.frame(frame)
[08:29:10.396]                       master <- NULL
[08:29:10.396]                       while (!identical(envir, .GlobalEnv) && 
[08:29:10.396]                         !identical(envir, emptyenv())) {
[08:29:10.396]                         if (exists("master", mode = "list", envir = envir, 
[08:29:10.396]                           inherits = FALSE)) {
[08:29:10.396]                           master <- get("master", mode = "list", 
[08:29:10.396]                             envir = envir, inherits = FALSE)
[08:29:10.396]                           if (inherits(master, c("SOCKnode", 
[08:29:10.396]                             "SOCK0node"))) {
[08:29:10.396]                             sendCondition <<- function(cond) {
[08:29:10.396]                               data <- list(type = "VALUE", value = cond, 
[08:29:10.396]                                 success = TRUE)
[08:29:10.396]                               parallel_sendData(master, data)
[08:29:10.396]                             }
[08:29:10.396]                             return(sendCondition)
[08:29:10.396]                           }
[08:29:10.396]                         }
[08:29:10.396]                         frame <- frame + 1L
[08:29:10.396]                         envir <- sys.frame(frame)
[08:29:10.396]                       }
[08:29:10.396]                     }
[08:29:10.396]                     sendCondition <<- function(cond) NULL
[08:29:10.396]                   }
[08:29:10.396]                 })
[08:29:10.396]                 withCallingHandlers({
[08:29:10.396]                   {
[08:29:10.396]                     Sys.sleep(0.5)
[08:29:10.396]                     list(a = 1, b = 42L)
[08:29:10.396]                   }
[08:29:10.396]                 }, immediateCondition = function(cond) {
[08:29:10.396]                   sendCondition <- ...future.makeSendCondition()
[08:29:10.396]                   sendCondition(cond)
[08:29:10.396]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:10.396]                   {
[08:29:10.396]                     inherits <- base::inherits
[08:29:10.396]                     invokeRestart <- base::invokeRestart
[08:29:10.396]                     is.null <- base::is.null
[08:29:10.396]                     muffled <- FALSE
[08:29:10.396]                     if (inherits(cond, "message")) {
[08:29:10.396]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:10.396]                       if (muffled) 
[08:29:10.396]                         invokeRestart("muffleMessage")
[08:29:10.396]                     }
[08:29:10.396]                     else if (inherits(cond, "warning")) {
[08:29:10.396]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:10.396]                       if (muffled) 
[08:29:10.396]                         invokeRestart("muffleWarning")
[08:29:10.396]                     }
[08:29:10.396]                     else if (inherits(cond, "condition")) {
[08:29:10.396]                       if (!is.null(pattern)) {
[08:29:10.396]                         computeRestarts <- base::computeRestarts
[08:29:10.396]                         grepl <- base::grepl
[08:29:10.396]                         restarts <- computeRestarts(cond)
[08:29:10.396]                         for (restart in restarts) {
[08:29:10.396]                           name <- restart$name
[08:29:10.396]                           if (is.null(name)) 
[08:29:10.396]                             next
[08:29:10.396]                           if (!grepl(pattern, name)) 
[08:29:10.396]                             next
[08:29:10.396]                           invokeRestart(restart)
[08:29:10.396]                           muffled <- TRUE
[08:29:10.396]                           break
[08:29:10.396]                         }
[08:29:10.396]                       }
[08:29:10.396]                     }
[08:29:10.396]                     invisible(muffled)
[08:29:10.396]                   }
[08:29:10.396]                   muffleCondition(cond)
[08:29:10.396]                 })
[08:29:10.396]             }))
[08:29:10.396]             future::FutureResult(value = ...future.value$value, 
[08:29:10.396]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:10.396]                   ...future.rng), globalenv = if (FALSE) 
[08:29:10.396]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:10.396]                     ...future.globalenv.names))
[08:29:10.396]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:10.396]         }, condition = base::local({
[08:29:10.396]             c <- base::c
[08:29:10.396]             inherits <- base::inherits
[08:29:10.396]             invokeRestart <- base::invokeRestart
[08:29:10.396]             length <- base::length
[08:29:10.396]             list <- base::list
[08:29:10.396]             seq.int <- base::seq.int
[08:29:10.396]             signalCondition <- base::signalCondition
[08:29:10.396]             sys.calls <- base::sys.calls
[08:29:10.396]             `[[` <- base::`[[`
[08:29:10.396]             `+` <- base::`+`
[08:29:10.396]             `<<-` <- base::`<<-`
[08:29:10.396]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:10.396]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:10.396]                   3L)]
[08:29:10.396]             }
[08:29:10.396]             function(cond) {
[08:29:10.396]                 is_error <- inherits(cond, "error")
[08:29:10.396]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:10.396]                   NULL)
[08:29:10.396]                 if (is_error) {
[08:29:10.396]                   sessionInformation <- function() {
[08:29:10.396]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:10.396]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:10.396]                       search = base::search(), system = base::Sys.info())
[08:29:10.396]                   }
[08:29:10.396]                   ...future.conditions[[length(...future.conditions) + 
[08:29:10.396]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:10.396]                     cond$call), session = sessionInformation(), 
[08:29:10.396]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:10.396]                   signalCondition(cond)
[08:29:10.396]                 }
[08:29:10.396]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:10.396]                 "immediateCondition"))) {
[08:29:10.396]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:10.396]                   ...future.conditions[[length(...future.conditions) + 
[08:29:10.396]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:10.396]                   if (TRUE && !signal) {
[08:29:10.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:10.396]                     {
[08:29:10.396]                       inherits <- base::inherits
[08:29:10.396]                       invokeRestart <- base::invokeRestart
[08:29:10.396]                       is.null <- base::is.null
[08:29:10.396]                       muffled <- FALSE
[08:29:10.396]                       if (inherits(cond, "message")) {
[08:29:10.396]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:10.396]                         if (muffled) 
[08:29:10.396]                           invokeRestart("muffleMessage")
[08:29:10.396]                       }
[08:29:10.396]                       else if (inherits(cond, "warning")) {
[08:29:10.396]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:10.396]                         if (muffled) 
[08:29:10.396]                           invokeRestart("muffleWarning")
[08:29:10.396]                       }
[08:29:10.396]                       else if (inherits(cond, "condition")) {
[08:29:10.396]                         if (!is.null(pattern)) {
[08:29:10.396]                           computeRestarts <- base::computeRestarts
[08:29:10.396]                           grepl <- base::grepl
[08:29:10.396]                           restarts <- computeRestarts(cond)
[08:29:10.396]                           for (restart in restarts) {
[08:29:10.396]                             name <- restart$name
[08:29:10.396]                             if (is.null(name)) 
[08:29:10.396]                               next
[08:29:10.396]                             if (!grepl(pattern, name)) 
[08:29:10.396]                               next
[08:29:10.396]                             invokeRestart(restart)
[08:29:10.396]                             muffled <- TRUE
[08:29:10.396]                             break
[08:29:10.396]                           }
[08:29:10.396]                         }
[08:29:10.396]                       }
[08:29:10.396]                       invisible(muffled)
[08:29:10.396]                     }
[08:29:10.396]                     muffleCondition(cond, pattern = "^muffle")
[08:29:10.396]                   }
[08:29:10.396]                 }
[08:29:10.396]                 else {
[08:29:10.396]                   if (TRUE) {
[08:29:10.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:10.396]                     {
[08:29:10.396]                       inherits <- base::inherits
[08:29:10.396]                       invokeRestart <- base::invokeRestart
[08:29:10.396]                       is.null <- base::is.null
[08:29:10.396]                       muffled <- FALSE
[08:29:10.396]                       if (inherits(cond, "message")) {
[08:29:10.396]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:10.396]                         if (muffled) 
[08:29:10.396]                           invokeRestart("muffleMessage")
[08:29:10.396]                       }
[08:29:10.396]                       else if (inherits(cond, "warning")) {
[08:29:10.396]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:10.396]                         if (muffled) 
[08:29:10.396]                           invokeRestart("muffleWarning")
[08:29:10.396]                       }
[08:29:10.396]                       else if (inherits(cond, "condition")) {
[08:29:10.396]                         if (!is.null(pattern)) {
[08:29:10.396]                           computeRestarts <- base::computeRestarts
[08:29:10.396]                           grepl <- base::grepl
[08:29:10.396]                           restarts <- computeRestarts(cond)
[08:29:10.396]                           for (restart in restarts) {
[08:29:10.396]                             name <- restart$name
[08:29:10.396]                             if (is.null(name)) 
[08:29:10.396]                               next
[08:29:10.396]                             if (!grepl(pattern, name)) 
[08:29:10.396]                               next
[08:29:10.396]                             invokeRestart(restart)
[08:29:10.396]                             muffled <- TRUE
[08:29:10.396]                             break
[08:29:10.396]                           }
[08:29:10.396]                         }
[08:29:10.396]                       }
[08:29:10.396]                       invisible(muffled)
[08:29:10.396]                     }
[08:29:10.396]                     muffleCondition(cond, pattern = "^muffle")
[08:29:10.396]                   }
[08:29:10.396]                 }
[08:29:10.396]             }
[08:29:10.396]         }))
[08:29:10.396]     }, error = function(ex) {
[08:29:10.396]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:10.396]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:10.396]                 ...future.rng), started = ...future.startTime, 
[08:29:10.396]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:10.396]             version = "1.8"), class = "FutureResult")
[08:29:10.396]     }, finally = {
[08:29:10.396]         if (!identical(...future.workdir, getwd())) 
[08:29:10.396]             setwd(...future.workdir)
[08:29:10.396]         {
[08:29:10.396]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:10.396]                 ...future.oldOptions$nwarnings <- NULL
[08:29:10.396]             }
[08:29:10.396]             base::options(...future.oldOptions)
[08:29:10.396]             if (.Platform$OS.type == "windows") {
[08:29:10.396]                 old_names <- names(...future.oldEnvVars)
[08:29:10.396]                 envs <- base::Sys.getenv()
[08:29:10.396]                 names <- names(envs)
[08:29:10.396]                 common <- intersect(names, old_names)
[08:29:10.396]                 added <- setdiff(names, old_names)
[08:29:10.396]                 removed <- setdiff(old_names, names)
[08:29:10.396]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:10.396]                   envs[common]]
[08:29:10.396]                 NAMES <- toupper(changed)
[08:29:10.396]                 args <- list()
[08:29:10.396]                 for (kk in seq_along(NAMES)) {
[08:29:10.396]                   name <- changed[[kk]]
[08:29:10.396]                   NAME <- NAMES[[kk]]
[08:29:10.396]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:10.396]                     next
[08:29:10.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:10.396]                 }
[08:29:10.396]                 NAMES <- toupper(added)
[08:29:10.396]                 for (kk in seq_along(NAMES)) {
[08:29:10.396]                   name <- added[[kk]]
[08:29:10.396]                   NAME <- NAMES[[kk]]
[08:29:10.396]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:10.396]                     next
[08:29:10.396]                   args[[name]] <- ""
[08:29:10.396]                 }
[08:29:10.396]                 NAMES <- toupper(removed)
[08:29:10.396]                 for (kk in seq_along(NAMES)) {
[08:29:10.396]                   name <- removed[[kk]]
[08:29:10.396]                   NAME <- NAMES[[kk]]
[08:29:10.396]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:10.396]                     next
[08:29:10.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:10.396]                 }
[08:29:10.396]                 if (length(args) > 0) 
[08:29:10.396]                   base::do.call(base::Sys.setenv, args = args)
[08:29:10.396]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:10.396]             }
[08:29:10.396]             else {
[08:29:10.396]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:10.396]             }
[08:29:10.396]             {
[08:29:10.396]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:10.396]                   0L) {
[08:29:10.396]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:10.396]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:10.396]                   base::options(opts)
[08:29:10.396]                 }
[08:29:10.396]                 {
[08:29:10.396]                   {
[08:29:10.396]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:10.396]                     NULL
[08:29:10.396]                   }
[08:29:10.396]                   options(future.plan = NULL)
[08:29:10.396]                   if (is.na(NA_character_)) 
[08:29:10.396]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:10.396]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:10.396]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:10.396]                     .init = FALSE)
[08:29:10.396]                 }
[08:29:10.396]             }
[08:29:10.396]         }
[08:29:10.396]     })
[08:29:10.396]     if (TRUE) {
[08:29:10.396]         base::sink(type = "output", split = FALSE)
[08:29:10.396]         if (TRUE) {
[08:29:10.396]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:10.396]         }
[08:29:10.396]         else {
[08:29:10.396]             ...future.result["stdout"] <- base::list(NULL)
[08:29:10.396]         }
[08:29:10.396]         base::close(...future.stdout)
[08:29:10.396]         ...future.stdout <- NULL
[08:29:10.396]     }
[08:29:10.396]     ...future.result$conditions <- ...future.conditions
[08:29:10.396]     ...future.result$finished <- base::Sys.time()
[08:29:10.396]     ...future.result
[08:29:10.396] }
[08:29:10.399] MultisessionFuture started
[08:29:10.399] - Launch lazy future ... done
[08:29:10.399] run() for ‘MultisessionFuture’ ... done
[08:29:10.942] receiveMessageFromWorker() for ClusterFuture ...
[08:29:10.942] - Validating connection of MultisessionFuture
[08:29:10.942] - received message: FutureResult
[08:29:10.942] - Received FutureResult
[08:29:10.942] - Erased future from FutureRegistry
[08:29:10.942] result() for ClusterFuture ...
[08:29:10.943] - result already collected: FutureResult
[08:29:10.943] result() for ClusterFuture ... done
[08:29:10.943] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:10.943] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[08:29:10.943] getGlobalsAndPackages() ...
[08:29:10.943] Searching for globals...
[08:29:10.944] - globals found: [2] ‘list’, ‘stop’
[08:29:10.944] Searching for globals ... DONE
[08:29:10.944] Resolving globals: FALSE
[08:29:10.944] 
[08:29:10.944] 
[08:29:10.944] getGlobalsAndPackages() ... DONE
[08:29:10.945] run() for ‘Future’ ...
[08:29:10.945] - state: ‘created’
[08:29:10.945] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:10.958] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:10.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:10.959]   - Field: ‘node’
[08:29:10.959]   - Field: ‘label’
[08:29:10.959]   - Field: ‘local’
[08:29:10.959]   - Field: ‘owner’
[08:29:10.959]   - Field: ‘envir’
[08:29:10.959]   - Field: ‘workers’
[08:29:10.959]   - Field: ‘packages’
[08:29:10.959]   - Field: ‘gc’
[08:29:10.959]   - Field: ‘conditions’
[08:29:10.959]   - Field: ‘persistent’
[08:29:10.960]   - Field: ‘expr’
[08:29:10.960]   - Field: ‘uuid’
[08:29:10.960]   - Field: ‘seed’
[08:29:10.960]   - Field: ‘version’
[08:29:10.960]   - Field: ‘result’
[08:29:10.960]   - Field: ‘asynchronous’
[08:29:10.960]   - Field: ‘calls’
[08:29:10.960]   - Field: ‘globals’
[08:29:10.960]   - Field: ‘stdout’
[08:29:10.960]   - Field: ‘earlySignal’
[08:29:10.960]   - Field: ‘lazy’
[08:29:10.960]   - Field: ‘state’
[08:29:10.961] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:10.961] - Launch lazy future ...
[08:29:10.961] Packages needed by the future expression (n = 0): <none>
[08:29:10.961] Packages needed by future strategies (n = 0): <none>
[08:29:10.961] {
[08:29:10.961]     {
[08:29:10.961]         {
[08:29:10.961]             ...future.startTime <- base::Sys.time()
[08:29:10.961]             {
[08:29:10.961]                 {
[08:29:10.961]                   {
[08:29:10.961]                     {
[08:29:10.961]                       base::local({
[08:29:10.961]                         has_future <- base::requireNamespace("future", 
[08:29:10.961]                           quietly = TRUE)
[08:29:10.961]                         if (has_future) {
[08:29:10.961]                           ns <- base::getNamespace("future")
[08:29:10.961]                           version <- ns[[".package"]][["version"]]
[08:29:10.961]                           if (is.null(version)) 
[08:29:10.961]                             version <- utils::packageVersion("future")
[08:29:10.961]                         }
[08:29:10.961]                         else {
[08:29:10.961]                           version <- NULL
[08:29:10.961]                         }
[08:29:10.961]                         if (!has_future || version < "1.8.0") {
[08:29:10.961]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:10.961]                             "", base::R.version$version.string), 
[08:29:10.961]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:10.961]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:10.961]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:10.961]                               "release", "version")], collapse = " "), 
[08:29:10.961]                             hostname = base::Sys.info()[["nodename"]])
[08:29:10.961]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:10.961]                             info)
[08:29:10.961]                           info <- base::paste(info, collapse = "; ")
[08:29:10.961]                           if (!has_future) {
[08:29:10.961]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:10.961]                               info)
[08:29:10.961]                           }
[08:29:10.961]                           else {
[08:29:10.961]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:10.961]                               info, version)
[08:29:10.961]                           }
[08:29:10.961]                           base::stop(msg)
[08:29:10.961]                         }
[08:29:10.961]                       })
[08:29:10.961]                     }
[08:29:10.961]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:10.961]                     base::options(mc.cores = 1L)
[08:29:10.961]                   }
[08:29:10.961]                   ...future.strategy.old <- future::plan("list")
[08:29:10.961]                   options(future.plan = NULL)
[08:29:10.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:10.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:10.961]                 }
[08:29:10.961]                 ...future.workdir <- getwd()
[08:29:10.961]             }
[08:29:10.961]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:10.961]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:10.961]         }
[08:29:10.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:10.961]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:10.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:10.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:10.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:10.961]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:10.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:10.961]             base::names(...future.oldOptions))
[08:29:10.961]     }
[08:29:10.961]     if (FALSE) {
[08:29:10.961]     }
[08:29:10.961]     else {
[08:29:10.961]         if (TRUE) {
[08:29:10.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:10.961]                 open = "w")
[08:29:10.961]         }
[08:29:10.961]         else {
[08:29:10.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:10.961]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:10.961]         }
[08:29:10.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:10.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:10.961]             base::sink(type = "output", split = FALSE)
[08:29:10.961]             base::close(...future.stdout)
[08:29:10.961]         }, add = TRUE)
[08:29:10.961]     }
[08:29:10.961]     ...future.frame <- base::sys.nframe()
[08:29:10.961]     ...future.conditions <- base::list()
[08:29:10.961]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:10.961]     if (FALSE) {
[08:29:10.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:10.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:10.961]     }
[08:29:10.961]     ...future.result <- base::tryCatch({
[08:29:10.961]         base::withCallingHandlers({
[08:29:10.961]             ...future.value <- base::withVisible(base::local({
[08:29:10.961]                 ...future.makeSendCondition <- base::local({
[08:29:10.961]                   sendCondition <- NULL
[08:29:10.961]                   function(frame = 1L) {
[08:29:10.961]                     if (is.function(sendCondition)) 
[08:29:10.961]                       return(sendCondition)
[08:29:10.961]                     ns <- getNamespace("parallel")
[08:29:10.961]                     if (exists("sendData", mode = "function", 
[08:29:10.961]                       envir = ns)) {
[08:29:10.961]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:10.961]                         envir = ns)
[08:29:10.961]                       envir <- sys.frame(frame)
[08:29:10.961]                       master <- NULL
[08:29:10.961]                       while (!identical(envir, .GlobalEnv) && 
[08:29:10.961]                         !identical(envir, emptyenv())) {
[08:29:10.961]                         if (exists("master", mode = "list", envir = envir, 
[08:29:10.961]                           inherits = FALSE)) {
[08:29:10.961]                           master <- get("master", mode = "list", 
[08:29:10.961]                             envir = envir, inherits = FALSE)
[08:29:10.961]                           if (inherits(master, c("SOCKnode", 
[08:29:10.961]                             "SOCK0node"))) {
[08:29:10.961]                             sendCondition <<- function(cond) {
[08:29:10.961]                               data <- list(type = "VALUE", value = cond, 
[08:29:10.961]                                 success = TRUE)
[08:29:10.961]                               parallel_sendData(master, data)
[08:29:10.961]                             }
[08:29:10.961]                             return(sendCondition)
[08:29:10.961]                           }
[08:29:10.961]                         }
[08:29:10.961]                         frame <- frame + 1L
[08:29:10.961]                         envir <- sys.frame(frame)
[08:29:10.961]                       }
[08:29:10.961]                     }
[08:29:10.961]                     sendCondition <<- function(cond) NULL
[08:29:10.961]                   }
[08:29:10.961]                 })
[08:29:10.961]                 withCallingHandlers({
[08:29:10.961]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:10.961]                 }, immediateCondition = function(cond) {
[08:29:10.961]                   sendCondition <- ...future.makeSendCondition()
[08:29:10.961]                   sendCondition(cond)
[08:29:10.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:10.961]                   {
[08:29:10.961]                     inherits <- base::inherits
[08:29:10.961]                     invokeRestart <- base::invokeRestart
[08:29:10.961]                     is.null <- base::is.null
[08:29:10.961]                     muffled <- FALSE
[08:29:10.961]                     if (inherits(cond, "message")) {
[08:29:10.961]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:10.961]                       if (muffled) 
[08:29:10.961]                         invokeRestart("muffleMessage")
[08:29:10.961]                     }
[08:29:10.961]                     else if (inherits(cond, "warning")) {
[08:29:10.961]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:10.961]                       if (muffled) 
[08:29:10.961]                         invokeRestart("muffleWarning")
[08:29:10.961]                     }
[08:29:10.961]                     else if (inherits(cond, "condition")) {
[08:29:10.961]                       if (!is.null(pattern)) {
[08:29:10.961]                         computeRestarts <- base::computeRestarts
[08:29:10.961]                         grepl <- base::grepl
[08:29:10.961]                         restarts <- computeRestarts(cond)
[08:29:10.961]                         for (restart in restarts) {
[08:29:10.961]                           name <- restart$name
[08:29:10.961]                           if (is.null(name)) 
[08:29:10.961]                             next
[08:29:10.961]                           if (!grepl(pattern, name)) 
[08:29:10.961]                             next
[08:29:10.961]                           invokeRestart(restart)
[08:29:10.961]                           muffled <- TRUE
[08:29:10.961]                           break
[08:29:10.961]                         }
[08:29:10.961]                       }
[08:29:10.961]                     }
[08:29:10.961]                     invisible(muffled)
[08:29:10.961]                   }
[08:29:10.961]                   muffleCondition(cond)
[08:29:10.961]                 })
[08:29:10.961]             }))
[08:29:10.961]             future::FutureResult(value = ...future.value$value, 
[08:29:10.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:10.961]                   ...future.rng), globalenv = if (FALSE) 
[08:29:10.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:10.961]                     ...future.globalenv.names))
[08:29:10.961]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:10.961]         }, condition = base::local({
[08:29:10.961]             c <- base::c
[08:29:10.961]             inherits <- base::inherits
[08:29:10.961]             invokeRestart <- base::invokeRestart
[08:29:10.961]             length <- base::length
[08:29:10.961]             list <- base::list
[08:29:10.961]             seq.int <- base::seq.int
[08:29:10.961]             signalCondition <- base::signalCondition
[08:29:10.961]             sys.calls <- base::sys.calls
[08:29:10.961]             `[[` <- base::`[[`
[08:29:10.961]             `+` <- base::`+`
[08:29:10.961]             `<<-` <- base::`<<-`
[08:29:10.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:10.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:10.961]                   3L)]
[08:29:10.961]             }
[08:29:10.961]             function(cond) {
[08:29:10.961]                 is_error <- inherits(cond, "error")
[08:29:10.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:10.961]                   NULL)
[08:29:10.961]                 if (is_error) {
[08:29:10.961]                   sessionInformation <- function() {
[08:29:10.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:10.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:10.961]                       search = base::search(), system = base::Sys.info())
[08:29:10.961]                   }
[08:29:10.961]                   ...future.conditions[[length(...future.conditions) + 
[08:29:10.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:10.961]                     cond$call), session = sessionInformation(), 
[08:29:10.961]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:10.961]                   signalCondition(cond)
[08:29:10.961]                 }
[08:29:10.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:10.961]                 "immediateCondition"))) {
[08:29:10.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:10.961]                   ...future.conditions[[length(...future.conditions) + 
[08:29:10.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:10.961]                   if (TRUE && !signal) {
[08:29:10.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:10.961]                     {
[08:29:10.961]                       inherits <- base::inherits
[08:29:10.961]                       invokeRestart <- base::invokeRestart
[08:29:10.961]                       is.null <- base::is.null
[08:29:10.961]                       muffled <- FALSE
[08:29:10.961]                       if (inherits(cond, "message")) {
[08:29:10.961]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:10.961]                         if (muffled) 
[08:29:10.961]                           invokeRestart("muffleMessage")
[08:29:10.961]                       }
[08:29:10.961]                       else if (inherits(cond, "warning")) {
[08:29:10.961]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:10.961]                         if (muffled) 
[08:29:10.961]                           invokeRestart("muffleWarning")
[08:29:10.961]                       }
[08:29:10.961]                       else if (inherits(cond, "condition")) {
[08:29:10.961]                         if (!is.null(pattern)) {
[08:29:10.961]                           computeRestarts <- base::computeRestarts
[08:29:10.961]                           grepl <- base::grepl
[08:29:10.961]                           restarts <- computeRestarts(cond)
[08:29:10.961]                           for (restart in restarts) {
[08:29:10.961]                             name <- restart$name
[08:29:10.961]                             if (is.null(name)) 
[08:29:10.961]                               next
[08:29:10.961]                             if (!grepl(pattern, name)) 
[08:29:10.961]                               next
[08:29:10.961]                             invokeRestart(restart)
[08:29:10.961]                             muffled <- TRUE
[08:29:10.961]                             break
[08:29:10.961]                           }
[08:29:10.961]                         }
[08:29:10.961]                       }
[08:29:10.961]                       invisible(muffled)
[08:29:10.961]                     }
[08:29:10.961]                     muffleCondition(cond, pattern = "^muffle")
[08:29:10.961]                   }
[08:29:10.961]                 }
[08:29:10.961]                 else {
[08:29:10.961]                   if (TRUE) {
[08:29:10.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:10.961]                     {
[08:29:10.961]                       inherits <- base::inherits
[08:29:10.961]                       invokeRestart <- base::invokeRestart
[08:29:10.961]                       is.null <- base::is.null
[08:29:10.961]                       muffled <- FALSE
[08:29:10.961]                       if (inherits(cond, "message")) {
[08:29:10.961]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:10.961]                         if (muffled) 
[08:29:10.961]                           invokeRestart("muffleMessage")
[08:29:10.961]                       }
[08:29:10.961]                       else if (inherits(cond, "warning")) {
[08:29:10.961]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:10.961]                         if (muffled) 
[08:29:10.961]                           invokeRestart("muffleWarning")
[08:29:10.961]                       }
[08:29:10.961]                       else if (inherits(cond, "condition")) {
[08:29:10.961]                         if (!is.null(pattern)) {
[08:29:10.961]                           computeRestarts <- base::computeRestarts
[08:29:10.961]                           grepl <- base::grepl
[08:29:10.961]                           restarts <- computeRestarts(cond)
[08:29:10.961]                           for (restart in restarts) {
[08:29:10.961]                             name <- restart$name
[08:29:10.961]                             if (is.null(name)) 
[08:29:10.961]                               next
[08:29:10.961]                             if (!grepl(pattern, name)) 
[08:29:10.961]                               next
[08:29:10.961]                             invokeRestart(restart)
[08:29:10.961]                             muffled <- TRUE
[08:29:10.961]                             break
[08:29:10.961]                           }
[08:29:10.961]                         }
[08:29:10.961]                       }
[08:29:10.961]                       invisible(muffled)
[08:29:10.961]                     }
[08:29:10.961]                     muffleCondition(cond, pattern = "^muffle")
[08:29:10.961]                   }
[08:29:10.961]                 }
[08:29:10.961]             }
[08:29:10.961]         }))
[08:29:10.961]     }, error = function(ex) {
[08:29:10.961]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:10.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:10.961]                 ...future.rng), started = ...future.startTime, 
[08:29:10.961]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:10.961]             version = "1.8"), class = "FutureResult")
[08:29:10.961]     }, finally = {
[08:29:10.961]         if (!identical(...future.workdir, getwd())) 
[08:29:10.961]             setwd(...future.workdir)
[08:29:10.961]         {
[08:29:10.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:10.961]                 ...future.oldOptions$nwarnings <- NULL
[08:29:10.961]             }
[08:29:10.961]             base::options(...future.oldOptions)
[08:29:10.961]             if (.Platform$OS.type == "windows") {
[08:29:10.961]                 old_names <- names(...future.oldEnvVars)
[08:29:10.961]                 envs <- base::Sys.getenv()
[08:29:10.961]                 names <- names(envs)
[08:29:10.961]                 common <- intersect(names, old_names)
[08:29:10.961]                 added <- setdiff(names, old_names)
[08:29:10.961]                 removed <- setdiff(old_names, names)
[08:29:10.961]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:10.961]                   envs[common]]
[08:29:10.961]                 NAMES <- toupper(changed)
[08:29:10.961]                 args <- list()
[08:29:10.961]                 for (kk in seq_along(NAMES)) {
[08:29:10.961]                   name <- changed[[kk]]
[08:29:10.961]                   NAME <- NAMES[[kk]]
[08:29:10.961]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:10.961]                     next
[08:29:10.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:10.961]                 }
[08:29:10.961]                 NAMES <- toupper(added)
[08:29:10.961]                 for (kk in seq_along(NAMES)) {
[08:29:10.961]                   name <- added[[kk]]
[08:29:10.961]                   NAME <- NAMES[[kk]]
[08:29:10.961]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:10.961]                     next
[08:29:10.961]                   args[[name]] <- ""
[08:29:10.961]                 }
[08:29:10.961]                 NAMES <- toupper(removed)
[08:29:10.961]                 for (kk in seq_along(NAMES)) {
[08:29:10.961]                   name <- removed[[kk]]
[08:29:10.961]                   NAME <- NAMES[[kk]]
[08:29:10.961]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:10.961]                     next
[08:29:10.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:10.961]                 }
[08:29:10.961]                 if (length(args) > 0) 
[08:29:10.961]                   base::do.call(base::Sys.setenv, args = args)
[08:29:10.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:10.961]             }
[08:29:10.961]             else {
[08:29:10.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:10.961]             }
[08:29:10.961]             {
[08:29:10.961]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:10.961]                   0L) {
[08:29:10.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:10.961]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:10.961]                   base::options(opts)
[08:29:10.961]                 }
[08:29:10.961]                 {
[08:29:10.961]                   {
[08:29:10.961]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:10.961]                     NULL
[08:29:10.961]                   }
[08:29:10.961]                   options(future.plan = NULL)
[08:29:10.961]                   if (is.na(NA_character_)) 
[08:29:10.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:10.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:10.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:10.961]                     .init = FALSE)
[08:29:10.961]                 }
[08:29:10.961]             }
[08:29:10.961]         }
[08:29:10.961]     })
[08:29:10.961]     if (TRUE) {
[08:29:10.961]         base::sink(type = "output", split = FALSE)
[08:29:10.961]         if (TRUE) {
[08:29:10.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:10.961]         }
[08:29:10.961]         else {
[08:29:10.961]             ...future.result["stdout"] <- base::list(NULL)
[08:29:10.961]         }
[08:29:10.961]         base::close(...future.stdout)
[08:29:10.961]         ...future.stdout <- NULL
[08:29:10.961]     }
[08:29:10.961]     ...future.result$conditions <- ...future.conditions
[08:29:10.961]     ...future.result$finished <- base::Sys.time()
[08:29:10.961]     ...future.result
[08:29:10.961] }
[08:29:10.964] MultisessionFuture started
[08:29:10.964] - Launch lazy future ... done
[08:29:10.964] run() for ‘MultisessionFuture’ ... done
[08:29:11.006] receiveMessageFromWorker() for ClusterFuture ...
[08:29:11.006] - Validating connection of MultisessionFuture
[08:29:11.007] - received message: FutureResult
[08:29:11.007] - Received FutureResult
[08:29:11.007] - Erased future from FutureRegistry
[08:29:11.007] result() for ClusterFuture ...
[08:29:11.007] - result already collected: FutureResult
[08:29:11.007] result() for ClusterFuture ... done
[08:29:11.007] signalConditions() ...
[08:29:11.007]  - include = ‘immediateCondition’
[08:29:11.008]  - exclude = 
[08:29:11.008]  - resignal = FALSE
[08:29:11.008]  - Number of conditions: 1
[08:29:11.008] signalConditions() ... done
[08:29:11.008] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:11.008] A MultisessionFuture was resolved (result was not collected)
[08:29:11.008] getGlobalsAndPackages() ...
[08:29:11.008] Searching for globals...
[08:29:11.009] - globals found: [2] ‘list’, ‘stop’
[08:29:11.009] Searching for globals ... DONE
[08:29:11.009] Resolving globals: FALSE
[08:29:11.009] 
[08:29:11.009] 
[08:29:11.009] getGlobalsAndPackages() ... DONE
[08:29:11.010] run() for ‘Future’ ...
[08:29:11.010] - state: ‘created’
[08:29:11.010] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:11.025] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:11.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:11.025]   - Field: ‘node’
[08:29:11.025]   - Field: ‘label’
[08:29:11.025]   - Field: ‘local’
[08:29:11.025]   - Field: ‘owner’
[08:29:11.025]   - Field: ‘envir’
[08:29:11.025]   - Field: ‘workers’
[08:29:11.025]   - Field: ‘packages’
[08:29:11.025]   - Field: ‘gc’
[08:29:11.026]   - Field: ‘conditions’
[08:29:11.026]   - Field: ‘persistent’
[08:29:11.026]   - Field: ‘expr’
[08:29:11.026]   - Field: ‘uuid’
[08:29:11.026]   - Field: ‘seed’
[08:29:11.026]   - Field: ‘version’
[08:29:11.026]   - Field: ‘result’
[08:29:11.026]   - Field: ‘asynchronous’
[08:29:11.026]   - Field: ‘calls’
[08:29:11.026]   - Field: ‘globals’
[08:29:11.026]   - Field: ‘stdout’
[08:29:11.026]   - Field: ‘earlySignal’
[08:29:11.027]   - Field: ‘lazy’
[08:29:11.027]   - Field: ‘state’
[08:29:11.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:11.027] - Launch lazy future ...
[08:29:11.027] Packages needed by the future expression (n = 0): <none>
[08:29:11.027] Packages needed by future strategies (n = 0): <none>
[08:29:11.028] {
[08:29:11.028]     {
[08:29:11.028]         {
[08:29:11.028]             ...future.startTime <- base::Sys.time()
[08:29:11.028]             {
[08:29:11.028]                 {
[08:29:11.028]                   {
[08:29:11.028]                     {
[08:29:11.028]                       base::local({
[08:29:11.028]                         has_future <- base::requireNamespace("future", 
[08:29:11.028]                           quietly = TRUE)
[08:29:11.028]                         if (has_future) {
[08:29:11.028]                           ns <- base::getNamespace("future")
[08:29:11.028]                           version <- ns[[".package"]][["version"]]
[08:29:11.028]                           if (is.null(version)) 
[08:29:11.028]                             version <- utils::packageVersion("future")
[08:29:11.028]                         }
[08:29:11.028]                         else {
[08:29:11.028]                           version <- NULL
[08:29:11.028]                         }
[08:29:11.028]                         if (!has_future || version < "1.8.0") {
[08:29:11.028]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:11.028]                             "", base::R.version$version.string), 
[08:29:11.028]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:11.028]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:11.028]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:11.028]                               "release", "version")], collapse = " "), 
[08:29:11.028]                             hostname = base::Sys.info()[["nodename"]])
[08:29:11.028]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:11.028]                             info)
[08:29:11.028]                           info <- base::paste(info, collapse = "; ")
[08:29:11.028]                           if (!has_future) {
[08:29:11.028]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:11.028]                               info)
[08:29:11.028]                           }
[08:29:11.028]                           else {
[08:29:11.028]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:11.028]                               info, version)
[08:29:11.028]                           }
[08:29:11.028]                           base::stop(msg)
[08:29:11.028]                         }
[08:29:11.028]                       })
[08:29:11.028]                     }
[08:29:11.028]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:11.028]                     base::options(mc.cores = 1L)
[08:29:11.028]                   }
[08:29:11.028]                   ...future.strategy.old <- future::plan("list")
[08:29:11.028]                   options(future.plan = NULL)
[08:29:11.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:11.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:11.028]                 }
[08:29:11.028]                 ...future.workdir <- getwd()
[08:29:11.028]             }
[08:29:11.028]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:11.028]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:11.028]         }
[08:29:11.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:11.028]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:11.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:11.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:11.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:11.028]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:11.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:11.028]             base::names(...future.oldOptions))
[08:29:11.028]     }
[08:29:11.028]     if (FALSE) {
[08:29:11.028]     }
[08:29:11.028]     else {
[08:29:11.028]         if (TRUE) {
[08:29:11.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:11.028]                 open = "w")
[08:29:11.028]         }
[08:29:11.028]         else {
[08:29:11.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:11.028]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:11.028]         }
[08:29:11.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:11.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:11.028]             base::sink(type = "output", split = FALSE)
[08:29:11.028]             base::close(...future.stdout)
[08:29:11.028]         }, add = TRUE)
[08:29:11.028]     }
[08:29:11.028]     ...future.frame <- base::sys.nframe()
[08:29:11.028]     ...future.conditions <- base::list()
[08:29:11.028]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:11.028]     if (FALSE) {
[08:29:11.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:11.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:11.028]     }
[08:29:11.028]     ...future.result <- base::tryCatch({
[08:29:11.028]         base::withCallingHandlers({
[08:29:11.028]             ...future.value <- base::withVisible(base::local({
[08:29:11.028]                 ...future.makeSendCondition <- base::local({
[08:29:11.028]                   sendCondition <- NULL
[08:29:11.028]                   function(frame = 1L) {
[08:29:11.028]                     if (is.function(sendCondition)) 
[08:29:11.028]                       return(sendCondition)
[08:29:11.028]                     ns <- getNamespace("parallel")
[08:29:11.028]                     if (exists("sendData", mode = "function", 
[08:29:11.028]                       envir = ns)) {
[08:29:11.028]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:11.028]                         envir = ns)
[08:29:11.028]                       envir <- sys.frame(frame)
[08:29:11.028]                       master <- NULL
[08:29:11.028]                       while (!identical(envir, .GlobalEnv) && 
[08:29:11.028]                         !identical(envir, emptyenv())) {
[08:29:11.028]                         if (exists("master", mode = "list", envir = envir, 
[08:29:11.028]                           inherits = FALSE)) {
[08:29:11.028]                           master <- get("master", mode = "list", 
[08:29:11.028]                             envir = envir, inherits = FALSE)
[08:29:11.028]                           if (inherits(master, c("SOCKnode", 
[08:29:11.028]                             "SOCK0node"))) {
[08:29:11.028]                             sendCondition <<- function(cond) {
[08:29:11.028]                               data <- list(type = "VALUE", value = cond, 
[08:29:11.028]                                 success = TRUE)
[08:29:11.028]                               parallel_sendData(master, data)
[08:29:11.028]                             }
[08:29:11.028]                             return(sendCondition)
[08:29:11.028]                           }
[08:29:11.028]                         }
[08:29:11.028]                         frame <- frame + 1L
[08:29:11.028]                         envir <- sys.frame(frame)
[08:29:11.028]                       }
[08:29:11.028]                     }
[08:29:11.028]                     sendCondition <<- function(cond) NULL
[08:29:11.028]                   }
[08:29:11.028]                 })
[08:29:11.028]                 withCallingHandlers({
[08:29:11.028]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:11.028]                 }, immediateCondition = function(cond) {
[08:29:11.028]                   sendCondition <- ...future.makeSendCondition()
[08:29:11.028]                   sendCondition(cond)
[08:29:11.028]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:11.028]                   {
[08:29:11.028]                     inherits <- base::inherits
[08:29:11.028]                     invokeRestart <- base::invokeRestart
[08:29:11.028]                     is.null <- base::is.null
[08:29:11.028]                     muffled <- FALSE
[08:29:11.028]                     if (inherits(cond, "message")) {
[08:29:11.028]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:11.028]                       if (muffled) 
[08:29:11.028]                         invokeRestart("muffleMessage")
[08:29:11.028]                     }
[08:29:11.028]                     else if (inherits(cond, "warning")) {
[08:29:11.028]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:11.028]                       if (muffled) 
[08:29:11.028]                         invokeRestart("muffleWarning")
[08:29:11.028]                     }
[08:29:11.028]                     else if (inherits(cond, "condition")) {
[08:29:11.028]                       if (!is.null(pattern)) {
[08:29:11.028]                         computeRestarts <- base::computeRestarts
[08:29:11.028]                         grepl <- base::grepl
[08:29:11.028]                         restarts <- computeRestarts(cond)
[08:29:11.028]                         for (restart in restarts) {
[08:29:11.028]                           name <- restart$name
[08:29:11.028]                           if (is.null(name)) 
[08:29:11.028]                             next
[08:29:11.028]                           if (!grepl(pattern, name)) 
[08:29:11.028]                             next
[08:29:11.028]                           invokeRestart(restart)
[08:29:11.028]                           muffled <- TRUE
[08:29:11.028]                           break
[08:29:11.028]                         }
[08:29:11.028]                       }
[08:29:11.028]                     }
[08:29:11.028]                     invisible(muffled)
[08:29:11.028]                   }
[08:29:11.028]                   muffleCondition(cond)
[08:29:11.028]                 })
[08:29:11.028]             }))
[08:29:11.028]             future::FutureResult(value = ...future.value$value, 
[08:29:11.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:11.028]                   ...future.rng), globalenv = if (FALSE) 
[08:29:11.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:11.028]                     ...future.globalenv.names))
[08:29:11.028]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:11.028]         }, condition = base::local({
[08:29:11.028]             c <- base::c
[08:29:11.028]             inherits <- base::inherits
[08:29:11.028]             invokeRestart <- base::invokeRestart
[08:29:11.028]             length <- base::length
[08:29:11.028]             list <- base::list
[08:29:11.028]             seq.int <- base::seq.int
[08:29:11.028]             signalCondition <- base::signalCondition
[08:29:11.028]             sys.calls <- base::sys.calls
[08:29:11.028]             `[[` <- base::`[[`
[08:29:11.028]             `+` <- base::`+`
[08:29:11.028]             `<<-` <- base::`<<-`
[08:29:11.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:11.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:11.028]                   3L)]
[08:29:11.028]             }
[08:29:11.028]             function(cond) {
[08:29:11.028]                 is_error <- inherits(cond, "error")
[08:29:11.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:11.028]                   NULL)
[08:29:11.028]                 if (is_error) {
[08:29:11.028]                   sessionInformation <- function() {
[08:29:11.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:11.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:11.028]                       search = base::search(), system = base::Sys.info())
[08:29:11.028]                   }
[08:29:11.028]                   ...future.conditions[[length(...future.conditions) + 
[08:29:11.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:11.028]                     cond$call), session = sessionInformation(), 
[08:29:11.028]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:11.028]                   signalCondition(cond)
[08:29:11.028]                 }
[08:29:11.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:11.028]                 "immediateCondition"))) {
[08:29:11.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:11.028]                   ...future.conditions[[length(...future.conditions) + 
[08:29:11.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:11.028]                   if (TRUE && !signal) {
[08:29:11.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:11.028]                     {
[08:29:11.028]                       inherits <- base::inherits
[08:29:11.028]                       invokeRestart <- base::invokeRestart
[08:29:11.028]                       is.null <- base::is.null
[08:29:11.028]                       muffled <- FALSE
[08:29:11.028]                       if (inherits(cond, "message")) {
[08:29:11.028]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:11.028]                         if (muffled) 
[08:29:11.028]                           invokeRestart("muffleMessage")
[08:29:11.028]                       }
[08:29:11.028]                       else if (inherits(cond, "warning")) {
[08:29:11.028]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:11.028]                         if (muffled) 
[08:29:11.028]                           invokeRestart("muffleWarning")
[08:29:11.028]                       }
[08:29:11.028]                       else if (inherits(cond, "condition")) {
[08:29:11.028]                         if (!is.null(pattern)) {
[08:29:11.028]                           computeRestarts <- base::computeRestarts
[08:29:11.028]                           grepl <- base::grepl
[08:29:11.028]                           restarts <- computeRestarts(cond)
[08:29:11.028]                           for (restart in restarts) {
[08:29:11.028]                             name <- restart$name
[08:29:11.028]                             if (is.null(name)) 
[08:29:11.028]                               next
[08:29:11.028]                             if (!grepl(pattern, name)) 
[08:29:11.028]                               next
[08:29:11.028]                             invokeRestart(restart)
[08:29:11.028]                             muffled <- TRUE
[08:29:11.028]                             break
[08:29:11.028]                           }
[08:29:11.028]                         }
[08:29:11.028]                       }
[08:29:11.028]                       invisible(muffled)
[08:29:11.028]                     }
[08:29:11.028]                     muffleCondition(cond, pattern = "^muffle")
[08:29:11.028]                   }
[08:29:11.028]                 }
[08:29:11.028]                 else {
[08:29:11.028]                   if (TRUE) {
[08:29:11.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:11.028]                     {
[08:29:11.028]                       inherits <- base::inherits
[08:29:11.028]                       invokeRestart <- base::invokeRestart
[08:29:11.028]                       is.null <- base::is.null
[08:29:11.028]                       muffled <- FALSE
[08:29:11.028]                       if (inherits(cond, "message")) {
[08:29:11.028]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:11.028]                         if (muffled) 
[08:29:11.028]                           invokeRestart("muffleMessage")
[08:29:11.028]                       }
[08:29:11.028]                       else if (inherits(cond, "warning")) {
[08:29:11.028]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:11.028]                         if (muffled) 
[08:29:11.028]                           invokeRestart("muffleWarning")
[08:29:11.028]                       }
[08:29:11.028]                       else if (inherits(cond, "condition")) {
[08:29:11.028]                         if (!is.null(pattern)) {
[08:29:11.028]                           computeRestarts <- base::computeRestarts
[08:29:11.028]                           grepl <- base::grepl
[08:29:11.028]                           restarts <- computeRestarts(cond)
[08:29:11.028]                           for (restart in restarts) {
[08:29:11.028]                             name <- restart$name
[08:29:11.028]                             if (is.null(name)) 
[08:29:11.028]                               next
[08:29:11.028]                             if (!grepl(pattern, name)) 
[08:29:11.028]                               next
[08:29:11.028]                             invokeRestart(restart)
[08:29:11.028]                             muffled <- TRUE
[08:29:11.028]                             break
[08:29:11.028]                           }
[08:29:11.028]                         }
[08:29:11.028]                       }
[08:29:11.028]                       invisible(muffled)
[08:29:11.028]                     }
[08:29:11.028]                     muffleCondition(cond, pattern = "^muffle")
[08:29:11.028]                   }
[08:29:11.028]                 }
[08:29:11.028]             }
[08:29:11.028]         }))
[08:29:11.028]     }, error = function(ex) {
[08:29:11.028]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:11.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:11.028]                 ...future.rng), started = ...future.startTime, 
[08:29:11.028]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:11.028]             version = "1.8"), class = "FutureResult")
[08:29:11.028]     }, finally = {
[08:29:11.028]         if (!identical(...future.workdir, getwd())) 
[08:29:11.028]             setwd(...future.workdir)
[08:29:11.028]         {
[08:29:11.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:11.028]                 ...future.oldOptions$nwarnings <- NULL
[08:29:11.028]             }
[08:29:11.028]             base::options(...future.oldOptions)
[08:29:11.028]             if (.Platform$OS.type == "windows") {
[08:29:11.028]                 old_names <- names(...future.oldEnvVars)
[08:29:11.028]                 envs <- base::Sys.getenv()
[08:29:11.028]                 names <- names(envs)
[08:29:11.028]                 common <- intersect(names, old_names)
[08:29:11.028]                 added <- setdiff(names, old_names)
[08:29:11.028]                 removed <- setdiff(old_names, names)
[08:29:11.028]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:11.028]                   envs[common]]
[08:29:11.028]                 NAMES <- toupper(changed)
[08:29:11.028]                 args <- list()
[08:29:11.028]                 for (kk in seq_along(NAMES)) {
[08:29:11.028]                   name <- changed[[kk]]
[08:29:11.028]                   NAME <- NAMES[[kk]]
[08:29:11.028]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:11.028]                     next
[08:29:11.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:11.028]                 }
[08:29:11.028]                 NAMES <- toupper(added)
[08:29:11.028]                 for (kk in seq_along(NAMES)) {
[08:29:11.028]                   name <- added[[kk]]
[08:29:11.028]                   NAME <- NAMES[[kk]]
[08:29:11.028]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:11.028]                     next
[08:29:11.028]                   args[[name]] <- ""
[08:29:11.028]                 }
[08:29:11.028]                 NAMES <- toupper(removed)
[08:29:11.028]                 for (kk in seq_along(NAMES)) {
[08:29:11.028]                   name <- removed[[kk]]
[08:29:11.028]                   NAME <- NAMES[[kk]]
[08:29:11.028]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:11.028]                     next
[08:29:11.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:11.028]                 }
[08:29:11.028]                 if (length(args) > 0) 
[08:29:11.028]                   base::do.call(base::Sys.setenv, args = args)
[08:29:11.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:11.028]             }
[08:29:11.028]             else {
[08:29:11.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:11.028]             }
[08:29:11.028]             {
[08:29:11.028]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:11.028]                   0L) {
[08:29:11.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:11.028]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:11.028]                   base::options(opts)
[08:29:11.028]                 }
[08:29:11.028]                 {
[08:29:11.028]                   {
[08:29:11.028]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:11.028]                     NULL
[08:29:11.028]                   }
[08:29:11.028]                   options(future.plan = NULL)
[08:29:11.028]                   if (is.na(NA_character_)) 
[08:29:11.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:11.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:11.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:11.028]                     .init = FALSE)
[08:29:11.028]                 }
[08:29:11.028]             }
[08:29:11.028]         }
[08:29:11.028]     })
[08:29:11.028]     if (TRUE) {
[08:29:11.028]         base::sink(type = "output", split = FALSE)
[08:29:11.028]         if (TRUE) {
[08:29:11.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:11.028]         }
[08:29:11.028]         else {
[08:29:11.028]             ...future.result["stdout"] <- base::list(NULL)
[08:29:11.028]         }
[08:29:11.028]         base::close(...future.stdout)
[08:29:11.028]         ...future.stdout <- NULL
[08:29:11.028]     }
[08:29:11.028]     ...future.result$conditions <- ...future.conditions
[08:29:11.028]     ...future.result$finished <- base::Sys.time()
[08:29:11.028]     ...future.result
[08:29:11.028] }
[08:29:11.031] MultisessionFuture started
[08:29:11.031] - Launch lazy future ... done
[08:29:11.031] run() for ‘MultisessionFuture’ ... done
[08:29:11.073] receiveMessageFromWorker() for ClusterFuture ...
[08:29:11.073] - Validating connection of MultisessionFuture
[08:29:11.074] - received message: FutureResult
[08:29:11.074] - Received FutureResult
[08:29:11.074] - Erased future from FutureRegistry
[08:29:11.074] result() for ClusterFuture ...
[08:29:11.074] - result already collected: FutureResult
[08:29:11.074] result() for ClusterFuture ... done
[08:29:11.074] signalConditions() ...
[08:29:11.074]  - include = ‘immediateCondition’
[08:29:11.074]  - exclude = 
[08:29:11.074]  - resignal = FALSE
[08:29:11.074]  - Number of conditions: 1
[08:29:11.075] signalConditions() ... done
[08:29:11.075] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:11.075] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[08:29:11.075] getGlobalsAndPackages() ...
[08:29:11.075] Searching for globals...
[08:29:11.076] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:11.076] Searching for globals ... DONE
[08:29:11.076] Resolving globals: FALSE
[08:29:11.077] 
[08:29:11.077] 
[08:29:11.077] getGlobalsAndPackages() ... DONE
[08:29:11.077] run() for ‘Future’ ...
[08:29:11.077] - state: ‘created’
[08:29:11.077] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:11.091] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:11.091] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:11.091]   - Field: ‘node’
[08:29:11.091]   - Field: ‘label’
[08:29:11.091]   - Field: ‘local’
[08:29:11.091]   - Field: ‘owner’
[08:29:11.091]   - Field: ‘envir’
[08:29:11.092]   - Field: ‘workers’
[08:29:11.092]   - Field: ‘packages’
[08:29:11.092]   - Field: ‘gc’
[08:29:11.092]   - Field: ‘conditions’
[08:29:11.092]   - Field: ‘persistent’
[08:29:11.092]   - Field: ‘expr’
[08:29:11.092]   - Field: ‘uuid’
[08:29:11.092]   - Field: ‘seed’
[08:29:11.092]   - Field: ‘version’
[08:29:11.092]   - Field: ‘result’
[08:29:11.092]   - Field: ‘asynchronous’
[08:29:11.092]   - Field: ‘calls’
[08:29:11.093]   - Field: ‘globals’
[08:29:11.093]   - Field: ‘stdout’
[08:29:11.093]   - Field: ‘earlySignal’
[08:29:11.093]   - Field: ‘lazy’
[08:29:11.093]   - Field: ‘state’
[08:29:11.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:11.093] - Launch lazy future ...
[08:29:11.093] Packages needed by the future expression (n = 0): <none>
[08:29:11.093] Packages needed by future strategies (n = 0): <none>
[08:29:11.094] {
[08:29:11.094]     {
[08:29:11.094]         {
[08:29:11.094]             ...future.startTime <- base::Sys.time()
[08:29:11.094]             {
[08:29:11.094]                 {
[08:29:11.094]                   {
[08:29:11.094]                     {
[08:29:11.094]                       base::local({
[08:29:11.094]                         has_future <- base::requireNamespace("future", 
[08:29:11.094]                           quietly = TRUE)
[08:29:11.094]                         if (has_future) {
[08:29:11.094]                           ns <- base::getNamespace("future")
[08:29:11.094]                           version <- ns[[".package"]][["version"]]
[08:29:11.094]                           if (is.null(version)) 
[08:29:11.094]                             version <- utils::packageVersion("future")
[08:29:11.094]                         }
[08:29:11.094]                         else {
[08:29:11.094]                           version <- NULL
[08:29:11.094]                         }
[08:29:11.094]                         if (!has_future || version < "1.8.0") {
[08:29:11.094]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:11.094]                             "", base::R.version$version.string), 
[08:29:11.094]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:11.094]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:11.094]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:11.094]                               "release", "version")], collapse = " "), 
[08:29:11.094]                             hostname = base::Sys.info()[["nodename"]])
[08:29:11.094]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:11.094]                             info)
[08:29:11.094]                           info <- base::paste(info, collapse = "; ")
[08:29:11.094]                           if (!has_future) {
[08:29:11.094]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:11.094]                               info)
[08:29:11.094]                           }
[08:29:11.094]                           else {
[08:29:11.094]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:11.094]                               info, version)
[08:29:11.094]                           }
[08:29:11.094]                           base::stop(msg)
[08:29:11.094]                         }
[08:29:11.094]                       })
[08:29:11.094]                     }
[08:29:11.094]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:11.094]                     base::options(mc.cores = 1L)
[08:29:11.094]                   }
[08:29:11.094]                   ...future.strategy.old <- future::plan("list")
[08:29:11.094]                   options(future.plan = NULL)
[08:29:11.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:11.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:11.094]                 }
[08:29:11.094]                 ...future.workdir <- getwd()
[08:29:11.094]             }
[08:29:11.094]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:11.094]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:11.094]         }
[08:29:11.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:11.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:11.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:11.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:11.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:11.094]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:11.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:11.094]             base::names(...future.oldOptions))
[08:29:11.094]     }
[08:29:11.094]     if (FALSE) {
[08:29:11.094]     }
[08:29:11.094]     else {
[08:29:11.094]         if (TRUE) {
[08:29:11.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:11.094]                 open = "w")
[08:29:11.094]         }
[08:29:11.094]         else {
[08:29:11.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:11.094]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:11.094]         }
[08:29:11.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:11.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:11.094]             base::sink(type = "output", split = FALSE)
[08:29:11.094]             base::close(...future.stdout)
[08:29:11.094]         }, add = TRUE)
[08:29:11.094]     }
[08:29:11.094]     ...future.frame <- base::sys.nframe()
[08:29:11.094]     ...future.conditions <- base::list()
[08:29:11.094]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:11.094]     if (FALSE) {
[08:29:11.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:11.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:11.094]     }
[08:29:11.094]     ...future.result <- base::tryCatch({
[08:29:11.094]         base::withCallingHandlers({
[08:29:11.094]             ...future.value <- base::withVisible(base::local({
[08:29:11.094]                 ...future.makeSendCondition <- base::local({
[08:29:11.094]                   sendCondition <- NULL
[08:29:11.094]                   function(frame = 1L) {
[08:29:11.094]                     if (is.function(sendCondition)) 
[08:29:11.094]                       return(sendCondition)
[08:29:11.094]                     ns <- getNamespace("parallel")
[08:29:11.094]                     if (exists("sendData", mode = "function", 
[08:29:11.094]                       envir = ns)) {
[08:29:11.094]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:11.094]                         envir = ns)
[08:29:11.094]                       envir <- sys.frame(frame)
[08:29:11.094]                       master <- NULL
[08:29:11.094]                       while (!identical(envir, .GlobalEnv) && 
[08:29:11.094]                         !identical(envir, emptyenv())) {
[08:29:11.094]                         if (exists("master", mode = "list", envir = envir, 
[08:29:11.094]                           inherits = FALSE)) {
[08:29:11.094]                           master <- get("master", mode = "list", 
[08:29:11.094]                             envir = envir, inherits = FALSE)
[08:29:11.094]                           if (inherits(master, c("SOCKnode", 
[08:29:11.094]                             "SOCK0node"))) {
[08:29:11.094]                             sendCondition <<- function(cond) {
[08:29:11.094]                               data <- list(type = "VALUE", value = cond, 
[08:29:11.094]                                 success = TRUE)
[08:29:11.094]                               parallel_sendData(master, data)
[08:29:11.094]                             }
[08:29:11.094]                             return(sendCondition)
[08:29:11.094]                           }
[08:29:11.094]                         }
[08:29:11.094]                         frame <- frame + 1L
[08:29:11.094]                         envir <- sys.frame(frame)
[08:29:11.094]                       }
[08:29:11.094]                     }
[08:29:11.094]                     sendCondition <<- function(cond) NULL
[08:29:11.094]                   }
[08:29:11.094]                 })
[08:29:11.094]                 withCallingHandlers({
[08:29:11.094]                   {
[08:29:11.094]                     Sys.sleep(0.5)
[08:29:11.094]                     list(a = 1, b = 42L)
[08:29:11.094]                   }
[08:29:11.094]                 }, immediateCondition = function(cond) {
[08:29:11.094]                   sendCondition <- ...future.makeSendCondition()
[08:29:11.094]                   sendCondition(cond)
[08:29:11.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:11.094]                   {
[08:29:11.094]                     inherits <- base::inherits
[08:29:11.094]                     invokeRestart <- base::invokeRestart
[08:29:11.094]                     is.null <- base::is.null
[08:29:11.094]                     muffled <- FALSE
[08:29:11.094]                     if (inherits(cond, "message")) {
[08:29:11.094]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:11.094]                       if (muffled) 
[08:29:11.094]                         invokeRestart("muffleMessage")
[08:29:11.094]                     }
[08:29:11.094]                     else if (inherits(cond, "warning")) {
[08:29:11.094]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:11.094]                       if (muffled) 
[08:29:11.094]                         invokeRestart("muffleWarning")
[08:29:11.094]                     }
[08:29:11.094]                     else if (inherits(cond, "condition")) {
[08:29:11.094]                       if (!is.null(pattern)) {
[08:29:11.094]                         computeRestarts <- base::computeRestarts
[08:29:11.094]                         grepl <- base::grepl
[08:29:11.094]                         restarts <- computeRestarts(cond)
[08:29:11.094]                         for (restart in restarts) {
[08:29:11.094]                           name <- restart$name
[08:29:11.094]                           if (is.null(name)) 
[08:29:11.094]                             next
[08:29:11.094]                           if (!grepl(pattern, name)) 
[08:29:11.094]                             next
[08:29:11.094]                           invokeRestart(restart)
[08:29:11.094]                           muffled <- TRUE
[08:29:11.094]                           break
[08:29:11.094]                         }
[08:29:11.094]                       }
[08:29:11.094]                     }
[08:29:11.094]                     invisible(muffled)
[08:29:11.094]                   }
[08:29:11.094]                   muffleCondition(cond)
[08:29:11.094]                 })
[08:29:11.094]             }))
[08:29:11.094]             future::FutureResult(value = ...future.value$value, 
[08:29:11.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:11.094]                   ...future.rng), globalenv = if (FALSE) 
[08:29:11.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:11.094]                     ...future.globalenv.names))
[08:29:11.094]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:11.094]         }, condition = base::local({
[08:29:11.094]             c <- base::c
[08:29:11.094]             inherits <- base::inherits
[08:29:11.094]             invokeRestart <- base::invokeRestart
[08:29:11.094]             length <- base::length
[08:29:11.094]             list <- base::list
[08:29:11.094]             seq.int <- base::seq.int
[08:29:11.094]             signalCondition <- base::signalCondition
[08:29:11.094]             sys.calls <- base::sys.calls
[08:29:11.094]             `[[` <- base::`[[`
[08:29:11.094]             `+` <- base::`+`
[08:29:11.094]             `<<-` <- base::`<<-`
[08:29:11.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:11.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:11.094]                   3L)]
[08:29:11.094]             }
[08:29:11.094]             function(cond) {
[08:29:11.094]                 is_error <- inherits(cond, "error")
[08:29:11.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:11.094]                   NULL)
[08:29:11.094]                 if (is_error) {
[08:29:11.094]                   sessionInformation <- function() {
[08:29:11.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:11.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:11.094]                       search = base::search(), system = base::Sys.info())
[08:29:11.094]                   }
[08:29:11.094]                   ...future.conditions[[length(...future.conditions) + 
[08:29:11.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:11.094]                     cond$call), session = sessionInformation(), 
[08:29:11.094]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:11.094]                   signalCondition(cond)
[08:29:11.094]                 }
[08:29:11.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:11.094]                 "immediateCondition"))) {
[08:29:11.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:11.094]                   ...future.conditions[[length(...future.conditions) + 
[08:29:11.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:11.094]                   if (TRUE && !signal) {
[08:29:11.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:11.094]                     {
[08:29:11.094]                       inherits <- base::inherits
[08:29:11.094]                       invokeRestart <- base::invokeRestart
[08:29:11.094]                       is.null <- base::is.null
[08:29:11.094]                       muffled <- FALSE
[08:29:11.094]                       if (inherits(cond, "message")) {
[08:29:11.094]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:11.094]                         if (muffled) 
[08:29:11.094]                           invokeRestart("muffleMessage")
[08:29:11.094]                       }
[08:29:11.094]                       else if (inherits(cond, "warning")) {
[08:29:11.094]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:11.094]                         if (muffled) 
[08:29:11.094]                           invokeRestart("muffleWarning")
[08:29:11.094]                       }
[08:29:11.094]                       else if (inherits(cond, "condition")) {
[08:29:11.094]                         if (!is.null(pattern)) {
[08:29:11.094]                           computeRestarts <- base::computeRestarts
[08:29:11.094]                           grepl <- base::grepl
[08:29:11.094]                           restarts <- computeRestarts(cond)
[08:29:11.094]                           for (restart in restarts) {
[08:29:11.094]                             name <- restart$name
[08:29:11.094]                             if (is.null(name)) 
[08:29:11.094]                               next
[08:29:11.094]                             if (!grepl(pattern, name)) 
[08:29:11.094]                               next
[08:29:11.094]                             invokeRestart(restart)
[08:29:11.094]                             muffled <- TRUE
[08:29:11.094]                             break
[08:29:11.094]                           }
[08:29:11.094]                         }
[08:29:11.094]                       }
[08:29:11.094]                       invisible(muffled)
[08:29:11.094]                     }
[08:29:11.094]                     muffleCondition(cond, pattern = "^muffle")
[08:29:11.094]                   }
[08:29:11.094]                 }
[08:29:11.094]                 else {
[08:29:11.094]                   if (TRUE) {
[08:29:11.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:11.094]                     {
[08:29:11.094]                       inherits <- base::inherits
[08:29:11.094]                       invokeRestart <- base::invokeRestart
[08:29:11.094]                       is.null <- base::is.null
[08:29:11.094]                       muffled <- FALSE
[08:29:11.094]                       if (inherits(cond, "message")) {
[08:29:11.094]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:11.094]                         if (muffled) 
[08:29:11.094]                           invokeRestart("muffleMessage")
[08:29:11.094]                       }
[08:29:11.094]                       else if (inherits(cond, "warning")) {
[08:29:11.094]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:11.094]                         if (muffled) 
[08:29:11.094]                           invokeRestart("muffleWarning")
[08:29:11.094]                       }
[08:29:11.094]                       else if (inherits(cond, "condition")) {
[08:29:11.094]                         if (!is.null(pattern)) {
[08:29:11.094]                           computeRestarts <- base::computeRestarts
[08:29:11.094]                           grepl <- base::grepl
[08:29:11.094]                           restarts <- computeRestarts(cond)
[08:29:11.094]                           for (restart in restarts) {
[08:29:11.094]                             name <- restart$name
[08:29:11.094]                             if (is.null(name)) 
[08:29:11.094]                               next
[08:29:11.094]                             if (!grepl(pattern, name)) 
[08:29:11.094]                               next
[08:29:11.094]                             invokeRestart(restart)
[08:29:11.094]                             muffled <- TRUE
[08:29:11.094]                             break
[08:29:11.094]                           }
[08:29:11.094]                         }
[08:29:11.094]                       }
[08:29:11.094]                       invisible(muffled)
[08:29:11.094]                     }
[08:29:11.094]                     muffleCondition(cond, pattern = "^muffle")
[08:29:11.094]                   }
[08:29:11.094]                 }
[08:29:11.094]             }
[08:29:11.094]         }))
[08:29:11.094]     }, error = function(ex) {
[08:29:11.094]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:11.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:11.094]                 ...future.rng), started = ...future.startTime, 
[08:29:11.094]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:11.094]             version = "1.8"), class = "FutureResult")
[08:29:11.094]     }, finally = {
[08:29:11.094]         if (!identical(...future.workdir, getwd())) 
[08:29:11.094]             setwd(...future.workdir)
[08:29:11.094]         {
[08:29:11.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:11.094]                 ...future.oldOptions$nwarnings <- NULL
[08:29:11.094]             }
[08:29:11.094]             base::options(...future.oldOptions)
[08:29:11.094]             if (.Platform$OS.type == "windows") {
[08:29:11.094]                 old_names <- names(...future.oldEnvVars)
[08:29:11.094]                 envs <- base::Sys.getenv()
[08:29:11.094]                 names <- names(envs)
[08:29:11.094]                 common <- intersect(names, old_names)
[08:29:11.094]                 added <- setdiff(names, old_names)
[08:29:11.094]                 removed <- setdiff(old_names, names)
[08:29:11.094]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:11.094]                   envs[common]]
[08:29:11.094]                 NAMES <- toupper(changed)
[08:29:11.094]                 args <- list()
[08:29:11.094]                 for (kk in seq_along(NAMES)) {
[08:29:11.094]                   name <- changed[[kk]]
[08:29:11.094]                   NAME <- NAMES[[kk]]
[08:29:11.094]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:11.094]                     next
[08:29:11.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:11.094]                 }
[08:29:11.094]                 NAMES <- toupper(added)
[08:29:11.094]                 for (kk in seq_along(NAMES)) {
[08:29:11.094]                   name <- added[[kk]]
[08:29:11.094]                   NAME <- NAMES[[kk]]
[08:29:11.094]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:11.094]                     next
[08:29:11.094]                   args[[name]] <- ""
[08:29:11.094]                 }
[08:29:11.094]                 NAMES <- toupper(removed)
[08:29:11.094]                 for (kk in seq_along(NAMES)) {
[08:29:11.094]                   name <- removed[[kk]]
[08:29:11.094]                   NAME <- NAMES[[kk]]
[08:29:11.094]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:11.094]                     next
[08:29:11.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:11.094]                 }
[08:29:11.094]                 if (length(args) > 0) 
[08:29:11.094]                   base::do.call(base::Sys.setenv, args = args)
[08:29:11.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:11.094]             }
[08:29:11.094]             else {
[08:29:11.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:11.094]             }
[08:29:11.094]             {
[08:29:11.094]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:11.094]                   0L) {
[08:29:11.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:11.094]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:11.094]                   base::options(opts)
[08:29:11.094]                 }
[08:29:11.094]                 {
[08:29:11.094]                   {
[08:29:11.094]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:11.094]                     NULL
[08:29:11.094]                   }
[08:29:11.094]                   options(future.plan = NULL)
[08:29:11.094]                   if (is.na(NA_character_)) 
[08:29:11.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:11.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:11.094]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:11.094]                     .init = FALSE)
[08:29:11.094]                 }
[08:29:11.094]             }
[08:29:11.094]         }
[08:29:11.094]     })
[08:29:11.094]     if (TRUE) {
[08:29:11.094]         base::sink(type = "output", split = FALSE)
[08:29:11.094]         if (TRUE) {
[08:29:11.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:11.094]         }
[08:29:11.094]         else {
[08:29:11.094]             ...future.result["stdout"] <- base::list(NULL)
[08:29:11.094]         }
[08:29:11.094]         base::close(...future.stdout)
[08:29:11.094]         ...future.stdout <- NULL
[08:29:11.094]     }
[08:29:11.094]     ...future.result$conditions <- ...future.conditions
[08:29:11.094]     ...future.result$finished <- base::Sys.time()
[08:29:11.094]     ...future.result
[08:29:11.094] }
[08:29:11.097] MultisessionFuture started
[08:29:11.097] - Launch lazy future ... done
[08:29:11.097] run() for ‘MultisessionFuture’ ... done
[08:29:11.640] receiveMessageFromWorker() for ClusterFuture ...
[08:29:11.640] - Validating connection of MultisessionFuture
[08:29:11.640] - received message: FutureResult
[08:29:11.640] - Received FutureResult
[08:29:11.641] - Erased future from FutureRegistry
[08:29:11.641] result() for ClusterFuture ...
[08:29:11.641] - result already collected: FutureResult
[08:29:11.641] result() for ClusterFuture ... done
[08:29:11.641] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:11.641] A MultisessionFuture was resolved (result was not collected)
[08:29:11.641] getGlobalsAndPackages() ...
[08:29:11.641] Searching for globals...
[08:29:11.642] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:11.642] Searching for globals ... DONE
[08:29:11.643] Resolving globals: FALSE
[08:29:11.643] 
[08:29:11.643] 
[08:29:11.643] getGlobalsAndPackages() ... DONE
[08:29:11.643] run() for ‘Future’ ...
[08:29:11.643] - state: ‘created’
[08:29:11.644] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:11.657] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:11.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:11.658]   - Field: ‘node’
[08:29:11.658]   - Field: ‘label’
[08:29:11.658]   - Field: ‘local’
[08:29:11.658]   - Field: ‘owner’
[08:29:11.658]   - Field: ‘envir’
[08:29:11.658]   - Field: ‘workers’
[08:29:11.658]   - Field: ‘packages’
[08:29:11.658]   - Field: ‘gc’
[08:29:11.658]   - Field: ‘conditions’
[08:29:11.658]   - Field: ‘persistent’
[08:29:11.658]   - Field: ‘expr’
[08:29:11.658]   - Field: ‘uuid’
[08:29:11.659]   - Field: ‘seed’
[08:29:11.659]   - Field: ‘version’
[08:29:11.659]   - Field: ‘result’
[08:29:11.659]   - Field: ‘asynchronous’
[08:29:11.659]   - Field: ‘calls’
[08:29:11.659]   - Field: ‘globals’
[08:29:11.659]   - Field: ‘stdout’
[08:29:11.659]   - Field: ‘earlySignal’
[08:29:11.659]   - Field: ‘lazy’
[08:29:11.659]   - Field: ‘state’
[08:29:11.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:11.660] - Launch lazy future ...
[08:29:11.660] Packages needed by the future expression (n = 0): <none>
[08:29:11.660] Packages needed by future strategies (n = 0): <none>
[08:29:11.660] {
[08:29:11.660]     {
[08:29:11.660]         {
[08:29:11.660]             ...future.startTime <- base::Sys.time()
[08:29:11.660]             {
[08:29:11.660]                 {
[08:29:11.660]                   {
[08:29:11.660]                     {
[08:29:11.660]                       base::local({
[08:29:11.660]                         has_future <- base::requireNamespace("future", 
[08:29:11.660]                           quietly = TRUE)
[08:29:11.660]                         if (has_future) {
[08:29:11.660]                           ns <- base::getNamespace("future")
[08:29:11.660]                           version <- ns[[".package"]][["version"]]
[08:29:11.660]                           if (is.null(version)) 
[08:29:11.660]                             version <- utils::packageVersion("future")
[08:29:11.660]                         }
[08:29:11.660]                         else {
[08:29:11.660]                           version <- NULL
[08:29:11.660]                         }
[08:29:11.660]                         if (!has_future || version < "1.8.0") {
[08:29:11.660]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:11.660]                             "", base::R.version$version.string), 
[08:29:11.660]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:11.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:11.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:11.660]                               "release", "version")], collapse = " "), 
[08:29:11.660]                             hostname = base::Sys.info()[["nodename"]])
[08:29:11.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:11.660]                             info)
[08:29:11.660]                           info <- base::paste(info, collapse = "; ")
[08:29:11.660]                           if (!has_future) {
[08:29:11.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:11.660]                               info)
[08:29:11.660]                           }
[08:29:11.660]                           else {
[08:29:11.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:11.660]                               info, version)
[08:29:11.660]                           }
[08:29:11.660]                           base::stop(msg)
[08:29:11.660]                         }
[08:29:11.660]                       })
[08:29:11.660]                     }
[08:29:11.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:11.660]                     base::options(mc.cores = 1L)
[08:29:11.660]                   }
[08:29:11.660]                   ...future.strategy.old <- future::plan("list")
[08:29:11.660]                   options(future.plan = NULL)
[08:29:11.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:11.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:11.660]                 }
[08:29:11.660]                 ...future.workdir <- getwd()
[08:29:11.660]             }
[08:29:11.660]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:11.660]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:11.660]         }
[08:29:11.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:11.660]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:11.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:11.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:11.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:11.660]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:11.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:11.660]             base::names(...future.oldOptions))
[08:29:11.660]     }
[08:29:11.660]     if (FALSE) {
[08:29:11.660]     }
[08:29:11.660]     else {
[08:29:11.660]         if (TRUE) {
[08:29:11.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:11.660]                 open = "w")
[08:29:11.660]         }
[08:29:11.660]         else {
[08:29:11.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:11.660]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:11.660]         }
[08:29:11.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:11.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:11.660]             base::sink(type = "output", split = FALSE)
[08:29:11.660]             base::close(...future.stdout)
[08:29:11.660]         }, add = TRUE)
[08:29:11.660]     }
[08:29:11.660]     ...future.frame <- base::sys.nframe()
[08:29:11.660]     ...future.conditions <- base::list()
[08:29:11.660]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:11.660]     if (FALSE) {
[08:29:11.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:11.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:11.660]     }
[08:29:11.660]     ...future.result <- base::tryCatch({
[08:29:11.660]         base::withCallingHandlers({
[08:29:11.660]             ...future.value <- base::withVisible(base::local({
[08:29:11.660]                 ...future.makeSendCondition <- base::local({
[08:29:11.660]                   sendCondition <- NULL
[08:29:11.660]                   function(frame = 1L) {
[08:29:11.660]                     if (is.function(sendCondition)) 
[08:29:11.660]                       return(sendCondition)
[08:29:11.660]                     ns <- getNamespace("parallel")
[08:29:11.660]                     if (exists("sendData", mode = "function", 
[08:29:11.660]                       envir = ns)) {
[08:29:11.660]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:11.660]                         envir = ns)
[08:29:11.660]                       envir <- sys.frame(frame)
[08:29:11.660]                       master <- NULL
[08:29:11.660]                       while (!identical(envir, .GlobalEnv) && 
[08:29:11.660]                         !identical(envir, emptyenv())) {
[08:29:11.660]                         if (exists("master", mode = "list", envir = envir, 
[08:29:11.660]                           inherits = FALSE)) {
[08:29:11.660]                           master <- get("master", mode = "list", 
[08:29:11.660]                             envir = envir, inherits = FALSE)
[08:29:11.660]                           if (inherits(master, c("SOCKnode", 
[08:29:11.660]                             "SOCK0node"))) {
[08:29:11.660]                             sendCondition <<- function(cond) {
[08:29:11.660]                               data <- list(type = "VALUE", value = cond, 
[08:29:11.660]                                 success = TRUE)
[08:29:11.660]                               parallel_sendData(master, data)
[08:29:11.660]                             }
[08:29:11.660]                             return(sendCondition)
[08:29:11.660]                           }
[08:29:11.660]                         }
[08:29:11.660]                         frame <- frame + 1L
[08:29:11.660]                         envir <- sys.frame(frame)
[08:29:11.660]                       }
[08:29:11.660]                     }
[08:29:11.660]                     sendCondition <<- function(cond) NULL
[08:29:11.660]                   }
[08:29:11.660]                 })
[08:29:11.660]                 withCallingHandlers({
[08:29:11.660]                   {
[08:29:11.660]                     Sys.sleep(0.5)
[08:29:11.660]                     list(a = 1, b = 42L)
[08:29:11.660]                   }
[08:29:11.660]                 }, immediateCondition = function(cond) {
[08:29:11.660]                   sendCondition <- ...future.makeSendCondition()
[08:29:11.660]                   sendCondition(cond)
[08:29:11.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:11.660]                   {
[08:29:11.660]                     inherits <- base::inherits
[08:29:11.660]                     invokeRestart <- base::invokeRestart
[08:29:11.660]                     is.null <- base::is.null
[08:29:11.660]                     muffled <- FALSE
[08:29:11.660]                     if (inherits(cond, "message")) {
[08:29:11.660]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:11.660]                       if (muffled) 
[08:29:11.660]                         invokeRestart("muffleMessage")
[08:29:11.660]                     }
[08:29:11.660]                     else if (inherits(cond, "warning")) {
[08:29:11.660]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:11.660]                       if (muffled) 
[08:29:11.660]                         invokeRestart("muffleWarning")
[08:29:11.660]                     }
[08:29:11.660]                     else if (inherits(cond, "condition")) {
[08:29:11.660]                       if (!is.null(pattern)) {
[08:29:11.660]                         computeRestarts <- base::computeRestarts
[08:29:11.660]                         grepl <- base::grepl
[08:29:11.660]                         restarts <- computeRestarts(cond)
[08:29:11.660]                         for (restart in restarts) {
[08:29:11.660]                           name <- restart$name
[08:29:11.660]                           if (is.null(name)) 
[08:29:11.660]                             next
[08:29:11.660]                           if (!grepl(pattern, name)) 
[08:29:11.660]                             next
[08:29:11.660]                           invokeRestart(restart)
[08:29:11.660]                           muffled <- TRUE
[08:29:11.660]                           break
[08:29:11.660]                         }
[08:29:11.660]                       }
[08:29:11.660]                     }
[08:29:11.660]                     invisible(muffled)
[08:29:11.660]                   }
[08:29:11.660]                   muffleCondition(cond)
[08:29:11.660]                 })
[08:29:11.660]             }))
[08:29:11.660]             future::FutureResult(value = ...future.value$value, 
[08:29:11.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:11.660]                   ...future.rng), globalenv = if (FALSE) 
[08:29:11.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:11.660]                     ...future.globalenv.names))
[08:29:11.660]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:11.660]         }, condition = base::local({
[08:29:11.660]             c <- base::c
[08:29:11.660]             inherits <- base::inherits
[08:29:11.660]             invokeRestart <- base::invokeRestart
[08:29:11.660]             length <- base::length
[08:29:11.660]             list <- base::list
[08:29:11.660]             seq.int <- base::seq.int
[08:29:11.660]             signalCondition <- base::signalCondition
[08:29:11.660]             sys.calls <- base::sys.calls
[08:29:11.660]             `[[` <- base::`[[`
[08:29:11.660]             `+` <- base::`+`
[08:29:11.660]             `<<-` <- base::`<<-`
[08:29:11.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:11.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:11.660]                   3L)]
[08:29:11.660]             }
[08:29:11.660]             function(cond) {
[08:29:11.660]                 is_error <- inherits(cond, "error")
[08:29:11.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:11.660]                   NULL)
[08:29:11.660]                 if (is_error) {
[08:29:11.660]                   sessionInformation <- function() {
[08:29:11.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:11.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:11.660]                       search = base::search(), system = base::Sys.info())
[08:29:11.660]                   }
[08:29:11.660]                   ...future.conditions[[length(...future.conditions) + 
[08:29:11.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:11.660]                     cond$call), session = sessionInformation(), 
[08:29:11.660]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:11.660]                   signalCondition(cond)
[08:29:11.660]                 }
[08:29:11.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:11.660]                 "immediateCondition"))) {
[08:29:11.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:11.660]                   ...future.conditions[[length(...future.conditions) + 
[08:29:11.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:11.660]                   if (TRUE && !signal) {
[08:29:11.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:11.660]                     {
[08:29:11.660]                       inherits <- base::inherits
[08:29:11.660]                       invokeRestart <- base::invokeRestart
[08:29:11.660]                       is.null <- base::is.null
[08:29:11.660]                       muffled <- FALSE
[08:29:11.660]                       if (inherits(cond, "message")) {
[08:29:11.660]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:11.660]                         if (muffled) 
[08:29:11.660]                           invokeRestart("muffleMessage")
[08:29:11.660]                       }
[08:29:11.660]                       else if (inherits(cond, "warning")) {
[08:29:11.660]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:11.660]                         if (muffled) 
[08:29:11.660]                           invokeRestart("muffleWarning")
[08:29:11.660]                       }
[08:29:11.660]                       else if (inherits(cond, "condition")) {
[08:29:11.660]                         if (!is.null(pattern)) {
[08:29:11.660]                           computeRestarts <- base::computeRestarts
[08:29:11.660]                           grepl <- base::grepl
[08:29:11.660]                           restarts <- computeRestarts(cond)
[08:29:11.660]                           for (restart in restarts) {
[08:29:11.660]                             name <- restart$name
[08:29:11.660]                             if (is.null(name)) 
[08:29:11.660]                               next
[08:29:11.660]                             if (!grepl(pattern, name)) 
[08:29:11.660]                               next
[08:29:11.660]                             invokeRestart(restart)
[08:29:11.660]                             muffled <- TRUE
[08:29:11.660]                             break
[08:29:11.660]                           }
[08:29:11.660]                         }
[08:29:11.660]                       }
[08:29:11.660]                       invisible(muffled)
[08:29:11.660]                     }
[08:29:11.660]                     muffleCondition(cond, pattern = "^muffle")
[08:29:11.660]                   }
[08:29:11.660]                 }
[08:29:11.660]                 else {
[08:29:11.660]                   if (TRUE) {
[08:29:11.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:11.660]                     {
[08:29:11.660]                       inherits <- base::inherits
[08:29:11.660]                       invokeRestart <- base::invokeRestart
[08:29:11.660]                       is.null <- base::is.null
[08:29:11.660]                       muffled <- FALSE
[08:29:11.660]                       if (inherits(cond, "message")) {
[08:29:11.660]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:11.660]                         if (muffled) 
[08:29:11.660]                           invokeRestart("muffleMessage")
[08:29:11.660]                       }
[08:29:11.660]                       else if (inherits(cond, "warning")) {
[08:29:11.660]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:11.660]                         if (muffled) 
[08:29:11.660]                           invokeRestart("muffleWarning")
[08:29:11.660]                       }
[08:29:11.660]                       else if (inherits(cond, "condition")) {
[08:29:11.660]                         if (!is.null(pattern)) {
[08:29:11.660]                           computeRestarts <- base::computeRestarts
[08:29:11.660]                           grepl <- base::grepl
[08:29:11.660]                           restarts <- computeRestarts(cond)
[08:29:11.660]                           for (restart in restarts) {
[08:29:11.660]                             name <- restart$name
[08:29:11.660]                             if (is.null(name)) 
[08:29:11.660]                               next
[08:29:11.660]                             if (!grepl(pattern, name)) 
[08:29:11.660]                               next
[08:29:11.660]                             invokeRestart(restart)
[08:29:11.660]                             muffled <- TRUE
[08:29:11.660]                             break
[08:29:11.660]                           }
[08:29:11.660]                         }
[08:29:11.660]                       }
[08:29:11.660]                       invisible(muffled)
[08:29:11.660]                     }
[08:29:11.660]                     muffleCondition(cond, pattern = "^muffle")
[08:29:11.660]                   }
[08:29:11.660]                 }
[08:29:11.660]             }
[08:29:11.660]         }))
[08:29:11.660]     }, error = function(ex) {
[08:29:11.660]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:11.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:11.660]                 ...future.rng), started = ...future.startTime, 
[08:29:11.660]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:11.660]             version = "1.8"), class = "FutureResult")
[08:29:11.660]     }, finally = {
[08:29:11.660]         if (!identical(...future.workdir, getwd())) 
[08:29:11.660]             setwd(...future.workdir)
[08:29:11.660]         {
[08:29:11.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:11.660]                 ...future.oldOptions$nwarnings <- NULL
[08:29:11.660]             }
[08:29:11.660]             base::options(...future.oldOptions)
[08:29:11.660]             if (.Platform$OS.type == "windows") {
[08:29:11.660]                 old_names <- names(...future.oldEnvVars)
[08:29:11.660]                 envs <- base::Sys.getenv()
[08:29:11.660]                 names <- names(envs)
[08:29:11.660]                 common <- intersect(names, old_names)
[08:29:11.660]                 added <- setdiff(names, old_names)
[08:29:11.660]                 removed <- setdiff(old_names, names)
[08:29:11.660]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:11.660]                   envs[common]]
[08:29:11.660]                 NAMES <- toupper(changed)
[08:29:11.660]                 args <- list()
[08:29:11.660]                 for (kk in seq_along(NAMES)) {
[08:29:11.660]                   name <- changed[[kk]]
[08:29:11.660]                   NAME <- NAMES[[kk]]
[08:29:11.660]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:11.660]                     next
[08:29:11.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:11.660]                 }
[08:29:11.660]                 NAMES <- toupper(added)
[08:29:11.660]                 for (kk in seq_along(NAMES)) {
[08:29:11.660]                   name <- added[[kk]]
[08:29:11.660]                   NAME <- NAMES[[kk]]
[08:29:11.660]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:11.660]                     next
[08:29:11.660]                   args[[name]] <- ""
[08:29:11.660]                 }
[08:29:11.660]                 NAMES <- toupper(removed)
[08:29:11.660]                 for (kk in seq_along(NAMES)) {
[08:29:11.660]                   name <- removed[[kk]]
[08:29:11.660]                   NAME <- NAMES[[kk]]
[08:29:11.660]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:11.660]                     next
[08:29:11.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:11.660]                 }
[08:29:11.660]                 if (length(args) > 0) 
[08:29:11.660]                   base::do.call(base::Sys.setenv, args = args)
[08:29:11.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:11.660]             }
[08:29:11.660]             else {
[08:29:11.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:11.660]             }
[08:29:11.660]             {
[08:29:11.660]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:11.660]                   0L) {
[08:29:11.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:11.660]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:11.660]                   base::options(opts)
[08:29:11.660]                 }
[08:29:11.660]                 {
[08:29:11.660]                   {
[08:29:11.660]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:11.660]                     NULL
[08:29:11.660]                   }
[08:29:11.660]                   options(future.plan = NULL)
[08:29:11.660]                   if (is.na(NA_character_)) 
[08:29:11.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:11.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:11.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:11.660]                     .init = FALSE)
[08:29:11.660]                 }
[08:29:11.660]             }
[08:29:11.660]         }
[08:29:11.660]     })
[08:29:11.660]     if (TRUE) {
[08:29:11.660]         base::sink(type = "output", split = FALSE)
[08:29:11.660]         if (TRUE) {
[08:29:11.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:11.660]         }
[08:29:11.660]         else {
[08:29:11.660]             ...future.result["stdout"] <- base::list(NULL)
[08:29:11.660]         }
[08:29:11.660]         base::close(...future.stdout)
[08:29:11.660]         ...future.stdout <- NULL
[08:29:11.660]     }
[08:29:11.660]     ...future.result$conditions <- ...future.conditions
[08:29:11.660]     ...future.result$finished <- base::Sys.time()
[08:29:11.660]     ...future.result
[08:29:11.660] }
[08:29:11.663] MultisessionFuture started
[08:29:11.663] - Launch lazy future ... done
[08:29:11.663] run() for ‘MultisessionFuture’ ... done
[08:29:12.206] receiveMessageFromWorker() for ClusterFuture ...
[08:29:12.206] - Validating connection of MultisessionFuture
[08:29:12.206] - received message: FutureResult
[08:29:12.207] - Received FutureResult
[08:29:12.207] - Erased future from FutureRegistry
[08:29:12.207] result() for ClusterFuture ...
[08:29:12.207] - result already collected: FutureResult
[08:29:12.207] result() for ClusterFuture ... done
[08:29:12.207] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:12.207] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[08:29:12.207] getGlobalsAndPackages() ...
[08:29:12.207] Searching for globals...
[08:29:12.208] - globals found: [2] ‘list’, ‘stop’
[08:29:12.208] Searching for globals ... DONE
[08:29:12.208] Resolving globals: FALSE
[08:29:12.209] 
[08:29:12.209] 
[08:29:12.209] getGlobalsAndPackages() ... DONE
[08:29:12.209] run() for ‘Future’ ...
[08:29:12.209] - state: ‘created’
[08:29:12.209] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:12.224] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:12.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:12.224]   - Field: ‘node’
[08:29:12.224]   - Field: ‘label’
[08:29:12.224]   - Field: ‘local’
[08:29:12.224]   - Field: ‘owner’
[08:29:12.224]   - Field: ‘envir’
[08:29:12.224]   - Field: ‘workers’
[08:29:12.224]   - Field: ‘packages’
[08:29:12.224]   - Field: ‘gc’
[08:29:12.225]   - Field: ‘conditions’
[08:29:12.225]   - Field: ‘persistent’
[08:29:12.227]   - Field: ‘expr’
[08:29:12.227]   - Field: ‘uuid’
[08:29:12.227]   - Field: ‘seed’
[08:29:12.227]   - Field: ‘version’
[08:29:12.227]   - Field: ‘result’
[08:29:12.227]   - Field: ‘asynchronous’
[08:29:12.227]   - Field: ‘calls’
[08:29:12.227]   - Field: ‘globals’
[08:29:12.227]   - Field: ‘stdout’
[08:29:12.228]   - Field: ‘earlySignal’
[08:29:12.228]   - Field: ‘lazy’
[08:29:12.228]   - Field: ‘state’
[08:29:12.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:12.228] - Launch lazy future ...
[08:29:12.228] Packages needed by the future expression (n = 0): <none>
[08:29:12.228] Packages needed by future strategies (n = 0): <none>
[08:29:12.229] {
[08:29:12.229]     {
[08:29:12.229]         {
[08:29:12.229]             ...future.startTime <- base::Sys.time()
[08:29:12.229]             {
[08:29:12.229]                 {
[08:29:12.229]                   {
[08:29:12.229]                     {
[08:29:12.229]                       base::local({
[08:29:12.229]                         has_future <- base::requireNamespace("future", 
[08:29:12.229]                           quietly = TRUE)
[08:29:12.229]                         if (has_future) {
[08:29:12.229]                           ns <- base::getNamespace("future")
[08:29:12.229]                           version <- ns[[".package"]][["version"]]
[08:29:12.229]                           if (is.null(version)) 
[08:29:12.229]                             version <- utils::packageVersion("future")
[08:29:12.229]                         }
[08:29:12.229]                         else {
[08:29:12.229]                           version <- NULL
[08:29:12.229]                         }
[08:29:12.229]                         if (!has_future || version < "1.8.0") {
[08:29:12.229]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:12.229]                             "", base::R.version$version.string), 
[08:29:12.229]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:12.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:12.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:12.229]                               "release", "version")], collapse = " "), 
[08:29:12.229]                             hostname = base::Sys.info()[["nodename"]])
[08:29:12.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:12.229]                             info)
[08:29:12.229]                           info <- base::paste(info, collapse = "; ")
[08:29:12.229]                           if (!has_future) {
[08:29:12.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:12.229]                               info)
[08:29:12.229]                           }
[08:29:12.229]                           else {
[08:29:12.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:12.229]                               info, version)
[08:29:12.229]                           }
[08:29:12.229]                           base::stop(msg)
[08:29:12.229]                         }
[08:29:12.229]                       })
[08:29:12.229]                     }
[08:29:12.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:12.229]                     base::options(mc.cores = 1L)
[08:29:12.229]                   }
[08:29:12.229]                   ...future.strategy.old <- future::plan("list")
[08:29:12.229]                   options(future.plan = NULL)
[08:29:12.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:12.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:12.229]                 }
[08:29:12.229]                 ...future.workdir <- getwd()
[08:29:12.229]             }
[08:29:12.229]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:12.229]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:12.229]         }
[08:29:12.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:12.229]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:12.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:12.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:12.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:12.229]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:12.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:12.229]             base::names(...future.oldOptions))
[08:29:12.229]     }
[08:29:12.229]     if (FALSE) {
[08:29:12.229]     }
[08:29:12.229]     else {
[08:29:12.229]         if (TRUE) {
[08:29:12.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:12.229]                 open = "w")
[08:29:12.229]         }
[08:29:12.229]         else {
[08:29:12.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:12.229]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:12.229]         }
[08:29:12.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:12.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:12.229]             base::sink(type = "output", split = FALSE)
[08:29:12.229]             base::close(...future.stdout)
[08:29:12.229]         }, add = TRUE)
[08:29:12.229]     }
[08:29:12.229]     ...future.frame <- base::sys.nframe()
[08:29:12.229]     ...future.conditions <- base::list()
[08:29:12.229]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:12.229]     if (FALSE) {
[08:29:12.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:12.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:12.229]     }
[08:29:12.229]     ...future.result <- base::tryCatch({
[08:29:12.229]         base::withCallingHandlers({
[08:29:12.229]             ...future.value <- base::withVisible(base::local({
[08:29:12.229]                 ...future.makeSendCondition <- base::local({
[08:29:12.229]                   sendCondition <- NULL
[08:29:12.229]                   function(frame = 1L) {
[08:29:12.229]                     if (is.function(sendCondition)) 
[08:29:12.229]                       return(sendCondition)
[08:29:12.229]                     ns <- getNamespace("parallel")
[08:29:12.229]                     if (exists("sendData", mode = "function", 
[08:29:12.229]                       envir = ns)) {
[08:29:12.229]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:12.229]                         envir = ns)
[08:29:12.229]                       envir <- sys.frame(frame)
[08:29:12.229]                       master <- NULL
[08:29:12.229]                       while (!identical(envir, .GlobalEnv) && 
[08:29:12.229]                         !identical(envir, emptyenv())) {
[08:29:12.229]                         if (exists("master", mode = "list", envir = envir, 
[08:29:12.229]                           inherits = FALSE)) {
[08:29:12.229]                           master <- get("master", mode = "list", 
[08:29:12.229]                             envir = envir, inherits = FALSE)
[08:29:12.229]                           if (inherits(master, c("SOCKnode", 
[08:29:12.229]                             "SOCK0node"))) {
[08:29:12.229]                             sendCondition <<- function(cond) {
[08:29:12.229]                               data <- list(type = "VALUE", value = cond, 
[08:29:12.229]                                 success = TRUE)
[08:29:12.229]                               parallel_sendData(master, data)
[08:29:12.229]                             }
[08:29:12.229]                             return(sendCondition)
[08:29:12.229]                           }
[08:29:12.229]                         }
[08:29:12.229]                         frame <- frame + 1L
[08:29:12.229]                         envir <- sys.frame(frame)
[08:29:12.229]                       }
[08:29:12.229]                     }
[08:29:12.229]                     sendCondition <<- function(cond) NULL
[08:29:12.229]                   }
[08:29:12.229]                 })
[08:29:12.229]                 withCallingHandlers({
[08:29:12.229]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:12.229]                 }, immediateCondition = function(cond) {
[08:29:12.229]                   sendCondition <- ...future.makeSendCondition()
[08:29:12.229]                   sendCondition(cond)
[08:29:12.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.229]                   {
[08:29:12.229]                     inherits <- base::inherits
[08:29:12.229]                     invokeRestart <- base::invokeRestart
[08:29:12.229]                     is.null <- base::is.null
[08:29:12.229]                     muffled <- FALSE
[08:29:12.229]                     if (inherits(cond, "message")) {
[08:29:12.229]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:12.229]                       if (muffled) 
[08:29:12.229]                         invokeRestart("muffleMessage")
[08:29:12.229]                     }
[08:29:12.229]                     else if (inherits(cond, "warning")) {
[08:29:12.229]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:12.229]                       if (muffled) 
[08:29:12.229]                         invokeRestart("muffleWarning")
[08:29:12.229]                     }
[08:29:12.229]                     else if (inherits(cond, "condition")) {
[08:29:12.229]                       if (!is.null(pattern)) {
[08:29:12.229]                         computeRestarts <- base::computeRestarts
[08:29:12.229]                         grepl <- base::grepl
[08:29:12.229]                         restarts <- computeRestarts(cond)
[08:29:12.229]                         for (restart in restarts) {
[08:29:12.229]                           name <- restart$name
[08:29:12.229]                           if (is.null(name)) 
[08:29:12.229]                             next
[08:29:12.229]                           if (!grepl(pattern, name)) 
[08:29:12.229]                             next
[08:29:12.229]                           invokeRestart(restart)
[08:29:12.229]                           muffled <- TRUE
[08:29:12.229]                           break
[08:29:12.229]                         }
[08:29:12.229]                       }
[08:29:12.229]                     }
[08:29:12.229]                     invisible(muffled)
[08:29:12.229]                   }
[08:29:12.229]                   muffleCondition(cond)
[08:29:12.229]                 })
[08:29:12.229]             }))
[08:29:12.229]             future::FutureResult(value = ...future.value$value, 
[08:29:12.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:12.229]                   ...future.rng), globalenv = if (FALSE) 
[08:29:12.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:12.229]                     ...future.globalenv.names))
[08:29:12.229]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:12.229]         }, condition = base::local({
[08:29:12.229]             c <- base::c
[08:29:12.229]             inherits <- base::inherits
[08:29:12.229]             invokeRestart <- base::invokeRestart
[08:29:12.229]             length <- base::length
[08:29:12.229]             list <- base::list
[08:29:12.229]             seq.int <- base::seq.int
[08:29:12.229]             signalCondition <- base::signalCondition
[08:29:12.229]             sys.calls <- base::sys.calls
[08:29:12.229]             `[[` <- base::`[[`
[08:29:12.229]             `+` <- base::`+`
[08:29:12.229]             `<<-` <- base::`<<-`
[08:29:12.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:12.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:12.229]                   3L)]
[08:29:12.229]             }
[08:29:12.229]             function(cond) {
[08:29:12.229]                 is_error <- inherits(cond, "error")
[08:29:12.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:12.229]                   NULL)
[08:29:12.229]                 if (is_error) {
[08:29:12.229]                   sessionInformation <- function() {
[08:29:12.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:12.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:12.229]                       search = base::search(), system = base::Sys.info())
[08:29:12.229]                   }
[08:29:12.229]                   ...future.conditions[[length(...future.conditions) + 
[08:29:12.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:12.229]                     cond$call), session = sessionInformation(), 
[08:29:12.229]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:12.229]                   signalCondition(cond)
[08:29:12.229]                 }
[08:29:12.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:12.229]                 "immediateCondition"))) {
[08:29:12.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:12.229]                   ...future.conditions[[length(...future.conditions) + 
[08:29:12.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:12.229]                   if (TRUE && !signal) {
[08:29:12.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.229]                     {
[08:29:12.229]                       inherits <- base::inherits
[08:29:12.229]                       invokeRestart <- base::invokeRestart
[08:29:12.229]                       is.null <- base::is.null
[08:29:12.229]                       muffled <- FALSE
[08:29:12.229]                       if (inherits(cond, "message")) {
[08:29:12.229]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:12.229]                         if (muffled) 
[08:29:12.229]                           invokeRestart("muffleMessage")
[08:29:12.229]                       }
[08:29:12.229]                       else if (inherits(cond, "warning")) {
[08:29:12.229]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:12.229]                         if (muffled) 
[08:29:12.229]                           invokeRestart("muffleWarning")
[08:29:12.229]                       }
[08:29:12.229]                       else if (inherits(cond, "condition")) {
[08:29:12.229]                         if (!is.null(pattern)) {
[08:29:12.229]                           computeRestarts <- base::computeRestarts
[08:29:12.229]                           grepl <- base::grepl
[08:29:12.229]                           restarts <- computeRestarts(cond)
[08:29:12.229]                           for (restart in restarts) {
[08:29:12.229]                             name <- restart$name
[08:29:12.229]                             if (is.null(name)) 
[08:29:12.229]                               next
[08:29:12.229]                             if (!grepl(pattern, name)) 
[08:29:12.229]                               next
[08:29:12.229]                             invokeRestart(restart)
[08:29:12.229]                             muffled <- TRUE
[08:29:12.229]                             break
[08:29:12.229]                           }
[08:29:12.229]                         }
[08:29:12.229]                       }
[08:29:12.229]                       invisible(muffled)
[08:29:12.229]                     }
[08:29:12.229]                     muffleCondition(cond, pattern = "^muffle")
[08:29:12.229]                   }
[08:29:12.229]                 }
[08:29:12.229]                 else {
[08:29:12.229]                   if (TRUE) {
[08:29:12.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.229]                     {
[08:29:12.229]                       inherits <- base::inherits
[08:29:12.229]                       invokeRestart <- base::invokeRestart
[08:29:12.229]                       is.null <- base::is.null
[08:29:12.229]                       muffled <- FALSE
[08:29:12.229]                       if (inherits(cond, "message")) {
[08:29:12.229]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:12.229]                         if (muffled) 
[08:29:12.229]                           invokeRestart("muffleMessage")
[08:29:12.229]                       }
[08:29:12.229]                       else if (inherits(cond, "warning")) {
[08:29:12.229]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:12.229]                         if (muffled) 
[08:29:12.229]                           invokeRestart("muffleWarning")
[08:29:12.229]                       }
[08:29:12.229]                       else if (inherits(cond, "condition")) {
[08:29:12.229]                         if (!is.null(pattern)) {
[08:29:12.229]                           computeRestarts <- base::computeRestarts
[08:29:12.229]                           grepl <- base::grepl
[08:29:12.229]                           restarts <- computeRestarts(cond)
[08:29:12.229]                           for (restart in restarts) {
[08:29:12.229]                             name <- restart$name
[08:29:12.229]                             if (is.null(name)) 
[08:29:12.229]                               next
[08:29:12.229]                             if (!grepl(pattern, name)) 
[08:29:12.229]                               next
[08:29:12.229]                             invokeRestart(restart)
[08:29:12.229]                             muffled <- TRUE
[08:29:12.229]                             break
[08:29:12.229]                           }
[08:29:12.229]                         }
[08:29:12.229]                       }
[08:29:12.229]                       invisible(muffled)
[08:29:12.229]                     }
[08:29:12.229]                     muffleCondition(cond, pattern = "^muffle")
[08:29:12.229]                   }
[08:29:12.229]                 }
[08:29:12.229]             }
[08:29:12.229]         }))
[08:29:12.229]     }, error = function(ex) {
[08:29:12.229]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:12.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:12.229]                 ...future.rng), started = ...future.startTime, 
[08:29:12.229]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:12.229]             version = "1.8"), class = "FutureResult")
[08:29:12.229]     }, finally = {
[08:29:12.229]         if (!identical(...future.workdir, getwd())) 
[08:29:12.229]             setwd(...future.workdir)
[08:29:12.229]         {
[08:29:12.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:12.229]                 ...future.oldOptions$nwarnings <- NULL
[08:29:12.229]             }
[08:29:12.229]             base::options(...future.oldOptions)
[08:29:12.229]             if (.Platform$OS.type == "windows") {
[08:29:12.229]                 old_names <- names(...future.oldEnvVars)
[08:29:12.229]                 envs <- base::Sys.getenv()
[08:29:12.229]                 names <- names(envs)
[08:29:12.229]                 common <- intersect(names, old_names)
[08:29:12.229]                 added <- setdiff(names, old_names)
[08:29:12.229]                 removed <- setdiff(old_names, names)
[08:29:12.229]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:12.229]                   envs[common]]
[08:29:12.229]                 NAMES <- toupper(changed)
[08:29:12.229]                 args <- list()
[08:29:12.229]                 for (kk in seq_along(NAMES)) {
[08:29:12.229]                   name <- changed[[kk]]
[08:29:12.229]                   NAME <- NAMES[[kk]]
[08:29:12.229]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.229]                     next
[08:29:12.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:12.229]                 }
[08:29:12.229]                 NAMES <- toupper(added)
[08:29:12.229]                 for (kk in seq_along(NAMES)) {
[08:29:12.229]                   name <- added[[kk]]
[08:29:12.229]                   NAME <- NAMES[[kk]]
[08:29:12.229]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.229]                     next
[08:29:12.229]                   args[[name]] <- ""
[08:29:12.229]                 }
[08:29:12.229]                 NAMES <- toupper(removed)
[08:29:12.229]                 for (kk in seq_along(NAMES)) {
[08:29:12.229]                   name <- removed[[kk]]
[08:29:12.229]                   NAME <- NAMES[[kk]]
[08:29:12.229]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.229]                     next
[08:29:12.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:12.229]                 }
[08:29:12.229]                 if (length(args) > 0) 
[08:29:12.229]                   base::do.call(base::Sys.setenv, args = args)
[08:29:12.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:12.229]             }
[08:29:12.229]             else {
[08:29:12.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:12.229]             }
[08:29:12.229]             {
[08:29:12.229]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:12.229]                   0L) {
[08:29:12.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:12.229]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:12.229]                   base::options(opts)
[08:29:12.229]                 }
[08:29:12.229]                 {
[08:29:12.229]                   {
[08:29:12.229]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:12.229]                     NULL
[08:29:12.229]                   }
[08:29:12.229]                   options(future.plan = NULL)
[08:29:12.229]                   if (is.na(NA_character_)) 
[08:29:12.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:12.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:12.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:12.229]                     .init = FALSE)
[08:29:12.229]                 }
[08:29:12.229]             }
[08:29:12.229]         }
[08:29:12.229]     })
[08:29:12.229]     if (TRUE) {
[08:29:12.229]         base::sink(type = "output", split = FALSE)
[08:29:12.229]         if (TRUE) {
[08:29:12.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:12.229]         }
[08:29:12.229]         else {
[08:29:12.229]             ...future.result["stdout"] <- base::list(NULL)
[08:29:12.229]         }
[08:29:12.229]         base::close(...future.stdout)
[08:29:12.229]         ...future.stdout <- NULL
[08:29:12.229]     }
[08:29:12.229]     ...future.result$conditions <- ...future.conditions
[08:29:12.229]     ...future.result$finished <- base::Sys.time()
[08:29:12.229]     ...future.result
[08:29:12.229] }
[08:29:12.232] MultisessionFuture started
[08:29:12.232] - Launch lazy future ... done
[08:29:12.232] run() for ‘MultisessionFuture’ ... done
[08:29:12.274] receiveMessageFromWorker() for ClusterFuture ...
[08:29:12.274] - Validating connection of MultisessionFuture
[08:29:12.275] - received message: FutureResult
[08:29:12.275] - Received FutureResult
[08:29:12.275] - Erased future from FutureRegistry
[08:29:12.275] result() for ClusterFuture ...
[08:29:12.275] - result already collected: FutureResult
[08:29:12.275] result() for ClusterFuture ... done
[08:29:12.275] signalConditions() ...
[08:29:12.275]  - include = ‘immediateCondition’
[08:29:12.275]  - exclude = 
[08:29:12.276]  - resignal = FALSE
[08:29:12.276]  - Number of conditions: 1
[08:29:12.276] signalConditions() ... done
[08:29:12.276] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:12.276] A MultisessionFuture was resolved (result was not collected)
[08:29:12.276] getGlobalsAndPackages() ...
[08:29:12.276] Searching for globals...
[08:29:12.277] - globals found: [2] ‘list’, ‘stop’
[08:29:12.277] Searching for globals ... DONE
[08:29:12.277] Resolving globals: FALSE
[08:29:12.277] 
[08:29:12.277] 
[08:29:12.277] getGlobalsAndPackages() ... DONE
[08:29:12.278] run() for ‘Future’ ...
[08:29:12.278] - state: ‘created’
[08:29:12.278] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:12.291] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:12.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:12.292]   - Field: ‘node’
[08:29:12.292]   - Field: ‘label’
[08:29:12.292]   - Field: ‘local’
[08:29:12.292]   - Field: ‘owner’
[08:29:12.292]   - Field: ‘envir’
[08:29:12.292]   - Field: ‘workers’
[08:29:12.292]   - Field: ‘packages’
[08:29:12.292]   - Field: ‘gc’
[08:29:12.292]   - Field: ‘conditions’
[08:29:12.293]   - Field: ‘persistent’
[08:29:12.293]   - Field: ‘expr’
[08:29:12.293]   - Field: ‘uuid’
[08:29:12.293]   - Field: ‘seed’
[08:29:12.293]   - Field: ‘version’
[08:29:12.293]   - Field: ‘result’
[08:29:12.293]   - Field: ‘asynchronous’
[08:29:12.293]   - Field: ‘calls’
[08:29:12.293]   - Field: ‘globals’
[08:29:12.293]   - Field: ‘stdout’
[08:29:12.293]   - Field: ‘earlySignal’
[08:29:12.293]   - Field: ‘lazy’
[08:29:12.293]   - Field: ‘state’
[08:29:12.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:12.294] - Launch lazy future ...
[08:29:12.294] Packages needed by the future expression (n = 0): <none>
[08:29:12.294] Packages needed by future strategies (n = 0): <none>
[08:29:12.294] {
[08:29:12.294]     {
[08:29:12.294]         {
[08:29:12.294]             ...future.startTime <- base::Sys.time()
[08:29:12.294]             {
[08:29:12.294]                 {
[08:29:12.294]                   {
[08:29:12.294]                     {
[08:29:12.294]                       base::local({
[08:29:12.294]                         has_future <- base::requireNamespace("future", 
[08:29:12.294]                           quietly = TRUE)
[08:29:12.294]                         if (has_future) {
[08:29:12.294]                           ns <- base::getNamespace("future")
[08:29:12.294]                           version <- ns[[".package"]][["version"]]
[08:29:12.294]                           if (is.null(version)) 
[08:29:12.294]                             version <- utils::packageVersion("future")
[08:29:12.294]                         }
[08:29:12.294]                         else {
[08:29:12.294]                           version <- NULL
[08:29:12.294]                         }
[08:29:12.294]                         if (!has_future || version < "1.8.0") {
[08:29:12.294]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:12.294]                             "", base::R.version$version.string), 
[08:29:12.294]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:12.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:12.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:12.294]                               "release", "version")], collapse = " "), 
[08:29:12.294]                             hostname = base::Sys.info()[["nodename"]])
[08:29:12.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:12.294]                             info)
[08:29:12.294]                           info <- base::paste(info, collapse = "; ")
[08:29:12.294]                           if (!has_future) {
[08:29:12.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:12.294]                               info)
[08:29:12.294]                           }
[08:29:12.294]                           else {
[08:29:12.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:12.294]                               info, version)
[08:29:12.294]                           }
[08:29:12.294]                           base::stop(msg)
[08:29:12.294]                         }
[08:29:12.294]                       })
[08:29:12.294]                     }
[08:29:12.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:12.294]                     base::options(mc.cores = 1L)
[08:29:12.294]                   }
[08:29:12.294]                   ...future.strategy.old <- future::plan("list")
[08:29:12.294]                   options(future.plan = NULL)
[08:29:12.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:12.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:12.294]                 }
[08:29:12.294]                 ...future.workdir <- getwd()
[08:29:12.294]             }
[08:29:12.294]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:12.294]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:12.294]         }
[08:29:12.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:12.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:12.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:12.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:12.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:12.294]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:12.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:12.294]             base::names(...future.oldOptions))
[08:29:12.294]     }
[08:29:12.294]     if (FALSE) {
[08:29:12.294]     }
[08:29:12.294]     else {
[08:29:12.294]         if (TRUE) {
[08:29:12.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:12.294]                 open = "w")
[08:29:12.294]         }
[08:29:12.294]         else {
[08:29:12.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:12.294]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:12.294]         }
[08:29:12.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:12.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:12.294]             base::sink(type = "output", split = FALSE)
[08:29:12.294]             base::close(...future.stdout)
[08:29:12.294]         }, add = TRUE)
[08:29:12.294]     }
[08:29:12.294]     ...future.frame <- base::sys.nframe()
[08:29:12.294]     ...future.conditions <- base::list()
[08:29:12.294]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:12.294]     if (FALSE) {
[08:29:12.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:12.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:12.294]     }
[08:29:12.294]     ...future.result <- base::tryCatch({
[08:29:12.294]         base::withCallingHandlers({
[08:29:12.294]             ...future.value <- base::withVisible(base::local({
[08:29:12.294]                 ...future.makeSendCondition <- base::local({
[08:29:12.294]                   sendCondition <- NULL
[08:29:12.294]                   function(frame = 1L) {
[08:29:12.294]                     if (is.function(sendCondition)) 
[08:29:12.294]                       return(sendCondition)
[08:29:12.294]                     ns <- getNamespace("parallel")
[08:29:12.294]                     if (exists("sendData", mode = "function", 
[08:29:12.294]                       envir = ns)) {
[08:29:12.294]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:12.294]                         envir = ns)
[08:29:12.294]                       envir <- sys.frame(frame)
[08:29:12.294]                       master <- NULL
[08:29:12.294]                       while (!identical(envir, .GlobalEnv) && 
[08:29:12.294]                         !identical(envir, emptyenv())) {
[08:29:12.294]                         if (exists("master", mode = "list", envir = envir, 
[08:29:12.294]                           inherits = FALSE)) {
[08:29:12.294]                           master <- get("master", mode = "list", 
[08:29:12.294]                             envir = envir, inherits = FALSE)
[08:29:12.294]                           if (inherits(master, c("SOCKnode", 
[08:29:12.294]                             "SOCK0node"))) {
[08:29:12.294]                             sendCondition <<- function(cond) {
[08:29:12.294]                               data <- list(type = "VALUE", value = cond, 
[08:29:12.294]                                 success = TRUE)
[08:29:12.294]                               parallel_sendData(master, data)
[08:29:12.294]                             }
[08:29:12.294]                             return(sendCondition)
[08:29:12.294]                           }
[08:29:12.294]                         }
[08:29:12.294]                         frame <- frame + 1L
[08:29:12.294]                         envir <- sys.frame(frame)
[08:29:12.294]                       }
[08:29:12.294]                     }
[08:29:12.294]                     sendCondition <<- function(cond) NULL
[08:29:12.294]                   }
[08:29:12.294]                 })
[08:29:12.294]                 withCallingHandlers({
[08:29:12.294]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:12.294]                 }, immediateCondition = function(cond) {
[08:29:12.294]                   sendCondition <- ...future.makeSendCondition()
[08:29:12.294]                   sendCondition(cond)
[08:29:12.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.294]                   {
[08:29:12.294]                     inherits <- base::inherits
[08:29:12.294]                     invokeRestart <- base::invokeRestart
[08:29:12.294]                     is.null <- base::is.null
[08:29:12.294]                     muffled <- FALSE
[08:29:12.294]                     if (inherits(cond, "message")) {
[08:29:12.294]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:12.294]                       if (muffled) 
[08:29:12.294]                         invokeRestart("muffleMessage")
[08:29:12.294]                     }
[08:29:12.294]                     else if (inherits(cond, "warning")) {
[08:29:12.294]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:12.294]                       if (muffled) 
[08:29:12.294]                         invokeRestart("muffleWarning")
[08:29:12.294]                     }
[08:29:12.294]                     else if (inherits(cond, "condition")) {
[08:29:12.294]                       if (!is.null(pattern)) {
[08:29:12.294]                         computeRestarts <- base::computeRestarts
[08:29:12.294]                         grepl <- base::grepl
[08:29:12.294]                         restarts <- computeRestarts(cond)
[08:29:12.294]                         for (restart in restarts) {
[08:29:12.294]                           name <- restart$name
[08:29:12.294]                           if (is.null(name)) 
[08:29:12.294]                             next
[08:29:12.294]                           if (!grepl(pattern, name)) 
[08:29:12.294]                             next
[08:29:12.294]                           invokeRestart(restart)
[08:29:12.294]                           muffled <- TRUE
[08:29:12.294]                           break
[08:29:12.294]                         }
[08:29:12.294]                       }
[08:29:12.294]                     }
[08:29:12.294]                     invisible(muffled)
[08:29:12.294]                   }
[08:29:12.294]                   muffleCondition(cond)
[08:29:12.294]                 })
[08:29:12.294]             }))
[08:29:12.294]             future::FutureResult(value = ...future.value$value, 
[08:29:12.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:12.294]                   ...future.rng), globalenv = if (FALSE) 
[08:29:12.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:12.294]                     ...future.globalenv.names))
[08:29:12.294]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:12.294]         }, condition = base::local({
[08:29:12.294]             c <- base::c
[08:29:12.294]             inherits <- base::inherits
[08:29:12.294]             invokeRestart <- base::invokeRestart
[08:29:12.294]             length <- base::length
[08:29:12.294]             list <- base::list
[08:29:12.294]             seq.int <- base::seq.int
[08:29:12.294]             signalCondition <- base::signalCondition
[08:29:12.294]             sys.calls <- base::sys.calls
[08:29:12.294]             `[[` <- base::`[[`
[08:29:12.294]             `+` <- base::`+`
[08:29:12.294]             `<<-` <- base::`<<-`
[08:29:12.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:12.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:12.294]                   3L)]
[08:29:12.294]             }
[08:29:12.294]             function(cond) {
[08:29:12.294]                 is_error <- inherits(cond, "error")
[08:29:12.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:12.294]                   NULL)
[08:29:12.294]                 if (is_error) {
[08:29:12.294]                   sessionInformation <- function() {
[08:29:12.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:12.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:12.294]                       search = base::search(), system = base::Sys.info())
[08:29:12.294]                   }
[08:29:12.294]                   ...future.conditions[[length(...future.conditions) + 
[08:29:12.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:12.294]                     cond$call), session = sessionInformation(), 
[08:29:12.294]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:12.294]                   signalCondition(cond)
[08:29:12.294]                 }
[08:29:12.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:12.294]                 "immediateCondition"))) {
[08:29:12.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:12.294]                   ...future.conditions[[length(...future.conditions) + 
[08:29:12.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:12.294]                   if (TRUE && !signal) {
[08:29:12.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.294]                     {
[08:29:12.294]                       inherits <- base::inherits
[08:29:12.294]                       invokeRestart <- base::invokeRestart
[08:29:12.294]                       is.null <- base::is.null
[08:29:12.294]                       muffled <- FALSE
[08:29:12.294]                       if (inherits(cond, "message")) {
[08:29:12.294]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:12.294]                         if (muffled) 
[08:29:12.294]                           invokeRestart("muffleMessage")
[08:29:12.294]                       }
[08:29:12.294]                       else if (inherits(cond, "warning")) {
[08:29:12.294]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:12.294]                         if (muffled) 
[08:29:12.294]                           invokeRestart("muffleWarning")
[08:29:12.294]                       }
[08:29:12.294]                       else if (inherits(cond, "condition")) {
[08:29:12.294]                         if (!is.null(pattern)) {
[08:29:12.294]                           computeRestarts <- base::computeRestarts
[08:29:12.294]                           grepl <- base::grepl
[08:29:12.294]                           restarts <- computeRestarts(cond)
[08:29:12.294]                           for (restart in restarts) {
[08:29:12.294]                             name <- restart$name
[08:29:12.294]                             if (is.null(name)) 
[08:29:12.294]                               next
[08:29:12.294]                             if (!grepl(pattern, name)) 
[08:29:12.294]                               next
[08:29:12.294]                             invokeRestart(restart)
[08:29:12.294]                             muffled <- TRUE
[08:29:12.294]                             break
[08:29:12.294]                           }
[08:29:12.294]                         }
[08:29:12.294]                       }
[08:29:12.294]                       invisible(muffled)
[08:29:12.294]                     }
[08:29:12.294]                     muffleCondition(cond, pattern = "^muffle")
[08:29:12.294]                   }
[08:29:12.294]                 }
[08:29:12.294]                 else {
[08:29:12.294]                   if (TRUE) {
[08:29:12.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.294]                     {
[08:29:12.294]                       inherits <- base::inherits
[08:29:12.294]                       invokeRestart <- base::invokeRestart
[08:29:12.294]                       is.null <- base::is.null
[08:29:12.294]                       muffled <- FALSE
[08:29:12.294]                       if (inherits(cond, "message")) {
[08:29:12.294]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:12.294]                         if (muffled) 
[08:29:12.294]                           invokeRestart("muffleMessage")
[08:29:12.294]                       }
[08:29:12.294]                       else if (inherits(cond, "warning")) {
[08:29:12.294]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:12.294]                         if (muffled) 
[08:29:12.294]                           invokeRestart("muffleWarning")
[08:29:12.294]                       }
[08:29:12.294]                       else if (inherits(cond, "condition")) {
[08:29:12.294]                         if (!is.null(pattern)) {
[08:29:12.294]                           computeRestarts <- base::computeRestarts
[08:29:12.294]                           grepl <- base::grepl
[08:29:12.294]                           restarts <- computeRestarts(cond)
[08:29:12.294]                           for (restart in restarts) {
[08:29:12.294]                             name <- restart$name
[08:29:12.294]                             if (is.null(name)) 
[08:29:12.294]                               next
[08:29:12.294]                             if (!grepl(pattern, name)) 
[08:29:12.294]                               next
[08:29:12.294]                             invokeRestart(restart)
[08:29:12.294]                             muffled <- TRUE
[08:29:12.294]                             break
[08:29:12.294]                           }
[08:29:12.294]                         }
[08:29:12.294]                       }
[08:29:12.294]                       invisible(muffled)
[08:29:12.294]                     }
[08:29:12.294]                     muffleCondition(cond, pattern = "^muffle")
[08:29:12.294]                   }
[08:29:12.294]                 }
[08:29:12.294]             }
[08:29:12.294]         }))
[08:29:12.294]     }, error = function(ex) {
[08:29:12.294]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:12.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:12.294]                 ...future.rng), started = ...future.startTime, 
[08:29:12.294]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:12.294]             version = "1.8"), class = "FutureResult")
[08:29:12.294]     }, finally = {
[08:29:12.294]         if (!identical(...future.workdir, getwd())) 
[08:29:12.294]             setwd(...future.workdir)
[08:29:12.294]         {
[08:29:12.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:12.294]                 ...future.oldOptions$nwarnings <- NULL
[08:29:12.294]             }
[08:29:12.294]             base::options(...future.oldOptions)
[08:29:12.294]             if (.Platform$OS.type == "windows") {
[08:29:12.294]                 old_names <- names(...future.oldEnvVars)
[08:29:12.294]                 envs <- base::Sys.getenv()
[08:29:12.294]                 names <- names(envs)
[08:29:12.294]                 common <- intersect(names, old_names)
[08:29:12.294]                 added <- setdiff(names, old_names)
[08:29:12.294]                 removed <- setdiff(old_names, names)
[08:29:12.294]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:12.294]                   envs[common]]
[08:29:12.294]                 NAMES <- toupper(changed)
[08:29:12.294]                 args <- list()
[08:29:12.294]                 for (kk in seq_along(NAMES)) {
[08:29:12.294]                   name <- changed[[kk]]
[08:29:12.294]                   NAME <- NAMES[[kk]]
[08:29:12.294]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.294]                     next
[08:29:12.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:12.294]                 }
[08:29:12.294]                 NAMES <- toupper(added)
[08:29:12.294]                 for (kk in seq_along(NAMES)) {
[08:29:12.294]                   name <- added[[kk]]
[08:29:12.294]                   NAME <- NAMES[[kk]]
[08:29:12.294]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.294]                     next
[08:29:12.294]                   args[[name]] <- ""
[08:29:12.294]                 }
[08:29:12.294]                 NAMES <- toupper(removed)
[08:29:12.294]                 for (kk in seq_along(NAMES)) {
[08:29:12.294]                   name <- removed[[kk]]
[08:29:12.294]                   NAME <- NAMES[[kk]]
[08:29:12.294]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.294]                     next
[08:29:12.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:12.294]                 }
[08:29:12.294]                 if (length(args) > 0) 
[08:29:12.294]                   base::do.call(base::Sys.setenv, args = args)
[08:29:12.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:12.294]             }
[08:29:12.294]             else {
[08:29:12.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:12.294]             }
[08:29:12.294]             {
[08:29:12.294]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:12.294]                   0L) {
[08:29:12.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:12.294]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:12.294]                   base::options(opts)
[08:29:12.294]                 }
[08:29:12.294]                 {
[08:29:12.294]                   {
[08:29:12.294]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:12.294]                     NULL
[08:29:12.294]                   }
[08:29:12.294]                   options(future.plan = NULL)
[08:29:12.294]                   if (is.na(NA_character_)) 
[08:29:12.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:12.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:12.294]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:12.294]                     .init = FALSE)
[08:29:12.294]                 }
[08:29:12.294]             }
[08:29:12.294]         }
[08:29:12.294]     })
[08:29:12.294]     if (TRUE) {
[08:29:12.294]         base::sink(type = "output", split = FALSE)
[08:29:12.294]         if (TRUE) {
[08:29:12.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:12.294]         }
[08:29:12.294]         else {
[08:29:12.294]             ...future.result["stdout"] <- base::list(NULL)
[08:29:12.294]         }
[08:29:12.294]         base::close(...future.stdout)
[08:29:12.294]         ...future.stdout <- NULL
[08:29:12.294]     }
[08:29:12.294]     ...future.result$conditions <- ...future.conditions
[08:29:12.294]     ...future.result$finished <- base::Sys.time()
[08:29:12.294]     ...future.result
[08:29:12.294] }
[08:29:12.297] MultisessionFuture started
[08:29:12.297] - Launch lazy future ... done
[08:29:12.297] run() for ‘MultisessionFuture’ ... done
[08:29:12.339] receiveMessageFromWorker() for ClusterFuture ...
[08:29:12.339] - Validating connection of MultisessionFuture
[08:29:12.339] - received message: FutureResult
[08:29:12.339] - Received FutureResult
[08:29:12.340] - Erased future from FutureRegistry
[08:29:12.340] result() for ClusterFuture ...
[08:29:12.340] - result already collected: FutureResult
[08:29:12.340] result() for ClusterFuture ... done
[08:29:12.340] signalConditions() ...
[08:29:12.340]  - include = ‘immediateCondition’
[08:29:12.340]  - exclude = 
[08:29:12.340]  - resignal = FALSE
[08:29:12.340]  - Number of conditions: 1
[08:29:12.340] signalConditions() ... done
[08:29:12.340] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:12.341] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[08:29:12.341] getGlobalsAndPackages() ...
[08:29:12.341] Searching for globals...
[08:29:12.342] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:12.342] Searching for globals ... DONE
[08:29:12.342] Resolving globals: FALSE
[08:29:12.342] 
[08:29:12.342] 
[08:29:12.343] getGlobalsAndPackages() ... DONE
[08:29:12.343] run() for ‘Future’ ...
[08:29:12.343] - state: ‘created’
[08:29:12.343] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:12.358] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:12.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:12.358]   - Field: ‘node’
[08:29:12.358]   - Field: ‘label’
[08:29:12.358]   - Field: ‘local’
[08:29:12.358]   - Field: ‘owner’
[08:29:12.358]   - Field: ‘envir’
[08:29:12.358]   - Field: ‘workers’
[08:29:12.358]   - Field: ‘packages’
[08:29:12.358]   - Field: ‘gc’
[08:29:12.358]   - Field: ‘conditions’
[08:29:12.359]   - Field: ‘persistent’
[08:29:12.359]   - Field: ‘expr’
[08:29:12.359]   - Field: ‘uuid’
[08:29:12.359]   - Field: ‘seed’
[08:29:12.359]   - Field: ‘version’
[08:29:12.359]   - Field: ‘result’
[08:29:12.359]   - Field: ‘asynchronous’
[08:29:12.359]   - Field: ‘calls’
[08:29:12.359]   - Field: ‘globals’
[08:29:12.359]   - Field: ‘stdout’
[08:29:12.359]   - Field: ‘earlySignal’
[08:29:12.360]   - Field: ‘lazy’
[08:29:12.360]   - Field: ‘state’
[08:29:12.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:12.360] - Launch lazy future ...
[08:29:12.360] Packages needed by the future expression (n = 0): <none>
[08:29:12.360] Packages needed by future strategies (n = 0): <none>
[08:29:12.361] {
[08:29:12.361]     {
[08:29:12.361]         {
[08:29:12.361]             ...future.startTime <- base::Sys.time()
[08:29:12.361]             {
[08:29:12.361]                 {
[08:29:12.361]                   {
[08:29:12.361]                     {
[08:29:12.361]                       base::local({
[08:29:12.361]                         has_future <- base::requireNamespace("future", 
[08:29:12.361]                           quietly = TRUE)
[08:29:12.361]                         if (has_future) {
[08:29:12.361]                           ns <- base::getNamespace("future")
[08:29:12.361]                           version <- ns[[".package"]][["version"]]
[08:29:12.361]                           if (is.null(version)) 
[08:29:12.361]                             version <- utils::packageVersion("future")
[08:29:12.361]                         }
[08:29:12.361]                         else {
[08:29:12.361]                           version <- NULL
[08:29:12.361]                         }
[08:29:12.361]                         if (!has_future || version < "1.8.0") {
[08:29:12.361]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:12.361]                             "", base::R.version$version.string), 
[08:29:12.361]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:12.361]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:12.361]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:12.361]                               "release", "version")], collapse = " "), 
[08:29:12.361]                             hostname = base::Sys.info()[["nodename"]])
[08:29:12.361]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:12.361]                             info)
[08:29:12.361]                           info <- base::paste(info, collapse = "; ")
[08:29:12.361]                           if (!has_future) {
[08:29:12.361]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:12.361]                               info)
[08:29:12.361]                           }
[08:29:12.361]                           else {
[08:29:12.361]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:12.361]                               info, version)
[08:29:12.361]                           }
[08:29:12.361]                           base::stop(msg)
[08:29:12.361]                         }
[08:29:12.361]                       })
[08:29:12.361]                     }
[08:29:12.361]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:12.361]                     base::options(mc.cores = 1L)
[08:29:12.361]                   }
[08:29:12.361]                   ...future.strategy.old <- future::plan("list")
[08:29:12.361]                   options(future.plan = NULL)
[08:29:12.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:12.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:12.361]                 }
[08:29:12.361]                 ...future.workdir <- getwd()
[08:29:12.361]             }
[08:29:12.361]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:12.361]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:12.361]         }
[08:29:12.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:12.361]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:12.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:12.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:12.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:12.361]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:12.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:12.361]             base::names(...future.oldOptions))
[08:29:12.361]     }
[08:29:12.361]     if (FALSE) {
[08:29:12.361]     }
[08:29:12.361]     else {
[08:29:12.361]         if (TRUE) {
[08:29:12.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:12.361]                 open = "w")
[08:29:12.361]         }
[08:29:12.361]         else {
[08:29:12.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:12.361]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:12.361]         }
[08:29:12.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:12.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:12.361]             base::sink(type = "output", split = FALSE)
[08:29:12.361]             base::close(...future.stdout)
[08:29:12.361]         }, add = TRUE)
[08:29:12.361]     }
[08:29:12.361]     ...future.frame <- base::sys.nframe()
[08:29:12.361]     ...future.conditions <- base::list()
[08:29:12.361]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:12.361]     if (FALSE) {
[08:29:12.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:12.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:12.361]     }
[08:29:12.361]     ...future.result <- base::tryCatch({
[08:29:12.361]         base::withCallingHandlers({
[08:29:12.361]             ...future.value <- base::withVisible(base::local({
[08:29:12.361]                 ...future.makeSendCondition <- base::local({
[08:29:12.361]                   sendCondition <- NULL
[08:29:12.361]                   function(frame = 1L) {
[08:29:12.361]                     if (is.function(sendCondition)) 
[08:29:12.361]                       return(sendCondition)
[08:29:12.361]                     ns <- getNamespace("parallel")
[08:29:12.361]                     if (exists("sendData", mode = "function", 
[08:29:12.361]                       envir = ns)) {
[08:29:12.361]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:12.361]                         envir = ns)
[08:29:12.361]                       envir <- sys.frame(frame)
[08:29:12.361]                       master <- NULL
[08:29:12.361]                       while (!identical(envir, .GlobalEnv) && 
[08:29:12.361]                         !identical(envir, emptyenv())) {
[08:29:12.361]                         if (exists("master", mode = "list", envir = envir, 
[08:29:12.361]                           inherits = FALSE)) {
[08:29:12.361]                           master <- get("master", mode = "list", 
[08:29:12.361]                             envir = envir, inherits = FALSE)
[08:29:12.361]                           if (inherits(master, c("SOCKnode", 
[08:29:12.361]                             "SOCK0node"))) {
[08:29:12.361]                             sendCondition <<- function(cond) {
[08:29:12.361]                               data <- list(type = "VALUE", value = cond, 
[08:29:12.361]                                 success = TRUE)
[08:29:12.361]                               parallel_sendData(master, data)
[08:29:12.361]                             }
[08:29:12.361]                             return(sendCondition)
[08:29:12.361]                           }
[08:29:12.361]                         }
[08:29:12.361]                         frame <- frame + 1L
[08:29:12.361]                         envir <- sys.frame(frame)
[08:29:12.361]                       }
[08:29:12.361]                     }
[08:29:12.361]                     sendCondition <<- function(cond) NULL
[08:29:12.361]                   }
[08:29:12.361]                 })
[08:29:12.361]                 withCallingHandlers({
[08:29:12.361]                   {
[08:29:12.361]                     Sys.sleep(0.5)
[08:29:12.361]                     list(a = 1, b = 42L)
[08:29:12.361]                   }
[08:29:12.361]                 }, immediateCondition = function(cond) {
[08:29:12.361]                   sendCondition <- ...future.makeSendCondition()
[08:29:12.361]                   sendCondition(cond)
[08:29:12.361]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.361]                   {
[08:29:12.361]                     inherits <- base::inherits
[08:29:12.361]                     invokeRestart <- base::invokeRestart
[08:29:12.361]                     is.null <- base::is.null
[08:29:12.361]                     muffled <- FALSE
[08:29:12.361]                     if (inherits(cond, "message")) {
[08:29:12.361]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:12.361]                       if (muffled) 
[08:29:12.361]                         invokeRestart("muffleMessage")
[08:29:12.361]                     }
[08:29:12.361]                     else if (inherits(cond, "warning")) {
[08:29:12.361]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:12.361]                       if (muffled) 
[08:29:12.361]                         invokeRestart("muffleWarning")
[08:29:12.361]                     }
[08:29:12.361]                     else if (inherits(cond, "condition")) {
[08:29:12.361]                       if (!is.null(pattern)) {
[08:29:12.361]                         computeRestarts <- base::computeRestarts
[08:29:12.361]                         grepl <- base::grepl
[08:29:12.361]                         restarts <- computeRestarts(cond)
[08:29:12.361]                         for (restart in restarts) {
[08:29:12.361]                           name <- restart$name
[08:29:12.361]                           if (is.null(name)) 
[08:29:12.361]                             next
[08:29:12.361]                           if (!grepl(pattern, name)) 
[08:29:12.361]                             next
[08:29:12.361]                           invokeRestart(restart)
[08:29:12.361]                           muffled <- TRUE
[08:29:12.361]                           break
[08:29:12.361]                         }
[08:29:12.361]                       }
[08:29:12.361]                     }
[08:29:12.361]                     invisible(muffled)
[08:29:12.361]                   }
[08:29:12.361]                   muffleCondition(cond)
[08:29:12.361]                 })
[08:29:12.361]             }))
[08:29:12.361]             future::FutureResult(value = ...future.value$value, 
[08:29:12.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:12.361]                   ...future.rng), globalenv = if (FALSE) 
[08:29:12.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:12.361]                     ...future.globalenv.names))
[08:29:12.361]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:12.361]         }, condition = base::local({
[08:29:12.361]             c <- base::c
[08:29:12.361]             inherits <- base::inherits
[08:29:12.361]             invokeRestart <- base::invokeRestart
[08:29:12.361]             length <- base::length
[08:29:12.361]             list <- base::list
[08:29:12.361]             seq.int <- base::seq.int
[08:29:12.361]             signalCondition <- base::signalCondition
[08:29:12.361]             sys.calls <- base::sys.calls
[08:29:12.361]             `[[` <- base::`[[`
[08:29:12.361]             `+` <- base::`+`
[08:29:12.361]             `<<-` <- base::`<<-`
[08:29:12.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:12.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:12.361]                   3L)]
[08:29:12.361]             }
[08:29:12.361]             function(cond) {
[08:29:12.361]                 is_error <- inherits(cond, "error")
[08:29:12.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:12.361]                   NULL)
[08:29:12.361]                 if (is_error) {
[08:29:12.361]                   sessionInformation <- function() {
[08:29:12.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:12.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:12.361]                       search = base::search(), system = base::Sys.info())
[08:29:12.361]                   }
[08:29:12.361]                   ...future.conditions[[length(...future.conditions) + 
[08:29:12.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:12.361]                     cond$call), session = sessionInformation(), 
[08:29:12.361]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:12.361]                   signalCondition(cond)
[08:29:12.361]                 }
[08:29:12.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:12.361]                 "immediateCondition"))) {
[08:29:12.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:12.361]                   ...future.conditions[[length(...future.conditions) + 
[08:29:12.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:12.361]                   if (TRUE && !signal) {
[08:29:12.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.361]                     {
[08:29:12.361]                       inherits <- base::inherits
[08:29:12.361]                       invokeRestart <- base::invokeRestart
[08:29:12.361]                       is.null <- base::is.null
[08:29:12.361]                       muffled <- FALSE
[08:29:12.361]                       if (inherits(cond, "message")) {
[08:29:12.361]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:12.361]                         if (muffled) 
[08:29:12.361]                           invokeRestart("muffleMessage")
[08:29:12.361]                       }
[08:29:12.361]                       else if (inherits(cond, "warning")) {
[08:29:12.361]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:12.361]                         if (muffled) 
[08:29:12.361]                           invokeRestart("muffleWarning")
[08:29:12.361]                       }
[08:29:12.361]                       else if (inherits(cond, "condition")) {
[08:29:12.361]                         if (!is.null(pattern)) {
[08:29:12.361]                           computeRestarts <- base::computeRestarts
[08:29:12.361]                           grepl <- base::grepl
[08:29:12.361]                           restarts <- computeRestarts(cond)
[08:29:12.361]                           for (restart in restarts) {
[08:29:12.361]                             name <- restart$name
[08:29:12.361]                             if (is.null(name)) 
[08:29:12.361]                               next
[08:29:12.361]                             if (!grepl(pattern, name)) 
[08:29:12.361]                               next
[08:29:12.361]                             invokeRestart(restart)
[08:29:12.361]                             muffled <- TRUE
[08:29:12.361]                             break
[08:29:12.361]                           }
[08:29:12.361]                         }
[08:29:12.361]                       }
[08:29:12.361]                       invisible(muffled)
[08:29:12.361]                     }
[08:29:12.361]                     muffleCondition(cond, pattern = "^muffle")
[08:29:12.361]                   }
[08:29:12.361]                 }
[08:29:12.361]                 else {
[08:29:12.361]                   if (TRUE) {
[08:29:12.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.361]                     {
[08:29:12.361]                       inherits <- base::inherits
[08:29:12.361]                       invokeRestart <- base::invokeRestart
[08:29:12.361]                       is.null <- base::is.null
[08:29:12.361]                       muffled <- FALSE
[08:29:12.361]                       if (inherits(cond, "message")) {
[08:29:12.361]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:12.361]                         if (muffled) 
[08:29:12.361]                           invokeRestart("muffleMessage")
[08:29:12.361]                       }
[08:29:12.361]                       else if (inherits(cond, "warning")) {
[08:29:12.361]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:12.361]                         if (muffled) 
[08:29:12.361]                           invokeRestart("muffleWarning")
[08:29:12.361]                       }
[08:29:12.361]                       else if (inherits(cond, "condition")) {
[08:29:12.361]                         if (!is.null(pattern)) {
[08:29:12.361]                           computeRestarts <- base::computeRestarts
[08:29:12.361]                           grepl <- base::grepl
[08:29:12.361]                           restarts <- computeRestarts(cond)
[08:29:12.361]                           for (restart in restarts) {
[08:29:12.361]                             name <- restart$name
[08:29:12.361]                             if (is.null(name)) 
[08:29:12.361]                               next
[08:29:12.361]                             if (!grepl(pattern, name)) 
[08:29:12.361]                               next
[08:29:12.361]                             invokeRestart(restart)
[08:29:12.361]                             muffled <- TRUE
[08:29:12.361]                             break
[08:29:12.361]                           }
[08:29:12.361]                         }
[08:29:12.361]                       }
[08:29:12.361]                       invisible(muffled)
[08:29:12.361]                     }
[08:29:12.361]                     muffleCondition(cond, pattern = "^muffle")
[08:29:12.361]                   }
[08:29:12.361]                 }
[08:29:12.361]             }
[08:29:12.361]         }))
[08:29:12.361]     }, error = function(ex) {
[08:29:12.361]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:12.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:12.361]                 ...future.rng), started = ...future.startTime, 
[08:29:12.361]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:12.361]             version = "1.8"), class = "FutureResult")
[08:29:12.361]     }, finally = {
[08:29:12.361]         if (!identical(...future.workdir, getwd())) 
[08:29:12.361]             setwd(...future.workdir)
[08:29:12.361]         {
[08:29:12.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:12.361]                 ...future.oldOptions$nwarnings <- NULL
[08:29:12.361]             }
[08:29:12.361]             base::options(...future.oldOptions)
[08:29:12.361]             if (.Platform$OS.type == "windows") {
[08:29:12.361]                 old_names <- names(...future.oldEnvVars)
[08:29:12.361]                 envs <- base::Sys.getenv()
[08:29:12.361]                 names <- names(envs)
[08:29:12.361]                 common <- intersect(names, old_names)
[08:29:12.361]                 added <- setdiff(names, old_names)
[08:29:12.361]                 removed <- setdiff(old_names, names)
[08:29:12.361]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:12.361]                   envs[common]]
[08:29:12.361]                 NAMES <- toupper(changed)
[08:29:12.361]                 args <- list()
[08:29:12.361]                 for (kk in seq_along(NAMES)) {
[08:29:12.361]                   name <- changed[[kk]]
[08:29:12.361]                   NAME <- NAMES[[kk]]
[08:29:12.361]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.361]                     next
[08:29:12.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:12.361]                 }
[08:29:12.361]                 NAMES <- toupper(added)
[08:29:12.361]                 for (kk in seq_along(NAMES)) {
[08:29:12.361]                   name <- added[[kk]]
[08:29:12.361]                   NAME <- NAMES[[kk]]
[08:29:12.361]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.361]                     next
[08:29:12.361]                   args[[name]] <- ""
[08:29:12.361]                 }
[08:29:12.361]                 NAMES <- toupper(removed)
[08:29:12.361]                 for (kk in seq_along(NAMES)) {
[08:29:12.361]                   name <- removed[[kk]]
[08:29:12.361]                   NAME <- NAMES[[kk]]
[08:29:12.361]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.361]                     next
[08:29:12.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:12.361]                 }
[08:29:12.361]                 if (length(args) > 0) 
[08:29:12.361]                   base::do.call(base::Sys.setenv, args = args)
[08:29:12.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:12.361]             }
[08:29:12.361]             else {
[08:29:12.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:12.361]             }
[08:29:12.361]             {
[08:29:12.361]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:12.361]                   0L) {
[08:29:12.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:12.361]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:12.361]                   base::options(opts)
[08:29:12.361]                 }
[08:29:12.361]                 {
[08:29:12.361]                   {
[08:29:12.361]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:12.361]                     NULL
[08:29:12.361]                   }
[08:29:12.361]                   options(future.plan = NULL)
[08:29:12.361]                   if (is.na(NA_character_)) 
[08:29:12.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:12.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:12.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:12.361]                     .init = FALSE)
[08:29:12.361]                 }
[08:29:12.361]             }
[08:29:12.361]         }
[08:29:12.361]     })
[08:29:12.361]     if (TRUE) {
[08:29:12.361]         base::sink(type = "output", split = FALSE)
[08:29:12.361]         if (TRUE) {
[08:29:12.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:12.361]         }
[08:29:12.361]         else {
[08:29:12.361]             ...future.result["stdout"] <- base::list(NULL)
[08:29:12.361]         }
[08:29:12.361]         base::close(...future.stdout)
[08:29:12.361]         ...future.stdout <- NULL
[08:29:12.361]     }
[08:29:12.361]     ...future.result$conditions <- ...future.conditions
[08:29:12.361]     ...future.result$finished <- base::Sys.time()
[08:29:12.361]     ...future.result
[08:29:12.361] }
[08:29:12.364] MultisessionFuture started
[08:29:12.364] - Launch lazy future ... done
[08:29:12.364] run() for ‘MultisessionFuture’ ... done
[08:29:12.907] receiveMessageFromWorker() for ClusterFuture ...
[08:29:12.907] - Validating connection of MultisessionFuture
[08:29:12.907] - received message: FutureResult
[08:29:12.907] - Received FutureResult
[08:29:12.907] - Erased future from FutureRegistry
[08:29:12.908] result() for ClusterFuture ...
[08:29:12.908] - result already collected: FutureResult
[08:29:12.908] result() for ClusterFuture ... done
[08:29:12.908] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:12.908] A MultisessionFuture was resolved
[08:29:12.908] getGlobalsAndPackages() ...
[08:29:12.908] Searching for globals...
[08:29:12.909] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:12.909] Searching for globals ... DONE
[08:29:12.909] Resolving globals: FALSE
[08:29:12.910] 
[08:29:12.910] 
[08:29:12.910] getGlobalsAndPackages() ... DONE
[08:29:12.910] run() for ‘Future’ ...
[08:29:12.910] - state: ‘created’
[08:29:12.910] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:12.924] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:12.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:12.924]   - Field: ‘node’
[08:29:12.925]   - Field: ‘label’
[08:29:12.925]   - Field: ‘local’
[08:29:12.925]   - Field: ‘owner’
[08:29:12.925]   - Field: ‘envir’
[08:29:12.925]   - Field: ‘workers’
[08:29:12.925]   - Field: ‘packages’
[08:29:12.925]   - Field: ‘gc’
[08:29:12.925]   - Field: ‘conditions’
[08:29:12.925]   - Field: ‘persistent’
[08:29:12.925]   - Field: ‘expr’
[08:29:12.925]   - Field: ‘uuid’
[08:29:12.925]   - Field: ‘seed’
[08:29:12.926]   - Field: ‘version’
[08:29:12.926]   - Field: ‘result’
[08:29:12.926]   - Field: ‘asynchronous’
[08:29:12.926]   - Field: ‘calls’
[08:29:12.926]   - Field: ‘globals’
[08:29:12.926]   - Field: ‘stdout’
[08:29:12.926]   - Field: ‘earlySignal’
[08:29:12.926]   - Field: ‘lazy’
[08:29:12.926]   - Field: ‘state’
[08:29:12.926] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:12.926] - Launch lazy future ...
[08:29:12.927] Packages needed by the future expression (n = 0): <none>
[08:29:12.927] Packages needed by future strategies (n = 0): <none>
[08:29:12.927] {
[08:29:12.927]     {
[08:29:12.927]         {
[08:29:12.927]             ...future.startTime <- base::Sys.time()
[08:29:12.927]             {
[08:29:12.927]                 {
[08:29:12.927]                   {
[08:29:12.927]                     {
[08:29:12.927]                       base::local({
[08:29:12.927]                         has_future <- base::requireNamespace("future", 
[08:29:12.927]                           quietly = TRUE)
[08:29:12.927]                         if (has_future) {
[08:29:12.927]                           ns <- base::getNamespace("future")
[08:29:12.927]                           version <- ns[[".package"]][["version"]]
[08:29:12.927]                           if (is.null(version)) 
[08:29:12.927]                             version <- utils::packageVersion("future")
[08:29:12.927]                         }
[08:29:12.927]                         else {
[08:29:12.927]                           version <- NULL
[08:29:12.927]                         }
[08:29:12.927]                         if (!has_future || version < "1.8.0") {
[08:29:12.927]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:12.927]                             "", base::R.version$version.string), 
[08:29:12.927]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:12.927]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:12.927]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:12.927]                               "release", "version")], collapse = " "), 
[08:29:12.927]                             hostname = base::Sys.info()[["nodename"]])
[08:29:12.927]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:12.927]                             info)
[08:29:12.927]                           info <- base::paste(info, collapse = "; ")
[08:29:12.927]                           if (!has_future) {
[08:29:12.927]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:12.927]                               info)
[08:29:12.927]                           }
[08:29:12.927]                           else {
[08:29:12.927]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:12.927]                               info, version)
[08:29:12.927]                           }
[08:29:12.927]                           base::stop(msg)
[08:29:12.927]                         }
[08:29:12.927]                       })
[08:29:12.927]                     }
[08:29:12.927]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:12.927]                     base::options(mc.cores = 1L)
[08:29:12.927]                   }
[08:29:12.927]                   ...future.strategy.old <- future::plan("list")
[08:29:12.927]                   options(future.plan = NULL)
[08:29:12.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:12.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:12.927]                 }
[08:29:12.927]                 ...future.workdir <- getwd()
[08:29:12.927]             }
[08:29:12.927]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:12.927]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:12.927]         }
[08:29:12.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:12.927]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:12.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:12.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:12.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:12.927]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:12.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:12.927]             base::names(...future.oldOptions))
[08:29:12.927]     }
[08:29:12.927]     if (FALSE) {
[08:29:12.927]     }
[08:29:12.927]     else {
[08:29:12.927]         if (TRUE) {
[08:29:12.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:12.927]                 open = "w")
[08:29:12.927]         }
[08:29:12.927]         else {
[08:29:12.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:12.927]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:12.927]         }
[08:29:12.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:12.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:12.927]             base::sink(type = "output", split = FALSE)
[08:29:12.927]             base::close(...future.stdout)
[08:29:12.927]         }, add = TRUE)
[08:29:12.927]     }
[08:29:12.927]     ...future.frame <- base::sys.nframe()
[08:29:12.927]     ...future.conditions <- base::list()
[08:29:12.927]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:12.927]     if (FALSE) {
[08:29:12.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:12.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:12.927]     }
[08:29:12.927]     ...future.result <- base::tryCatch({
[08:29:12.927]         base::withCallingHandlers({
[08:29:12.927]             ...future.value <- base::withVisible(base::local({
[08:29:12.927]                 ...future.makeSendCondition <- base::local({
[08:29:12.927]                   sendCondition <- NULL
[08:29:12.927]                   function(frame = 1L) {
[08:29:12.927]                     if (is.function(sendCondition)) 
[08:29:12.927]                       return(sendCondition)
[08:29:12.927]                     ns <- getNamespace("parallel")
[08:29:12.927]                     if (exists("sendData", mode = "function", 
[08:29:12.927]                       envir = ns)) {
[08:29:12.927]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:12.927]                         envir = ns)
[08:29:12.927]                       envir <- sys.frame(frame)
[08:29:12.927]                       master <- NULL
[08:29:12.927]                       while (!identical(envir, .GlobalEnv) && 
[08:29:12.927]                         !identical(envir, emptyenv())) {
[08:29:12.927]                         if (exists("master", mode = "list", envir = envir, 
[08:29:12.927]                           inherits = FALSE)) {
[08:29:12.927]                           master <- get("master", mode = "list", 
[08:29:12.927]                             envir = envir, inherits = FALSE)
[08:29:12.927]                           if (inherits(master, c("SOCKnode", 
[08:29:12.927]                             "SOCK0node"))) {
[08:29:12.927]                             sendCondition <<- function(cond) {
[08:29:12.927]                               data <- list(type = "VALUE", value = cond, 
[08:29:12.927]                                 success = TRUE)
[08:29:12.927]                               parallel_sendData(master, data)
[08:29:12.927]                             }
[08:29:12.927]                             return(sendCondition)
[08:29:12.927]                           }
[08:29:12.927]                         }
[08:29:12.927]                         frame <- frame + 1L
[08:29:12.927]                         envir <- sys.frame(frame)
[08:29:12.927]                       }
[08:29:12.927]                     }
[08:29:12.927]                     sendCondition <<- function(cond) NULL
[08:29:12.927]                   }
[08:29:12.927]                 })
[08:29:12.927]                 withCallingHandlers({
[08:29:12.927]                   {
[08:29:12.927]                     Sys.sleep(0.5)
[08:29:12.927]                     list(a = 1, b = 42L)
[08:29:12.927]                   }
[08:29:12.927]                 }, immediateCondition = function(cond) {
[08:29:12.927]                   sendCondition <- ...future.makeSendCondition()
[08:29:12.927]                   sendCondition(cond)
[08:29:12.927]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.927]                   {
[08:29:12.927]                     inherits <- base::inherits
[08:29:12.927]                     invokeRestart <- base::invokeRestart
[08:29:12.927]                     is.null <- base::is.null
[08:29:12.927]                     muffled <- FALSE
[08:29:12.927]                     if (inherits(cond, "message")) {
[08:29:12.927]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:12.927]                       if (muffled) 
[08:29:12.927]                         invokeRestart("muffleMessage")
[08:29:12.927]                     }
[08:29:12.927]                     else if (inherits(cond, "warning")) {
[08:29:12.927]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:12.927]                       if (muffled) 
[08:29:12.927]                         invokeRestart("muffleWarning")
[08:29:12.927]                     }
[08:29:12.927]                     else if (inherits(cond, "condition")) {
[08:29:12.927]                       if (!is.null(pattern)) {
[08:29:12.927]                         computeRestarts <- base::computeRestarts
[08:29:12.927]                         grepl <- base::grepl
[08:29:12.927]                         restarts <- computeRestarts(cond)
[08:29:12.927]                         for (restart in restarts) {
[08:29:12.927]                           name <- restart$name
[08:29:12.927]                           if (is.null(name)) 
[08:29:12.927]                             next
[08:29:12.927]                           if (!grepl(pattern, name)) 
[08:29:12.927]                             next
[08:29:12.927]                           invokeRestart(restart)
[08:29:12.927]                           muffled <- TRUE
[08:29:12.927]                           break
[08:29:12.927]                         }
[08:29:12.927]                       }
[08:29:12.927]                     }
[08:29:12.927]                     invisible(muffled)
[08:29:12.927]                   }
[08:29:12.927]                   muffleCondition(cond)
[08:29:12.927]                 })
[08:29:12.927]             }))
[08:29:12.927]             future::FutureResult(value = ...future.value$value, 
[08:29:12.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:12.927]                   ...future.rng), globalenv = if (FALSE) 
[08:29:12.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:12.927]                     ...future.globalenv.names))
[08:29:12.927]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:12.927]         }, condition = base::local({
[08:29:12.927]             c <- base::c
[08:29:12.927]             inherits <- base::inherits
[08:29:12.927]             invokeRestart <- base::invokeRestart
[08:29:12.927]             length <- base::length
[08:29:12.927]             list <- base::list
[08:29:12.927]             seq.int <- base::seq.int
[08:29:12.927]             signalCondition <- base::signalCondition
[08:29:12.927]             sys.calls <- base::sys.calls
[08:29:12.927]             `[[` <- base::`[[`
[08:29:12.927]             `+` <- base::`+`
[08:29:12.927]             `<<-` <- base::`<<-`
[08:29:12.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:12.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:12.927]                   3L)]
[08:29:12.927]             }
[08:29:12.927]             function(cond) {
[08:29:12.927]                 is_error <- inherits(cond, "error")
[08:29:12.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:12.927]                   NULL)
[08:29:12.927]                 if (is_error) {
[08:29:12.927]                   sessionInformation <- function() {
[08:29:12.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:12.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:12.927]                       search = base::search(), system = base::Sys.info())
[08:29:12.927]                   }
[08:29:12.927]                   ...future.conditions[[length(...future.conditions) + 
[08:29:12.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:12.927]                     cond$call), session = sessionInformation(), 
[08:29:12.927]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:12.927]                   signalCondition(cond)
[08:29:12.927]                 }
[08:29:12.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:12.927]                 "immediateCondition"))) {
[08:29:12.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:12.927]                   ...future.conditions[[length(...future.conditions) + 
[08:29:12.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:12.927]                   if (TRUE && !signal) {
[08:29:12.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.927]                     {
[08:29:12.927]                       inherits <- base::inherits
[08:29:12.927]                       invokeRestart <- base::invokeRestart
[08:29:12.927]                       is.null <- base::is.null
[08:29:12.927]                       muffled <- FALSE
[08:29:12.927]                       if (inherits(cond, "message")) {
[08:29:12.927]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:12.927]                         if (muffled) 
[08:29:12.927]                           invokeRestart("muffleMessage")
[08:29:12.927]                       }
[08:29:12.927]                       else if (inherits(cond, "warning")) {
[08:29:12.927]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:12.927]                         if (muffled) 
[08:29:12.927]                           invokeRestart("muffleWarning")
[08:29:12.927]                       }
[08:29:12.927]                       else if (inherits(cond, "condition")) {
[08:29:12.927]                         if (!is.null(pattern)) {
[08:29:12.927]                           computeRestarts <- base::computeRestarts
[08:29:12.927]                           grepl <- base::grepl
[08:29:12.927]                           restarts <- computeRestarts(cond)
[08:29:12.927]                           for (restart in restarts) {
[08:29:12.927]                             name <- restart$name
[08:29:12.927]                             if (is.null(name)) 
[08:29:12.927]                               next
[08:29:12.927]                             if (!grepl(pattern, name)) 
[08:29:12.927]                               next
[08:29:12.927]                             invokeRestart(restart)
[08:29:12.927]                             muffled <- TRUE
[08:29:12.927]                             break
[08:29:12.927]                           }
[08:29:12.927]                         }
[08:29:12.927]                       }
[08:29:12.927]                       invisible(muffled)
[08:29:12.927]                     }
[08:29:12.927]                     muffleCondition(cond, pattern = "^muffle")
[08:29:12.927]                   }
[08:29:12.927]                 }
[08:29:12.927]                 else {
[08:29:12.927]                   if (TRUE) {
[08:29:12.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:12.927]                     {
[08:29:12.927]                       inherits <- base::inherits
[08:29:12.927]                       invokeRestart <- base::invokeRestart
[08:29:12.927]                       is.null <- base::is.null
[08:29:12.927]                       muffled <- FALSE
[08:29:12.927]                       if (inherits(cond, "message")) {
[08:29:12.927]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:12.927]                         if (muffled) 
[08:29:12.927]                           invokeRestart("muffleMessage")
[08:29:12.927]                       }
[08:29:12.927]                       else if (inherits(cond, "warning")) {
[08:29:12.927]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:12.927]                         if (muffled) 
[08:29:12.927]                           invokeRestart("muffleWarning")
[08:29:12.927]                       }
[08:29:12.927]                       else if (inherits(cond, "condition")) {
[08:29:12.927]                         if (!is.null(pattern)) {
[08:29:12.927]                           computeRestarts <- base::computeRestarts
[08:29:12.927]                           grepl <- base::grepl
[08:29:12.927]                           restarts <- computeRestarts(cond)
[08:29:12.927]                           for (restart in restarts) {
[08:29:12.927]                             name <- restart$name
[08:29:12.927]                             if (is.null(name)) 
[08:29:12.927]                               next
[08:29:12.927]                             if (!grepl(pattern, name)) 
[08:29:12.927]                               next
[08:29:12.927]                             invokeRestart(restart)
[08:29:12.927]                             muffled <- TRUE
[08:29:12.927]                             break
[08:29:12.927]                           }
[08:29:12.927]                         }
[08:29:12.927]                       }
[08:29:12.927]                       invisible(muffled)
[08:29:12.927]                     }
[08:29:12.927]                     muffleCondition(cond, pattern = "^muffle")
[08:29:12.927]                   }
[08:29:12.927]                 }
[08:29:12.927]             }
[08:29:12.927]         }))
[08:29:12.927]     }, error = function(ex) {
[08:29:12.927]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:12.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:12.927]                 ...future.rng), started = ...future.startTime, 
[08:29:12.927]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:12.927]             version = "1.8"), class = "FutureResult")
[08:29:12.927]     }, finally = {
[08:29:12.927]         if (!identical(...future.workdir, getwd())) 
[08:29:12.927]             setwd(...future.workdir)
[08:29:12.927]         {
[08:29:12.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:12.927]                 ...future.oldOptions$nwarnings <- NULL
[08:29:12.927]             }
[08:29:12.927]             base::options(...future.oldOptions)
[08:29:12.927]             if (.Platform$OS.type == "windows") {
[08:29:12.927]                 old_names <- names(...future.oldEnvVars)
[08:29:12.927]                 envs <- base::Sys.getenv()
[08:29:12.927]                 names <- names(envs)
[08:29:12.927]                 common <- intersect(names, old_names)
[08:29:12.927]                 added <- setdiff(names, old_names)
[08:29:12.927]                 removed <- setdiff(old_names, names)
[08:29:12.927]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:12.927]                   envs[common]]
[08:29:12.927]                 NAMES <- toupper(changed)
[08:29:12.927]                 args <- list()
[08:29:12.927]                 for (kk in seq_along(NAMES)) {
[08:29:12.927]                   name <- changed[[kk]]
[08:29:12.927]                   NAME <- NAMES[[kk]]
[08:29:12.927]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.927]                     next
[08:29:12.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:12.927]                 }
[08:29:12.927]                 NAMES <- toupper(added)
[08:29:12.927]                 for (kk in seq_along(NAMES)) {
[08:29:12.927]                   name <- added[[kk]]
[08:29:12.927]                   NAME <- NAMES[[kk]]
[08:29:12.927]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.927]                     next
[08:29:12.927]                   args[[name]] <- ""
[08:29:12.927]                 }
[08:29:12.927]                 NAMES <- toupper(removed)
[08:29:12.927]                 for (kk in seq_along(NAMES)) {
[08:29:12.927]                   name <- removed[[kk]]
[08:29:12.927]                   NAME <- NAMES[[kk]]
[08:29:12.927]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:12.927]                     next
[08:29:12.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:12.927]                 }
[08:29:12.927]                 if (length(args) > 0) 
[08:29:12.927]                   base::do.call(base::Sys.setenv, args = args)
[08:29:12.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:12.927]             }
[08:29:12.927]             else {
[08:29:12.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:12.927]             }
[08:29:12.927]             {
[08:29:12.927]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:12.927]                   0L) {
[08:29:12.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:12.927]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:12.927]                   base::options(opts)
[08:29:12.927]                 }
[08:29:12.927]                 {
[08:29:12.927]                   {
[08:29:12.927]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:12.927]                     NULL
[08:29:12.927]                   }
[08:29:12.927]                   options(future.plan = NULL)
[08:29:12.927]                   if (is.na(NA_character_)) 
[08:29:12.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:12.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:12.927]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:12.927]                     .init = FALSE)
[08:29:12.927]                 }
[08:29:12.927]             }
[08:29:12.927]         }
[08:29:12.927]     })
[08:29:12.927]     if (TRUE) {
[08:29:12.927]         base::sink(type = "output", split = FALSE)
[08:29:12.927]         if (TRUE) {
[08:29:12.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:12.927]         }
[08:29:12.927]         else {
[08:29:12.927]             ...future.result["stdout"] <- base::list(NULL)
[08:29:12.927]         }
[08:29:12.927]         base::close(...future.stdout)
[08:29:12.927]         ...future.stdout <- NULL
[08:29:12.927]     }
[08:29:12.927]     ...future.result$conditions <- ...future.conditions
[08:29:12.927]     ...future.result$finished <- base::Sys.time()
[08:29:12.927]     ...future.result
[08:29:12.927] }
[08:29:12.930] MultisessionFuture started
[08:29:12.930] - Launch lazy future ... done
[08:29:12.930] run() for ‘MultisessionFuture’ ... done
[08:29:13.473] receiveMessageFromWorker() for ClusterFuture ...
[08:29:13.473] - Validating connection of MultisessionFuture
[08:29:13.473] - received message: FutureResult
[08:29:13.474] - Received FutureResult
[08:29:13.474] - Erased future from FutureRegistry
[08:29:13.474] result() for ClusterFuture ...
[08:29:13.474] - result already collected: FutureResult
[08:29:13.474] result() for ClusterFuture ... done
[08:29:13.474] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:13.474] A MultisessionFuture was resolved
- w/ exception ...
[08:29:13.474] getGlobalsAndPackages() ...
[08:29:13.474] Searching for globals...
[08:29:13.475] - globals found: [2] ‘list’, ‘stop’
[08:29:13.475] Searching for globals ... DONE
[08:29:13.475] Resolving globals: FALSE
[08:29:13.476] 
[08:29:13.476] 
[08:29:13.476] getGlobalsAndPackages() ... DONE
[08:29:13.476] run() for ‘Future’ ...
[08:29:13.476] - state: ‘created’
[08:29:13.476] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:13.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:13.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:13.490]   - Field: ‘node’
[08:29:13.490]   - Field: ‘label’
[08:29:13.490]   - Field: ‘local’
[08:29:13.490]   - Field: ‘owner’
[08:29:13.490]   - Field: ‘envir’
[08:29:13.490]   - Field: ‘workers’
[08:29:13.491]   - Field: ‘packages’
[08:29:13.491]   - Field: ‘gc’
[08:29:13.491]   - Field: ‘conditions’
[08:29:13.491]   - Field: ‘persistent’
[08:29:13.491]   - Field: ‘expr’
[08:29:13.491]   - Field: ‘uuid’
[08:29:13.491]   - Field: ‘seed’
[08:29:13.491]   - Field: ‘version’
[08:29:13.491]   - Field: ‘result’
[08:29:13.491]   - Field: ‘asynchronous’
[08:29:13.491]   - Field: ‘calls’
[08:29:13.492]   - Field: ‘globals’
[08:29:13.492]   - Field: ‘stdout’
[08:29:13.492]   - Field: ‘earlySignal’
[08:29:13.492]   - Field: ‘lazy’
[08:29:13.492]   - Field: ‘state’
[08:29:13.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:13.492] - Launch lazy future ...
[08:29:13.492] Packages needed by the future expression (n = 0): <none>
[08:29:13.492] Packages needed by future strategies (n = 0): <none>
[08:29:13.493] {
[08:29:13.493]     {
[08:29:13.493]         {
[08:29:13.493]             ...future.startTime <- base::Sys.time()
[08:29:13.493]             {
[08:29:13.493]                 {
[08:29:13.493]                   {
[08:29:13.493]                     {
[08:29:13.493]                       base::local({
[08:29:13.493]                         has_future <- base::requireNamespace("future", 
[08:29:13.493]                           quietly = TRUE)
[08:29:13.493]                         if (has_future) {
[08:29:13.493]                           ns <- base::getNamespace("future")
[08:29:13.493]                           version <- ns[[".package"]][["version"]]
[08:29:13.493]                           if (is.null(version)) 
[08:29:13.493]                             version <- utils::packageVersion("future")
[08:29:13.493]                         }
[08:29:13.493]                         else {
[08:29:13.493]                           version <- NULL
[08:29:13.493]                         }
[08:29:13.493]                         if (!has_future || version < "1.8.0") {
[08:29:13.493]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:13.493]                             "", base::R.version$version.string), 
[08:29:13.493]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:13.493]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:13.493]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:13.493]                               "release", "version")], collapse = " "), 
[08:29:13.493]                             hostname = base::Sys.info()[["nodename"]])
[08:29:13.493]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:13.493]                             info)
[08:29:13.493]                           info <- base::paste(info, collapse = "; ")
[08:29:13.493]                           if (!has_future) {
[08:29:13.493]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:13.493]                               info)
[08:29:13.493]                           }
[08:29:13.493]                           else {
[08:29:13.493]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:13.493]                               info, version)
[08:29:13.493]                           }
[08:29:13.493]                           base::stop(msg)
[08:29:13.493]                         }
[08:29:13.493]                       })
[08:29:13.493]                     }
[08:29:13.493]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:13.493]                     base::options(mc.cores = 1L)
[08:29:13.493]                   }
[08:29:13.493]                   ...future.strategy.old <- future::plan("list")
[08:29:13.493]                   options(future.plan = NULL)
[08:29:13.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:13.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:13.493]                 }
[08:29:13.493]                 ...future.workdir <- getwd()
[08:29:13.493]             }
[08:29:13.493]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:13.493]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:13.493]         }
[08:29:13.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:13.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:13.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:13.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:13.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:13.493]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:13.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:13.493]             base::names(...future.oldOptions))
[08:29:13.493]     }
[08:29:13.493]     if (FALSE) {
[08:29:13.493]     }
[08:29:13.493]     else {
[08:29:13.493]         if (TRUE) {
[08:29:13.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:13.493]                 open = "w")
[08:29:13.493]         }
[08:29:13.493]         else {
[08:29:13.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:13.493]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:13.493]         }
[08:29:13.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:13.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:13.493]             base::sink(type = "output", split = FALSE)
[08:29:13.493]             base::close(...future.stdout)
[08:29:13.493]         }, add = TRUE)
[08:29:13.493]     }
[08:29:13.493]     ...future.frame <- base::sys.nframe()
[08:29:13.493]     ...future.conditions <- base::list()
[08:29:13.493]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:13.493]     if (FALSE) {
[08:29:13.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:13.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:13.493]     }
[08:29:13.493]     ...future.result <- base::tryCatch({
[08:29:13.493]         base::withCallingHandlers({
[08:29:13.493]             ...future.value <- base::withVisible(base::local({
[08:29:13.493]                 ...future.makeSendCondition <- base::local({
[08:29:13.493]                   sendCondition <- NULL
[08:29:13.493]                   function(frame = 1L) {
[08:29:13.493]                     if (is.function(sendCondition)) 
[08:29:13.493]                       return(sendCondition)
[08:29:13.493]                     ns <- getNamespace("parallel")
[08:29:13.493]                     if (exists("sendData", mode = "function", 
[08:29:13.493]                       envir = ns)) {
[08:29:13.493]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:13.493]                         envir = ns)
[08:29:13.493]                       envir <- sys.frame(frame)
[08:29:13.493]                       master <- NULL
[08:29:13.493]                       while (!identical(envir, .GlobalEnv) && 
[08:29:13.493]                         !identical(envir, emptyenv())) {
[08:29:13.493]                         if (exists("master", mode = "list", envir = envir, 
[08:29:13.493]                           inherits = FALSE)) {
[08:29:13.493]                           master <- get("master", mode = "list", 
[08:29:13.493]                             envir = envir, inherits = FALSE)
[08:29:13.493]                           if (inherits(master, c("SOCKnode", 
[08:29:13.493]                             "SOCK0node"))) {
[08:29:13.493]                             sendCondition <<- function(cond) {
[08:29:13.493]                               data <- list(type = "VALUE", value = cond, 
[08:29:13.493]                                 success = TRUE)
[08:29:13.493]                               parallel_sendData(master, data)
[08:29:13.493]                             }
[08:29:13.493]                             return(sendCondition)
[08:29:13.493]                           }
[08:29:13.493]                         }
[08:29:13.493]                         frame <- frame + 1L
[08:29:13.493]                         envir <- sys.frame(frame)
[08:29:13.493]                       }
[08:29:13.493]                     }
[08:29:13.493]                     sendCondition <<- function(cond) NULL
[08:29:13.493]                   }
[08:29:13.493]                 })
[08:29:13.493]                 withCallingHandlers({
[08:29:13.493]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:13.493]                 }, immediateCondition = function(cond) {
[08:29:13.493]                   sendCondition <- ...future.makeSendCondition()
[08:29:13.493]                   sendCondition(cond)
[08:29:13.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:13.493]                   {
[08:29:13.493]                     inherits <- base::inherits
[08:29:13.493]                     invokeRestart <- base::invokeRestart
[08:29:13.493]                     is.null <- base::is.null
[08:29:13.493]                     muffled <- FALSE
[08:29:13.493]                     if (inherits(cond, "message")) {
[08:29:13.493]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:13.493]                       if (muffled) 
[08:29:13.493]                         invokeRestart("muffleMessage")
[08:29:13.493]                     }
[08:29:13.493]                     else if (inherits(cond, "warning")) {
[08:29:13.493]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:13.493]                       if (muffled) 
[08:29:13.493]                         invokeRestart("muffleWarning")
[08:29:13.493]                     }
[08:29:13.493]                     else if (inherits(cond, "condition")) {
[08:29:13.493]                       if (!is.null(pattern)) {
[08:29:13.493]                         computeRestarts <- base::computeRestarts
[08:29:13.493]                         grepl <- base::grepl
[08:29:13.493]                         restarts <- computeRestarts(cond)
[08:29:13.493]                         for (restart in restarts) {
[08:29:13.493]                           name <- restart$name
[08:29:13.493]                           if (is.null(name)) 
[08:29:13.493]                             next
[08:29:13.493]                           if (!grepl(pattern, name)) 
[08:29:13.493]                             next
[08:29:13.493]                           invokeRestart(restart)
[08:29:13.493]                           muffled <- TRUE
[08:29:13.493]                           break
[08:29:13.493]                         }
[08:29:13.493]                       }
[08:29:13.493]                     }
[08:29:13.493]                     invisible(muffled)
[08:29:13.493]                   }
[08:29:13.493]                   muffleCondition(cond)
[08:29:13.493]                 })
[08:29:13.493]             }))
[08:29:13.493]             future::FutureResult(value = ...future.value$value, 
[08:29:13.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:13.493]                   ...future.rng), globalenv = if (FALSE) 
[08:29:13.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:13.493]                     ...future.globalenv.names))
[08:29:13.493]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:13.493]         }, condition = base::local({
[08:29:13.493]             c <- base::c
[08:29:13.493]             inherits <- base::inherits
[08:29:13.493]             invokeRestart <- base::invokeRestart
[08:29:13.493]             length <- base::length
[08:29:13.493]             list <- base::list
[08:29:13.493]             seq.int <- base::seq.int
[08:29:13.493]             signalCondition <- base::signalCondition
[08:29:13.493]             sys.calls <- base::sys.calls
[08:29:13.493]             `[[` <- base::`[[`
[08:29:13.493]             `+` <- base::`+`
[08:29:13.493]             `<<-` <- base::`<<-`
[08:29:13.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:13.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:13.493]                   3L)]
[08:29:13.493]             }
[08:29:13.493]             function(cond) {
[08:29:13.493]                 is_error <- inherits(cond, "error")
[08:29:13.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:13.493]                   NULL)
[08:29:13.493]                 if (is_error) {
[08:29:13.493]                   sessionInformation <- function() {
[08:29:13.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:13.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:13.493]                       search = base::search(), system = base::Sys.info())
[08:29:13.493]                   }
[08:29:13.493]                   ...future.conditions[[length(...future.conditions) + 
[08:29:13.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:13.493]                     cond$call), session = sessionInformation(), 
[08:29:13.493]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:13.493]                   signalCondition(cond)
[08:29:13.493]                 }
[08:29:13.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:13.493]                 "immediateCondition"))) {
[08:29:13.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:13.493]                   ...future.conditions[[length(...future.conditions) + 
[08:29:13.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:13.493]                   if (TRUE && !signal) {
[08:29:13.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:13.493]                     {
[08:29:13.493]                       inherits <- base::inherits
[08:29:13.493]                       invokeRestart <- base::invokeRestart
[08:29:13.493]                       is.null <- base::is.null
[08:29:13.493]                       muffled <- FALSE
[08:29:13.493]                       if (inherits(cond, "message")) {
[08:29:13.493]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:13.493]                         if (muffled) 
[08:29:13.493]                           invokeRestart("muffleMessage")
[08:29:13.493]                       }
[08:29:13.493]                       else if (inherits(cond, "warning")) {
[08:29:13.493]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:13.493]                         if (muffled) 
[08:29:13.493]                           invokeRestart("muffleWarning")
[08:29:13.493]                       }
[08:29:13.493]                       else if (inherits(cond, "condition")) {
[08:29:13.493]                         if (!is.null(pattern)) {
[08:29:13.493]                           computeRestarts <- base::computeRestarts
[08:29:13.493]                           grepl <- base::grepl
[08:29:13.493]                           restarts <- computeRestarts(cond)
[08:29:13.493]                           for (restart in restarts) {
[08:29:13.493]                             name <- restart$name
[08:29:13.493]                             if (is.null(name)) 
[08:29:13.493]                               next
[08:29:13.493]                             if (!grepl(pattern, name)) 
[08:29:13.493]                               next
[08:29:13.493]                             invokeRestart(restart)
[08:29:13.493]                             muffled <- TRUE
[08:29:13.493]                             break
[08:29:13.493]                           }
[08:29:13.493]                         }
[08:29:13.493]                       }
[08:29:13.493]                       invisible(muffled)
[08:29:13.493]                     }
[08:29:13.493]                     muffleCondition(cond, pattern = "^muffle")
[08:29:13.493]                   }
[08:29:13.493]                 }
[08:29:13.493]                 else {
[08:29:13.493]                   if (TRUE) {
[08:29:13.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:13.493]                     {
[08:29:13.493]                       inherits <- base::inherits
[08:29:13.493]                       invokeRestart <- base::invokeRestart
[08:29:13.493]                       is.null <- base::is.null
[08:29:13.493]                       muffled <- FALSE
[08:29:13.493]                       if (inherits(cond, "message")) {
[08:29:13.493]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:13.493]                         if (muffled) 
[08:29:13.493]                           invokeRestart("muffleMessage")
[08:29:13.493]                       }
[08:29:13.493]                       else if (inherits(cond, "warning")) {
[08:29:13.493]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:13.493]                         if (muffled) 
[08:29:13.493]                           invokeRestart("muffleWarning")
[08:29:13.493]                       }
[08:29:13.493]                       else if (inherits(cond, "condition")) {
[08:29:13.493]                         if (!is.null(pattern)) {
[08:29:13.493]                           computeRestarts <- base::computeRestarts
[08:29:13.493]                           grepl <- base::grepl
[08:29:13.493]                           restarts <- computeRestarts(cond)
[08:29:13.493]                           for (restart in restarts) {
[08:29:13.493]                             name <- restart$name
[08:29:13.493]                             if (is.null(name)) 
[08:29:13.493]                               next
[08:29:13.493]                             if (!grepl(pattern, name)) 
[08:29:13.493]                               next
[08:29:13.493]                             invokeRestart(restart)
[08:29:13.493]                             muffled <- TRUE
[08:29:13.493]                             break
[08:29:13.493]                           }
[08:29:13.493]                         }
[08:29:13.493]                       }
[08:29:13.493]                       invisible(muffled)
[08:29:13.493]                     }
[08:29:13.493]                     muffleCondition(cond, pattern = "^muffle")
[08:29:13.493]                   }
[08:29:13.493]                 }
[08:29:13.493]             }
[08:29:13.493]         }))
[08:29:13.493]     }, error = function(ex) {
[08:29:13.493]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:13.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:13.493]                 ...future.rng), started = ...future.startTime, 
[08:29:13.493]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:13.493]             version = "1.8"), class = "FutureResult")
[08:29:13.493]     }, finally = {
[08:29:13.493]         if (!identical(...future.workdir, getwd())) 
[08:29:13.493]             setwd(...future.workdir)
[08:29:13.493]         {
[08:29:13.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:13.493]                 ...future.oldOptions$nwarnings <- NULL
[08:29:13.493]             }
[08:29:13.493]             base::options(...future.oldOptions)
[08:29:13.493]             if (.Platform$OS.type == "windows") {
[08:29:13.493]                 old_names <- names(...future.oldEnvVars)
[08:29:13.493]                 envs <- base::Sys.getenv()
[08:29:13.493]                 names <- names(envs)
[08:29:13.493]                 common <- intersect(names, old_names)
[08:29:13.493]                 added <- setdiff(names, old_names)
[08:29:13.493]                 removed <- setdiff(old_names, names)
[08:29:13.493]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:13.493]                   envs[common]]
[08:29:13.493]                 NAMES <- toupper(changed)
[08:29:13.493]                 args <- list()
[08:29:13.493]                 for (kk in seq_along(NAMES)) {
[08:29:13.493]                   name <- changed[[kk]]
[08:29:13.493]                   NAME <- NAMES[[kk]]
[08:29:13.493]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:13.493]                     next
[08:29:13.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:13.493]                 }
[08:29:13.493]                 NAMES <- toupper(added)
[08:29:13.493]                 for (kk in seq_along(NAMES)) {
[08:29:13.493]                   name <- added[[kk]]
[08:29:13.493]                   NAME <- NAMES[[kk]]
[08:29:13.493]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:13.493]                     next
[08:29:13.493]                   args[[name]] <- ""
[08:29:13.493]                 }
[08:29:13.493]                 NAMES <- toupper(removed)
[08:29:13.493]                 for (kk in seq_along(NAMES)) {
[08:29:13.493]                   name <- removed[[kk]]
[08:29:13.493]                   NAME <- NAMES[[kk]]
[08:29:13.493]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:13.493]                     next
[08:29:13.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:13.493]                 }
[08:29:13.493]                 if (length(args) > 0) 
[08:29:13.493]                   base::do.call(base::Sys.setenv, args = args)
[08:29:13.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:13.493]             }
[08:29:13.493]             else {
[08:29:13.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:13.493]             }
[08:29:13.493]             {
[08:29:13.493]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:13.493]                   0L) {
[08:29:13.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:13.493]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:13.493]                   base::options(opts)
[08:29:13.493]                 }
[08:29:13.493]                 {
[08:29:13.493]                   {
[08:29:13.493]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:13.493]                     NULL
[08:29:13.493]                   }
[08:29:13.493]                   options(future.plan = NULL)
[08:29:13.493]                   if (is.na(NA_character_)) 
[08:29:13.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:13.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:13.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:13.493]                     .init = FALSE)
[08:29:13.493]                 }
[08:29:13.493]             }
[08:29:13.493]         }
[08:29:13.493]     })
[08:29:13.493]     if (TRUE) {
[08:29:13.493]         base::sink(type = "output", split = FALSE)
[08:29:13.493]         if (TRUE) {
[08:29:13.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:13.493]         }
[08:29:13.493]         else {
[08:29:13.493]             ...future.result["stdout"] <- base::list(NULL)
[08:29:13.493]         }
[08:29:13.493]         base::close(...future.stdout)
[08:29:13.493]         ...future.stdout <- NULL
[08:29:13.493]     }
[08:29:13.493]     ...future.result$conditions <- ...future.conditions
[08:29:13.493]     ...future.result$finished <- base::Sys.time()
[08:29:13.493]     ...future.result
[08:29:13.493] }
[08:29:13.496] MultisessionFuture started
[08:29:13.496] - Launch lazy future ... done
[08:29:13.496] run() for ‘MultisessionFuture’ ... done
[08:29:13.538] receiveMessageFromWorker() for ClusterFuture ...
[08:29:13.538] - Validating connection of MultisessionFuture
[08:29:13.539] - received message: FutureResult
[08:29:13.539] - Received FutureResult
[08:29:13.539] - Erased future from FutureRegistry
[08:29:13.539] result() for ClusterFuture ...
[08:29:13.539] - result already collected: FutureResult
[08:29:13.539] result() for ClusterFuture ... done
[08:29:13.539] signalConditions() ...
[08:29:13.539]  - include = ‘immediateCondition’
[08:29:13.539]  - exclude = 
[08:29:13.540]  - resignal = FALSE
[08:29:13.540]  - Number of conditions: 1
[08:29:13.540] signalConditions() ... done
[08:29:13.540] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:13.540] A MultisessionFuture was resolved
[08:29:13.540] getGlobalsAndPackages() ...
[08:29:13.540] Searching for globals...
[08:29:13.541] - globals found: [2] ‘list’, ‘stop’
[08:29:13.541] Searching for globals ... DONE
[08:29:13.541] Resolving globals: FALSE
[08:29:13.541] 
[08:29:13.541] 
[08:29:13.541] getGlobalsAndPackages() ... DONE
[08:29:13.542] run() for ‘Future’ ...
[08:29:13.542] - state: ‘created’
[08:29:13.542] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:13.556] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:13.556] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:13.556]   - Field: ‘node’
[08:29:13.556]   - Field: ‘label’
[08:29:13.557]   - Field: ‘local’
[08:29:13.557]   - Field: ‘owner’
[08:29:13.557]   - Field: ‘envir’
[08:29:13.557]   - Field: ‘workers’
[08:29:13.557]   - Field: ‘packages’
[08:29:13.557]   - Field: ‘gc’
[08:29:13.557]   - Field: ‘conditions’
[08:29:13.557]   - Field: ‘persistent’
[08:29:13.557]   - Field: ‘expr’
[08:29:13.557]   - Field: ‘uuid’
[08:29:13.557]   - Field: ‘seed’
[08:29:13.557]   - Field: ‘version’
[08:29:13.558]   - Field: ‘result’
[08:29:13.558]   - Field: ‘asynchronous’
[08:29:13.558]   - Field: ‘calls’
[08:29:13.558]   - Field: ‘globals’
[08:29:13.558]   - Field: ‘stdout’
[08:29:13.558]   - Field: ‘earlySignal’
[08:29:13.558]   - Field: ‘lazy’
[08:29:13.558]   - Field: ‘state’
[08:29:13.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:13.558] - Launch lazy future ...
[08:29:13.559] Packages needed by the future expression (n = 0): <none>
[08:29:13.559] Packages needed by future strategies (n = 0): <none>
[08:29:13.559] {
[08:29:13.559]     {
[08:29:13.559]         {
[08:29:13.559]             ...future.startTime <- base::Sys.time()
[08:29:13.559]             {
[08:29:13.559]                 {
[08:29:13.559]                   {
[08:29:13.559]                     {
[08:29:13.559]                       base::local({
[08:29:13.559]                         has_future <- base::requireNamespace("future", 
[08:29:13.559]                           quietly = TRUE)
[08:29:13.559]                         if (has_future) {
[08:29:13.559]                           ns <- base::getNamespace("future")
[08:29:13.559]                           version <- ns[[".package"]][["version"]]
[08:29:13.559]                           if (is.null(version)) 
[08:29:13.559]                             version <- utils::packageVersion("future")
[08:29:13.559]                         }
[08:29:13.559]                         else {
[08:29:13.559]                           version <- NULL
[08:29:13.559]                         }
[08:29:13.559]                         if (!has_future || version < "1.8.0") {
[08:29:13.559]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:13.559]                             "", base::R.version$version.string), 
[08:29:13.559]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:13.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:13.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:13.559]                               "release", "version")], collapse = " "), 
[08:29:13.559]                             hostname = base::Sys.info()[["nodename"]])
[08:29:13.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:13.559]                             info)
[08:29:13.559]                           info <- base::paste(info, collapse = "; ")
[08:29:13.559]                           if (!has_future) {
[08:29:13.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:13.559]                               info)
[08:29:13.559]                           }
[08:29:13.559]                           else {
[08:29:13.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:13.559]                               info, version)
[08:29:13.559]                           }
[08:29:13.559]                           base::stop(msg)
[08:29:13.559]                         }
[08:29:13.559]                       })
[08:29:13.559]                     }
[08:29:13.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:13.559]                     base::options(mc.cores = 1L)
[08:29:13.559]                   }
[08:29:13.559]                   ...future.strategy.old <- future::plan("list")
[08:29:13.559]                   options(future.plan = NULL)
[08:29:13.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:13.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:13.559]                 }
[08:29:13.559]                 ...future.workdir <- getwd()
[08:29:13.559]             }
[08:29:13.559]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:13.559]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:13.559]         }
[08:29:13.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:13.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:13.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:13.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:13.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:13.559]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:13.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:13.559]             base::names(...future.oldOptions))
[08:29:13.559]     }
[08:29:13.559]     if (FALSE) {
[08:29:13.559]     }
[08:29:13.559]     else {
[08:29:13.559]         if (TRUE) {
[08:29:13.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:13.559]                 open = "w")
[08:29:13.559]         }
[08:29:13.559]         else {
[08:29:13.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:13.559]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:13.559]         }
[08:29:13.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:13.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:13.559]             base::sink(type = "output", split = FALSE)
[08:29:13.559]             base::close(...future.stdout)
[08:29:13.559]         }, add = TRUE)
[08:29:13.559]     }
[08:29:13.559]     ...future.frame <- base::sys.nframe()
[08:29:13.559]     ...future.conditions <- base::list()
[08:29:13.559]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:13.559]     if (FALSE) {
[08:29:13.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:13.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:13.559]     }
[08:29:13.559]     ...future.result <- base::tryCatch({
[08:29:13.559]         base::withCallingHandlers({
[08:29:13.559]             ...future.value <- base::withVisible(base::local({
[08:29:13.559]                 ...future.makeSendCondition <- base::local({
[08:29:13.559]                   sendCondition <- NULL
[08:29:13.559]                   function(frame = 1L) {
[08:29:13.559]                     if (is.function(sendCondition)) 
[08:29:13.559]                       return(sendCondition)
[08:29:13.559]                     ns <- getNamespace("parallel")
[08:29:13.559]                     if (exists("sendData", mode = "function", 
[08:29:13.559]                       envir = ns)) {
[08:29:13.559]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:13.559]                         envir = ns)
[08:29:13.559]                       envir <- sys.frame(frame)
[08:29:13.559]                       master <- NULL
[08:29:13.559]                       while (!identical(envir, .GlobalEnv) && 
[08:29:13.559]                         !identical(envir, emptyenv())) {
[08:29:13.559]                         if (exists("master", mode = "list", envir = envir, 
[08:29:13.559]                           inherits = FALSE)) {
[08:29:13.559]                           master <- get("master", mode = "list", 
[08:29:13.559]                             envir = envir, inherits = FALSE)
[08:29:13.559]                           if (inherits(master, c("SOCKnode", 
[08:29:13.559]                             "SOCK0node"))) {
[08:29:13.559]                             sendCondition <<- function(cond) {
[08:29:13.559]                               data <- list(type = "VALUE", value = cond, 
[08:29:13.559]                                 success = TRUE)
[08:29:13.559]                               parallel_sendData(master, data)
[08:29:13.559]                             }
[08:29:13.559]                             return(sendCondition)
[08:29:13.559]                           }
[08:29:13.559]                         }
[08:29:13.559]                         frame <- frame + 1L
[08:29:13.559]                         envir <- sys.frame(frame)
[08:29:13.559]                       }
[08:29:13.559]                     }
[08:29:13.559]                     sendCondition <<- function(cond) NULL
[08:29:13.559]                   }
[08:29:13.559]                 })
[08:29:13.559]                 withCallingHandlers({
[08:29:13.559]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:13.559]                 }, immediateCondition = function(cond) {
[08:29:13.559]                   sendCondition <- ...future.makeSendCondition()
[08:29:13.559]                   sendCondition(cond)
[08:29:13.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:13.559]                   {
[08:29:13.559]                     inherits <- base::inherits
[08:29:13.559]                     invokeRestart <- base::invokeRestart
[08:29:13.559]                     is.null <- base::is.null
[08:29:13.559]                     muffled <- FALSE
[08:29:13.559]                     if (inherits(cond, "message")) {
[08:29:13.559]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:13.559]                       if (muffled) 
[08:29:13.559]                         invokeRestart("muffleMessage")
[08:29:13.559]                     }
[08:29:13.559]                     else if (inherits(cond, "warning")) {
[08:29:13.559]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:13.559]                       if (muffled) 
[08:29:13.559]                         invokeRestart("muffleWarning")
[08:29:13.559]                     }
[08:29:13.559]                     else if (inherits(cond, "condition")) {
[08:29:13.559]                       if (!is.null(pattern)) {
[08:29:13.559]                         computeRestarts <- base::computeRestarts
[08:29:13.559]                         grepl <- base::grepl
[08:29:13.559]                         restarts <- computeRestarts(cond)
[08:29:13.559]                         for (restart in restarts) {
[08:29:13.559]                           name <- restart$name
[08:29:13.559]                           if (is.null(name)) 
[08:29:13.559]                             next
[08:29:13.559]                           if (!grepl(pattern, name)) 
[08:29:13.559]                             next
[08:29:13.559]                           invokeRestart(restart)
[08:29:13.559]                           muffled <- TRUE
[08:29:13.559]                           break
[08:29:13.559]                         }
[08:29:13.559]                       }
[08:29:13.559]                     }
[08:29:13.559]                     invisible(muffled)
[08:29:13.559]                   }
[08:29:13.559]                   muffleCondition(cond)
[08:29:13.559]                 })
[08:29:13.559]             }))
[08:29:13.559]             future::FutureResult(value = ...future.value$value, 
[08:29:13.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:13.559]                   ...future.rng), globalenv = if (FALSE) 
[08:29:13.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:13.559]                     ...future.globalenv.names))
[08:29:13.559]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:13.559]         }, condition = base::local({
[08:29:13.559]             c <- base::c
[08:29:13.559]             inherits <- base::inherits
[08:29:13.559]             invokeRestart <- base::invokeRestart
[08:29:13.559]             length <- base::length
[08:29:13.559]             list <- base::list
[08:29:13.559]             seq.int <- base::seq.int
[08:29:13.559]             signalCondition <- base::signalCondition
[08:29:13.559]             sys.calls <- base::sys.calls
[08:29:13.559]             `[[` <- base::`[[`
[08:29:13.559]             `+` <- base::`+`
[08:29:13.559]             `<<-` <- base::`<<-`
[08:29:13.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:13.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:13.559]                   3L)]
[08:29:13.559]             }
[08:29:13.559]             function(cond) {
[08:29:13.559]                 is_error <- inherits(cond, "error")
[08:29:13.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:13.559]                   NULL)
[08:29:13.559]                 if (is_error) {
[08:29:13.559]                   sessionInformation <- function() {
[08:29:13.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:13.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:13.559]                       search = base::search(), system = base::Sys.info())
[08:29:13.559]                   }
[08:29:13.559]                   ...future.conditions[[length(...future.conditions) + 
[08:29:13.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:13.559]                     cond$call), session = sessionInformation(), 
[08:29:13.559]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:13.559]                   signalCondition(cond)
[08:29:13.559]                 }
[08:29:13.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:13.559]                 "immediateCondition"))) {
[08:29:13.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:13.559]                   ...future.conditions[[length(...future.conditions) + 
[08:29:13.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:13.559]                   if (TRUE && !signal) {
[08:29:13.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:13.559]                     {
[08:29:13.559]                       inherits <- base::inherits
[08:29:13.559]                       invokeRestart <- base::invokeRestart
[08:29:13.559]                       is.null <- base::is.null
[08:29:13.559]                       muffled <- FALSE
[08:29:13.559]                       if (inherits(cond, "message")) {
[08:29:13.559]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:13.559]                         if (muffled) 
[08:29:13.559]                           invokeRestart("muffleMessage")
[08:29:13.559]                       }
[08:29:13.559]                       else if (inherits(cond, "warning")) {
[08:29:13.559]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:13.559]                         if (muffled) 
[08:29:13.559]                           invokeRestart("muffleWarning")
[08:29:13.559]                       }
[08:29:13.559]                       else if (inherits(cond, "condition")) {
[08:29:13.559]                         if (!is.null(pattern)) {
[08:29:13.559]                           computeRestarts <- base::computeRestarts
[08:29:13.559]                           grepl <- base::grepl
[08:29:13.559]                           restarts <- computeRestarts(cond)
[08:29:13.559]                           for (restart in restarts) {
[08:29:13.559]                             name <- restart$name
[08:29:13.559]                             if (is.null(name)) 
[08:29:13.559]                               next
[08:29:13.559]                             if (!grepl(pattern, name)) 
[08:29:13.559]                               next
[08:29:13.559]                             invokeRestart(restart)
[08:29:13.559]                             muffled <- TRUE
[08:29:13.559]                             break
[08:29:13.559]                           }
[08:29:13.559]                         }
[08:29:13.559]                       }
[08:29:13.559]                       invisible(muffled)
[08:29:13.559]                     }
[08:29:13.559]                     muffleCondition(cond, pattern = "^muffle")
[08:29:13.559]                   }
[08:29:13.559]                 }
[08:29:13.559]                 else {
[08:29:13.559]                   if (TRUE) {
[08:29:13.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:13.559]                     {
[08:29:13.559]                       inherits <- base::inherits
[08:29:13.559]                       invokeRestart <- base::invokeRestart
[08:29:13.559]                       is.null <- base::is.null
[08:29:13.559]                       muffled <- FALSE
[08:29:13.559]                       if (inherits(cond, "message")) {
[08:29:13.559]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:13.559]                         if (muffled) 
[08:29:13.559]                           invokeRestart("muffleMessage")
[08:29:13.559]                       }
[08:29:13.559]                       else if (inherits(cond, "warning")) {
[08:29:13.559]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:13.559]                         if (muffled) 
[08:29:13.559]                           invokeRestart("muffleWarning")
[08:29:13.559]                       }
[08:29:13.559]                       else if (inherits(cond, "condition")) {
[08:29:13.559]                         if (!is.null(pattern)) {
[08:29:13.559]                           computeRestarts <- base::computeRestarts
[08:29:13.559]                           grepl <- base::grepl
[08:29:13.559]                           restarts <- computeRestarts(cond)
[08:29:13.559]                           for (restart in restarts) {
[08:29:13.559]                             name <- restart$name
[08:29:13.559]                             if (is.null(name)) 
[08:29:13.559]                               next
[08:29:13.559]                             if (!grepl(pattern, name)) 
[08:29:13.559]                               next
[08:29:13.559]                             invokeRestart(restart)
[08:29:13.559]                             muffled <- TRUE
[08:29:13.559]                             break
[08:29:13.559]                           }
[08:29:13.559]                         }
[08:29:13.559]                       }
[08:29:13.559]                       invisible(muffled)
[08:29:13.559]                     }
[08:29:13.559]                     muffleCondition(cond, pattern = "^muffle")
[08:29:13.559]                   }
[08:29:13.559]                 }
[08:29:13.559]             }
[08:29:13.559]         }))
[08:29:13.559]     }, error = function(ex) {
[08:29:13.559]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:13.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:13.559]                 ...future.rng), started = ...future.startTime, 
[08:29:13.559]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:13.559]             version = "1.8"), class = "FutureResult")
[08:29:13.559]     }, finally = {
[08:29:13.559]         if (!identical(...future.workdir, getwd())) 
[08:29:13.559]             setwd(...future.workdir)
[08:29:13.559]         {
[08:29:13.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:13.559]                 ...future.oldOptions$nwarnings <- NULL
[08:29:13.559]             }
[08:29:13.559]             base::options(...future.oldOptions)
[08:29:13.559]             if (.Platform$OS.type == "windows") {
[08:29:13.559]                 old_names <- names(...future.oldEnvVars)
[08:29:13.559]                 envs <- base::Sys.getenv()
[08:29:13.559]                 names <- names(envs)
[08:29:13.559]                 common <- intersect(names, old_names)
[08:29:13.559]                 added <- setdiff(names, old_names)
[08:29:13.559]                 removed <- setdiff(old_names, names)
[08:29:13.559]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:13.559]                   envs[common]]
[08:29:13.559]                 NAMES <- toupper(changed)
[08:29:13.559]                 args <- list()
[08:29:13.559]                 for (kk in seq_along(NAMES)) {
[08:29:13.559]                   name <- changed[[kk]]
[08:29:13.559]                   NAME <- NAMES[[kk]]
[08:29:13.559]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:13.559]                     next
[08:29:13.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:13.559]                 }
[08:29:13.559]                 NAMES <- toupper(added)
[08:29:13.559]                 for (kk in seq_along(NAMES)) {
[08:29:13.559]                   name <- added[[kk]]
[08:29:13.559]                   NAME <- NAMES[[kk]]
[08:29:13.559]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:13.559]                     next
[08:29:13.559]                   args[[name]] <- ""
[08:29:13.559]                 }
[08:29:13.559]                 NAMES <- toupper(removed)
[08:29:13.559]                 for (kk in seq_along(NAMES)) {
[08:29:13.559]                   name <- removed[[kk]]
[08:29:13.559]                   NAME <- NAMES[[kk]]
[08:29:13.559]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:13.559]                     next
[08:29:13.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:13.559]                 }
[08:29:13.559]                 if (length(args) > 0) 
[08:29:13.559]                   base::do.call(base::Sys.setenv, args = args)
[08:29:13.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:13.559]             }
[08:29:13.559]             else {
[08:29:13.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:13.559]             }
[08:29:13.559]             {
[08:29:13.559]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:13.559]                   0L) {
[08:29:13.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:13.559]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:13.559]                   base::options(opts)
[08:29:13.559]                 }
[08:29:13.559]                 {
[08:29:13.559]                   {
[08:29:13.559]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:13.559]                     NULL
[08:29:13.559]                   }
[08:29:13.559]                   options(future.plan = NULL)
[08:29:13.559]                   if (is.na(NA_character_)) 
[08:29:13.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:13.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:13.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:13.559]                     .init = FALSE)
[08:29:13.559]                 }
[08:29:13.559]             }
[08:29:13.559]         }
[08:29:13.559]     })
[08:29:13.559]     if (TRUE) {
[08:29:13.559]         base::sink(type = "output", split = FALSE)
[08:29:13.559]         if (TRUE) {
[08:29:13.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:13.559]         }
[08:29:13.559]         else {
[08:29:13.559]             ...future.result["stdout"] <- base::list(NULL)
[08:29:13.559]         }
[08:29:13.559]         base::close(...future.stdout)
[08:29:13.559]         ...future.stdout <- NULL
[08:29:13.559]     }
[08:29:13.559]     ...future.result$conditions <- ...future.conditions
[08:29:13.559]     ...future.result$finished <- base::Sys.time()
[08:29:13.559]     ...future.result
[08:29:13.559] }
[08:29:13.562] MultisessionFuture started
[08:29:13.562] - Launch lazy future ... done
[08:29:13.564] run() for ‘MultisessionFuture’ ... done
[08:29:13.606] receiveMessageFromWorker() for ClusterFuture ...
[08:29:13.606] - Validating connection of MultisessionFuture
[08:29:13.607] - received message: FutureResult
[08:29:13.607] - Received FutureResult
[08:29:13.607] - Erased future from FutureRegistry
[08:29:13.607] result() for ClusterFuture ...
[08:29:13.607] - result already collected: FutureResult
[08:29:13.607] result() for ClusterFuture ... done
[08:29:13.607] signalConditions() ...
[08:29:13.607]  - include = ‘immediateCondition’
[08:29:13.607]  - exclude = 
[08:29:13.608]  - resignal = FALSE
[08:29:13.608]  - Number of conditions: 1
[08:29:13.608] signalConditions() ... done
[08:29:13.608] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:13.608] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[08:29:13.608] getGlobalsAndPackages() ...
[08:29:13.608] Searching for globals...
[08:29:13.609] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:13.609] Searching for globals ... DONE
[08:29:13.609] Resolving globals: FALSE
[08:29:13.610] 
[08:29:13.610] 
[08:29:13.610] getGlobalsAndPackages() ... DONE
[08:29:13.610] run() for ‘Future’ ...
[08:29:13.610] - state: ‘created’
[08:29:13.610] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:13.624] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:13.624] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:13.624]   - Field: ‘node’
[08:29:13.624]   - Field: ‘label’
[08:29:13.624]   - Field: ‘local’
[08:29:13.624]   - Field: ‘owner’
[08:29:13.625]   - Field: ‘envir’
[08:29:13.625]   - Field: ‘workers’
[08:29:13.625]   - Field: ‘packages’
[08:29:13.625]   - Field: ‘gc’
[08:29:13.625]   - Field: ‘conditions’
[08:29:13.625]   - Field: ‘persistent’
[08:29:13.625]   - Field: ‘expr’
[08:29:13.625]   - Field: ‘uuid’
[08:29:13.625]   - Field: ‘seed’
[08:29:13.625]   - Field: ‘version’
[08:29:13.625]   - Field: ‘result’
[08:29:13.625]   - Field: ‘asynchronous’
[08:29:13.626]   - Field: ‘calls’
[08:29:13.626]   - Field: ‘globals’
[08:29:13.626]   - Field: ‘stdout’
[08:29:13.626]   - Field: ‘earlySignal’
[08:29:13.626]   - Field: ‘lazy’
[08:29:13.626]   - Field: ‘state’
[08:29:13.626] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:13.626] - Launch lazy future ...
[08:29:13.626] Packages needed by the future expression (n = 0): <none>
[08:29:13.626] Packages needed by future strategies (n = 0): <none>
[08:29:13.627] {
[08:29:13.627]     {
[08:29:13.627]         {
[08:29:13.627]             ...future.startTime <- base::Sys.time()
[08:29:13.627]             {
[08:29:13.627]                 {
[08:29:13.627]                   {
[08:29:13.627]                     {
[08:29:13.627]                       base::local({
[08:29:13.627]                         has_future <- base::requireNamespace("future", 
[08:29:13.627]                           quietly = TRUE)
[08:29:13.627]                         if (has_future) {
[08:29:13.627]                           ns <- base::getNamespace("future")
[08:29:13.627]                           version <- ns[[".package"]][["version"]]
[08:29:13.627]                           if (is.null(version)) 
[08:29:13.627]                             version <- utils::packageVersion("future")
[08:29:13.627]                         }
[08:29:13.627]                         else {
[08:29:13.627]                           version <- NULL
[08:29:13.627]                         }
[08:29:13.627]                         if (!has_future || version < "1.8.0") {
[08:29:13.627]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:13.627]                             "", base::R.version$version.string), 
[08:29:13.627]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:13.627]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:13.627]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:13.627]                               "release", "version")], collapse = " "), 
[08:29:13.627]                             hostname = base::Sys.info()[["nodename"]])
[08:29:13.627]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:13.627]                             info)
[08:29:13.627]                           info <- base::paste(info, collapse = "; ")
[08:29:13.627]                           if (!has_future) {
[08:29:13.627]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:13.627]                               info)
[08:29:13.627]                           }
[08:29:13.627]                           else {
[08:29:13.627]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:13.627]                               info, version)
[08:29:13.627]                           }
[08:29:13.627]                           base::stop(msg)
[08:29:13.627]                         }
[08:29:13.627]                       })
[08:29:13.627]                     }
[08:29:13.627]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:13.627]                     base::options(mc.cores = 1L)
[08:29:13.627]                   }
[08:29:13.627]                   ...future.strategy.old <- future::plan("list")
[08:29:13.627]                   options(future.plan = NULL)
[08:29:13.627]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:13.627]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:13.627]                 }
[08:29:13.627]                 ...future.workdir <- getwd()
[08:29:13.627]             }
[08:29:13.627]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:13.627]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:13.627]         }
[08:29:13.627]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:13.627]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:13.627]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:13.627]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:13.627]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:13.627]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:13.627]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:13.627]             base::names(...future.oldOptions))
[08:29:13.627]     }
[08:29:13.627]     if (FALSE) {
[08:29:13.627]     }
[08:29:13.627]     else {
[08:29:13.627]         if (TRUE) {
[08:29:13.627]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:13.627]                 open = "w")
[08:29:13.627]         }
[08:29:13.627]         else {
[08:29:13.627]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:13.627]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:13.627]         }
[08:29:13.627]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:13.627]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:13.627]             base::sink(type = "output", split = FALSE)
[08:29:13.627]             base::close(...future.stdout)
[08:29:13.627]         }, add = TRUE)
[08:29:13.627]     }
[08:29:13.627]     ...future.frame <- base::sys.nframe()
[08:29:13.627]     ...future.conditions <- base::list()
[08:29:13.627]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:13.627]     if (FALSE) {
[08:29:13.627]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:13.627]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:13.627]     }
[08:29:13.627]     ...future.result <- base::tryCatch({
[08:29:13.627]         base::withCallingHandlers({
[08:29:13.627]             ...future.value <- base::withVisible(base::local({
[08:29:13.627]                 ...future.makeSendCondition <- base::local({
[08:29:13.627]                   sendCondition <- NULL
[08:29:13.627]                   function(frame = 1L) {
[08:29:13.627]                     if (is.function(sendCondition)) 
[08:29:13.627]                       return(sendCondition)
[08:29:13.627]                     ns <- getNamespace("parallel")
[08:29:13.627]                     if (exists("sendData", mode = "function", 
[08:29:13.627]                       envir = ns)) {
[08:29:13.627]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:13.627]                         envir = ns)
[08:29:13.627]                       envir <- sys.frame(frame)
[08:29:13.627]                       master <- NULL
[08:29:13.627]                       while (!identical(envir, .GlobalEnv) && 
[08:29:13.627]                         !identical(envir, emptyenv())) {
[08:29:13.627]                         if (exists("master", mode = "list", envir = envir, 
[08:29:13.627]                           inherits = FALSE)) {
[08:29:13.627]                           master <- get("master", mode = "list", 
[08:29:13.627]                             envir = envir, inherits = FALSE)
[08:29:13.627]                           if (inherits(master, c("SOCKnode", 
[08:29:13.627]                             "SOCK0node"))) {
[08:29:13.627]                             sendCondition <<- function(cond) {
[08:29:13.627]                               data <- list(type = "VALUE", value = cond, 
[08:29:13.627]                                 success = TRUE)
[08:29:13.627]                               parallel_sendData(master, data)
[08:29:13.627]                             }
[08:29:13.627]                             return(sendCondition)
[08:29:13.627]                           }
[08:29:13.627]                         }
[08:29:13.627]                         frame <- frame + 1L
[08:29:13.627]                         envir <- sys.frame(frame)
[08:29:13.627]                       }
[08:29:13.627]                     }
[08:29:13.627]                     sendCondition <<- function(cond) NULL
[08:29:13.627]                   }
[08:29:13.627]                 })
[08:29:13.627]                 withCallingHandlers({
[08:29:13.627]                   {
[08:29:13.627]                     Sys.sleep(0.5)
[08:29:13.627]                     list(a = 1, b = 42L)
[08:29:13.627]                   }
[08:29:13.627]                 }, immediateCondition = function(cond) {
[08:29:13.627]                   sendCondition <- ...future.makeSendCondition()
[08:29:13.627]                   sendCondition(cond)
[08:29:13.627]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:13.627]                   {
[08:29:13.627]                     inherits <- base::inherits
[08:29:13.627]                     invokeRestart <- base::invokeRestart
[08:29:13.627]                     is.null <- base::is.null
[08:29:13.627]                     muffled <- FALSE
[08:29:13.627]                     if (inherits(cond, "message")) {
[08:29:13.627]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:13.627]                       if (muffled) 
[08:29:13.627]                         invokeRestart("muffleMessage")
[08:29:13.627]                     }
[08:29:13.627]                     else if (inherits(cond, "warning")) {
[08:29:13.627]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:13.627]                       if (muffled) 
[08:29:13.627]                         invokeRestart("muffleWarning")
[08:29:13.627]                     }
[08:29:13.627]                     else if (inherits(cond, "condition")) {
[08:29:13.627]                       if (!is.null(pattern)) {
[08:29:13.627]                         computeRestarts <- base::computeRestarts
[08:29:13.627]                         grepl <- base::grepl
[08:29:13.627]                         restarts <- computeRestarts(cond)
[08:29:13.627]                         for (restart in restarts) {
[08:29:13.627]                           name <- restart$name
[08:29:13.627]                           if (is.null(name)) 
[08:29:13.627]                             next
[08:29:13.627]                           if (!grepl(pattern, name)) 
[08:29:13.627]                             next
[08:29:13.627]                           invokeRestart(restart)
[08:29:13.627]                           muffled <- TRUE
[08:29:13.627]                           break
[08:29:13.627]                         }
[08:29:13.627]                       }
[08:29:13.627]                     }
[08:29:13.627]                     invisible(muffled)
[08:29:13.627]                   }
[08:29:13.627]                   muffleCondition(cond)
[08:29:13.627]                 })
[08:29:13.627]             }))
[08:29:13.627]             future::FutureResult(value = ...future.value$value, 
[08:29:13.627]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:13.627]                   ...future.rng), globalenv = if (FALSE) 
[08:29:13.627]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:13.627]                     ...future.globalenv.names))
[08:29:13.627]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:13.627]         }, condition = base::local({
[08:29:13.627]             c <- base::c
[08:29:13.627]             inherits <- base::inherits
[08:29:13.627]             invokeRestart <- base::invokeRestart
[08:29:13.627]             length <- base::length
[08:29:13.627]             list <- base::list
[08:29:13.627]             seq.int <- base::seq.int
[08:29:13.627]             signalCondition <- base::signalCondition
[08:29:13.627]             sys.calls <- base::sys.calls
[08:29:13.627]             `[[` <- base::`[[`
[08:29:13.627]             `+` <- base::`+`
[08:29:13.627]             `<<-` <- base::`<<-`
[08:29:13.627]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:13.627]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:13.627]                   3L)]
[08:29:13.627]             }
[08:29:13.627]             function(cond) {
[08:29:13.627]                 is_error <- inherits(cond, "error")
[08:29:13.627]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:13.627]                   NULL)
[08:29:13.627]                 if (is_error) {
[08:29:13.627]                   sessionInformation <- function() {
[08:29:13.627]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:13.627]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:13.627]                       search = base::search(), system = base::Sys.info())
[08:29:13.627]                   }
[08:29:13.627]                   ...future.conditions[[length(...future.conditions) + 
[08:29:13.627]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:13.627]                     cond$call), session = sessionInformation(), 
[08:29:13.627]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:13.627]                   signalCondition(cond)
[08:29:13.627]                 }
[08:29:13.627]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:13.627]                 "immediateCondition"))) {
[08:29:13.627]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:13.627]                   ...future.conditions[[length(...future.conditions) + 
[08:29:13.627]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:13.627]                   if (TRUE && !signal) {
[08:29:13.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:13.627]                     {
[08:29:13.627]                       inherits <- base::inherits
[08:29:13.627]                       invokeRestart <- base::invokeRestart
[08:29:13.627]                       is.null <- base::is.null
[08:29:13.627]                       muffled <- FALSE
[08:29:13.627]                       if (inherits(cond, "message")) {
[08:29:13.627]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:13.627]                         if (muffled) 
[08:29:13.627]                           invokeRestart("muffleMessage")
[08:29:13.627]                       }
[08:29:13.627]                       else if (inherits(cond, "warning")) {
[08:29:13.627]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:13.627]                         if (muffled) 
[08:29:13.627]                           invokeRestart("muffleWarning")
[08:29:13.627]                       }
[08:29:13.627]                       else if (inherits(cond, "condition")) {
[08:29:13.627]                         if (!is.null(pattern)) {
[08:29:13.627]                           computeRestarts <- base::computeRestarts
[08:29:13.627]                           grepl <- base::grepl
[08:29:13.627]                           restarts <- computeRestarts(cond)
[08:29:13.627]                           for (restart in restarts) {
[08:29:13.627]                             name <- restart$name
[08:29:13.627]                             if (is.null(name)) 
[08:29:13.627]                               next
[08:29:13.627]                             if (!grepl(pattern, name)) 
[08:29:13.627]                               next
[08:29:13.627]                             invokeRestart(restart)
[08:29:13.627]                             muffled <- TRUE
[08:29:13.627]                             break
[08:29:13.627]                           }
[08:29:13.627]                         }
[08:29:13.627]                       }
[08:29:13.627]                       invisible(muffled)
[08:29:13.627]                     }
[08:29:13.627]                     muffleCondition(cond, pattern = "^muffle")
[08:29:13.627]                   }
[08:29:13.627]                 }
[08:29:13.627]                 else {
[08:29:13.627]                   if (TRUE) {
[08:29:13.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:13.627]                     {
[08:29:13.627]                       inherits <- base::inherits
[08:29:13.627]                       invokeRestart <- base::invokeRestart
[08:29:13.627]                       is.null <- base::is.null
[08:29:13.627]                       muffled <- FALSE
[08:29:13.627]                       if (inherits(cond, "message")) {
[08:29:13.627]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:13.627]                         if (muffled) 
[08:29:13.627]                           invokeRestart("muffleMessage")
[08:29:13.627]                       }
[08:29:13.627]                       else if (inherits(cond, "warning")) {
[08:29:13.627]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:13.627]                         if (muffled) 
[08:29:13.627]                           invokeRestart("muffleWarning")
[08:29:13.627]                       }
[08:29:13.627]                       else if (inherits(cond, "condition")) {
[08:29:13.627]                         if (!is.null(pattern)) {
[08:29:13.627]                           computeRestarts <- base::computeRestarts
[08:29:13.627]                           grepl <- base::grepl
[08:29:13.627]                           restarts <- computeRestarts(cond)
[08:29:13.627]                           for (restart in restarts) {
[08:29:13.627]                             name <- restart$name
[08:29:13.627]                             if (is.null(name)) 
[08:29:13.627]                               next
[08:29:13.627]                             if (!grepl(pattern, name)) 
[08:29:13.627]                               next
[08:29:13.627]                             invokeRestart(restart)
[08:29:13.627]                             muffled <- TRUE
[08:29:13.627]                             break
[08:29:13.627]                           }
[08:29:13.627]                         }
[08:29:13.627]                       }
[08:29:13.627]                       invisible(muffled)
[08:29:13.627]                     }
[08:29:13.627]                     muffleCondition(cond, pattern = "^muffle")
[08:29:13.627]                   }
[08:29:13.627]                 }
[08:29:13.627]             }
[08:29:13.627]         }))
[08:29:13.627]     }, error = function(ex) {
[08:29:13.627]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:13.627]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:13.627]                 ...future.rng), started = ...future.startTime, 
[08:29:13.627]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:13.627]             version = "1.8"), class = "FutureResult")
[08:29:13.627]     }, finally = {
[08:29:13.627]         if (!identical(...future.workdir, getwd())) 
[08:29:13.627]             setwd(...future.workdir)
[08:29:13.627]         {
[08:29:13.627]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:13.627]                 ...future.oldOptions$nwarnings <- NULL
[08:29:13.627]             }
[08:29:13.627]             base::options(...future.oldOptions)
[08:29:13.627]             if (.Platform$OS.type == "windows") {
[08:29:13.627]                 old_names <- names(...future.oldEnvVars)
[08:29:13.627]                 envs <- base::Sys.getenv()
[08:29:13.627]                 names <- names(envs)
[08:29:13.627]                 common <- intersect(names, old_names)
[08:29:13.627]                 added <- setdiff(names, old_names)
[08:29:13.627]                 removed <- setdiff(old_names, names)
[08:29:13.627]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:13.627]                   envs[common]]
[08:29:13.627]                 NAMES <- toupper(changed)
[08:29:13.627]                 args <- list()
[08:29:13.627]                 for (kk in seq_along(NAMES)) {
[08:29:13.627]                   name <- changed[[kk]]
[08:29:13.627]                   NAME <- NAMES[[kk]]
[08:29:13.627]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:13.627]                     next
[08:29:13.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:13.627]                 }
[08:29:13.627]                 NAMES <- toupper(added)
[08:29:13.627]                 for (kk in seq_along(NAMES)) {
[08:29:13.627]                   name <- added[[kk]]
[08:29:13.627]                   NAME <- NAMES[[kk]]
[08:29:13.627]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:13.627]                     next
[08:29:13.627]                   args[[name]] <- ""
[08:29:13.627]                 }
[08:29:13.627]                 NAMES <- toupper(removed)
[08:29:13.627]                 for (kk in seq_along(NAMES)) {
[08:29:13.627]                   name <- removed[[kk]]
[08:29:13.627]                   NAME <- NAMES[[kk]]
[08:29:13.627]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:13.627]                     next
[08:29:13.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:13.627]                 }
[08:29:13.627]                 if (length(args) > 0) 
[08:29:13.627]                   base::do.call(base::Sys.setenv, args = args)
[08:29:13.627]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:13.627]             }
[08:29:13.627]             else {
[08:29:13.627]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:13.627]             }
[08:29:13.627]             {
[08:29:13.627]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:13.627]                   0L) {
[08:29:13.627]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:13.627]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:13.627]                   base::options(opts)
[08:29:13.627]                 }
[08:29:13.627]                 {
[08:29:13.627]                   {
[08:29:13.627]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:13.627]                     NULL
[08:29:13.627]                   }
[08:29:13.627]                   options(future.plan = NULL)
[08:29:13.627]                   if (is.na(NA_character_)) 
[08:29:13.627]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:13.627]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:13.627]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:13.627]                     .init = FALSE)
[08:29:13.627]                 }
[08:29:13.627]             }
[08:29:13.627]         }
[08:29:13.627]     })
[08:29:13.627]     if (TRUE) {
[08:29:13.627]         base::sink(type = "output", split = FALSE)
[08:29:13.627]         if (TRUE) {
[08:29:13.627]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:13.627]         }
[08:29:13.627]         else {
[08:29:13.627]             ...future.result["stdout"] <- base::list(NULL)
[08:29:13.627]         }
[08:29:13.627]         base::close(...future.stdout)
[08:29:13.627]         ...future.stdout <- NULL
[08:29:13.627]     }
[08:29:13.627]     ...future.result$conditions <- ...future.conditions
[08:29:13.627]     ...future.result$finished <- base::Sys.time()
[08:29:13.627]     ...future.result
[08:29:13.627] }
[08:29:13.630] MultisessionFuture started
[08:29:13.630] - Launch lazy future ... done
[08:29:13.630] run() for ‘MultisessionFuture’ ... done
[08:29:14.173] receiveMessageFromWorker() for ClusterFuture ...
[08:29:14.173] - Validating connection of MultisessionFuture
[08:29:14.173] - received message: FutureResult
[08:29:14.173] - Received FutureResult
[08:29:14.174] - Erased future from FutureRegistry
[08:29:14.174] result() for ClusterFuture ...
[08:29:14.174] - result already collected: FutureResult
[08:29:14.174] result() for ClusterFuture ... done
[08:29:14.174] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:14.174] resolve() on list ...
[08:29:14.174]  recursive: 98
[08:29:14.174]  length: 2
[08:29:14.174]  elements: ‘a’, ‘b’
[08:29:14.174]  length: 1 (resolved future 1)
[08:29:14.175]  length: 0 (resolved future 2)
[08:29:14.175] resolve() on list ... DONE
[08:29:14.175] A MultisessionFuture was resolved (and resolved itself)
[08:29:14.175] getGlobalsAndPackages() ...
[08:29:14.175] Searching for globals...
[08:29:14.176] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:14.176] Searching for globals ... DONE
[08:29:14.176] Resolving globals: FALSE
[08:29:14.177] 
[08:29:14.177] 
[08:29:14.177] getGlobalsAndPackages() ... DONE
[08:29:14.177] run() for ‘Future’ ...
[08:29:14.177] - state: ‘created’
[08:29:14.177] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:14.192] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:14.192] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:14.192]   - Field: ‘node’
[08:29:14.192]   - Field: ‘label’
[08:29:14.192]   - Field: ‘local’
[08:29:14.192]   - Field: ‘owner’
[08:29:14.193]   - Field: ‘envir’
[08:29:14.193]   - Field: ‘workers’
[08:29:14.193]   - Field: ‘packages’
[08:29:14.193]   - Field: ‘gc’
[08:29:14.193]   - Field: ‘conditions’
[08:29:14.193]   - Field: ‘persistent’
[08:29:14.193]   - Field: ‘expr’
[08:29:14.193]   - Field: ‘uuid’
[08:29:14.193]   - Field: ‘seed’
[08:29:14.193]   - Field: ‘version’
[08:29:14.193]   - Field: ‘result’
[08:29:14.193]   - Field: ‘asynchronous’
[08:29:14.194]   - Field: ‘calls’
[08:29:14.194]   - Field: ‘globals’
[08:29:14.194]   - Field: ‘stdout’
[08:29:14.194]   - Field: ‘earlySignal’
[08:29:14.194]   - Field: ‘lazy’
[08:29:14.194]   - Field: ‘state’
[08:29:14.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:14.194] - Launch lazy future ...
[08:29:14.194] Packages needed by the future expression (n = 0): <none>
[08:29:14.195] Packages needed by future strategies (n = 0): <none>
[08:29:14.195] {
[08:29:14.195]     {
[08:29:14.195]         {
[08:29:14.195]             ...future.startTime <- base::Sys.time()
[08:29:14.195]             {
[08:29:14.195]                 {
[08:29:14.195]                   {
[08:29:14.195]                     {
[08:29:14.195]                       base::local({
[08:29:14.195]                         has_future <- base::requireNamespace("future", 
[08:29:14.195]                           quietly = TRUE)
[08:29:14.195]                         if (has_future) {
[08:29:14.195]                           ns <- base::getNamespace("future")
[08:29:14.195]                           version <- ns[[".package"]][["version"]]
[08:29:14.195]                           if (is.null(version)) 
[08:29:14.195]                             version <- utils::packageVersion("future")
[08:29:14.195]                         }
[08:29:14.195]                         else {
[08:29:14.195]                           version <- NULL
[08:29:14.195]                         }
[08:29:14.195]                         if (!has_future || version < "1.8.0") {
[08:29:14.195]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:14.195]                             "", base::R.version$version.string), 
[08:29:14.195]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:14.195]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:14.195]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:14.195]                               "release", "version")], collapse = " "), 
[08:29:14.195]                             hostname = base::Sys.info()[["nodename"]])
[08:29:14.195]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:14.195]                             info)
[08:29:14.195]                           info <- base::paste(info, collapse = "; ")
[08:29:14.195]                           if (!has_future) {
[08:29:14.195]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:14.195]                               info)
[08:29:14.195]                           }
[08:29:14.195]                           else {
[08:29:14.195]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:14.195]                               info, version)
[08:29:14.195]                           }
[08:29:14.195]                           base::stop(msg)
[08:29:14.195]                         }
[08:29:14.195]                       })
[08:29:14.195]                     }
[08:29:14.195]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:14.195]                     base::options(mc.cores = 1L)
[08:29:14.195]                   }
[08:29:14.195]                   ...future.strategy.old <- future::plan("list")
[08:29:14.195]                   options(future.plan = NULL)
[08:29:14.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:14.195]                 }
[08:29:14.195]                 ...future.workdir <- getwd()
[08:29:14.195]             }
[08:29:14.195]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:14.195]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:14.195]         }
[08:29:14.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:14.195]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:14.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:14.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:14.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:14.195]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:14.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:14.195]             base::names(...future.oldOptions))
[08:29:14.195]     }
[08:29:14.195]     if (FALSE) {
[08:29:14.195]     }
[08:29:14.195]     else {
[08:29:14.195]         if (TRUE) {
[08:29:14.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:14.195]                 open = "w")
[08:29:14.195]         }
[08:29:14.195]         else {
[08:29:14.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:14.195]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:14.195]         }
[08:29:14.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:14.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:14.195]             base::sink(type = "output", split = FALSE)
[08:29:14.195]             base::close(...future.stdout)
[08:29:14.195]         }, add = TRUE)
[08:29:14.195]     }
[08:29:14.195]     ...future.frame <- base::sys.nframe()
[08:29:14.195]     ...future.conditions <- base::list()
[08:29:14.195]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:14.195]     if (FALSE) {
[08:29:14.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:14.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:14.195]     }
[08:29:14.195]     ...future.result <- base::tryCatch({
[08:29:14.195]         base::withCallingHandlers({
[08:29:14.195]             ...future.value <- base::withVisible(base::local({
[08:29:14.195]                 ...future.makeSendCondition <- base::local({
[08:29:14.195]                   sendCondition <- NULL
[08:29:14.195]                   function(frame = 1L) {
[08:29:14.195]                     if (is.function(sendCondition)) 
[08:29:14.195]                       return(sendCondition)
[08:29:14.195]                     ns <- getNamespace("parallel")
[08:29:14.195]                     if (exists("sendData", mode = "function", 
[08:29:14.195]                       envir = ns)) {
[08:29:14.195]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:14.195]                         envir = ns)
[08:29:14.195]                       envir <- sys.frame(frame)
[08:29:14.195]                       master <- NULL
[08:29:14.195]                       while (!identical(envir, .GlobalEnv) && 
[08:29:14.195]                         !identical(envir, emptyenv())) {
[08:29:14.195]                         if (exists("master", mode = "list", envir = envir, 
[08:29:14.195]                           inherits = FALSE)) {
[08:29:14.195]                           master <- get("master", mode = "list", 
[08:29:14.195]                             envir = envir, inherits = FALSE)
[08:29:14.195]                           if (inherits(master, c("SOCKnode", 
[08:29:14.195]                             "SOCK0node"))) {
[08:29:14.195]                             sendCondition <<- function(cond) {
[08:29:14.195]                               data <- list(type = "VALUE", value = cond, 
[08:29:14.195]                                 success = TRUE)
[08:29:14.195]                               parallel_sendData(master, data)
[08:29:14.195]                             }
[08:29:14.195]                             return(sendCondition)
[08:29:14.195]                           }
[08:29:14.195]                         }
[08:29:14.195]                         frame <- frame + 1L
[08:29:14.195]                         envir <- sys.frame(frame)
[08:29:14.195]                       }
[08:29:14.195]                     }
[08:29:14.195]                     sendCondition <<- function(cond) NULL
[08:29:14.195]                   }
[08:29:14.195]                 })
[08:29:14.195]                 withCallingHandlers({
[08:29:14.195]                   {
[08:29:14.195]                     Sys.sleep(0.5)
[08:29:14.195]                     list(a = 1, b = 42L)
[08:29:14.195]                   }
[08:29:14.195]                 }, immediateCondition = function(cond) {
[08:29:14.195]                   sendCondition <- ...future.makeSendCondition()
[08:29:14.195]                   sendCondition(cond)
[08:29:14.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.195]                   {
[08:29:14.195]                     inherits <- base::inherits
[08:29:14.195]                     invokeRestart <- base::invokeRestart
[08:29:14.195]                     is.null <- base::is.null
[08:29:14.195]                     muffled <- FALSE
[08:29:14.195]                     if (inherits(cond, "message")) {
[08:29:14.195]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:14.195]                       if (muffled) 
[08:29:14.195]                         invokeRestart("muffleMessage")
[08:29:14.195]                     }
[08:29:14.195]                     else if (inherits(cond, "warning")) {
[08:29:14.195]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:14.195]                       if (muffled) 
[08:29:14.195]                         invokeRestart("muffleWarning")
[08:29:14.195]                     }
[08:29:14.195]                     else if (inherits(cond, "condition")) {
[08:29:14.195]                       if (!is.null(pattern)) {
[08:29:14.195]                         computeRestarts <- base::computeRestarts
[08:29:14.195]                         grepl <- base::grepl
[08:29:14.195]                         restarts <- computeRestarts(cond)
[08:29:14.195]                         for (restart in restarts) {
[08:29:14.195]                           name <- restart$name
[08:29:14.195]                           if (is.null(name)) 
[08:29:14.195]                             next
[08:29:14.195]                           if (!grepl(pattern, name)) 
[08:29:14.195]                             next
[08:29:14.195]                           invokeRestart(restart)
[08:29:14.195]                           muffled <- TRUE
[08:29:14.195]                           break
[08:29:14.195]                         }
[08:29:14.195]                       }
[08:29:14.195]                     }
[08:29:14.195]                     invisible(muffled)
[08:29:14.195]                   }
[08:29:14.195]                   muffleCondition(cond)
[08:29:14.195]                 })
[08:29:14.195]             }))
[08:29:14.195]             future::FutureResult(value = ...future.value$value, 
[08:29:14.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.195]                   ...future.rng), globalenv = if (FALSE) 
[08:29:14.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:14.195]                     ...future.globalenv.names))
[08:29:14.195]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:14.195]         }, condition = base::local({
[08:29:14.195]             c <- base::c
[08:29:14.195]             inherits <- base::inherits
[08:29:14.195]             invokeRestart <- base::invokeRestart
[08:29:14.195]             length <- base::length
[08:29:14.195]             list <- base::list
[08:29:14.195]             seq.int <- base::seq.int
[08:29:14.195]             signalCondition <- base::signalCondition
[08:29:14.195]             sys.calls <- base::sys.calls
[08:29:14.195]             `[[` <- base::`[[`
[08:29:14.195]             `+` <- base::`+`
[08:29:14.195]             `<<-` <- base::`<<-`
[08:29:14.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:14.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:14.195]                   3L)]
[08:29:14.195]             }
[08:29:14.195]             function(cond) {
[08:29:14.195]                 is_error <- inherits(cond, "error")
[08:29:14.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:14.195]                   NULL)
[08:29:14.195]                 if (is_error) {
[08:29:14.195]                   sessionInformation <- function() {
[08:29:14.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:14.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:14.195]                       search = base::search(), system = base::Sys.info())
[08:29:14.195]                   }
[08:29:14.195]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:14.195]                     cond$call), session = sessionInformation(), 
[08:29:14.195]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:14.195]                   signalCondition(cond)
[08:29:14.195]                 }
[08:29:14.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:14.195]                 "immediateCondition"))) {
[08:29:14.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:14.195]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:14.195]                   if (TRUE && !signal) {
[08:29:14.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.195]                     {
[08:29:14.195]                       inherits <- base::inherits
[08:29:14.195]                       invokeRestart <- base::invokeRestart
[08:29:14.195]                       is.null <- base::is.null
[08:29:14.195]                       muffled <- FALSE
[08:29:14.195]                       if (inherits(cond, "message")) {
[08:29:14.195]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.195]                         if (muffled) 
[08:29:14.195]                           invokeRestart("muffleMessage")
[08:29:14.195]                       }
[08:29:14.195]                       else if (inherits(cond, "warning")) {
[08:29:14.195]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.195]                         if (muffled) 
[08:29:14.195]                           invokeRestart("muffleWarning")
[08:29:14.195]                       }
[08:29:14.195]                       else if (inherits(cond, "condition")) {
[08:29:14.195]                         if (!is.null(pattern)) {
[08:29:14.195]                           computeRestarts <- base::computeRestarts
[08:29:14.195]                           grepl <- base::grepl
[08:29:14.195]                           restarts <- computeRestarts(cond)
[08:29:14.195]                           for (restart in restarts) {
[08:29:14.195]                             name <- restart$name
[08:29:14.195]                             if (is.null(name)) 
[08:29:14.195]                               next
[08:29:14.195]                             if (!grepl(pattern, name)) 
[08:29:14.195]                               next
[08:29:14.195]                             invokeRestart(restart)
[08:29:14.195]                             muffled <- TRUE
[08:29:14.195]                             break
[08:29:14.195]                           }
[08:29:14.195]                         }
[08:29:14.195]                       }
[08:29:14.195]                       invisible(muffled)
[08:29:14.195]                     }
[08:29:14.195]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.195]                   }
[08:29:14.195]                 }
[08:29:14.195]                 else {
[08:29:14.195]                   if (TRUE) {
[08:29:14.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.195]                     {
[08:29:14.195]                       inherits <- base::inherits
[08:29:14.195]                       invokeRestart <- base::invokeRestart
[08:29:14.195]                       is.null <- base::is.null
[08:29:14.195]                       muffled <- FALSE
[08:29:14.195]                       if (inherits(cond, "message")) {
[08:29:14.195]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.195]                         if (muffled) 
[08:29:14.195]                           invokeRestart("muffleMessage")
[08:29:14.195]                       }
[08:29:14.195]                       else if (inherits(cond, "warning")) {
[08:29:14.195]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.195]                         if (muffled) 
[08:29:14.195]                           invokeRestart("muffleWarning")
[08:29:14.195]                       }
[08:29:14.195]                       else if (inherits(cond, "condition")) {
[08:29:14.195]                         if (!is.null(pattern)) {
[08:29:14.195]                           computeRestarts <- base::computeRestarts
[08:29:14.195]                           grepl <- base::grepl
[08:29:14.195]                           restarts <- computeRestarts(cond)
[08:29:14.195]                           for (restart in restarts) {
[08:29:14.195]                             name <- restart$name
[08:29:14.195]                             if (is.null(name)) 
[08:29:14.195]                               next
[08:29:14.195]                             if (!grepl(pattern, name)) 
[08:29:14.195]                               next
[08:29:14.195]                             invokeRestart(restart)
[08:29:14.195]                             muffled <- TRUE
[08:29:14.195]                             break
[08:29:14.195]                           }
[08:29:14.195]                         }
[08:29:14.195]                       }
[08:29:14.195]                       invisible(muffled)
[08:29:14.195]                     }
[08:29:14.195]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.195]                   }
[08:29:14.195]                 }
[08:29:14.195]             }
[08:29:14.195]         }))
[08:29:14.195]     }, error = function(ex) {
[08:29:14.195]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:14.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.195]                 ...future.rng), started = ...future.startTime, 
[08:29:14.195]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:14.195]             version = "1.8"), class = "FutureResult")
[08:29:14.195]     }, finally = {
[08:29:14.195]         if (!identical(...future.workdir, getwd())) 
[08:29:14.195]             setwd(...future.workdir)
[08:29:14.195]         {
[08:29:14.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:14.195]                 ...future.oldOptions$nwarnings <- NULL
[08:29:14.195]             }
[08:29:14.195]             base::options(...future.oldOptions)
[08:29:14.195]             if (.Platform$OS.type == "windows") {
[08:29:14.195]                 old_names <- names(...future.oldEnvVars)
[08:29:14.195]                 envs <- base::Sys.getenv()
[08:29:14.195]                 names <- names(envs)
[08:29:14.195]                 common <- intersect(names, old_names)
[08:29:14.195]                 added <- setdiff(names, old_names)
[08:29:14.195]                 removed <- setdiff(old_names, names)
[08:29:14.195]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:14.195]                   envs[common]]
[08:29:14.195]                 NAMES <- toupper(changed)
[08:29:14.195]                 args <- list()
[08:29:14.195]                 for (kk in seq_along(NAMES)) {
[08:29:14.195]                   name <- changed[[kk]]
[08:29:14.195]                   NAME <- NAMES[[kk]]
[08:29:14.195]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.195]                     next
[08:29:14.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.195]                 }
[08:29:14.195]                 NAMES <- toupper(added)
[08:29:14.195]                 for (kk in seq_along(NAMES)) {
[08:29:14.195]                   name <- added[[kk]]
[08:29:14.195]                   NAME <- NAMES[[kk]]
[08:29:14.195]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.195]                     next
[08:29:14.195]                   args[[name]] <- ""
[08:29:14.195]                 }
[08:29:14.195]                 NAMES <- toupper(removed)
[08:29:14.195]                 for (kk in seq_along(NAMES)) {
[08:29:14.195]                   name <- removed[[kk]]
[08:29:14.195]                   NAME <- NAMES[[kk]]
[08:29:14.195]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.195]                     next
[08:29:14.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.195]                 }
[08:29:14.195]                 if (length(args) > 0) 
[08:29:14.195]                   base::do.call(base::Sys.setenv, args = args)
[08:29:14.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:14.195]             }
[08:29:14.195]             else {
[08:29:14.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:14.195]             }
[08:29:14.195]             {
[08:29:14.195]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:14.195]                   0L) {
[08:29:14.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:14.195]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:14.195]                   base::options(opts)
[08:29:14.195]                 }
[08:29:14.195]                 {
[08:29:14.195]                   {
[08:29:14.195]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:14.195]                     NULL
[08:29:14.195]                   }
[08:29:14.195]                   options(future.plan = NULL)
[08:29:14.195]                   if (is.na(NA_character_)) 
[08:29:14.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:14.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:14.195]                     .init = FALSE)
[08:29:14.195]                 }
[08:29:14.195]             }
[08:29:14.195]         }
[08:29:14.195]     })
[08:29:14.195]     if (TRUE) {
[08:29:14.195]         base::sink(type = "output", split = FALSE)
[08:29:14.195]         if (TRUE) {
[08:29:14.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:14.195]         }
[08:29:14.195]         else {
[08:29:14.195]             ...future.result["stdout"] <- base::list(NULL)
[08:29:14.195]         }
[08:29:14.195]         base::close(...future.stdout)
[08:29:14.195]         ...future.stdout <- NULL
[08:29:14.195]     }
[08:29:14.195]     ...future.result$conditions <- ...future.conditions
[08:29:14.195]     ...future.result$finished <- base::Sys.time()
[08:29:14.195]     ...future.result
[08:29:14.195] }
[08:29:14.198] MultisessionFuture started
[08:29:14.198] - Launch lazy future ... done
[08:29:14.198] run() for ‘MultisessionFuture’ ... done
[08:29:14.741] receiveMessageFromWorker() for ClusterFuture ...
[08:29:14.741] - Validating connection of MultisessionFuture
[08:29:14.741] - received message: FutureResult
[08:29:14.742] - Received FutureResult
[08:29:14.742] - Erased future from FutureRegistry
[08:29:14.742] result() for ClusterFuture ...
[08:29:14.742] - result already collected: FutureResult
[08:29:14.742] result() for ClusterFuture ... done
[08:29:14.742] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:14.742] resolve() on list ...
[08:29:14.742]  recursive: 98
[08:29:14.742]  length: 2
[08:29:14.742]  elements: ‘a’, ‘b’
[08:29:14.743]  length: 1 (resolved future 1)
[08:29:14.743]  length: 0 (resolved future 2)
[08:29:14.743] resolve() on list ... DONE
[08:29:14.743] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[08:29:14.743] getGlobalsAndPackages() ...
[08:29:14.743] Searching for globals...
[08:29:14.744] - globals found: [2] ‘list’, ‘stop’
[08:29:14.744] Searching for globals ... DONE
[08:29:14.744] Resolving globals: FALSE
[08:29:14.744] 
[08:29:14.744] 
[08:29:14.744] getGlobalsAndPackages() ... DONE
[08:29:14.745] run() for ‘Future’ ...
[08:29:14.745] - state: ‘created’
[08:29:14.745] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:14.759] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:14.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:14.759]   - Field: ‘node’
[08:29:14.759]   - Field: ‘label’
[08:29:14.759]   - Field: ‘local’
[08:29:14.759]   - Field: ‘owner’
[08:29:14.759]   - Field: ‘envir’
[08:29:14.759]   - Field: ‘workers’
[08:29:14.759]   - Field: ‘packages’
[08:29:14.760]   - Field: ‘gc’
[08:29:14.760]   - Field: ‘conditions’
[08:29:14.760]   - Field: ‘persistent’
[08:29:14.760]   - Field: ‘expr’
[08:29:14.760]   - Field: ‘uuid’
[08:29:14.760]   - Field: ‘seed’
[08:29:14.760]   - Field: ‘version’
[08:29:14.760]   - Field: ‘result’
[08:29:14.760]   - Field: ‘asynchronous’
[08:29:14.760]   - Field: ‘calls’
[08:29:14.760]   - Field: ‘globals’
[08:29:14.760]   - Field: ‘stdout’
[08:29:14.761]   - Field: ‘earlySignal’
[08:29:14.761]   - Field: ‘lazy’
[08:29:14.761]   - Field: ‘state’
[08:29:14.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:14.761] - Launch lazy future ...
[08:29:14.761] Packages needed by the future expression (n = 0): <none>
[08:29:14.761] Packages needed by future strategies (n = 0): <none>
[08:29:14.762] {
[08:29:14.762]     {
[08:29:14.762]         {
[08:29:14.762]             ...future.startTime <- base::Sys.time()
[08:29:14.762]             {
[08:29:14.762]                 {
[08:29:14.762]                   {
[08:29:14.762]                     {
[08:29:14.762]                       base::local({
[08:29:14.762]                         has_future <- base::requireNamespace("future", 
[08:29:14.762]                           quietly = TRUE)
[08:29:14.762]                         if (has_future) {
[08:29:14.762]                           ns <- base::getNamespace("future")
[08:29:14.762]                           version <- ns[[".package"]][["version"]]
[08:29:14.762]                           if (is.null(version)) 
[08:29:14.762]                             version <- utils::packageVersion("future")
[08:29:14.762]                         }
[08:29:14.762]                         else {
[08:29:14.762]                           version <- NULL
[08:29:14.762]                         }
[08:29:14.762]                         if (!has_future || version < "1.8.0") {
[08:29:14.762]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:14.762]                             "", base::R.version$version.string), 
[08:29:14.762]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:14.762]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:14.762]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:14.762]                               "release", "version")], collapse = " "), 
[08:29:14.762]                             hostname = base::Sys.info()[["nodename"]])
[08:29:14.762]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:14.762]                             info)
[08:29:14.762]                           info <- base::paste(info, collapse = "; ")
[08:29:14.762]                           if (!has_future) {
[08:29:14.762]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:14.762]                               info)
[08:29:14.762]                           }
[08:29:14.762]                           else {
[08:29:14.762]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:14.762]                               info, version)
[08:29:14.762]                           }
[08:29:14.762]                           base::stop(msg)
[08:29:14.762]                         }
[08:29:14.762]                       })
[08:29:14.762]                     }
[08:29:14.762]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:14.762]                     base::options(mc.cores = 1L)
[08:29:14.762]                   }
[08:29:14.762]                   ...future.strategy.old <- future::plan("list")
[08:29:14.762]                   options(future.plan = NULL)
[08:29:14.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:14.762]                 }
[08:29:14.762]                 ...future.workdir <- getwd()
[08:29:14.762]             }
[08:29:14.762]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:14.762]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:14.762]         }
[08:29:14.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:14.762]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:14.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:14.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:14.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:14.762]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:14.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:14.762]             base::names(...future.oldOptions))
[08:29:14.762]     }
[08:29:14.762]     if (FALSE) {
[08:29:14.762]     }
[08:29:14.762]     else {
[08:29:14.762]         if (TRUE) {
[08:29:14.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:14.762]                 open = "w")
[08:29:14.762]         }
[08:29:14.762]         else {
[08:29:14.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:14.762]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:14.762]         }
[08:29:14.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:14.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:14.762]             base::sink(type = "output", split = FALSE)
[08:29:14.762]             base::close(...future.stdout)
[08:29:14.762]         }, add = TRUE)
[08:29:14.762]     }
[08:29:14.762]     ...future.frame <- base::sys.nframe()
[08:29:14.762]     ...future.conditions <- base::list()
[08:29:14.762]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:14.762]     if (FALSE) {
[08:29:14.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:14.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:14.762]     }
[08:29:14.762]     ...future.result <- base::tryCatch({
[08:29:14.762]         base::withCallingHandlers({
[08:29:14.762]             ...future.value <- base::withVisible(base::local({
[08:29:14.762]                 ...future.makeSendCondition <- base::local({
[08:29:14.762]                   sendCondition <- NULL
[08:29:14.762]                   function(frame = 1L) {
[08:29:14.762]                     if (is.function(sendCondition)) 
[08:29:14.762]                       return(sendCondition)
[08:29:14.762]                     ns <- getNamespace("parallel")
[08:29:14.762]                     if (exists("sendData", mode = "function", 
[08:29:14.762]                       envir = ns)) {
[08:29:14.762]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:14.762]                         envir = ns)
[08:29:14.762]                       envir <- sys.frame(frame)
[08:29:14.762]                       master <- NULL
[08:29:14.762]                       while (!identical(envir, .GlobalEnv) && 
[08:29:14.762]                         !identical(envir, emptyenv())) {
[08:29:14.762]                         if (exists("master", mode = "list", envir = envir, 
[08:29:14.762]                           inherits = FALSE)) {
[08:29:14.762]                           master <- get("master", mode = "list", 
[08:29:14.762]                             envir = envir, inherits = FALSE)
[08:29:14.762]                           if (inherits(master, c("SOCKnode", 
[08:29:14.762]                             "SOCK0node"))) {
[08:29:14.762]                             sendCondition <<- function(cond) {
[08:29:14.762]                               data <- list(type = "VALUE", value = cond, 
[08:29:14.762]                                 success = TRUE)
[08:29:14.762]                               parallel_sendData(master, data)
[08:29:14.762]                             }
[08:29:14.762]                             return(sendCondition)
[08:29:14.762]                           }
[08:29:14.762]                         }
[08:29:14.762]                         frame <- frame + 1L
[08:29:14.762]                         envir <- sys.frame(frame)
[08:29:14.762]                       }
[08:29:14.762]                     }
[08:29:14.762]                     sendCondition <<- function(cond) NULL
[08:29:14.762]                   }
[08:29:14.762]                 })
[08:29:14.762]                 withCallingHandlers({
[08:29:14.762]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:14.762]                 }, immediateCondition = function(cond) {
[08:29:14.762]                   sendCondition <- ...future.makeSendCondition()
[08:29:14.762]                   sendCondition(cond)
[08:29:14.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.762]                   {
[08:29:14.762]                     inherits <- base::inherits
[08:29:14.762]                     invokeRestart <- base::invokeRestart
[08:29:14.762]                     is.null <- base::is.null
[08:29:14.762]                     muffled <- FALSE
[08:29:14.762]                     if (inherits(cond, "message")) {
[08:29:14.762]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:14.762]                       if (muffled) 
[08:29:14.762]                         invokeRestart("muffleMessage")
[08:29:14.762]                     }
[08:29:14.762]                     else if (inherits(cond, "warning")) {
[08:29:14.762]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:14.762]                       if (muffled) 
[08:29:14.762]                         invokeRestart("muffleWarning")
[08:29:14.762]                     }
[08:29:14.762]                     else if (inherits(cond, "condition")) {
[08:29:14.762]                       if (!is.null(pattern)) {
[08:29:14.762]                         computeRestarts <- base::computeRestarts
[08:29:14.762]                         grepl <- base::grepl
[08:29:14.762]                         restarts <- computeRestarts(cond)
[08:29:14.762]                         for (restart in restarts) {
[08:29:14.762]                           name <- restart$name
[08:29:14.762]                           if (is.null(name)) 
[08:29:14.762]                             next
[08:29:14.762]                           if (!grepl(pattern, name)) 
[08:29:14.762]                             next
[08:29:14.762]                           invokeRestart(restart)
[08:29:14.762]                           muffled <- TRUE
[08:29:14.762]                           break
[08:29:14.762]                         }
[08:29:14.762]                       }
[08:29:14.762]                     }
[08:29:14.762]                     invisible(muffled)
[08:29:14.762]                   }
[08:29:14.762]                   muffleCondition(cond)
[08:29:14.762]                 })
[08:29:14.762]             }))
[08:29:14.762]             future::FutureResult(value = ...future.value$value, 
[08:29:14.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.762]                   ...future.rng), globalenv = if (FALSE) 
[08:29:14.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:14.762]                     ...future.globalenv.names))
[08:29:14.762]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:14.762]         }, condition = base::local({
[08:29:14.762]             c <- base::c
[08:29:14.762]             inherits <- base::inherits
[08:29:14.762]             invokeRestart <- base::invokeRestart
[08:29:14.762]             length <- base::length
[08:29:14.762]             list <- base::list
[08:29:14.762]             seq.int <- base::seq.int
[08:29:14.762]             signalCondition <- base::signalCondition
[08:29:14.762]             sys.calls <- base::sys.calls
[08:29:14.762]             `[[` <- base::`[[`
[08:29:14.762]             `+` <- base::`+`
[08:29:14.762]             `<<-` <- base::`<<-`
[08:29:14.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:14.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:14.762]                   3L)]
[08:29:14.762]             }
[08:29:14.762]             function(cond) {
[08:29:14.762]                 is_error <- inherits(cond, "error")
[08:29:14.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:14.762]                   NULL)
[08:29:14.762]                 if (is_error) {
[08:29:14.762]                   sessionInformation <- function() {
[08:29:14.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:14.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:14.762]                       search = base::search(), system = base::Sys.info())
[08:29:14.762]                   }
[08:29:14.762]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:14.762]                     cond$call), session = sessionInformation(), 
[08:29:14.762]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:14.762]                   signalCondition(cond)
[08:29:14.762]                 }
[08:29:14.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:14.762]                 "immediateCondition"))) {
[08:29:14.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:14.762]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:14.762]                   if (TRUE && !signal) {
[08:29:14.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.762]                     {
[08:29:14.762]                       inherits <- base::inherits
[08:29:14.762]                       invokeRestart <- base::invokeRestart
[08:29:14.762]                       is.null <- base::is.null
[08:29:14.762]                       muffled <- FALSE
[08:29:14.762]                       if (inherits(cond, "message")) {
[08:29:14.762]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.762]                         if (muffled) 
[08:29:14.762]                           invokeRestart("muffleMessage")
[08:29:14.762]                       }
[08:29:14.762]                       else if (inherits(cond, "warning")) {
[08:29:14.762]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.762]                         if (muffled) 
[08:29:14.762]                           invokeRestart("muffleWarning")
[08:29:14.762]                       }
[08:29:14.762]                       else if (inherits(cond, "condition")) {
[08:29:14.762]                         if (!is.null(pattern)) {
[08:29:14.762]                           computeRestarts <- base::computeRestarts
[08:29:14.762]                           grepl <- base::grepl
[08:29:14.762]                           restarts <- computeRestarts(cond)
[08:29:14.762]                           for (restart in restarts) {
[08:29:14.762]                             name <- restart$name
[08:29:14.762]                             if (is.null(name)) 
[08:29:14.762]                               next
[08:29:14.762]                             if (!grepl(pattern, name)) 
[08:29:14.762]                               next
[08:29:14.762]                             invokeRestart(restart)
[08:29:14.762]                             muffled <- TRUE
[08:29:14.762]                             break
[08:29:14.762]                           }
[08:29:14.762]                         }
[08:29:14.762]                       }
[08:29:14.762]                       invisible(muffled)
[08:29:14.762]                     }
[08:29:14.762]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.762]                   }
[08:29:14.762]                 }
[08:29:14.762]                 else {
[08:29:14.762]                   if (TRUE) {
[08:29:14.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.762]                     {
[08:29:14.762]                       inherits <- base::inherits
[08:29:14.762]                       invokeRestart <- base::invokeRestart
[08:29:14.762]                       is.null <- base::is.null
[08:29:14.762]                       muffled <- FALSE
[08:29:14.762]                       if (inherits(cond, "message")) {
[08:29:14.762]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.762]                         if (muffled) 
[08:29:14.762]                           invokeRestart("muffleMessage")
[08:29:14.762]                       }
[08:29:14.762]                       else if (inherits(cond, "warning")) {
[08:29:14.762]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.762]                         if (muffled) 
[08:29:14.762]                           invokeRestart("muffleWarning")
[08:29:14.762]                       }
[08:29:14.762]                       else if (inherits(cond, "condition")) {
[08:29:14.762]                         if (!is.null(pattern)) {
[08:29:14.762]                           computeRestarts <- base::computeRestarts
[08:29:14.762]                           grepl <- base::grepl
[08:29:14.762]                           restarts <- computeRestarts(cond)
[08:29:14.762]                           for (restart in restarts) {
[08:29:14.762]                             name <- restart$name
[08:29:14.762]                             if (is.null(name)) 
[08:29:14.762]                               next
[08:29:14.762]                             if (!grepl(pattern, name)) 
[08:29:14.762]                               next
[08:29:14.762]                             invokeRestart(restart)
[08:29:14.762]                             muffled <- TRUE
[08:29:14.762]                             break
[08:29:14.762]                           }
[08:29:14.762]                         }
[08:29:14.762]                       }
[08:29:14.762]                       invisible(muffled)
[08:29:14.762]                     }
[08:29:14.762]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.762]                   }
[08:29:14.762]                 }
[08:29:14.762]             }
[08:29:14.762]         }))
[08:29:14.762]     }, error = function(ex) {
[08:29:14.762]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:14.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.762]                 ...future.rng), started = ...future.startTime, 
[08:29:14.762]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:14.762]             version = "1.8"), class = "FutureResult")
[08:29:14.762]     }, finally = {
[08:29:14.762]         if (!identical(...future.workdir, getwd())) 
[08:29:14.762]             setwd(...future.workdir)
[08:29:14.762]         {
[08:29:14.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:14.762]                 ...future.oldOptions$nwarnings <- NULL
[08:29:14.762]             }
[08:29:14.762]             base::options(...future.oldOptions)
[08:29:14.762]             if (.Platform$OS.type == "windows") {
[08:29:14.762]                 old_names <- names(...future.oldEnvVars)
[08:29:14.762]                 envs <- base::Sys.getenv()
[08:29:14.762]                 names <- names(envs)
[08:29:14.762]                 common <- intersect(names, old_names)
[08:29:14.762]                 added <- setdiff(names, old_names)
[08:29:14.762]                 removed <- setdiff(old_names, names)
[08:29:14.762]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:14.762]                   envs[common]]
[08:29:14.762]                 NAMES <- toupper(changed)
[08:29:14.762]                 args <- list()
[08:29:14.762]                 for (kk in seq_along(NAMES)) {
[08:29:14.762]                   name <- changed[[kk]]
[08:29:14.762]                   NAME <- NAMES[[kk]]
[08:29:14.762]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.762]                     next
[08:29:14.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.762]                 }
[08:29:14.762]                 NAMES <- toupper(added)
[08:29:14.762]                 for (kk in seq_along(NAMES)) {
[08:29:14.762]                   name <- added[[kk]]
[08:29:14.762]                   NAME <- NAMES[[kk]]
[08:29:14.762]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.762]                     next
[08:29:14.762]                   args[[name]] <- ""
[08:29:14.762]                 }
[08:29:14.762]                 NAMES <- toupper(removed)
[08:29:14.762]                 for (kk in seq_along(NAMES)) {
[08:29:14.762]                   name <- removed[[kk]]
[08:29:14.762]                   NAME <- NAMES[[kk]]
[08:29:14.762]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.762]                     next
[08:29:14.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.762]                 }
[08:29:14.762]                 if (length(args) > 0) 
[08:29:14.762]                   base::do.call(base::Sys.setenv, args = args)
[08:29:14.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:14.762]             }
[08:29:14.762]             else {
[08:29:14.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:14.762]             }
[08:29:14.762]             {
[08:29:14.762]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:14.762]                   0L) {
[08:29:14.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:14.762]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:14.762]                   base::options(opts)
[08:29:14.762]                 }
[08:29:14.762]                 {
[08:29:14.762]                   {
[08:29:14.762]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:14.762]                     NULL
[08:29:14.762]                   }
[08:29:14.762]                   options(future.plan = NULL)
[08:29:14.762]                   if (is.na(NA_character_)) 
[08:29:14.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:14.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:14.762]                     .init = FALSE)
[08:29:14.762]                 }
[08:29:14.762]             }
[08:29:14.762]         }
[08:29:14.762]     })
[08:29:14.762]     if (TRUE) {
[08:29:14.762]         base::sink(type = "output", split = FALSE)
[08:29:14.762]         if (TRUE) {
[08:29:14.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:14.762]         }
[08:29:14.762]         else {
[08:29:14.762]             ...future.result["stdout"] <- base::list(NULL)
[08:29:14.762]         }
[08:29:14.762]         base::close(...future.stdout)
[08:29:14.762]         ...future.stdout <- NULL
[08:29:14.762]     }
[08:29:14.762]     ...future.result$conditions <- ...future.conditions
[08:29:14.762]     ...future.result$finished <- base::Sys.time()
[08:29:14.762]     ...future.result
[08:29:14.762] }
[08:29:14.765] MultisessionFuture started
[08:29:14.765] - Launch lazy future ... done
[08:29:14.765] run() for ‘MultisessionFuture’ ... done
[08:29:14.807] receiveMessageFromWorker() for ClusterFuture ...
[08:29:14.807] - Validating connection of MultisessionFuture
[08:29:14.808] - received message: FutureResult
[08:29:14.808] - Received FutureResult
[08:29:14.808] - Erased future from FutureRegistry
[08:29:14.808] result() for ClusterFuture ...
[08:29:14.808] - result already collected: FutureResult
[08:29:14.808] result() for ClusterFuture ... done
[08:29:14.808] signalConditions() ...
[08:29:14.808]  - include = ‘immediateCondition’
[08:29:14.808]  - exclude = 
[08:29:14.809]  - resignal = FALSE
[08:29:14.809]  - Number of conditions: 1
[08:29:14.809] signalConditions() ... done
[08:29:14.809] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:14.809] A MultisessionFuture was resolved (and resolved itself)
[08:29:14.809] getGlobalsAndPackages() ...
[08:29:14.809] Searching for globals...
[08:29:14.810] - globals found: [2] ‘list’, ‘stop’
[08:29:14.810] Searching for globals ... DONE
[08:29:14.810] Resolving globals: FALSE
[08:29:14.810] 
[08:29:14.810] 
[08:29:14.810] getGlobalsAndPackages() ... DONE
[08:29:14.811] run() for ‘Future’ ...
[08:29:14.811] - state: ‘created’
[08:29:14.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:14.824] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:14.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:14.825]   - Field: ‘node’
[08:29:14.825]   - Field: ‘label’
[08:29:14.825]   - Field: ‘local’
[08:29:14.825]   - Field: ‘owner’
[08:29:14.825]   - Field: ‘envir’
[08:29:14.825]   - Field: ‘workers’
[08:29:14.825]   - Field: ‘packages’
[08:29:14.825]   - Field: ‘gc’
[08:29:14.825]   - Field: ‘conditions’
[08:29:14.826]   - Field: ‘persistent’
[08:29:14.826]   - Field: ‘expr’
[08:29:14.826]   - Field: ‘uuid’
[08:29:14.826]   - Field: ‘seed’
[08:29:14.826]   - Field: ‘version’
[08:29:14.826]   - Field: ‘result’
[08:29:14.826]   - Field: ‘asynchronous’
[08:29:14.826]   - Field: ‘calls’
[08:29:14.826]   - Field: ‘globals’
[08:29:14.826]   - Field: ‘stdout’
[08:29:14.826]   - Field: ‘earlySignal’
[08:29:14.826]   - Field: ‘lazy’
[08:29:14.827]   - Field: ‘state’
[08:29:14.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:14.827] - Launch lazy future ...
[08:29:14.827] Packages needed by the future expression (n = 0): <none>
[08:29:14.827] Packages needed by future strategies (n = 0): <none>
[08:29:14.827] {
[08:29:14.827]     {
[08:29:14.827]         {
[08:29:14.827]             ...future.startTime <- base::Sys.time()
[08:29:14.827]             {
[08:29:14.827]                 {
[08:29:14.827]                   {
[08:29:14.827]                     {
[08:29:14.827]                       base::local({
[08:29:14.827]                         has_future <- base::requireNamespace("future", 
[08:29:14.827]                           quietly = TRUE)
[08:29:14.827]                         if (has_future) {
[08:29:14.827]                           ns <- base::getNamespace("future")
[08:29:14.827]                           version <- ns[[".package"]][["version"]]
[08:29:14.827]                           if (is.null(version)) 
[08:29:14.827]                             version <- utils::packageVersion("future")
[08:29:14.827]                         }
[08:29:14.827]                         else {
[08:29:14.827]                           version <- NULL
[08:29:14.827]                         }
[08:29:14.827]                         if (!has_future || version < "1.8.0") {
[08:29:14.827]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:14.827]                             "", base::R.version$version.string), 
[08:29:14.827]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:14.827]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:14.827]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:14.827]                               "release", "version")], collapse = " "), 
[08:29:14.827]                             hostname = base::Sys.info()[["nodename"]])
[08:29:14.827]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:14.827]                             info)
[08:29:14.827]                           info <- base::paste(info, collapse = "; ")
[08:29:14.827]                           if (!has_future) {
[08:29:14.827]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:14.827]                               info)
[08:29:14.827]                           }
[08:29:14.827]                           else {
[08:29:14.827]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:14.827]                               info, version)
[08:29:14.827]                           }
[08:29:14.827]                           base::stop(msg)
[08:29:14.827]                         }
[08:29:14.827]                       })
[08:29:14.827]                     }
[08:29:14.827]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:14.827]                     base::options(mc.cores = 1L)
[08:29:14.827]                   }
[08:29:14.827]                   ...future.strategy.old <- future::plan("list")
[08:29:14.827]                   options(future.plan = NULL)
[08:29:14.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:14.827]                 }
[08:29:14.827]                 ...future.workdir <- getwd()
[08:29:14.827]             }
[08:29:14.827]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:14.827]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:14.827]         }
[08:29:14.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:14.827]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:14.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:14.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:14.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:14.827]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:14.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:14.827]             base::names(...future.oldOptions))
[08:29:14.827]     }
[08:29:14.827]     if (FALSE) {
[08:29:14.827]     }
[08:29:14.827]     else {
[08:29:14.827]         if (TRUE) {
[08:29:14.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:14.827]                 open = "w")
[08:29:14.827]         }
[08:29:14.827]         else {
[08:29:14.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:14.827]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:14.827]         }
[08:29:14.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:14.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:14.827]             base::sink(type = "output", split = FALSE)
[08:29:14.827]             base::close(...future.stdout)
[08:29:14.827]         }, add = TRUE)
[08:29:14.827]     }
[08:29:14.827]     ...future.frame <- base::sys.nframe()
[08:29:14.827]     ...future.conditions <- base::list()
[08:29:14.827]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:14.827]     if (FALSE) {
[08:29:14.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:14.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:14.827]     }
[08:29:14.827]     ...future.result <- base::tryCatch({
[08:29:14.827]         base::withCallingHandlers({
[08:29:14.827]             ...future.value <- base::withVisible(base::local({
[08:29:14.827]                 ...future.makeSendCondition <- base::local({
[08:29:14.827]                   sendCondition <- NULL
[08:29:14.827]                   function(frame = 1L) {
[08:29:14.827]                     if (is.function(sendCondition)) 
[08:29:14.827]                       return(sendCondition)
[08:29:14.827]                     ns <- getNamespace("parallel")
[08:29:14.827]                     if (exists("sendData", mode = "function", 
[08:29:14.827]                       envir = ns)) {
[08:29:14.827]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:14.827]                         envir = ns)
[08:29:14.827]                       envir <- sys.frame(frame)
[08:29:14.827]                       master <- NULL
[08:29:14.827]                       while (!identical(envir, .GlobalEnv) && 
[08:29:14.827]                         !identical(envir, emptyenv())) {
[08:29:14.827]                         if (exists("master", mode = "list", envir = envir, 
[08:29:14.827]                           inherits = FALSE)) {
[08:29:14.827]                           master <- get("master", mode = "list", 
[08:29:14.827]                             envir = envir, inherits = FALSE)
[08:29:14.827]                           if (inherits(master, c("SOCKnode", 
[08:29:14.827]                             "SOCK0node"))) {
[08:29:14.827]                             sendCondition <<- function(cond) {
[08:29:14.827]                               data <- list(type = "VALUE", value = cond, 
[08:29:14.827]                                 success = TRUE)
[08:29:14.827]                               parallel_sendData(master, data)
[08:29:14.827]                             }
[08:29:14.827]                             return(sendCondition)
[08:29:14.827]                           }
[08:29:14.827]                         }
[08:29:14.827]                         frame <- frame + 1L
[08:29:14.827]                         envir <- sys.frame(frame)
[08:29:14.827]                       }
[08:29:14.827]                     }
[08:29:14.827]                     sendCondition <<- function(cond) NULL
[08:29:14.827]                   }
[08:29:14.827]                 })
[08:29:14.827]                 withCallingHandlers({
[08:29:14.827]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:14.827]                 }, immediateCondition = function(cond) {
[08:29:14.827]                   sendCondition <- ...future.makeSendCondition()
[08:29:14.827]                   sendCondition(cond)
[08:29:14.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.827]                   {
[08:29:14.827]                     inherits <- base::inherits
[08:29:14.827]                     invokeRestart <- base::invokeRestart
[08:29:14.827]                     is.null <- base::is.null
[08:29:14.827]                     muffled <- FALSE
[08:29:14.827]                     if (inherits(cond, "message")) {
[08:29:14.827]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:14.827]                       if (muffled) 
[08:29:14.827]                         invokeRestart("muffleMessage")
[08:29:14.827]                     }
[08:29:14.827]                     else if (inherits(cond, "warning")) {
[08:29:14.827]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:14.827]                       if (muffled) 
[08:29:14.827]                         invokeRestart("muffleWarning")
[08:29:14.827]                     }
[08:29:14.827]                     else if (inherits(cond, "condition")) {
[08:29:14.827]                       if (!is.null(pattern)) {
[08:29:14.827]                         computeRestarts <- base::computeRestarts
[08:29:14.827]                         grepl <- base::grepl
[08:29:14.827]                         restarts <- computeRestarts(cond)
[08:29:14.827]                         for (restart in restarts) {
[08:29:14.827]                           name <- restart$name
[08:29:14.827]                           if (is.null(name)) 
[08:29:14.827]                             next
[08:29:14.827]                           if (!grepl(pattern, name)) 
[08:29:14.827]                             next
[08:29:14.827]                           invokeRestart(restart)
[08:29:14.827]                           muffled <- TRUE
[08:29:14.827]                           break
[08:29:14.827]                         }
[08:29:14.827]                       }
[08:29:14.827]                     }
[08:29:14.827]                     invisible(muffled)
[08:29:14.827]                   }
[08:29:14.827]                   muffleCondition(cond)
[08:29:14.827]                 })
[08:29:14.827]             }))
[08:29:14.827]             future::FutureResult(value = ...future.value$value, 
[08:29:14.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.827]                   ...future.rng), globalenv = if (FALSE) 
[08:29:14.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:14.827]                     ...future.globalenv.names))
[08:29:14.827]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:14.827]         }, condition = base::local({
[08:29:14.827]             c <- base::c
[08:29:14.827]             inherits <- base::inherits
[08:29:14.827]             invokeRestart <- base::invokeRestart
[08:29:14.827]             length <- base::length
[08:29:14.827]             list <- base::list
[08:29:14.827]             seq.int <- base::seq.int
[08:29:14.827]             signalCondition <- base::signalCondition
[08:29:14.827]             sys.calls <- base::sys.calls
[08:29:14.827]             `[[` <- base::`[[`
[08:29:14.827]             `+` <- base::`+`
[08:29:14.827]             `<<-` <- base::`<<-`
[08:29:14.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:14.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:14.827]                   3L)]
[08:29:14.827]             }
[08:29:14.827]             function(cond) {
[08:29:14.827]                 is_error <- inherits(cond, "error")
[08:29:14.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:14.827]                   NULL)
[08:29:14.827]                 if (is_error) {
[08:29:14.827]                   sessionInformation <- function() {
[08:29:14.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:14.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:14.827]                       search = base::search(), system = base::Sys.info())
[08:29:14.827]                   }
[08:29:14.827]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:14.827]                     cond$call), session = sessionInformation(), 
[08:29:14.827]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:14.827]                   signalCondition(cond)
[08:29:14.827]                 }
[08:29:14.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:14.827]                 "immediateCondition"))) {
[08:29:14.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:14.827]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:14.827]                   if (TRUE && !signal) {
[08:29:14.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.827]                     {
[08:29:14.827]                       inherits <- base::inherits
[08:29:14.827]                       invokeRestart <- base::invokeRestart
[08:29:14.827]                       is.null <- base::is.null
[08:29:14.827]                       muffled <- FALSE
[08:29:14.827]                       if (inherits(cond, "message")) {
[08:29:14.827]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.827]                         if (muffled) 
[08:29:14.827]                           invokeRestart("muffleMessage")
[08:29:14.827]                       }
[08:29:14.827]                       else if (inherits(cond, "warning")) {
[08:29:14.827]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.827]                         if (muffled) 
[08:29:14.827]                           invokeRestart("muffleWarning")
[08:29:14.827]                       }
[08:29:14.827]                       else if (inherits(cond, "condition")) {
[08:29:14.827]                         if (!is.null(pattern)) {
[08:29:14.827]                           computeRestarts <- base::computeRestarts
[08:29:14.827]                           grepl <- base::grepl
[08:29:14.827]                           restarts <- computeRestarts(cond)
[08:29:14.827]                           for (restart in restarts) {
[08:29:14.827]                             name <- restart$name
[08:29:14.827]                             if (is.null(name)) 
[08:29:14.827]                               next
[08:29:14.827]                             if (!grepl(pattern, name)) 
[08:29:14.827]                               next
[08:29:14.827]                             invokeRestart(restart)
[08:29:14.827]                             muffled <- TRUE
[08:29:14.827]                             break
[08:29:14.827]                           }
[08:29:14.827]                         }
[08:29:14.827]                       }
[08:29:14.827]                       invisible(muffled)
[08:29:14.827]                     }
[08:29:14.827]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.827]                   }
[08:29:14.827]                 }
[08:29:14.827]                 else {
[08:29:14.827]                   if (TRUE) {
[08:29:14.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.827]                     {
[08:29:14.827]                       inherits <- base::inherits
[08:29:14.827]                       invokeRestart <- base::invokeRestart
[08:29:14.827]                       is.null <- base::is.null
[08:29:14.827]                       muffled <- FALSE
[08:29:14.827]                       if (inherits(cond, "message")) {
[08:29:14.827]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.827]                         if (muffled) 
[08:29:14.827]                           invokeRestart("muffleMessage")
[08:29:14.827]                       }
[08:29:14.827]                       else if (inherits(cond, "warning")) {
[08:29:14.827]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.827]                         if (muffled) 
[08:29:14.827]                           invokeRestart("muffleWarning")
[08:29:14.827]                       }
[08:29:14.827]                       else if (inherits(cond, "condition")) {
[08:29:14.827]                         if (!is.null(pattern)) {
[08:29:14.827]                           computeRestarts <- base::computeRestarts
[08:29:14.827]                           grepl <- base::grepl
[08:29:14.827]                           restarts <- computeRestarts(cond)
[08:29:14.827]                           for (restart in restarts) {
[08:29:14.827]                             name <- restart$name
[08:29:14.827]                             if (is.null(name)) 
[08:29:14.827]                               next
[08:29:14.827]                             if (!grepl(pattern, name)) 
[08:29:14.827]                               next
[08:29:14.827]                             invokeRestart(restart)
[08:29:14.827]                             muffled <- TRUE
[08:29:14.827]                             break
[08:29:14.827]                           }
[08:29:14.827]                         }
[08:29:14.827]                       }
[08:29:14.827]                       invisible(muffled)
[08:29:14.827]                     }
[08:29:14.827]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.827]                   }
[08:29:14.827]                 }
[08:29:14.827]             }
[08:29:14.827]         }))
[08:29:14.827]     }, error = function(ex) {
[08:29:14.827]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:14.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.827]                 ...future.rng), started = ...future.startTime, 
[08:29:14.827]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:14.827]             version = "1.8"), class = "FutureResult")
[08:29:14.827]     }, finally = {
[08:29:14.827]         if (!identical(...future.workdir, getwd())) 
[08:29:14.827]             setwd(...future.workdir)
[08:29:14.827]         {
[08:29:14.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:14.827]                 ...future.oldOptions$nwarnings <- NULL
[08:29:14.827]             }
[08:29:14.827]             base::options(...future.oldOptions)
[08:29:14.827]             if (.Platform$OS.type == "windows") {
[08:29:14.827]                 old_names <- names(...future.oldEnvVars)
[08:29:14.827]                 envs <- base::Sys.getenv()
[08:29:14.827]                 names <- names(envs)
[08:29:14.827]                 common <- intersect(names, old_names)
[08:29:14.827]                 added <- setdiff(names, old_names)
[08:29:14.827]                 removed <- setdiff(old_names, names)
[08:29:14.827]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:14.827]                   envs[common]]
[08:29:14.827]                 NAMES <- toupper(changed)
[08:29:14.827]                 args <- list()
[08:29:14.827]                 for (kk in seq_along(NAMES)) {
[08:29:14.827]                   name <- changed[[kk]]
[08:29:14.827]                   NAME <- NAMES[[kk]]
[08:29:14.827]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.827]                     next
[08:29:14.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.827]                 }
[08:29:14.827]                 NAMES <- toupper(added)
[08:29:14.827]                 for (kk in seq_along(NAMES)) {
[08:29:14.827]                   name <- added[[kk]]
[08:29:14.827]                   NAME <- NAMES[[kk]]
[08:29:14.827]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.827]                     next
[08:29:14.827]                   args[[name]] <- ""
[08:29:14.827]                 }
[08:29:14.827]                 NAMES <- toupper(removed)
[08:29:14.827]                 for (kk in seq_along(NAMES)) {
[08:29:14.827]                   name <- removed[[kk]]
[08:29:14.827]                   NAME <- NAMES[[kk]]
[08:29:14.827]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.827]                     next
[08:29:14.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.827]                 }
[08:29:14.827]                 if (length(args) > 0) 
[08:29:14.827]                   base::do.call(base::Sys.setenv, args = args)
[08:29:14.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:14.827]             }
[08:29:14.827]             else {
[08:29:14.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:14.827]             }
[08:29:14.827]             {
[08:29:14.827]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:14.827]                   0L) {
[08:29:14.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:14.827]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:14.827]                   base::options(opts)
[08:29:14.827]                 }
[08:29:14.827]                 {
[08:29:14.827]                   {
[08:29:14.827]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:14.827]                     NULL
[08:29:14.827]                   }
[08:29:14.827]                   options(future.plan = NULL)
[08:29:14.827]                   if (is.na(NA_character_)) 
[08:29:14.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:14.827]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:14.827]                     .init = FALSE)
[08:29:14.827]                 }
[08:29:14.827]             }
[08:29:14.827]         }
[08:29:14.827]     })
[08:29:14.827]     if (TRUE) {
[08:29:14.827]         base::sink(type = "output", split = FALSE)
[08:29:14.827]         if (TRUE) {
[08:29:14.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:14.827]         }
[08:29:14.827]         else {
[08:29:14.827]             ...future.result["stdout"] <- base::list(NULL)
[08:29:14.827]         }
[08:29:14.827]         base::close(...future.stdout)
[08:29:14.827]         ...future.stdout <- NULL
[08:29:14.827]     }
[08:29:14.827]     ...future.result$conditions <- ...future.conditions
[08:29:14.827]     ...future.result$finished <- base::Sys.time()
[08:29:14.827]     ...future.result
[08:29:14.827] }
[08:29:14.830] MultisessionFuture started
[08:29:14.830] - Launch lazy future ... done
[08:29:14.831] run() for ‘MultisessionFuture’ ... done
[08:29:14.872] receiveMessageFromWorker() for ClusterFuture ...
[08:29:14.872] - Validating connection of MultisessionFuture
[08:29:14.873] - received message: FutureResult
[08:29:14.873] - Received FutureResult
[08:29:14.873] - Erased future from FutureRegistry
[08:29:14.873] result() for ClusterFuture ...
[08:29:14.873] - result already collected: FutureResult
[08:29:14.873] result() for ClusterFuture ... done
[08:29:14.873] signalConditions() ...
[08:29:14.873]  - include = ‘immediateCondition’
[08:29:14.873]  - exclude = 
[08:29:14.874]  - resignal = FALSE
[08:29:14.874]  - Number of conditions: 1
[08:29:14.874] signalConditions() ... done
[08:29:14.874] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:14.874] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[08:29:14.874] getGlobalsAndPackages() ...
[08:29:14.874] Searching for globals...
[08:29:14.875] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:14.875] Searching for globals ... DONE
[08:29:14.876] Resolving globals: FALSE
[08:29:14.876] 
[08:29:14.876] 
[08:29:14.876] getGlobalsAndPackages() ... DONE
[08:29:14.876] run() for ‘Future’ ...
[08:29:14.876] - state: ‘created’
[08:29:14.876] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:14.890] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:14.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:14.890]   - Field: ‘node’
[08:29:14.891]   - Field: ‘label’
[08:29:14.891]   - Field: ‘local’
[08:29:14.891]   - Field: ‘owner’
[08:29:14.891]   - Field: ‘envir’
[08:29:14.891]   - Field: ‘workers’
[08:29:14.891]   - Field: ‘packages’
[08:29:14.891]   - Field: ‘gc’
[08:29:14.891]   - Field: ‘conditions’
[08:29:14.891]   - Field: ‘persistent’
[08:29:14.891]   - Field: ‘expr’
[08:29:14.891]   - Field: ‘uuid’
[08:29:14.891]   - Field: ‘seed’
[08:29:14.892]   - Field: ‘version’
[08:29:14.892]   - Field: ‘result’
[08:29:14.892]   - Field: ‘asynchronous’
[08:29:14.892]   - Field: ‘calls’
[08:29:14.892]   - Field: ‘globals’
[08:29:14.892]   - Field: ‘stdout’
[08:29:14.892]   - Field: ‘earlySignal’
[08:29:14.892]   - Field: ‘lazy’
[08:29:14.892]   - Field: ‘state’
[08:29:14.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:14.892] - Launch lazy future ...
[08:29:14.893] Packages needed by the future expression (n = 0): <none>
[08:29:14.893] Packages needed by future strategies (n = 0): <none>
[08:29:14.893] {
[08:29:14.893]     {
[08:29:14.893]         {
[08:29:14.893]             ...future.startTime <- base::Sys.time()
[08:29:14.893]             {
[08:29:14.893]                 {
[08:29:14.893]                   {
[08:29:14.893]                     {
[08:29:14.893]                       base::local({
[08:29:14.893]                         has_future <- base::requireNamespace("future", 
[08:29:14.893]                           quietly = TRUE)
[08:29:14.893]                         if (has_future) {
[08:29:14.893]                           ns <- base::getNamespace("future")
[08:29:14.893]                           version <- ns[[".package"]][["version"]]
[08:29:14.893]                           if (is.null(version)) 
[08:29:14.893]                             version <- utils::packageVersion("future")
[08:29:14.893]                         }
[08:29:14.893]                         else {
[08:29:14.893]                           version <- NULL
[08:29:14.893]                         }
[08:29:14.893]                         if (!has_future || version < "1.8.0") {
[08:29:14.893]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:14.893]                             "", base::R.version$version.string), 
[08:29:14.893]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:14.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:14.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:14.893]                               "release", "version")], collapse = " "), 
[08:29:14.893]                             hostname = base::Sys.info()[["nodename"]])
[08:29:14.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:14.893]                             info)
[08:29:14.893]                           info <- base::paste(info, collapse = "; ")
[08:29:14.893]                           if (!has_future) {
[08:29:14.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:14.893]                               info)
[08:29:14.893]                           }
[08:29:14.893]                           else {
[08:29:14.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:14.893]                               info, version)
[08:29:14.893]                           }
[08:29:14.893]                           base::stop(msg)
[08:29:14.893]                         }
[08:29:14.893]                       })
[08:29:14.893]                     }
[08:29:14.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:14.893]                     base::options(mc.cores = 1L)
[08:29:14.893]                   }
[08:29:14.893]                   ...future.strategy.old <- future::plan("list")
[08:29:14.893]                   options(future.plan = NULL)
[08:29:14.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:14.893]                 }
[08:29:14.893]                 ...future.workdir <- getwd()
[08:29:14.893]             }
[08:29:14.893]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:14.893]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:14.893]         }
[08:29:14.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:14.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:14.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:14.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:14.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:14.893]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:14.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:14.893]             base::names(...future.oldOptions))
[08:29:14.893]     }
[08:29:14.893]     if (FALSE) {
[08:29:14.893]     }
[08:29:14.893]     else {
[08:29:14.893]         if (TRUE) {
[08:29:14.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:14.893]                 open = "w")
[08:29:14.893]         }
[08:29:14.893]         else {
[08:29:14.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:14.893]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:14.893]         }
[08:29:14.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:14.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:14.893]             base::sink(type = "output", split = FALSE)
[08:29:14.893]             base::close(...future.stdout)
[08:29:14.893]         }, add = TRUE)
[08:29:14.893]     }
[08:29:14.893]     ...future.frame <- base::sys.nframe()
[08:29:14.893]     ...future.conditions <- base::list()
[08:29:14.893]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:14.893]     if (FALSE) {
[08:29:14.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:14.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:14.893]     }
[08:29:14.893]     ...future.result <- base::tryCatch({
[08:29:14.893]         base::withCallingHandlers({
[08:29:14.893]             ...future.value <- base::withVisible(base::local({
[08:29:14.893]                 ...future.makeSendCondition <- base::local({
[08:29:14.893]                   sendCondition <- NULL
[08:29:14.893]                   function(frame = 1L) {
[08:29:14.893]                     if (is.function(sendCondition)) 
[08:29:14.893]                       return(sendCondition)
[08:29:14.893]                     ns <- getNamespace("parallel")
[08:29:14.893]                     if (exists("sendData", mode = "function", 
[08:29:14.893]                       envir = ns)) {
[08:29:14.893]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:14.893]                         envir = ns)
[08:29:14.893]                       envir <- sys.frame(frame)
[08:29:14.893]                       master <- NULL
[08:29:14.893]                       while (!identical(envir, .GlobalEnv) && 
[08:29:14.893]                         !identical(envir, emptyenv())) {
[08:29:14.893]                         if (exists("master", mode = "list", envir = envir, 
[08:29:14.893]                           inherits = FALSE)) {
[08:29:14.893]                           master <- get("master", mode = "list", 
[08:29:14.893]                             envir = envir, inherits = FALSE)
[08:29:14.893]                           if (inherits(master, c("SOCKnode", 
[08:29:14.893]                             "SOCK0node"))) {
[08:29:14.893]                             sendCondition <<- function(cond) {
[08:29:14.893]                               data <- list(type = "VALUE", value = cond, 
[08:29:14.893]                                 success = TRUE)
[08:29:14.893]                               parallel_sendData(master, data)
[08:29:14.893]                             }
[08:29:14.893]                             return(sendCondition)
[08:29:14.893]                           }
[08:29:14.893]                         }
[08:29:14.893]                         frame <- frame + 1L
[08:29:14.893]                         envir <- sys.frame(frame)
[08:29:14.893]                       }
[08:29:14.893]                     }
[08:29:14.893]                     sendCondition <<- function(cond) NULL
[08:29:14.893]                   }
[08:29:14.893]                 })
[08:29:14.893]                 withCallingHandlers({
[08:29:14.893]                   {
[08:29:14.893]                     Sys.sleep(0.5)
[08:29:14.893]                     list(a = 1, b = 42L)
[08:29:14.893]                   }
[08:29:14.893]                 }, immediateCondition = function(cond) {
[08:29:14.893]                   sendCondition <- ...future.makeSendCondition()
[08:29:14.893]                   sendCondition(cond)
[08:29:14.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.893]                   {
[08:29:14.893]                     inherits <- base::inherits
[08:29:14.893]                     invokeRestart <- base::invokeRestart
[08:29:14.893]                     is.null <- base::is.null
[08:29:14.893]                     muffled <- FALSE
[08:29:14.893]                     if (inherits(cond, "message")) {
[08:29:14.893]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:14.893]                       if (muffled) 
[08:29:14.893]                         invokeRestart("muffleMessage")
[08:29:14.893]                     }
[08:29:14.893]                     else if (inherits(cond, "warning")) {
[08:29:14.893]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:14.893]                       if (muffled) 
[08:29:14.893]                         invokeRestart("muffleWarning")
[08:29:14.893]                     }
[08:29:14.893]                     else if (inherits(cond, "condition")) {
[08:29:14.893]                       if (!is.null(pattern)) {
[08:29:14.893]                         computeRestarts <- base::computeRestarts
[08:29:14.893]                         grepl <- base::grepl
[08:29:14.893]                         restarts <- computeRestarts(cond)
[08:29:14.893]                         for (restart in restarts) {
[08:29:14.893]                           name <- restart$name
[08:29:14.893]                           if (is.null(name)) 
[08:29:14.893]                             next
[08:29:14.893]                           if (!grepl(pattern, name)) 
[08:29:14.893]                             next
[08:29:14.893]                           invokeRestart(restart)
[08:29:14.893]                           muffled <- TRUE
[08:29:14.893]                           break
[08:29:14.893]                         }
[08:29:14.893]                       }
[08:29:14.893]                     }
[08:29:14.893]                     invisible(muffled)
[08:29:14.893]                   }
[08:29:14.893]                   muffleCondition(cond)
[08:29:14.893]                 })
[08:29:14.893]             }))
[08:29:14.893]             future::FutureResult(value = ...future.value$value, 
[08:29:14.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.893]                   ...future.rng), globalenv = if (FALSE) 
[08:29:14.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:14.893]                     ...future.globalenv.names))
[08:29:14.893]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:14.893]         }, condition = base::local({
[08:29:14.893]             c <- base::c
[08:29:14.893]             inherits <- base::inherits
[08:29:14.893]             invokeRestart <- base::invokeRestart
[08:29:14.893]             length <- base::length
[08:29:14.893]             list <- base::list
[08:29:14.893]             seq.int <- base::seq.int
[08:29:14.893]             signalCondition <- base::signalCondition
[08:29:14.893]             sys.calls <- base::sys.calls
[08:29:14.893]             `[[` <- base::`[[`
[08:29:14.893]             `+` <- base::`+`
[08:29:14.893]             `<<-` <- base::`<<-`
[08:29:14.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:14.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:14.893]                   3L)]
[08:29:14.893]             }
[08:29:14.893]             function(cond) {
[08:29:14.893]                 is_error <- inherits(cond, "error")
[08:29:14.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:14.893]                   NULL)
[08:29:14.893]                 if (is_error) {
[08:29:14.893]                   sessionInformation <- function() {
[08:29:14.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:14.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:14.893]                       search = base::search(), system = base::Sys.info())
[08:29:14.893]                   }
[08:29:14.893]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:14.893]                     cond$call), session = sessionInformation(), 
[08:29:14.893]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:14.893]                   signalCondition(cond)
[08:29:14.893]                 }
[08:29:14.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:14.893]                 "immediateCondition"))) {
[08:29:14.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:14.893]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:14.893]                   if (TRUE && !signal) {
[08:29:14.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.893]                     {
[08:29:14.893]                       inherits <- base::inherits
[08:29:14.893]                       invokeRestart <- base::invokeRestart
[08:29:14.893]                       is.null <- base::is.null
[08:29:14.893]                       muffled <- FALSE
[08:29:14.893]                       if (inherits(cond, "message")) {
[08:29:14.893]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.893]                         if (muffled) 
[08:29:14.893]                           invokeRestart("muffleMessage")
[08:29:14.893]                       }
[08:29:14.893]                       else if (inherits(cond, "warning")) {
[08:29:14.893]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.893]                         if (muffled) 
[08:29:14.893]                           invokeRestart("muffleWarning")
[08:29:14.893]                       }
[08:29:14.893]                       else if (inherits(cond, "condition")) {
[08:29:14.893]                         if (!is.null(pattern)) {
[08:29:14.893]                           computeRestarts <- base::computeRestarts
[08:29:14.893]                           grepl <- base::grepl
[08:29:14.893]                           restarts <- computeRestarts(cond)
[08:29:14.893]                           for (restart in restarts) {
[08:29:14.893]                             name <- restart$name
[08:29:14.893]                             if (is.null(name)) 
[08:29:14.893]                               next
[08:29:14.893]                             if (!grepl(pattern, name)) 
[08:29:14.893]                               next
[08:29:14.893]                             invokeRestart(restart)
[08:29:14.893]                             muffled <- TRUE
[08:29:14.893]                             break
[08:29:14.893]                           }
[08:29:14.893]                         }
[08:29:14.893]                       }
[08:29:14.893]                       invisible(muffled)
[08:29:14.893]                     }
[08:29:14.893]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.893]                   }
[08:29:14.893]                 }
[08:29:14.893]                 else {
[08:29:14.893]                   if (TRUE) {
[08:29:14.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.893]                     {
[08:29:14.893]                       inherits <- base::inherits
[08:29:14.893]                       invokeRestart <- base::invokeRestart
[08:29:14.893]                       is.null <- base::is.null
[08:29:14.893]                       muffled <- FALSE
[08:29:14.893]                       if (inherits(cond, "message")) {
[08:29:14.893]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.893]                         if (muffled) 
[08:29:14.893]                           invokeRestart("muffleMessage")
[08:29:14.893]                       }
[08:29:14.893]                       else if (inherits(cond, "warning")) {
[08:29:14.893]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.893]                         if (muffled) 
[08:29:14.893]                           invokeRestart("muffleWarning")
[08:29:14.893]                       }
[08:29:14.893]                       else if (inherits(cond, "condition")) {
[08:29:14.893]                         if (!is.null(pattern)) {
[08:29:14.893]                           computeRestarts <- base::computeRestarts
[08:29:14.893]                           grepl <- base::grepl
[08:29:14.893]                           restarts <- computeRestarts(cond)
[08:29:14.893]                           for (restart in restarts) {
[08:29:14.893]                             name <- restart$name
[08:29:14.893]                             if (is.null(name)) 
[08:29:14.893]                               next
[08:29:14.893]                             if (!grepl(pattern, name)) 
[08:29:14.893]                               next
[08:29:14.893]                             invokeRestart(restart)
[08:29:14.893]                             muffled <- TRUE
[08:29:14.893]                             break
[08:29:14.893]                           }
[08:29:14.893]                         }
[08:29:14.893]                       }
[08:29:14.893]                       invisible(muffled)
[08:29:14.893]                     }
[08:29:14.893]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.893]                   }
[08:29:14.893]                 }
[08:29:14.893]             }
[08:29:14.893]         }))
[08:29:14.893]     }, error = function(ex) {
[08:29:14.893]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:14.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.893]                 ...future.rng), started = ...future.startTime, 
[08:29:14.893]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:14.893]             version = "1.8"), class = "FutureResult")
[08:29:14.893]     }, finally = {
[08:29:14.893]         if (!identical(...future.workdir, getwd())) 
[08:29:14.893]             setwd(...future.workdir)
[08:29:14.893]         {
[08:29:14.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:14.893]                 ...future.oldOptions$nwarnings <- NULL
[08:29:14.893]             }
[08:29:14.893]             base::options(...future.oldOptions)
[08:29:14.893]             if (.Platform$OS.type == "windows") {
[08:29:14.893]                 old_names <- names(...future.oldEnvVars)
[08:29:14.893]                 envs <- base::Sys.getenv()
[08:29:14.893]                 names <- names(envs)
[08:29:14.893]                 common <- intersect(names, old_names)
[08:29:14.893]                 added <- setdiff(names, old_names)
[08:29:14.893]                 removed <- setdiff(old_names, names)
[08:29:14.893]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:14.893]                   envs[common]]
[08:29:14.893]                 NAMES <- toupper(changed)
[08:29:14.893]                 args <- list()
[08:29:14.893]                 for (kk in seq_along(NAMES)) {
[08:29:14.893]                   name <- changed[[kk]]
[08:29:14.893]                   NAME <- NAMES[[kk]]
[08:29:14.893]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.893]                     next
[08:29:14.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.893]                 }
[08:29:14.893]                 NAMES <- toupper(added)
[08:29:14.893]                 for (kk in seq_along(NAMES)) {
[08:29:14.893]                   name <- added[[kk]]
[08:29:14.893]                   NAME <- NAMES[[kk]]
[08:29:14.893]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.893]                     next
[08:29:14.893]                   args[[name]] <- ""
[08:29:14.893]                 }
[08:29:14.893]                 NAMES <- toupper(removed)
[08:29:14.893]                 for (kk in seq_along(NAMES)) {
[08:29:14.893]                   name <- removed[[kk]]
[08:29:14.893]                   NAME <- NAMES[[kk]]
[08:29:14.893]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.893]                     next
[08:29:14.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.893]                 }
[08:29:14.893]                 if (length(args) > 0) 
[08:29:14.893]                   base::do.call(base::Sys.setenv, args = args)
[08:29:14.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:14.893]             }
[08:29:14.893]             else {
[08:29:14.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:14.893]             }
[08:29:14.893]             {
[08:29:14.893]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:14.893]                   0L) {
[08:29:14.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:14.893]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:14.893]                   base::options(opts)
[08:29:14.893]                 }
[08:29:14.893]                 {
[08:29:14.893]                   {
[08:29:14.893]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:14.893]                     NULL
[08:29:14.893]                   }
[08:29:14.893]                   options(future.plan = NULL)
[08:29:14.893]                   if (is.na(NA_character_)) 
[08:29:14.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:14.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:14.893]                     .init = FALSE)
[08:29:14.893]                 }
[08:29:14.893]             }
[08:29:14.893]         }
[08:29:14.893]     })
[08:29:14.893]     if (TRUE) {
[08:29:14.893]         base::sink(type = "output", split = FALSE)
[08:29:14.893]         if (TRUE) {
[08:29:14.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:14.893]         }
[08:29:14.893]         else {
[08:29:14.893]             ...future.result["stdout"] <- base::list(NULL)
[08:29:14.893]         }
[08:29:14.893]         base::close(...future.stdout)
[08:29:14.893]         ...future.stdout <- NULL
[08:29:14.893]     }
[08:29:14.893]     ...future.result$conditions <- ...future.conditions
[08:29:14.893]     ...future.result$finished <- base::Sys.time()
[08:29:14.893]     ...future.result
[08:29:14.893] }
[08:29:14.896] MultisessionFuture started
[08:29:14.896] - Launch lazy future ... done
[08:29:14.896] run() for ‘MultisessionFuture’ ... done
[08:29:14.902] getGlobalsAndPackages() ...
[08:29:14.902] Searching for globals...
[08:29:14.903] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:14.903] Searching for globals ... DONE
[08:29:14.903] Resolving globals: FALSE
[08:29:14.903] 
[08:29:14.904] 
[08:29:14.904] getGlobalsAndPackages() ... DONE
- w/ exception ...
[08:29:14.904] getGlobalsAndPackages() ...
[08:29:14.904] Searching for globals...
[08:29:14.905] - globals found: [2] ‘list’, ‘stop’
[08:29:14.905] Searching for globals ... DONE
[08:29:14.905] Resolving globals: FALSE
[08:29:14.905] 
[08:29:14.905] 
[08:29:14.905] getGlobalsAndPackages() ... DONE
[08:29:14.905] run() for ‘Future’ ...
[08:29:14.905] - state: ‘created’
[08:29:14.906] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:14.919] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:14.919] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:14.919]   - Field: ‘node’
[08:29:14.920]   - Field: ‘label’
[08:29:14.920]   - Field: ‘local’
[08:29:14.920]   - Field: ‘owner’
[08:29:14.920]   - Field: ‘envir’
[08:29:14.920]   - Field: ‘workers’
[08:29:14.920]   - Field: ‘packages’
[08:29:14.920]   - Field: ‘gc’
[08:29:14.920]   - Field: ‘conditions’
[08:29:14.920]   - Field: ‘persistent’
[08:29:14.920]   - Field: ‘expr’
[08:29:14.920]   - Field: ‘uuid’
[08:29:14.920]   - Field: ‘seed’
[08:29:14.921]   - Field: ‘version’
[08:29:14.921]   - Field: ‘result’
[08:29:14.921]   - Field: ‘asynchronous’
[08:29:14.921]   - Field: ‘calls’
[08:29:14.921]   - Field: ‘globals’
[08:29:14.921]   - Field: ‘stdout’
[08:29:14.921]   - Field: ‘earlySignal’
[08:29:14.921]   - Field: ‘lazy’
[08:29:14.921]   - Field: ‘state’
[08:29:14.921] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:14.921] - Launch lazy future ...
[08:29:14.922] Packages needed by the future expression (n = 0): <none>
[08:29:14.922] Packages needed by future strategies (n = 0): <none>
[08:29:14.922] {
[08:29:14.922]     {
[08:29:14.922]         {
[08:29:14.922]             ...future.startTime <- base::Sys.time()
[08:29:14.922]             {
[08:29:14.922]                 {
[08:29:14.922]                   {
[08:29:14.922]                     {
[08:29:14.922]                       base::local({
[08:29:14.922]                         has_future <- base::requireNamespace("future", 
[08:29:14.922]                           quietly = TRUE)
[08:29:14.922]                         if (has_future) {
[08:29:14.922]                           ns <- base::getNamespace("future")
[08:29:14.922]                           version <- ns[[".package"]][["version"]]
[08:29:14.922]                           if (is.null(version)) 
[08:29:14.922]                             version <- utils::packageVersion("future")
[08:29:14.922]                         }
[08:29:14.922]                         else {
[08:29:14.922]                           version <- NULL
[08:29:14.922]                         }
[08:29:14.922]                         if (!has_future || version < "1.8.0") {
[08:29:14.922]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:14.922]                             "", base::R.version$version.string), 
[08:29:14.922]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:14.922]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:14.922]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:14.922]                               "release", "version")], collapse = " "), 
[08:29:14.922]                             hostname = base::Sys.info()[["nodename"]])
[08:29:14.922]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:14.922]                             info)
[08:29:14.922]                           info <- base::paste(info, collapse = "; ")
[08:29:14.922]                           if (!has_future) {
[08:29:14.922]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:14.922]                               info)
[08:29:14.922]                           }
[08:29:14.922]                           else {
[08:29:14.922]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:14.922]                               info, version)
[08:29:14.922]                           }
[08:29:14.922]                           base::stop(msg)
[08:29:14.922]                         }
[08:29:14.922]                       })
[08:29:14.922]                     }
[08:29:14.922]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:14.922]                     base::options(mc.cores = 1L)
[08:29:14.922]                   }
[08:29:14.922]                   ...future.strategy.old <- future::plan("list")
[08:29:14.922]                   options(future.plan = NULL)
[08:29:14.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:14.922]                 }
[08:29:14.922]                 ...future.workdir <- getwd()
[08:29:14.922]             }
[08:29:14.922]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:14.922]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:14.922]         }
[08:29:14.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:14.922]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:14.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:14.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:14.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:14.922]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:14.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:14.922]             base::names(...future.oldOptions))
[08:29:14.922]     }
[08:29:14.922]     if (FALSE) {
[08:29:14.922]     }
[08:29:14.922]     else {
[08:29:14.922]         if (TRUE) {
[08:29:14.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:14.922]                 open = "w")
[08:29:14.922]         }
[08:29:14.922]         else {
[08:29:14.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:14.922]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:14.922]         }
[08:29:14.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:14.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:14.922]             base::sink(type = "output", split = FALSE)
[08:29:14.922]             base::close(...future.stdout)
[08:29:14.922]         }, add = TRUE)
[08:29:14.922]     }
[08:29:14.922]     ...future.frame <- base::sys.nframe()
[08:29:14.922]     ...future.conditions <- base::list()
[08:29:14.922]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:14.922]     if (FALSE) {
[08:29:14.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:14.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:14.922]     }
[08:29:14.922]     ...future.result <- base::tryCatch({
[08:29:14.922]         base::withCallingHandlers({
[08:29:14.922]             ...future.value <- base::withVisible(base::local({
[08:29:14.922]                 ...future.makeSendCondition <- base::local({
[08:29:14.922]                   sendCondition <- NULL
[08:29:14.922]                   function(frame = 1L) {
[08:29:14.922]                     if (is.function(sendCondition)) 
[08:29:14.922]                       return(sendCondition)
[08:29:14.922]                     ns <- getNamespace("parallel")
[08:29:14.922]                     if (exists("sendData", mode = "function", 
[08:29:14.922]                       envir = ns)) {
[08:29:14.922]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:14.922]                         envir = ns)
[08:29:14.922]                       envir <- sys.frame(frame)
[08:29:14.922]                       master <- NULL
[08:29:14.922]                       while (!identical(envir, .GlobalEnv) && 
[08:29:14.922]                         !identical(envir, emptyenv())) {
[08:29:14.922]                         if (exists("master", mode = "list", envir = envir, 
[08:29:14.922]                           inherits = FALSE)) {
[08:29:14.922]                           master <- get("master", mode = "list", 
[08:29:14.922]                             envir = envir, inherits = FALSE)
[08:29:14.922]                           if (inherits(master, c("SOCKnode", 
[08:29:14.922]                             "SOCK0node"))) {
[08:29:14.922]                             sendCondition <<- function(cond) {
[08:29:14.922]                               data <- list(type = "VALUE", value = cond, 
[08:29:14.922]                                 success = TRUE)
[08:29:14.922]                               parallel_sendData(master, data)
[08:29:14.922]                             }
[08:29:14.922]                             return(sendCondition)
[08:29:14.922]                           }
[08:29:14.922]                         }
[08:29:14.922]                         frame <- frame + 1L
[08:29:14.922]                         envir <- sys.frame(frame)
[08:29:14.922]                       }
[08:29:14.922]                     }
[08:29:14.922]                     sendCondition <<- function(cond) NULL
[08:29:14.922]                   }
[08:29:14.922]                 })
[08:29:14.922]                 withCallingHandlers({
[08:29:14.922]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:14.922]                 }, immediateCondition = function(cond) {
[08:29:14.922]                   sendCondition <- ...future.makeSendCondition()
[08:29:14.922]                   sendCondition(cond)
[08:29:14.922]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.922]                   {
[08:29:14.922]                     inherits <- base::inherits
[08:29:14.922]                     invokeRestart <- base::invokeRestart
[08:29:14.922]                     is.null <- base::is.null
[08:29:14.922]                     muffled <- FALSE
[08:29:14.922]                     if (inherits(cond, "message")) {
[08:29:14.922]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:14.922]                       if (muffled) 
[08:29:14.922]                         invokeRestart("muffleMessage")
[08:29:14.922]                     }
[08:29:14.922]                     else if (inherits(cond, "warning")) {
[08:29:14.922]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:14.922]                       if (muffled) 
[08:29:14.922]                         invokeRestart("muffleWarning")
[08:29:14.922]                     }
[08:29:14.922]                     else if (inherits(cond, "condition")) {
[08:29:14.922]                       if (!is.null(pattern)) {
[08:29:14.922]                         computeRestarts <- base::computeRestarts
[08:29:14.922]                         grepl <- base::grepl
[08:29:14.922]                         restarts <- computeRestarts(cond)
[08:29:14.922]                         for (restart in restarts) {
[08:29:14.922]                           name <- restart$name
[08:29:14.922]                           if (is.null(name)) 
[08:29:14.922]                             next
[08:29:14.922]                           if (!grepl(pattern, name)) 
[08:29:14.922]                             next
[08:29:14.922]                           invokeRestart(restart)
[08:29:14.922]                           muffled <- TRUE
[08:29:14.922]                           break
[08:29:14.922]                         }
[08:29:14.922]                       }
[08:29:14.922]                     }
[08:29:14.922]                     invisible(muffled)
[08:29:14.922]                   }
[08:29:14.922]                   muffleCondition(cond)
[08:29:14.922]                 })
[08:29:14.922]             }))
[08:29:14.922]             future::FutureResult(value = ...future.value$value, 
[08:29:14.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.922]                   ...future.rng), globalenv = if (FALSE) 
[08:29:14.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:14.922]                     ...future.globalenv.names))
[08:29:14.922]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:14.922]         }, condition = base::local({
[08:29:14.922]             c <- base::c
[08:29:14.922]             inherits <- base::inherits
[08:29:14.922]             invokeRestart <- base::invokeRestart
[08:29:14.922]             length <- base::length
[08:29:14.922]             list <- base::list
[08:29:14.922]             seq.int <- base::seq.int
[08:29:14.922]             signalCondition <- base::signalCondition
[08:29:14.922]             sys.calls <- base::sys.calls
[08:29:14.922]             `[[` <- base::`[[`
[08:29:14.922]             `+` <- base::`+`
[08:29:14.922]             `<<-` <- base::`<<-`
[08:29:14.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:14.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:14.922]                   3L)]
[08:29:14.922]             }
[08:29:14.922]             function(cond) {
[08:29:14.922]                 is_error <- inherits(cond, "error")
[08:29:14.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:14.922]                   NULL)
[08:29:14.922]                 if (is_error) {
[08:29:14.922]                   sessionInformation <- function() {
[08:29:14.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:14.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:14.922]                       search = base::search(), system = base::Sys.info())
[08:29:14.922]                   }
[08:29:14.922]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:14.922]                     cond$call), session = sessionInformation(), 
[08:29:14.922]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:14.922]                   signalCondition(cond)
[08:29:14.922]                 }
[08:29:14.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:14.922]                 "immediateCondition"))) {
[08:29:14.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:14.922]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:14.922]                   if (TRUE && !signal) {
[08:29:14.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.922]                     {
[08:29:14.922]                       inherits <- base::inherits
[08:29:14.922]                       invokeRestart <- base::invokeRestart
[08:29:14.922]                       is.null <- base::is.null
[08:29:14.922]                       muffled <- FALSE
[08:29:14.922]                       if (inherits(cond, "message")) {
[08:29:14.922]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.922]                         if (muffled) 
[08:29:14.922]                           invokeRestart("muffleMessage")
[08:29:14.922]                       }
[08:29:14.922]                       else if (inherits(cond, "warning")) {
[08:29:14.922]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.922]                         if (muffled) 
[08:29:14.922]                           invokeRestart("muffleWarning")
[08:29:14.922]                       }
[08:29:14.922]                       else if (inherits(cond, "condition")) {
[08:29:14.922]                         if (!is.null(pattern)) {
[08:29:14.922]                           computeRestarts <- base::computeRestarts
[08:29:14.922]                           grepl <- base::grepl
[08:29:14.922]                           restarts <- computeRestarts(cond)
[08:29:14.922]                           for (restart in restarts) {
[08:29:14.922]                             name <- restart$name
[08:29:14.922]                             if (is.null(name)) 
[08:29:14.922]                               next
[08:29:14.922]                             if (!grepl(pattern, name)) 
[08:29:14.922]                               next
[08:29:14.922]                             invokeRestart(restart)
[08:29:14.922]                             muffled <- TRUE
[08:29:14.922]                             break
[08:29:14.922]                           }
[08:29:14.922]                         }
[08:29:14.922]                       }
[08:29:14.922]                       invisible(muffled)
[08:29:14.922]                     }
[08:29:14.922]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.922]                   }
[08:29:14.922]                 }
[08:29:14.922]                 else {
[08:29:14.922]                   if (TRUE) {
[08:29:14.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.922]                     {
[08:29:14.922]                       inherits <- base::inherits
[08:29:14.922]                       invokeRestart <- base::invokeRestart
[08:29:14.922]                       is.null <- base::is.null
[08:29:14.922]                       muffled <- FALSE
[08:29:14.922]                       if (inherits(cond, "message")) {
[08:29:14.922]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.922]                         if (muffled) 
[08:29:14.922]                           invokeRestart("muffleMessage")
[08:29:14.922]                       }
[08:29:14.922]                       else if (inherits(cond, "warning")) {
[08:29:14.922]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.922]                         if (muffled) 
[08:29:14.922]                           invokeRestart("muffleWarning")
[08:29:14.922]                       }
[08:29:14.922]                       else if (inherits(cond, "condition")) {
[08:29:14.922]                         if (!is.null(pattern)) {
[08:29:14.922]                           computeRestarts <- base::computeRestarts
[08:29:14.922]                           grepl <- base::grepl
[08:29:14.922]                           restarts <- computeRestarts(cond)
[08:29:14.922]                           for (restart in restarts) {
[08:29:14.922]                             name <- restart$name
[08:29:14.922]                             if (is.null(name)) 
[08:29:14.922]                               next
[08:29:14.922]                             if (!grepl(pattern, name)) 
[08:29:14.922]                               next
[08:29:14.922]                             invokeRestart(restart)
[08:29:14.922]                             muffled <- TRUE
[08:29:14.922]                             break
[08:29:14.922]                           }
[08:29:14.922]                         }
[08:29:14.922]                       }
[08:29:14.922]                       invisible(muffled)
[08:29:14.922]                     }
[08:29:14.922]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.922]                   }
[08:29:14.922]                 }
[08:29:14.922]             }
[08:29:14.922]         }))
[08:29:14.922]     }, error = function(ex) {
[08:29:14.922]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:14.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.922]                 ...future.rng), started = ...future.startTime, 
[08:29:14.922]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:14.922]             version = "1.8"), class = "FutureResult")
[08:29:14.922]     }, finally = {
[08:29:14.922]         if (!identical(...future.workdir, getwd())) 
[08:29:14.922]             setwd(...future.workdir)
[08:29:14.922]         {
[08:29:14.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:14.922]                 ...future.oldOptions$nwarnings <- NULL
[08:29:14.922]             }
[08:29:14.922]             base::options(...future.oldOptions)
[08:29:14.922]             if (.Platform$OS.type == "windows") {
[08:29:14.922]                 old_names <- names(...future.oldEnvVars)
[08:29:14.922]                 envs <- base::Sys.getenv()
[08:29:14.922]                 names <- names(envs)
[08:29:14.922]                 common <- intersect(names, old_names)
[08:29:14.922]                 added <- setdiff(names, old_names)
[08:29:14.922]                 removed <- setdiff(old_names, names)
[08:29:14.922]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:14.922]                   envs[common]]
[08:29:14.922]                 NAMES <- toupper(changed)
[08:29:14.922]                 args <- list()
[08:29:14.922]                 for (kk in seq_along(NAMES)) {
[08:29:14.922]                   name <- changed[[kk]]
[08:29:14.922]                   NAME <- NAMES[[kk]]
[08:29:14.922]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.922]                     next
[08:29:14.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.922]                 }
[08:29:14.922]                 NAMES <- toupper(added)
[08:29:14.922]                 for (kk in seq_along(NAMES)) {
[08:29:14.922]                   name <- added[[kk]]
[08:29:14.922]                   NAME <- NAMES[[kk]]
[08:29:14.922]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.922]                     next
[08:29:14.922]                   args[[name]] <- ""
[08:29:14.922]                 }
[08:29:14.922]                 NAMES <- toupper(removed)
[08:29:14.922]                 for (kk in seq_along(NAMES)) {
[08:29:14.922]                   name <- removed[[kk]]
[08:29:14.922]                   NAME <- NAMES[[kk]]
[08:29:14.922]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.922]                     next
[08:29:14.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.922]                 }
[08:29:14.922]                 if (length(args) > 0) 
[08:29:14.922]                   base::do.call(base::Sys.setenv, args = args)
[08:29:14.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:14.922]             }
[08:29:14.922]             else {
[08:29:14.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:14.922]             }
[08:29:14.922]             {
[08:29:14.922]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:14.922]                   0L) {
[08:29:14.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:14.922]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:14.922]                   base::options(opts)
[08:29:14.922]                 }
[08:29:14.922]                 {
[08:29:14.922]                   {
[08:29:14.922]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:14.922]                     NULL
[08:29:14.922]                   }
[08:29:14.922]                   options(future.plan = NULL)
[08:29:14.922]                   if (is.na(NA_character_)) 
[08:29:14.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:14.922]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:14.922]                     .init = FALSE)
[08:29:14.922]                 }
[08:29:14.922]             }
[08:29:14.922]         }
[08:29:14.922]     })
[08:29:14.922]     if (TRUE) {
[08:29:14.922]         base::sink(type = "output", split = FALSE)
[08:29:14.922]         if (TRUE) {
[08:29:14.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:14.922]         }
[08:29:14.922]         else {
[08:29:14.922]             ...future.result["stdout"] <- base::list(NULL)
[08:29:14.922]         }
[08:29:14.922]         base::close(...future.stdout)
[08:29:14.922]         ...future.stdout <- NULL
[08:29:14.922]     }
[08:29:14.922]     ...future.result$conditions <- ...future.conditions
[08:29:14.922]     ...future.result$finished <- base::Sys.time()
[08:29:14.922]     ...future.result
[08:29:14.922] }
[08:29:14.924] Poll #1 (0): usedNodes() = 2, workers = 2
[08:29:14.935] receiveMessageFromWorker() for ClusterFuture ...
[08:29:14.935] - Validating connection of MultisessionFuture
[08:29:14.935] - received message: FutureResult
[08:29:14.935] - Received FutureResult
[08:29:14.936] - Erased future from FutureRegistry
[08:29:14.936] result() for ClusterFuture ...
[08:29:14.936] - result already collected: FutureResult
[08:29:14.936] result() for ClusterFuture ... done
[08:29:14.936] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:14.936] result() for ClusterFuture ...
[08:29:14.936] - result already collected: FutureResult
[08:29:14.936] result() for ClusterFuture ... done
[08:29:14.936] result() for ClusterFuture ...
[08:29:14.936] - result already collected: FutureResult
[08:29:14.936] result() for ClusterFuture ... done
[08:29:14.938] MultisessionFuture started
[08:29:14.938] - Launch lazy future ... done
[08:29:14.938] run() for ‘MultisessionFuture’ ... done
[08:29:14.938] getGlobalsAndPackages() ...
[08:29:14.938] Searching for globals...
[08:29:14.939] - globals found: [2] ‘list’, ‘stop’
[08:29:14.939] Searching for globals ... DONE
[08:29:14.939] Resolving globals: FALSE
[08:29:14.939] 
[08:29:14.939] 
[08:29:14.939] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[08:29:14.940] getGlobalsAndPackages() ...
[08:29:14.940] Searching for globals...
[08:29:14.941] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:14.941] Searching for globals ... DONE
[08:29:14.941] Resolving globals: FALSE
[08:29:14.941] 
[08:29:14.941] 
[08:29:14.941] getGlobalsAndPackages() ... DONE
[08:29:14.942] run() for ‘Future’ ...
[08:29:14.942] - state: ‘created’
[08:29:14.942] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:14.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:14.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:14.956]   - Field: ‘node’
[08:29:14.956]   - Field: ‘label’
[08:29:14.956]   - Field: ‘local’
[08:29:14.956]   - Field: ‘owner’
[08:29:14.956]   - Field: ‘envir’
[08:29:14.956]   - Field: ‘workers’
[08:29:14.956]   - Field: ‘packages’
[08:29:14.956]   - Field: ‘gc’
[08:29:14.956]   - Field: ‘conditions’
[08:29:14.956]   - Field: ‘persistent’
[08:29:14.956]   - Field: ‘expr’
[08:29:14.957]   - Field: ‘uuid’
[08:29:14.957]   - Field: ‘seed’
[08:29:14.957]   - Field: ‘version’
[08:29:14.957]   - Field: ‘result’
[08:29:14.957]   - Field: ‘asynchronous’
[08:29:14.957]   - Field: ‘calls’
[08:29:14.957]   - Field: ‘globals’
[08:29:14.957]   - Field: ‘stdout’
[08:29:14.957]   - Field: ‘earlySignal’
[08:29:14.957]   - Field: ‘lazy’
[08:29:14.957]   - Field: ‘state’
[08:29:14.958] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:14.958] - Launch lazy future ...
[08:29:14.958] Packages needed by the future expression (n = 0): <none>
[08:29:14.958] Packages needed by future strategies (n = 0): <none>
[08:29:14.958] {
[08:29:14.958]     {
[08:29:14.958]         {
[08:29:14.958]             ...future.startTime <- base::Sys.time()
[08:29:14.958]             {
[08:29:14.958]                 {
[08:29:14.958]                   {
[08:29:14.958]                     {
[08:29:14.958]                       base::local({
[08:29:14.958]                         has_future <- base::requireNamespace("future", 
[08:29:14.958]                           quietly = TRUE)
[08:29:14.958]                         if (has_future) {
[08:29:14.958]                           ns <- base::getNamespace("future")
[08:29:14.958]                           version <- ns[[".package"]][["version"]]
[08:29:14.958]                           if (is.null(version)) 
[08:29:14.958]                             version <- utils::packageVersion("future")
[08:29:14.958]                         }
[08:29:14.958]                         else {
[08:29:14.958]                           version <- NULL
[08:29:14.958]                         }
[08:29:14.958]                         if (!has_future || version < "1.8.0") {
[08:29:14.958]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:14.958]                             "", base::R.version$version.string), 
[08:29:14.958]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:14.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:14.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:14.958]                               "release", "version")], collapse = " "), 
[08:29:14.958]                             hostname = base::Sys.info()[["nodename"]])
[08:29:14.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:14.958]                             info)
[08:29:14.958]                           info <- base::paste(info, collapse = "; ")
[08:29:14.958]                           if (!has_future) {
[08:29:14.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:14.958]                               info)
[08:29:14.958]                           }
[08:29:14.958]                           else {
[08:29:14.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:14.958]                               info, version)
[08:29:14.958]                           }
[08:29:14.958]                           base::stop(msg)
[08:29:14.958]                         }
[08:29:14.958]                       })
[08:29:14.958]                     }
[08:29:14.958]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:14.958]                     base::options(mc.cores = 1L)
[08:29:14.958]                   }
[08:29:14.958]                   ...future.strategy.old <- future::plan("list")
[08:29:14.958]                   options(future.plan = NULL)
[08:29:14.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:14.958]                 }
[08:29:14.958]                 ...future.workdir <- getwd()
[08:29:14.958]             }
[08:29:14.958]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:14.958]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:14.958]         }
[08:29:14.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:14.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:14.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:14.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:14.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:14.958]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:14.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:14.958]             base::names(...future.oldOptions))
[08:29:14.958]     }
[08:29:14.958]     if (FALSE) {
[08:29:14.958]     }
[08:29:14.958]     else {
[08:29:14.958]         if (TRUE) {
[08:29:14.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:14.958]                 open = "w")
[08:29:14.958]         }
[08:29:14.958]         else {
[08:29:14.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:14.958]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:14.958]         }
[08:29:14.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:14.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:14.958]             base::sink(type = "output", split = FALSE)
[08:29:14.958]             base::close(...future.stdout)
[08:29:14.958]         }, add = TRUE)
[08:29:14.958]     }
[08:29:14.958]     ...future.frame <- base::sys.nframe()
[08:29:14.958]     ...future.conditions <- base::list()
[08:29:14.958]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:14.958]     if (FALSE) {
[08:29:14.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:14.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:14.958]     }
[08:29:14.958]     ...future.result <- base::tryCatch({
[08:29:14.958]         base::withCallingHandlers({
[08:29:14.958]             ...future.value <- base::withVisible(base::local({
[08:29:14.958]                 ...future.makeSendCondition <- base::local({
[08:29:14.958]                   sendCondition <- NULL
[08:29:14.958]                   function(frame = 1L) {
[08:29:14.958]                     if (is.function(sendCondition)) 
[08:29:14.958]                       return(sendCondition)
[08:29:14.958]                     ns <- getNamespace("parallel")
[08:29:14.958]                     if (exists("sendData", mode = "function", 
[08:29:14.958]                       envir = ns)) {
[08:29:14.958]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:14.958]                         envir = ns)
[08:29:14.958]                       envir <- sys.frame(frame)
[08:29:14.958]                       master <- NULL
[08:29:14.958]                       while (!identical(envir, .GlobalEnv) && 
[08:29:14.958]                         !identical(envir, emptyenv())) {
[08:29:14.958]                         if (exists("master", mode = "list", envir = envir, 
[08:29:14.958]                           inherits = FALSE)) {
[08:29:14.958]                           master <- get("master", mode = "list", 
[08:29:14.958]                             envir = envir, inherits = FALSE)
[08:29:14.958]                           if (inherits(master, c("SOCKnode", 
[08:29:14.958]                             "SOCK0node"))) {
[08:29:14.958]                             sendCondition <<- function(cond) {
[08:29:14.958]                               data <- list(type = "VALUE", value = cond, 
[08:29:14.958]                                 success = TRUE)
[08:29:14.958]                               parallel_sendData(master, data)
[08:29:14.958]                             }
[08:29:14.958]                             return(sendCondition)
[08:29:14.958]                           }
[08:29:14.958]                         }
[08:29:14.958]                         frame <- frame + 1L
[08:29:14.958]                         envir <- sys.frame(frame)
[08:29:14.958]                       }
[08:29:14.958]                     }
[08:29:14.958]                     sendCondition <<- function(cond) NULL
[08:29:14.958]                   }
[08:29:14.958]                 })
[08:29:14.958]                 withCallingHandlers({
[08:29:14.958]                   {
[08:29:14.958]                     Sys.sleep(0.5)
[08:29:14.958]                     list(a = 1, b = 42L)
[08:29:14.958]                   }
[08:29:14.958]                 }, immediateCondition = function(cond) {
[08:29:14.958]                   sendCondition <- ...future.makeSendCondition()
[08:29:14.958]                   sendCondition(cond)
[08:29:14.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.958]                   {
[08:29:14.958]                     inherits <- base::inherits
[08:29:14.958]                     invokeRestart <- base::invokeRestart
[08:29:14.958]                     is.null <- base::is.null
[08:29:14.958]                     muffled <- FALSE
[08:29:14.958]                     if (inherits(cond, "message")) {
[08:29:14.958]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:14.958]                       if (muffled) 
[08:29:14.958]                         invokeRestart("muffleMessage")
[08:29:14.958]                     }
[08:29:14.958]                     else if (inherits(cond, "warning")) {
[08:29:14.958]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:14.958]                       if (muffled) 
[08:29:14.958]                         invokeRestart("muffleWarning")
[08:29:14.958]                     }
[08:29:14.958]                     else if (inherits(cond, "condition")) {
[08:29:14.958]                       if (!is.null(pattern)) {
[08:29:14.958]                         computeRestarts <- base::computeRestarts
[08:29:14.958]                         grepl <- base::grepl
[08:29:14.958]                         restarts <- computeRestarts(cond)
[08:29:14.958]                         for (restart in restarts) {
[08:29:14.958]                           name <- restart$name
[08:29:14.958]                           if (is.null(name)) 
[08:29:14.958]                             next
[08:29:14.958]                           if (!grepl(pattern, name)) 
[08:29:14.958]                             next
[08:29:14.958]                           invokeRestart(restart)
[08:29:14.958]                           muffled <- TRUE
[08:29:14.958]                           break
[08:29:14.958]                         }
[08:29:14.958]                       }
[08:29:14.958]                     }
[08:29:14.958]                     invisible(muffled)
[08:29:14.958]                   }
[08:29:14.958]                   muffleCondition(cond)
[08:29:14.958]                 })
[08:29:14.958]             }))
[08:29:14.958]             future::FutureResult(value = ...future.value$value, 
[08:29:14.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.958]                   ...future.rng), globalenv = if (FALSE) 
[08:29:14.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:14.958]                     ...future.globalenv.names))
[08:29:14.958]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:14.958]         }, condition = base::local({
[08:29:14.958]             c <- base::c
[08:29:14.958]             inherits <- base::inherits
[08:29:14.958]             invokeRestart <- base::invokeRestart
[08:29:14.958]             length <- base::length
[08:29:14.958]             list <- base::list
[08:29:14.958]             seq.int <- base::seq.int
[08:29:14.958]             signalCondition <- base::signalCondition
[08:29:14.958]             sys.calls <- base::sys.calls
[08:29:14.958]             `[[` <- base::`[[`
[08:29:14.958]             `+` <- base::`+`
[08:29:14.958]             `<<-` <- base::`<<-`
[08:29:14.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:14.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:14.958]                   3L)]
[08:29:14.958]             }
[08:29:14.958]             function(cond) {
[08:29:14.958]                 is_error <- inherits(cond, "error")
[08:29:14.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:14.958]                   NULL)
[08:29:14.958]                 if (is_error) {
[08:29:14.958]                   sessionInformation <- function() {
[08:29:14.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:14.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:14.958]                       search = base::search(), system = base::Sys.info())
[08:29:14.958]                   }
[08:29:14.958]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:14.958]                     cond$call), session = sessionInformation(), 
[08:29:14.958]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:14.958]                   signalCondition(cond)
[08:29:14.958]                 }
[08:29:14.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:14.958]                 "immediateCondition"))) {
[08:29:14.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:14.958]                   ...future.conditions[[length(...future.conditions) + 
[08:29:14.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:14.958]                   if (TRUE && !signal) {
[08:29:14.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.958]                     {
[08:29:14.958]                       inherits <- base::inherits
[08:29:14.958]                       invokeRestart <- base::invokeRestart
[08:29:14.958]                       is.null <- base::is.null
[08:29:14.958]                       muffled <- FALSE
[08:29:14.958]                       if (inherits(cond, "message")) {
[08:29:14.958]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.958]                         if (muffled) 
[08:29:14.958]                           invokeRestart("muffleMessage")
[08:29:14.958]                       }
[08:29:14.958]                       else if (inherits(cond, "warning")) {
[08:29:14.958]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.958]                         if (muffled) 
[08:29:14.958]                           invokeRestart("muffleWarning")
[08:29:14.958]                       }
[08:29:14.958]                       else if (inherits(cond, "condition")) {
[08:29:14.958]                         if (!is.null(pattern)) {
[08:29:14.958]                           computeRestarts <- base::computeRestarts
[08:29:14.958]                           grepl <- base::grepl
[08:29:14.958]                           restarts <- computeRestarts(cond)
[08:29:14.958]                           for (restart in restarts) {
[08:29:14.958]                             name <- restart$name
[08:29:14.958]                             if (is.null(name)) 
[08:29:14.958]                               next
[08:29:14.958]                             if (!grepl(pattern, name)) 
[08:29:14.958]                               next
[08:29:14.958]                             invokeRestart(restart)
[08:29:14.958]                             muffled <- TRUE
[08:29:14.958]                             break
[08:29:14.958]                           }
[08:29:14.958]                         }
[08:29:14.958]                       }
[08:29:14.958]                       invisible(muffled)
[08:29:14.958]                     }
[08:29:14.958]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.958]                   }
[08:29:14.958]                 }
[08:29:14.958]                 else {
[08:29:14.958]                   if (TRUE) {
[08:29:14.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:14.958]                     {
[08:29:14.958]                       inherits <- base::inherits
[08:29:14.958]                       invokeRestart <- base::invokeRestart
[08:29:14.958]                       is.null <- base::is.null
[08:29:14.958]                       muffled <- FALSE
[08:29:14.958]                       if (inherits(cond, "message")) {
[08:29:14.958]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:14.958]                         if (muffled) 
[08:29:14.958]                           invokeRestart("muffleMessage")
[08:29:14.958]                       }
[08:29:14.958]                       else if (inherits(cond, "warning")) {
[08:29:14.958]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:14.958]                         if (muffled) 
[08:29:14.958]                           invokeRestart("muffleWarning")
[08:29:14.958]                       }
[08:29:14.958]                       else if (inherits(cond, "condition")) {
[08:29:14.958]                         if (!is.null(pattern)) {
[08:29:14.958]                           computeRestarts <- base::computeRestarts
[08:29:14.958]                           grepl <- base::grepl
[08:29:14.958]                           restarts <- computeRestarts(cond)
[08:29:14.958]                           for (restart in restarts) {
[08:29:14.958]                             name <- restart$name
[08:29:14.958]                             if (is.null(name)) 
[08:29:14.958]                               next
[08:29:14.958]                             if (!grepl(pattern, name)) 
[08:29:14.958]                               next
[08:29:14.958]                             invokeRestart(restart)
[08:29:14.958]                             muffled <- TRUE
[08:29:14.958]                             break
[08:29:14.958]                           }
[08:29:14.958]                         }
[08:29:14.958]                       }
[08:29:14.958]                       invisible(muffled)
[08:29:14.958]                     }
[08:29:14.958]                     muffleCondition(cond, pattern = "^muffle")
[08:29:14.958]                   }
[08:29:14.958]                 }
[08:29:14.958]             }
[08:29:14.958]         }))
[08:29:14.958]     }, error = function(ex) {
[08:29:14.958]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:14.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:14.958]                 ...future.rng), started = ...future.startTime, 
[08:29:14.958]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:14.958]             version = "1.8"), class = "FutureResult")
[08:29:14.958]     }, finally = {
[08:29:14.958]         if (!identical(...future.workdir, getwd())) 
[08:29:14.958]             setwd(...future.workdir)
[08:29:14.958]         {
[08:29:14.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:14.958]                 ...future.oldOptions$nwarnings <- NULL
[08:29:14.958]             }
[08:29:14.958]             base::options(...future.oldOptions)
[08:29:14.958]             if (.Platform$OS.type == "windows") {
[08:29:14.958]                 old_names <- names(...future.oldEnvVars)
[08:29:14.958]                 envs <- base::Sys.getenv()
[08:29:14.958]                 names <- names(envs)
[08:29:14.958]                 common <- intersect(names, old_names)
[08:29:14.958]                 added <- setdiff(names, old_names)
[08:29:14.958]                 removed <- setdiff(old_names, names)
[08:29:14.958]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:14.958]                   envs[common]]
[08:29:14.958]                 NAMES <- toupper(changed)
[08:29:14.958]                 args <- list()
[08:29:14.958]                 for (kk in seq_along(NAMES)) {
[08:29:14.958]                   name <- changed[[kk]]
[08:29:14.958]                   NAME <- NAMES[[kk]]
[08:29:14.958]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.958]                     next
[08:29:14.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.958]                 }
[08:29:14.958]                 NAMES <- toupper(added)
[08:29:14.958]                 for (kk in seq_along(NAMES)) {
[08:29:14.958]                   name <- added[[kk]]
[08:29:14.958]                   NAME <- NAMES[[kk]]
[08:29:14.958]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.958]                     next
[08:29:14.958]                   args[[name]] <- ""
[08:29:14.958]                 }
[08:29:14.958]                 NAMES <- toupper(removed)
[08:29:14.958]                 for (kk in seq_along(NAMES)) {
[08:29:14.958]                   name <- removed[[kk]]
[08:29:14.958]                   NAME <- NAMES[[kk]]
[08:29:14.958]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:14.958]                     next
[08:29:14.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:14.958]                 }
[08:29:14.958]                 if (length(args) > 0) 
[08:29:14.958]                   base::do.call(base::Sys.setenv, args = args)
[08:29:14.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:14.958]             }
[08:29:14.958]             else {
[08:29:14.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:14.958]             }
[08:29:14.958]             {
[08:29:14.958]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:14.958]                   0L) {
[08:29:14.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:14.958]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:14.958]                   base::options(opts)
[08:29:14.958]                 }
[08:29:14.958]                 {
[08:29:14.958]                   {
[08:29:14.958]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:14.958]                     NULL
[08:29:14.958]                   }
[08:29:14.958]                   options(future.plan = NULL)
[08:29:14.958]                   if (is.na(NA_character_)) 
[08:29:14.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:14.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:14.958]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:14.958]                     .init = FALSE)
[08:29:14.958]                 }
[08:29:14.958]             }
[08:29:14.958]         }
[08:29:14.958]     })
[08:29:14.958]     if (TRUE) {
[08:29:14.958]         base::sink(type = "output", split = FALSE)
[08:29:14.958]         if (TRUE) {
[08:29:14.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:14.958]         }
[08:29:14.958]         else {
[08:29:14.958]             ...future.result["stdout"] <- base::list(NULL)
[08:29:14.958]         }
[08:29:14.958]         base::close(...future.stdout)
[08:29:14.958]         ...future.stdout <- NULL
[08:29:14.958]     }
[08:29:14.958]     ...future.result$conditions <- ...future.conditions
[08:29:14.958]     ...future.result$finished <- base::Sys.time()
[08:29:14.958]     ...future.result
[08:29:14.958] }
[08:29:14.961] Poll #1 (0): usedNodes() = 2, workers = 2
[08:29:14.982] receiveMessageFromWorker() for ClusterFuture ...
[08:29:14.982] - Validating connection of MultisessionFuture
[08:29:14.982] - received message: FutureResult
[08:29:14.982] - Received FutureResult
[08:29:14.983] - Erased future from FutureRegistry
[08:29:14.983] result() for ClusterFuture ...
[08:29:14.983] - result already collected: FutureResult
[08:29:14.983] result() for ClusterFuture ... done
[08:29:14.983] signalConditions() ...
[08:29:14.983]  - include = ‘immediateCondition’
[08:29:14.983]  - exclude = 
[08:29:14.983]  - resignal = FALSE
[08:29:14.983]  - Number of conditions: 1
[08:29:14.983] signalConditions() ... done
[08:29:14.983] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:14.983] result() for ClusterFuture ...
[08:29:14.984] - result already collected: FutureResult
[08:29:14.984] result() for ClusterFuture ... done
[08:29:14.984] result() for ClusterFuture ...
[08:29:14.984] - result already collected: FutureResult
[08:29:14.984] result() for ClusterFuture ... done
[08:29:14.984] signalConditions() ...
[08:29:14.984]  - include = ‘immediateCondition’
[08:29:14.984]  - exclude = 
[08:29:14.984]  - resignal = FALSE
[08:29:14.984]  - Number of conditions: 1
[08:29:14.984] signalConditions() ... done
[08:29:14.985] MultisessionFuture started
[08:29:14.986] - Launch lazy future ... done
[08:29:14.986] run() for ‘MultisessionFuture’ ... done
[08:29:15.528] receiveMessageFromWorker() for ClusterFuture ...
[08:29:15.528] - Validating connection of MultisessionFuture
[08:29:15.528] - received message: FutureResult
[08:29:15.528] - Received FutureResult
[08:29:15.528] - Erased future from FutureRegistry
[08:29:15.529] result() for ClusterFuture ...
[08:29:15.529] - result already collected: FutureResult
[08:29:15.529] result() for ClusterFuture ... done
[08:29:15.529] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:15.529] A MultisessionFuture was resolved
[08:29:15.529] getGlobalsAndPackages() ...
[08:29:15.529] Searching for globals...
[08:29:15.530] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:15.530] Searching for globals ... DONE
[08:29:15.530] Resolving globals: FALSE
[08:29:15.531] 
[08:29:15.531] 
[08:29:15.531] getGlobalsAndPackages() ... DONE
[08:29:15.531] run() for ‘Future’ ...
[08:29:15.531] - state: ‘created’
[08:29:15.531] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:15.545] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:15.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:15.545]   - Field: ‘node’
[08:29:15.546]   - Field: ‘label’
[08:29:15.546]   - Field: ‘local’
[08:29:15.546]   - Field: ‘owner’
[08:29:15.546]   - Field: ‘envir’
[08:29:15.546]   - Field: ‘workers’
[08:29:15.546]   - Field: ‘packages’
[08:29:15.546]   - Field: ‘gc’
[08:29:15.546]   - Field: ‘conditions’
[08:29:15.546]   - Field: ‘persistent’
[08:29:15.546]   - Field: ‘expr’
[08:29:15.546]   - Field: ‘uuid’
[08:29:15.546]   - Field: ‘seed’
[08:29:15.547]   - Field: ‘version’
[08:29:15.547]   - Field: ‘result’
[08:29:15.547]   - Field: ‘asynchronous’
[08:29:15.547]   - Field: ‘calls’
[08:29:15.547]   - Field: ‘globals’
[08:29:15.547]   - Field: ‘stdout’
[08:29:15.547]   - Field: ‘earlySignal’
[08:29:15.547]   - Field: ‘lazy’
[08:29:15.547]   - Field: ‘state’
[08:29:15.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:15.547] - Launch lazy future ...
[08:29:15.548] Packages needed by the future expression (n = 0): <none>
[08:29:15.548] Packages needed by future strategies (n = 0): <none>
[08:29:15.548] {
[08:29:15.548]     {
[08:29:15.548]         {
[08:29:15.548]             ...future.startTime <- base::Sys.time()
[08:29:15.548]             {
[08:29:15.548]                 {
[08:29:15.548]                   {
[08:29:15.548]                     {
[08:29:15.548]                       base::local({
[08:29:15.548]                         has_future <- base::requireNamespace("future", 
[08:29:15.548]                           quietly = TRUE)
[08:29:15.548]                         if (has_future) {
[08:29:15.548]                           ns <- base::getNamespace("future")
[08:29:15.548]                           version <- ns[[".package"]][["version"]]
[08:29:15.548]                           if (is.null(version)) 
[08:29:15.548]                             version <- utils::packageVersion("future")
[08:29:15.548]                         }
[08:29:15.548]                         else {
[08:29:15.548]                           version <- NULL
[08:29:15.548]                         }
[08:29:15.548]                         if (!has_future || version < "1.8.0") {
[08:29:15.548]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:15.548]                             "", base::R.version$version.string), 
[08:29:15.548]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:15.548]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:15.548]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:15.548]                               "release", "version")], collapse = " "), 
[08:29:15.548]                             hostname = base::Sys.info()[["nodename"]])
[08:29:15.548]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:15.548]                             info)
[08:29:15.548]                           info <- base::paste(info, collapse = "; ")
[08:29:15.548]                           if (!has_future) {
[08:29:15.548]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:15.548]                               info)
[08:29:15.548]                           }
[08:29:15.548]                           else {
[08:29:15.548]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:15.548]                               info, version)
[08:29:15.548]                           }
[08:29:15.548]                           base::stop(msg)
[08:29:15.548]                         }
[08:29:15.548]                       })
[08:29:15.548]                     }
[08:29:15.548]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:15.548]                     base::options(mc.cores = 1L)
[08:29:15.548]                   }
[08:29:15.548]                   ...future.strategy.old <- future::plan("list")
[08:29:15.548]                   options(future.plan = NULL)
[08:29:15.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:15.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:15.548]                 }
[08:29:15.548]                 ...future.workdir <- getwd()
[08:29:15.548]             }
[08:29:15.548]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:15.548]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:15.548]         }
[08:29:15.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:15.548]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:15.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:15.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:15.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:15.548]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:15.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:15.548]             base::names(...future.oldOptions))
[08:29:15.548]     }
[08:29:15.548]     if (FALSE) {
[08:29:15.548]     }
[08:29:15.548]     else {
[08:29:15.548]         if (TRUE) {
[08:29:15.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:15.548]                 open = "w")
[08:29:15.548]         }
[08:29:15.548]         else {
[08:29:15.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:15.548]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:15.548]         }
[08:29:15.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:15.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:15.548]             base::sink(type = "output", split = FALSE)
[08:29:15.548]             base::close(...future.stdout)
[08:29:15.548]         }, add = TRUE)
[08:29:15.548]     }
[08:29:15.548]     ...future.frame <- base::sys.nframe()
[08:29:15.548]     ...future.conditions <- base::list()
[08:29:15.548]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:15.548]     if (FALSE) {
[08:29:15.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:15.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:15.548]     }
[08:29:15.548]     ...future.result <- base::tryCatch({
[08:29:15.548]         base::withCallingHandlers({
[08:29:15.548]             ...future.value <- base::withVisible(base::local({
[08:29:15.548]                 ...future.makeSendCondition <- base::local({
[08:29:15.548]                   sendCondition <- NULL
[08:29:15.548]                   function(frame = 1L) {
[08:29:15.548]                     if (is.function(sendCondition)) 
[08:29:15.548]                       return(sendCondition)
[08:29:15.548]                     ns <- getNamespace("parallel")
[08:29:15.548]                     if (exists("sendData", mode = "function", 
[08:29:15.548]                       envir = ns)) {
[08:29:15.548]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:15.548]                         envir = ns)
[08:29:15.548]                       envir <- sys.frame(frame)
[08:29:15.548]                       master <- NULL
[08:29:15.548]                       while (!identical(envir, .GlobalEnv) && 
[08:29:15.548]                         !identical(envir, emptyenv())) {
[08:29:15.548]                         if (exists("master", mode = "list", envir = envir, 
[08:29:15.548]                           inherits = FALSE)) {
[08:29:15.548]                           master <- get("master", mode = "list", 
[08:29:15.548]                             envir = envir, inherits = FALSE)
[08:29:15.548]                           if (inherits(master, c("SOCKnode", 
[08:29:15.548]                             "SOCK0node"))) {
[08:29:15.548]                             sendCondition <<- function(cond) {
[08:29:15.548]                               data <- list(type = "VALUE", value = cond, 
[08:29:15.548]                                 success = TRUE)
[08:29:15.548]                               parallel_sendData(master, data)
[08:29:15.548]                             }
[08:29:15.548]                             return(sendCondition)
[08:29:15.548]                           }
[08:29:15.548]                         }
[08:29:15.548]                         frame <- frame + 1L
[08:29:15.548]                         envir <- sys.frame(frame)
[08:29:15.548]                       }
[08:29:15.548]                     }
[08:29:15.548]                     sendCondition <<- function(cond) NULL
[08:29:15.548]                   }
[08:29:15.548]                 })
[08:29:15.548]                 withCallingHandlers({
[08:29:15.548]                   {
[08:29:15.548]                     Sys.sleep(0.5)
[08:29:15.548]                     list(a = 1, b = 42L)
[08:29:15.548]                   }
[08:29:15.548]                 }, immediateCondition = function(cond) {
[08:29:15.548]                   sendCondition <- ...future.makeSendCondition()
[08:29:15.548]                   sendCondition(cond)
[08:29:15.548]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:15.548]                   {
[08:29:15.548]                     inherits <- base::inherits
[08:29:15.548]                     invokeRestart <- base::invokeRestart
[08:29:15.548]                     is.null <- base::is.null
[08:29:15.548]                     muffled <- FALSE
[08:29:15.548]                     if (inherits(cond, "message")) {
[08:29:15.548]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:15.548]                       if (muffled) 
[08:29:15.548]                         invokeRestart("muffleMessage")
[08:29:15.548]                     }
[08:29:15.548]                     else if (inherits(cond, "warning")) {
[08:29:15.548]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:15.548]                       if (muffled) 
[08:29:15.548]                         invokeRestart("muffleWarning")
[08:29:15.548]                     }
[08:29:15.548]                     else if (inherits(cond, "condition")) {
[08:29:15.548]                       if (!is.null(pattern)) {
[08:29:15.548]                         computeRestarts <- base::computeRestarts
[08:29:15.548]                         grepl <- base::grepl
[08:29:15.548]                         restarts <- computeRestarts(cond)
[08:29:15.548]                         for (restart in restarts) {
[08:29:15.548]                           name <- restart$name
[08:29:15.548]                           if (is.null(name)) 
[08:29:15.548]                             next
[08:29:15.548]                           if (!grepl(pattern, name)) 
[08:29:15.548]                             next
[08:29:15.548]                           invokeRestart(restart)
[08:29:15.548]                           muffled <- TRUE
[08:29:15.548]                           break
[08:29:15.548]                         }
[08:29:15.548]                       }
[08:29:15.548]                     }
[08:29:15.548]                     invisible(muffled)
[08:29:15.548]                   }
[08:29:15.548]                   muffleCondition(cond)
[08:29:15.548]                 })
[08:29:15.548]             }))
[08:29:15.548]             future::FutureResult(value = ...future.value$value, 
[08:29:15.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:15.548]                   ...future.rng), globalenv = if (FALSE) 
[08:29:15.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:15.548]                     ...future.globalenv.names))
[08:29:15.548]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:15.548]         }, condition = base::local({
[08:29:15.548]             c <- base::c
[08:29:15.548]             inherits <- base::inherits
[08:29:15.548]             invokeRestart <- base::invokeRestart
[08:29:15.548]             length <- base::length
[08:29:15.548]             list <- base::list
[08:29:15.548]             seq.int <- base::seq.int
[08:29:15.548]             signalCondition <- base::signalCondition
[08:29:15.548]             sys.calls <- base::sys.calls
[08:29:15.548]             `[[` <- base::`[[`
[08:29:15.548]             `+` <- base::`+`
[08:29:15.548]             `<<-` <- base::`<<-`
[08:29:15.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:15.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:15.548]                   3L)]
[08:29:15.548]             }
[08:29:15.548]             function(cond) {
[08:29:15.548]                 is_error <- inherits(cond, "error")
[08:29:15.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:15.548]                   NULL)
[08:29:15.548]                 if (is_error) {
[08:29:15.548]                   sessionInformation <- function() {
[08:29:15.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:15.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:15.548]                       search = base::search(), system = base::Sys.info())
[08:29:15.548]                   }
[08:29:15.548]                   ...future.conditions[[length(...future.conditions) + 
[08:29:15.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:15.548]                     cond$call), session = sessionInformation(), 
[08:29:15.548]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:15.548]                   signalCondition(cond)
[08:29:15.548]                 }
[08:29:15.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:15.548]                 "immediateCondition"))) {
[08:29:15.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:15.548]                   ...future.conditions[[length(...future.conditions) + 
[08:29:15.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:15.548]                   if (TRUE && !signal) {
[08:29:15.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:15.548]                     {
[08:29:15.548]                       inherits <- base::inherits
[08:29:15.548]                       invokeRestart <- base::invokeRestart
[08:29:15.548]                       is.null <- base::is.null
[08:29:15.548]                       muffled <- FALSE
[08:29:15.548]                       if (inherits(cond, "message")) {
[08:29:15.548]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:15.548]                         if (muffled) 
[08:29:15.548]                           invokeRestart("muffleMessage")
[08:29:15.548]                       }
[08:29:15.548]                       else if (inherits(cond, "warning")) {
[08:29:15.548]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:15.548]                         if (muffled) 
[08:29:15.548]                           invokeRestart("muffleWarning")
[08:29:15.548]                       }
[08:29:15.548]                       else if (inherits(cond, "condition")) {
[08:29:15.548]                         if (!is.null(pattern)) {
[08:29:15.548]                           computeRestarts <- base::computeRestarts
[08:29:15.548]                           grepl <- base::grepl
[08:29:15.548]                           restarts <- computeRestarts(cond)
[08:29:15.548]                           for (restart in restarts) {
[08:29:15.548]                             name <- restart$name
[08:29:15.548]                             if (is.null(name)) 
[08:29:15.548]                               next
[08:29:15.548]                             if (!grepl(pattern, name)) 
[08:29:15.548]                               next
[08:29:15.548]                             invokeRestart(restart)
[08:29:15.548]                             muffled <- TRUE
[08:29:15.548]                             break
[08:29:15.548]                           }
[08:29:15.548]                         }
[08:29:15.548]                       }
[08:29:15.548]                       invisible(muffled)
[08:29:15.548]                     }
[08:29:15.548]                     muffleCondition(cond, pattern = "^muffle")
[08:29:15.548]                   }
[08:29:15.548]                 }
[08:29:15.548]                 else {
[08:29:15.548]                   if (TRUE) {
[08:29:15.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:15.548]                     {
[08:29:15.548]                       inherits <- base::inherits
[08:29:15.548]                       invokeRestart <- base::invokeRestart
[08:29:15.548]                       is.null <- base::is.null
[08:29:15.548]                       muffled <- FALSE
[08:29:15.548]                       if (inherits(cond, "message")) {
[08:29:15.548]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:15.548]                         if (muffled) 
[08:29:15.548]                           invokeRestart("muffleMessage")
[08:29:15.548]                       }
[08:29:15.548]                       else if (inherits(cond, "warning")) {
[08:29:15.548]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:15.548]                         if (muffled) 
[08:29:15.548]                           invokeRestart("muffleWarning")
[08:29:15.548]                       }
[08:29:15.548]                       else if (inherits(cond, "condition")) {
[08:29:15.548]                         if (!is.null(pattern)) {
[08:29:15.548]                           computeRestarts <- base::computeRestarts
[08:29:15.548]                           grepl <- base::grepl
[08:29:15.548]                           restarts <- computeRestarts(cond)
[08:29:15.548]                           for (restart in restarts) {
[08:29:15.548]                             name <- restart$name
[08:29:15.548]                             if (is.null(name)) 
[08:29:15.548]                               next
[08:29:15.548]                             if (!grepl(pattern, name)) 
[08:29:15.548]                               next
[08:29:15.548]                             invokeRestart(restart)
[08:29:15.548]                             muffled <- TRUE
[08:29:15.548]                             break
[08:29:15.548]                           }
[08:29:15.548]                         }
[08:29:15.548]                       }
[08:29:15.548]                       invisible(muffled)
[08:29:15.548]                     }
[08:29:15.548]                     muffleCondition(cond, pattern = "^muffle")
[08:29:15.548]                   }
[08:29:15.548]                 }
[08:29:15.548]             }
[08:29:15.548]         }))
[08:29:15.548]     }, error = function(ex) {
[08:29:15.548]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:15.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:15.548]                 ...future.rng), started = ...future.startTime, 
[08:29:15.548]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:15.548]             version = "1.8"), class = "FutureResult")
[08:29:15.548]     }, finally = {
[08:29:15.548]         if (!identical(...future.workdir, getwd())) 
[08:29:15.548]             setwd(...future.workdir)
[08:29:15.548]         {
[08:29:15.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:15.548]                 ...future.oldOptions$nwarnings <- NULL
[08:29:15.548]             }
[08:29:15.548]             base::options(...future.oldOptions)
[08:29:15.548]             if (.Platform$OS.type == "windows") {
[08:29:15.548]                 old_names <- names(...future.oldEnvVars)
[08:29:15.548]                 envs <- base::Sys.getenv()
[08:29:15.548]                 names <- names(envs)
[08:29:15.548]                 common <- intersect(names, old_names)
[08:29:15.548]                 added <- setdiff(names, old_names)
[08:29:15.548]                 removed <- setdiff(old_names, names)
[08:29:15.548]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:15.548]                   envs[common]]
[08:29:15.548]                 NAMES <- toupper(changed)
[08:29:15.548]                 args <- list()
[08:29:15.548]                 for (kk in seq_along(NAMES)) {
[08:29:15.548]                   name <- changed[[kk]]
[08:29:15.548]                   NAME <- NAMES[[kk]]
[08:29:15.548]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:15.548]                     next
[08:29:15.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:15.548]                 }
[08:29:15.548]                 NAMES <- toupper(added)
[08:29:15.548]                 for (kk in seq_along(NAMES)) {
[08:29:15.548]                   name <- added[[kk]]
[08:29:15.548]                   NAME <- NAMES[[kk]]
[08:29:15.548]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:15.548]                     next
[08:29:15.548]                   args[[name]] <- ""
[08:29:15.548]                 }
[08:29:15.548]                 NAMES <- toupper(removed)
[08:29:15.548]                 for (kk in seq_along(NAMES)) {
[08:29:15.548]                   name <- removed[[kk]]
[08:29:15.548]                   NAME <- NAMES[[kk]]
[08:29:15.548]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:15.548]                     next
[08:29:15.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:15.548]                 }
[08:29:15.548]                 if (length(args) > 0) 
[08:29:15.548]                   base::do.call(base::Sys.setenv, args = args)
[08:29:15.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:15.548]             }
[08:29:15.548]             else {
[08:29:15.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:15.548]             }
[08:29:15.548]             {
[08:29:15.548]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:15.548]                   0L) {
[08:29:15.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:15.548]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:15.548]                   base::options(opts)
[08:29:15.548]                 }
[08:29:15.548]                 {
[08:29:15.548]                   {
[08:29:15.548]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:15.548]                     NULL
[08:29:15.548]                   }
[08:29:15.548]                   options(future.plan = NULL)
[08:29:15.548]                   if (is.na(NA_character_)) 
[08:29:15.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:15.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:15.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:15.548]                     .init = FALSE)
[08:29:15.548]                 }
[08:29:15.548]             }
[08:29:15.548]         }
[08:29:15.548]     })
[08:29:15.548]     if (TRUE) {
[08:29:15.548]         base::sink(type = "output", split = FALSE)
[08:29:15.548]         if (TRUE) {
[08:29:15.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:15.548]         }
[08:29:15.548]         else {
[08:29:15.548]             ...future.result["stdout"] <- base::list(NULL)
[08:29:15.548]         }
[08:29:15.548]         base::close(...future.stdout)
[08:29:15.548]         ...future.stdout <- NULL
[08:29:15.548]     }
[08:29:15.548]     ...future.result$conditions <- ...future.conditions
[08:29:15.548]     ...future.result$finished <- base::Sys.time()
[08:29:15.548]     ...future.result
[08:29:15.548] }
[08:29:15.551] MultisessionFuture started
[08:29:15.551] - Launch lazy future ... done
[08:29:15.551] run() for ‘MultisessionFuture’ ... done
[08:29:16.094] receiveMessageFromWorker() for ClusterFuture ...
[08:29:16.094] - Validating connection of MultisessionFuture
[08:29:16.094] - received message: FutureResult
[08:29:16.095] - Received FutureResult
[08:29:16.095] - Erased future from FutureRegistry
[08:29:16.095] result() for ClusterFuture ...
[08:29:16.095] - result already collected: FutureResult
[08:29:16.095] result() for ClusterFuture ... done
[08:29:16.095] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:16.095] A MultisessionFuture was resolved
- w/ exception ...
[08:29:16.095] getGlobalsAndPackages() ...
[08:29:16.095] Searching for globals...
[08:29:16.096] - globals found: [2] ‘list’, ‘stop’
[08:29:16.096] Searching for globals ... DONE
[08:29:16.096] Resolving globals: FALSE
[08:29:16.097] 
[08:29:16.097] 
[08:29:16.097] getGlobalsAndPackages() ... DONE
[08:29:16.097] run() for ‘Future’ ...
[08:29:16.097] - state: ‘created’
[08:29:16.097] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:16.111] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:16.111] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:16.111]   - Field: ‘node’
[08:29:16.112]   - Field: ‘label’
[08:29:16.112]   - Field: ‘local’
[08:29:16.112]   - Field: ‘owner’
[08:29:16.112]   - Field: ‘envir’
[08:29:16.112]   - Field: ‘workers’
[08:29:16.112]   - Field: ‘packages’
[08:29:16.112]   - Field: ‘gc’
[08:29:16.112]   - Field: ‘conditions’
[08:29:16.112]   - Field: ‘persistent’
[08:29:16.112]   - Field: ‘expr’
[08:29:16.112]   - Field: ‘uuid’
[08:29:16.113]   - Field: ‘seed’
[08:29:16.113]   - Field: ‘version’
[08:29:16.113]   - Field: ‘result’
[08:29:16.113]   - Field: ‘asynchronous’
[08:29:16.113]   - Field: ‘calls’
[08:29:16.113]   - Field: ‘globals’
[08:29:16.113]   - Field: ‘stdout’
[08:29:16.113]   - Field: ‘earlySignal’
[08:29:16.113]   - Field: ‘lazy’
[08:29:16.113]   - Field: ‘state’
[08:29:16.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:16.113] - Launch lazy future ...
[08:29:16.114] Packages needed by the future expression (n = 0): <none>
[08:29:16.114] Packages needed by future strategies (n = 0): <none>
[08:29:16.114] {
[08:29:16.114]     {
[08:29:16.114]         {
[08:29:16.114]             ...future.startTime <- base::Sys.time()
[08:29:16.114]             {
[08:29:16.114]                 {
[08:29:16.114]                   {
[08:29:16.114]                     {
[08:29:16.114]                       base::local({
[08:29:16.114]                         has_future <- base::requireNamespace("future", 
[08:29:16.114]                           quietly = TRUE)
[08:29:16.114]                         if (has_future) {
[08:29:16.114]                           ns <- base::getNamespace("future")
[08:29:16.114]                           version <- ns[[".package"]][["version"]]
[08:29:16.114]                           if (is.null(version)) 
[08:29:16.114]                             version <- utils::packageVersion("future")
[08:29:16.114]                         }
[08:29:16.114]                         else {
[08:29:16.114]                           version <- NULL
[08:29:16.114]                         }
[08:29:16.114]                         if (!has_future || version < "1.8.0") {
[08:29:16.114]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:16.114]                             "", base::R.version$version.string), 
[08:29:16.114]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:16.114]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:16.114]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:16.114]                               "release", "version")], collapse = " "), 
[08:29:16.114]                             hostname = base::Sys.info()[["nodename"]])
[08:29:16.114]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:16.114]                             info)
[08:29:16.114]                           info <- base::paste(info, collapse = "; ")
[08:29:16.114]                           if (!has_future) {
[08:29:16.114]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:16.114]                               info)
[08:29:16.114]                           }
[08:29:16.114]                           else {
[08:29:16.114]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:16.114]                               info, version)
[08:29:16.114]                           }
[08:29:16.114]                           base::stop(msg)
[08:29:16.114]                         }
[08:29:16.114]                       })
[08:29:16.114]                     }
[08:29:16.114]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:16.114]                     base::options(mc.cores = 1L)
[08:29:16.114]                   }
[08:29:16.114]                   ...future.strategy.old <- future::plan("list")
[08:29:16.114]                   options(future.plan = NULL)
[08:29:16.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:16.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:16.114]                 }
[08:29:16.114]                 ...future.workdir <- getwd()
[08:29:16.114]             }
[08:29:16.114]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:16.114]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:16.114]         }
[08:29:16.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:16.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:16.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:16.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:16.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:16.114]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:16.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:16.114]             base::names(...future.oldOptions))
[08:29:16.114]     }
[08:29:16.114]     if (FALSE) {
[08:29:16.114]     }
[08:29:16.114]     else {
[08:29:16.114]         if (TRUE) {
[08:29:16.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:16.114]                 open = "w")
[08:29:16.114]         }
[08:29:16.114]         else {
[08:29:16.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:16.114]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:16.114]         }
[08:29:16.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:16.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:16.114]             base::sink(type = "output", split = FALSE)
[08:29:16.114]             base::close(...future.stdout)
[08:29:16.114]         }, add = TRUE)
[08:29:16.114]     }
[08:29:16.114]     ...future.frame <- base::sys.nframe()
[08:29:16.114]     ...future.conditions <- base::list()
[08:29:16.114]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:16.114]     if (FALSE) {
[08:29:16.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:16.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:16.114]     }
[08:29:16.114]     ...future.result <- base::tryCatch({
[08:29:16.114]         base::withCallingHandlers({
[08:29:16.114]             ...future.value <- base::withVisible(base::local({
[08:29:16.114]                 ...future.makeSendCondition <- base::local({
[08:29:16.114]                   sendCondition <- NULL
[08:29:16.114]                   function(frame = 1L) {
[08:29:16.114]                     if (is.function(sendCondition)) 
[08:29:16.114]                       return(sendCondition)
[08:29:16.114]                     ns <- getNamespace("parallel")
[08:29:16.114]                     if (exists("sendData", mode = "function", 
[08:29:16.114]                       envir = ns)) {
[08:29:16.114]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:16.114]                         envir = ns)
[08:29:16.114]                       envir <- sys.frame(frame)
[08:29:16.114]                       master <- NULL
[08:29:16.114]                       while (!identical(envir, .GlobalEnv) && 
[08:29:16.114]                         !identical(envir, emptyenv())) {
[08:29:16.114]                         if (exists("master", mode = "list", envir = envir, 
[08:29:16.114]                           inherits = FALSE)) {
[08:29:16.114]                           master <- get("master", mode = "list", 
[08:29:16.114]                             envir = envir, inherits = FALSE)
[08:29:16.114]                           if (inherits(master, c("SOCKnode", 
[08:29:16.114]                             "SOCK0node"))) {
[08:29:16.114]                             sendCondition <<- function(cond) {
[08:29:16.114]                               data <- list(type = "VALUE", value = cond, 
[08:29:16.114]                                 success = TRUE)
[08:29:16.114]                               parallel_sendData(master, data)
[08:29:16.114]                             }
[08:29:16.114]                             return(sendCondition)
[08:29:16.114]                           }
[08:29:16.114]                         }
[08:29:16.114]                         frame <- frame + 1L
[08:29:16.114]                         envir <- sys.frame(frame)
[08:29:16.114]                       }
[08:29:16.114]                     }
[08:29:16.114]                     sendCondition <<- function(cond) NULL
[08:29:16.114]                   }
[08:29:16.114]                 })
[08:29:16.114]                 withCallingHandlers({
[08:29:16.114]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:16.114]                 }, immediateCondition = function(cond) {
[08:29:16.114]                   sendCondition <- ...future.makeSendCondition()
[08:29:16.114]                   sendCondition(cond)
[08:29:16.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.114]                   {
[08:29:16.114]                     inherits <- base::inherits
[08:29:16.114]                     invokeRestart <- base::invokeRestart
[08:29:16.114]                     is.null <- base::is.null
[08:29:16.114]                     muffled <- FALSE
[08:29:16.114]                     if (inherits(cond, "message")) {
[08:29:16.114]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:16.114]                       if (muffled) 
[08:29:16.114]                         invokeRestart("muffleMessage")
[08:29:16.114]                     }
[08:29:16.114]                     else if (inherits(cond, "warning")) {
[08:29:16.114]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:16.114]                       if (muffled) 
[08:29:16.114]                         invokeRestart("muffleWarning")
[08:29:16.114]                     }
[08:29:16.114]                     else if (inherits(cond, "condition")) {
[08:29:16.114]                       if (!is.null(pattern)) {
[08:29:16.114]                         computeRestarts <- base::computeRestarts
[08:29:16.114]                         grepl <- base::grepl
[08:29:16.114]                         restarts <- computeRestarts(cond)
[08:29:16.114]                         for (restart in restarts) {
[08:29:16.114]                           name <- restart$name
[08:29:16.114]                           if (is.null(name)) 
[08:29:16.114]                             next
[08:29:16.114]                           if (!grepl(pattern, name)) 
[08:29:16.114]                             next
[08:29:16.114]                           invokeRestart(restart)
[08:29:16.114]                           muffled <- TRUE
[08:29:16.114]                           break
[08:29:16.114]                         }
[08:29:16.114]                       }
[08:29:16.114]                     }
[08:29:16.114]                     invisible(muffled)
[08:29:16.114]                   }
[08:29:16.114]                   muffleCondition(cond)
[08:29:16.114]                 })
[08:29:16.114]             }))
[08:29:16.114]             future::FutureResult(value = ...future.value$value, 
[08:29:16.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:16.114]                   ...future.rng), globalenv = if (FALSE) 
[08:29:16.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:16.114]                     ...future.globalenv.names))
[08:29:16.114]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:16.114]         }, condition = base::local({
[08:29:16.114]             c <- base::c
[08:29:16.114]             inherits <- base::inherits
[08:29:16.114]             invokeRestart <- base::invokeRestart
[08:29:16.114]             length <- base::length
[08:29:16.114]             list <- base::list
[08:29:16.114]             seq.int <- base::seq.int
[08:29:16.114]             signalCondition <- base::signalCondition
[08:29:16.114]             sys.calls <- base::sys.calls
[08:29:16.114]             `[[` <- base::`[[`
[08:29:16.114]             `+` <- base::`+`
[08:29:16.114]             `<<-` <- base::`<<-`
[08:29:16.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:16.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:16.114]                   3L)]
[08:29:16.114]             }
[08:29:16.114]             function(cond) {
[08:29:16.114]                 is_error <- inherits(cond, "error")
[08:29:16.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:16.114]                   NULL)
[08:29:16.114]                 if (is_error) {
[08:29:16.114]                   sessionInformation <- function() {
[08:29:16.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:16.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:16.114]                       search = base::search(), system = base::Sys.info())
[08:29:16.114]                   }
[08:29:16.114]                   ...future.conditions[[length(...future.conditions) + 
[08:29:16.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:16.114]                     cond$call), session = sessionInformation(), 
[08:29:16.114]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:16.114]                   signalCondition(cond)
[08:29:16.114]                 }
[08:29:16.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:16.114]                 "immediateCondition"))) {
[08:29:16.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:16.114]                   ...future.conditions[[length(...future.conditions) + 
[08:29:16.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:16.114]                   if (TRUE && !signal) {
[08:29:16.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.114]                     {
[08:29:16.114]                       inherits <- base::inherits
[08:29:16.114]                       invokeRestart <- base::invokeRestart
[08:29:16.114]                       is.null <- base::is.null
[08:29:16.114]                       muffled <- FALSE
[08:29:16.114]                       if (inherits(cond, "message")) {
[08:29:16.114]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:16.114]                         if (muffled) 
[08:29:16.114]                           invokeRestart("muffleMessage")
[08:29:16.114]                       }
[08:29:16.114]                       else if (inherits(cond, "warning")) {
[08:29:16.114]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:16.114]                         if (muffled) 
[08:29:16.114]                           invokeRestart("muffleWarning")
[08:29:16.114]                       }
[08:29:16.114]                       else if (inherits(cond, "condition")) {
[08:29:16.114]                         if (!is.null(pattern)) {
[08:29:16.114]                           computeRestarts <- base::computeRestarts
[08:29:16.114]                           grepl <- base::grepl
[08:29:16.114]                           restarts <- computeRestarts(cond)
[08:29:16.114]                           for (restart in restarts) {
[08:29:16.114]                             name <- restart$name
[08:29:16.114]                             if (is.null(name)) 
[08:29:16.114]                               next
[08:29:16.114]                             if (!grepl(pattern, name)) 
[08:29:16.114]                               next
[08:29:16.114]                             invokeRestart(restart)
[08:29:16.114]                             muffled <- TRUE
[08:29:16.114]                             break
[08:29:16.114]                           }
[08:29:16.114]                         }
[08:29:16.114]                       }
[08:29:16.114]                       invisible(muffled)
[08:29:16.114]                     }
[08:29:16.114]                     muffleCondition(cond, pattern = "^muffle")
[08:29:16.114]                   }
[08:29:16.114]                 }
[08:29:16.114]                 else {
[08:29:16.114]                   if (TRUE) {
[08:29:16.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.114]                     {
[08:29:16.114]                       inherits <- base::inherits
[08:29:16.114]                       invokeRestart <- base::invokeRestart
[08:29:16.114]                       is.null <- base::is.null
[08:29:16.114]                       muffled <- FALSE
[08:29:16.114]                       if (inherits(cond, "message")) {
[08:29:16.114]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:16.114]                         if (muffled) 
[08:29:16.114]                           invokeRestart("muffleMessage")
[08:29:16.114]                       }
[08:29:16.114]                       else if (inherits(cond, "warning")) {
[08:29:16.114]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:16.114]                         if (muffled) 
[08:29:16.114]                           invokeRestart("muffleWarning")
[08:29:16.114]                       }
[08:29:16.114]                       else if (inherits(cond, "condition")) {
[08:29:16.114]                         if (!is.null(pattern)) {
[08:29:16.114]                           computeRestarts <- base::computeRestarts
[08:29:16.114]                           grepl <- base::grepl
[08:29:16.114]                           restarts <- computeRestarts(cond)
[08:29:16.114]                           for (restart in restarts) {
[08:29:16.114]                             name <- restart$name
[08:29:16.114]                             if (is.null(name)) 
[08:29:16.114]                               next
[08:29:16.114]                             if (!grepl(pattern, name)) 
[08:29:16.114]                               next
[08:29:16.114]                             invokeRestart(restart)
[08:29:16.114]                             muffled <- TRUE
[08:29:16.114]                             break
[08:29:16.114]                           }
[08:29:16.114]                         }
[08:29:16.114]                       }
[08:29:16.114]                       invisible(muffled)
[08:29:16.114]                     }
[08:29:16.114]                     muffleCondition(cond, pattern = "^muffle")
[08:29:16.114]                   }
[08:29:16.114]                 }
[08:29:16.114]             }
[08:29:16.114]         }))
[08:29:16.114]     }, error = function(ex) {
[08:29:16.114]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:16.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:16.114]                 ...future.rng), started = ...future.startTime, 
[08:29:16.114]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:16.114]             version = "1.8"), class = "FutureResult")
[08:29:16.114]     }, finally = {
[08:29:16.114]         if (!identical(...future.workdir, getwd())) 
[08:29:16.114]             setwd(...future.workdir)
[08:29:16.114]         {
[08:29:16.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:16.114]                 ...future.oldOptions$nwarnings <- NULL
[08:29:16.114]             }
[08:29:16.114]             base::options(...future.oldOptions)
[08:29:16.114]             if (.Platform$OS.type == "windows") {
[08:29:16.114]                 old_names <- names(...future.oldEnvVars)
[08:29:16.114]                 envs <- base::Sys.getenv()
[08:29:16.114]                 names <- names(envs)
[08:29:16.114]                 common <- intersect(names, old_names)
[08:29:16.114]                 added <- setdiff(names, old_names)
[08:29:16.114]                 removed <- setdiff(old_names, names)
[08:29:16.114]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:16.114]                   envs[common]]
[08:29:16.114]                 NAMES <- toupper(changed)
[08:29:16.114]                 args <- list()
[08:29:16.114]                 for (kk in seq_along(NAMES)) {
[08:29:16.114]                   name <- changed[[kk]]
[08:29:16.114]                   NAME <- NAMES[[kk]]
[08:29:16.114]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.114]                     next
[08:29:16.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:16.114]                 }
[08:29:16.114]                 NAMES <- toupper(added)
[08:29:16.114]                 for (kk in seq_along(NAMES)) {
[08:29:16.114]                   name <- added[[kk]]
[08:29:16.114]                   NAME <- NAMES[[kk]]
[08:29:16.114]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.114]                     next
[08:29:16.114]                   args[[name]] <- ""
[08:29:16.114]                 }
[08:29:16.114]                 NAMES <- toupper(removed)
[08:29:16.114]                 for (kk in seq_along(NAMES)) {
[08:29:16.114]                   name <- removed[[kk]]
[08:29:16.114]                   NAME <- NAMES[[kk]]
[08:29:16.114]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.114]                     next
[08:29:16.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:16.114]                 }
[08:29:16.114]                 if (length(args) > 0) 
[08:29:16.114]                   base::do.call(base::Sys.setenv, args = args)
[08:29:16.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:16.114]             }
[08:29:16.114]             else {
[08:29:16.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:16.114]             }
[08:29:16.114]             {
[08:29:16.114]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:16.114]                   0L) {
[08:29:16.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:16.114]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:16.114]                   base::options(opts)
[08:29:16.114]                 }
[08:29:16.114]                 {
[08:29:16.114]                   {
[08:29:16.114]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:16.114]                     NULL
[08:29:16.114]                   }
[08:29:16.114]                   options(future.plan = NULL)
[08:29:16.114]                   if (is.na(NA_character_)) 
[08:29:16.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:16.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:16.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:16.114]                     .init = FALSE)
[08:29:16.114]                 }
[08:29:16.114]             }
[08:29:16.114]         }
[08:29:16.114]     })
[08:29:16.114]     if (TRUE) {
[08:29:16.114]         base::sink(type = "output", split = FALSE)
[08:29:16.114]         if (TRUE) {
[08:29:16.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:16.114]         }
[08:29:16.114]         else {
[08:29:16.114]             ...future.result["stdout"] <- base::list(NULL)
[08:29:16.114]         }
[08:29:16.114]         base::close(...future.stdout)
[08:29:16.114]         ...future.stdout <- NULL
[08:29:16.114]     }
[08:29:16.114]     ...future.result$conditions <- ...future.conditions
[08:29:16.114]     ...future.result$finished <- base::Sys.time()
[08:29:16.114]     ...future.result
[08:29:16.114] }
[08:29:16.117] MultisessionFuture started
[08:29:16.118] - Launch lazy future ... done
[08:29:16.118] run() for ‘MultisessionFuture’ ... done
[08:29:16.160] receiveMessageFromWorker() for ClusterFuture ...
[08:29:16.161] - Validating connection of MultisessionFuture
[08:29:16.161] - received message: FutureResult
[08:29:16.161] - Received FutureResult
[08:29:16.162] - Erased future from FutureRegistry
[08:29:16.162] result() for ClusterFuture ...
[08:29:16.162] - result already collected: FutureResult
[08:29:16.162] result() for ClusterFuture ... done
[08:29:16.162] signalConditions() ...
[08:29:16.162]  - include = ‘immediateCondition’
[08:29:16.162]  - exclude = 
[08:29:16.162]  - resignal = FALSE
[08:29:16.162]  - Number of conditions: 1
[08:29:16.162] signalConditions() ... done
[08:29:16.162] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:16.162] A MultisessionFuture was resolved
[08:29:16.163] getGlobalsAndPackages() ...
[08:29:16.163] Searching for globals...
[08:29:16.163] - globals found: [2] ‘list’, ‘stop’
[08:29:16.163] Searching for globals ... DONE
[08:29:16.164] Resolving globals: FALSE
[08:29:16.164] 
[08:29:16.164] 
[08:29:16.164] getGlobalsAndPackages() ... DONE
[08:29:16.164] run() for ‘Future’ ...
[08:29:16.164] - state: ‘created’
[08:29:16.165] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:16.178] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:16.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:16.179]   - Field: ‘node’
[08:29:16.179]   - Field: ‘label’
[08:29:16.179]   - Field: ‘local’
[08:29:16.179]   - Field: ‘owner’
[08:29:16.179]   - Field: ‘envir’
[08:29:16.179]   - Field: ‘workers’
[08:29:16.179]   - Field: ‘packages’
[08:29:16.179]   - Field: ‘gc’
[08:29:16.179]   - Field: ‘conditions’
[08:29:16.179]   - Field: ‘persistent’
[08:29:16.179]   - Field: ‘expr’
[08:29:16.180]   - Field: ‘uuid’
[08:29:16.180]   - Field: ‘seed’
[08:29:16.180]   - Field: ‘version’
[08:29:16.180]   - Field: ‘result’
[08:29:16.180]   - Field: ‘asynchronous’
[08:29:16.180]   - Field: ‘calls’
[08:29:16.180]   - Field: ‘globals’
[08:29:16.180]   - Field: ‘stdout’
[08:29:16.180]   - Field: ‘earlySignal’
[08:29:16.180]   - Field: ‘lazy’
[08:29:16.180]   - Field: ‘state’
[08:29:16.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:16.181] - Launch lazy future ...
[08:29:16.181] Packages needed by the future expression (n = 0): <none>
[08:29:16.181] Packages needed by future strategies (n = 0): <none>
[08:29:16.184] {
[08:29:16.184]     {
[08:29:16.184]         {
[08:29:16.184]             ...future.startTime <- base::Sys.time()
[08:29:16.184]             {
[08:29:16.184]                 {
[08:29:16.184]                   {
[08:29:16.184]                     {
[08:29:16.184]                       base::local({
[08:29:16.184]                         has_future <- base::requireNamespace("future", 
[08:29:16.184]                           quietly = TRUE)
[08:29:16.184]                         if (has_future) {
[08:29:16.184]                           ns <- base::getNamespace("future")
[08:29:16.184]                           version <- ns[[".package"]][["version"]]
[08:29:16.184]                           if (is.null(version)) 
[08:29:16.184]                             version <- utils::packageVersion("future")
[08:29:16.184]                         }
[08:29:16.184]                         else {
[08:29:16.184]                           version <- NULL
[08:29:16.184]                         }
[08:29:16.184]                         if (!has_future || version < "1.8.0") {
[08:29:16.184]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:16.184]                             "", base::R.version$version.string), 
[08:29:16.184]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:16.184]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:16.184]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:16.184]                               "release", "version")], collapse = " "), 
[08:29:16.184]                             hostname = base::Sys.info()[["nodename"]])
[08:29:16.184]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:16.184]                             info)
[08:29:16.184]                           info <- base::paste(info, collapse = "; ")
[08:29:16.184]                           if (!has_future) {
[08:29:16.184]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:16.184]                               info)
[08:29:16.184]                           }
[08:29:16.184]                           else {
[08:29:16.184]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:16.184]                               info, version)
[08:29:16.184]                           }
[08:29:16.184]                           base::stop(msg)
[08:29:16.184]                         }
[08:29:16.184]                       })
[08:29:16.184]                     }
[08:29:16.184]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:16.184]                     base::options(mc.cores = 1L)
[08:29:16.184]                   }
[08:29:16.184]                   ...future.strategy.old <- future::plan("list")
[08:29:16.184]                   options(future.plan = NULL)
[08:29:16.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:16.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:16.184]                 }
[08:29:16.184]                 ...future.workdir <- getwd()
[08:29:16.184]             }
[08:29:16.184]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:16.184]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:16.184]         }
[08:29:16.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:16.184]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:16.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:16.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:16.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:16.184]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:16.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:16.184]             base::names(...future.oldOptions))
[08:29:16.184]     }
[08:29:16.184]     if (FALSE) {
[08:29:16.184]     }
[08:29:16.184]     else {
[08:29:16.184]         if (TRUE) {
[08:29:16.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:16.184]                 open = "w")
[08:29:16.184]         }
[08:29:16.184]         else {
[08:29:16.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:16.184]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:16.184]         }
[08:29:16.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:16.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:16.184]             base::sink(type = "output", split = FALSE)
[08:29:16.184]             base::close(...future.stdout)
[08:29:16.184]         }, add = TRUE)
[08:29:16.184]     }
[08:29:16.184]     ...future.frame <- base::sys.nframe()
[08:29:16.184]     ...future.conditions <- base::list()
[08:29:16.184]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:16.184]     if (FALSE) {
[08:29:16.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:16.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:16.184]     }
[08:29:16.184]     ...future.result <- base::tryCatch({
[08:29:16.184]         base::withCallingHandlers({
[08:29:16.184]             ...future.value <- base::withVisible(base::local({
[08:29:16.184]                 ...future.makeSendCondition <- base::local({
[08:29:16.184]                   sendCondition <- NULL
[08:29:16.184]                   function(frame = 1L) {
[08:29:16.184]                     if (is.function(sendCondition)) 
[08:29:16.184]                       return(sendCondition)
[08:29:16.184]                     ns <- getNamespace("parallel")
[08:29:16.184]                     if (exists("sendData", mode = "function", 
[08:29:16.184]                       envir = ns)) {
[08:29:16.184]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:16.184]                         envir = ns)
[08:29:16.184]                       envir <- sys.frame(frame)
[08:29:16.184]                       master <- NULL
[08:29:16.184]                       while (!identical(envir, .GlobalEnv) && 
[08:29:16.184]                         !identical(envir, emptyenv())) {
[08:29:16.184]                         if (exists("master", mode = "list", envir = envir, 
[08:29:16.184]                           inherits = FALSE)) {
[08:29:16.184]                           master <- get("master", mode = "list", 
[08:29:16.184]                             envir = envir, inherits = FALSE)
[08:29:16.184]                           if (inherits(master, c("SOCKnode", 
[08:29:16.184]                             "SOCK0node"))) {
[08:29:16.184]                             sendCondition <<- function(cond) {
[08:29:16.184]                               data <- list(type = "VALUE", value = cond, 
[08:29:16.184]                                 success = TRUE)
[08:29:16.184]                               parallel_sendData(master, data)
[08:29:16.184]                             }
[08:29:16.184]                             return(sendCondition)
[08:29:16.184]                           }
[08:29:16.184]                         }
[08:29:16.184]                         frame <- frame + 1L
[08:29:16.184]                         envir <- sys.frame(frame)
[08:29:16.184]                       }
[08:29:16.184]                     }
[08:29:16.184]                     sendCondition <<- function(cond) NULL
[08:29:16.184]                   }
[08:29:16.184]                 })
[08:29:16.184]                 withCallingHandlers({
[08:29:16.184]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:16.184]                 }, immediateCondition = function(cond) {
[08:29:16.184]                   sendCondition <- ...future.makeSendCondition()
[08:29:16.184]                   sendCondition(cond)
[08:29:16.184]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.184]                   {
[08:29:16.184]                     inherits <- base::inherits
[08:29:16.184]                     invokeRestart <- base::invokeRestart
[08:29:16.184]                     is.null <- base::is.null
[08:29:16.184]                     muffled <- FALSE
[08:29:16.184]                     if (inherits(cond, "message")) {
[08:29:16.184]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:16.184]                       if (muffled) 
[08:29:16.184]                         invokeRestart("muffleMessage")
[08:29:16.184]                     }
[08:29:16.184]                     else if (inherits(cond, "warning")) {
[08:29:16.184]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:16.184]                       if (muffled) 
[08:29:16.184]                         invokeRestart("muffleWarning")
[08:29:16.184]                     }
[08:29:16.184]                     else if (inherits(cond, "condition")) {
[08:29:16.184]                       if (!is.null(pattern)) {
[08:29:16.184]                         computeRestarts <- base::computeRestarts
[08:29:16.184]                         grepl <- base::grepl
[08:29:16.184]                         restarts <- computeRestarts(cond)
[08:29:16.184]                         for (restart in restarts) {
[08:29:16.184]                           name <- restart$name
[08:29:16.184]                           if (is.null(name)) 
[08:29:16.184]                             next
[08:29:16.184]                           if (!grepl(pattern, name)) 
[08:29:16.184]                             next
[08:29:16.184]                           invokeRestart(restart)
[08:29:16.184]                           muffled <- TRUE
[08:29:16.184]                           break
[08:29:16.184]                         }
[08:29:16.184]                       }
[08:29:16.184]                     }
[08:29:16.184]                     invisible(muffled)
[08:29:16.184]                   }
[08:29:16.184]                   muffleCondition(cond)
[08:29:16.184]                 })
[08:29:16.184]             }))
[08:29:16.184]             future::FutureResult(value = ...future.value$value, 
[08:29:16.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:16.184]                   ...future.rng), globalenv = if (FALSE) 
[08:29:16.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:16.184]                     ...future.globalenv.names))
[08:29:16.184]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:16.184]         }, condition = base::local({
[08:29:16.184]             c <- base::c
[08:29:16.184]             inherits <- base::inherits
[08:29:16.184]             invokeRestart <- base::invokeRestart
[08:29:16.184]             length <- base::length
[08:29:16.184]             list <- base::list
[08:29:16.184]             seq.int <- base::seq.int
[08:29:16.184]             signalCondition <- base::signalCondition
[08:29:16.184]             sys.calls <- base::sys.calls
[08:29:16.184]             `[[` <- base::`[[`
[08:29:16.184]             `+` <- base::`+`
[08:29:16.184]             `<<-` <- base::`<<-`
[08:29:16.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:16.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:16.184]                   3L)]
[08:29:16.184]             }
[08:29:16.184]             function(cond) {
[08:29:16.184]                 is_error <- inherits(cond, "error")
[08:29:16.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:16.184]                   NULL)
[08:29:16.184]                 if (is_error) {
[08:29:16.184]                   sessionInformation <- function() {
[08:29:16.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:16.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:16.184]                       search = base::search(), system = base::Sys.info())
[08:29:16.184]                   }
[08:29:16.184]                   ...future.conditions[[length(...future.conditions) + 
[08:29:16.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:16.184]                     cond$call), session = sessionInformation(), 
[08:29:16.184]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:16.184]                   signalCondition(cond)
[08:29:16.184]                 }
[08:29:16.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:16.184]                 "immediateCondition"))) {
[08:29:16.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:16.184]                   ...future.conditions[[length(...future.conditions) + 
[08:29:16.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:16.184]                   if (TRUE && !signal) {
[08:29:16.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.184]                     {
[08:29:16.184]                       inherits <- base::inherits
[08:29:16.184]                       invokeRestart <- base::invokeRestart
[08:29:16.184]                       is.null <- base::is.null
[08:29:16.184]                       muffled <- FALSE
[08:29:16.184]                       if (inherits(cond, "message")) {
[08:29:16.184]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:16.184]                         if (muffled) 
[08:29:16.184]                           invokeRestart("muffleMessage")
[08:29:16.184]                       }
[08:29:16.184]                       else if (inherits(cond, "warning")) {
[08:29:16.184]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:16.184]                         if (muffled) 
[08:29:16.184]                           invokeRestart("muffleWarning")
[08:29:16.184]                       }
[08:29:16.184]                       else if (inherits(cond, "condition")) {
[08:29:16.184]                         if (!is.null(pattern)) {
[08:29:16.184]                           computeRestarts <- base::computeRestarts
[08:29:16.184]                           grepl <- base::grepl
[08:29:16.184]                           restarts <- computeRestarts(cond)
[08:29:16.184]                           for (restart in restarts) {
[08:29:16.184]                             name <- restart$name
[08:29:16.184]                             if (is.null(name)) 
[08:29:16.184]                               next
[08:29:16.184]                             if (!grepl(pattern, name)) 
[08:29:16.184]                               next
[08:29:16.184]                             invokeRestart(restart)
[08:29:16.184]                             muffled <- TRUE
[08:29:16.184]                             break
[08:29:16.184]                           }
[08:29:16.184]                         }
[08:29:16.184]                       }
[08:29:16.184]                       invisible(muffled)
[08:29:16.184]                     }
[08:29:16.184]                     muffleCondition(cond, pattern = "^muffle")
[08:29:16.184]                   }
[08:29:16.184]                 }
[08:29:16.184]                 else {
[08:29:16.184]                   if (TRUE) {
[08:29:16.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.184]                     {
[08:29:16.184]                       inherits <- base::inherits
[08:29:16.184]                       invokeRestart <- base::invokeRestart
[08:29:16.184]                       is.null <- base::is.null
[08:29:16.184]                       muffled <- FALSE
[08:29:16.184]                       if (inherits(cond, "message")) {
[08:29:16.184]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:16.184]                         if (muffled) 
[08:29:16.184]                           invokeRestart("muffleMessage")
[08:29:16.184]                       }
[08:29:16.184]                       else if (inherits(cond, "warning")) {
[08:29:16.184]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:16.184]                         if (muffled) 
[08:29:16.184]                           invokeRestart("muffleWarning")
[08:29:16.184]                       }
[08:29:16.184]                       else if (inherits(cond, "condition")) {
[08:29:16.184]                         if (!is.null(pattern)) {
[08:29:16.184]                           computeRestarts <- base::computeRestarts
[08:29:16.184]                           grepl <- base::grepl
[08:29:16.184]                           restarts <- computeRestarts(cond)
[08:29:16.184]                           for (restart in restarts) {
[08:29:16.184]                             name <- restart$name
[08:29:16.184]                             if (is.null(name)) 
[08:29:16.184]                               next
[08:29:16.184]                             if (!grepl(pattern, name)) 
[08:29:16.184]                               next
[08:29:16.184]                             invokeRestart(restart)
[08:29:16.184]                             muffled <- TRUE
[08:29:16.184]                             break
[08:29:16.184]                           }
[08:29:16.184]                         }
[08:29:16.184]                       }
[08:29:16.184]                       invisible(muffled)
[08:29:16.184]                     }
[08:29:16.184]                     muffleCondition(cond, pattern = "^muffle")
[08:29:16.184]                   }
[08:29:16.184]                 }
[08:29:16.184]             }
[08:29:16.184]         }))
[08:29:16.184]     }, error = function(ex) {
[08:29:16.184]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:16.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:16.184]                 ...future.rng), started = ...future.startTime, 
[08:29:16.184]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:16.184]             version = "1.8"), class = "FutureResult")
[08:29:16.184]     }, finally = {
[08:29:16.184]         if (!identical(...future.workdir, getwd())) 
[08:29:16.184]             setwd(...future.workdir)
[08:29:16.184]         {
[08:29:16.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:16.184]                 ...future.oldOptions$nwarnings <- NULL
[08:29:16.184]             }
[08:29:16.184]             base::options(...future.oldOptions)
[08:29:16.184]             if (.Platform$OS.type == "windows") {
[08:29:16.184]                 old_names <- names(...future.oldEnvVars)
[08:29:16.184]                 envs <- base::Sys.getenv()
[08:29:16.184]                 names <- names(envs)
[08:29:16.184]                 common <- intersect(names, old_names)
[08:29:16.184]                 added <- setdiff(names, old_names)
[08:29:16.184]                 removed <- setdiff(old_names, names)
[08:29:16.184]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:16.184]                   envs[common]]
[08:29:16.184]                 NAMES <- toupper(changed)
[08:29:16.184]                 args <- list()
[08:29:16.184]                 for (kk in seq_along(NAMES)) {
[08:29:16.184]                   name <- changed[[kk]]
[08:29:16.184]                   NAME <- NAMES[[kk]]
[08:29:16.184]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.184]                     next
[08:29:16.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:16.184]                 }
[08:29:16.184]                 NAMES <- toupper(added)
[08:29:16.184]                 for (kk in seq_along(NAMES)) {
[08:29:16.184]                   name <- added[[kk]]
[08:29:16.184]                   NAME <- NAMES[[kk]]
[08:29:16.184]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.184]                     next
[08:29:16.184]                   args[[name]] <- ""
[08:29:16.184]                 }
[08:29:16.184]                 NAMES <- toupper(removed)
[08:29:16.184]                 for (kk in seq_along(NAMES)) {
[08:29:16.184]                   name <- removed[[kk]]
[08:29:16.184]                   NAME <- NAMES[[kk]]
[08:29:16.184]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.184]                     next
[08:29:16.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:16.184]                 }
[08:29:16.184]                 if (length(args) > 0) 
[08:29:16.184]                   base::do.call(base::Sys.setenv, args = args)
[08:29:16.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:16.184]             }
[08:29:16.184]             else {
[08:29:16.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:16.184]             }
[08:29:16.184]             {
[08:29:16.184]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:16.184]                   0L) {
[08:29:16.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:16.184]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:16.184]                   base::options(opts)
[08:29:16.184]                 }
[08:29:16.184]                 {
[08:29:16.184]                   {
[08:29:16.184]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:16.184]                     NULL
[08:29:16.184]                   }
[08:29:16.184]                   options(future.plan = NULL)
[08:29:16.184]                   if (is.na(NA_character_)) 
[08:29:16.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:16.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:16.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:16.184]                     .init = FALSE)
[08:29:16.184]                 }
[08:29:16.184]             }
[08:29:16.184]         }
[08:29:16.184]     })
[08:29:16.184]     if (TRUE) {
[08:29:16.184]         base::sink(type = "output", split = FALSE)
[08:29:16.184]         if (TRUE) {
[08:29:16.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:16.184]         }
[08:29:16.184]         else {
[08:29:16.184]             ...future.result["stdout"] <- base::list(NULL)
[08:29:16.184]         }
[08:29:16.184]         base::close(...future.stdout)
[08:29:16.184]         ...future.stdout <- NULL
[08:29:16.184]     }
[08:29:16.184]     ...future.result$conditions <- ...future.conditions
[08:29:16.184]     ...future.result$finished <- base::Sys.time()
[08:29:16.184]     ...future.result
[08:29:16.184] }
[08:29:16.187] MultisessionFuture started
[08:29:16.187] - Launch lazy future ... done
[08:29:16.187] run() for ‘MultisessionFuture’ ... done
[08:29:16.230] receiveMessageFromWorker() for ClusterFuture ...
[08:29:16.230] - Validating connection of MultisessionFuture
[08:29:16.230] - received message: FutureResult
[08:29:16.230] - Received FutureResult
[08:29:16.231] - Erased future from FutureRegistry
[08:29:16.231] result() for ClusterFuture ...
[08:29:16.231] - result already collected: FutureResult
[08:29:16.231] result() for ClusterFuture ... done
[08:29:16.231] signalConditions() ...
[08:29:16.231]  - include = ‘immediateCondition’
[08:29:16.231]  - exclude = 
[08:29:16.231]  - resignal = FALSE
[08:29:16.231]  - Number of conditions: 1
[08:29:16.231] signalConditions() ... done
[08:29:16.231] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:16.232] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[08:29:16.232] getGlobalsAndPackages() ...
[08:29:16.232] Searching for globals...
[08:29:16.233] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:16.233] Searching for globals ... DONE
[08:29:16.233] Resolving globals: FALSE
[08:29:16.234] 
[08:29:16.234] 
[08:29:16.234] getGlobalsAndPackages() ... DONE
[08:29:16.234] run() for ‘Future’ ...
[08:29:16.234] - state: ‘created’
[08:29:16.234] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:16.249] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:16.249] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:16.249]   - Field: ‘node’
[08:29:16.249]   - Field: ‘label’
[08:29:16.250]   - Field: ‘local’
[08:29:16.250]   - Field: ‘owner’
[08:29:16.250]   - Field: ‘envir’
[08:29:16.250]   - Field: ‘workers’
[08:29:16.250]   - Field: ‘packages’
[08:29:16.250]   - Field: ‘gc’
[08:29:16.250]   - Field: ‘conditions’
[08:29:16.250]   - Field: ‘persistent’
[08:29:16.250]   - Field: ‘expr’
[08:29:16.250]   - Field: ‘uuid’
[08:29:16.250]   - Field: ‘seed’
[08:29:16.250]   - Field: ‘version’
[08:29:16.251]   - Field: ‘result’
[08:29:16.251]   - Field: ‘asynchronous’
[08:29:16.251]   - Field: ‘calls’
[08:29:16.251]   - Field: ‘globals’
[08:29:16.251]   - Field: ‘stdout’
[08:29:16.251]   - Field: ‘earlySignal’
[08:29:16.251]   - Field: ‘lazy’
[08:29:16.251]   - Field: ‘state’
[08:29:16.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:16.251] - Launch lazy future ...
[08:29:16.252] Packages needed by the future expression (n = 0): <none>
[08:29:16.252] Packages needed by future strategies (n = 0): <none>
[08:29:16.252] {
[08:29:16.252]     {
[08:29:16.252]         {
[08:29:16.252]             ...future.startTime <- base::Sys.time()
[08:29:16.252]             {
[08:29:16.252]                 {
[08:29:16.252]                   {
[08:29:16.252]                     {
[08:29:16.252]                       base::local({
[08:29:16.252]                         has_future <- base::requireNamespace("future", 
[08:29:16.252]                           quietly = TRUE)
[08:29:16.252]                         if (has_future) {
[08:29:16.252]                           ns <- base::getNamespace("future")
[08:29:16.252]                           version <- ns[[".package"]][["version"]]
[08:29:16.252]                           if (is.null(version)) 
[08:29:16.252]                             version <- utils::packageVersion("future")
[08:29:16.252]                         }
[08:29:16.252]                         else {
[08:29:16.252]                           version <- NULL
[08:29:16.252]                         }
[08:29:16.252]                         if (!has_future || version < "1.8.0") {
[08:29:16.252]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:16.252]                             "", base::R.version$version.string), 
[08:29:16.252]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:16.252]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:16.252]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:16.252]                               "release", "version")], collapse = " "), 
[08:29:16.252]                             hostname = base::Sys.info()[["nodename"]])
[08:29:16.252]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:16.252]                             info)
[08:29:16.252]                           info <- base::paste(info, collapse = "; ")
[08:29:16.252]                           if (!has_future) {
[08:29:16.252]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:16.252]                               info)
[08:29:16.252]                           }
[08:29:16.252]                           else {
[08:29:16.252]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:16.252]                               info, version)
[08:29:16.252]                           }
[08:29:16.252]                           base::stop(msg)
[08:29:16.252]                         }
[08:29:16.252]                       })
[08:29:16.252]                     }
[08:29:16.252]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:16.252]                     base::options(mc.cores = 1L)
[08:29:16.252]                   }
[08:29:16.252]                   ...future.strategy.old <- future::plan("list")
[08:29:16.252]                   options(future.plan = NULL)
[08:29:16.252]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:16.252]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:16.252]                 }
[08:29:16.252]                 ...future.workdir <- getwd()
[08:29:16.252]             }
[08:29:16.252]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:16.252]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:16.252]         }
[08:29:16.252]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:16.252]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:16.252]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:16.252]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:16.252]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:16.252]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:16.252]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:16.252]             base::names(...future.oldOptions))
[08:29:16.252]     }
[08:29:16.252]     if (FALSE) {
[08:29:16.252]     }
[08:29:16.252]     else {
[08:29:16.252]         if (TRUE) {
[08:29:16.252]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:16.252]                 open = "w")
[08:29:16.252]         }
[08:29:16.252]         else {
[08:29:16.252]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:16.252]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:16.252]         }
[08:29:16.252]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:16.252]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:16.252]             base::sink(type = "output", split = FALSE)
[08:29:16.252]             base::close(...future.stdout)
[08:29:16.252]         }, add = TRUE)
[08:29:16.252]     }
[08:29:16.252]     ...future.frame <- base::sys.nframe()
[08:29:16.252]     ...future.conditions <- base::list()
[08:29:16.252]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:16.252]     if (FALSE) {
[08:29:16.252]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:16.252]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:16.252]     }
[08:29:16.252]     ...future.result <- base::tryCatch({
[08:29:16.252]         base::withCallingHandlers({
[08:29:16.252]             ...future.value <- base::withVisible(base::local({
[08:29:16.252]                 ...future.makeSendCondition <- base::local({
[08:29:16.252]                   sendCondition <- NULL
[08:29:16.252]                   function(frame = 1L) {
[08:29:16.252]                     if (is.function(sendCondition)) 
[08:29:16.252]                       return(sendCondition)
[08:29:16.252]                     ns <- getNamespace("parallel")
[08:29:16.252]                     if (exists("sendData", mode = "function", 
[08:29:16.252]                       envir = ns)) {
[08:29:16.252]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:16.252]                         envir = ns)
[08:29:16.252]                       envir <- sys.frame(frame)
[08:29:16.252]                       master <- NULL
[08:29:16.252]                       while (!identical(envir, .GlobalEnv) && 
[08:29:16.252]                         !identical(envir, emptyenv())) {
[08:29:16.252]                         if (exists("master", mode = "list", envir = envir, 
[08:29:16.252]                           inherits = FALSE)) {
[08:29:16.252]                           master <- get("master", mode = "list", 
[08:29:16.252]                             envir = envir, inherits = FALSE)
[08:29:16.252]                           if (inherits(master, c("SOCKnode", 
[08:29:16.252]                             "SOCK0node"))) {
[08:29:16.252]                             sendCondition <<- function(cond) {
[08:29:16.252]                               data <- list(type = "VALUE", value = cond, 
[08:29:16.252]                                 success = TRUE)
[08:29:16.252]                               parallel_sendData(master, data)
[08:29:16.252]                             }
[08:29:16.252]                             return(sendCondition)
[08:29:16.252]                           }
[08:29:16.252]                         }
[08:29:16.252]                         frame <- frame + 1L
[08:29:16.252]                         envir <- sys.frame(frame)
[08:29:16.252]                       }
[08:29:16.252]                     }
[08:29:16.252]                     sendCondition <<- function(cond) NULL
[08:29:16.252]                   }
[08:29:16.252]                 })
[08:29:16.252]                 withCallingHandlers({
[08:29:16.252]                   {
[08:29:16.252]                     Sys.sleep(0.5)
[08:29:16.252]                     list(a = 1, b = 42L)
[08:29:16.252]                   }
[08:29:16.252]                 }, immediateCondition = function(cond) {
[08:29:16.252]                   sendCondition <- ...future.makeSendCondition()
[08:29:16.252]                   sendCondition(cond)
[08:29:16.252]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.252]                   {
[08:29:16.252]                     inherits <- base::inherits
[08:29:16.252]                     invokeRestart <- base::invokeRestart
[08:29:16.252]                     is.null <- base::is.null
[08:29:16.252]                     muffled <- FALSE
[08:29:16.252]                     if (inherits(cond, "message")) {
[08:29:16.252]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:16.252]                       if (muffled) 
[08:29:16.252]                         invokeRestart("muffleMessage")
[08:29:16.252]                     }
[08:29:16.252]                     else if (inherits(cond, "warning")) {
[08:29:16.252]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:16.252]                       if (muffled) 
[08:29:16.252]                         invokeRestart("muffleWarning")
[08:29:16.252]                     }
[08:29:16.252]                     else if (inherits(cond, "condition")) {
[08:29:16.252]                       if (!is.null(pattern)) {
[08:29:16.252]                         computeRestarts <- base::computeRestarts
[08:29:16.252]                         grepl <- base::grepl
[08:29:16.252]                         restarts <- computeRestarts(cond)
[08:29:16.252]                         for (restart in restarts) {
[08:29:16.252]                           name <- restart$name
[08:29:16.252]                           if (is.null(name)) 
[08:29:16.252]                             next
[08:29:16.252]                           if (!grepl(pattern, name)) 
[08:29:16.252]                             next
[08:29:16.252]                           invokeRestart(restart)
[08:29:16.252]                           muffled <- TRUE
[08:29:16.252]                           break
[08:29:16.252]                         }
[08:29:16.252]                       }
[08:29:16.252]                     }
[08:29:16.252]                     invisible(muffled)
[08:29:16.252]                   }
[08:29:16.252]                   muffleCondition(cond)
[08:29:16.252]                 })
[08:29:16.252]             }))
[08:29:16.252]             future::FutureResult(value = ...future.value$value, 
[08:29:16.252]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:16.252]                   ...future.rng), globalenv = if (FALSE) 
[08:29:16.252]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:16.252]                     ...future.globalenv.names))
[08:29:16.252]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:16.252]         }, condition = base::local({
[08:29:16.252]             c <- base::c
[08:29:16.252]             inherits <- base::inherits
[08:29:16.252]             invokeRestart <- base::invokeRestart
[08:29:16.252]             length <- base::length
[08:29:16.252]             list <- base::list
[08:29:16.252]             seq.int <- base::seq.int
[08:29:16.252]             signalCondition <- base::signalCondition
[08:29:16.252]             sys.calls <- base::sys.calls
[08:29:16.252]             `[[` <- base::`[[`
[08:29:16.252]             `+` <- base::`+`
[08:29:16.252]             `<<-` <- base::`<<-`
[08:29:16.252]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:16.252]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:16.252]                   3L)]
[08:29:16.252]             }
[08:29:16.252]             function(cond) {
[08:29:16.252]                 is_error <- inherits(cond, "error")
[08:29:16.252]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:16.252]                   NULL)
[08:29:16.252]                 if (is_error) {
[08:29:16.252]                   sessionInformation <- function() {
[08:29:16.252]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:16.252]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:16.252]                       search = base::search(), system = base::Sys.info())
[08:29:16.252]                   }
[08:29:16.252]                   ...future.conditions[[length(...future.conditions) + 
[08:29:16.252]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:16.252]                     cond$call), session = sessionInformation(), 
[08:29:16.252]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:16.252]                   signalCondition(cond)
[08:29:16.252]                 }
[08:29:16.252]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:16.252]                 "immediateCondition"))) {
[08:29:16.252]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:16.252]                   ...future.conditions[[length(...future.conditions) + 
[08:29:16.252]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:16.252]                   if (TRUE && !signal) {
[08:29:16.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.252]                     {
[08:29:16.252]                       inherits <- base::inherits
[08:29:16.252]                       invokeRestart <- base::invokeRestart
[08:29:16.252]                       is.null <- base::is.null
[08:29:16.252]                       muffled <- FALSE
[08:29:16.252]                       if (inherits(cond, "message")) {
[08:29:16.252]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:16.252]                         if (muffled) 
[08:29:16.252]                           invokeRestart("muffleMessage")
[08:29:16.252]                       }
[08:29:16.252]                       else if (inherits(cond, "warning")) {
[08:29:16.252]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:16.252]                         if (muffled) 
[08:29:16.252]                           invokeRestart("muffleWarning")
[08:29:16.252]                       }
[08:29:16.252]                       else if (inherits(cond, "condition")) {
[08:29:16.252]                         if (!is.null(pattern)) {
[08:29:16.252]                           computeRestarts <- base::computeRestarts
[08:29:16.252]                           grepl <- base::grepl
[08:29:16.252]                           restarts <- computeRestarts(cond)
[08:29:16.252]                           for (restart in restarts) {
[08:29:16.252]                             name <- restart$name
[08:29:16.252]                             if (is.null(name)) 
[08:29:16.252]                               next
[08:29:16.252]                             if (!grepl(pattern, name)) 
[08:29:16.252]                               next
[08:29:16.252]                             invokeRestart(restart)
[08:29:16.252]                             muffled <- TRUE
[08:29:16.252]                             break
[08:29:16.252]                           }
[08:29:16.252]                         }
[08:29:16.252]                       }
[08:29:16.252]                       invisible(muffled)
[08:29:16.252]                     }
[08:29:16.252]                     muffleCondition(cond, pattern = "^muffle")
[08:29:16.252]                   }
[08:29:16.252]                 }
[08:29:16.252]                 else {
[08:29:16.252]                   if (TRUE) {
[08:29:16.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.252]                     {
[08:29:16.252]                       inherits <- base::inherits
[08:29:16.252]                       invokeRestart <- base::invokeRestart
[08:29:16.252]                       is.null <- base::is.null
[08:29:16.252]                       muffled <- FALSE
[08:29:16.252]                       if (inherits(cond, "message")) {
[08:29:16.252]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:16.252]                         if (muffled) 
[08:29:16.252]                           invokeRestart("muffleMessage")
[08:29:16.252]                       }
[08:29:16.252]                       else if (inherits(cond, "warning")) {
[08:29:16.252]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:16.252]                         if (muffled) 
[08:29:16.252]                           invokeRestart("muffleWarning")
[08:29:16.252]                       }
[08:29:16.252]                       else if (inherits(cond, "condition")) {
[08:29:16.252]                         if (!is.null(pattern)) {
[08:29:16.252]                           computeRestarts <- base::computeRestarts
[08:29:16.252]                           grepl <- base::grepl
[08:29:16.252]                           restarts <- computeRestarts(cond)
[08:29:16.252]                           for (restart in restarts) {
[08:29:16.252]                             name <- restart$name
[08:29:16.252]                             if (is.null(name)) 
[08:29:16.252]                               next
[08:29:16.252]                             if (!grepl(pattern, name)) 
[08:29:16.252]                               next
[08:29:16.252]                             invokeRestart(restart)
[08:29:16.252]                             muffled <- TRUE
[08:29:16.252]                             break
[08:29:16.252]                           }
[08:29:16.252]                         }
[08:29:16.252]                       }
[08:29:16.252]                       invisible(muffled)
[08:29:16.252]                     }
[08:29:16.252]                     muffleCondition(cond, pattern = "^muffle")
[08:29:16.252]                   }
[08:29:16.252]                 }
[08:29:16.252]             }
[08:29:16.252]         }))
[08:29:16.252]     }, error = function(ex) {
[08:29:16.252]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:16.252]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:16.252]                 ...future.rng), started = ...future.startTime, 
[08:29:16.252]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:16.252]             version = "1.8"), class = "FutureResult")
[08:29:16.252]     }, finally = {
[08:29:16.252]         if (!identical(...future.workdir, getwd())) 
[08:29:16.252]             setwd(...future.workdir)
[08:29:16.252]         {
[08:29:16.252]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:16.252]                 ...future.oldOptions$nwarnings <- NULL
[08:29:16.252]             }
[08:29:16.252]             base::options(...future.oldOptions)
[08:29:16.252]             if (.Platform$OS.type == "windows") {
[08:29:16.252]                 old_names <- names(...future.oldEnvVars)
[08:29:16.252]                 envs <- base::Sys.getenv()
[08:29:16.252]                 names <- names(envs)
[08:29:16.252]                 common <- intersect(names, old_names)
[08:29:16.252]                 added <- setdiff(names, old_names)
[08:29:16.252]                 removed <- setdiff(old_names, names)
[08:29:16.252]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:16.252]                   envs[common]]
[08:29:16.252]                 NAMES <- toupper(changed)
[08:29:16.252]                 args <- list()
[08:29:16.252]                 for (kk in seq_along(NAMES)) {
[08:29:16.252]                   name <- changed[[kk]]
[08:29:16.252]                   NAME <- NAMES[[kk]]
[08:29:16.252]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.252]                     next
[08:29:16.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:16.252]                 }
[08:29:16.252]                 NAMES <- toupper(added)
[08:29:16.252]                 for (kk in seq_along(NAMES)) {
[08:29:16.252]                   name <- added[[kk]]
[08:29:16.252]                   NAME <- NAMES[[kk]]
[08:29:16.252]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.252]                     next
[08:29:16.252]                   args[[name]] <- ""
[08:29:16.252]                 }
[08:29:16.252]                 NAMES <- toupper(removed)
[08:29:16.252]                 for (kk in seq_along(NAMES)) {
[08:29:16.252]                   name <- removed[[kk]]
[08:29:16.252]                   NAME <- NAMES[[kk]]
[08:29:16.252]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.252]                     next
[08:29:16.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:16.252]                 }
[08:29:16.252]                 if (length(args) > 0) 
[08:29:16.252]                   base::do.call(base::Sys.setenv, args = args)
[08:29:16.252]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:16.252]             }
[08:29:16.252]             else {
[08:29:16.252]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:16.252]             }
[08:29:16.252]             {
[08:29:16.252]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:16.252]                   0L) {
[08:29:16.252]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:16.252]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:16.252]                   base::options(opts)
[08:29:16.252]                 }
[08:29:16.252]                 {
[08:29:16.252]                   {
[08:29:16.252]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:16.252]                     NULL
[08:29:16.252]                   }
[08:29:16.252]                   options(future.plan = NULL)
[08:29:16.252]                   if (is.na(NA_character_)) 
[08:29:16.252]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:16.252]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:16.252]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:16.252]                     .init = FALSE)
[08:29:16.252]                 }
[08:29:16.252]             }
[08:29:16.252]         }
[08:29:16.252]     })
[08:29:16.252]     if (TRUE) {
[08:29:16.252]         base::sink(type = "output", split = FALSE)
[08:29:16.252]         if (TRUE) {
[08:29:16.252]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:16.252]         }
[08:29:16.252]         else {
[08:29:16.252]             ...future.result["stdout"] <- base::list(NULL)
[08:29:16.252]         }
[08:29:16.252]         base::close(...future.stdout)
[08:29:16.252]         ...future.stdout <- NULL
[08:29:16.252]     }
[08:29:16.252]     ...future.result$conditions <- ...future.conditions
[08:29:16.252]     ...future.result$finished <- base::Sys.time()
[08:29:16.252]     ...future.result
[08:29:16.252] }
[08:29:16.255] MultisessionFuture started
[08:29:16.255] - Launch lazy future ... done
[08:29:16.256] run() for ‘MultisessionFuture’ ... done
[08:29:16.798] receiveMessageFromWorker() for ClusterFuture ...
[08:29:16.798] - Validating connection of MultisessionFuture
[08:29:16.798] - received message: FutureResult
[08:29:16.798] - Received FutureResult
[08:29:16.799] - Erased future from FutureRegistry
[08:29:16.799] result() for ClusterFuture ...
[08:29:16.799] - result already collected: FutureResult
[08:29:16.799] result() for ClusterFuture ... done
[08:29:16.799] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:16.799] resolve() on list ...
[08:29:16.799]  recursive: 0
[08:29:16.799]  length: 2
[08:29:16.799]  elements: ‘a’, ‘b’
[08:29:16.799]  length: 1 (resolved future 1)
[08:29:16.800]  length: 0 (resolved future 2)
[08:29:16.800] resolve() on list ... DONE
[08:29:16.800] A MultisessionFuture was resolved (and resolved itself)
[08:29:16.800] getGlobalsAndPackages() ...
[08:29:16.800] Searching for globals...
[08:29:16.801] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:16.801] Searching for globals ... DONE
[08:29:16.801] Resolving globals: FALSE
[08:29:16.802] 
[08:29:16.802] 
[08:29:16.802] getGlobalsAndPackages() ... DONE
[08:29:16.802] run() for ‘Future’ ...
[08:29:16.802] - state: ‘created’
[08:29:16.802] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:16.816] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:16.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:16.817]   - Field: ‘node’
[08:29:16.817]   - Field: ‘label’
[08:29:16.817]   - Field: ‘local’
[08:29:16.817]   - Field: ‘owner’
[08:29:16.817]   - Field: ‘envir’
[08:29:16.817]   - Field: ‘workers’
[08:29:16.817]   - Field: ‘packages’
[08:29:16.817]   - Field: ‘gc’
[08:29:16.817]   - Field: ‘conditions’
[08:29:16.817]   - Field: ‘persistent’
[08:29:16.817]   - Field: ‘expr’
[08:29:16.818]   - Field: ‘uuid’
[08:29:16.818]   - Field: ‘seed’
[08:29:16.818]   - Field: ‘version’
[08:29:16.818]   - Field: ‘result’
[08:29:16.818]   - Field: ‘asynchronous’
[08:29:16.818]   - Field: ‘calls’
[08:29:16.818]   - Field: ‘globals’
[08:29:16.818]   - Field: ‘stdout’
[08:29:16.818]   - Field: ‘earlySignal’
[08:29:16.818]   - Field: ‘lazy’
[08:29:16.818]   - Field: ‘state’
[08:29:16.818] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:16.819] - Launch lazy future ...
[08:29:16.819] Packages needed by the future expression (n = 0): <none>
[08:29:16.819] Packages needed by future strategies (n = 0): <none>
[08:29:16.819] {
[08:29:16.819]     {
[08:29:16.819]         {
[08:29:16.819]             ...future.startTime <- base::Sys.time()
[08:29:16.819]             {
[08:29:16.819]                 {
[08:29:16.819]                   {
[08:29:16.819]                     {
[08:29:16.819]                       base::local({
[08:29:16.819]                         has_future <- base::requireNamespace("future", 
[08:29:16.819]                           quietly = TRUE)
[08:29:16.819]                         if (has_future) {
[08:29:16.819]                           ns <- base::getNamespace("future")
[08:29:16.819]                           version <- ns[[".package"]][["version"]]
[08:29:16.819]                           if (is.null(version)) 
[08:29:16.819]                             version <- utils::packageVersion("future")
[08:29:16.819]                         }
[08:29:16.819]                         else {
[08:29:16.819]                           version <- NULL
[08:29:16.819]                         }
[08:29:16.819]                         if (!has_future || version < "1.8.0") {
[08:29:16.819]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:16.819]                             "", base::R.version$version.string), 
[08:29:16.819]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:16.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:16.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:16.819]                               "release", "version")], collapse = " "), 
[08:29:16.819]                             hostname = base::Sys.info()[["nodename"]])
[08:29:16.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:16.819]                             info)
[08:29:16.819]                           info <- base::paste(info, collapse = "; ")
[08:29:16.819]                           if (!has_future) {
[08:29:16.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:16.819]                               info)
[08:29:16.819]                           }
[08:29:16.819]                           else {
[08:29:16.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:16.819]                               info, version)
[08:29:16.819]                           }
[08:29:16.819]                           base::stop(msg)
[08:29:16.819]                         }
[08:29:16.819]                       })
[08:29:16.819]                     }
[08:29:16.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:16.819]                     base::options(mc.cores = 1L)
[08:29:16.819]                   }
[08:29:16.819]                   ...future.strategy.old <- future::plan("list")
[08:29:16.819]                   options(future.plan = NULL)
[08:29:16.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:16.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:16.819]                 }
[08:29:16.819]                 ...future.workdir <- getwd()
[08:29:16.819]             }
[08:29:16.819]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:16.819]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:16.819]         }
[08:29:16.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:16.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:16.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:16.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:16.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:16.819]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:16.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:16.819]             base::names(...future.oldOptions))
[08:29:16.819]     }
[08:29:16.819]     if (FALSE) {
[08:29:16.819]     }
[08:29:16.819]     else {
[08:29:16.819]         if (TRUE) {
[08:29:16.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:16.819]                 open = "w")
[08:29:16.819]         }
[08:29:16.819]         else {
[08:29:16.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:16.819]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:16.819]         }
[08:29:16.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:16.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:16.819]             base::sink(type = "output", split = FALSE)
[08:29:16.819]             base::close(...future.stdout)
[08:29:16.819]         }, add = TRUE)
[08:29:16.819]     }
[08:29:16.819]     ...future.frame <- base::sys.nframe()
[08:29:16.819]     ...future.conditions <- base::list()
[08:29:16.819]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:16.819]     if (FALSE) {
[08:29:16.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:16.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:16.819]     }
[08:29:16.819]     ...future.result <- base::tryCatch({
[08:29:16.819]         base::withCallingHandlers({
[08:29:16.819]             ...future.value <- base::withVisible(base::local({
[08:29:16.819]                 ...future.makeSendCondition <- base::local({
[08:29:16.819]                   sendCondition <- NULL
[08:29:16.819]                   function(frame = 1L) {
[08:29:16.819]                     if (is.function(sendCondition)) 
[08:29:16.819]                       return(sendCondition)
[08:29:16.819]                     ns <- getNamespace("parallel")
[08:29:16.819]                     if (exists("sendData", mode = "function", 
[08:29:16.819]                       envir = ns)) {
[08:29:16.819]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:16.819]                         envir = ns)
[08:29:16.819]                       envir <- sys.frame(frame)
[08:29:16.819]                       master <- NULL
[08:29:16.819]                       while (!identical(envir, .GlobalEnv) && 
[08:29:16.819]                         !identical(envir, emptyenv())) {
[08:29:16.819]                         if (exists("master", mode = "list", envir = envir, 
[08:29:16.819]                           inherits = FALSE)) {
[08:29:16.819]                           master <- get("master", mode = "list", 
[08:29:16.819]                             envir = envir, inherits = FALSE)
[08:29:16.819]                           if (inherits(master, c("SOCKnode", 
[08:29:16.819]                             "SOCK0node"))) {
[08:29:16.819]                             sendCondition <<- function(cond) {
[08:29:16.819]                               data <- list(type = "VALUE", value = cond, 
[08:29:16.819]                                 success = TRUE)
[08:29:16.819]                               parallel_sendData(master, data)
[08:29:16.819]                             }
[08:29:16.819]                             return(sendCondition)
[08:29:16.819]                           }
[08:29:16.819]                         }
[08:29:16.819]                         frame <- frame + 1L
[08:29:16.819]                         envir <- sys.frame(frame)
[08:29:16.819]                       }
[08:29:16.819]                     }
[08:29:16.819]                     sendCondition <<- function(cond) NULL
[08:29:16.819]                   }
[08:29:16.819]                 })
[08:29:16.819]                 withCallingHandlers({
[08:29:16.819]                   {
[08:29:16.819]                     Sys.sleep(0.5)
[08:29:16.819]                     list(a = 1, b = 42L)
[08:29:16.819]                   }
[08:29:16.819]                 }, immediateCondition = function(cond) {
[08:29:16.819]                   sendCondition <- ...future.makeSendCondition()
[08:29:16.819]                   sendCondition(cond)
[08:29:16.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.819]                   {
[08:29:16.819]                     inherits <- base::inherits
[08:29:16.819]                     invokeRestart <- base::invokeRestart
[08:29:16.819]                     is.null <- base::is.null
[08:29:16.819]                     muffled <- FALSE
[08:29:16.819]                     if (inherits(cond, "message")) {
[08:29:16.819]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:16.819]                       if (muffled) 
[08:29:16.819]                         invokeRestart("muffleMessage")
[08:29:16.819]                     }
[08:29:16.819]                     else if (inherits(cond, "warning")) {
[08:29:16.819]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:16.819]                       if (muffled) 
[08:29:16.819]                         invokeRestart("muffleWarning")
[08:29:16.819]                     }
[08:29:16.819]                     else if (inherits(cond, "condition")) {
[08:29:16.819]                       if (!is.null(pattern)) {
[08:29:16.819]                         computeRestarts <- base::computeRestarts
[08:29:16.819]                         grepl <- base::grepl
[08:29:16.819]                         restarts <- computeRestarts(cond)
[08:29:16.819]                         for (restart in restarts) {
[08:29:16.819]                           name <- restart$name
[08:29:16.819]                           if (is.null(name)) 
[08:29:16.819]                             next
[08:29:16.819]                           if (!grepl(pattern, name)) 
[08:29:16.819]                             next
[08:29:16.819]                           invokeRestart(restart)
[08:29:16.819]                           muffled <- TRUE
[08:29:16.819]                           break
[08:29:16.819]                         }
[08:29:16.819]                       }
[08:29:16.819]                     }
[08:29:16.819]                     invisible(muffled)
[08:29:16.819]                   }
[08:29:16.819]                   muffleCondition(cond)
[08:29:16.819]                 })
[08:29:16.819]             }))
[08:29:16.819]             future::FutureResult(value = ...future.value$value, 
[08:29:16.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:16.819]                   ...future.rng), globalenv = if (FALSE) 
[08:29:16.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:16.819]                     ...future.globalenv.names))
[08:29:16.819]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:16.819]         }, condition = base::local({
[08:29:16.819]             c <- base::c
[08:29:16.819]             inherits <- base::inherits
[08:29:16.819]             invokeRestart <- base::invokeRestart
[08:29:16.819]             length <- base::length
[08:29:16.819]             list <- base::list
[08:29:16.819]             seq.int <- base::seq.int
[08:29:16.819]             signalCondition <- base::signalCondition
[08:29:16.819]             sys.calls <- base::sys.calls
[08:29:16.819]             `[[` <- base::`[[`
[08:29:16.819]             `+` <- base::`+`
[08:29:16.819]             `<<-` <- base::`<<-`
[08:29:16.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:16.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:16.819]                   3L)]
[08:29:16.819]             }
[08:29:16.819]             function(cond) {
[08:29:16.819]                 is_error <- inherits(cond, "error")
[08:29:16.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:16.819]                   NULL)
[08:29:16.819]                 if (is_error) {
[08:29:16.819]                   sessionInformation <- function() {
[08:29:16.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:16.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:16.819]                       search = base::search(), system = base::Sys.info())
[08:29:16.819]                   }
[08:29:16.819]                   ...future.conditions[[length(...future.conditions) + 
[08:29:16.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:16.819]                     cond$call), session = sessionInformation(), 
[08:29:16.819]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:16.819]                   signalCondition(cond)
[08:29:16.819]                 }
[08:29:16.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:16.819]                 "immediateCondition"))) {
[08:29:16.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:16.819]                   ...future.conditions[[length(...future.conditions) + 
[08:29:16.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:16.819]                   if (TRUE && !signal) {
[08:29:16.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.819]                     {
[08:29:16.819]                       inherits <- base::inherits
[08:29:16.819]                       invokeRestart <- base::invokeRestart
[08:29:16.819]                       is.null <- base::is.null
[08:29:16.819]                       muffled <- FALSE
[08:29:16.819]                       if (inherits(cond, "message")) {
[08:29:16.819]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:16.819]                         if (muffled) 
[08:29:16.819]                           invokeRestart("muffleMessage")
[08:29:16.819]                       }
[08:29:16.819]                       else if (inherits(cond, "warning")) {
[08:29:16.819]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:16.819]                         if (muffled) 
[08:29:16.819]                           invokeRestart("muffleWarning")
[08:29:16.819]                       }
[08:29:16.819]                       else if (inherits(cond, "condition")) {
[08:29:16.819]                         if (!is.null(pattern)) {
[08:29:16.819]                           computeRestarts <- base::computeRestarts
[08:29:16.819]                           grepl <- base::grepl
[08:29:16.819]                           restarts <- computeRestarts(cond)
[08:29:16.819]                           for (restart in restarts) {
[08:29:16.819]                             name <- restart$name
[08:29:16.819]                             if (is.null(name)) 
[08:29:16.819]                               next
[08:29:16.819]                             if (!grepl(pattern, name)) 
[08:29:16.819]                               next
[08:29:16.819]                             invokeRestart(restart)
[08:29:16.819]                             muffled <- TRUE
[08:29:16.819]                             break
[08:29:16.819]                           }
[08:29:16.819]                         }
[08:29:16.819]                       }
[08:29:16.819]                       invisible(muffled)
[08:29:16.819]                     }
[08:29:16.819]                     muffleCondition(cond, pattern = "^muffle")
[08:29:16.819]                   }
[08:29:16.819]                 }
[08:29:16.819]                 else {
[08:29:16.819]                   if (TRUE) {
[08:29:16.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:16.819]                     {
[08:29:16.819]                       inherits <- base::inherits
[08:29:16.819]                       invokeRestart <- base::invokeRestart
[08:29:16.819]                       is.null <- base::is.null
[08:29:16.819]                       muffled <- FALSE
[08:29:16.819]                       if (inherits(cond, "message")) {
[08:29:16.819]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:16.819]                         if (muffled) 
[08:29:16.819]                           invokeRestart("muffleMessage")
[08:29:16.819]                       }
[08:29:16.819]                       else if (inherits(cond, "warning")) {
[08:29:16.819]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:16.819]                         if (muffled) 
[08:29:16.819]                           invokeRestart("muffleWarning")
[08:29:16.819]                       }
[08:29:16.819]                       else if (inherits(cond, "condition")) {
[08:29:16.819]                         if (!is.null(pattern)) {
[08:29:16.819]                           computeRestarts <- base::computeRestarts
[08:29:16.819]                           grepl <- base::grepl
[08:29:16.819]                           restarts <- computeRestarts(cond)
[08:29:16.819]                           for (restart in restarts) {
[08:29:16.819]                             name <- restart$name
[08:29:16.819]                             if (is.null(name)) 
[08:29:16.819]                               next
[08:29:16.819]                             if (!grepl(pattern, name)) 
[08:29:16.819]                               next
[08:29:16.819]                             invokeRestart(restart)
[08:29:16.819]                             muffled <- TRUE
[08:29:16.819]                             break
[08:29:16.819]                           }
[08:29:16.819]                         }
[08:29:16.819]                       }
[08:29:16.819]                       invisible(muffled)
[08:29:16.819]                     }
[08:29:16.819]                     muffleCondition(cond, pattern = "^muffle")
[08:29:16.819]                   }
[08:29:16.819]                 }
[08:29:16.819]             }
[08:29:16.819]         }))
[08:29:16.819]     }, error = function(ex) {
[08:29:16.819]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:16.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:16.819]                 ...future.rng), started = ...future.startTime, 
[08:29:16.819]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:16.819]             version = "1.8"), class = "FutureResult")
[08:29:16.819]     }, finally = {
[08:29:16.819]         if (!identical(...future.workdir, getwd())) 
[08:29:16.819]             setwd(...future.workdir)
[08:29:16.819]         {
[08:29:16.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:16.819]                 ...future.oldOptions$nwarnings <- NULL
[08:29:16.819]             }
[08:29:16.819]             base::options(...future.oldOptions)
[08:29:16.819]             if (.Platform$OS.type == "windows") {
[08:29:16.819]                 old_names <- names(...future.oldEnvVars)
[08:29:16.819]                 envs <- base::Sys.getenv()
[08:29:16.819]                 names <- names(envs)
[08:29:16.819]                 common <- intersect(names, old_names)
[08:29:16.819]                 added <- setdiff(names, old_names)
[08:29:16.819]                 removed <- setdiff(old_names, names)
[08:29:16.819]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:16.819]                   envs[common]]
[08:29:16.819]                 NAMES <- toupper(changed)
[08:29:16.819]                 args <- list()
[08:29:16.819]                 for (kk in seq_along(NAMES)) {
[08:29:16.819]                   name <- changed[[kk]]
[08:29:16.819]                   NAME <- NAMES[[kk]]
[08:29:16.819]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.819]                     next
[08:29:16.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:16.819]                 }
[08:29:16.819]                 NAMES <- toupper(added)
[08:29:16.819]                 for (kk in seq_along(NAMES)) {
[08:29:16.819]                   name <- added[[kk]]
[08:29:16.819]                   NAME <- NAMES[[kk]]
[08:29:16.819]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.819]                     next
[08:29:16.819]                   args[[name]] <- ""
[08:29:16.819]                 }
[08:29:16.819]                 NAMES <- toupper(removed)
[08:29:16.819]                 for (kk in seq_along(NAMES)) {
[08:29:16.819]                   name <- removed[[kk]]
[08:29:16.819]                   NAME <- NAMES[[kk]]
[08:29:16.819]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:16.819]                     next
[08:29:16.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:16.819]                 }
[08:29:16.819]                 if (length(args) > 0) 
[08:29:16.819]                   base::do.call(base::Sys.setenv, args = args)
[08:29:16.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:16.819]             }
[08:29:16.819]             else {
[08:29:16.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:16.819]             }
[08:29:16.819]             {
[08:29:16.819]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:16.819]                   0L) {
[08:29:16.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:16.819]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:16.819]                   base::options(opts)
[08:29:16.819]                 }
[08:29:16.819]                 {
[08:29:16.819]                   {
[08:29:16.819]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:16.819]                     NULL
[08:29:16.819]                   }
[08:29:16.819]                   options(future.plan = NULL)
[08:29:16.819]                   if (is.na(NA_character_)) 
[08:29:16.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:16.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:16.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:16.819]                     .init = FALSE)
[08:29:16.819]                 }
[08:29:16.819]             }
[08:29:16.819]         }
[08:29:16.819]     })
[08:29:16.819]     if (TRUE) {
[08:29:16.819]         base::sink(type = "output", split = FALSE)
[08:29:16.819]         if (TRUE) {
[08:29:16.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:16.819]         }
[08:29:16.819]         else {
[08:29:16.819]             ...future.result["stdout"] <- base::list(NULL)
[08:29:16.819]         }
[08:29:16.819]         base::close(...future.stdout)
[08:29:16.819]         ...future.stdout <- NULL
[08:29:16.819]     }
[08:29:16.819]     ...future.result$conditions <- ...future.conditions
[08:29:16.819]     ...future.result$finished <- base::Sys.time()
[08:29:16.819]     ...future.result
[08:29:16.819] }
[08:29:16.822] MultisessionFuture started
[08:29:16.823] - Launch lazy future ... done
[08:29:16.823] run() for ‘MultisessionFuture’ ... done
[08:29:17.365] receiveMessageFromWorker() for ClusterFuture ...
[08:29:17.365] - Validating connection of MultisessionFuture
[08:29:17.365] - received message: FutureResult
[08:29:17.366] - Received FutureResult
[08:29:17.366] - Erased future from FutureRegistry
[08:29:17.366] result() for ClusterFuture ...
[08:29:17.366] - result already collected: FutureResult
[08:29:17.366] result() for ClusterFuture ... done
[08:29:17.366] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:17.366] resolve() on list ...
[08:29:17.366]  recursive: 0
[08:29:17.366]  length: 2
[08:29:17.366]  elements: ‘a’, ‘b’
[08:29:17.367]  length: 1 (resolved future 1)
[08:29:17.367]  length: 0 (resolved future 2)
[08:29:17.367] resolve() on list ... DONE
[08:29:17.367] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[08:29:17.367] getGlobalsAndPackages() ...
[08:29:17.367] Searching for globals...
[08:29:17.368] - globals found: [2] ‘list’, ‘stop’
[08:29:17.368] Searching for globals ... DONE
[08:29:17.368] Resolving globals: FALSE
[08:29:17.368] 
[08:29:17.368] 
[08:29:17.368] getGlobalsAndPackages() ... DONE
[08:29:17.369] run() for ‘Future’ ...
[08:29:17.369] - state: ‘created’
[08:29:17.369] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:17.383] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:17.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:17.383]   - Field: ‘node’
[08:29:17.383]   - Field: ‘label’
[08:29:17.383]   - Field: ‘local’
[08:29:17.383]   - Field: ‘owner’
[08:29:17.383]   - Field: ‘envir’
[08:29:17.384]   - Field: ‘workers’
[08:29:17.384]   - Field: ‘packages’
[08:29:17.384]   - Field: ‘gc’
[08:29:17.384]   - Field: ‘conditions’
[08:29:17.384]   - Field: ‘persistent’
[08:29:17.384]   - Field: ‘expr’
[08:29:17.384]   - Field: ‘uuid’
[08:29:17.384]   - Field: ‘seed’
[08:29:17.384]   - Field: ‘version’
[08:29:17.384]   - Field: ‘result’
[08:29:17.384]   - Field: ‘asynchronous’
[08:29:17.384]   - Field: ‘calls’
[08:29:17.385]   - Field: ‘globals’
[08:29:17.385]   - Field: ‘stdout’
[08:29:17.385]   - Field: ‘earlySignal’
[08:29:17.385]   - Field: ‘lazy’
[08:29:17.385]   - Field: ‘state’
[08:29:17.385] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:17.385] - Launch lazy future ...
[08:29:17.385] Packages needed by the future expression (n = 0): <none>
[08:29:17.385] Packages needed by future strategies (n = 0): <none>
[08:29:17.386] {
[08:29:17.386]     {
[08:29:17.386]         {
[08:29:17.386]             ...future.startTime <- base::Sys.time()
[08:29:17.386]             {
[08:29:17.386]                 {
[08:29:17.386]                   {
[08:29:17.386]                     {
[08:29:17.386]                       base::local({
[08:29:17.386]                         has_future <- base::requireNamespace("future", 
[08:29:17.386]                           quietly = TRUE)
[08:29:17.386]                         if (has_future) {
[08:29:17.386]                           ns <- base::getNamespace("future")
[08:29:17.386]                           version <- ns[[".package"]][["version"]]
[08:29:17.386]                           if (is.null(version)) 
[08:29:17.386]                             version <- utils::packageVersion("future")
[08:29:17.386]                         }
[08:29:17.386]                         else {
[08:29:17.386]                           version <- NULL
[08:29:17.386]                         }
[08:29:17.386]                         if (!has_future || version < "1.8.0") {
[08:29:17.386]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:17.386]                             "", base::R.version$version.string), 
[08:29:17.386]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:17.386]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:17.386]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:17.386]                               "release", "version")], collapse = " "), 
[08:29:17.386]                             hostname = base::Sys.info()[["nodename"]])
[08:29:17.386]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:17.386]                             info)
[08:29:17.386]                           info <- base::paste(info, collapse = "; ")
[08:29:17.386]                           if (!has_future) {
[08:29:17.386]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:17.386]                               info)
[08:29:17.386]                           }
[08:29:17.386]                           else {
[08:29:17.386]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:17.386]                               info, version)
[08:29:17.386]                           }
[08:29:17.386]                           base::stop(msg)
[08:29:17.386]                         }
[08:29:17.386]                       })
[08:29:17.386]                     }
[08:29:17.386]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:17.386]                     base::options(mc.cores = 1L)
[08:29:17.386]                   }
[08:29:17.386]                   ...future.strategy.old <- future::plan("list")
[08:29:17.386]                   options(future.plan = NULL)
[08:29:17.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:17.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:17.386]                 }
[08:29:17.386]                 ...future.workdir <- getwd()
[08:29:17.386]             }
[08:29:17.386]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:17.386]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:17.386]         }
[08:29:17.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:17.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:17.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:17.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:17.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:17.386]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:17.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:17.386]             base::names(...future.oldOptions))
[08:29:17.386]     }
[08:29:17.386]     if (FALSE) {
[08:29:17.386]     }
[08:29:17.386]     else {
[08:29:17.386]         if (TRUE) {
[08:29:17.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:17.386]                 open = "w")
[08:29:17.386]         }
[08:29:17.386]         else {
[08:29:17.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:17.386]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:17.386]         }
[08:29:17.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:17.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:17.386]             base::sink(type = "output", split = FALSE)
[08:29:17.386]             base::close(...future.stdout)
[08:29:17.386]         }, add = TRUE)
[08:29:17.386]     }
[08:29:17.386]     ...future.frame <- base::sys.nframe()
[08:29:17.386]     ...future.conditions <- base::list()
[08:29:17.386]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:17.386]     if (FALSE) {
[08:29:17.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:17.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:17.386]     }
[08:29:17.386]     ...future.result <- base::tryCatch({
[08:29:17.386]         base::withCallingHandlers({
[08:29:17.386]             ...future.value <- base::withVisible(base::local({
[08:29:17.386]                 ...future.makeSendCondition <- base::local({
[08:29:17.386]                   sendCondition <- NULL
[08:29:17.386]                   function(frame = 1L) {
[08:29:17.386]                     if (is.function(sendCondition)) 
[08:29:17.386]                       return(sendCondition)
[08:29:17.386]                     ns <- getNamespace("parallel")
[08:29:17.386]                     if (exists("sendData", mode = "function", 
[08:29:17.386]                       envir = ns)) {
[08:29:17.386]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:17.386]                         envir = ns)
[08:29:17.386]                       envir <- sys.frame(frame)
[08:29:17.386]                       master <- NULL
[08:29:17.386]                       while (!identical(envir, .GlobalEnv) && 
[08:29:17.386]                         !identical(envir, emptyenv())) {
[08:29:17.386]                         if (exists("master", mode = "list", envir = envir, 
[08:29:17.386]                           inherits = FALSE)) {
[08:29:17.386]                           master <- get("master", mode = "list", 
[08:29:17.386]                             envir = envir, inherits = FALSE)
[08:29:17.386]                           if (inherits(master, c("SOCKnode", 
[08:29:17.386]                             "SOCK0node"))) {
[08:29:17.386]                             sendCondition <<- function(cond) {
[08:29:17.386]                               data <- list(type = "VALUE", value = cond, 
[08:29:17.386]                                 success = TRUE)
[08:29:17.386]                               parallel_sendData(master, data)
[08:29:17.386]                             }
[08:29:17.386]                             return(sendCondition)
[08:29:17.386]                           }
[08:29:17.386]                         }
[08:29:17.386]                         frame <- frame + 1L
[08:29:17.386]                         envir <- sys.frame(frame)
[08:29:17.386]                       }
[08:29:17.386]                     }
[08:29:17.386]                     sendCondition <<- function(cond) NULL
[08:29:17.386]                   }
[08:29:17.386]                 })
[08:29:17.386]                 withCallingHandlers({
[08:29:17.386]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:17.386]                 }, immediateCondition = function(cond) {
[08:29:17.386]                   sendCondition <- ...future.makeSendCondition()
[08:29:17.386]                   sendCondition(cond)
[08:29:17.386]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:17.386]                   {
[08:29:17.386]                     inherits <- base::inherits
[08:29:17.386]                     invokeRestart <- base::invokeRestart
[08:29:17.386]                     is.null <- base::is.null
[08:29:17.386]                     muffled <- FALSE
[08:29:17.386]                     if (inherits(cond, "message")) {
[08:29:17.386]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:17.386]                       if (muffled) 
[08:29:17.386]                         invokeRestart("muffleMessage")
[08:29:17.386]                     }
[08:29:17.386]                     else if (inherits(cond, "warning")) {
[08:29:17.386]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:17.386]                       if (muffled) 
[08:29:17.386]                         invokeRestart("muffleWarning")
[08:29:17.386]                     }
[08:29:17.386]                     else if (inherits(cond, "condition")) {
[08:29:17.386]                       if (!is.null(pattern)) {
[08:29:17.386]                         computeRestarts <- base::computeRestarts
[08:29:17.386]                         grepl <- base::grepl
[08:29:17.386]                         restarts <- computeRestarts(cond)
[08:29:17.386]                         for (restart in restarts) {
[08:29:17.386]                           name <- restart$name
[08:29:17.386]                           if (is.null(name)) 
[08:29:17.386]                             next
[08:29:17.386]                           if (!grepl(pattern, name)) 
[08:29:17.386]                             next
[08:29:17.386]                           invokeRestart(restart)
[08:29:17.386]                           muffled <- TRUE
[08:29:17.386]                           break
[08:29:17.386]                         }
[08:29:17.386]                       }
[08:29:17.386]                     }
[08:29:17.386]                     invisible(muffled)
[08:29:17.386]                   }
[08:29:17.386]                   muffleCondition(cond)
[08:29:17.386]                 })
[08:29:17.386]             }))
[08:29:17.386]             future::FutureResult(value = ...future.value$value, 
[08:29:17.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:17.386]                   ...future.rng), globalenv = if (FALSE) 
[08:29:17.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:17.386]                     ...future.globalenv.names))
[08:29:17.386]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:17.386]         }, condition = base::local({
[08:29:17.386]             c <- base::c
[08:29:17.386]             inherits <- base::inherits
[08:29:17.386]             invokeRestart <- base::invokeRestart
[08:29:17.386]             length <- base::length
[08:29:17.386]             list <- base::list
[08:29:17.386]             seq.int <- base::seq.int
[08:29:17.386]             signalCondition <- base::signalCondition
[08:29:17.386]             sys.calls <- base::sys.calls
[08:29:17.386]             `[[` <- base::`[[`
[08:29:17.386]             `+` <- base::`+`
[08:29:17.386]             `<<-` <- base::`<<-`
[08:29:17.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:17.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:17.386]                   3L)]
[08:29:17.386]             }
[08:29:17.386]             function(cond) {
[08:29:17.386]                 is_error <- inherits(cond, "error")
[08:29:17.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:17.386]                   NULL)
[08:29:17.386]                 if (is_error) {
[08:29:17.386]                   sessionInformation <- function() {
[08:29:17.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:17.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:17.386]                       search = base::search(), system = base::Sys.info())
[08:29:17.386]                   }
[08:29:17.386]                   ...future.conditions[[length(...future.conditions) + 
[08:29:17.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:17.386]                     cond$call), session = sessionInformation(), 
[08:29:17.386]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:17.386]                   signalCondition(cond)
[08:29:17.386]                 }
[08:29:17.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:17.386]                 "immediateCondition"))) {
[08:29:17.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:17.386]                   ...future.conditions[[length(...future.conditions) + 
[08:29:17.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:17.386]                   if (TRUE && !signal) {
[08:29:17.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:17.386]                     {
[08:29:17.386]                       inherits <- base::inherits
[08:29:17.386]                       invokeRestart <- base::invokeRestart
[08:29:17.386]                       is.null <- base::is.null
[08:29:17.386]                       muffled <- FALSE
[08:29:17.386]                       if (inherits(cond, "message")) {
[08:29:17.386]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:17.386]                         if (muffled) 
[08:29:17.386]                           invokeRestart("muffleMessage")
[08:29:17.386]                       }
[08:29:17.386]                       else if (inherits(cond, "warning")) {
[08:29:17.386]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:17.386]                         if (muffled) 
[08:29:17.386]                           invokeRestart("muffleWarning")
[08:29:17.386]                       }
[08:29:17.386]                       else if (inherits(cond, "condition")) {
[08:29:17.386]                         if (!is.null(pattern)) {
[08:29:17.386]                           computeRestarts <- base::computeRestarts
[08:29:17.386]                           grepl <- base::grepl
[08:29:17.386]                           restarts <- computeRestarts(cond)
[08:29:17.386]                           for (restart in restarts) {
[08:29:17.386]                             name <- restart$name
[08:29:17.386]                             if (is.null(name)) 
[08:29:17.386]                               next
[08:29:17.386]                             if (!grepl(pattern, name)) 
[08:29:17.386]                               next
[08:29:17.386]                             invokeRestart(restart)
[08:29:17.386]                             muffled <- TRUE
[08:29:17.386]                             break
[08:29:17.386]                           }
[08:29:17.386]                         }
[08:29:17.386]                       }
[08:29:17.386]                       invisible(muffled)
[08:29:17.386]                     }
[08:29:17.386]                     muffleCondition(cond, pattern = "^muffle")
[08:29:17.386]                   }
[08:29:17.386]                 }
[08:29:17.386]                 else {
[08:29:17.386]                   if (TRUE) {
[08:29:17.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:17.386]                     {
[08:29:17.386]                       inherits <- base::inherits
[08:29:17.386]                       invokeRestart <- base::invokeRestart
[08:29:17.386]                       is.null <- base::is.null
[08:29:17.386]                       muffled <- FALSE
[08:29:17.386]                       if (inherits(cond, "message")) {
[08:29:17.386]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:17.386]                         if (muffled) 
[08:29:17.386]                           invokeRestart("muffleMessage")
[08:29:17.386]                       }
[08:29:17.386]                       else if (inherits(cond, "warning")) {
[08:29:17.386]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:17.386]                         if (muffled) 
[08:29:17.386]                           invokeRestart("muffleWarning")
[08:29:17.386]                       }
[08:29:17.386]                       else if (inherits(cond, "condition")) {
[08:29:17.386]                         if (!is.null(pattern)) {
[08:29:17.386]                           computeRestarts <- base::computeRestarts
[08:29:17.386]                           grepl <- base::grepl
[08:29:17.386]                           restarts <- computeRestarts(cond)
[08:29:17.386]                           for (restart in restarts) {
[08:29:17.386]                             name <- restart$name
[08:29:17.386]                             if (is.null(name)) 
[08:29:17.386]                               next
[08:29:17.386]                             if (!grepl(pattern, name)) 
[08:29:17.386]                               next
[08:29:17.386]                             invokeRestart(restart)
[08:29:17.386]                             muffled <- TRUE
[08:29:17.386]                             break
[08:29:17.386]                           }
[08:29:17.386]                         }
[08:29:17.386]                       }
[08:29:17.386]                       invisible(muffled)
[08:29:17.386]                     }
[08:29:17.386]                     muffleCondition(cond, pattern = "^muffle")
[08:29:17.386]                   }
[08:29:17.386]                 }
[08:29:17.386]             }
[08:29:17.386]         }))
[08:29:17.386]     }, error = function(ex) {
[08:29:17.386]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:17.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:17.386]                 ...future.rng), started = ...future.startTime, 
[08:29:17.386]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:17.386]             version = "1.8"), class = "FutureResult")
[08:29:17.386]     }, finally = {
[08:29:17.386]         if (!identical(...future.workdir, getwd())) 
[08:29:17.386]             setwd(...future.workdir)
[08:29:17.386]         {
[08:29:17.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:17.386]                 ...future.oldOptions$nwarnings <- NULL
[08:29:17.386]             }
[08:29:17.386]             base::options(...future.oldOptions)
[08:29:17.386]             if (.Platform$OS.type == "windows") {
[08:29:17.386]                 old_names <- names(...future.oldEnvVars)
[08:29:17.386]                 envs <- base::Sys.getenv()
[08:29:17.386]                 names <- names(envs)
[08:29:17.386]                 common <- intersect(names, old_names)
[08:29:17.386]                 added <- setdiff(names, old_names)
[08:29:17.386]                 removed <- setdiff(old_names, names)
[08:29:17.386]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:17.386]                   envs[common]]
[08:29:17.386]                 NAMES <- toupper(changed)
[08:29:17.386]                 args <- list()
[08:29:17.386]                 for (kk in seq_along(NAMES)) {
[08:29:17.386]                   name <- changed[[kk]]
[08:29:17.386]                   NAME <- NAMES[[kk]]
[08:29:17.386]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:17.386]                     next
[08:29:17.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:17.386]                 }
[08:29:17.386]                 NAMES <- toupper(added)
[08:29:17.386]                 for (kk in seq_along(NAMES)) {
[08:29:17.386]                   name <- added[[kk]]
[08:29:17.386]                   NAME <- NAMES[[kk]]
[08:29:17.386]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:17.386]                     next
[08:29:17.386]                   args[[name]] <- ""
[08:29:17.386]                 }
[08:29:17.386]                 NAMES <- toupper(removed)
[08:29:17.386]                 for (kk in seq_along(NAMES)) {
[08:29:17.386]                   name <- removed[[kk]]
[08:29:17.386]                   NAME <- NAMES[[kk]]
[08:29:17.386]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:17.386]                     next
[08:29:17.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:17.386]                 }
[08:29:17.386]                 if (length(args) > 0) 
[08:29:17.386]                   base::do.call(base::Sys.setenv, args = args)
[08:29:17.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:17.386]             }
[08:29:17.386]             else {
[08:29:17.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:17.386]             }
[08:29:17.386]             {
[08:29:17.386]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:17.386]                   0L) {
[08:29:17.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:17.386]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:17.386]                   base::options(opts)
[08:29:17.386]                 }
[08:29:17.386]                 {
[08:29:17.386]                   {
[08:29:17.386]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:17.386]                     NULL
[08:29:17.386]                   }
[08:29:17.386]                   options(future.plan = NULL)
[08:29:17.386]                   if (is.na(NA_character_)) 
[08:29:17.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:17.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:17.386]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:17.386]                     .init = FALSE)
[08:29:17.386]                 }
[08:29:17.386]             }
[08:29:17.386]         }
[08:29:17.386]     })
[08:29:17.386]     if (TRUE) {
[08:29:17.386]         base::sink(type = "output", split = FALSE)
[08:29:17.386]         if (TRUE) {
[08:29:17.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:17.386]         }
[08:29:17.386]         else {
[08:29:17.386]             ...future.result["stdout"] <- base::list(NULL)
[08:29:17.386]         }
[08:29:17.386]         base::close(...future.stdout)
[08:29:17.386]         ...future.stdout <- NULL
[08:29:17.386]     }
[08:29:17.386]     ...future.result$conditions <- ...future.conditions
[08:29:17.386]     ...future.result$finished <- base::Sys.time()
[08:29:17.386]     ...future.result
[08:29:17.386] }
[08:29:17.389] MultisessionFuture started
[08:29:17.389] - Launch lazy future ... done
[08:29:17.389] run() for ‘MultisessionFuture’ ... done
[08:29:17.431] receiveMessageFromWorker() for ClusterFuture ...
[08:29:17.432] - Validating connection of MultisessionFuture
[08:29:17.432] - received message: FutureResult
[08:29:17.432] - Received FutureResult
[08:29:17.432] - Erased future from FutureRegistry
[08:29:17.433] result() for ClusterFuture ...
[08:29:17.433] - result already collected: FutureResult
[08:29:17.433] result() for ClusterFuture ... done
[08:29:17.433] signalConditions() ...
[08:29:17.433]  - include = ‘immediateCondition’
[08:29:17.433]  - exclude = 
[08:29:17.433]  - resignal = FALSE
[08:29:17.433]  - Number of conditions: 1
[08:29:17.433] signalConditions() ... done
[08:29:17.433] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:17.433] A MultisessionFuture was resolved (and resolved itself)
[08:29:17.434] getGlobalsAndPackages() ...
[08:29:17.434] Searching for globals...
[08:29:17.434] - globals found: [2] ‘list’, ‘stop’
[08:29:17.434] Searching for globals ... DONE
[08:29:17.435] Resolving globals: FALSE
[08:29:17.435] 
[08:29:17.435] 
[08:29:17.435] getGlobalsAndPackages() ... DONE
[08:29:17.435] run() for ‘Future’ ...
[08:29:17.435] - state: ‘created’
[08:29:17.436] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:17.450] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:17.450] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:17.450]   - Field: ‘node’
[08:29:17.450]   - Field: ‘label’
[08:29:17.450]   - Field: ‘local’
[08:29:17.450]   - Field: ‘owner’
[08:29:17.450]   - Field: ‘envir’
[08:29:17.450]   - Field: ‘workers’
[08:29:17.450]   - Field: ‘packages’
[08:29:17.450]   - Field: ‘gc’
[08:29:17.451]   - Field: ‘conditions’
[08:29:17.451]   - Field: ‘persistent’
[08:29:17.451]   - Field: ‘expr’
[08:29:17.451]   - Field: ‘uuid’
[08:29:17.451]   - Field: ‘seed’
[08:29:17.451]   - Field: ‘version’
[08:29:17.451]   - Field: ‘result’
[08:29:17.451]   - Field: ‘asynchronous’
[08:29:17.451]   - Field: ‘calls’
[08:29:17.451]   - Field: ‘globals’
[08:29:17.451]   - Field: ‘stdout’
[08:29:17.451]   - Field: ‘earlySignal’
[08:29:17.452]   - Field: ‘lazy’
[08:29:17.452]   - Field: ‘state’
[08:29:17.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:17.452] - Launch lazy future ...
[08:29:17.452] Packages needed by the future expression (n = 0): <none>
[08:29:17.452] Packages needed by future strategies (n = 0): <none>
[08:29:17.453] {
[08:29:17.453]     {
[08:29:17.453]         {
[08:29:17.453]             ...future.startTime <- base::Sys.time()
[08:29:17.453]             {
[08:29:17.453]                 {
[08:29:17.453]                   {
[08:29:17.453]                     {
[08:29:17.453]                       base::local({
[08:29:17.453]                         has_future <- base::requireNamespace("future", 
[08:29:17.453]                           quietly = TRUE)
[08:29:17.453]                         if (has_future) {
[08:29:17.453]                           ns <- base::getNamespace("future")
[08:29:17.453]                           version <- ns[[".package"]][["version"]]
[08:29:17.453]                           if (is.null(version)) 
[08:29:17.453]                             version <- utils::packageVersion("future")
[08:29:17.453]                         }
[08:29:17.453]                         else {
[08:29:17.453]                           version <- NULL
[08:29:17.453]                         }
[08:29:17.453]                         if (!has_future || version < "1.8.0") {
[08:29:17.453]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:17.453]                             "", base::R.version$version.string), 
[08:29:17.453]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:17.453]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:17.453]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:17.453]                               "release", "version")], collapse = " "), 
[08:29:17.453]                             hostname = base::Sys.info()[["nodename"]])
[08:29:17.453]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:17.453]                             info)
[08:29:17.453]                           info <- base::paste(info, collapse = "; ")
[08:29:17.453]                           if (!has_future) {
[08:29:17.453]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:17.453]                               info)
[08:29:17.453]                           }
[08:29:17.453]                           else {
[08:29:17.453]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:17.453]                               info, version)
[08:29:17.453]                           }
[08:29:17.453]                           base::stop(msg)
[08:29:17.453]                         }
[08:29:17.453]                       })
[08:29:17.453]                     }
[08:29:17.453]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:17.453]                     base::options(mc.cores = 1L)
[08:29:17.453]                   }
[08:29:17.453]                   ...future.strategy.old <- future::plan("list")
[08:29:17.453]                   options(future.plan = NULL)
[08:29:17.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:17.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:17.453]                 }
[08:29:17.453]                 ...future.workdir <- getwd()
[08:29:17.453]             }
[08:29:17.453]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:17.453]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:17.453]         }
[08:29:17.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:17.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:17.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:17.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:17.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:17.453]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:17.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:17.453]             base::names(...future.oldOptions))
[08:29:17.453]     }
[08:29:17.453]     if (FALSE) {
[08:29:17.453]     }
[08:29:17.453]     else {
[08:29:17.453]         if (TRUE) {
[08:29:17.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:17.453]                 open = "w")
[08:29:17.453]         }
[08:29:17.453]         else {
[08:29:17.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:17.453]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:17.453]         }
[08:29:17.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:17.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:17.453]             base::sink(type = "output", split = FALSE)
[08:29:17.453]             base::close(...future.stdout)
[08:29:17.453]         }, add = TRUE)
[08:29:17.453]     }
[08:29:17.453]     ...future.frame <- base::sys.nframe()
[08:29:17.453]     ...future.conditions <- base::list()
[08:29:17.453]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:17.453]     if (FALSE) {
[08:29:17.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:17.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:17.453]     }
[08:29:17.453]     ...future.result <- base::tryCatch({
[08:29:17.453]         base::withCallingHandlers({
[08:29:17.453]             ...future.value <- base::withVisible(base::local({
[08:29:17.453]                 ...future.makeSendCondition <- base::local({
[08:29:17.453]                   sendCondition <- NULL
[08:29:17.453]                   function(frame = 1L) {
[08:29:17.453]                     if (is.function(sendCondition)) 
[08:29:17.453]                       return(sendCondition)
[08:29:17.453]                     ns <- getNamespace("parallel")
[08:29:17.453]                     if (exists("sendData", mode = "function", 
[08:29:17.453]                       envir = ns)) {
[08:29:17.453]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:17.453]                         envir = ns)
[08:29:17.453]                       envir <- sys.frame(frame)
[08:29:17.453]                       master <- NULL
[08:29:17.453]                       while (!identical(envir, .GlobalEnv) && 
[08:29:17.453]                         !identical(envir, emptyenv())) {
[08:29:17.453]                         if (exists("master", mode = "list", envir = envir, 
[08:29:17.453]                           inherits = FALSE)) {
[08:29:17.453]                           master <- get("master", mode = "list", 
[08:29:17.453]                             envir = envir, inherits = FALSE)
[08:29:17.453]                           if (inherits(master, c("SOCKnode", 
[08:29:17.453]                             "SOCK0node"))) {
[08:29:17.453]                             sendCondition <<- function(cond) {
[08:29:17.453]                               data <- list(type = "VALUE", value = cond, 
[08:29:17.453]                                 success = TRUE)
[08:29:17.453]                               parallel_sendData(master, data)
[08:29:17.453]                             }
[08:29:17.453]                             return(sendCondition)
[08:29:17.453]                           }
[08:29:17.453]                         }
[08:29:17.453]                         frame <- frame + 1L
[08:29:17.453]                         envir <- sys.frame(frame)
[08:29:17.453]                       }
[08:29:17.453]                     }
[08:29:17.453]                     sendCondition <<- function(cond) NULL
[08:29:17.453]                   }
[08:29:17.453]                 })
[08:29:17.453]                 withCallingHandlers({
[08:29:17.453]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:17.453]                 }, immediateCondition = function(cond) {
[08:29:17.453]                   sendCondition <- ...future.makeSendCondition()
[08:29:17.453]                   sendCondition(cond)
[08:29:17.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:17.453]                   {
[08:29:17.453]                     inherits <- base::inherits
[08:29:17.453]                     invokeRestart <- base::invokeRestart
[08:29:17.453]                     is.null <- base::is.null
[08:29:17.453]                     muffled <- FALSE
[08:29:17.453]                     if (inherits(cond, "message")) {
[08:29:17.453]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:17.453]                       if (muffled) 
[08:29:17.453]                         invokeRestart("muffleMessage")
[08:29:17.453]                     }
[08:29:17.453]                     else if (inherits(cond, "warning")) {
[08:29:17.453]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:17.453]                       if (muffled) 
[08:29:17.453]                         invokeRestart("muffleWarning")
[08:29:17.453]                     }
[08:29:17.453]                     else if (inherits(cond, "condition")) {
[08:29:17.453]                       if (!is.null(pattern)) {
[08:29:17.453]                         computeRestarts <- base::computeRestarts
[08:29:17.453]                         grepl <- base::grepl
[08:29:17.453]                         restarts <- computeRestarts(cond)
[08:29:17.453]                         for (restart in restarts) {
[08:29:17.453]                           name <- restart$name
[08:29:17.453]                           if (is.null(name)) 
[08:29:17.453]                             next
[08:29:17.453]                           if (!grepl(pattern, name)) 
[08:29:17.453]                             next
[08:29:17.453]                           invokeRestart(restart)
[08:29:17.453]                           muffled <- TRUE
[08:29:17.453]                           break
[08:29:17.453]                         }
[08:29:17.453]                       }
[08:29:17.453]                     }
[08:29:17.453]                     invisible(muffled)
[08:29:17.453]                   }
[08:29:17.453]                   muffleCondition(cond)
[08:29:17.453]                 })
[08:29:17.453]             }))
[08:29:17.453]             future::FutureResult(value = ...future.value$value, 
[08:29:17.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:17.453]                   ...future.rng), globalenv = if (FALSE) 
[08:29:17.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:17.453]                     ...future.globalenv.names))
[08:29:17.453]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:17.453]         }, condition = base::local({
[08:29:17.453]             c <- base::c
[08:29:17.453]             inherits <- base::inherits
[08:29:17.453]             invokeRestart <- base::invokeRestart
[08:29:17.453]             length <- base::length
[08:29:17.453]             list <- base::list
[08:29:17.453]             seq.int <- base::seq.int
[08:29:17.453]             signalCondition <- base::signalCondition
[08:29:17.453]             sys.calls <- base::sys.calls
[08:29:17.453]             `[[` <- base::`[[`
[08:29:17.453]             `+` <- base::`+`
[08:29:17.453]             `<<-` <- base::`<<-`
[08:29:17.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:17.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:17.453]                   3L)]
[08:29:17.453]             }
[08:29:17.453]             function(cond) {
[08:29:17.453]                 is_error <- inherits(cond, "error")
[08:29:17.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:17.453]                   NULL)
[08:29:17.453]                 if (is_error) {
[08:29:17.453]                   sessionInformation <- function() {
[08:29:17.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:17.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:17.453]                       search = base::search(), system = base::Sys.info())
[08:29:17.453]                   }
[08:29:17.453]                   ...future.conditions[[length(...future.conditions) + 
[08:29:17.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:17.453]                     cond$call), session = sessionInformation(), 
[08:29:17.453]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:17.453]                   signalCondition(cond)
[08:29:17.453]                 }
[08:29:17.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:17.453]                 "immediateCondition"))) {
[08:29:17.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:17.453]                   ...future.conditions[[length(...future.conditions) + 
[08:29:17.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:17.453]                   if (TRUE && !signal) {
[08:29:17.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:17.453]                     {
[08:29:17.453]                       inherits <- base::inherits
[08:29:17.453]                       invokeRestart <- base::invokeRestart
[08:29:17.453]                       is.null <- base::is.null
[08:29:17.453]                       muffled <- FALSE
[08:29:17.453]                       if (inherits(cond, "message")) {
[08:29:17.453]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:17.453]                         if (muffled) 
[08:29:17.453]                           invokeRestart("muffleMessage")
[08:29:17.453]                       }
[08:29:17.453]                       else if (inherits(cond, "warning")) {
[08:29:17.453]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:17.453]                         if (muffled) 
[08:29:17.453]                           invokeRestart("muffleWarning")
[08:29:17.453]                       }
[08:29:17.453]                       else if (inherits(cond, "condition")) {
[08:29:17.453]                         if (!is.null(pattern)) {
[08:29:17.453]                           computeRestarts <- base::computeRestarts
[08:29:17.453]                           grepl <- base::grepl
[08:29:17.453]                           restarts <- computeRestarts(cond)
[08:29:17.453]                           for (restart in restarts) {
[08:29:17.453]                             name <- restart$name
[08:29:17.453]                             if (is.null(name)) 
[08:29:17.453]                               next
[08:29:17.453]                             if (!grepl(pattern, name)) 
[08:29:17.453]                               next
[08:29:17.453]                             invokeRestart(restart)
[08:29:17.453]                             muffled <- TRUE
[08:29:17.453]                             break
[08:29:17.453]                           }
[08:29:17.453]                         }
[08:29:17.453]                       }
[08:29:17.453]                       invisible(muffled)
[08:29:17.453]                     }
[08:29:17.453]                     muffleCondition(cond, pattern = "^muffle")
[08:29:17.453]                   }
[08:29:17.453]                 }
[08:29:17.453]                 else {
[08:29:17.453]                   if (TRUE) {
[08:29:17.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:17.453]                     {
[08:29:17.453]                       inherits <- base::inherits
[08:29:17.453]                       invokeRestart <- base::invokeRestart
[08:29:17.453]                       is.null <- base::is.null
[08:29:17.453]                       muffled <- FALSE
[08:29:17.453]                       if (inherits(cond, "message")) {
[08:29:17.453]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:17.453]                         if (muffled) 
[08:29:17.453]                           invokeRestart("muffleMessage")
[08:29:17.453]                       }
[08:29:17.453]                       else if (inherits(cond, "warning")) {
[08:29:17.453]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:17.453]                         if (muffled) 
[08:29:17.453]                           invokeRestart("muffleWarning")
[08:29:17.453]                       }
[08:29:17.453]                       else if (inherits(cond, "condition")) {
[08:29:17.453]                         if (!is.null(pattern)) {
[08:29:17.453]                           computeRestarts <- base::computeRestarts
[08:29:17.453]                           grepl <- base::grepl
[08:29:17.453]                           restarts <- computeRestarts(cond)
[08:29:17.453]                           for (restart in restarts) {
[08:29:17.453]                             name <- restart$name
[08:29:17.453]                             if (is.null(name)) 
[08:29:17.453]                               next
[08:29:17.453]                             if (!grepl(pattern, name)) 
[08:29:17.453]                               next
[08:29:17.453]                             invokeRestart(restart)
[08:29:17.453]                             muffled <- TRUE
[08:29:17.453]                             break
[08:29:17.453]                           }
[08:29:17.453]                         }
[08:29:17.453]                       }
[08:29:17.453]                       invisible(muffled)
[08:29:17.453]                     }
[08:29:17.453]                     muffleCondition(cond, pattern = "^muffle")
[08:29:17.453]                   }
[08:29:17.453]                 }
[08:29:17.453]             }
[08:29:17.453]         }))
[08:29:17.453]     }, error = function(ex) {
[08:29:17.453]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:17.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:17.453]                 ...future.rng), started = ...future.startTime, 
[08:29:17.453]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:17.453]             version = "1.8"), class = "FutureResult")
[08:29:17.453]     }, finally = {
[08:29:17.453]         if (!identical(...future.workdir, getwd())) 
[08:29:17.453]             setwd(...future.workdir)
[08:29:17.453]         {
[08:29:17.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:17.453]                 ...future.oldOptions$nwarnings <- NULL
[08:29:17.453]             }
[08:29:17.453]             base::options(...future.oldOptions)
[08:29:17.453]             if (.Platform$OS.type == "windows") {
[08:29:17.453]                 old_names <- names(...future.oldEnvVars)
[08:29:17.453]                 envs <- base::Sys.getenv()
[08:29:17.453]                 names <- names(envs)
[08:29:17.453]                 common <- intersect(names, old_names)
[08:29:17.453]                 added <- setdiff(names, old_names)
[08:29:17.453]                 removed <- setdiff(old_names, names)
[08:29:17.453]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:17.453]                   envs[common]]
[08:29:17.453]                 NAMES <- toupper(changed)
[08:29:17.453]                 args <- list()
[08:29:17.453]                 for (kk in seq_along(NAMES)) {
[08:29:17.453]                   name <- changed[[kk]]
[08:29:17.453]                   NAME <- NAMES[[kk]]
[08:29:17.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:17.453]                     next
[08:29:17.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:17.453]                 }
[08:29:17.453]                 NAMES <- toupper(added)
[08:29:17.453]                 for (kk in seq_along(NAMES)) {
[08:29:17.453]                   name <- added[[kk]]
[08:29:17.453]                   NAME <- NAMES[[kk]]
[08:29:17.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:17.453]                     next
[08:29:17.453]                   args[[name]] <- ""
[08:29:17.453]                 }
[08:29:17.453]                 NAMES <- toupper(removed)
[08:29:17.453]                 for (kk in seq_along(NAMES)) {
[08:29:17.453]                   name <- removed[[kk]]
[08:29:17.453]                   NAME <- NAMES[[kk]]
[08:29:17.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:17.453]                     next
[08:29:17.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:17.453]                 }
[08:29:17.453]                 if (length(args) > 0) 
[08:29:17.453]                   base::do.call(base::Sys.setenv, args = args)
[08:29:17.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:17.453]             }
[08:29:17.453]             else {
[08:29:17.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:17.453]             }
[08:29:17.453]             {
[08:29:17.453]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:17.453]                   0L) {
[08:29:17.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:17.453]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:17.453]                   base::options(opts)
[08:29:17.453]                 }
[08:29:17.453]                 {
[08:29:17.453]                   {
[08:29:17.453]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:17.453]                     NULL
[08:29:17.453]                   }
[08:29:17.453]                   options(future.plan = NULL)
[08:29:17.453]                   if (is.na(NA_character_)) 
[08:29:17.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:17.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:17.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:17.453]                     .init = FALSE)
[08:29:17.453]                 }
[08:29:17.453]             }
[08:29:17.453]         }
[08:29:17.453]     })
[08:29:17.453]     if (TRUE) {
[08:29:17.453]         base::sink(type = "output", split = FALSE)
[08:29:17.453]         if (TRUE) {
[08:29:17.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:17.453]         }
[08:29:17.453]         else {
[08:29:17.453]             ...future.result["stdout"] <- base::list(NULL)
[08:29:17.453]         }
[08:29:17.453]         base::close(...future.stdout)
[08:29:17.453]         ...future.stdout <- NULL
[08:29:17.453]     }
[08:29:17.453]     ...future.result$conditions <- ...future.conditions
[08:29:17.453]     ...future.result$finished <- base::Sys.time()
[08:29:17.453]     ...future.result
[08:29:17.453] }
[08:29:17.456] MultisessionFuture started
[08:29:17.456] - Launch lazy future ... done
[08:29:17.456] run() for ‘MultisessionFuture’ ... done
[08:29:17.499] receiveMessageFromWorker() for ClusterFuture ...
[08:29:17.499] - Validating connection of MultisessionFuture
[08:29:17.500] - received message: FutureResult
[08:29:17.500] - Received FutureResult
[08:29:17.500] - Erased future from FutureRegistry
[08:29:17.500] result() for ClusterFuture ...
[08:29:17.500] - result already collected: FutureResult
[08:29:17.500] result() for ClusterFuture ... done
[08:29:17.500] signalConditions() ...
[08:29:17.500]  - include = ‘immediateCondition’
[08:29:17.500]  - exclude = 
[08:29:17.500]  - resignal = FALSE
[08:29:17.501]  - Number of conditions: 1
[08:29:17.501] signalConditions() ... done
[08:29:17.501] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:17.501] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[08:29:17.501] getGlobalsAndPackages() ...
[08:29:17.501] Searching for globals...
[08:29:17.502] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:17.503] Searching for globals ... DONE
[08:29:17.503] Resolving globals: FALSE
[08:29:17.503] 
[08:29:17.503] 
[08:29:17.503] getGlobalsAndPackages() ... DONE
[08:29:17.503] run() for ‘Future’ ...
[08:29:17.504] - state: ‘created’
[08:29:17.504] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:17.518] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:17.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:17.518]   - Field: ‘node’
[08:29:17.518]   - Field: ‘label’
[08:29:17.519]   - Field: ‘local’
[08:29:17.519]   - Field: ‘owner’
[08:29:17.519]   - Field: ‘envir’
[08:29:17.519]   - Field: ‘workers’
[08:29:17.519]   - Field: ‘packages’
[08:29:17.519]   - Field: ‘gc’
[08:29:17.519]   - Field: ‘conditions’
[08:29:17.519]   - Field: ‘persistent’
[08:29:17.519]   - Field: ‘expr’
[08:29:17.519]   - Field: ‘uuid’
[08:29:17.519]   - Field: ‘seed’
[08:29:17.519]   - Field: ‘version’
[08:29:17.520]   - Field: ‘result’
[08:29:17.520]   - Field: ‘asynchronous’
[08:29:17.520]   - Field: ‘calls’
[08:29:17.520]   - Field: ‘globals’
[08:29:17.520]   - Field: ‘stdout’
[08:29:17.520]   - Field: ‘earlySignal’
[08:29:17.520]   - Field: ‘lazy’
[08:29:17.520]   - Field: ‘state’
[08:29:17.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:17.520] - Launch lazy future ...
[08:29:17.521] Packages needed by the future expression (n = 0): <none>
[08:29:17.521] Packages needed by future strategies (n = 0): <none>
[08:29:17.521] {
[08:29:17.521]     {
[08:29:17.521]         {
[08:29:17.521]             ...future.startTime <- base::Sys.time()
[08:29:17.521]             {
[08:29:17.521]                 {
[08:29:17.521]                   {
[08:29:17.521]                     {
[08:29:17.521]                       base::local({
[08:29:17.521]                         has_future <- base::requireNamespace("future", 
[08:29:17.521]                           quietly = TRUE)
[08:29:17.521]                         if (has_future) {
[08:29:17.521]                           ns <- base::getNamespace("future")
[08:29:17.521]                           version <- ns[[".package"]][["version"]]
[08:29:17.521]                           if (is.null(version)) 
[08:29:17.521]                             version <- utils::packageVersion("future")
[08:29:17.521]                         }
[08:29:17.521]                         else {
[08:29:17.521]                           version <- NULL
[08:29:17.521]                         }
[08:29:17.521]                         if (!has_future || version < "1.8.0") {
[08:29:17.521]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:17.521]                             "", base::R.version$version.string), 
[08:29:17.521]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:17.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:17.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:17.521]                               "release", "version")], collapse = " "), 
[08:29:17.521]                             hostname = base::Sys.info()[["nodename"]])
[08:29:17.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:17.521]                             info)
[08:29:17.521]                           info <- base::paste(info, collapse = "; ")
[08:29:17.521]                           if (!has_future) {
[08:29:17.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:17.521]                               info)
[08:29:17.521]                           }
[08:29:17.521]                           else {
[08:29:17.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:17.521]                               info, version)
[08:29:17.521]                           }
[08:29:17.521]                           base::stop(msg)
[08:29:17.521]                         }
[08:29:17.521]                       })
[08:29:17.521]                     }
[08:29:17.521]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:17.521]                     base::options(mc.cores = 1L)
[08:29:17.521]                   }
[08:29:17.521]                   ...future.strategy.old <- future::plan("list")
[08:29:17.521]                   options(future.plan = NULL)
[08:29:17.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:17.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:17.521]                 }
[08:29:17.521]                 ...future.workdir <- getwd()
[08:29:17.521]             }
[08:29:17.521]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:17.521]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:17.521]         }
[08:29:17.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:17.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:17.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:17.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:17.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:17.521]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:17.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:17.521]             base::names(...future.oldOptions))
[08:29:17.521]     }
[08:29:17.521]     if (FALSE) {
[08:29:17.521]     }
[08:29:17.521]     else {
[08:29:17.521]         if (TRUE) {
[08:29:17.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:17.521]                 open = "w")
[08:29:17.521]         }
[08:29:17.521]         else {
[08:29:17.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:17.521]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:17.521]         }
[08:29:17.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:17.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:17.521]             base::sink(type = "output", split = FALSE)
[08:29:17.521]             base::close(...future.stdout)
[08:29:17.521]         }, add = TRUE)
[08:29:17.521]     }
[08:29:17.521]     ...future.frame <- base::sys.nframe()
[08:29:17.521]     ...future.conditions <- base::list()
[08:29:17.521]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:17.521]     if (FALSE) {
[08:29:17.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:17.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:17.521]     }
[08:29:17.521]     ...future.result <- base::tryCatch({
[08:29:17.521]         base::withCallingHandlers({
[08:29:17.521]             ...future.value <- base::withVisible(base::local({
[08:29:17.521]                 ...future.makeSendCondition <- base::local({
[08:29:17.521]                   sendCondition <- NULL
[08:29:17.521]                   function(frame = 1L) {
[08:29:17.521]                     if (is.function(sendCondition)) 
[08:29:17.521]                       return(sendCondition)
[08:29:17.521]                     ns <- getNamespace("parallel")
[08:29:17.521]                     if (exists("sendData", mode = "function", 
[08:29:17.521]                       envir = ns)) {
[08:29:17.521]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:17.521]                         envir = ns)
[08:29:17.521]                       envir <- sys.frame(frame)
[08:29:17.521]                       master <- NULL
[08:29:17.521]                       while (!identical(envir, .GlobalEnv) && 
[08:29:17.521]                         !identical(envir, emptyenv())) {
[08:29:17.521]                         if (exists("master", mode = "list", envir = envir, 
[08:29:17.521]                           inherits = FALSE)) {
[08:29:17.521]                           master <- get("master", mode = "list", 
[08:29:17.521]                             envir = envir, inherits = FALSE)
[08:29:17.521]                           if (inherits(master, c("SOCKnode", 
[08:29:17.521]                             "SOCK0node"))) {
[08:29:17.521]                             sendCondition <<- function(cond) {
[08:29:17.521]                               data <- list(type = "VALUE", value = cond, 
[08:29:17.521]                                 success = TRUE)
[08:29:17.521]                               parallel_sendData(master, data)
[08:29:17.521]                             }
[08:29:17.521]                             return(sendCondition)
[08:29:17.521]                           }
[08:29:17.521]                         }
[08:29:17.521]                         frame <- frame + 1L
[08:29:17.521]                         envir <- sys.frame(frame)
[08:29:17.521]                       }
[08:29:17.521]                     }
[08:29:17.521]                     sendCondition <<- function(cond) NULL
[08:29:17.521]                   }
[08:29:17.521]                 })
[08:29:17.521]                 withCallingHandlers({
[08:29:17.521]                   {
[08:29:17.521]                     Sys.sleep(0.5)
[08:29:17.521]                     list(a = 1, b = 42L)
[08:29:17.521]                   }
[08:29:17.521]                 }, immediateCondition = function(cond) {
[08:29:17.521]                   sendCondition <- ...future.makeSendCondition()
[08:29:17.521]                   sendCondition(cond)
[08:29:17.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:17.521]                   {
[08:29:17.521]                     inherits <- base::inherits
[08:29:17.521]                     invokeRestart <- base::invokeRestart
[08:29:17.521]                     is.null <- base::is.null
[08:29:17.521]                     muffled <- FALSE
[08:29:17.521]                     if (inherits(cond, "message")) {
[08:29:17.521]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:17.521]                       if (muffled) 
[08:29:17.521]                         invokeRestart("muffleMessage")
[08:29:17.521]                     }
[08:29:17.521]                     else if (inherits(cond, "warning")) {
[08:29:17.521]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:17.521]                       if (muffled) 
[08:29:17.521]                         invokeRestart("muffleWarning")
[08:29:17.521]                     }
[08:29:17.521]                     else if (inherits(cond, "condition")) {
[08:29:17.521]                       if (!is.null(pattern)) {
[08:29:17.521]                         computeRestarts <- base::computeRestarts
[08:29:17.521]                         grepl <- base::grepl
[08:29:17.521]                         restarts <- computeRestarts(cond)
[08:29:17.521]                         for (restart in restarts) {
[08:29:17.521]                           name <- restart$name
[08:29:17.521]                           if (is.null(name)) 
[08:29:17.521]                             next
[08:29:17.521]                           if (!grepl(pattern, name)) 
[08:29:17.521]                             next
[08:29:17.521]                           invokeRestart(restart)
[08:29:17.521]                           muffled <- TRUE
[08:29:17.521]                           break
[08:29:17.521]                         }
[08:29:17.521]                       }
[08:29:17.521]                     }
[08:29:17.521]                     invisible(muffled)
[08:29:17.521]                   }
[08:29:17.521]                   muffleCondition(cond)
[08:29:17.521]                 })
[08:29:17.521]             }))
[08:29:17.521]             future::FutureResult(value = ...future.value$value, 
[08:29:17.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:17.521]                   ...future.rng), globalenv = if (FALSE) 
[08:29:17.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:17.521]                     ...future.globalenv.names))
[08:29:17.521]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:17.521]         }, condition = base::local({
[08:29:17.521]             c <- base::c
[08:29:17.521]             inherits <- base::inherits
[08:29:17.521]             invokeRestart <- base::invokeRestart
[08:29:17.521]             length <- base::length
[08:29:17.521]             list <- base::list
[08:29:17.521]             seq.int <- base::seq.int
[08:29:17.521]             signalCondition <- base::signalCondition
[08:29:17.521]             sys.calls <- base::sys.calls
[08:29:17.521]             `[[` <- base::`[[`
[08:29:17.521]             `+` <- base::`+`
[08:29:17.521]             `<<-` <- base::`<<-`
[08:29:17.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:17.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:17.521]                   3L)]
[08:29:17.521]             }
[08:29:17.521]             function(cond) {
[08:29:17.521]                 is_error <- inherits(cond, "error")
[08:29:17.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:17.521]                   NULL)
[08:29:17.521]                 if (is_error) {
[08:29:17.521]                   sessionInformation <- function() {
[08:29:17.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:17.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:17.521]                       search = base::search(), system = base::Sys.info())
[08:29:17.521]                   }
[08:29:17.521]                   ...future.conditions[[length(...future.conditions) + 
[08:29:17.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:17.521]                     cond$call), session = sessionInformation(), 
[08:29:17.521]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:17.521]                   signalCondition(cond)
[08:29:17.521]                 }
[08:29:17.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:17.521]                 "immediateCondition"))) {
[08:29:17.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:17.521]                   ...future.conditions[[length(...future.conditions) + 
[08:29:17.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:17.521]                   if (TRUE && !signal) {
[08:29:17.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:17.521]                     {
[08:29:17.521]                       inherits <- base::inherits
[08:29:17.521]                       invokeRestart <- base::invokeRestart
[08:29:17.521]                       is.null <- base::is.null
[08:29:17.521]                       muffled <- FALSE
[08:29:17.521]                       if (inherits(cond, "message")) {
[08:29:17.521]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:17.521]                         if (muffled) 
[08:29:17.521]                           invokeRestart("muffleMessage")
[08:29:17.521]                       }
[08:29:17.521]                       else if (inherits(cond, "warning")) {
[08:29:17.521]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:17.521]                         if (muffled) 
[08:29:17.521]                           invokeRestart("muffleWarning")
[08:29:17.521]                       }
[08:29:17.521]                       else if (inherits(cond, "condition")) {
[08:29:17.521]                         if (!is.null(pattern)) {
[08:29:17.521]                           computeRestarts <- base::computeRestarts
[08:29:17.521]                           grepl <- base::grepl
[08:29:17.521]                           restarts <- computeRestarts(cond)
[08:29:17.521]                           for (restart in restarts) {
[08:29:17.521]                             name <- restart$name
[08:29:17.521]                             if (is.null(name)) 
[08:29:17.521]                               next
[08:29:17.521]                             if (!grepl(pattern, name)) 
[08:29:17.521]                               next
[08:29:17.521]                             invokeRestart(restart)
[08:29:17.521]                             muffled <- TRUE
[08:29:17.521]                             break
[08:29:17.521]                           }
[08:29:17.521]                         }
[08:29:17.521]                       }
[08:29:17.521]                       invisible(muffled)
[08:29:17.521]                     }
[08:29:17.521]                     muffleCondition(cond, pattern = "^muffle")
[08:29:17.521]                   }
[08:29:17.521]                 }
[08:29:17.521]                 else {
[08:29:17.521]                   if (TRUE) {
[08:29:17.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:17.521]                     {
[08:29:17.521]                       inherits <- base::inherits
[08:29:17.521]                       invokeRestart <- base::invokeRestart
[08:29:17.521]                       is.null <- base::is.null
[08:29:17.521]                       muffled <- FALSE
[08:29:17.521]                       if (inherits(cond, "message")) {
[08:29:17.521]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:17.521]                         if (muffled) 
[08:29:17.521]                           invokeRestart("muffleMessage")
[08:29:17.521]                       }
[08:29:17.521]                       else if (inherits(cond, "warning")) {
[08:29:17.521]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:17.521]                         if (muffled) 
[08:29:17.521]                           invokeRestart("muffleWarning")
[08:29:17.521]                       }
[08:29:17.521]                       else if (inherits(cond, "condition")) {
[08:29:17.521]                         if (!is.null(pattern)) {
[08:29:17.521]                           computeRestarts <- base::computeRestarts
[08:29:17.521]                           grepl <- base::grepl
[08:29:17.521]                           restarts <- computeRestarts(cond)
[08:29:17.521]                           for (restart in restarts) {
[08:29:17.521]                             name <- restart$name
[08:29:17.521]                             if (is.null(name)) 
[08:29:17.521]                               next
[08:29:17.521]                             if (!grepl(pattern, name)) 
[08:29:17.521]                               next
[08:29:17.521]                             invokeRestart(restart)
[08:29:17.521]                             muffled <- TRUE
[08:29:17.521]                             break
[08:29:17.521]                           }
[08:29:17.521]                         }
[08:29:17.521]                       }
[08:29:17.521]                       invisible(muffled)
[08:29:17.521]                     }
[08:29:17.521]                     muffleCondition(cond, pattern = "^muffle")
[08:29:17.521]                   }
[08:29:17.521]                 }
[08:29:17.521]             }
[08:29:17.521]         }))
[08:29:17.521]     }, error = function(ex) {
[08:29:17.521]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:17.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:17.521]                 ...future.rng), started = ...future.startTime, 
[08:29:17.521]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:17.521]             version = "1.8"), class = "FutureResult")
[08:29:17.521]     }, finally = {
[08:29:17.521]         if (!identical(...future.workdir, getwd())) 
[08:29:17.521]             setwd(...future.workdir)
[08:29:17.521]         {
[08:29:17.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:17.521]                 ...future.oldOptions$nwarnings <- NULL
[08:29:17.521]             }
[08:29:17.521]             base::options(...future.oldOptions)
[08:29:17.521]             if (.Platform$OS.type == "windows") {
[08:29:17.521]                 old_names <- names(...future.oldEnvVars)
[08:29:17.521]                 envs <- base::Sys.getenv()
[08:29:17.521]                 names <- names(envs)
[08:29:17.521]                 common <- intersect(names, old_names)
[08:29:17.521]                 added <- setdiff(names, old_names)
[08:29:17.521]                 removed <- setdiff(old_names, names)
[08:29:17.521]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:17.521]                   envs[common]]
[08:29:17.521]                 NAMES <- toupper(changed)
[08:29:17.521]                 args <- list()
[08:29:17.521]                 for (kk in seq_along(NAMES)) {
[08:29:17.521]                   name <- changed[[kk]]
[08:29:17.521]                   NAME <- NAMES[[kk]]
[08:29:17.521]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:17.521]                     next
[08:29:17.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:17.521]                 }
[08:29:17.521]                 NAMES <- toupper(added)
[08:29:17.521]                 for (kk in seq_along(NAMES)) {
[08:29:17.521]                   name <- added[[kk]]
[08:29:17.521]                   NAME <- NAMES[[kk]]
[08:29:17.521]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:17.521]                     next
[08:29:17.521]                   args[[name]] <- ""
[08:29:17.521]                 }
[08:29:17.521]                 NAMES <- toupper(removed)
[08:29:17.521]                 for (kk in seq_along(NAMES)) {
[08:29:17.521]                   name <- removed[[kk]]
[08:29:17.521]                   NAME <- NAMES[[kk]]
[08:29:17.521]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:17.521]                     next
[08:29:17.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:17.521]                 }
[08:29:17.521]                 if (length(args) > 0) 
[08:29:17.521]                   base::do.call(base::Sys.setenv, args = args)
[08:29:17.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:17.521]             }
[08:29:17.521]             else {
[08:29:17.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:17.521]             }
[08:29:17.521]             {
[08:29:17.521]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:17.521]                   0L) {
[08:29:17.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:17.521]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:17.521]                   base::options(opts)
[08:29:17.521]                 }
[08:29:17.521]                 {
[08:29:17.521]                   {
[08:29:17.521]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:17.521]                     NULL
[08:29:17.521]                   }
[08:29:17.521]                   options(future.plan = NULL)
[08:29:17.521]                   if (is.na(NA_character_)) 
[08:29:17.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:17.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:17.521]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:17.521]                     .init = FALSE)
[08:29:17.521]                 }
[08:29:17.521]             }
[08:29:17.521]         }
[08:29:17.521]     })
[08:29:17.521]     if (TRUE) {
[08:29:17.521]         base::sink(type = "output", split = FALSE)
[08:29:17.521]         if (TRUE) {
[08:29:17.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:17.521]         }
[08:29:17.521]         else {
[08:29:17.521]             ...future.result["stdout"] <- base::list(NULL)
[08:29:17.521]         }
[08:29:17.521]         base::close(...future.stdout)
[08:29:17.521]         ...future.stdout <- NULL
[08:29:17.521]     }
[08:29:17.521]     ...future.result$conditions <- ...future.conditions
[08:29:17.521]     ...future.result$finished <- base::Sys.time()
[08:29:17.521]     ...future.result
[08:29:17.521] }
[08:29:17.527] MultisessionFuture started
[08:29:17.528] - Launch lazy future ... done
[08:29:17.528] run() for ‘MultisessionFuture’ ... done
[08:29:18.071] receiveMessageFromWorker() for ClusterFuture ...
[08:29:18.071] - Validating connection of MultisessionFuture
[08:29:18.071] - received message: FutureResult
[08:29:18.071] - Received FutureResult
[08:29:18.072] - Erased future from FutureRegistry
[08:29:18.072] result() for ClusterFuture ...
[08:29:18.072] - result already collected: FutureResult
[08:29:18.072] result() for ClusterFuture ... done
[08:29:18.072] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:18.072] resolve() on list ...
[08:29:18.072]  recursive: 1
[08:29:18.073]  length: 2
[08:29:18.073]  elements: ‘a’, ‘b’
[08:29:18.073]  length: 1 (resolved future 1)
[08:29:18.073]  length: 0 (resolved future 2)
[08:29:18.073] resolve() on list ... DONE
[08:29:18.074] A MultisessionFuture was resolved (and resolved itself)
[08:29:18.074] getGlobalsAndPackages() ...
[08:29:18.074] Searching for globals...
[08:29:18.076] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:18.076] Searching for globals ... DONE
[08:29:18.076] Resolving globals: FALSE
[08:29:18.077] 
[08:29:18.077] 
[08:29:18.077] getGlobalsAndPackages() ... DONE
[08:29:18.077] run() for ‘Future’ ...
[08:29:18.078] - state: ‘created’
[08:29:18.078] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:18.094] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:18.094] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:18.094]   - Field: ‘node’
[08:29:18.094]   - Field: ‘label’
[08:29:18.094]   - Field: ‘local’
[08:29:18.094]   - Field: ‘owner’
[08:29:18.094]   - Field: ‘envir’
[08:29:18.094]   - Field: ‘workers’
[08:29:18.094]   - Field: ‘packages’
[08:29:18.094]   - Field: ‘gc’
[08:29:18.094]   - Field: ‘conditions’
[08:29:18.095]   - Field: ‘persistent’
[08:29:18.095]   - Field: ‘expr’
[08:29:18.095]   - Field: ‘uuid’
[08:29:18.095]   - Field: ‘seed’
[08:29:18.095]   - Field: ‘version’
[08:29:18.095]   - Field: ‘result’
[08:29:18.095]   - Field: ‘asynchronous’
[08:29:18.095]   - Field: ‘calls’
[08:29:18.095]   - Field: ‘globals’
[08:29:18.095]   - Field: ‘stdout’
[08:29:18.095]   - Field: ‘earlySignal’
[08:29:18.096]   - Field: ‘lazy’
[08:29:18.096]   - Field: ‘state’
[08:29:18.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:18.096] - Launch lazy future ...
[08:29:18.096] Packages needed by the future expression (n = 0): <none>
[08:29:18.096] Packages needed by future strategies (n = 0): <none>
[08:29:18.097] {
[08:29:18.097]     {
[08:29:18.097]         {
[08:29:18.097]             ...future.startTime <- base::Sys.time()
[08:29:18.097]             {
[08:29:18.097]                 {
[08:29:18.097]                   {
[08:29:18.097]                     {
[08:29:18.097]                       base::local({
[08:29:18.097]                         has_future <- base::requireNamespace("future", 
[08:29:18.097]                           quietly = TRUE)
[08:29:18.097]                         if (has_future) {
[08:29:18.097]                           ns <- base::getNamespace("future")
[08:29:18.097]                           version <- ns[[".package"]][["version"]]
[08:29:18.097]                           if (is.null(version)) 
[08:29:18.097]                             version <- utils::packageVersion("future")
[08:29:18.097]                         }
[08:29:18.097]                         else {
[08:29:18.097]                           version <- NULL
[08:29:18.097]                         }
[08:29:18.097]                         if (!has_future || version < "1.8.0") {
[08:29:18.097]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:18.097]                             "", base::R.version$version.string), 
[08:29:18.097]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:18.097]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:18.097]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:18.097]                               "release", "version")], collapse = " "), 
[08:29:18.097]                             hostname = base::Sys.info()[["nodename"]])
[08:29:18.097]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:18.097]                             info)
[08:29:18.097]                           info <- base::paste(info, collapse = "; ")
[08:29:18.097]                           if (!has_future) {
[08:29:18.097]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:18.097]                               info)
[08:29:18.097]                           }
[08:29:18.097]                           else {
[08:29:18.097]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:18.097]                               info, version)
[08:29:18.097]                           }
[08:29:18.097]                           base::stop(msg)
[08:29:18.097]                         }
[08:29:18.097]                       })
[08:29:18.097]                     }
[08:29:18.097]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:18.097]                     base::options(mc.cores = 1L)
[08:29:18.097]                   }
[08:29:18.097]                   ...future.strategy.old <- future::plan("list")
[08:29:18.097]                   options(future.plan = NULL)
[08:29:18.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:18.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:18.097]                 }
[08:29:18.097]                 ...future.workdir <- getwd()
[08:29:18.097]             }
[08:29:18.097]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:18.097]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:18.097]         }
[08:29:18.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:18.097]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:18.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:18.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:18.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:18.097]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:18.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:18.097]             base::names(...future.oldOptions))
[08:29:18.097]     }
[08:29:18.097]     if (FALSE) {
[08:29:18.097]     }
[08:29:18.097]     else {
[08:29:18.097]         if (TRUE) {
[08:29:18.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:18.097]                 open = "w")
[08:29:18.097]         }
[08:29:18.097]         else {
[08:29:18.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:18.097]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:18.097]         }
[08:29:18.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:18.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:18.097]             base::sink(type = "output", split = FALSE)
[08:29:18.097]             base::close(...future.stdout)
[08:29:18.097]         }, add = TRUE)
[08:29:18.097]     }
[08:29:18.097]     ...future.frame <- base::sys.nframe()
[08:29:18.097]     ...future.conditions <- base::list()
[08:29:18.097]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:18.097]     if (FALSE) {
[08:29:18.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:18.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:18.097]     }
[08:29:18.097]     ...future.result <- base::tryCatch({
[08:29:18.097]         base::withCallingHandlers({
[08:29:18.097]             ...future.value <- base::withVisible(base::local({
[08:29:18.097]                 ...future.makeSendCondition <- base::local({
[08:29:18.097]                   sendCondition <- NULL
[08:29:18.097]                   function(frame = 1L) {
[08:29:18.097]                     if (is.function(sendCondition)) 
[08:29:18.097]                       return(sendCondition)
[08:29:18.097]                     ns <- getNamespace("parallel")
[08:29:18.097]                     if (exists("sendData", mode = "function", 
[08:29:18.097]                       envir = ns)) {
[08:29:18.097]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:18.097]                         envir = ns)
[08:29:18.097]                       envir <- sys.frame(frame)
[08:29:18.097]                       master <- NULL
[08:29:18.097]                       while (!identical(envir, .GlobalEnv) && 
[08:29:18.097]                         !identical(envir, emptyenv())) {
[08:29:18.097]                         if (exists("master", mode = "list", envir = envir, 
[08:29:18.097]                           inherits = FALSE)) {
[08:29:18.097]                           master <- get("master", mode = "list", 
[08:29:18.097]                             envir = envir, inherits = FALSE)
[08:29:18.097]                           if (inherits(master, c("SOCKnode", 
[08:29:18.097]                             "SOCK0node"))) {
[08:29:18.097]                             sendCondition <<- function(cond) {
[08:29:18.097]                               data <- list(type = "VALUE", value = cond, 
[08:29:18.097]                                 success = TRUE)
[08:29:18.097]                               parallel_sendData(master, data)
[08:29:18.097]                             }
[08:29:18.097]                             return(sendCondition)
[08:29:18.097]                           }
[08:29:18.097]                         }
[08:29:18.097]                         frame <- frame + 1L
[08:29:18.097]                         envir <- sys.frame(frame)
[08:29:18.097]                       }
[08:29:18.097]                     }
[08:29:18.097]                     sendCondition <<- function(cond) NULL
[08:29:18.097]                   }
[08:29:18.097]                 })
[08:29:18.097]                 withCallingHandlers({
[08:29:18.097]                   {
[08:29:18.097]                     Sys.sleep(0.5)
[08:29:18.097]                     list(a = 1, b = 42L)
[08:29:18.097]                   }
[08:29:18.097]                 }, immediateCondition = function(cond) {
[08:29:18.097]                   sendCondition <- ...future.makeSendCondition()
[08:29:18.097]                   sendCondition(cond)
[08:29:18.097]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.097]                   {
[08:29:18.097]                     inherits <- base::inherits
[08:29:18.097]                     invokeRestart <- base::invokeRestart
[08:29:18.097]                     is.null <- base::is.null
[08:29:18.097]                     muffled <- FALSE
[08:29:18.097]                     if (inherits(cond, "message")) {
[08:29:18.097]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:18.097]                       if (muffled) 
[08:29:18.097]                         invokeRestart("muffleMessage")
[08:29:18.097]                     }
[08:29:18.097]                     else if (inherits(cond, "warning")) {
[08:29:18.097]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:18.097]                       if (muffled) 
[08:29:18.097]                         invokeRestart("muffleWarning")
[08:29:18.097]                     }
[08:29:18.097]                     else if (inherits(cond, "condition")) {
[08:29:18.097]                       if (!is.null(pattern)) {
[08:29:18.097]                         computeRestarts <- base::computeRestarts
[08:29:18.097]                         grepl <- base::grepl
[08:29:18.097]                         restarts <- computeRestarts(cond)
[08:29:18.097]                         for (restart in restarts) {
[08:29:18.097]                           name <- restart$name
[08:29:18.097]                           if (is.null(name)) 
[08:29:18.097]                             next
[08:29:18.097]                           if (!grepl(pattern, name)) 
[08:29:18.097]                             next
[08:29:18.097]                           invokeRestart(restart)
[08:29:18.097]                           muffled <- TRUE
[08:29:18.097]                           break
[08:29:18.097]                         }
[08:29:18.097]                       }
[08:29:18.097]                     }
[08:29:18.097]                     invisible(muffled)
[08:29:18.097]                   }
[08:29:18.097]                   muffleCondition(cond)
[08:29:18.097]                 })
[08:29:18.097]             }))
[08:29:18.097]             future::FutureResult(value = ...future.value$value, 
[08:29:18.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:18.097]                   ...future.rng), globalenv = if (FALSE) 
[08:29:18.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:18.097]                     ...future.globalenv.names))
[08:29:18.097]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:18.097]         }, condition = base::local({
[08:29:18.097]             c <- base::c
[08:29:18.097]             inherits <- base::inherits
[08:29:18.097]             invokeRestart <- base::invokeRestart
[08:29:18.097]             length <- base::length
[08:29:18.097]             list <- base::list
[08:29:18.097]             seq.int <- base::seq.int
[08:29:18.097]             signalCondition <- base::signalCondition
[08:29:18.097]             sys.calls <- base::sys.calls
[08:29:18.097]             `[[` <- base::`[[`
[08:29:18.097]             `+` <- base::`+`
[08:29:18.097]             `<<-` <- base::`<<-`
[08:29:18.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:18.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:18.097]                   3L)]
[08:29:18.097]             }
[08:29:18.097]             function(cond) {
[08:29:18.097]                 is_error <- inherits(cond, "error")
[08:29:18.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:18.097]                   NULL)
[08:29:18.097]                 if (is_error) {
[08:29:18.097]                   sessionInformation <- function() {
[08:29:18.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:18.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:18.097]                       search = base::search(), system = base::Sys.info())
[08:29:18.097]                   }
[08:29:18.097]                   ...future.conditions[[length(...future.conditions) + 
[08:29:18.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:18.097]                     cond$call), session = sessionInformation(), 
[08:29:18.097]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:18.097]                   signalCondition(cond)
[08:29:18.097]                 }
[08:29:18.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:18.097]                 "immediateCondition"))) {
[08:29:18.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:18.097]                   ...future.conditions[[length(...future.conditions) + 
[08:29:18.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:18.097]                   if (TRUE && !signal) {
[08:29:18.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.097]                     {
[08:29:18.097]                       inherits <- base::inherits
[08:29:18.097]                       invokeRestart <- base::invokeRestart
[08:29:18.097]                       is.null <- base::is.null
[08:29:18.097]                       muffled <- FALSE
[08:29:18.097]                       if (inherits(cond, "message")) {
[08:29:18.097]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:18.097]                         if (muffled) 
[08:29:18.097]                           invokeRestart("muffleMessage")
[08:29:18.097]                       }
[08:29:18.097]                       else if (inherits(cond, "warning")) {
[08:29:18.097]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:18.097]                         if (muffled) 
[08:29:18.097]                           invokeRestart("muffleWarning")
[08:29:18.097]                       }
[08:29:18.097]                       else if (inherits(cond, "condition")) {
[08:29:18.097]                         if (!is.null(pattern)) {
[08:29:18.097]                           computeRestarts <- base::computeRestarts
[08:29:18.097]                           grepl <- base::grepl
[08:29:18.097]                           restarts <- computeRestarts(cond)
[08:29:18.097]                           for (restart in restarts) {
[08:29:18.097]                             name <- restart$name
[08:29:18.097]                             if (is.null(name)) 
[08:29:18.097]                               next
[08:29:18.097]                             if (!grepl(pattern, name)) 
[08:29:18.097]                               next
[08:29:18.097]                             invokeRestart(restart)
[08:29:18.097]                             muffled <- TRUE
[08:29:18.097]                             break
[08:29:18.097]                           }
[08:29:18.097]                         }
[08:29:18.097]                       }
[08:29:18.097]                       invisible(muffled)
[08:29:18.097]                     }
[08:29:18.097]                     muffleCondition(cond, pattern = "^muffle")
[08:29:18.097]                   }
[08:29:18.097]                 }
[08:29:18.097]                 else {
[08:29:18.097]                   if (TRUE) {
[08:29:18.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.097]                     {
[08:29:18.097]                       inherits <- base::inherits
[08:29:18.097]                       invokeRestart <- base::invokeRestart
[08:29:18.097]                       is.null <- base::is.null
[08:29:18.097]                       muffled <- FALSE
[08:29:18.097]                       if (inherits(cond, "message")) {
[08:29:18.097]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:18.097]                         if (muffled) 
[08:29:18.097]                           invokeRestart("muffleMessage")
[08:29:18.097]                       }
[08:29:18.097]                       else if (inherits(cond, "warning")) {
[08:29:18.097]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:18.097]                         if (muffled) 
[08:29:18.097]                           invokeRestart("muffleWarning")
[08:29:18.097]                       }
[08:29:18.097]                       else if (inherits(cond, "condition")) {
[08:29:18.097]                         if (!is.null(pattern)) {
[08:29:18.097]                           computeRestarts <- base::computeRestarts
[08:29:18.097]                           grepl <- base::grepl
[08:29:18.097]                           restarts <- computeRestarts(cond)
[08:29:18.097]                           for (restart in restarts) {
[08:29:18.097]                             name <- restart$name
[08:29:18.097]                             if (is.null(name)) 
[08:29:18.097]                               next
[08:29:18.097]                             if (!grepl(pattern, name)) 
[08:29:18.097]                               next
[08:29:18.097]                             invokeRestart(restart)
[08:29:18.097]                             muffled <- TRUE
[08:29:18.097]                             break
[08:29:18.097]                           }
[08:29:18.097]                         }
[08:29:18.097]                       }
[08:29:18.097]                       invisible(muffled)
[08:29:18.097]                     }
[08:29:18.097]                     muffleCondition(cond, pattern = "^muffle")
[08:29:18.097]                   }
[08:29:18.097]                 }
[08:29:18.097]             }
[08:29:18.097]         }))
[08:29:18.097]     }, error = function(ex) {
[08:29:18.097]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:18.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:18.097]                 ...future.rng), started = ...future.startTime, 
[08:29:18.097]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:18.097]             version = "1.8"), class = "FutureResult")
[08:29:18.097]     }, finally = {
[08:29:18.097]         if (!identical(...future.workdir, getwd())) 
[08:29:18.097]             setwd(...future.workdir)
[08:29:18.097]         {
[08:29:18.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:18.097]                 ...future.oldOptions$nwarnings <- NULL
[08:29:18.097]             }
[08:29:18.097]             base::options(...future.oldOptions)
[08:29:18.097]             if (.Platform$OS.type == "windows") {
[08:29:18.097]                 old_names <- names(...future.oldEnvVars)
[08:29:18.097]                 envs <- base::Sys.getenv()
[08:29:18.097]                 names <- names(envs)
[08:29:18.097]                 common <- intersect(names, old_names)
[08:29:18.097]                 added <- setdiff(names, old_names)
[08:29:18.097]                 removed <- setdiff(old_names, names)
[08:29:18.097]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:18.097]                   envs[common]]
[08:29:18.097]                 NAMES <- toupper(changed)
[08:29:18.097]                 args <- list()
[08:29:18.097]                 for (kk in seq_along(NAMES)) {
[08:29:18.097]                   name <- changed[[kk]]
[08:29:18.097]                   NAME <- NAMES[[kk]]
[08:29:18.097]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.097]                     next
[08:29:18.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:18.097]                 }
[08:29:18.097]                 NAMES <- toupper(added)
[08:29:18.097]                 for (kk in seq_along(NAMES)) {
[08:29:18.097]                   name <- added[[kk]]
[08:29:18.097]                   NAME <- NAMES[[kk]]
[08:29:18.097]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.097]                     next
[08:29:18.097]                   args[[name]] <- ""
[08:29:18.097]                 }
[08:29:18.097]                 NAMES <- toupper(removed)
[08:29:18.097]                 for (kk in seq_along(NAMES)) {
[08:29:18.097]                   name <- removed[[kk]]
[08:29:18.097]                   NAME <- NAMES[[kk]]
[08:29:18.097]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.097]                     next
[08:29:18.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:18.097]                 }
[08:29:18.097]                 if (length(args) > 0) 
[08:29:18.097]                   base::do.call(base::Sys.setenv, args = args)
[08:29:18.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:18.097]             }
[08:29:18.097]             else {
[08:29:18.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:18.097]             }
[08:29:18.097]             {
[08:29:18.097]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:18.097]                   0L) {
[08:29:18.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:18.097]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:18.097]                   base::options(opts)
[08:29:18.097]                 }
[08:29:18.097]                 {
[08:29:18.097]                   {
[08:29:18.097]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:18.097]                     NULL
[08:29:18.097]                   }
[08:29:18.097]                   options(future.plan = NULL)
[08:29:18.097]                   if (is.na(NA_character_)) 
[08:29:18.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:18.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:18.097]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:18.097]                     .init = FALSE)
[08:29:18.097]                 }
[08:29:18.097]             }
[08:29:18.097]         }
[08:29:18.097]     })
[08:29:18.097]     if (TRUE) {
[08:29:18.097]         base::sink(type = "output", split = FALSE)
[08:29:18.097]         if (TRUE) {
[08:29:18.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:18.097]         }
[08:29:18.097]         else {
[08:29:18.097]             ...future.result["stdout"] <- base::list(NULL)
[08:29:18.097]         }
[08:29:18.097]         base::close(...future.stdout)
[08:29:18.097]         ...future.stdout <- NULL
[08:29:18.097]     }
[08:29:18.097]     ...future.result$conditions <- ...future.conditions
[08:29:18.097]     ...future.result$finished <- base::Sys.time()
[08:29:18.097]     ...future.result
[08:29:18.097] }
[08:29:18.100] MultisessionFuture started
[08:29:18.100] - Launch lazy future ... done
[08:29:18.100] run() for ‘MultisessionFuture’ ... done
[08:29:18.643] receiveMessageFromWorker() for ClusterFuture ...
[08:29:18.644] - Validating connection of MultisessionFuture
[08:29:18.644] - received message: FutureResult
[08:29:18.644] - Received FutureResult
[08:29:18.644] - Erased future from FutureRegistry
[08:29:18.644] result() for ClusterFuture ...
[08:29:18.644] - result already collected: FutureResult
[08:29:18.644] result() for ClusterFuture ... done
[08:29:18.644] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:18.645] resolve() on list ...
[08:29:18.645]  recursive: 1
[08:29:18.645]  length: 2
[08:29:18.645]  elements: ‘a’, ‘b’
[08:29:18.645]  length: 1 (resolved future 1)
[08:29:18.645]  length: 0 (resolved future 2)
[08:29:18.645] resolve() on list ... DONE
[08:29:18.645] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[08:29:18.645] getGlobalsAndPackages() ...
[08:29:18.645] Searching for globals...
[08:29:18.646] - globals found: [2] ‘list’, ‘stop’
[08:29:18.646] Searching for globals ... DONE
[08:29:18.646] Resolving globals: FALSE
[08:29:18.647] 
[08:29:18.647] 
[08:29:18.647] getGlobalsAndPackages() ... DONE
[08:29:18.647] run() for ‘Future’ ...
[08:29:18.647] - state: ‘created’
[08:29:18.647] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:18.661] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:18.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:18.661]   - Field: ‘node’
[08:29:18.661]   - Field: ‘label’
[08:29:18.662]   - Field: ‘local’
[08:29:18.662]   - Field: ‘owner’
[08:29:18.662]   - Field: ‘envir’
[08:29:18.662]   - Field: ‘workers’
[08:29:18.662]   - Field: ‘packages’
[08:29:18.662]   - Field: ‘gc’
[08:29:18.662]   - Field: ‘conditions’
[08:29:18.662]   - Field: ‘persistent’
[08:29:18.662]   - Field: ‘expr’
[08:29:18.662]   - Field: ‘uuid’
[08:29:18.662]   - Field: ‘seed’
[08:29:18.663]   - Field: ‘version’
[08:29:18.663]   - Field: ‘result’
[08:29:18.663]   - Field: ‘asynchronous’
[08:29:18.663]   - Field: ‘calls’
[08:29:18.663]   - Field: ‘globals’
[08:29:18.663]   - Field: ‘stdout’
[08:29:18.663]   - Field: ‘earlySignal’
[08:29:18.663]   - Field: ‘lazy’
[08:29:18.663]   - Field: ‘state’
[08:29:18.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:18.663] - Launch lazy future ...
[08:29:18.664] Packages needed by the future expression (n = 0): <none>
[08:29:18.664] Packages needed by future strategies (n = 0): <none>
[08:29:18.664] {
[08:29:18.664]     {
[08:29:18.664]         {
[08:29:18.664]             ...future.startTime <- base::Sys.time()
[08:29:18.664]             {
[08:29:18.664]                 {
[08:29:18.664]                   {
[08:29:18.664]                     {
[08:29:18.664]                       base::local({
[08:29:18.664]                         has_future <- base::requireNamespace("future", 
[08:29:18.664]                           quietly = TRUE)
[08:29:18.664]                         if (has_future) {
[08:29:18.664]                           ns <- base::getNamespace("future")
[08:29:18.664]                           version <- ns[[".package"]][["version"]]
[08:29:18.664]                           if (is.null(version)) 
[08:29:18.664]                             version <- utils::packageVersion("future")
[08:29:18.664]                         }
[08:29:18.664]                         else {
[08:29:18.664]                           version <- NULL
[08:29:18.664]                         }
[08:29:18.664]                         if (!has_future || version < "1.8.0") {
[08:29:18.664]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:18.664]                             "", base::R.version$version.string), 
[08:29:18.664]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:18.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:18.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:18.664]                               "release", "version")], collapse = " "), 
[08:29:18.664]                             hostname = base::Sys.info()[["nodename"]])
[08:29:18.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:18.664]                             info)
[08:29:18.664]                           info <- base::paste(info, collapse = "; ")
[08:29:18.664]                           if (!has_future) {
[08:29:18.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:18.664]                               info)
[08:29:18.664]                           }
[08:29:18.664]                           else {
[08:29:18.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:18.664]                               info, version)
[08:29:18.664]                           }
[08:29:18.664]                           base::stop(msg)
[08:29:18.664]                         }
[08:29:18.664]                       })
[08:29:18.664]                     }
[08:29:18.664]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:18.664]                     base::options(mc.cores = 1L)
[08:29:18.664]                   }
[08:29:18.664]                   ...future.strategy.old <- future::plan("list")
[08:29:18.664]                   options(future.plan = NULL)
[08:29:18.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:18.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:18.664]                 }
[08:29:18.664]                 ...future.workdir <- getwd()
[08:29:18.664]             }
[08:29:18.664]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:18.664]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:18.664]         }
[08:29:18.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:18.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:18.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:18.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:18.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:18.664]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:18.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:18.664]             base::names(...future.oldOptions))
[08:29:18.664]     }
[08:29:18.664]     if (FALSE) {
[08:29:18.664]     }
[08:29:18.664]     else {
[08:29:18.664]         if (TRUE) {
[08:29:18.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:18.664]                 open = "w")
[08:29:18.664]         }
[08:29:18.664]         else {
[08:29:18.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:18.664]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:18.664]         }
[08:29:18.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:18.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:18.664]             base::sink(type = "output", split = FALSE)
[08:29:18.664]             base::close(...future.stdout)
[08:29:18.664]         }, add = TRUE)
[08:29:18.664]     }
[08:29:18.664]     ...future.frame <- base::sys.nframe()
[08:29:18.664]     ...future.conditions <- base::list()
[08:29:18.664]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:18.664]     if (FALSE) {
[08:29:18.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:18.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:18.664]     }
[08:29:18.664]     ...future.result <- base::tryCatch({
[08:29:18.664]         base::withCallingHandlers({
[08:29:18.664]             ...future.value <- base::withVisible(base::local({
[08:29:18.664]                 ...future.makeSendCondition <- base::local({
[08:29:18.664]                   sendCondition <- NULL
[08:29:18.664]                   function(frame = 1L) {
[08:29:18.664]                     if (is.function(sendCondition)) 
[08:29:18.664]                       return(sendCondition)
[08:29:18.664]                     ns <- getNamespace("parallel")
[08:29:18.664]                     if (exists("sendData", mode = "function", 
[08:29:18.664]                       envir = ns)) {
[08:29:18.664]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:18.664]                         envir = ns)
[08:29:18.664]                       envir <- sys.frame(frame)
[08:29:18.664]                       master <- NULL
[08:29:18.664]                       while (!identical(envir, .GlobalEnv) && 
[08:29:18.664]                         !identical(envir, emptyenv())) {
[08:29:18.664]                         if (exists("master", mode = "list", envir = envir, 
[08:29:18.664]                           inherits = FALSE)) {
[08:29:18.664]                           master <- get("master", mode = "list", 
[08:29:18.664]                             envir = envir, inherits = FALSE)
[08:29:18.664]                           if (inherits(master, c("SOCKnode", 
[08:29:18.664]                             "SOCK0node"))) {
[08:29:18.664]                             sendCondition <<- function(cond) {
[08:29:18.664]                               data <- list(type = "VALUE", value = cond, 
[08:29:18.664]                                 success = TRUE)
[08:29:18.664]                               parallel_sendData(master, data)
[08:29:18.664]                             }
[08:29:18.664]                             return(sendCondition)
[08:29:18.664]                           }
[08:29:18.664]                         }
[08:29:18.664]                         frame <- frame + 1L
[08:29:18.664]                         envir <- sys.frame(frame)
[08:29:18.664]                       }
[08:29:18.664]                     }
[08:29:18.664]                     sendCondition <<- function(cond) NULL
[08:29:18.664]                   }
[08:29:18.664]                 })
[08:29:18.664]                 withCallingHandlers({
[08:29:18.664]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:18.664]                 }, immediateCondition = function(cond) {
[08:29:18.664]                   sendCondition <- ...future.makeSendCondition()
[08:29:18.664]                   sendCondition(cond)
[08:29:18.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.664]                   {
[08:29:18.664]                     inherits <- base::inherits
[08:29:18.664]                     invokeRestart <- base::invokeRestart
[08:29:18.664]                     is.null <- base::is.null
[08:29:18.664]                     muffled <- FALSE
[08:29:18.664]                     if (inherits(cond, "message")) {
[08:29:18.664]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:18.664]                       if (muffled) 
[08:29:18.664]                         invokeRestart("muffleMessage")
[08:29:18.664]                     }
[08:29:18.664]                     else if (inherits(cond, "warning")) {
[08:29:18.664]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:18.664]                       if (muffled) 
[08:29:18.664]                         invokeRestart("muffleWarning")
[08:29:18.664]                     }
[08:29:18.664]                     else if (inherits(cond, "condition")) {
[08:29:18.664]                       if (!is.null(pattern)) {
[08:29:18.664]                         computeRestarts <- base::computeRestarts
[08:29:18.664]                         grepl <- base::grepl
[08:29:18.664]                         restarts <- computeRestarts(cond)
[08:29:18.664]                         for (restart in restarts) {
[08:29:18.664]                           name <- restart$name
[08:29:18.664]                           if (is.null(name)) 
[08:29:18.664]                             next
[08:29:18.664]                           if (!grepl(pattern, name)) 
[08:29:18.664]                             next
[08:29:18.664]                           invokeRestart(restart)
[08:29:18.664]                           muffled <- TRUE
[08:29:18.664]                           break
[08:29:18.664]                         }
[08:29:18.664]                       }
[08:29:18.664]                     }
[08:29:18.664]                     invisible(muffled)
[08:29:18.664]                   }
[08:29:18.664]                   muffleCondition(cond)
[08:29:18.664]                 })
[08:29:18.664]             }))
[08:29:18.664]             future::FutureResult(value = ...future.value$value, 
[08:29:18.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:18.664]                   ...future.rng), globalenv = if (FALSE) 
[08:29:18.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:18.664]                     ...future.globalenv.names))
[08:29:18.664]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:18.664]         }, condition = base::local({
[08:29:18.664]             c <- base::c
[08:29:18.664]             inherits <- base::inherits
[08:29:18.664]             invokeRestart <- base::invokeRestart
[08:29:18.664]             length <- base::length
[08:29:18.664]             list <- base::list
[08:29:18.664]             seq.int <- base::seq.int
[08:29:18.664]             signalCondition <- base::signalCondition
[08:29:18.664]             sys.calls <- base::sys.calls
[08:29:18.664]             `[[` <- base::`[[`
[08:29:18.664]             `+` <- base::`+`
[08:29:18.664]             `<<-` <- base::`<<-`
[08:29:18.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:18.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:18.664]                   3L)]
[08:29:18.664]             }
[08:29:18.664]             function(cond) {
[08:29:18.664]                 is_error <- inherits(cond, "error")
[08:29:18.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:18.664]                   NULL)
[08:29:18.664]                 if (is_error) {
[08:29:18.664]                   sessionInformation <- function() {
[08:29:18.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:18.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:18.664]                       search = base::search(), system = base::Sys.info())
[08:29:18.664]                   }
[08:29:18.664]                   ...future.conditions[[length(...future.conditions) + 
[08:29:18.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:18.664]                     cond$call), session = sessionInformation(), 
[08:29:18.664]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:18.664]                   signalCondition(cond)
[08:29:18.664]                 }
[08:29:18.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:18.664]                 "immediateCondition"))) {
[08:29:18.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:18.664]                   ...future.conditions[[length(...future.conditions) + 
[08:29:18.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:18.664]                   if (TRUE && !signal) {
[08:29:18.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.664]                     {
[08:29:18.664]                       inherits <- base::inherits
[08:29:18.664]                       invokeRestart <- base::invokeRestart
[08:29:18.664]                       is.null <- base::is.null
[08:29:18.664]                       muffled <- FALSE
[08:29:18.664]                       if (inherits(cond, "message")) {
[08:29:18.664]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:18.664]                         if (muffled) 
[08:29:18.664]                           invokeRestart("muffleMessage")
[08:29:18.664]                       }
[08:29:18.664]                       else if (inherits(cond, "warning")) {
[08:29:18.664]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:18.664]                         if (muffled) 
[08:29:18.664]                           invokeRestart("muffleWarning")
[08:29:18.664]                       }
[08:29:18.664]                       else if (inherits(cond, "condition")) {
[08:29:18.664]                         if (!is.null(pattern)) {
[08:29:18.664]                           computeRestarts <- base::computeRestarts
[08:29:18.664]                           grepl <- base::grepl
[08:29:18.664]                           restarts <- computeRestarts(cond)
[08:29:18.664]                           for (restart in restarts) {
[08:29:18.664]                             name <- restart$name
[08:29:18.664]                             if (is.null(name)) 
[08:29:18.664]                               next
[08:29:18.664]                             if (!grepl(pattern, name)) 
[08:29:18.664]                               next
[08:29:18.664]                             invokeRestart(restart)
[08:29:18.664]                             muffled <- TRUE
[08:29:18.664]                             break
[08:29:18.664]                           }
[08:29:18.664]                         }
[08:29:18.664]                       }
[08:29:18.664]                       invisible(muffled)
[08:29:18.664]                     }
[08:29:18.664]                     muffleCondition(cond, pattern = "^muffle")
[08:29:18.664]                   }
[08:29:18.664]                 }
[08:29:18.664]                 else {
[08:29:18.664]                   if (TRUE) {
[08:29:18.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.664]                     {
[08:29:18.664]                       inherits <- base::inherits
[08:29:18.664]                       invokeRestart <- base::invokeRestart
[08:29:18.664]                       is.null <- base::is.null
[08:29:18.664]                       muffled <- FALSE
[08:29:18.664]                       if (inherits(cond, "message")) {
[08:29:18.664]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:18.664]                         if (muffled) 
[08:29:18.664]                           invokeRestart("muffleMessage")
[08:29:18.664]                       }
[08:29:18.664]                       else if (inherits(cond, "warning")) {
[08:29:18.664]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:18.664]                         if (muffled) 
[08:29:18.664]                           invokeRestart("muffleWarning")
[08:29:18.664]                       }
[08:29:18.664]                       else if (inherits(cond, "condition")) {
[08:29:18.664]                         if (!is.null(pattern)) {
[08:29:18.664]                           computeRestarts <- base::computeRestarts
[08:29:18.664]                           grepl <- base::grepl
[08:29:18.664]                           restarts <- computeRestarts(cond)
[08:29:18.664]                           for (restart in restarts) {
[08:29:18.664]                             name <- restart$name
[08:29:18.664]                             if (is.null(name)) 
[08:29:18.664]                               next
[08:29:18.664]                             if (!grepl(pattern, name)) 
[08:29:18.664]                               next
[08:29:18.664]                             invokeRestart(restart)
[08:29:18.664]                             muffled <- TRUE
[08:29:18.664]                             break
[08:29:18.664]                           }
[08:29:18.664]                         }
[08:29:18.664]                       }
[08:29:18.664]                       invisible(muffled)
[08:29:18.664]                     }
[08:29:18.664]                     muffleCondition(cond, pattern = "^muffle")
[08:29:18.664]                   }
[08:29:18.664]                 }
[08:29:18.664]             }
[08:29:18.664]         }))
[08:29:18.664]     }, error = function(ex) {
[08:29:18.664]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:18.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:18.664]                 ...future.rng), started = ...future.startTime, 
[08:29:18.664]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:18.664]             version = "1.8"), class = "FutureResult")
[08:29:18.664]     }, finally = {
[08:29:18.664]         if (!identical(...future.workdir, getwd())) 
[08:29:18.664]             setwd(...future.workdir)
[08:29:18.664]         {
[08:29:18.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:18.664]                 ...future.oldOptions$nwarnings <- NULL
[08:29:18.664]             }
[08:29:18.664]             base::options(...future.oldOptions)
[08:29:18.664]             if (.Platform$OS.type == "windows") {
[08:29:18.664]                 old_names <- names(...future.oldEnvVars)
[08:29:18.664]                 envs <- base::Sys.getenv()
[08:29:18.664]                 names <- names(envs)
[08:29:18.664]                 common <- intersect(names, old_names)
[08:29:18.664]                 added <- setdiff(names, old_names)
[08:29:18.664]                 removed <- setdiff(old_names, names)
[08:29:18.664]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:18.664]                   envs[common]]
[08:29:18.664]                 NAMES <- toupper(changed)
[08:29:18.664]                 args <- list()
[08:29:18.664]                 for (kk in seq_along(NAMES)) {
[08:29:18.664]                   name <- changed[[kk]]
[08:29:18.664]                   NAME <- NAMES[[kk]]
[08:29:18.664]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.664]                     next
[08:29:18.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:18.664]                 }
[08:29:18.664]                 NAMES <- toupper(added)
[08:29:18.664]                 for (kk in seq_along(NAMES)) {
[08:29:18.664]                   name <- added[[kk]]
[08:29:18.664]                   NAME <- NAMES[[kk]]
[08:29:18.664]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.664]                     next
[08:29:18.664]                   args[[name]] <- ""
[08:29:18.664]                 }
[08:29:18.664]                 NAMES <- toupper(removed)
[08:29:18.664]                 for (kk in seq_along(NAMES)) {
[08:29:18.664]                   name <- removed[[kk]]
[08:29:18.664]                   NAME <- NAMES[[kk]]
[08:29:18.664]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.664]                     next
[08:29:18.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:18.664]                 }
[08:29:18.664]                 if (length(args) > 0) 
[08:29:18.664]                   base::do.call(base::Sys.setenv, args = args)
[08:29:18.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:18.664]             }
[08:29:18.664]             else {
[08:29:18.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:18.664]             }
[08:29:18.664]             {
[08:29:18.664]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:18.664]                   0L) {
[08:29:18.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:18.664]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:18.664]                   base::options(opts)
[08:29:18.664]                 }
[08:29:18.664]                 {
[08:29:18.664]                   {
[08:29:18.664]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:18.664]                     NULL
[08:29:18.664]                   }
[08:29:18.664]                   options(future.plan = NULL)
[08:29:18.664]                   if (is.na(NA_character_)) 
[08:29:18.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:18.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:18.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:18.664]                     .init = FALSE)
[08:29:18.664]                 }
[08:29:18.664]             }
[08:29:18.664]         }
[08:29:18.664]     })
[08:29:18.664]     if (TRUE) {
[08:29:18.664]         base::sink(type = "output", split = FALSE)
[08:29:18.664]         if (TRUE) {
[08:29:18.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:18.664]         }
[08:29:18.664]         else {
[08:29:18.664]             ...future.result["stdout"] <- base::list(NULL)
[08:29:18.664]         }
[08:29:18.664]         base::close(...future.stdout)
[08:29:18.664]         ...future.stdout <- NULL
[08:29:18.664]     }
[08:29:18.664]     ...future.result$conditions <- ...future.conditions
[08:29:18.664]     ...future.result$finished <- base::Sys.time()
[08:29:18.664]     ...future.result
[08:29:18.664] }
[08:29:18.667] MultisessionFuture started
[08:29:18.667] - Launch lazy future ... done
[08:29:18.667] run() for ‘MultisessionFuture’ ... done
[08:29:18.709] receiveMessageFromWorker() for ClusterFuture ...
[08:29:18.709] - Validating connection of MultisessionFuture
[08:29:18.710] - received message: FutureResult
[08:29:18.710] - Received FutureResult
[08:29:18.710] - Erased future from FutureRegistry
[08:29:18.710] result() for ClusterFuture ...
[08:29:18.710] - result already collected: FutureResult
[08:29:18.710] result() for ClusterFuture ... done
[08:29:18.710] signalConditions() ...
[08:29:18.710]  - include = ‘immediateCondition’
[08:29:18.710]  - exclude = 
[08:29:18.711]  - resignal = FALSE
[08:29:18.711]  - Number of conditions: 1
[08:29:18.711] signalConditions() ... done
[08:29:18.711] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:18.711] A MultisessionFuture was resolved (and resolved itself)
[08:29:18.711] getGlobalsAndPackages() ...
[08:29:18.711] Searching for globals...
[08:29:18.712] - globals found: [2] ‘list’, ‘stop’
[08:29:18.712] Searching for globals ... DONE
[08:29:18.712] Resolving globals: FALSE
[08:29:18.712] 
[08:29:18.712] 
[08:29:18.712] getGlobalsAndPackages() ... DONE
[08:29:18.713] run() for ‘Future’ ...
[08:29:18.713] - state: ‘created’
[08:29:18.713] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:18.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:18.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:18.727]   - Field: ‘node’
[08:29:18.727]   - Field: ‘label’
[08:29:18.727]   - Field: ‘local’
[08:29:18.727]   - Field: ‘owner’
[08:29:18.727]   - Field: ‘envir’
[08:29:18.727]   - Field: ‘workers’
[08:29:18.727]   - Field: ‘packages’
[08:29:18.727]   - Field: ‘gc’
[08:29:18.728]   - Field: ‘conditions’
[08:29:18.728]   - Field: ‘persistent’
[08:29:18.728]   - Field: ‘expr’
[08:29:18.728]   - Field: ‘uuid’
[08:29:18.728]   - Field: ‘seed’
[08:29:18.728]   - Field: ‘version’
[08:29:18.728]   - Field: ‘result’
[08:29:18.728]   - Field: ‘asynchronous’
[08:29:18.728]   - Field: ‘calls’
[08:29:18.728]   - Field: ‘globals’
[08:29:18.728]   - Field: ‘stdout’
[08:29:18.728]   - Field: ‘earlySignal’
[08:29:18.729]   - Field: ‘lazy’
[08:29:18.729]   - Field: ‘state’
[08:29:18.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:18.729] - Launch lazy future ...
[08:29:18.729] Packages needed by the future expression (n = 0): <none>
[08:29:18.729] Packages needed by future strategies (n = 0): <none>
[08:29:18.730] {
[08:29:18.730]     {
[08:29:18.730]         {
[08:29:18.730]             ...future.startTime <- base::Sys.time()
[08:29:18.730]             {
[08:29:18.730]                 {
[08:29:18.730]                   {
[08:29:18.730]                     {
[08:29:18.730]                       base::local({
[08:29:18.730]                         has_future <- base::requireNamespace("future", 
[08:29:18.730]                           quietly = TRUE)
[08:29:18.730]                         if (has_future) {
[08:29:18.730]                           ns <- base::getNamespace("future")
[08:29:18.730]                           version <- ns[[".package"]][["version"]]
[08:29:18.730]                           if (is.null(version)) 
[08:29:18.730]                             version <- utils::packageVersion("future")
[08:29:18.730]                         }
[08:29:18.730]                         else {
[08:29:18.730]                           version <- NULL
[08:29:18.730]                         }
[08:29:18.730]                         if (!has_future || version < "1.8.0") {
[08:29:18.730]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:18.730]                             "", base::R.version$version.string), 
[08:29:18.730]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:18.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:18.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:18.730]                               "release", "version")], collapse = " "), 
[08:29:18.730]                             hostname = base::Sys.info()[["nodename"]])
[08:29:18.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:18.730]                             info)
[08:29:18.730]                           info <- base::paste(info, collapse = "; ")
[08:29:18.730]                           if (!has_future) {
[08:29:18.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:18.730]                               info)
[08:29:18.730]                           }
[08:29:18.730]                           else {
[08:29:18.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:18.730]                               info, version)
[08:29:18.730]                           }
[08:29:18.730]                           base::stop(msg)
[08:29:18.730]                         }
[08:29:18.730]                       })
[08:29:18.730]                     }
[08:29:18.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:18.730]                     base::options(mc.cores = 1L)
[08:29:18.730]                   }
[08:29:18.730]                   ...future.strategy.old <- future::plan("list")
[08:29:18.730]                   options(future.plan = NULL)
[08:29:18.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:18.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:18.730]                 }
[08:29:18.730]                 ...future.workdir <- getwd()
[08:29:18.730]             }
[08:29:18.730]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:18.730]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:18.730]         }
[08:29:18.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:18.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:18.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:18.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:18.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:18.730]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:18.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:18.730]             base::names(...future.oldOptions))
[08:29:18.730]     }
[08:29:18.730]     if (FALSE) {
[08:29:18.730]     }
[08:29:18.730]     else {
[08:29:18.730]         if (TRUE) {
[08:29:18.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:18.730]                 open = "w")
[08:29:18.730]         }
[08:29:18.730]         else {
[08:29:18.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:18.730]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:18.730]         }
[08:29:18.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:18.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:18.730]             base::sink(type = "output", split = FALSE)
[08:29:18.730]             base::close(...future.stdout)
[08:29:18.730]         }, add = TRUE)
[08:29:18.730]     }
[08:29:18.730]     ...future.frame <- base::sys.nframe()
[08:29:18.730]     ...future.conditions <- base::list()
[08:29:18.730]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:18.730]     if (FALSE) {
[08:29:18.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:18.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:18.730]     }
[08:29:18.730]     ...future.result <- base::tryCatch({
[08:29:18.730]         base::withCallingHandlers({
[08:29:18.730]             ...future.value <- base::withVisible(base::local({
[08:29:18.730]                 ...future.makeSendCondition <- base::local({
[08:29:18.730]                   sendCondition <- NULL
[08:29:18.730]                   function(frame = 1L) {
[08:29:18.730]                     if (is.function(sendCondition)) 
[08:29:18.730]                       return(sendCondition)
[08:29:18.730]                     ns <- getNamespace("parallel")
[08:29:18.730]                     if (exists("sendData", mode = "function", 
[08:29:18.730]                       envir = ns)) {
[08:29:18.730]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:18.730]                         envir = ns)
[08:29:18.730]                       envir <- sys.frame(frame)
[08:29:18.730]                       master <- NULL
[08:29:18.730]                       while (!identical(envir, .GlobalEnv) && 
[08:29:18.730]                         !identical(envir, emptyenv())) {
[08:29:18.730]                         if (exists("master", mode = "list", envir = envir, 
[08:29:18.730]                           inherits = FALSE)) {
[08:29:18.730]                           master <- get("master", mode = "list", 
[08:29:18.730]                             envir = envir, inherits = FALSE)
[08:29:18.730]                           if (inherits(master, c("SOCKnode", 
[08:29:18.730]                             "SOCK0node"))) {
[08:29:18.730]                             sendCondition <<- function(cond) {
[08:29:18.730]                               data <- list(type = "VALUE", value = cond, 
[08:29:18.730]                                 success = TRUE)
[08:29:18.730]                               parallel_sendData(master, data)
[08:29:18.730]                             }
[08:29:18.730]                             return(sendCondition)
[08:29:18.730]                           }
[08:29:18.730]                         }
[08:29:18.730]                         frame <- frame + 1L
[08:29:18.730]                         envir <- sys.frame(frame)
[08:29:18.730]                       }
[08:29:18.730]                     }
[08:29:18.730]                     sendCondition <<- function(cond) NULL
[08:29:18.730]                   }
[08:29:18.730]                 })
[08:29:18.730]                 withCallingHandlers({
[08:29:18.730]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:18.730]                 }, immediateCondition = function(cond) {
[08:29:18.730]                   sendCondition <- ...future.makeSendCondition()
[08:29:18.730]                   sendCondition(cond)
[08:29:18.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.730]                   {
[08:29:18.730]                     inherits <- base::inherits
[08:29:18.730]                     invokeRestart <- base::invokeRestart
[08:29:18.730]                     is.null <- base::is.null
[08:29:18.730]                     muffled <- FALSE
[08:29:18.730]                     if (inherits(cond, "message")) {
[08:29:18.730]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:18.730]                       if (muffled) 
[08:29:18.730]                         invokeRestart("muffleMessage")
[08:29:18.730]                     }
[08:29:18.730]                     else if (inherits(cond, "warning")) {
[08:29:18.730]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:18.730]                       if (muffled) 
[08:29:18.730]                         invokeRestart("muffleWarning")
[08:29:18.730]                     }
[08:29:18.730]                     else if (inherits(cond, "condition")) {
[08:29:18.730]                       if (!is.null(pattern)) {
[08:29:18.730]                         computeRestarts <- base::computeRestarts
[08:29:18.730]                         grepl <- base::grepl
[08:29:18.730]                         restarts <- computeRestarts(cond)
[08:29:18.730]                         for (restart in restarts) {
[08:29:18.730]                           name <- restart$name
[08:29:18.730]                           if (is.null(name)) 
[08:29:18.730]                             next
[08:29:18.730]                           if (!grepl(pattern, name)) 
[08:29:18.730]                             next
[08:29:18.730]                           invokeRestart(restart)
[08:29:18.730]                           muffled <- TRUE
[08:29:18.730]                           break
[08:29:18.730]                         }
[08:29:18.730]                       }
[08:29:18.730]                     }
[08:29:18.730]                     invisible(muffled)
[08:29:18.730]                   }
[08:29:18.730]                   muffleCondition(cond)
[08:29:18.730]                 })
[08:29:18.730]             }))
[08:29:18.730]             future::FutureResult(value = ...future.value$value, 
[08:29:18.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:18.730]                   ...future.rng), globalenv = if (FALSE) 
[08:29:18.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:18.730]                     ...future.globalenv.names))
[08:29:18.730]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:18.730]         }, condition = base::local({
[08:29:18.730]             c <- base::c
[08:29:18.730]             inherits <- base::inherits
[08:29:18.730]             invokeRestart <- base::invokeRestart
[08:29:18.730]             length <- base::length
[08:29:18.730]             list <- base::list
[08:29:18.730]             seq.int <- base::seq.int
[08:29:18.730]             signalCondition <- base::signalCondition
[08:29:18.730]             sys.calls <- base::sys.calls
[08:29:18.730]             `[[` <- base::`[[`
[08:29:18.730]             `+` <- base::`+`
[08:29:18.730]             `<<-` <- base::`<<-`
[08:29:18.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:18.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:18.730]                   3L)]
[08:29:18.730]             }
[08:29:18.730]             function(cond) {
[08:29:18.730]                 is_error <- inherits(cond, "error")
[08:29:18.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:18.730]                   NULL)
[08:29:18.730]                 if (is_error) {
[08:29:18.730]                   sessionInformation <- function() {
[08:29:18.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:18.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:18.730]                       search = base::search(), system = base::Sys.info())
[08:29:18.730]                   }
[08:29:18.730]                   ...future.conditions[[length(...future.conditions) + 
[08:29:18.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:18.730]                     cond$call), session = sessionInformation(), 
[08:29:18.730]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:18.730]                   signalCondition(cond)
[08:29:18.730]                 }
[08:29:18.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:18.730]                 "immediateCondition"))) {
[08:29:18.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:18.730]                   ...future.conditions[[length(...future.conditions) + 
[08:29:18.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:18.730]                   if (TRUE && !signal) {
[08:29:18.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.730]                     {
[08:29:18.730]                       inherits <- base::inherits
[08:29:18.730]                       invokeRestart <- base::invokeRestart
[08:29:18.730]                       is.null <- base::is.null
[08:29:18.730]                       muffled <- FALSE
[08:29:18.730]                       if (inherits(cond, "message")) {
[08:29:18.730]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:18.730]                         if (muffled) 
[08:29:18.730]                           invokeRestart("muffleMessage")
[08:29:18.730]                       }
[08:29:18.730]                       else if (inherits(cond, "warning")) {
[08:29:18.730]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:18.730]                         if (muffled) 
[08:29:18.730]                           invokeRestart("muffleWarning")
[08:29:18.730]                       }
[08:29:18.730]                       else if (inherits(cond, "condition")) {
[08:29:18.730]                         if (!is.null(pattern)) {
[08:29:18.730]                           computeRestarts <- base::computeRestarts
[08:29:18.730]                           grepl <- base::grepl
[08:29:18.730]                           restarts <- computeRestarts(cond)
[08:29:18.730]                           for (restart in restarts) {
[08:29:18.730]                             name <- restart$name
[08:29:18.730]                             if (is.null(name)) 
[08:29:18.730]                               next
[08:29:18.730]                             if (!grepl(pattern, name)) 
[08:29:18.730]                               next
[08:29:18.730]                             invokeRestart(restart)
[08:29:18.730]                             muffled <- TRUE
[08:29:18.730]                             break
[08:29:18.730]                           }
[08:29:18.730]                         }
[08:29:18.730]                       }
[08:29:18.730]                       invisible(muffled)
[08:29:18.730]                     }
[08:29:18.730]                     muffleCondition(cond, pattern = "^muffle")
[08:29:18.730]                   }
[08:29:18.730]                 }
[08:29:18.730]                 else {
[08:29:18.730]                   if (TRUE) {
[08:29:18.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.730]                     {
[08:29:18.730]                       inherits <- base::inherits
[08:29:18.730]                       invokeRestart <- base::invokeRestart
[08:29:18.730]                       is.null <- base::is.null
[08:29:18.730]                       muffled <- FALSE
[08:29:18.730]                       if (inherits(cond, "message")) {
[08:29:18.730]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:18.730]                         if (muffled) 
[08:29:18.730]                           invokeRestart("muffleMessage")
[08:29:18.730]                       }
[08:29:18.730]                       else if (inherits(cond, "warning")) {
[08:29:18.730]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:18.730]                         if (muffled) 
[08:29:18.730]                           invokeRestart("muffleWarning")
[08:29:18.730]                       }
[08:29:18.730]                       else if (inherits(cond, "condition")) {
[08:29:18.730]                         if (!is.null(pattern)) {
[08:29:18.730]                           computeRestarts <- base::computeRestarts
[08:29:18.730]                           grepl <- base::grepl
[08:29:18.730]                           restarts <- computeRestarts(cond)
[08:29:18.730]                           for (restart in restarts) {
[08:29:18.730]                             name <- restart$name
[08:29:18.730]                             if (is.null(name)) 
[08:29:18.730]                               next
[08:29:18.730]                             if (!grepl(pattern, name)) 
[08:29:18.730]                               next
[08:29:18.730]                             invokeRestart(restart)
[08:29:18.730]                             muffled <- TRUE
[08:29:18.730]                             break
[08:29:18.730]                           }
[08:29:18.730]                         }
[08:29:18.730]                       }
[08:29:18.730]                       invisible(muffled)
[08:29:18.730]                     }
[08:29:18.730]                     muffleCondition(cond, pattern = "^muffle")
[08:29:18.730]                   }
[08:29:18.730]                 }
[08:29:18.730]             }
[08:29:18.730]         }))
[08:29:18.730]     }, error = function(ex) {
[08:29:18.730]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:18.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:18.730]                 ...future.rng), started = ...future.startTime, 
[08:29:18.730]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:18.730]             version = "1.8"), class = "FutureResult")
[08:29:18.730]     }, finally = {
[08:29:18.730]         if (!identical(...future.workdir, getwd())) 
[08:29:18.730]             setwd(...future.workdir)
[08:29:18.730]         {
[08:29:18.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:18.730]                 ...future.oldOptions$nwarnings <- NULL
[08:29:18.730]             }
[08:29:18.730]             base::options(...future.oldOptions)
[08:29:18.730]             if (.Platform$OS.type == "windows") {
[08:29:18.730]                 old_names <- names(...future.oldEnvVars)
[08:29:18.730]                 envs <- base::Sys.getenv()
[08:29:18.730]                 names <- names(envs)
[08:29:18.730]                 common <- intersect(names, old_names)
[08:29:18.730]                 added <- setdiff(names, old_names)
[08:29:18.730]                 removed <- setdiff(old_names, names)
[08:29:18.730]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:18.730]                   envs[common]]
[08:29:18.730]                 NAMES <- toupper(changed)
[08:29:18.730]                 args <- list()
[08:29:18.730]                 for (kk in seq_along(NAMES)) {
[08:29:18.730]                   name <- changed[[kk]]
[08:29:18.730]                   NAME <- NAMES[[kk]]
[08:29:18.730]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.730]                     next
[08:29:18.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:18.730]                 }
[08:29:18.730]                 NAMES <- toupper(added)
[08:29:18.730]                 for (kk in seq_along(NAMES)) {
[08:29:18.730]                   name <- added[[kk]]
[08:29:18.730]                   NAME <- NAMES[[kk]]
[08:29:18.730]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.730]                     next
[08:29:18.730]                   args[[name]] <- ""
[08:29:18.730]                 }
[08:29:18.730]                 NAMES <- toupper(removed)
[08:29:18.730]                 for (kk in seq_along(NAMES)) {
[08:29:18.730]                   name <- removed[[kk]]
[08:29:18.730]                   NAME <- NAMES[[kk]]
[08:29:18.730]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.730]                     next
[08:29:18.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:18.730]                 }
[08:29:18.730]                 if (length(args) > 0) 
[08:29:18.730]                   base::do.call(base::Sys.setenv, args = args)
[08:29:18.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:18.730]             }
[08:29:18.730]             else {
[08:29:18.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:18.730]             }
[08:29:18.730]             {
[08:29:18.730]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:18.730]                   0L) {
[08:29:18.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:18.730]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:18.730]                   base::options(opts)
[08:29:18.730]                 }
[08:29:18.730]                 {
[08:29:18.730]                   {
[08:29:18.730]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:18.730]                     NULL
[08:29:18.730]                   }
[08:29:18.730]                   options(future.plan = NULL)
[08:29:18.730]                   if (is.na(NA_character_)) 
[08:29:18.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:18.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:18.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:18.730]                     .init = FALSE)
[08:29:18.730]                 }
[08:29:18.730]             }
[08:29:18.730]         }
[08:29:18.730]     })
[08:29:18.730]     if (TRUE) {
[08:29:18.730]         base::sink(type = "output", split = FALSE)
[08:29:18.730]         if (TRUE) {
[08:29:18.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:18.730]         }
[08:29:18.730]         else {
[08:29:18.730]             ...future.result["stdout"] <- base::list(NULL)
[08:29:18.730]         }
[08:29:18.730]         base::close(...future.stdout)
[08:29:18.730]         ...future.stdout <- NULL
[08:29:18.730]     }
[08:29:18.730]     ...future.result$conditions <- ...future.conditions
[08:29:18.730]     ...future.result$finished <- base::Sys.time()
[08:29:18.730]     ...future.result
[08:29:18.730] }
[08:29:18.733] MultisessionFuture started
[08:29:18.733] - Launch lazy future ... done
[08:29:18.733] run() for ‘MultisessionFuture’ ... done
[08:29:18.775] receiveMessageFromWorker() for ClusterFuture ...
[08:29:18.775] - Validating connection of MultisessionFuture
[08:29:18.776] - received message: FutureResult
[08:29:18.776] - Received FutureResult
[08:29:18.776] - Erased future from FutureRegistry
[08:29:18.776] result() for ClusterFuture ...
[08:29:18.776] - result already collected: FutureResult
[08:29:18.776] result() for ClusterFuture ... done
[08:29:18.776] signalConditions() ...
[08:29:18.776]  - include = ‘immediateCondition’
[08:29:18.776]  - exclude = 
[08:29:18.776]  - resignal = FALSE
[08:29:18.776]  - Number of conditions: 1
[08:29:18.777] signalConditions() ... done
[08:29:18.777] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:18.777] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[08:29:18.777] getGlobalsAndPackages() ...
[08:29:18.777] Searching for globals...
[08:29:18.778] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:18.778] Searching for globals ... DONE
[08:29:18.778] Resolving globals: FALSE
[08:29:18.779] 
[08:29:18.779] 
[08:29:18.779] getGlobalsAndPackages() ... DONE
[08:29:18.779] run() for ‘Future’ ...
[08:29:18.779] - state: ‘created’
[08:29:18.779] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:18.793] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:18.793] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:18.793]   - Field: ‘node’
[08:29:18.794]   - Field: ‘label’
[08:29:18.794]   - Field: ‘local’
[08:29:18.794]   - Field: ‘owner’
[08:29:18.794]   - Field: ‘envir’
[08:29:18.794]   - Field: ‘workers’
[08:29:18.794]   - Field: ‘packages’
[08:29:18.794]   - Field: ‘gc’
[08:29:18.794]   - Field: ‘conditions’
[08:29:18.794]   - Field: ‘persistent’
[08:29:18.794]   - Field: ‘expr’
[08:29:18.794]   - Field: ‘uuid’
[08:29:18.795]   - Field: ‘seed’
[08:29:18.795]   - Field: ‘version’
[08:29:18.795]   - Field: ‘result’
[08:29:18.795]   - Field: ‘asynchronous’
[08:29:18.795]   - Field: ‘calls’
[08:29:18.795]   - Field: ‘globals’
[08:29:18.795]   - Field: ‘stdout’
[08:29:18.795]   - Field: ‘earlySignal’
[08:29:18.795]   - Field: ‘lazy’
[08:29:18.795]   - Field: ‘state’
[08:29:18.795] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:18.795] - Launch lazy future ...
[08:29:18.796] Packages needed by the future expression (n = 0): <none>
[08:29:18.796] Packages needed by future strategies (n = 0): <none>
[08:29:18.796] {
[08:29:18.796]     {
[08:29:18.796]         {
[08:29:18.796]             ...future.startTime <- base::Sys.time()
[08:29:18.796]             {
[08:29:18.796]                 {
[08:29:18.796]                   {
[08:29:18.796]                     {
[08:29:18.796]                       base::local({
[08:29:18.796]                         has_future <- base::requireNamespace("future", 
[08:29:18.796]                           quietly = TRUE)
[08:29:18.796]                         if (has_future) {
[08:29:18.796]                           ns <- base::getNamespace("future")
[08:29:18.796]                           version <- ns[[".package"]][["version"]]
[08:29:18.796]                           if (is.null(version)) 
[08:29:18.796]                             version <- utils::packageVersion("future")
[08:29:18.796]                         }
[08:29:18.796]                         else {
[08:29:18.796]                           version <- NULL
[08:29:18.796]                         }
[08:29:18.796]                         if (!has_future || version < "1.8.0") {
[08:29:18.796]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:18.796]                             "", base::R.version$version.string), 
[08:29:18.796]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:18.796]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:18.796]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:18.796]                               "release", "version")], collapse = " "), 
[08:29:18.796]                             hostname = base::Sys.info()[["nodename"]])
[08:29:18.796]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:18.796]                             info)
[08:29:18.796]                           info <- base::paste(info, collapse = "; ")
[08:29:18.796]                           if (!has_future) {
[08:29:18.796]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:18.796]                               info)
[08:29:18.796]                           }
[08:29:18.796]                           else {
[08:29:18.796]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:18.796]                               info, version)
[08:29:18.796]                           }
[08:29:18.796]                           base::stop(msg)
[08:29:18.796]                         }
[08:29:18.796]                       })
[08:29:18.796]                     }
[08:29:18.796]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:18.796]                     base::options(mc.cores = 1L)
[08:29:18.796]                   }
[08:29:18.796]                   ...future.strategy.old <- future::plan("list")
[08:29:18.796]                   options(future.plan = NULL)
[08:29:18.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:18.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:18.796]                 }
[08:29:18.796]                 ...future.workdir <- getwd()
[08:29:18.796]             }
[08:29:18.796]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:18.796]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:18.796]         }
[08:29:18.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:18.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:18.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:18.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:18.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:18.796]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:18.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:18.796]             base::names(...future.oldOptions))
[08:29:18.796]     }
[08:29:18.796]     if (FALSE) {
[08:29:18.796]     }
[08:29:18.796]     else {
[08:29:18.796]         if (TRUE) {
[08:29:18.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:18.796]                 open = "w")
[08:29:18.796]         }
[08:29:18.796]         else {
[08:29:18.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:18.796]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:18.796]         }
[08:29:18.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:18.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:18.796]             base::sink(type = "output", split = FALSE)
[08:29:18.796]             base::close(...future.stdout)
[08:29:18.796]         }, add = TRUE)
[08:29:18.796]     }
[08:29:18.796]     ...future.frame <- base::sys.nframe()
[08:29:18.796]     ...future.conditions <- base::list()
[08:29:18.796]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:18.796]     if (FALSE) {
[08:29:18.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:18.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:18.796]     }
[08:29:18.796]     ...future.result <- base::tryCatch({
[08:29:18.796]         base::withCallingHandlers({
[08:29:18.796]             ...future.value <- base::withVisible(base::local({
[08:29:18.796]                 ...future.makeSendCondition <- base::local({
[08:29:18.796]                   sendCondition <- NULL
[08:29:18.796]                   function(frame = 1L) {
[08:29:18.796]                     if (is.function(sendCondition)) 
[08:29:18.796]                       return(sendCondition)
[08:29:18.796]                     ns <- getNamespace("parallel")
[08:29:18.796]                     if (exists("sendData", mode = "function", 
[08:29:18.796]                       envir = ns)) {
[08:29:18.796]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:18.796]                         envir = ns)
[08:29:18.796]                       envir <- sys.frame(frame)
[08:29:18.796]                       master <- NULL
[08:29:18.796]                       while (!identical(envir, .GlobalEnv) && 
[08:29:18.796]                         !identical(envir, emptyenv())) {
[08:29:18.796]                         if (exists("master", mode = "list", envir = envir, 
[08:29:18.796]                           inherits = FALSE)) {
[08:29:18.796]                           master <- get("master", mode = "list", 
[08:29:18.796]                             envir = envir, inherits = FALSE)
[08:29:18.796]                           if (inherits(master, c("SOCKnode", 
[08:29:18.796]                             "SOCK0node"))) {
[08:29:18.796]                             sendCondition <<- function(cond) {
[08:29:18.796]                               data <- list(type = "VALUE", value = cond, 
[08:29:18.796]                                 success = TRUE)
[08:29:18.796]                               parallel_sendData(master, data)
[08:29:18.796]                             }
[08:29:18.796]                             return(sendCondition)
[08:29:18.796]                           }
[08:29:18.796]                         }
[08:29:18.796]                         frame <- frame + 1L
[08:29:18.796]                         envir <- sys.frame(frame)
[08:29:18.796]                       }
[08:29:18.796]                     }
[08:29:18.796]                     sendCondition <<- function(cond) NULL
[08:29:18.796]                   }
[08:29:18.796]                 })
[08:29:18.796]                 withCallingHandlers({
[08:29:18.796]                   {
[08:29:18.796]                     Sys.sleep(0.5)
[08:29:18.796]                     list(a = 1, b = 42L)
[08:29:18.796]                   }
[08:29:18.796]                 }, immediateCondition = function(cond) {
[08:29:18.796]                   sendCondition <- ...future.makeSendCondition()
[08:29:18.796]                   sendCondition(cond)
[08:29:18.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.796]                   {
[08:29:18.796]                     inherits <- base::inherits
[08:29:18.796]                     invokeRestart <- base::invokeRestart
[08:29:18.796]                     is.null <- base::is.null
[08:29:18.796]                     muffled <- FALSE
[08:29:18.796]                     if (inherits(cond, "message")) {
[08:29:18.796]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:18.796]                       if (muffled) 
[08:29:18.796]                         invokeRestart("muffleMessage")
[08:29:18.796]                     }
[08:29:18.796]                     else if (inherits(cond, "warning")) {
[08:29:18.796]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:18.796]                       if (muffled) 
[08:29:18.796]                         invokeRestart("muffleWarning")
[08:29:18.796]                     }
[08:29:18.796]                     else if (inherits(cond, "condition")) {
[08:29:18.796]                       if (!is.null(pattern)) {
[08:29:18.796]                         computeRestarts <- base::computeRestarts
[08:29:18.796]                         grepl <- base::grepl
[08:29:18.796]                         restarts <- computeRestarts(cond)
[08:29:18.796]                         for (restart in restarts) {
[08:29:18.796]                           name <- restart$name
[08:29:18.796]                           if (is.null(name)) 
[08:29:18.796]                             next
[08:29:18.796]                           if (!grepl(pattern, name)) 
[08:29:18.796]                             next
[08:29:18.796]                           invokeRestart(restart)
[08:29:18.796]                           muffled <- TRUE
[08:29:18.796]                           break
[08:29:18.796]                         }
[08:29:18.796]                       }
[08:29:18.796]                     }
[08:29:18.796]                     invisible(muffled)
[08:29:18.796]                   }
[08:29:18.796]                   muffleCondition(cond)
[08:29:18.796]                 })
[08:29:18.796]             }))
[08:29:18.796]             future::FutureResult(value = ...future.value$value, 
[08:29:18.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:18.796]                   ...future.rng), globalenv = if (FALSE) 
[08:29:18.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:18.796]                     ...future.globalenv.names))
[08:29:18.796]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:18.796]         }, condition = base::local({
[08:29:18.796]             c <- base::c
[08:29:18.796]             inherits <- base::inherits
[08:29:18.796]             invokeRestart <- base::invokeRestart
[08:29:18.796]             length <- base::length
[08:29:18.796]             list <- base::list
[08:29:18.796]             seq.int <- base::seq.int
[08:29:18.796]             signalCondition <- base::signalCondition
[08:29:18.796]             sys.calls <- base::sys.calls
[08:29:18.796]             `[[` <- base::`[[`
[08:29:18.796]             `+` <- base::`+`
[08:29:18.796]             `<<-` <- base::`<<-`
[08:29:18.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:18.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:18.796]                   3L)]
[08:29:18.796]             }
[08:29:18.796]             function(cond) {
[08:29:18.796]                 is_error <- inherits(cond, "error")
[08:29:18.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:18.796]                   NULL)
[08:29:18.796]                 if (is_error) {
[08:29:18.796]                   sessionInformation <- function() {
[08:29:18.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:18.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:18.796]                       search = base::search(), system = base::Sys.info())
[08:29:18.796]                   }
[08:29:18.796]                   ...future.conditions[[length(...future.conditions) + 
[08:29:18.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:18.796]                     cond$call), session = sessionInformation(), 
[08:29:18.796]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:18.796]                   signalCondition(cond)
[08:29:18.796]                 }
[08:29:18.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:18.796]                 "immediateCondition"))) {
[08:29:18.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:18.796]                   ...future.conditions[[length(...future.conditions) + 
[08:29:18.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:18.796]                   if (TRUE && !signal) {
[08:29:18.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.796]                     {
[08:29:18.796]                       inherits <- base::inherits
[08:29:18.796]                       invokeRestart <- base::invokeRestart
[08:29:18.796]                       is.null <- base::is.null
[08:29:18.796]                       muffled <- FALSE
[08:29:18.796]                       if (inherits(cond, "message")) {
[08:29:18.796]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:18.796]                         if (muffled) 
[08:29:18.796]                           invokeRestart("muffleMessage")
[08:29:18.796]                       }
[08:29:18.796]                       else if (inherits(cond, "warning")) {
[08:29:18.796]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:18.796]                         if (muffled) 
[08:29:18.796]                           invokeRestart("muffleWarning")
[08:29:18.796]                       }
[08:29:18.796]                       else if (inherits(cond, "condition")) {
[08:29:18.796]                         if (!is.null(pattern)) {
[08:29:18.796]                           computeRestarts <- base::computeRestarts
[08:29:18.796]                           grepl <- base::grepl
[08:29:18.796]                           restarts <- computeRestarts(cond)
[08:29:18.796]                           for (restart in restarts) {
[08:29:18.796]                             name <- restart$name
[08:29:18.796]                             if (is.null(name)) 
[08:29:18.796]                               next
[08:29:18.796]                             if (!grepl(pattern, name)) 
[08:29:18.796]                               next
[08:29:18.796]                             invokeRestart(restart)
[08:29:18.796]                             muffled <- TRUE
[08:29:18.796]                             break
[08:29:18.796]                           }
[08:29:18.796]                         }
[08:29:18.796]                       }
[08:29:18.796]                       invisible(muffled)
[08:29:18.796]                     }
[08:29:18.796]                     muffleCondition(cond, pattern = "^muffle")
[08:29:18.796]                   }
[08:29:18.796]                 }
[08:29:18.796]                 else {
[08:29:18.796]                   if (TRUE) {
[08:29:18.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:18.796]                     {
[08:29:18.796]                       inherits <- base::inherits
[08:29:18.796]                       invokeRestart <- base::invokeRestart
[08:29:18.796]                       is.null <- base::is.null
[08:29:18.796]                       muffled <- FALSE
[08:29:18.796]                       if (inherits(cond, "message")) {
[08:29:18.796]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:18.796]                         if (muffled) 
[08:29:18.796]                           invokeRestart("muffleMessage")
[08:29:18.796]                       }
[08:29:18.796]                       else if (inherits(cond, "warning")) {
[08:29:18.796]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:18.796]                         if (muffled) 
[08:29:18.796]                           invokeRestart("muffleWarning")
[08:29:18.796]                       }
[08:29:18.796]                       else if (inherits(cond, "condition")) {
[08:29:18.796]                         if (!is.null(pattern)) {
[08:29:18.796]                           computeRestarts <- base::computeRestarts
[08:29:18.796]                           grepl <- base::grepl
[08:29:18.796]                           restarts <- computeRestarts(cond)
[08:29:18.796]                           for (restart in restarts) {
[08:29:18.796]                             name <- restart$name
[08:29:18.796]                             if (is.null(name)) 
[08:29:18.796]                               next
[08:29:18.796]                             if (!grepl(pattern, name)) 
[08:29:18.796]                               next
[08:29:18.796]                             invokeRestart(restart)
[08:29:18.796]                             muffled <- TRUE
[08:29:18.796]                             break
[08:29:18.796]                           }
[08:29:18.796]                         }
[08:29:18.796]                       }
[08:29:18.796]                       invisible(muffled)
[08:29:18.796]                     }
[08:29:18.796]                     muffleCondition(cond, pattern = "^muffle")
[08:29:18.796]                   }
[08:29:18.796]                 }
[08:29:18.796]             }
[08:29:18.796]         }))
[08:29:18.796]     }, error = function(ex) {
[08:29:18.796]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:18.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:18.796]                 ...future.rng), started = ...future.startTime, 
[08:29:18.796]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:18.796]             version = "1.8"), class = "FutureResult")
[08:29:18.796]     }, finally = {
[08:29:18.796]         if (!identical(...future.workdir, getwd())) 
[08:29:18.796]             setwd(...future.workdir)
[08:29:18.796]         {
[08:29:18.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:18.796]                 ...future.oldOptions$nwarnings <- NULL
[08:29:18.796]             }
[08:29:18.796]             base::options(...future.oldOptions)
[08:29:18.796]             if (.Platform$OS.type == "windows") {
[08:29:18.796]                 old_names <- names(...future.oldEnvVars)
[08:29:18.796]                 envs <- base::Sys.getenv()
[08:29:18.796]                 names <- names(envs)
[08:29:18.796]                 common <- intersect(names, old_names)
[08:29:18.796]                 added <- setdiff(names, old_names)
[08:29:18.796]                 removed <- setdiff(old_names, names)
[08:29:18.796]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:18.796]                   envs[common]]
[08:29:18.796]                 NAMES <- toupper(changed)
[08:29:18.796]                 args <- list()
[08:29:18.796]                 for (kk in seq_along(NAMES)) {
[08:29:18.796]                   name <- changed[[kk]]
[08:29:18.796]                   NAME <- NAMES[[kk]]
[08:29:18.796]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.796]                     next
[08:29:18.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:18.796]                 }
[08:29:18.796]                 NAMES <- toupper(added)
[08:29:18.796]                 for (kk in seq_along(NAMES)) {
[08:29:18.796]                   name <- added[[kk]]
[08:29:18.796]                   NAME <- NAMES[[kk]]
[08:29:18.796]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.796]                     next
[08:29:18.796]                   args[[name]] <- ""
[08:29:18.796]                 }
[08:29:18.796]                 NAMES <- toupper(removed)
[08:29:18.796]                 for (kk in seq_along(NAMES)) {
[08:29:18.796]                   name <- removed[[kk]]
[08:29:18.796]                   NAME <- NAMES[[kk]]
[08:29:18.796]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:18.796]                     next
[08:29:18.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:18.796]                 }
[08:29:18.796]                 if (length(args) > 0) 
[08:29:18.796]                   base::do.call(base::Sys.setenv, args = args)
[08:29:18.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:18.796]             }
[08:29:18.796]             else {
[08:29:18.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:18.796]             }
[08:29:18.796]             {
[08:29:18.796]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:18.796]                   0L) {
[08:29:18.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:18.796]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:18.796]                   base::options(opts)
[08:29:18.796]                 }
[08:29:18.796]                 {
[08:29:18.796]                   {
[08:29:18.796]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:18.796]                     NULL
[08:29:18.796]                   }
[08:29:18.796]                   options(future.plan = NULL)
[08:29:18.796]                   if (is.na(NA_character_)) 
[08:29:18.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:18.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:18.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:18.796]                     .init = FALSE)
[08:29:18.796]                 }
[08:29:18.796]             }
[08:29:18.796]         }
[08:29:18.796]     })
[08:29:18.796]     if (TRUE) {
[08:29:18.796]         base::sink(type = "output", split = FALSE)
[08:29:18.796]         if (TRUE) {
[08:29:18.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:18.796]         }
[08:29:18.796]         else {
[08:29:18.796]             ...future.result["stdout"] <- base::list(NULL)
[08:29:18.796]         }
[08:29:18.796]         base::close(...future.stdout)
[08:29:18.796]         ...future.stdout <- NULL
[08:29:18.796]     }
[08:29:18.796]     ...future.result$conditions <- ...future.conditions
[08:29:18.796]     ...future.result$finished <- base::Sys.time()
[08:29:18.796]     ...future.result
[08:29:18.796] }
[08:29:18.799] MultisessionFuture started
[08:29:18.799] - Launch lazy future ... done
[08:29:18.799] run() for ‘MultisessionFuture’ ... done
[08:29:19.342] receiveMessageFromWorker() for ClusterFuture ...
[08:29:19.342] - Validating connection of MultisessionFuture
[08:29:19.342] - received message: FutureResult
[08:29:19.342] - Received FutureResult
[08:29:19.343] - Erased future from FutureRegistry
[08:29:19.343] result() for ClusterFuture ...
[08:29:19.343] - result already collected: FutureResult
[08:29:19.343] result() for ClusterFuture ... done
[08:29:19.343] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:19.343] resolve() on list ...
[08:29:19.343]  recursive: Inf
[08:29:19.343]  length: 2
[08:29:19.343]  elements: ‘a’, ‘b’
[08:29:19.343]  length: 1 (resolved future 1)
[08:29:19.343]  length: 0 (resolved future 2)
[08:29:19.344] resolve() on list ... DONE
[08:29:19.344] A MultisessionFuture was resolved (and resolved itself)
[08:29:19.344] getGlobalsAndPackages() ...
[08:29:19.344] Searching for globals...
[08:29:19.345] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[08:29:19.345] Searching for globals ... DONE
[08:29:19.345] Resolving globals: FALSE
[08:29:19.345] 
[08:29:19.346] 
[08:29:19.346] getGlobalsAndPackages() ... DONE
[08:29:19.346] run() for ‘Future’ ...
[08:29:19.346] - state: ‘created’
[08:29:19.346] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:19.363] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:19.363] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:19.363]   - Field: ‘node’
[08:29:19.363]   - Field: ‘label’
[08:29:19.363]   - Field: ‘local’
[08:29:19.363]   - Field: ‘owner’
[08:29:19.363]   - Field: ‘envir’
[08:29:19.363]   - Field: ‘workers’
[08:29:19.363]   - Field: ‘packages’
[08:29:19.364]   - Field: ‘gc’
[08:29:19.364]   - Field: ‘conditions’
[08:29:19.364]   - Field: ‘persistent’
[08:29:19.364]   - Field: ‘expr’
[08:29:19.364]   - Field: ‘uuid’
[08:29:19.364]   - Field: ‘seed’
[08:29:19.364]   - Field: ‘version’
[08:29:19.364]   - Field: ‘result’
[08:29:19.364]   - Field: ‘asynchronous’
[08:29:19.364]   - Field: ‘calls’
[08:29:19.364]   - Field: ‘globals’
[08:29:19.365]   - Field: ‘stdout’
[08:29:19.365]   - Field: ‘earlySignal’
[08:29:19.365]   - Field: ‘lazy’
[08:29:19.365]   - Field: ‘state’
[08:29:19.365] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:19.365] - Launch lazy future ...
[08:29:19.365] Packages needed by the future expression (n = 0): <none>
[08:29:19.365] Packages needed by future strategies (n = 0): <none>
[08:29:19.366] {
[08:29:19.366]     {
[08:29:19.366]         {
[08:29:19.366]             ...future.startTime <- base::Sys.time()
[08:29:19.366]             {
[08:29:19.366]                 {
[08:29:19.366]                   {
[08:29:19.366]                     {
[08:29:19.366]                       base::local({
[08:29:19.366]                         has_future <- base::requireNamespace("future", 
[08:29:19.366]                           quietly = TRUE)
[08:29:19.366]                         if (has_future) {
[08:29:19.366]                           ns <- base::getNamespace("future")
[08:29:19.366]                           version <- ns[[".package"]][["version"]]
[08:29:19.366]                           if (is.null(version)) 
[08:29:19.366]                             version <- utils::packageVersion("future")
[08:29:19.366]                         }
[08:29:19.366]                         else {
[08:29:19.366]                           version <- NULL
[08:29:19.366]                         }
[08:29:19.366]                         if (!has_future || version < "1.8.0") {
[08:29:19.366]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:19.366]                             "", base::R.version$version.string), 
[08:29:19.366]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:19.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:19.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:19.366]                               "release", "version")], collapse = " "), 
[08:29:19.366]                             hostname = base::Sys.info()[["nodename"]])
[08:29:19.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:19.366]                             info)
[08:29:19.366]                           info <- base::paste(info, collapse = "; ")
[08:29:19.366]                           if (!has_future) {
[08:29:19.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:19.366]                               info)
[08:29:19.366]                           }
[08:29:19.366]                           else {
[08:29:19.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:19.366]                               info, version)
[08:29:19.366]                           }
[08:29:19.366]                           base::stop(msg)
[08:29:19.366]                         }
[08:29:19.366]                       })
[08:29:19.366]                     }
[08:29:19.366]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:19.366]                     base::options(mc.cores = 1L)
[08:29:19.366]                   }
[08:29:19.366]                   ...future.strategy.old <- future::plan("list")
[08:29:19.366]                   options(future.plan = NULL)
[08:29:19.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:19.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:19.366]                 }
[08:29:19.366]                 ...future.workdir <- getwd()
[08:29:19.366]             }
[08:29:19.366]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:19.366]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:19.366]         }
[08:29:19.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:19.366]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:19.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:19.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:19.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:19.366]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:19.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:19.366]             base::names(...future.oldOptions))
[08:29:19.366]     }
[08:29:19.366]     if (FALSE) {
[08:29:19.366]     }
[08:29:19.366]     else {
[08:29:19.366]         if (TRUE) {
[08:29:19.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:19.366]                 open = "w")
[08:29:19.366]         }
[08:29:19.366]         else {
[08:29:19.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:19.366]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:19.366]         }
[08:29:19.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:19.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:19.366]             base::sink(type = "output", split = FALSE)
[08:29:19.366]             base::close(...future.stdout)
[08:29:19.366]         }, add = TRUE)
[08:29:19.366]     }
[08:29:19.366]     ...future.frame <- base::sys.nframe()
[08:29:19.366]     ...future.conditions <- base::list()
[08:29:19.366]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:19.366]     if (FALSE) {
[08:29:19.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:19.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:19.366]     }
[08:29:19.366]     ...future.result <- base::tryCatch({
[08:29:19.366]         base::withCallingHandlers({
[08:29:19.366]             ...future.value <- base::withVisible(base::local({
[08:29:19.366]                 ...future.makeSendCondition <- base::local({
[08:29:19.366]                   sendCondition <- NULL
[08:29:19.366]                   function(frame = 1L) {
[08:29:19.366]                     if (is.function(sendCondition)) 
[08:29:19.366]                       return(sendCondition)
[08:29:19.366]                     ns <- getNamespace("parallel")
[08:29:19.366]                     if (exists("sendData", mode = "function", 
[08:29:19.366]                       envir = ns)) {
[08:29:19.366]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:19.366]                         envir = ns)
[08:29:19.366]                       envir <- sys.frame(frame)
[08:29:19.366]                       master <- NULL
[08:29:19.366]                       while (!identical(envir, .GlobalEnv) && 
[08:29:19.366]                         !identical(envir, emptyenv())) {
[08:29:19.366]                         if (exists("master", mode = "list", envir = envir, 
[08:29:19.366]                           inherits = FALSE)) {
[08:29:19.366]                           master <- get("master", mode = "list", 
[08:29:19.366]                             envir = envir, inherits = FALSE)
[08:29:19.366]                           if (inherits(master, c("SOCKnode", 
[08:29:19.366]                             "SOCK0node"))) {
[08:29:19.366]                             sendCondition <<- function(cond) {
[08:29:19.366]                               data <- list(type = "VALUE", value = cond, 
[08:29:19.366]                                 success = TRUE)
[08:29:19.366]                               parallel_sendData(master, data)
[08:29:19.366]                             }
[08:29:19.366]                             return(sendCondition)
[08:29:19.366]                           }
[08:29:19.366]                         }
[08:29:19.366]                         frame <- frame + 1L
[08:29:19.366]                         envir <- sys.frame(frame)
[08:29:19.366]                       }
[08:29:19.366]                     }
[08:29:19.366]                     sendCondition <<- function(cond) NULL
[08:29:19.366]                   }
[08:29:19.366]                 })
[08:29:19.366]                 withCallingHandlers({
[08:29:19.366]                   {
[08:29:19.366]                     Sys.sleep(0.5)
[08:29:19.366]                     list(a = 1, b = 42L)
[08:29:19.366]                   }
[08:29:19.366]                 }, immediateCondition = function(cond) {
[08:29:19.366]                   sendCondition <- ...future.makeSendCondition()
[08:29:19.366]                   sendCondition(cond)
[08:29:19.366]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:19.366]                   {
[08:29:19.366]                     inherits <- base::inherits
[08:29:19.366]                     invokeRestart <- base::invokeRestart
[08:29:19.366]                     is.null <- base::is.null
[08:29:19.366]                     muffled <- FALSE
[08:29:19.366]                     if (inherits(cond, "message")) {
[08:29:19.366]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:19.366]                       if (muffled) 
[08:29:19.366]                         invokeRestart("muffleMessage")
[08:29:19.366]                     }
[08:29:19.366]                     else if (inherits(cond, "warning")) {
[08:29:19.366]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:19.366]                       if (muffled) 
[08:29:19.366]                         invokeRestart("muffleWarning")
[08:29:19.366]                     }
[08:29:19.366]                     else if (inherits(cond, "condition")) {
[08:29:19.366]                       if (!is.null(pattern)) {
[08:29:19.366]                         computeRestarts <- base::computeRestarts
[08:29:19.366]                         grepl <- base::grepl
[08:29:19.366]                         restarts <- computeRestarts(cond)
[08:29:19.366]                         for (restart in restarts) {
[08:29:19.366]                           name <- restart$name
[08:29:19.366]                           if (is.null(name)) 
[08:29:19.366]                             next
[08:29:19.366]                           if (!grepl(pattern, name)) 
[08:29:19.366]                             next
[08:29:19.366]                           invokeRestart(restart)
[08:29:19.366]                           muffled <- TRUE
[08:29:19.366]                           break
[08:29:19.366]                         }
[08:29:19.366]                       }
[08:29:19.366]                     }
[08:29:19.366]                     invisible(muffled)
[08:29:19.366]                   }
[08:29:19.366]                   muffleCondition(cond)
[08:29:19.366]                 })
[08:29:19.366]             }))
[08:29:19.366]             future::FutureResult(value = ...future.value$value, 
[08:29:19.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:19.366]                   ...future.rng), globalenv = if (FALSE) 
[08:29:19.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:19.366]                     ...future.globalenv.names))
[08:29:19.366]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:19.366]         }, condition = base::local({
[08:29:19.366]             c <- base::c
[08:29:19.366]             inherits <- base::inherits
[08:29:19.366]             invokeRestart <- base::invokeRestart
[08:29:19.366]             length <- base::length
[08:29:19.366]             list <- base::list
[08:29:19.366]             seq.int <- base::seq.int
[08:29:19.366]             signalCondition <- base::signalCondition
[08:29:19.366]             sys.calls <- base::sys.calls
[08:29:19.366]             `[[` <- base::`[[`
[08:29:19.366]             `+` <- base::`+`
[08:29:19.366]             `<<-` <- base::`<<-`
[08:29:19.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:19.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:19.366]                   3L)]
[08:29:19.366]             }
[08:29:19.366]             function(cond) {
[08:29:19.366]                 is_error <- inherits(cond, "error")
[08:29:19.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:19.366]                   NULL)
[08:29:19.366]                 if (is_error) {
[08:29:19.366]                   sessionInformation <- function() {
[08:29:19.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:19.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:19.366]                       search = base::search(), system = base::Sys.info())
[08:29:19.366]                   }
[08:29:19.366]                   ...future.conditions[[length(...future.conditions) + 
[08:29:19.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:19.366]                     cond$call), session = sessionInformation(), 
[08:29:19.366]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:19.366]                   signalCondition(cond)
[08:29:19.366]                 }
[08:29:19.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:19.366]                 "immediateCondition"))) {
[08:29:19.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:19.366]                   ...future.conditions[[length(...future.conditions) + 
[08:29:19.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:19.366]                   if (TRUE && !signal) {
[08:29:19.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:19.366]                     {
[08:29:19.366]                       inherits <- base::inherits
[08:29:19.366]                       invokeRestart <- base::invokeRestart
[08:29:19.366]                       is.null <- base::is.null
[08:29:19.366]                       muffled <- FALSE
[08:29:19.366]                       if (inherits(cond, "message")) {
[08:29:19.366]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:19.366]                         if (muffled) 
[08:29:19.366]                           invokeRestart("muffleMessage")
[08:29:19.366]                       }
[08:29:19.366]                       else if (inherits(cond, "warning")) {
[08:29:19.366]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:19.366]                         if (muffled) 
[08:29:19.366]                           invokeRestart("muffleWarning")
[08:29:19.366]                       }
[08:29:19.366]                       else if (inherits(cond, "condition")) {
[08:29:19.366]                         if (!is.null(pattern)) {
[08:29:19.366]                           computeRestarts <- base::computeRestarts
[08:29:19.366]                           grepl <- base::grepl
[08:29:19.366]                           restarts <- computeRestarts(cond)
[08:29:19.366]                           for (restart in restarts) {
[08:29:19.366]                             name <- restart$name
[08:29:19.366]                             if (is.null(name)) 
[08:29:19.366]                               next
[08:29:19.366]                             if (!grepl(pattern, name)) 
[08:29:19.366]                               next
[08:29:19.366]                             invokeRestart(restart)
[08:29:19.366]                             muffled <- TRUE
[08:29:19.366]                             break
[08:29:19.366]                           }
[08:29:19.366]                         }
[08:29:19.366]                       }
[08:29:19.366]                       invisible(muffled)
[08:29:19.366]                     }
[08:29:19.366]                     muffleCondition(cond, pattern = "^muffle")
[08:29:19.366]                   }
[08:29:19.366]                 }
[08:29:19.366]                 else {
[08:29:19.366]                   if (TRUE) {
[08:29:19.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:19.366]                     {
[08:29:19.366]                       inherits <- base::inherits
[08:29:19.366]                       invokeRestart <- base::invokeRestart
[08:29:19.366]                       is.null <- base::is.null
[08:29:19.366]                       muffled <- FALSE
[08:29:19.366]                       if (inherits(cond, "message")) {
[08:29:19.366]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:19.366]                         if (muffled) 
[08:29:19.366]                           invokeRestart("muffleMessage")
[08:29:19.366]                       }
[08:29:19.366]                       else if (inherits(cond, "warning")) {
[08:29:19.366]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:19.366]                         if (muffled) 
[08:29:19.366]                           invokeRestart("muffleWarning")
[08:29:19.366]                       }
[08:29:19.366]                       else if (inherits(cond, "condition")) {
[08:29:19.366]                         if (!is.null(pattern)) {
[08:29:19.366]                           computeRestarts <- base::computeRestarts
[08:29:19.366]                           grepl <- base::grepl
[08:29:19.366]                           restarts <- computeRestarts(cond)
[08:29:19.366]                           for (restart in restarts) {
[08:29:19.366]                             name <- restart$name
[08:29:19.366]                             if (is.null(name)) 
[08:29:19.366]                               next
[08:29:19.366]                             if (!grepl(pattern, name)) 
[08:29:19.366]                               next
[08:29:19.366]                             invokeRestart(restart)
[08:29:19.366]                             muffled <- TRUE
[08:29:19.366]                             break
[08:29:19.366]                           }
[08:29:19.366]                         }
[08:29:19.366]                       }
[08:29:19.366]                       invisible(muffled)
[08:29:19.366]                     }
[08:29:19.366]                     muffleCondition(cond, pattern = "^muffle")
[08:29:19.366]                   }
[08:29:19.366]                 }
[08:29:19.366]             }
[08:29:19.366]         }))
[08:29:19.366]     }, error = function(ex) {
[08:29:19.366]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:19.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:19.366]                 ...future.rng), started = ...future.startTime, 
[08:29:19.366]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:19.366]             version = "1.8"), class = "FutureResult")
[08:29:19.366]     }, finally = {
[08:29:19.366]         if (!identical(...future.workdir, getwd())) 
[08:29:19.366]             setwd(...future.workdir)
[08:29:19.366]         {
[08:29:19.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:19.366]                 ...future.oldOptions$nwarnings <- NULL
[08:29:19.366]             }
[08:29:19.366]             base::options(...future.oldOptions)
[08:29:19.366]             if (.Platform$OS.type == "windows") {
[08:29:19.366]                 old_names <- names(...future.oldEnvVars)
[08:29:19.366]                 envs <- base::Sys.getenv()
[08:29:19.366]                 names <- names(envs)
[08:29:19.366]                 common <- intersect(names, old_names)
[08:29:19.366]                 added <- setdiff(names, old_names)
[08:29:19.366]                 removed <- setdiff(old_names, names)
[08:29:19.366]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:19.366]                   envs[common]]
[08:29:19.366]                 NAMES <- toupper(changed)
[08:29:19.366]                 args <- list()
[08:29:19.366]                 for (kk in seq_along(NAMES)) {
[08:29:19.366]                   name <- changed[[kk]]
[08:29:19.366]                   NAME <- NAMES[[kk]]
[08:29:19.366]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:19.366]                     next
[08:29:19.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:19.366]                 }
[08:29:19.366]                 NAMES <- toupper(added)
[08:29:19.366]                 for (kk in seq_along(NAMES)) {
[08:29:19.366]                   name <- added[[kk]]
[08:29:19.366]                   NAME <- NAMES[[kk]]
[08:29:19.366]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:19.366]                     next
[08:29:19.366]                   args[[name]] <- ""
[08:29:19.366]                 }
[08:29:19.366]                 NAMES <- toupper(removed)
[08:29:19.366]                 for (kk in seq_along(NAMES)) {
[08:29:19.366]                   name <- removed[[kk]]
[08:29:19.366]                   NAME <- NAMES[[kk]]
[08:29:19.366]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:19.366]                     next
[08:29:19.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:19.366]                 }
[08:29:19.366]                 if (length(args) > 0) 
[08:29:19.366]                   base::do.call(base::Sys.setenv, args = args)
[08:29:19.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:19.366]             }
[08:29:19.366]             else {
[08:29:19.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:19.366]             }
[08:29:19.366]             {
[08:29:19.366]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:19.366]                   0L) {
[08:29:19.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:19.366]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:19.366]                   base::options(opts)
[08:29:19.366]                 }
[08:29:19.366]                 {
[08:29:19.366]                   {
[08:29:19.366]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:19.366]                     NULL
[08:29:19.366]                   }
[08:29:19.366]                   options(future.plan = NULL)
[08:29:19.366]                   if (is.na(NA_character_)) 
[08:29:19.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:19.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:19.366]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:19.366]                     .init = FALSE)
[08:29:19.366]                 }
[08:29:19.366]             }
[08:29:19.366]         }
[08:29:19.366]     })
[08:29:19.366]     if (TRUE) {
[08:29:19.366]         base::sink(type = "output", split = FALSE)
[08:29:19.366]         if (TRUE) {
[08:29:19.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:19.366]         }
[08:29:19.366]         else {
[08:29:19.366]             ...future.result["stdout"] <- base::list(NULL)
[08:29:19.366]         }
[08:29:19.366]         base::close(...future.stdout)
[08:29:19.366]         ...future.stdout <- NULL
[08:29:19.366]     }
[08:29:19.366]     ...future.result$conditions <- ...future.conditions
[08:29:19.366]     ...future.result$finished <- base::Sys.time()
[08:29:19.366]     ...future.result
[08:29:19.366] }
[08:29:19.369] MultisessionFuture started
[08:29:19.369] - Launch lazy future ... done
[08:29:19.369] run() for ‘MultisessionFuture’ ... done
[08:29:19.912] receiveMessageFromWorker() for ClusterFuture ...
[08:29:19.912] - Validating connection of MultisessionFuture
[08:29:19.912] - received message: FutureResult
[08:29:19.913] - Received FutureResult
[08:29:19.913] - Erased future from FutureRegistry
[08:29:19.913] result() for ClusterFuture ...
[08:29:19.913] - result already collected: FutureResult
[08:29:19.913] result() for ClusterFuture ... done
[08:29:19.913] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:19.913] resolve() on list ...
[08:29:19.913]  recursive: Inf
[08:29:19.913]  length: 2
[08:29:19.913]  elements: ‘a’, ‘b’
[08:29:19.913]  length: 1 (resolved future 1)
[08:29:19.914]  length: 0 (resolved future 2)
[08:29:19.914] resolve() on list ... DONE
[08:29:19.914] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[08:29:19.914] getGlobalsAndPackages() ...
[08:29:19.914] Searching for globals...
[08:29:19.915] - globals found: [2] ‘list’, ‘stop’
[08:29:19.915] Searching for globals ... DONE
[08:29:19.915] Resolving globals: FALSE
[08:29:19.915] 
[08:29:19.915] 
[08:29:19.915] getGlobalsAndPackages() ... DONE
[08:29:19.916] run() for ‘Future’ ...
[08:29:19.916] - state: ‘created’
[08:29:19.916] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:19.929] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:19.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:19.930]   - Field: ‘node’
[08:29:19.930]   - Field: ‘label’
[08:29:19.930]   - Field: ‘local’
[08:29:19.930]   - Field: ‘owner’
[08:29:19.930]   - Field: ‘envir’
[08:29:19.930]   - Field: ‘workers’
[08:29:19.930]   - Field: ‘packages’
[08:29:19.930]   - Field: ‘gc’
[08:29:19.930]   - Field: ‘conditions’
[08:29:19.930]   - Field: ‘persistent’
[08:29:19.931]   - Field: ‘expr’
[08:29:19.931]   - Field: ‘uuid’
[08:29:19.931]   - Field: ‘seed’
[08:29:19.931]   - Field: ‘version’
[08:29:19.931]   - Field: ‘result’
[08:29:19.931]   - Field: ‘asynchronous’
[08:29:19.931]   - Field: ‘calls’
[08:29:19.931]   - Field: ‘globals’
[08:29:19.931]   - Field: ‘stdout’
[08:29:19.931]   - Field: ‘earlySignal’
[08:29:19.931]   - Field: ‘lazy’
[08:29:19.932]   - Field: ‘state’
[08:29:19.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:19.932] - Launch lazy future ...
[08:29:19.932] Packages needed by the future expression (n = 0): <none>
[08:29:19.932] Packages needed by future strategies (n = 0): <none>
[08:29:19.932] {
[08:29:19.932]     {
[08:29:19.932]         {
[08:29:19.932]             ...future.startTime <- base::Sys.time()
[08:29:19.932]             {
[08:29:19.932]                 {
[08:29:19.932]                   {
[08:29:19.932]                     {
[08:29:19.932]                       base::local({
[08:29:19.932]                         has_future <- base::requireNamespace("future", 
[08:29:19.932]                           quietly = TRUE)
[08:29:19.932]                         if (has_future) {
[08:29:19.932]                           ns <- base::getNamespace("future")
[08:29:19.932]                           version <- ns[[".package"]][["version"]]
[08:29:19.932]                           if (is.null(version)) 
[08:29:19.932]                             version <- utils::packageVersion("future")
[08:29:19.932]                         }
[08:29:19.932]                         else {
[08:29:19.932]                           version <- NULL
[08:29:19.932]                         }
[08:29:19.932]                         if (!has_future || version < "1.8.0") {
[08:29:19.932]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:19.932]                             "", base::R.version$version.string), 
[08:29:19.932]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:19.932]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:19.932]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:19.932]                               "release", "version")], collapse = " "), 
[08:29:19.932]                             hostname = base::Sys.info()[["nodename"]])
[08:29:19.932]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:19.932]                             info)
[08:29:19.932]                           info <- base::paste(info, collapse = "; ")
[08:29:19.932]                           if (!has_future) {
[08:29:19.932]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:19.932]                               info)
[08:29:19.932]                           }
[08:29:19.932]                           else {
[08:29:19.932]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:19.932]                               info, version)
[08:29:19.932]                           }
[08:29:19.932]                           base::stop(msg)
[08:29:19.932]                         }
[08:29:19.932]                       })
[08:29:19.932]                     }
[08:29:19.932]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:19.932]                     base::options(mc.cores = 1L)
[08:29:19.932]                   }
[08:29:19.932]                   ...future.strategy.old <- future::plan("list")
[08:29:19.932]                   options(future.plan = NULL)
[08:29:19.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:19.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:19.932]                 }
[08:29:19.932]                 ...future.workdir <- getwd()
[08:29:19.932]             }
[08:29:19.932]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:19.932]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:19.932]         }
[08:29:19.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:19.932]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:19.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:19.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:19.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:19.932]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:19.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:19.932]             base::names(...future.oldOptions))
[08:29:19.932]     }
[08:29:19.932]     if (FALSE) {
[08:29:19.932]     }
[08:29:19.932]     else {
[08:29:19.932]         if (TRUE) {
[08:29:19.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:19.932]                 open = "w")
[08:29:19.932]         }
[08:29:19.932]         else {
[08:29:19.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:19.932]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:19.932]         }
[08:29:19.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:19.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:19.932]             base::sink(type = "output", split = FALSE)
[08:29:19.932]             base::close(...future.stdout)
[08:29:19.932]         }, add = TRUE)
[08:29:19.932]     }
[08:29:19.932]     ...future.frame <- base::sys.nframe()
[08:29:19.932]     ...future.conditions <- base::list()
[08:29:19.932]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:19.932]     if (FALSE) {
[08:29:19.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:19.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:19.932]     }
[08:29:19.932]     ...future.result <- base::tryCatch({
[08:29:19.932]         base::withCallingHandlers({
[08:29:19.932]             ...future.value <- base::withVisible(base::local({
[08:29:19.932]                 ...future.makeSendCondition <- base::local({
[08:29:19.932]                   sendCondition <- NULL
[08:29:19.932]                   function(frame = 1L) {
[08:29:19.932]                     if (is.function(sendCondition)) 
[08:29:19.932]                       return(sendCondition)
[08:29:19.932]                     ns <- getNamespace("parallel")
[08:29:19.932]                     if (exists("sendData", mode = "function", 
[08:29:19.932]                       envir = ns)) {
[08:29:19.932]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:19.932]                         envir = ns)
[08:29:19.932]                       envir <- sys.frame(frame)
[08:29:19.932]                       master <- NULL
[08:29:19.932]                       while (!identical(envir, .GlobalEnv) && 
[08:29:19.932]                         !identical(envir, emptyenv())) {
[08:29:19.932]                         if (exists("master", mode = "list", envir = envir, 
[08:29:19.932]                           inherits = FALSE)) {
[08:29:19.932]                           master <- get("master", mode = "list", 
[08:29:19.932]                             envir = envir, inherits = FALSE)
[08:29:19.932]                           if (inherits(master, c("SOCKnode", 
[08:29:19.932]                             "SOCK0node"))) {
[08:29:19.932]                             sendCondition <<- function(cond) {
[08:29:19.932]                               data <- list(type = "VALUE", value = cond, 
[08:29:19.932]                                 success = TRUE)
[08:29:19.932]                               parallel_sendData(master, data)
[08:29:19.932]                             }
[08:29:19.932]                             return(sendCondition)
[08:29:19.932]                           }
[08:29:19.932]                         }
[08:29:19.932]                         frame <- frame + 1L
[08:29:19.932]                         envir <- sys.frame(frame)
[08:29:19.932]                       }
[08:29:19.932]                     }
[08:29:19.932]                     sendCondition <<- function(cond) NULL
[08:29:19.932]                   }
[08:29:19.932]                 })
[08:29:19.932]                 withCallingHandlers({
[08:29:19.932]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:19.932]                 }, immediateCondition = function(cond) {
[08:29:19.932]                   sendCondition <- ...future.makeSendCondition()
[08:29:19.932]                   sendCondition(cond)
[08:29:19.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:19.932]                   {
[08:29:19.932]                     inherits <- base::inherits
[08:29:19.932]                     invokeRestart <- base::invokeRestart
[08:29:19.932]                     is.null <- base::is.null
[08:29:19.932]                     muffled <- FALSE
[08:29:19.932]                     if (inherits(cond, "message")) {
[08:29:19.932]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:19.932]                       if (muffled) 
[08:29:19.932]                         invokeRestart("muffleMessage")
[08:29:19.932]                     }
[08:29:19.932]                     else if (inherits(cond, "warning")) {
[08:29:19.932]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:19.932]                       if (muffled) 
[08:29:19.932]                         invokeRestart("muffleWarning")
[08:29:19.932]                     }
[08:29:19.932]                     else if (inherits(cond, "condition")) {
[08:29:19.932]                       if (!is.null(pattern)) {
[08:29:19.932]                         computeRestarts <- base::computeRestarts
[08:29:19.932]                         grepl <- base::grepl
[08:29:19.932]                         restarts <- computeRestarts(cond)
[08:29:19.932]                         for (restart in restarts) {
[08:29:19.932]                           name <- restart$name
[08:29:19.932]                           if (is.null(name)) 
[08:29:19.932]                             next
[08:29:19.932]                           if (!grepl(pattern, name)) 
[08:29:19.932]                             next
[08:29:19.932]                           invokeRestart(restart)
[08:29:19.932]                           muffled <- TRUE
[08:29:19.932]                           break
[08:29:19.932]                         }
[08:29:19.932]                       }
[08:29:19.932]                     }
[08:29:19.932]                     invisible(muffled)
[08:29:19.932]                   }
[08:29:19.932]                   muffleCondition(cond)
[08:29:19.932]                 })
[08:29:19.932]             }))
[08:29:19.932]             future::FutureResult(value = ...future.value$value, 
[08:29:19.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:19.932]                   ...future.rng), globalenv = if (FALSE) 
[08:29:19.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:19.932]                     ...future.globalenv.names))
[08:29:19.932]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:19.932]         }, condition = base::local({
[08:29:19.932]             c <- base::c
[08:29:19.932]             inherits <- base::inherits
[08:29:19.932]             invokeRestart <- base::invokeRestart
[08:29:19.932]             length <- base::length
[08:29:19.932]             list <- base::list
[08:29:19.932]             seq.int <- base::seq.int
[08:29:19.932]             signalCondition <- base::signalCondition
[08:29:19.932]             sys.calls <- base::sys.calls
[08:29:19.932]             `[[` <- base::`[[`
[08:29:19.932]             `+` <- base::`+`
[08:29:19.932]             `<<-` <- base::`<<-`
[08:29:19.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:19.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:19.932]                   3L)]
[08:29:19.932]             }
[08:29:19.932]             function(cond) {
[08:29:19.932]                 is_error <- inherits(cond, "error")
[08:29:19.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:19.932]                   NULL)
[08:29:19.932]                 if (is_error) {
[08:29:19.932]                   sessionInformation <- function() {
[08:29:19.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:19.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:19.932]                       search = base::search(), system = base::Sys.info())
[08:29:19.932]                   }
[08:29:19.932]                   ...future.conditions[[length(...future.conditions) + 
[08:29:19.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:19.932]                     cond$call), session = sessionInformation(), 
[08:29:19.932]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:19.932]                   signalCondition(cond)
[08:29:19.932]                 }
[08:29:19.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:19.932]                 "immediateCondition"))) {
[08:29:19.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:19.932]                   ...future.conditions[[length(...future.conditions) + 
[08:29:19.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:19.932]                   if (TRUE && !signal) {
[08:29:19.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:19.932]                     {
[08:29:19.932]                       inherits <- base::inherits
[08:29:19.932]                       invokeRestart <- base::invokeRestart
[08:29:19.932]                       is.null <- base::is.null
[08:29:19.932]                       muffled <- FALSE
[08:29:19.932]                       if (inherits(cond, "message")) {
[08:29:19.932]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:19.932]                         if (muffled) 
[08:29:19.932]                           invokeRestart("muffleMessage")
[08:29:19.932]                       }
[08:29:19.932]                       else if (inherits(cond, "warning")) {
[08:29:19.932]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:19.932]                         if (muffled) 
[08:29:19.932]                           invokeRestart("muffleWarning")
[08:29:19.932]                       }
[08:29:19.932]                       else if (inherits(cond, "condition")) {
[08:29:19.932]                         if (!is.null(pattern)) {
[08:29:19.932]                           computeRestarts <- base::computeRestarts
[08:29:19.932]                           grepl <- base::grepl
[08:29:19.932]                           restarts <- computeRestarts(cond)
[08:29:19.932]                           for (restart in restarts) {
[08:29:19.932]                             name <- restart$name
[08:29:19.932]                             if (is.null(name)) 
[08:29:19.932]                               next
[08:29:19.932]                             if (!grepl(pattern, name)) 
[08:29:19.932]                               next
[08:29:19.932]                             invokeRestart(restart)
[08:29:19.932]                             muffled <- TRUE
[08:29:19.932]                             break
[08:29:19.932]                           }
[08:29:19.932]                         }
[08:29:19.932]                       }
[08:29:19.932]                       invisible(muffled)
[08:29:19.932]                     }
[08:29:19.932]                     muffleCondition(cond, pattern = "^muffle")
[08:29:19.932]                   }
[08:29:19.932]                 }
[08:29:19.932]                 else {
[08:29:19.932]                   if (TRUE) {
[08:29:19.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:19.932]                     {
[08:29:19.932]                       inherits <- base::inherits
[08:29:19.932]                       invokeRestart <- base::invokeRestart
[08:29:19.932]                       is.null <- base::is.null
[08:29:19.932]                       muffled <- FALSE
[08:29:19.932]                       if (inherits(cond, "message")) {
[08:29:19.932]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:19.932]                         if (muffled) 
[08:29:19.932]                           invokeRestart("muffleMessage")
[08:29:19.932]                       }
[08:29:19.932]                       else if (inherits(cond, "warning")) {
[08:29:19.932]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:19.932]                         if (muffled) 
[08:29:19.932]                           invokeRestart("muffleWarning")
[08:29:19.932]                       }
[08:29:19.932]                       else if (inherits(cond, "condition")) {
[08:29:19.932]                         if (!is.null(pattern)) {
[08:29:19.932]                           computeRestarts <- base::computeRestarts
[08:29:19.932]                           grepl <- base::grepl
[08:29:19.932]                           restarts <- computeRestarts(cond)
[08:29:19.932]                           for (restart in restarts) {
[08:29:19.932]                             name <- restart$name
[08:29:19.932]                             if (is.null(name)) 
[08:29:19.932]                               next
[08:29:19.932]                             if (!grepl(pattern, name)) 
[08:29:19.932]                               next
[08:29:19.932]                             invokeRestart(restart)
[08:29:19.932]                             muffled <- TRUE
[08:29:19.932]                             break
[08:29:19.932]                           }
[08:29:19.932]                         }
[08:29:19.932]                       }
[08:29:19.932]                       invisible(muffled)
[08:29:19.932]                     }
[08:29:19.932]                     muffleCondition(cond, pattern = "^muffle")
[08:29:19.932]                   }
[08:29:19.932]                 }
[08:29:19.932]             }
[08:29:19.932]         }))
[08:29:19.932]     }, error = function(ex) {
[08:29:19.932]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:19.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:19.932]                 ...future.rng), started = ...future.startTime, 
[08:29:19.932]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:19.932]             version = "1.8"), class = "FutureResult")
[08:29:19.932]     }, finally = {
[08:29:19.932]         if (!identical(...future.workdir, getwd())) 
[08:29:19.932]             setwd(...future.workdir)
[08:29:19.932]         {
[08:29:19.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:19.932]                 ...future.oldOptions$nwarnings <- NULL
[08:29:19.932]             }
[08:29:19.932]             base::options(...future.oldOptions)
[08:29:19.932]             if (.Platform$OS.type == "windows") {
[08:29:19.932]                 old_names <- names(...future.oldEnvVars)
[08:29:19.932]                 envs <- base::Sys.getenv()
[08:29:19.932]                 names <- names(envs)
[08:29:19.932]                 common <- intersect(names, old_names)
[08:29:19.932]                 added <- setdiff(names, old_names)
[08:29:19.932]                 removed <- setdiff(old_names, names)
[08:29:19.932]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:19.932]                   envs[common]]
[08:29:19.932]                 NAMES <- toupper(changed)
[08:29:19.932]                 args <- list()
[08:29:19.932]                 for (kk in seq_along(NAMES)) {
[08:29:19.932]                   name <- changed[[kk]]
[08:29:19.932]                   NAME <- NAMES[[kk]]
[08:29:19.932]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:19.932]                     next
[08:29:19.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:19.932]                 }
[08:29:19.932]                 NAMES <- toupper(added)
[08:29:19.932]                 for (kk in seq_along(NAMES)) {
[08:29:19.932]                   name <- added[[kk]]
[08:29:19.932]                   NAME <- NAMES[[kk]]
[08:29:19.932]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:19.932]                     next
[08:29:19.932]                   args[[name]] <- ""
[08:29:19.932]                 }
[08:29:19.932]                 NAMES <- toupper(removed)
[08:29:19.932]                 for (kk in seq_along(NAMES)) {
[08:29:19.932]                   name <- removed[[kk]]
[08:29:19.932]                   NAME <- NAMES[[kk]]
[08:29:19.932]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:19.932]                     next
[08:29:19.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:19.932]                 }
[08:29:19.932]                 if (length(args) > 0) 
[08:29:19.932]                   base::do.call(base::Sys.setenv, args = args)
[08:29:19.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:19.932]             }
[08:29:19.932]             else {
[08:29:19.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:19.932]             }
[08:29:19.932]             {
[08:29:19.932]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:19.932]                   0L) {
[08:29:19.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:19.932]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:19.932]                   base::options(opts)
[08:29:19.932]                 }
[08:29:19.932]                 {
[08:29:19.932]                   {
[08:29:19.932]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:19.932]                     NULL
[08:29:19.932]                   }
[08:29:19.932]                   options(future.plan = NULL)
[08:29:19.932]                   if (is.na(NA_character_)) 
[08:29:19.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:19.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:19.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:19.932]                     .init = FALSE)
[08:29:19.932]                 }
[08:29:19.932]             }
[08:29:19.932]         }
[08:29:19.932]     })
[08:29:19.932]     if (TRUE) {
[08:29:19.932]         base::sink(type = "output", split = FALSE)
[08:29:19.932]         if (TRUE) {
[08:29:19.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:19.932]         }
[08:29:19.932]         else {
[08:29:19.932]             ...future.result["stdout"] <- base::list(NULL)
[08:29:19.932]         }
[08:29:19.932]         base::close(...future.stdout)
[08:29:19.932]         ...future.stdout <- NULL
[08:29:19.932]     }
[08:29:19.932]     ...future.result$conditions <- ...future.conditions
[08:29:19.932]     ...future.result$finished <- base::Sys.time()
[08:29:19.932]     ...future.result
[08:29:19.932] }
[08:29:19.936] MultisessionFuture started
[08:29:19.936] - Launch lazy future ... done
[08:29:19.936] run() for ‘MultisessionFuture’ ... done
[08:29:19.979] receiveMessageFromWorker() for ClusterFuture ...
[08:29:19.979] - Validating connection of MultisessionFuture
[08:29:19.980] - received message: FutureResult
[08:29:19.980] - Received FutureResult
[08:29:19.980] - Erased future from FutureRegistry
[08:29:19.980] result() for ClusterFuture ...
[08:29:19.981] - result already collected: FutureResult
[08:29:19.981] result() for ClusterFuture ... done
[08:29:19.981] signalConditions() ...
[08:29:19.981]  - include = ‘immediateCondition’
[08:29:19.981]  - exclude = 
[08:29:19.981]  - resignal = FALSE
[08:29:19.981]  - Number of conditions: 1
[08:29:19.982] signalConditions() ... done
[08:29:19.982] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:19.982] A MultisessionFuture was resolved (and resolved itself)
[08:29:19.982] getGlobalsAndPackages() ...
[08:29:19.982] Searching for globals...
[08:29:19.984] - globals found: [2] ‘list’, ‘stop’
[08:29:19.984] Searching for globals ... DONE
[08:29:19.984] Resolving globals: FALSE
[08:29:19.984] 
[08:29:19.984] 
[08:29:19.985] getGlobalsAndPackages() ... DONE
[08:29:19.985] run() for ‘Future’ ...
[08:29:19.985] - state: ‘created’
[08:29:19.985] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.001] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.002]   - Field: ‘node’
[08:29:20.002]   - Field: ‘label’
[08:29:20.002]   - Field: ‘local’
[08:29:20.002]   - Field: ‘owner’
[08:29:20.002]   - Field: ‘envir’
[08:29:20.002]   - Field: ‘workers’
[08:29:20.002]   - Field: ‘packages’
[08:29:20.003]   - Field: ‘gc’
[08:29:20.003]   - Field: ‘conditions’
[08:29:20.003]   - Field: ‘persistent’
[08:29:20.003]   - Field: ‘expr’
[08:29:20.003]   - Field: ‘uuid’
[08:29:20.003]   - Field: ‘seed’
[08:29:20.003]   - Field: ‘version’
[08:29:20.004]   - Field: ‘result’
[08:29:20.004]   - Field: ‘asynchronous’
[08:29:20.004]   - Field: ‘calls’
[08:29:20.004]   - Field: ‘globals’
[08:29:20.004]   - Field: ‘stdout’
[08:29:20.004]   - Field: ‘earlySignal’
[08:29:20.004]   - Field: ‘lazy’
[08:29:20.004]   - Field: ‘state’
[08:29:20.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.005] - Launch lazy future ...
[08:29:20.005] Packages needed by the future expression (n = 0): <none>
[08:29:20.005] Packages needed by future strategies (n = 0): <none>
[08:29:20.006] {
[08:29:20.006]     {
[08:29:20.006]         {
[08:29:20.006]             ...future.startTime <- base::Sys.time()
[08:29:20.006]             {
[08:29:20.006]                 {
[08:29:20.006]                   {
[08:29:20.006]                     {
[08:29:20.006]                       base::local({
[08:29:20.006]                         has_future <- base::requireNamespace("future", 
[08:29:20.006]                           quietly = TRUE)
[08:29:20.006]                         if (has_future) {
[08:29:20.006]                           ns <- base::getNamespace("future")
[08:29:20.006]                           version <- ns[[".package"]][["version"]]
[08:29:20.006]                           if (is.null(version)) 
[08:29:20.006]                             version <- utils::packageVersion("future")
[08:29:20.006]                         }
[08:29:20.006]                         else {
[08:29:20.006]                           version <- NULL
[08:29:20.006]                         }
[08:29:20.006]                         if (!has_future || version < "1.8.0") {
[08:29:20.006]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.006]                             "", base::R.version$version.string), 
[08:29:20.006]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.006]                               "release", "version")], collapse = " "), 
[08:29:20.006]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.006]                             info)
[08:29:20.006]                           info <- base::paste(info, collapse = "; ")
[08:29:20.006]                           if (!has_future) {
[08:29:20.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.006]                               info)
[08:29:20.006]                           }
[08:29:20.006]                           else {
[08:29:20.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.006]                               info, version)
[08:29:20.006]                           }
[08:29:20.006]                           base::stop(msg)
[08:29:20.006]                         }
[08:29:20.006]                       })
[08:29:20.006]                     }
[08:29:20.006]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.006]                     base::options(mc.cores = 1L)
[08:29:20.006]                   }
[08:29:20.006]                   ...future.strategy.old <- future::plan("list")
[08:29:20.006]                   options(future.plan = NULL)
[08:29:20.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.006]                 }
[08:29:20.006]                 ...future.workdir <- getwd()
[08:29:20.006]             }
[08:29:20.006]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.006]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.006]         }
[08:29:20.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.006]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.006]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.006]             base::names(...future.oldOptions))
[08:29:20.006]     }
[08:29:20.006]     if (FALSE) {
[08:29:20.006]     }
[08:29:20.006]     else {
[08:29:20.006]         if (TRUE) {
[08:29:20.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.006]                 open = "w")
[08:29:20.006]         }
[08:29:20.006]         else {
[08:29:20.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.006]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.006]         }
[08:29:20.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.006]             base::sink(type = "output", split = FALSE)
[08:29:20.006]             base::close(...future.stdout)
[08:29:20.006]         }, add = TRUE)
[08:29:20.006]     }
[08:29:20.006]     ...future.frame <- base::sys.nframe()
[08:29:20.006]     ...future.conditions <- base::list()
[08:29:20.006]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.006]     if (FALSE) {
[08:29:20.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.006]     }
[08:29:20.006]     ...future.result <- base::tryCatch({
[08:29:20.006]         base::withCallingHandlers({
[08:29:20.006]             ...future.value <- base::withVisible(base::local({
[08:29:20.006]                 ...future.makeSendCondition <- base::local({
[08:29:20.006]                   sendCondition <- NULL
[08:29:20.006]                   function(frame = 1L) {
[08:29:20.006]                     if (is.function(sendCondition)) 
[08:29:20.006]                       return(sendCondition)
[08:29:20.006]                     ns <- getNamespace("parallel")
[08:29:20.006]                     if (exists("sendData", mode = "function", 
[08:29:20.006]                       envir = ns)) {
[08:29:20.006]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.006]                         envir = ns)
[08:29:20.006]                       envir <- sys.frame(frame)
[08:29:20.006]                       master <- NULL
[08:29:20.006]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.006]                         !identical(envir, emptyenv())) {
[08:29:20.006]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.006]                           inherits = FALSE)) {
[08:29:20.006]                           master <- get("master", mode = "list", 
[08:29:20.006]                             envir = envir, inherits = FALSE)
[08:29:20.006]                           if (inherits(master, c("SOCKnode", 
[08:29:20.006]                             "SOCK0node"))) {
[08:29:20.006]                             sendCondition <<- function(cond) {
[08:29:20.006]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.006]                                 success = TRUE)
[08:29:20.006]                               parallel_sendData(master, data)
[08:29:20.006]                             }
[08:29:20.006]                             return(sendCondition)
[08:29:20.006]                           }
[08:29:20.006]                         }
[08:29:20.006]                         frame <- frame + 1L
[08:29:20.006]                         envir <- sys.frame(frame)
[08:29:20.006]                       }
[08:29:20.006]                     }
[08:29:20.006]                     sendCondition <<- function(cond) NULL
[08:29:20.006]                   }
[08:29:20.006]                 })
[08:29:20.006]                 withCallingHandlers({
[08:29:20.006]                   list(a = 1, b = 42L, c = stop("Nah!"))
[08:29:20.006]                 }, immediateCondition = function(cond) {
[08:29:20.006]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.006]                   sendCondition(cond)
[08:29:20.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.006]                   {
[08:29:20.006]                     inherits <- base::inherits
[08:29:20.006]                     invokeRestart <- base::invokeRestart
[08:29:20.006]                     is.null <- base::is.null
[08:29:20.006]                     muffled <- FALSE
[08:29:20.006]                     if (inherits(cond, "message")) {
[08:29:20.006]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.006]                       if (muffled) 
[08:29:20.006]                         invokeRestart("muffleMessage")
[08:29:20.006]                     }
[08:29:20.006]                     else if (inherits(cond, "warning")) {
[08:29:20.006]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.006]                       if (muffled) 
[08:29:20.006]                         invokeRestart("muffleWarning")
[08:29:20.006]                     }
[08:29:20.006]                     else if (inherits(cond, "condition")) {
[08:29:20.006]                       if (!is.null(pattern)) {
[08:29:20.006]                         computeRestarts <- base::computeRestarts
[08:29:20.006]                         grepl <- base::grepl
[08:29:20.006]                         restarts <- computeRestarts(cond)
[08:29:20.006]                         for (restart in restarts) {
[08:29:20.006]                           name <- restart$name
[08:29:20.006]                           if (is.null(name)) 
[08:29:20.006]                             next
[08:29:20.006]                           if (!grepl(pattern, name)) 
[08:29:20.006]                             next
[08:29:20.006]                           invokeRestart(restart)
[08:29:20.006]                           muffled <- TRUE
[08:29:20.006]                           break
[08:29:20.006]                         }
[08:29:20.006]                       }
[08:29:20.006]                     }
[08:29:20.006]                     invisible(muffled)
[08:29:20.006]                   }
[08:29:20.006]                   muffleCondition(cond)
[08:29:20.006]                 })
[08:29:20.006]             }))
[08:29:20.006]             future::FutureResult(value = ...future.value$value, 
[08:29:20.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.006]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.006]                     ...future.globalenv.names))
[08:29:20.006]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.006]         }, condition = base::local({
[08:29:20.006]             c <- base::c
[08:29:20.006]             inherits <- base::inherits
[08:29:20.006]             invokeRestart <- base::invokeRestart
[08:29:20.006]             length <- base::length
[08:29:20.006]             list <- base::list
[08:29:20.006]             seq.int <- base::seq.int
[08:29:20.006]             signalCondition <- base::signalCondition
[08:29:20.006]             sys.calls <- base::sys.calls
[08:29:20.006]             `[[` <- base::`[[`
[08:29:20.006]             `+` <- base::`+`
[08:29:20.006]             `<<-` <- base::`<<-`
[08:29:20.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.006]                   3L)]
[08:29:20.006]             }
[08:29:20.006]             function(cond) {
[08:29:20.006]                 is_error <- inherits(cond, "error")
[08:29:20.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.006]                   NULL)
[08:29:20.006]                 if (is_error) {
[08:29:20.006]                   sessionInformation <- function() {
[08:29:20.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.006]                       search = base::search(), system = base::Sys.info())
[08:29:20.006]                   }
[08:29:20.006]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.006]                     cond$call), session = sessionInformation(), 
[08:29:20.006]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.006]                   signalCondition(cond)
[08:29:20.006]                 }
[08:29:20.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.006]                 "immediateCondition"))) {
[08:29:20.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.006]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.006]                   if (TRUE && !signal) {
[08:29:20.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.006]                     {
[08:29:20.006]                       inherits <- base::inherits
[08:29:20.006]                       invokeRestart <- base::invokeRestart
[08:29:20.006]                       is.null <- base::is.null
[08:29:20.006]                       muffled <- FALSE
[08:29:20.006]                       if (inherits(cond, "message")) {
[08:29:20.006]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.006]                         if (muffled) 
[08:29:20.006]                           invokeRestart("muffleMessage")
[08:29:20.006]                       }
[08:29:20.006]                       else if (inherits(cond, "warning")) {
[08:29:20.006]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.006]                         if (muffled) 
[08:29:20.006]                           invokeRestart("muffleWarning")
[08:29:20.006]                       }
[08:29:20.006]                       else if (inherits(cond, "condition")) {
[08:29:20.006]                         if (!is.null(pattern)) {
[08:29:20.006]                           computeRestarts <- base::computeRestarts
[08:29:20.006]                           grepl <- base::grepl
[08:29:20.006]                           restarts <- computeRestarts(cond)
[08:29:20.006]                           for (restart in restarts) {
[08:29:20.006]                             name <- restart$name
[08:29:20.006]                             if (is.null(name)) 
[08:29:20.006]                               next
[08:29:20.006]                             if (!grepl(pattern, name)) 
[08:29:20.006]                               next
[08:29:20.006]                             invokeRestart(restart)
[08:29:20.006]                             muffled <- TRUE
[08:29:20.006]                             break
[08:29:20.006]                           }
[08:29:20.006]                         }
[08:29:20.006]                       }
[08:29:20.006]                       invisible(muffled)
[08:29:20.006]                     }
[08:29:20.006]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.006]                   }
[08:29:20.006]                 }
[08:29:20.006]                 else {
[08:29:20.006]                   if (TRUE) {
[08:29:20.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.006]                     {
[08:29:20.006]                       inherits <- base::inherits
[08:29:20.006]                       invokeRestart <- base::invokeRestart
[08:29:20.006]                       is.null <- base::is.null
[08:29:20.006]                       muffled <- FALSE
[08:29:20.006]                       if (inherits(cond, "message")) {
[08:29:20.006]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.006]                         if (muffled) 
[08:29:20.006]                           invokeRestart("muffleMessage")
[08:29:20.006]                       }
[08:29:20.006]                       else if (inherits(cond, "warning")) {
[08:29:20.006]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.006]                         if (muffled) 
[08:29:20.006]                           invokeRestart("muffleWarning")
[08:29:20.006]                       }
[08:29:20.006]                       else if (inherits(cond, "condition")) {
[08:29:20.006]                         if (!is.null(pattern)) {
[08:29:20.006]                           computeRestarts <- base::computeRestarts
[08:29:20.006]                           grepl <- base::grepl
[08:29:20.006]                           restarts <- computeRestarts(cond)
[08:29:20.006]                           for (restart in restarts) {
[08:29:20.006]                             name <- restart$name
[08:29:20.006]                             if (is.null(name)) 
[08:29:20.006]                               next
[08:29:20.006]                             if (!grepl(pattern, name)) 
[08:29:20.006]                               next
[08:29:20.006]                             invokeRestart(restart)
[08:29:20.006]                             muffled <- TRUE
[08:29:20.006]                             break
[08:29:20.006]                           }
[08:29:20.006]                         }
[08:29:20.006]                       }
[08:29:20.006]                       invisible(muffled)
[08:29:20.006]                     }
[08:29:20.006]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.006]                   }
[08:29:20.006]                 }
[08:29:20.006]             }
[08:29:20.006]         }))
[08:29:20.006]     }, error = function(ex) {
[08:29:20.006]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.006]                 ...future.rng), started = ...future.startTime, 
[08:29:20.006]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.006]             version = "1.8"), class = "FutureResult")
[08:29:20.006]     }, finally = {
[08:29:20.006]         if (!identical(...future.workdir, getwd())) 
[08:29:20.006]             setwd(...future.workdir)
[08:29:20.006]         {
[08:29:20.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.006]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.006]             }
[08:29:20.006]             base::options(...future.oldOptions)
[08:29:20.006]             if (.Platform$OS.type == "windows") {
[08:29:20.006]                 old_names <- names(...future.oldEnvVars)
[08:29:20.006]                 envs <- base::Sys.getenv()
[08:29:20.006]                 names <- names(envs)
[08:29:20.006]                 common <- intersect(names, old_names)
[08:29:20.006]                 added <- setdiff(names, old_names)
[08:29:20.006]                 removed <- setdiff(old_names, names)
[08:29:20.006]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.006]                   envs[common]]
[08:29:20.006]                 NAMES <- toupper(changed)
[08:29:20.006]                 args <- list()
[08:29:20.006]                 for (kk in seq_along(NAMES)) {
[08:29:20.006]                   name <- changed[[kk]]
[08:29:20.006]                   NAME <- NAMES[[kk]]
[08:29:20.006]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.006]                     next
[08:29:20.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.006]                 }
[08:29:20.006]                 NAMES <- toupper(added)
[08:29:20.006]                 for (kk in seq_along(NAMES)) {
[08:29:20.006]                   name <- added[[kk]]
[08:29:20.006]                   NAME <- NAMES[[kk]]
[08:29:20.006]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.006]                     next
[08:29:20.006]                   args[[name]] <- ""
[08:29:20.006]                 }
[08:29:20.006]                 NAMES <- toupper(removed)
[08:29:20.006]                 for (kk in seq_along(NAMES)) {
[08:29:20.006]                   name <- removed[[kk]]
[08:29:20.006]                   NAME <- NAMES[[kk]]
[08:29:20.006]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.006]                     next
[08:29:20.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.006]                 }
[08:29:20.006]                 if (length(args) > 0) 
[08:29:20.006]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.006]             }
[08:29:20.006]             else {
[08:29:20.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.006]             }
[08:29:20.006]             {
[08:29:20.006]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.006]                   0L) {
[08:29:20.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.006]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.006]                   base::options(opts)
[08:29:20.006]                 }
[08:29:20.006]                 {
[08:29:20.006]                   {
[08:29:20.006]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.006]                     NULL
[08:29:20.006]                   }
[08:29:20.006]                   options(future.plan = NULL)
[08:29:20.006]                   if (is.na(NA_character_)) 
[08:29:20.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.006]                     .init = FALSE)
[08:29:20.006]                 }
[08:29:20.006]             }
[08:29:20.006]         }
[08:29:20.006]     })
[08:29:20.006]     if (TRUE) {
[08:29:20.006]         base::sink(type = "output", split = FALSE)
[08:29:20.006]         if (TRUE) {
[08:29:20.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.006]         }
[08:29:20.006]         else {
[08:29:20.006]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.006]         }
[08:29:20.006]         base::close(...future.stdout)
[08:29:20.006]         ...future.stdout <- NULL
[08:29:20.006]     }
[08:29:20.006]     ...future.result$conditions <- ...future.conditions
[08:29:20.006]     ...future.result$finished <- base::Sys.time()
[08:29:20.006]     ...future.result
[08:29:20.006] }
[08:29:20.011] MultisessionFuture started
[08:29:20.011] - Launch lazy future ... done
[08:29:20.012] run() for ‘MultisessionFuture’ ... done
[08:29:20.054] receiveMessageFromWorker() for ClusterFuture ...
[08:29:20.054] - Validating connection of MultisessionFuture
[08:29:20.054] - received message: FutureResult
[08:29:20.054] - Received FutureResult
[08:29:20.055] - Erased future from FutureRegistry
[08:29:20.055] result() for ClusterFuture ...
[08:29:20.055] - result already collected: FutureResult
[08:29:20.055] result() for ClusterFuture ... done
[08:29:20.055] signalConditions() ...
[08:29:20.055]  - include = ‘immediateCondition’
[08:29:20.055]  - exclude = 
[08:29:20.055]  - resignal = FALSE
[08:29:20.055]  - Number of conditions: 1
[08:29:20.055] signalConditions() ... done
[08:29:20.055] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:20.056] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[08:29:20.056] resolve() on list ...
[08:29:20.056]  recursive: 0
[08:29:20.056]  length: 2
[08:29:20.056]  elements: ‘a’, ‘b’
[08:29:20.056]  length: 1 (resolved future 1)
[08:29:20.056]  length: 0 (resolved future 2)
[08:29:20.056] resolve() on list ... DONE
[08:29:20.056] getGlobalsAndPackages() ...
[08:29:20.057] Searching for globals...
[08:29:20.057] 
[08:29:20.057] Searching for globals ... DONE
[08:29:20.057] - globals: [0] <none>
[08:29:20.057] getGlobalsAndPackages() ... DONE
[08:29:20.057] run() for ‘Future’ ...
[08:29:20.057] - state: ‘created’
[08:29:20.058] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.071] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.072]   - Field: ‘node’
[08:29:20.072]   - Field: ‘label’
[08:29:20.072]   - Field: ‘local’
[08:29:20.072]   - Field: ‘owner’
[08:29:20.072]   - Field: ‘envir’
[08:29:20.072]   - Field: ‘workers’
[08:29:20.072]   - Field: ‘packages’
[08:29:20.072]   - Field: ‘gc’
[08:29:20.072]   - Field: ‘conditions’
[08:29:20.072]   - Field: ‘persistent’
[08:29:20.073]   - Field: ‘expr’
[08:29:20.073]   - Field: ‘uuid’
[08:29:20.073]   - Field: ‘seed’
[08:29:20.073]   - Field: ‘version’
[08:29:20.073]   - Field: ‘result’
[08:29:20.073]   - Field: ‘asynchronous’
[08:29:20.073]   - Field: ‘calls’
[08:29:20.073]   - Field: ‘globals’
[08:29:20.073]   - Field: ‘stdout’
[08:29:20.073]   - Field: ‘earlySignal’
[08:29:20.073]   - Field: ‘lazy’
[08:29:20.073]   - Field: ‘state’
[08:29:20.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.074] - Launch lazy future ...
[08:29:20.074] Packages needed by the future expression (n = 0): <none>
[08:29:20.074] Packages needed by future strategies (n = 0): <none>
[08:29:20.074] {
[08:29:20.074]     {
[08:29:20.074]         {
[08:29:20.074]             ...future.startTime <- base::Sys.time()
[08:29:20.074]             {
[08:29:20.074]                 {
[08:29:20.074]                   {
[08:29:20.074]                     {
[08:29:20.074]                       base::local({
[08:29:20.074]                         has_future <- base::requireNamespace("future", 
[08:29:20.074]                           quietly = TRUE)
[08:29:20.074]                         if (has_future) {
[08:29:20.074]                           ns <- base::getNamespace("future")
[08:29:20.074]                           version <- ns[[".package"]][["version"]]
[08:29:20.074]                           if (is.null(version)) 
[08:29:20.074]                             version <- utils::packageVersion("future")
[08:29:20.074]                         }
[08:29:20.074]                         else {
[08:29:20.074]                           version <- NULL
[08:29:20.074]                         }
[08:29:20.074]                         if (!has_future || version < "1.8.0") {
[08:29:20.074]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.074]                             "", base::R.version$version.string), 
[08:29:20.074]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.074]                               "release", "version")], collapse = " "), 
[08:29:20.074]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.074]                             info)
[08:29:20.074]                           info <- base::paste(info, collapse = "; ")
[08:29:20.074]                           if (!has_future) {
[08:29:20.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.074]                               info)
[08:29:20.074]                           }
[08:29:20.074]                           else {
[08:29:20.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.074]                               info, version)
[08:29:20.074]                           }
[08:29:20.074]                           base::stop(msg)
[08:29:20.074]                         }
[08:29:20.074]                       })
[08:29:20.074]                     }
[08:29:20.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.074]                     base::options(mc.cores = 1L)
[08:29:20.074]                   }
[08:29:20.074]                   ...future.strategy.old <- future::plan("list")
[08:29:20.074]                   options(future.plan = NULL)
[08:29:20.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.074]                 }
[08:29:20.074]                 ...future.workdir <- getwd()
[08:29:20.074]             }
[08:29:20.074]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.074]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.074]         }
[08:29:20.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.074]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.074]             base::names(...future.oldOptions))
[08:29:20.074]     }
[08:29:20.074]     if (FALSE) {
[08:29:20.074]     }
[08:29:20.074]     else {
[08:29:20.074]         if (TRUE) {
[08:29:20.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.074]                 open = "w")
[08:29:20.074]         }
[08:29:20.074]         else {
[08:29:20.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.074]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.074]         }
[08:29:20.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.074]             base::sink(type = "output", split = FALSE)
[08:29:20.074]             base::close(...future.stdout)
[08:29:20.074]         }, add = TRUE)
[08:29:20.074]     }
[08:29:20.074]     ...future.frame <- base::sys.nframe()
[08:29:20.074]     ...future.conditions <- base::list()
[08:29:20.074]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.074]     if (FALSE) {
[08:29:20.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.074]     }
[08:29:20.074]     ...future.result <- base::tryCatch({
[08:29:20.074]         base::withCallingHandlers({
[08:29:20.074]             ...future.value <- base::withVisible(base::local({
[08:29:20.074]                 ...future.makeSendCondition <- base::local({
[08:29:20.074]                   sendCondition <- NULL
[08:29:20.074]                   function(frame = 1L) {
[08:29:20.074]                     if (is.function(sendCondition)) 
[08:29:20.074]                       return(sendCondition)
[08:29:20.074]                     ns <- getNamespace("parallel")
[08:29:20.074]                     if (exists("sendData", mode = "function", 
[08:29:20.074]                       envir = ns)) {
[08:29:20.074]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.074]                         envir = ns)
[08:29:20.074]                       envir <- sys.frame(frame)
[08:29:20.074]                       master <- NULL
[08:29:20.074]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.074]                         !identical(envir, emptyenv())) {
[08:29:20.074]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.074]                           inherits = FALSE)) {
[08:29:20.074]                           master <- get("master", mode = "list", 
[08:29:20.074]                             envir = envir, inherits = FALSE)
[08:29:20.074]                           if (inherits(master, c("SOCKnode", 
[08:29:20.074]                             "SOCK0node"))) {
[08:29:20.074]                             sendCondition <<- function(cond) {
[08:29:20.074]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.074]                                 success = TRUE)
[08:29:20.074]                               parallel_sendData(master, data)
[08:29:20.074]                             }
[08:29:20.074]                             return(sendCondition)
[08:29:20.074]                           }
[08:29:20.074]                         }
[08:29:20.074]                         frame <- frame + 1L
[08:29:20.074]                         envir <- sys.frame(frame)
[08:29:20.074]                       }
[08:29:20.074]                     }
[08:29:20.074]                     sendCondition <<- function(cond) NULL
[08:29:20.074]                   }
[08:29:20.074]                 })
[08:29:20.074]                 withCallingHandlers({
[08:29:20.074]                   1
[08:29:20.074]                 }, immediateCondition = function(cond) {
[08:29:20.074]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.074]                   sendCondition(cond)
[08:29:20.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.074]                   {
[08:29:20.074]                     inherits <- base::inherits
[08:29:20.074]                     invokeRestart <- base::invokeRestart
[08:29:20.074]                     is.null <- base::is.null
[08:29:20.074]                     muffled <- FALSE
[08:29:20.074]                     if (inherits(cond, "message")) {
[08:29:20.074]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.074]                       if (muffled) 
[08:29:20.074]                         invokeRestart("muffleMessage")
[08:29:20.074]                     }
[08:29:20.074]                     else if (inherits(cond, "warning")) {
[08:29:20.074]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.074]                       if (muffled) 
[08:29:20.074]                         invokeRestart("muffleWarning")
[08:29:20.074]                     }
[08:29:20.074]                     else if (inherits(cond, "condition")) {
[08:29:20.074]                       if (!is.null(pattern)) {
[08:29:20.074]                         computeRestarts <- base::computeRestarts
[08:29:20.074]                         grepl <- base::grepl
[08:29:20.074]                         restarts <- computeRestarts(cond)
[08:29:20.074]                         for (restart in restarts) {
[08:29:20.074]                           name <- restart$name
[08:29:20.074]                           if (is.null(name)) 
[08:29:20.074]                             next
[08:29:20.074]                           if (!grepl(pattern, name)) 
[08:29:20.074]                             next
[08:29:20.074]                           invokeRestart(restart)
[08:29:20.074]                           muffled <- TRUE
[08:29:20.074]                           break
[08:29:20.074]                         }
[08:29:20.074]                       }
[08:29:20.074]                     }
[08:29:20.074]                     invisible(muffled)
[08:29:20.074]                   }
[08:29:20.074]                   muffleCondition(cond)
[08:29:20.074]                 })
[08:29:20.074]             }))
[08:29:20.074]             future::FutureResult(value = ...future.value$value, 
[08:29:20.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.074]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.074]                     ...future.globalenv.names))
[08:29:20.074]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.074]         }, condition = base::local({
[08:29:20.074]             c <- base::c
[08:29:20.074]             inherits <- base::inherits
[08:29:20.074]             invokeRestart <- base::invokeRestart
[08:29:20.074]             length <- base::length
[08:29:20.074]             list <- base::list
[08:29:20.074]             seq.int <- base::seq.int
[08:29:20.074]             signalCondition <- base::signalCondition
[08:29:20.074]             sys.calls <- base::sys.calls
[08:29:20.074]             `[[` <- base::`[[`
[08:29:20.074]             `+` <- base::`+`
[08:29:20.074]             `<<-` <- base::`<<-`
[08:29:20.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.074]                   3L)]
[08:29:20.074]             }
[08:29:20.074]             function(cond) {
[08:29:20.074]                 is_error <- inherits(cond, "error")
[08:29:20.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.074]                   NULL)
[08:29:20.074]                 if (is_error) {
[08:29:20.074]                   sessionInformation <- function() {
[08:29:20.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.074]                       search = base::search(), system = base::Sys.info())
[08:29:20.074]                   }
[08:29:20.074]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.074]                     cond$call), session = sessionInformation(), 
[08:29:20.074]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.074]                   signalCondition(cond)
[08:29:20.074]                 }
[08:29:20.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.074]                 "immediateCondition"))) {
[08:29:20.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.074]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.074]                   if (TRUE && !signal) {
[08:29:20.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.074]                     {
[08:29:20.074]                       inherits <- base::inherits
[08:29:20.074]                       invokeRestart <- base::invokeRestart
[08:29:20.074]                       is.null <- base::is.null
[08:29:20.074]                       muffled <- FALSE
[08:29:20.074]                       if (inherits(cond, "message")) {
[08:29:20.074]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.074]                         if (muffled) 
[08:29:20.074]                           invokeRestart("muffleMessage")
[08:29:20.074]                       }
[08:29:20.074]                       else if (inherits(cond, "warning")) {
[08:29:20.074]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.074]                         if (muffled) 
[08:29:20.074]                           invokeRestart("muffleWarning")
[08:29:20.074]                       }
[08:29:20.074]                       else if (inherits(cond, "condition")) {
[08:29:20.074]                         if (!is.null(pattern)) {
[08:29:20.074]                           computeRestarts <- base::computeRestarts
[08:29:20.074]                           grepl <- base::grepl
[08:29:20.074]                           restarts <- computeRestarts(cond)
[08:29:20.074]                           for (restart in restarts) {
[08:29:20.074]                             name <- restart$name
[08:29:20.074]                             if (is.null(name)) 
[08:29:20.074]                               next
[08:29:20.074]                             if (!grepl(pattern, name)) 
[08:29:20.074]                               next
[08:29:20.074]                             invokeRestart(restart)
[08:29:20.074]                             muffled <- TRUE
[08:29:20.074]                             break
[08:29:20.074]                           }
[08:29:20.074]                         }
[08:29:20.074]                       }
[08:29:20.074]                       invisible(muffled)
[08:29:20.074]                     }
[08:29:20.074]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.074]                   }
[08:29:20.074]                 }
[08:29:20.074]                 else {
[08:29:20.074]                   if (TRUE) {
[08:29:20.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.074]                     {
[08:29:20.074]                       inherits <- base::inherits
[08:29:20.074]                       invokeRestart <- base::invokeRestart
[08:29:20.074]                       is.null <- base::is.null
[08:29:20.074]                       muffled <- FALSE
[08:29:20.074]                       if (inherits(cond, "message")) {
[08:29:20.074]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.074]                         if (muffled) 
[08:29:20.074]                           invokeRestart("muffleMessage")
[08:29:20.074]                       }
[08:29:20.074]                       else if (inherits(cond, "warning")) {
[08:29:20.074]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.074]                         if (muffled) 
[08:29:20.074]                           invokeRestart("muffleWarning")
[08:29:20.074]                       }
[08:29:20.074]                       else if (inherits(cond, "condition")) {
[08:29:20.074]                         if (!is.null(pattern)) {
[08:29:20.074]                           computeRestarts <- base::computeRestarts
[08:29:20.074]                           grepl <- base::grepl
[08:29:20.074]                           restarts <- computeRestarts(cond)
[08:29:20.074]                           for (restart in restarts) {
[08:29:20.074]                             name <- restart$name
[08:29:20.074]                             if (is.null(name)) 
[08:29:20.074]                               next
[08:29:20.074]                             if (!grepl(pattern, name)) 
[08:29:20.074]                               next
[08:29:20.074]                             invokeRestart(restart)
[08:29:20.074]                             muffled <- TRUE
[08:29:20.074]                             break
[08:29:20.074]                           }
[08:29:20.074]                         }
[08:29:20.074]                       }
[08:29:20.074]                       invisible(muffled)
[08:29:20.074]                     }
[08:29:20.074]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.074]                   }
[08:29:20.074]                 }
[08:29:20.074]             }
[08:29:20.074]         }))
[08:29:20.074]     }, error = function(ex) {
[08:29:20.074]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.074]                 ...future.rng), started = ...future.startTime, 
[08:29:20.074]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.074]             version = "1.8"), class = "FutureResult")
[08:29:20.074]     }, finally = {
[08:29:20.074]         if (!identical(...future.workdir, getwd())) 
[08:29:20.074]             setwd(...future.workdir)
[08:29:20.074]         {
[08:29:20.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.074]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.074]             }
[08:29:20.074]             base::options(...future.oldOptions)
[08:29:20.074]             if (.Platform$OS.type == "windows") {
[08:29:20.074]                 old_names <- names(...future.oldEnvVars)
[08:29:20.074]                 envs <- base::Sys.getenv()
[08:29:20.074]                 names <- names(envs)
[08:29:20.074]                 common <- intersect(names, old_names)
[08:29:20.074]                 added <- setdiff(names, old_names)
[08:29:20.074]                 removed <- setdiff(old_names, names)
[08:29:20.074]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.074]                   envs[common]]
[08:29:20.074]                 NAMES <- toupper(changed)
[08:29:20.074]                 args <- list()
[08:29:20.074]                 for (kk in seq_along(NAMES)) {
[08:29:20.074]                   name <- changed[[kk]]
[08:29:20.074]                   NAME <- NAMES[[kk]]
[08:29:20.074]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.074]                     next
[08:29:20.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.074]                 }
[08:29:20.074]                 NAMES <- toupper(added)
[08:29:20.074]                 for (kk in seq_along(NAMES)) {
[08:29:20.074]                   name <- added[[kk]]
[08:29:20.074]                   NAME <- NAMES[[kk]]
[08:29:20.074]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.074]                     next
[08:29:20.074]                   args[[name]] <- ""
[08:29:20.074]                 }
[08:29:20.074]                 NAMES <- toupper(removed)
[08:29:20.074]                 for (kk in seq_along(NAMES)) {
[08:29:20.074]                   name <- removed[[kk]]
[08:29:20.074]                   NAME <- NAMES[[kk]]
[08:29:20.074]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.074]                     next
[08:29:20.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.074]                 }
[08:29:20.074]                 if (length(args) > 0) 
[08:29:20.074]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.074]             }
[08:29:20.074]             else {
[08:29:20.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.074]             }
[08:29:20.074]             {
[08:29:20.074]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.074]                   0L) {
[08:29:20.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.074]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.074]                   base::options(opts)
[08:29:20.074]                 }
[08:29:20.074]                 {
[08:29:20.074]                   {
[08:29:20.074]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.074]                     NULL
[08:29:20.074]                   }
[08:29:20.074]                   options(future.plan = NULL)
[08:29:20.074]                   if (is.na(NA_character_)) 
[08:29:20.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.074]                     .init = FALSE)
[08:29:20.074]                 }
[08:29:20.074]             }
[08:29:20.074]         }
[08:29:20.074]     })
[08:29:20.074]     if (TRUE) {
[08:29:20.074]         base::sink(type = "output", split = FALSE)
[08:29:20.074]         if (TRUE) {
[08:29:20.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.074]         }
[08:29:20.074]         else {
[08:29:20.074]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.074]         }
[08:29:20.074]         base::close(...future.stdout)
[08:29:20.074]         ...future.stdout <- NULL
[08:29:20.074]     }
[08:29:20.074]     ...future.result$conditions <- ...future.conditions
[08:29:20.074]     ...future.result$finished <- base::Sys.time()
[08:29:20.074]     ...future.result
[08:29:20.074] }
[08:29:20.077] MultisessionFuture started
[08:29:20.078] - Launch lazy future ... done
[08:29:20.078] run() for ‘MultisessionFuture’ ... done
[08:29:20.078] getGlobalsAndPackages() ...
[08:29:20.078] Searching for globals...
[08:29:20.078] 
[08:29:20.078] Searching for globals ... DONE
[08:29:20.078] - globals: [0] <none>
[08:29:20.079] getGlobalsAndPackages() ... DONE
[08:29:20.079] run() for ‘Future’ ...
[08:29:20.079] - state: ‘created’
[08:29:20.079] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.093] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.093]   - Field: ‘node’
[08:29:20.093]   - Field: ‘label’
[08:29:20.093]   - Field: ‘local’
[08:29:20.093]   - Field: ‘owner’
[08:29:20.093]   - Field: ‘envir’
[08:29:20.093]   - Field: ‘workers’
[08:29:20.093]   - Field: ‘packages’
[08:29:20.093]   - Field: ‘gc’
[08:29:20.094]   - Field: ‘conditions’
[08:29:20.094]   - Field: ‘persistent’
[08:29:20.094]   - Field: ‘expr’
[08:29:20.094]   - Field: ‘uuid’
[08:29:20.094]   - Field: ‘seed’
[08:29:20.094]   - Field: ‘version’
[08:29:20.094]   - Field: ‘result’
[08:29:20.094]   - Field: ‘asynchronous’
[08:29:20.094]   - Field: ‘calls’
[08:29:20.094]   - Field: ‘globals’
[08:29:20.094]   - Field: ‘stdout’
[08:29:20.094]   - Field: ‘earlySignal’
[08:29:20.095]   - Field: ‘lazy’
[08:29:20.095]   - Field: ‘state’
[08:29:20.095] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.095] - Launch lazy future ...
[08:29:20.095] Packages needed by the future expression (n = 0): <none>
[08:29:20.095] Packages needed by future strategies (n = 0): <none>
[08:29:20.096] {
[08:29:20.096]     {
[08:29:20.096]         {
[08:29:20.096]             ...future.startTime <- base::Sys.time()
[08:29:20.096]             {
[08:29:20.096]                 {
[08:29:20.096]                   {
[08:29:20.096]                     {
[08:29:20.096]                       base::local({
[08:29:20.096]                         has_future <- base::requireNamespace("future", 
[08:29:20.096]                           quietly = TRUE)
[08:29:20.096]                         if (has_future) {
[08:29:20.096]                           ns <- base::getNamespace("future")
[08:29:20.096]                           version <- ns[[".package"]][["version"]]
[08:29:20.096]                           if (is.null(version)) 
[08:29:20.096]                             version <- utils::packageVersion("future")
[08:29:20.096]                         }
[08:29:20.096]                         else {
[08:29:20.096]                           version <- NULL
[08:29:20.096]                         }
[08:29:20.096]                         if (!has_future || version < "1.8.0") {
[08:29:20.096]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.096]                             "", base::R.version$version.string), 
[08:29:20.096]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.096]                               "release", "version")], collapse = " "), 
[08:29:20.096]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.096]                             info)
[08:29:20.096]                           info <- base::paste(info, collapse = "; ")
[08:29:20.096]                           if (!has_future) {
[08:29:20.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.096]                               info)
[08:29:20.096]                           }
[08:29:20.096]                           else {
[08:29:20.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.096]                               info, version)
[08:29:20.096]                           }
[08:29:20.096]                           base::stop(msg)
[08:29:20.096]                         }
[08:29:20.096]                       })
[08:29:20.096]                     }
[08:29:20.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.096]                     base::options(mc.cores = 1L)
[08:29:20.096]                   }
[08:29:20.096]                   ...future.strategy.old <- future::plan("list")
[08:29:20.096]                   options(future.plan = NULL)
[08:29:20.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.096]                 }
[08:29:20.096]                 ...future.workdir <- getwd()
[08:29:20.096]             }
[08:29:20.096]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.096]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.096]         }
[08:29:20.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.096]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.096]             base::names(...future.oldOptions))
[08:29:20.096]     }
[08:29:20.096]     if (FALSE) {
[08:29:20.096]     }
[08:29:20.096]     else {
[08:29:20.096]         if (TRUE) {
[08:29:20.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.096]                 open = "w")
[08:29:20.096]         }
[08:29:20.096]         else {
[08:29:20.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.096]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.096]         }
[08:29:20.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.096]             base::sink(type = "output", split = FALSE)
[08:29:20.096]             base::close(...future.stdout)
[08:29:20.096]         }, add = TRUE)
[08:29:20.096]     }
[08:29:20.096]     ...future.frame <- base::sys.nframe()
[08:29:20.096]     ...future.conditions <- base::list()
[08:29:20.096]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.096]     if (FALSE) {
[08:29:20.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.096]     }
[08:29:20.096]     ...future.result <- base::tryCatch({
[08:29:20.096]         base::withCallingHandlers({
[08:29:20.096]             ...future.value <- base::withVisible(base::local({
[08:29:20.096]                 ...future.makeSendCondition <- base::local({
[08:29:20.096]                   sendCondition <- NULL
[08:29:20.096]                   function(frame = 1L) {
[08:29:20.096]                     if (is.function(sendCondition)) 
[08:29:20.096]                       return(sendCondition)
[08:29:20.096]                     ns <- getNamespace("parallel")
[08:29:20.096]                     if (exists("sendData", mode = "function", 
[08:29:20.096]                       envir = ns)) {
[08:29:20.096]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.096]                         envir = ns)
[08:29:20.096]                       envir <- sys.frame(frame)
[08:29:20.096]                       master <- NULL
[08:29:20.096]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.096]                         !identical(envir, emptyenv())) {
[08:29:20.096]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.096]                           inherits = FALSE)) {
[08:29:20.096]                           master <- get("master", mode = "list", 
[08:29:20.096]                             envir = envir, inherits = FALSE)
[08:29:20.096]                           if (inherits(master, c("SOCKnode", 
[08:29:20.096]                             "SOCK0node"))) {
[08:29:20.096]                             sendCondition <<- function(cond) {
[08:29:20.096]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.096]                                 success = TRUE)
[08:29:20.096]                               parallel_sendData(master, data)
[08:29:20.096]                             }
[08:29:20.096]                             return(sendCondition)
[08:29:20.096]                           }
[08:29:20.096]                         }
[08:29:20.096]                         frame <- frame + 1L
[08:29:20.096]                         envir <- sys.frame(frame)
[08:29:20.096]                       }
[08:29:20.096]                     }
[08:29:20.096]                     sendCondition <<- function(cond) NULL
[08:29:20.096]                   }
[08:29:20.096]                 })
[08:29:20.096]                 withCallingHandlers({
[08:29:20.096]                   2
[08:29:20.096]                 }, immediateCondition = function(cond) {
[08:29:20.096]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.096]                   sendCondition(cond)
[08:29:20.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.096]                   {
[08:29:20.096]                     inherits <- base::inherits
[08:29:20.096]                     invokeRestart <- base::invokeRestart
[08:29:20.096]                     is.null <- base::is.null
[08:29:20.096]                     muffled <- FALSE
[08:29:20.096]                     if (inherits(cond, "message")) {
[08:29:20.096]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.096]                       if (muffled) 
[08:29:20.096]                         invokeRestart("muffleMessage")
[08:29:20.096]                     }
[08:29:20.096]                     else if (inherits(cond, "warning")) {
[08:29:20.096]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.096]                       if (muffled) 
[08:29:20.096]                         invokeRestart("muffleWarning")
[08:29:20.096]                     }
[08:29:20.096]                     else if (inherits(cond, "condition")) {
[08:29:20.096]                       if (!is.null(pattern)) {
[08:29:20.096]                         computeRestarts <- base::computeRestarts
[08:29:20.096]                         grepl <- base::grepl
[08:29:20.096]                         restarts <- computeRestarts(cond)
[08:29:20.096]                         for (restart in restarts) {
[08:29:20.096]                           name <- restart$name
[08:29:20.096]                           if (is.null(name)) 
[08:29:20.096]                             next
[08:29:20.096]                           if (!grepl(pattern, name)) 
[08:29:20.096]                             next
[08:29:20.096]                           invokeRestart(restart)
[08:29:20.096]                           muffled <- TRUE
[08:29:20.096]                           break
[08:29:20.096]                         }
[08:29:20.096]                       }
[08:29:20.096]                     }
[08:29:20.096]                     invisible(muffled)
[08:29:20.096]                   }
[08:29:20.096]                   muffleCondition(cond)
[08:29:20.096]                 })
[08:29:20.096]             }))
[08:29:20.096]             future::FutureResult(value = ...future.value$value, 
[08:29:20.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.096]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.096]                     ...future.globalenv.names))
[08:29:20.096]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.096]         }, condition = base::local({
[08:29:20.096]             c <- base::c
[08:29:20.096]             inherits <- base::inherits
[08:29:20.096]             invokeRestart <- base::invokeRestart
[08:29:20.096]             length <- base::length
[08:29:20.096]             list <- base::list
[08:29:20.096]             seq.int <- base::seq.int
[08:29:20.096]             signalCondition <- base::signalCondition
[08:29:20.096]             sys.calls <- base::sys.calls
[08:29:20.096]             `[[` <- base::`[[`
[08:29:20.096]             `+` <- base::`+`
[08:29:20.096]             `<<-` <- base::`<<-`
[08:29:20.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.096]                   3L)]
[08:29:20.096]             }
[08:29:20.096]             function(cond) {
[08:29:20.096]                 is_error <- inherits(cond, "error")
[08:29:20.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.096]                   NULL)
[08:29:20.096]                 if (is_error) {
[08:29:20.096]                   sessionInformation <- function() {
[08:29:20.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.096]                       search = base::search(), system = base::Sys.info())
[08:29:20.096]                   }
[08:29:20.096]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.096]                     cond$call), session = sessionInformation(), 
[08:29:20.096]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.096]                   signalCondition(cond)
[08:29:20.096]                 }
[08:29:20.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.096]                 "immediateCondition"))) {
[08:29:20.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.096]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.096]                   if (TRUE && !signal) {
[08:29:20.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.096]                     {
[08:29:20.096]                       inherits <- base::inherits
[08:29:20.096]                       invokeRestart <- base::invokeRestart
[08:29:20.096]                       is.null <- base::is.null
[08:29:20.096]                       muffled <- FALSE
[08:29:20.096]                       if (inherits(cond, "message")) {
[08:29:20.096]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.096]                         if (muffled) 
[08:29:20.096]                           invokeRestart("muffleMessage")
[08:29:20.096]                       }
[08:29:20.096]                       else if (inherits(cond, "warning")) {
[08:29:20.096]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.096]                         if (muffled) 
[08:29:20.096]                           invokeRestart("muffleWarning")
[08:29:20.096]                       }
[08:29:20.096]                       else if (inherits(cond, "condition")) {
[08:29:20.096]                         if (!is.null(pattern)) {
[08:29:20.096]                           computeRestarts <- base::computeRestarts
[08:29:20.096]                           grepl <- base::grepl
[08:29:20.096]                           restarts <- computeRestarts(cond)
[08:29:20.096]                           for (restart in restarts) {
[08:29:20.096]                             name <- restart$name
[08:29:20.096]                             if (is.null(name)) 
[08:29:20.096]                               next
[08:29:20.096]                             if (!grepl(pattern, name)) 
[08:29:20.096]                               next
[08:29:20.096]                             invokeRestart(restart)
[08:29:20.096]                             muffled <- TRUE
[08:29:20.096]                             break
[08:29:20.096]                           }
[08:29:20.096]                         }
[08:29:20.096]                       }
[08:29:20.096]                       invisible(muffled)
[08:29:20.096]                     }
[08:29:20.096]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.096]                   }
[08:29:20.096]                 }
[08:29:20.096]                 else {
[08:29:20.096]                   if (TRUE) {
[08:29:20.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.096]                     {
[08:29:20.096]                       inherits <- base::inherits
[08:29:20.096]                       invokeRestart <- base::invokeRestart
[08:29:20.096]                       is.null <- base::is.null
[08:29:20.096]                       muffled <- FALSE
[08:29:20.096]                       if (inherits(cond, "message")) {
[08:29:20.096]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.096]                         if (muffled) 
[08:29:20.096]                           invokeRestart("muffleMessage")
[08:29:20.096]                       }
[08:29:20.096]                       else if (inherits(cond, "warning")) {
[08:29:20.096]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.096]                         if (muffled) 
[08:29:20.096]                           invokeRestart("muffleWarning")
[08:29:20.096]                       }
[08:29:20.096]                       else if (inherits(cond, "condition")) {
[08:29:20.096]                         if (!is.null(pattern)) {
[08:29:20.096]                           computeRestarts <- base::computeRestarts
[08:29:20.096]                           grepl <- base::grepl
[08:29:20.096]                           restarts <- computeRestarts(cond)
[08:29:20.096]                           for (restart in restarts) {
[08:29:20.096]                             name <- restart$name
[08:29:20.096]                             if (is.null(name)) 
[08:29:20.096]                               next
[08:29:20.096]                             if (!grepl(pattern, name)) 
[08:29:20.096]                               next
[08:29:20.096]                             invokeRestart(restart)
[08:29:20.096]                             muffled <- TRUE
[08:29:20.096]                             break
[08:29:20.096]                           }
[08:29:20.096]                         }
[08:29:20.096]                       }
[08:29:20.096]                       invisible(muffled)
[08:29:20.096]                     }
[08:29:20.096]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.096]                   }
[08:29:20.096]                 }
[08:29:20.096]             }
[08:29:20.096]         }))
[08:29:20.096]     }, error = function(ex) {
[08:29:20.096]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.096]                 ...future.rng), started = ...future.startTime, 
[08:29:20.096]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.096]             version = "1.8"), class = "FutureResult")
[08:29:20.096]     }, finally = {
[08:29:20.096]         if (!identical(...future.workdir, getwd())) 
[08:29:20.096]             setwd(...future.workdir)
[08:29:20.096]         {
[08:29:20.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.096]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.096]             }
[08:29:20.096]             base::options(...future.oldOptions)
[08:29:20.096]             if (.Platform$OS.type == "windows") {
[08:29:20.096]                 old_names <- names(...future.oldEnvVars)
[08:29:20.096]                 envs <- base::Sys.getenv()
[08:29:20.096]                 names <- names(envs)
[08:29:20.096]                 common <- intersect(names, old_names)
[08:29:20.096]                 added <- setdiff(names, old_names)
[08:29:20.096]                 removed <- setdiff(old_names, names)
[08:29:20.096]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.096]                   envs[common]]
[08:29:20.096]                 NAMES <- toupper(changed)
[08:29:20.096]                 args <- list()
[08:29:20.096]                 for (kk in seq_along(NAMES)) {
[08:29:20.096]                   name <- changed[[kk]]
[08:29:20.096]                   NAME <- NAMES[[kk]]
[08:29:20.096]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.096]                     next
[08:29:20.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.096]                 }
[08:29:20.096]                 NAMES <- toupper(added)
[08:29:20.096]                 for (kk in seq_along(NAMES)) {
[08:29:20.096]                   name <- added[[kk]]
[08:29:20.096]                   NAME <- NAMES[[kk]]
[08:29:20.096]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.096]                     next
[08:29:20.096]                   args[[name]] <- ""
[08:29:20.096]                 }
[08:29:20.096]                 NAMES <- toupper(removed)
[08:29:20.096]                 for (kk in seq_along(NAMES)) {
[08:29:20.096]                   name <- removed[[kk]]
[08:29:20.096]                   NAME <- NAMES[[kk]]
[08:29:20.096]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.096]                     next
[08:29:20.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.096]                 }
[08:29:20.096]                 if (length(args) > 0) 
[08:29:20.096]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.096]             }
[08:29:20.096]             else {
[08:29:20.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.096]             }
[08:29:20.096]             {
[08:29:20.096]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.096]                   0L) {
[08:29:20.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.096]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.096]                   base::options(opts)
[08:29:20.096]                 }
[08:29:20.096]                 {
[08:29:20.096]                   {
[08:29:20.096]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.096]                     NULL
[08:29:20.096]                   }
[08:29:20.096]                   options(future.plan = NULL)
[08:29:20.096]                   if (is.na(NA_character_)) 
[08:29:20.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.096]                     .init = FALSE)
[08:29:20.096]                 }
[08:29:20.096]             }
[08:29:20.096]         }
[08:29:20.096]     })
[08:29:20.096]     if (TRUE) {
[08:29:20.096]         base::sink(type = "output", split = FALSE)
[08:29:20.096]         if (TRUE) {
[08:29:20.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.096]         }
[08:29:20.096]         else {
[08:29:20.096]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.096]         }
[08:29:20.096]         base::close(...future.stdout)
[08:29:20.096]         ...future.stdout <- NULL
[08:29:20.096]     }
[08:29:20.096]     ...future.result$conditions <- ...future.conditions
[08:29:20.096]     ...future.result$finished <- base::Sys.time()
[08:29:20.096]     ...future.result
[08:29:20.096] }
[08:29:20.098] Poll #1 (0): usedNodes() = 2, workers = 2
[08:29:20.108] receiveMessageFromWorker() for ClusterFuture ...
[08:29:20.109] - Validating connection of MultisessionFuture
[08:29:20.109] - received message: FutureResult
[08:29:20.109] - Received FutureResult
[08:29:20.109] - Erased future from FutureRegistry
[08:29:20.109] result() for ClusterFuture ...
[08:29:20.109] - result already collected: FutureResult
[08:29:20.109] result() for ClusterFuture ... done
[08:29:20.109] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:20.110] result() for ClusterFuture ...
[08:29:20.110] - result already collected: FutureResult
[08:29:20.110] result() for ClusterFuture ... done
[08:29:20.110] result() for ClusterFuture ...
[08:29:20.110] - result already collected: FutureResult
[08:29:20.110] result() for ClusterFuture ... done
[08:29:20.111] MultisessionFuture started
[08:29:20.111] - Launch lazy future ... done
[08:29:20.111] run() for ‘MultisessionFuture’ ... done
[08:29:20.111] resolve() on list ...
[08:29:20.111]  recursive: 0
[08:29:20.111]  length: 3
[08:29:20.112]  elements: ‘a’, ‘b’, ‘’
[08:29:20.120] receiveMessageFromWorker() for ClusterFuture ...
[08:29:20.120] - Validating connection of MultisessionFuture
[08:29:20.120] - received message: FutureResult
[08:29:20.120] - Received FutureResult
[08:29:20.120] - Erased future from FutureRegistry
[08:29:20.121] result() for ClusterFuture ...
[08:29:20.121] - result already collected: FutureResult
[08:29:20.121] result() for ClusterFuture ... done
[08:29:20.121] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:20.121] Future #1
[08:29:20.121]  length: 2 (resolved future 1)
[08:29:20.131]  length: 1 (resolved future 3)
[08:29:20.163] receiveMessageFromWorker() for ClusterFuture ...
[08:29:20.163] - Validating connection of MultisessionFuture
[08:29:20.163] - received message: FutureResult
[08:29:20.163] - Received FutureResult
[08:29:20.163] - Erased future from FutureRegistry
[08:29:20.163] result() for ClusterFuture ...
[08:29:20.163] - result already collected: FutureResult
[08:29:20.164] result() for ClusterFuture ... done
[08:29:20.164] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:20.164] Future #2
[08:29:20.164]  length: 0 (resolved future 2)
[08:29:20.164] resolve() on list ... DONE
[08:29:20.164] getGlobalsAndPackages() ...
[08:29:20.164] Searching for globals...
[08:29:20.164] 
[08:29:20.165] Searching for globals ... DONE
[08:29:20.165] - globals: [0] <none>
[08:29:20.165] getGlobalsAndPackages() ... DONE
[08:29:20.165] getGlobalsAndPackages() ...
[08:29:20.165] Searching for globals...
[08:29:20.165] 
[08:29:20.165] Searching for globals ... DONE
[08:29:20.166] - globals: [0] <none>
[08:29:20.166] getGlobalsAndPackages() ... DONE
[08:29:20.166] run() for ‘Future’ ...
[08:29:20.166] - state: ‘created’
[08:29:20.166] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.180] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.180]   - Field: ‘node’
[08:29:20.180]   - Field: ‘label’
[08:29:20.181]   - Field: ‘local’
[08:29:20.181]   - Field: ‘owner’
[08:29:20.181]   - Field: ‘envir’
[08:29:20.181]   - Field: ‘workers’
[08:29:20.181]   - Field: ‘packages’
[08:29:20.181]   - Field: ‘gc’
[08:29:20.181]   - Field: ‘conditions’
[08:29:20.181]   - Field: ‘persistent’
[08:29:20.181]   - Field: ‘expr’
[08:29:20.181]   - Field: ‘uuid’
[08:29:20.181]   - Field: ‘seed’
[08:29:20.182]   - Field: ‘version’
[08:29:20.182]   - Field: ‘result’
[08:29:20.182]   - Field: ‘asynchronous’
[08:29:20.182]   - Field: ‘calls’
[08:29:20.182]   - Field: ‘globals’
[08:29:20.182]   - Field: ‘stdout’
[08:29:20.182]   - Field: ‘earlySignal’
[08:29:20.182]   - Field: ‘lazy’
[08:29:20.182]   - Field: ‘state’
[08:29:20.182] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.182] - Launch lazy future ...
[08:29:20.183] Packages needed by the future expression (n = 0): <none>
[08:29:20.183] Packages needed by future strategies (n = 0): <none>
[08:29:20.183] {
[08:29:20.183]     {
[08:29:20.183]         {
[08:29:20.183]             ...future.startTime <- base::Sys.time()
[08:29:20.183]             {
[08:29:20.183]                 {
[08:29:20.183]                   {
[08:29:20.183]                     {
[08:29:20.183]                       base::local({
[08:29:20.183]                         has_future <- base::requireNamespace("future", 
[08:29:20.183]                           quietly = TRUE)
[08:29:20.183]                         if (has_future) {
[08:29:20.183]                           ns <- base::getNamespace("future")
[08:29:20.183]                           version <- ns[[".package"]][["version"]]
[08:29:20.183]                           if (is.null(version)) 
[08:29:20.183]                             version <- utils::packageVersion("future")
[08:29:20.183]                         }
[08:29:20.183]                         else {
[08:29:20.183]                           version <- NULL
[08:29:20.183]                         }
[08:29:20.183]                         if (!has_future || version < "1.8.0") {
[08:29:20.183]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.183]                             "", base::R.version$version.string), 
[08:29:20.183]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.183]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.183]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.183]                               "release", "version")], collapse = " "), 
[08:29:20.183]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.183]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.183]                             info)
[08:29:20.183]                           info <- base::paste(info, collapse = "; ")
[08:29:20.183]                           if (!has_future) {
[08:29:20.183]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.183]                               info)
[08:29:20.183]                           }
[08:29:20.183]                           else {
[08:29:20.183]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.183]                               info, version)
[08:29:20.183]                           }
[08:29:20.183]                           base::stop(msg)
[08:29:20.183]                         }
[08:29:20.183]                       })
[08:29:20.183]                     }
[08:29:20.183]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.183]                     base::options(mc.cores = 1L)
[08:29:20.183]                   }
[08:29:20.183]                   ...future.strategy.old <- future::plan("list")
[08:29:20.183]                   options(future.plan = NULL)
[08:29:20.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.183]                 }
[08:29:20.183]                 ...future.workdir <- getwd()
[08:29:20.183]             }
[08:29:20.183]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.183]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.183]         }
[08:29:20.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.183]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.183]             base::names(...future.oldOptions))
[08:29:20.183]     }
[08:29:20.183]     if (FALSE) {
[08:29:20.183]     }
[08:29:20.183]     else {
[08:29:20.183]         if (TRUE) {
[08:29:20.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.183]                 open = "w")
[08:29:20.183]         }
[08:29:20.183]         else {
[08:29:20.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.183]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.183]         }
[08:29:20.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.183]             base::sink(type = "output", split = FALSE)
[08:29:20.183]             base::close(...future.stdout)
[08:29:20.183]         }, add = TRUE)
[08:29:20.183]     }
[08:29:20.183]     ...future.frame <- base::sys.nframe()
[08:29:20.183]     ...future.conditions <- base::list()
[08:29:20.183]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.183]     if (FALSE) {
[08:29:20.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.183]     }
[08:29:20.183]     ...future.result <- base::tryCatch({
[08:29:20.183]         base::withCallingHandlers({
[08:29:20.183]             ...future.value <- base::withVisible(base::local({
[08:29:20.183]                 ...future.makeSendCondition <- base::local({
[08:29:20.183]                   sendCondition <- NULL
[08:29:20.183]                   function(frame = 1L) {
[08:29:20.183]                     if (is.function(sendCondition)) 
[08:29:20.183]                       return(sendCondition)
[08:29:20.183]                     ns <- getNamespace("parallel")
[08:29:20.183]                     if (exists("sendData", mode = "function", 
[08:29:20.183]                       envir = ns)) {
[08:29:20.183]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.183]                         envir = ns)
[08:29:20.183]                       envir <- sys.frame(frame)
[08:29:20.183]                       master <- NULL
[08:29:20.183]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.183]                         !identical(envir, emptyenv())) {
[08:29:20.183]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.183]                           inherits = FALSE)) {
[08:29:20.183]                           master <- get("master", mode = "list", 
[08:29:20.183]                             envir = envir, inherits = FALSE)
[08:29:20.183]                           if (inherits(master, c("SOCKnode", 
[08:29:20.183]                             "SOCK0node"))) {
[08:29:20.183]                             sendCondition <<- function(cond) {
[08:29:20.183]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.183]                                 success = TRUE)
[08:29:20.183]                               parallel_sendData(master, data)
[08:29:20.183]                             }
[08:29:20.183]                             return(sendCondition)
[08:29:20.183]                           }
[08:29:20.183]                         }
[08:29:20.183]                         frame <- frame + 1L
[08:29:20.183]                         envir <- sys.frame(frame)
[08:29:20.183]                       }
[08:29:20.183]                     }
[08:29:20.183]                     sendCondition <<- function(cond) NULL
[08:29:20.183]                   }
[08:29:20.183]                 })
[08:29:20.183]                 withCallingHandlers({
[08:29:20.183]                   2
[08:29:20.183]                 }, immediateCondition = function(cond) {
[08:29:20.183]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.183]                   sendCondition(cond)
[08:29:20.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.183]                   {
[08:29:20.183]                     inherits <- base::inherits
[08:29:20.183]                     invokeRestart <- base::invokeRestart
[08:29:20.183]                     is.null <- base::is.null
[08:29:20.183]                     muffled <- FALSE
[08:29:20.183]                     if (inherits(cond, "message")) {
[08:29:20.183]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.183]                       if (muffled) 
[08:29:20.183]                         invokeRestart("muffleMessage")
[08:29:20.183]                     }
[08:29:20.183]                     else if (inherits(cond, "warning")) {
[08:29:20.183]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.183]                       if (muffled) 
[08:29:20.183]                         invokeRestart("muffleWarning")
[08:29:20.183]                     }
[08:29:20.183]                     else if (inherits(cond, "condition")) {
[08:29:20.183]                       if (!is.null(pattern)) {
[08:29:20.183]                         computeRestarts <- base::computeRestarts
[08:29:20.183]                         grepl <- base::grepl
[08:29:20.183]                         restarts <- computeRestarts(cond)
[08:29:20.183]                         for (restart in restarts) {
[08:29:20.183]                           name <- restart$name
[08:29:20.183]                           if (is.null(name)) 
[08:29:20.183]                             next
[08:29:20.183]                           if (!grepl(pattern, name)) 
[08:29:20.183]                             next
[08:29:20.183]                           invokeRestart(restart)
[08:29:20.183]                           muffled <- TRUE
[08:29:20.183]                           break
[08:29:20.183]                         }
[08:29:20.183]                       }
[08:29:20.183]                     }
[08:29:20.183]                     invisible(muffled)
[08:29:20.183]                   }
[08:29:20.183]                   muffleCondition(cond)
[08:29:20.183]                 })
[08:29:20.183]             }))
[08:29:20.183]             future::FutureResult(value = ...future.value$value, 
[08:29:20.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.183]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.183]                     ...future.globalenv.names))
[08:29:20.183]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.183]         }, condition = base::local({
[08:29:20.183]             c <- base::c
[08:29:20.183]             inherits <- base::inherits
[08:29:20.183]             invokeRestart <- base::invokeRestart
[08:29:20.183]             length <- base::length
[08:29:20.183]             list <- base::list
[08:29:20.183]             seq.int <- base::seq.int
[08:29:20.183]             signalCondition <- base::signalCondition
[08:29:20.183]             sys.calls <- base::sys.calls
[08:29:20.183]             `[[` <- base::`[[`
[08:29:20.183]             `+` <- base::`+`
[08:29:20.183]             `<<-` <- base::`<<-`
[08:29:20.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.183]                   3L)]
[08:29:20.183]             }
[08:29:20.183]             function(cond) {
[08:29:20.183]                 is_error <- inherits(cond, "error")
[08:29:20.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.183]                   NULL)
[08:29:20.183]                 if (is_error) {
[08:29:20.183]                   sessionInformation <- function() {
[08:29:20.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.183]                       search = base::search(), system = base::Sys.info())
[08:29:20.183]                   }
[08:29:20.183]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.183]                     cond$call), session = sessionInformation(), 
[08:29:20.183]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.183]                   signalCondition(cond)
[08:29:20.183]                 }
[08:29:20.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.183]                 "immediateCondition"))) {
[08:29:20.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.183]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.183]                   if (TRUE && !signal) {
[08:29:20.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.183]                     {
[08:29:20.183]                       inherits <- base::inherits
[08:29:20.183]                       invokeRestart <- base::invokeRestart
[08:29:20.183]                       is.null <- base::is.null
[08:29:20.183]                       muffled <- FALSE
[08:29:20.183]                       if (inherits(cond, "message")) {
[08:29:20.183]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.183]                         if (muffled) 
[08:29:20.183]                           invokeRestart("muffleMessage")
[08:29:20.183]                       }
[08:29:20.183]                       else if (inherits(cond, "warning")) {
[08:29:20.183]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.183]                         if (muffled) 
[08:29:20.183]                           invokeRestart("muffleWarning")
[08:29:20.183]                       }
[08:29:20.183]                       else if (inherits(cond, "condition")) {
[08:29:20.183]                         if (!is.null(pattern)) {
[08:29:20.183]                           computeRestarts <- base::computeRestarts
[08:29:20.183]                           grepl <- base::grepl
[08:29:20.183]                           restarts <- computeRestarts(cond)
[08:29:20.183]                           for (restart in restarts) {
[08:29:20.183]                             name <- restart$name
[08:29:20.183]                             if (is.null(name)) 
[08:29:20.183]                               next
[08:29:20.183]                             if (!grepl(pattern, name)) 
[08:29:20.183]                               next
[08:29:20.183]                             invokeRestart(restart)
[08:29:20.183]                             muffled <- TRUE
[08:29:20.183]                             break
[08:29:20.183]                           }
[08:29:20.183]                         }
[08:29:20.183]                       }
[08:29:20.183]                       invisible(muffled)
[08:29:20.183]                     }
[08:29:20.183]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.183]                   }
[08:29:20.183]                 }
[08:29:20.183]                 else {
[08:29:20.183]                   if (TRUE) {
[08:29:20.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.183]                     {
[08:29:20.183]                       inherits <- base::inherits
[08:29:20.183]                       invokeRestart <- base::invokeRestart
[08:29:20.183]                       is.null <- base::is.null
[08:29:20.183]                       muffled <- FALSE
[08:29:20.183]                       if (inherits(cond, "message")) {
[08:29:20.183]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.183]                         if (muffled) 
[08:29:20.183]                           invokeRestart("muffleMessage")
[08:29:20.183]                       }
[08:29:20.183]                       else if (inherits(cond, "warning")) {
[08:29:20.183]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.183]                         if (muffled) 
[08:29:20.183]                           invokeRestart("muffleWarning")
[08:29:20.183]                       }
[08:29:20.183]                       else if (inherits(cond, "condition")) {
[08:29:20.183]                         if (!is.null(pattern)) {
[08:29:20.183]                           computeRestarts <- base::computeRestarts
[08:29:20.183]                           grepl <- base::grepl
[08:29:20.183]                           restarts <- computeRestarts(cond)
[08:29:20.183]                           for (restart in restarts) {
[08:29:20.183]                             name <- restart$name
[08:29:20.183]                             if (is.null(name)) 
[08:29:20.183]                               next
[08:29:20.183]                             if (!grepl(pattern, name)) 
[08:29:20.183]                               next
[08:29:20.183]                             invokeRestart(restart)
[08:29:20.183]                             muffled <- TRUE
[08:29:20.183]                             break
[08:29:20.183]                           }
[08:29:20.183]                         }
[08:29:20.183]                       }
[08:29:20.183]                       invisible(muffled)
[08:29:20.183]                     }
[08:29:20.183]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.183]                   }
[08:29:20.183]                 }
[08:29:20.183]             }
[08:29:20.183]         }))
[08:29:20.183]     }, error = function(ex) {
[08:29:20.183]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.183]                 ...future.rng), started = ...future.startTime, 
[08:29:20.183]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.183]             version = "1.8"), class = "FutureResult")
[08:29:20.183]     }, finally = {
[08:29:20.183]         if (!identical(...future.workdir, getwd())) 
[08:29:20.183]             setwd(...future.workdir)
[08:29:20.183]         {
[08:29:20.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.183]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.183]             }
[08:29:20.183]             base::options(...future.oldOptions)
[08:29:20.183]             if (.Platform$OS.type == "windows") {
[08:29:20.183]                 old_names <- names(...future.oldEnvVars)
[08:29:20.183]                 envs <- base::Sys.getenv()
[08:29:20.183]                 names <- names(envs)
[08:29:20.183]                 common <- intersect(names, old_names)
[08:29:20.183]                 added <- setdiff(names, old_names)
[08:29:20.183]                 removed <- setdiff(old_names, names)
[08:29:20.183]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.183]                   envs[common]]
[08:29:20.183]                 NAMES <- toupper(changed)
[08:29:20.183]                 args <- list()
[08:29:20.183]                 for (kk in seq_along(NAMES)) {
[08:29:20.183]                   name <- changed[[kk]]
[08:29:20.183]                   NAME <- NAMES[[kk]]
[08:29:20.183]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.183]                     next
[08:29:20.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.183]                 }
[08:29:20.183]                 NAMES <- toupper(added)
[08:29:20.183]                 for (kk in seq_along(NAMES)) {
[08:29:20.183]                   name <- added[[kk]]
[08:29:20.183]                   NAME <- NAMES[[kk]]
[08:29:20.183]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.183]                     next
[08:29:20.183]                   args[[name]] <- ""
[08:29:20.183]                 }
[08:29:20.183]                 NAMES <- toupper(removed)
[08:29:20.183]                 for (kk in seq_along(NAMES)) {
[08:29:20.183]                   name <- removed[[kk]]
[08:29:20.183]                   NAME <- NAMES[[kk]]
[08:29:20.183]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.183]                     next
[08:29:20.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.183]                 }
[08:29:20.183]                 if (length(args) > 0) 
[08:29:20.183]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.183]             }
[08:29:20.183]             else {
[08:29:20.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.183]             }
[08:29:20.183]             {
[08:29:20.183]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.183]                   0L) {
[08:29:20.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.183]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.183]                   base::options(opts)
[08:29:20.183]                 }
[08:29:20.183]                 {
[08:29:20.183]                   {
[08:29:20.183]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.183]                     NULL
[08:29:20.183]                   }
[08:29:20.183]                   options(future.plan = NULL)
[08:29:20.183]                   if (is.na(NA_character_)) 
[08:29:20.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.183]                     .init = FALSE)
[08:29:20.183]                 }
[08:29:20.183]             }
[08:29:20.183]         }
[08:29:20.183]     })
[08:29:20.183]     if (TRUE) {
[08:29:20.183]         base::sink(type = "output", split = FALSE)
[08:29:20.183]         if (TRUE) {
[08:29:20.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.183]         }
[08:29:20.183]         else {
[08:29:20.183]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.183]         }
[08:29:20.183]         base::close(...future.stdout)
[08:29:20.183]         ...future.stdout <- NULL
[08:29:20.183]     }
[08:29:20.183]     ...future.result$conditions <- ...future.conditions
[08:29:20.183]     ...future.result$finished <- base::Sys.time()
[08:29:20.183]     ...future.result
[08:29:20.183] }
[08:29:20.186] MultisessionFuture started
[08:29:20.186] - Launch lazy future ... done
[08:29:20.187] run() for ‘MultisessionFuture’ ... done
[08:29:20.187] resolve() on list ...
[08:29:20.187]  recursive: 0
[08:29:20.187]  length: 3
[08:29:20.187]  elements: ‘a’, ‘b’, ‘’
[08:29:20.187] run() for ‘Future’ ...
[08:29:20.187] - state: ‘created’
[08:29:20.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.205] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.205] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.205]   - Field: ‘node’
[08:29:20.205]   - Field: ‘label’
[08:29:20.205]   - Field: ‘local’
[08:29:20.205]   - Field: ‘owner’
[08:29:20.206]   - Field: ‘envir’
[08:29:20.206]   - Field: ‘workers’
[08:29:20.206]   - Field: ‘packages’
[08:29:20.206]   - Field: ‘gc’
[08:29:20.206]   - Field: ‘conditions’
[08:29:20.206]   - Field: ‘persistent’
[08:29:20.206]   - Field: ‘expr’
[08:29:20.206]   - Field: ‘uuid’
[08:29:20.206]   - Field: ‘seed’
[08:29:20.206]   - Field: ‘version’
[08:29:20.206]   - Field: ‘result’
[08:29:20.207]   - Field: ‘asynchronous’
[08:29:20.207]   - Field: ‘calls’
[08:29:20.207]   - Field: ‘globals’
[08:29:20.207]   - Field: ‘stdout’
[08:29:20.207]   - Field: ‘earlySignal’
[08:29:20.207]   - Field: ‘lazy’
[08:29:20.207]   - Field: ‘state’
[08:29:20.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.207] - Launch lazy future ...
[08:29:20.207] Packages needed by the future expression (n = 0): <none>
[08:29:20.208] Packages needed by future strategies (n = 0): <none>
[08:29:20.208] {
[08:29:20.208]     {
[08:29:20.208]         {
[08:29:20.208]             ...future.startTime <- base::Sys.time()
[08:29:20.208]             {
[08:29:20.208]                 {
[08:29:20.208]                   {
[08:29:20.208]                     {
[08:29:20.208]                       base::local({
[08:29:20.208]                         has_future <- base::requireNamespace("future", 
[08:29:20.208]                           quietly = TRUE)
[08:29:20.208]                         if (has_future) {
[08:29:20.208]                           ns <- base::getNamespace("future")
[08:29:20.208]                           version <- ns[[".package"]][["version"]]
[08:29:20.208]                           if (is.null(version)) 
[08:29:20.208]                             version <- utils::packageVersion("future")
[08:29:20.208]                         }
[08:29:20.208]                         else {
[08:29:20.208]                           version <- NULL
[08:29:20.208]                         }
[08:29:20.208]                         if (!has_future || version < "1.8.0") {
[08:29:20.208]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.208]                             "", base::R.version$version.string), 
[08:29:20.208]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.208]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.208]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.208]                               "release", "version")], collapse = " "), 
[08:29:20.208]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.208]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.208]                             info)
[08:29:20.208]                           info <- base::paste(info, collapse = "; ")
[08:29:20.208]                           if (!has_future) {
[08:29:20.208]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.208]                               info)
[08:29:20.208]                           }
[08:29:20.208]                           else {
[08:29:20.208]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.208]                               info, version)
[08:29:20.208]                           }
[08:29:20.208]                           base::stop(msg)
[08:29:20.208]                         }
[08:29:20.208]                       })
[08:29:20.208]                     }
[08:29:20.208]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.208]                     base::options(mc.cores = 1L)
[08:29:20.208]                   }
[08:29:20.208]                   ...future.strategy.old <- future::plan("list")
[08:29:20.208]                   options(future.plan = NULL)
[08:29:20.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.208]                 }
[08:29:20.208]                 ...future.workdir <- getwd()
[08:29:20.208]             }
[08:29:20.208]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.208]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.208]         }
[08:29:20.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.208]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.208]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.208]             base::names(...future.oldOptions))
[08:29:20.208]     }
[08:29:20.208]     if (FALSE) {
[08:29:20.208]     }
[08:29:20.208]     else {
[08:29:20.208]         if (TRUE) {
[08:29:20.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.208]                 open = "w")
[08:29:20.208]         }
[08:29:20.208]         else {
[08:29:20.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.208]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.208]         }
[08:29:20.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.208]             base::sink(type = "output", split = FALSE)
[08:29:20.208]             base::close(...future.stdout)
[08:29:20.208]         }, add = TRUE)
[08:29:20.208]     }
[08:29:20.208]     ...future.frame <- base::sys.nframe()
[08:29:20.208]     ...future.conditions <- base::list()
[08:29:20.208]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.208]     if (FALSE) {
[08:29:20.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.208]     }
[08:29:20.208]     ...future.result <- base::tryCatch({
[08:29:20.208]         base::withCallingHandlers({
[08:29:20.208]             ...future.value <- base::withVisible(base::local({
[08:29:20.208]                 ...future.makeSendCondition <- base::local({
[08:29:20.208]                   sendCondition <- NULL
[08:29:20.208]                   function(frame = 1L) {
[08:29:20.208]                     if (is.function(sendCondition)) 
[08:29:20.208]                       return(sendCondition)
[08:29:20.208]                     ns <- getNamespace("parallel")
[08:29:20.208]                     if (exists("sendData", mode = "function", 
[08:29:20.208]                       envir = ns)) {
[08:29:20.208]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.208]                         envir = ns)
[08:29:20.208]                       envir <- sys.frame(frame)
[08:29:20.208]                       master <- NULL
[08:29:20.208]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.208]                         !identical(envir, emptyenv())) {
[08:29:20.208]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.208]                           inherits = FALSE)) {
[08:29:20.208]                           master <- get("master", mode = "list", 
[08:29:20.208]                             envir = envir, inherits = FALSE)
[08:29:20.208]                           if (inherits(master, c("SOCKnode", 
[08:29:20.208]                             "SOCK0node"))) {
[08:29:20.208]                             sendCondition <<- function(cond) {
[08:29:20.208]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.208]                                 success = TRUE)
[08:29:20.208]                               parallel_sendData(master, data)
[08:29:20.208]                             }
[08:29:20.208]                             return(sendCondition)
[08:29:20.208]                           }
[08:29:20.208]                         }
[08:29:20.208]                         frame <- frame + 1L
[08:29:20.208]                         envir <- sys.frame(frame)
[08:29:20.208]                       }
[08:29:20.208]                     }
[08:29:20.208]                     sendCondition <<- function(cond) NULL
[08:29:20.208]                   }
[08:29:20.208]                 })
[08:29:20.208]                 withCallingHandlers({
[08:29:20.208]                   1
[08:29:20.208]                 }, immediateCondition = function(cond) {
[08:29:20.208]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.208]                   sendCondition(cond)
[08:29:20.208]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.208]                   {
[08:29:20.208]                     inherits <- base::inherits
[08:29:20.208]                     invokeRestart <- base::invokeRestart
[08:29:20.208]                     is.null <- base::is.null
[08:29:20.208]                     muffled <- FALSE
[08:29:20.208]                     if (inherits(cond, "message")) {
[08:29:20.208]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.208]                       if (muffled) 
[08:29:20.208]                         invokeRestart("muffleMessage")
[08:29:20.208]                     }
[08:29:20.208]                     else if (inherits(cond, "warning")) {
[08:29:20.208]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.208]                       if (muffled) 
[08:29:20.208]                         invokeRestart("muffleWarning")
[08:29:20.208]                     }
[08:29:20.208]                     else if (inherits(cond, "condition")) {
[08:29:20.208]                       if (!is.null(pattern)) {
[08:29:20.208]                         computeRestarts <- base::computeRestarts
[08:29:20.208]                         grepl <- base::grepl
[08:29:20.208]                         restarts <- computeRestarts(cond)
[08:29:20.208]                         for (restart in restarts) {
[08:29:20.208]                           name <- restart$name
[08:29:20.208]                           if (is.null(name)) 
[08:29:20.208]                             next
[08:29:20.208]                           if (!grepl(pattern, name)) 
[08:29:20.208]                             next
[08:29:20.208]                           invokeRestart(restart)
[08:29:20.208]                           muffled <- TRUE
[08:29:20.208]                           break
[08:29:20.208]                         }
[08:29:20.208]                       }
[08:29:20.208]                     }
[08:29:20.208]                     invisible(muffled)
[08:29:20.208]                   }
[08:29:20.208]                   muffleCondition(cond)
[08:29:20.208]                 })
[08:29:20.208]             }))
[08:29:20.208]             future::FutureResult(value = ...future.value$value, 
[08:29:20.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.208]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.208]                     ...future.globalenv.names))
[08:29:20.208]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.208]         }, condition = base::local({
[08:29:20.208]             c <- base::c
[08:29:20.208]             inherits <- base::inherits
[08:29:20.208]             invokeRestart <- base::invokeRestart
[08:29:20.208]             length <- base::length
[08:29:20.208]             list <- base::list
[08:29:20.208]             seq.int <- base::seq.int
[08:29:20.208]             signalCondition <- base::signalCondition
[08:29:20.208]             sys.calls <- base::sys.calls
[08:29:20.208]             `[[` <- base::`[[`
[08:29:20.208]             `+` <- base::`+`
[08:29:20.208]             `<<-` <- base::`<<-`
[08:29:20.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.208]                   3L)]
[08:29:20.208]             }
[08:29:20.208]             function(cond) {
[08:29:20.208]                 is_error <- inherits(cond, "error")
[08:29:20.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.208]                   NULL)
[08:29:20.208]                 if (is_error) {
[08:29:20.208]                   sessionInformation <- function() {
[08:29:20.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.208]                       search = base::search(), system = base::Sys.info())
[08:29:20.208]                   }
[08:29:20.208]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.208]                     cond$call), session = sessionInformation(), 
[08:29:20.208]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.208]                   signalCondition(cond)
[08:29:20.208]                 }
[08:29:20.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.208]                 "immediateCondition"))) {
[08:29:20.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.208]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.208]                   if (TRUE && !signal) {
[08:29:20.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.208]                     {
[08:29:20.208]                       inherits <- base::inherits
[08:29:20.208]                       invokeRestart <- base::invokeRestart
[08:29:20.208]                       is.null <- base::is.null
[08:29:20.208]                       muffled <- FALSE
[08:29:20.208]                       if (inherits(cond, "message")) {
[08:29:20.208]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.208]                         if (muffled) 
[08:29:20.208]                           invokeRestart("muffleMessage")
[08:29:20.208]                       }
[08:29:20.208]                       else if (inherits(cond, "warning")) {
[08:29:20.208]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.208]                         if (muffled) 
[08:29:20.208]                           invokeRestart("muffleWarning")
[08:29:20.208]                       }
[08:29:20.208]                       else if (inherits(cond, "condition")) {
[08:29:20.208]                         if (!is.null(pattern)) {
[08:29:20.208]                           computeRestarts <- base::computeRestarts
[08:29:20.208]                           grepl <- base::grepl
[08:29:20.208]                           restarts <- computeRestarts(cond)
[08:29:20.208]                           for (restart in restarts) {
[08:29:20.208]                             name <- restart$name
[08:29:20.208]                             if (is.null(name)) 
[08:29:20.208]                               next
[08:29:20.208]                             if (!grepl(pattern, name)) 
[08:29:20.208]                               next
[08:29:20.208]                             invokeRestart(restart)
[08:29:20.208]                             muffled <- TRUE
[08:29:20.208]                             break
[08:29:20.208]                           }
[08:29:20.208]                         }
[08:29:20.208]                       }
[08:29:20.208]                       invisible(muffled)
[08:29:20.208]                     }
[08:29:20.208]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.208]                   }
[08:29:20.208]                 }
[08:29:20.208]                 else {
[08:29:20.208]                   if (TRUE) {
[08:29:20.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.208]                     {
[08:29:20.208]                       inherits <- base::inherits
[08:29:20.208]                       invokeRestart <- base::invokeRestart
[08:29:20.208]                       is.null <- base::is.null
[08:29:20.208]                       muffled <- FALSE
[08:29:20.208]                       if (inherits(cond, "message")) {
[08:29:20.208]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.208]                         if (muffled) 
[08:29:20.208]                           invokeRestart("muffleMessage")
[08:29:20.208]                       }
[08:29:20.208]                       else if (inherits(cond, "warning")) {
[08:29:20.208]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.208]                         if (muffled) 
[08:29:20.208]                           invokeRestart("muffleWarning")
[08:29:20.208]                       }
[08:29:20.208]                       else if (inherits(cond, "condition")) {
[08:29:20.208]                         if (!is.null(pattern)) {
[08:29:20.208]                           computeRestarts <- base::computeRestarts
[08:29:20.208]                           grepl <- base::grepl
[08:29:20.208]                           restarts <- computeRestarts(cond)
[08:29:20.208]                           for (restart in restarts) {
[08:29:20.208]                             name <- restart$name
[08:29:20.208]                             if (is.null(name)) 
[08:29:20.208]                               next
[08:29:20.208]                             if (!grepl(pattern, name)) 
[08:29:20.208]                               next
[08:29:20.208]                             invokeRestart(restart)
[08:29:20.208]                             muffled <- TRUE
[08:29:20.208]                             break
[08:29:20.208]                           }
[08:29:20.208]                         }
[08:29:20.208]                       }
[08:29:20.208]                       invisible(muffled)
[08:29:20.208]                     }
[08:29:20.208]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.208]                   }
[08:29:20.208]                 }
[08:29:20.208]             }
[08:29:20.208]         }))
[08:29:20.208]     }, error = function(ex) {
[08:29:20.208]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.208]                 ...future.rng), started = ...future.startTime, 
[08:29:20.208]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.208]             version = "1.8"), class = "FutureResult")
[08:29:20.208]     }, finally = {
[08:29:20.208]         if (!identical(...future.workdir, getwd())) 
[08:29:20.208]             setwd(...future.workdir)
[08:29:20.208]         {
[08:29:20.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.208]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.208]             }
[08:29:20.208]             base::options(...future.oldOptions)
[08:29:20.208]             if (.Platform$OS.type == "windows") {
[08:29:20.208]                 old_names <- names(...future.oldEnvVars)
[08:29:20.208]                 envs <- base::Sys.getenv()
[08:29:20.208]                 names <- names(envs)
[08:29:20.208]                 common <- intersect(names, old_names)
[08:29:20.208]                 added <- setdiff(names, old_names)
[08:29:20.208]                 removed <- setdiff(old_names, names)
[08:29:20.208]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.208]                   envs[common]]
[08:29:20.208]                 NAMES <- toupper(changed)
[08:29:20.208]                 args <- list()
[08:29:20.208]                 for (kk in seq_along(NAMES)) {
[08:29:20.208]                   name <- changed[[kk]]
[08:29:20.208]                   NAME <- NAMES[[kk]]
[08:29:20.208]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.208]                     next
[08:29:20.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.208]                 }
[08:29:20.208]                 NAMES <- toupper(added)
[08:29:20.208]                 for (kk in seq_along(NAMES)) {
[08:29:20.208]                   name <- added[[kk]]
[08:29:20.208]                   NAME <- NAMES[[kk]]
[08:29:20.208]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.208]                     next
[08:29:20.208]                   args[[name]] <- ""
[08:29:20.208]                 }
[08:29:20.208]                 NAMES <- toupper(removed)
[08:29:20.208]                 for (kk in seq_along(NAMES)) {
[08:29:20.208]                   name <- removed[[kk]]
[08:29:20.208]                   NAME <- NAMES[[kk]]
[08:29:20.208]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.208]                     next
[08:29:20.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.208]                 }
[08:29:20.208]                 if (length(args) > 0) 
[08:29:20.208]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.208]             }
[08:29:20.208]             else {
[08:29:20.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.208]             }
[08:29:20.208]             {
[08:29:20.208]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.208]                   0L) {
[08:29:20.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.208]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.208]                   base::options(opts)
[08:29:20.208]                 }
[08:29:20.208]                 {
[08:29:20.208]                   {
[08:29:20.208]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.208]                     NULL
[08:29:20.208]                   }
[08:29:20.208]                   options(future.plan = NULL)
[08:29:20.208]                   if (is.na(NA_character_)) 
[08:29:20.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.208]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.208]                     .init = FALSE)
[08:29:20.208]                 }
[08:29:20.208]             }
[08:29:20.208]         }
[08:29:20.208]     })
[08:29:20.208]     if (TRUE) {
[08:29:20.208]         base::sink(type = "output", split = FALSE)
[08:29:20.208]         if (TRUE) {
[08:29:20.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.208]         }
[08:29:20.208]         else {
[08:29:20.208]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.208]         }
[08:29:20.208]         base::close(...future.stdout)
[08:29:20.208]         ...future.stdout <- NULL
[08:29:20.208]     }
[08:29:20.208]     ...future.result$conditions <- ...future.conditions
[08:29:20.208]     ...future.result$finished <- base::Sys.time()
[08:29:20.208]     ...future.result
[08:29:20.208] }
[08:29:20.211] MultisessionFuture started
[08:29:20.211] - Launch lazy future ... done
[08:29:20.211] run() for ‘MultisessionFuture’ ... done
[08:29:20.228] receiveMessageFromWorker() for ClusterFuture ...
[08:29:20.228] - Validating connection of MultisessionFuture
[08:29:20.228] - received message: FutureResult
[08:29:20.229] - Received FutureResult
[08:29:20.229] - Erased future from FutureRegistry
[08:29:20.229] result() for ClusterFuture ...
[08:29:20.229] - result already collected: FutureResult
[08:29:20.229] result() for ClusterFuture ... done
[08:29:20.229] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:20.229] Future #2
[08:29:20.229]  length: 2 (resolved future 2)
[08:29:20.229]  length: 1 (resolved future 3)
[08:29:20.260] receiveMessageFromWorker() for ClusterFuture ...
[08:29:20.261] - Validating connection of MultisessionFuture
[08:29:20.261] - received message: FutureResult
[08:29:20.261] - Received FutureResult
[08:29:20.261] - Erased future from FutureRegistry
[08:29:20.261] result() for ClusterFuture ...
[08:29:20.261] - result already collected: FutureResult
[08:29:20.261] result() for ClusterFuture ... done
[08:29:20.261] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:20.261] Future #1
[08:29:20.262]  length: 0 (resolved future 1)
[08:29:20.262] resolve() on list ... DONE
[08:29:20.262] getGlobalsAndPackages() ...
[08:29:20.262] Searching for globals...
[08:29:20.262] 
[08:29:20.262] Searching for globals ... DONE
[08:29:20.262] - globals: [0] <none>
[08:29:20.262] getGlobalsAndPackages() ... DONE
[08:29:20.263] getGlobalsAndPackages() ...
[08:29:20.263] Searching for globals...
[08:29:20.263] 
[08:29:20.263] Searching for globals ... DONE
[08:29:20.263] - globals: [0] <none>
[08:29:20.263] getGlobalsAndPackages() ... DONE
[08:29:20.263] resolve() on list ...
[08:29:20.264]  recursive: 0
[08:29:20.264]  length: 3
[08:29:20.264]  elements: ‘a’, ‘b’, ‘’
[08:29:20.264] run() for ‘Future’ ...
[08:29:20.264] - state: ‘created’
[08:29:20.264] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.278] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.278]   - Field: ‘node’
[08:29:20.278]   - Field: ‘label’
[08:29:20.278]   - Field: ‘local’
[08:29:20.278]   - Field: ‘owner’
[08:29:20.278]   - Field: ‘envir’
[08:29:20.278]   - Field: ‘workers’
[08:29:20.278]   - Field: ‘packages’
[08:29:20.279]   - Field: ‘gc’
[08:29:20.279]   - Field: ‘conditions’
[08:29:20.279]   - Field: ‘persistent’
[08:29:20.279]   - Field: ‘expr’
[08:29:20.279]   - Field: ‘uuid’
[08:29:20.279]   - Field: ‘seed’
[08:29:20.279]   - Field: ‘version’
[08:29:20.279]   - Field: ‘result’
[08:29:20.279]   - Field: ‘asynchronous’
[08:29:20.279]   - Field: ‘calls’
[08:29:20.279]   - Field: ‘globals’
[08:29:20.279]   - Field: ‘stdout’
[08:29:20.280]   - Field: ‘earlySignal’
[08:29:20.280]   - Field: ‘lazy’
[08:29:20.280]   - Field: ‘state’
[08:29:20.280] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.280] - Launch lazy future ...
[08:29:20.280] Packages needed by the future expression (n = 0): <none>
[08:29:20.280] Packages needed by future strategies (n = 0): <none>
[08:29:20.281] {
[08:29:20.281]     {
[08:29:20.281]         {
[08:29:20.281]             ...future.startTime <- base::Sys.time()
[08:29:20.281]             {
[08:29:20.281]                 {
[08:29:20.281]                   {
[08:29:20.281]                     {
[08:29:20.281]                       base::local({
[08:29:20.281]                         has_future <- base::requireNamespace("future", 
[08:29:20.281]                           quietly = TRUE)
[08:29:20.281]                         if (has_future) {
[08:29:20.281]                           ns <- base::getNamespace("future")
[08:29:20.281]                           version <- ns[[".package"]][["version"]]
[08:29:20.281]                           if (is.null(version)) 
[08:29:20.281]                             version <- utils::packageVersion("future")
[08:29:20.281]                         }
[08:29:20.281]                         else {
[08:29:20.281]                           version <- NULL
[08:29:20.281]                         }
[08:29:20.281]                         if (!has_future || version < "1.8.0") {
[08:29:20.281]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.281]                             "", base::R.version$version.string), 
[08:29:20.281]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.281]                               "release", "version")], collapse = " "), 
[08:29:20.281]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.281]                             info)
[08:29:20.281]                           info <- base::paste(info, collapse = "; ")
[08:29:20.281]                           if (!has_future) {
[08:29:20.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.281]                               info)
[08:29:20.281]                           }
[08:29:20.281]                           else {
[08:29:20.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.281]                               info, version)
[08:29:20.281]                           }
[08:29:20.281]                           base::stop(msg)
[08:29:20.281]                         }
[08:29:20.281]                       })
[08:29:20.281]                     }
[08:29:20.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.281]                     base::options(mc.cores = 1L)
[08:29:20.281]                   }
[08:29:20.281]                   ...future.strategy.old <- future::plan("list")
[08:29:20.281]                   options(future.plan = NULL)
[08:29:20.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.281]                 }
[08:29:20.281]                 ...future.workdir <- getwd()
[08:29:20.281]             }
[08:29:20.281]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.281]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.281]         }
[08:29:20.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.281]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.281]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.281]             base::names(...future.oldOptions))
[08:29:20.281]     }
[08:29:20.281]     if (FALSE) {
[08:29:20.281]     }
[08:29:20.281]     else {
[08:29:20.281]         if (TRUE) {
[08:29:20.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.281]                 open = "w")
[08:29:20.281]         }
[08:29:20.281]         else {
[08:29:20.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.281]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.281]         }
[08:29:20.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.281]             base::sink(type = "output", split = FALSE)
[08:29:20.281]             base::close(...future.stdout)
[08:29:20.281]         }, add = TRUE)
[08:29:20.281]     }
[08:29:20.281]     ...future.frame <- base::sys.nframe()
[08:29:20.281]     ...future.conditions <- base::list()
[08:29:20.281]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.281]     if (FALSE) {
[08:29:20.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.281]     }
[08:29:20.281]     ...future.result <- base::tryCatch({
[08:29:20.281]         base::withCallingHandlers({
[08:29:20.281]             ...future.value <- base::withVisible(base::local({
[08:29:20.281]                 ...future.makeSendCondition <- base::local({
[08:29:20.281]                   sendCondition <- NULL
[08:29:20.281]                   function(frame = 1L) {
[08:29:20.281]                     if (is.function(sendCondition)) 
[08:29:20.281]                       return(sendCondition)
[08:29:20.281]                     ns <- getNamespace("parallel")
[08:29:20.281]                     if (exists("sendData", mode = "function", 
[08:29:20.281]                       envir = ns)) {
[08:29:20.281]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.281]                         envir = ns)
[08:29:20.281]                       envir <- sys.frame(frame)
[08:29:20.281]                       master <- NULL
[08:29:20.281]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.281]                         !identical(envir, emptyenv())) {
[08:29:20.281]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.281]                           inherits = FALSE)) {
[08:29:20.281]                           master <- get("master", mode = "list", 
[08:29:20.281]                             envir = envir, inherits = FALSE)
[08:29:20.281]                           if (inherits(master, c("SOCKnode", 
[08:29:20.281]                             "SOCK0node"))) {
[08:29:20.281]                             sendCondition <<- function(cond) {
[08:29:20.281]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.281]                                 success = TRUE)
[08:29:20.281]                               parallel_sendData(master, data)
[08:29:20.281]                             }
[08:29:20.281]                             return(sendCondition)
[08:29:20.281]                           }
[08:29:20.281]                         }
[08:29:20.281]                         frame <- frame + 1L
[08:29:20.281]                         envir <- sys.frame(frame)
[08:29:20.281]                       }
[08:29:20.281]                     }
[08:29:20.281]                     sendCondition <<- function(cond) NULL
[08:29:20.281]                   }
[08:29:20.281]                 })
[08:29:20.281]                 withCallingHandlers({
[08:29:20.281]                   1
[08:29:20.281]                 }, immediateCondition = function(cond) {
[08:29:20.281]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.281]                   sendCondition(cond)
[08:29:20.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.281]                   {
[08:29:20.281]                     inherits <- base::inherits
[08:29:20.281]                     invokeRestart <- base::invokeRestart
[08:29:20.281]                     is.null <- base::is.null
[08:29:20.281]                     muffled <- FALSE
[08:29:20.281]                     if (inherits(cond, "message")) {
[08:29:20.281]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.281]                       if (muffled) 
[08:29:20.281]                         invokeRestart("muffleMessage")
[08:29:20.281]                     }
[08:29:20.281]                     else if (inherits(cond, "warning")) {
[08:29:20.281]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.281]                       if (muffled) 
[08:29:20.281]                         invokeRestart("muffleWarning")
[08:29:20.281]                     }
[08:29:20.281]                     else if (inherits(cond, "condition")) {
[08:29:20.281]                       if (!is.null(pattern)) {
[08:29:20.281]                         computeRestarts <- base::computeRestarts
[08:29:20.281]                         grepl <- base::grepl
[08:29:20.281]                         restarts <- computeRestarts(cond)
[08:29:20.281]                         for (restart in restarts) {
[08:29:20.281]                           name <- restart$name
[08:29:20.281]                           if (is.null(name)) 
[08:29:20.281]                             next
[08:29:20.281]                           if (!grepl(pattern, name)) 
[08:29:20.281]                             next
[08:29:20.281]                           invokeRestart(restart)
[08:29:20.281]                           muffled <- TRUE
[08:29:20.281]                           break
[08:29:20.281]                         }
[08:29:20.281]                       }
[08:29:20.281]                     }
[08:29:20.281]                     invisible(muffled)
[08:29:20.281]                   }
[08:29:20.281]                   muffleCondition(cond)
[08:29:20.281]                 })
[08:29:20.281]             }))
[08:29:20.281]             future::FutureResult(value = ...future.value$value, 
[08:29:20.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.281]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.281]                     ...future.globalenv.names))
[08:29:20.281]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.281]         }, condition = base::local({
[08:29:20.281]             c <- base::c
[08:29:20.281]             inherits <- base::inherits
[08:29:20.281]             invokeRestart <- base::invokeRestart
[08:29:20.281]             length <- base::length
[08:29:20.281]             list <- base::list
[08:29:20.281]             seq.int <- base::seq.int
[08:29:20.281]             signalCondition <- base::signalCondition
[08:29:20.281]             sys.calls <- base::sys.calls
[08:29:20.281]             `[[` <- base::`[[`
[08:29:20.281]             `+` <- base::`+`
[08:29:20.281]             `<<-` <- base::`<<-`
[08:29:20.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.281]                   3L)]
[08:29:20.281]             }
[08:29:20.281]             function(cond) {
[08:29:20.281]                 is_error <- inherits(cond, "error")
[08:29:20.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.281]                   NULL)
[08:29:20.281]                 if (is_error) {
[08:29:20.281]                   sessionInformation <- function() {
[08:29:20.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.281]                       search = base::search(), system = base::Sys.info())
[08:29:20.281]                   }
[08:29:20.281]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.281]                     cond$call), session = sessionInformation(), 
[08:29:20.281]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.281]                   signalCondition(cond)
[08:29:20.281]                 }
[08:29:20.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.281]                 "immediateCondition"))) {
[08:29:20.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.281]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.281]                   if (TRUE && !signal) {
[08:29:20.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.281]                     {
[08:29:20.281]                       inherits <- base::inherits
[08:29:20.281]                       invokeRestart <- base::invokeRestart
[08:29:20.281]                       is.null <- base::is.null
[08:29:20.281]                       muffled <- FALSE
[08:29:20.281]                       if (inherits(cond, "message")) {
[08:29:20.281]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.281]                         if (muffled) 
[08:29:20.281]                           invokeRestart("muffleMessage")
[08:29:20.281]                       }
[08:29:20.281]                       else if (inherits(cond, "warning")) {
[08:29:20.281]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.281]                         if (muffled) 
[08:29:20.281]                           invokeRestart("muffleWarning")
[08:29:20.281]                       }
[08:29:20.281]                       else if (inherits(cond, "condition")) {
[08:29:20.281]                         if (!is.null(pattern)) {
[08:29:20.281]                           computeRestarts <- base::computeRestarts
[08:29:20.281]                           grepl <- base::grepl
[08:29:20.281]                           restarts <- computeRestarts(cond)
[08:29:20.281]                           for (restart in restarts) {
[08:29:20.281]                             name <- restart$name
[08:29:20.281]                             if (is.null(name)) 
[08:29:20.281]                               next
[08:29:20.281]                             if (!grepl(pattern, name)) 
[08:29:20.281]                               next
[08:29:20.281]                             invokeRestart(restart)
[08:29:20.281]                             muffled <- TRUE
[08:29:20.281]                             break
[08:29:20.281]                           }
[08:29:20.281]                         }
[08:29:20.281]                       }
[08:29:20.281]                       invisible(muffled)
[08:29:20.281]                     }
[08:29:20.281]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.281]                   }
[08:29:20.281]                 }
[08:29:20.281]                 else {
[08:29:20.281]                   if (TRUE) {
[08:29:20.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.281]                     {
[08:29:20.281]                       inherits <- base::inherits
[08:29:20.281]                       invokeRestart <- base::invokeRestart
[08:29:20.281]                       is.null <- base::is.null
[08:29:20.281]                       muffled <- FALSE
[08:29:20.281]                       if (inherits(cond, "message")) {
[08:29:20.281]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.281]                         if (muffled) 
[08:29:20.281]                           invokeRestart("muffleMessage")
[08:29:20.281]                       }
[08:29:20.281]                       else if (inherits(cond, "warning")) {
[08:29:20.281]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.281]                         if (muffled) 
[08:29:20.281]                           invokeRestart("muffleWarning")
[08:29:20.281]                       }
[08:29:20.281]                       else if (inherits(cond, "condition")) {
[08:29:20.281]                         if (!is.null(pattern)) {
[08:29:20.281]                           computeRestarts <- base::computeRestarts
[08:29:20.281]                           grepl <- base::grepl
[08:29:20.281]                           restarts <- computeRestarts(cond)
[08:29:20.281]                           for (restart in restarts) {
[08:29:20.281]                             name <- restart$name
[08:29:20.281]                             if (is.null(name)) 
[08:29:20.281]                               next
[08:29:20.281]                             if (!grepl(pattern, name)) 
[08:29:20.281]                               next
[08:29:20.281]                             invokeRestart(restart)
[08:29:20.281]                             muffled <- TRUE
[08:29:20.281]                             break
[08:29:20.281]                           }
[08:29:20.281]                         }
[08:29:20.281]                       }
[08:29:20.281]                       invisible(muffled)
[08:29:20.281]                     }
[08:29:20.281]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.281]                   }
[08:29:20.281]                 }
[08:29:20.281]             }
[08:29:20.281]         }))
[08:29:20.281]     }, error = function(ex) {
[08:29:20.281]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.281]                 ...future.rng), started = ...future.startTime, 
[08:29:20.281]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.281]             version = "1.8"), class = "FutureResult")
[08:29:20.281]     }, finally = {
[08:29:20.281]         if (!identical(...future.workdir, getwd())) 
[08:29:20.281]             setwd(...future.workdir)
[08:29:20.281]         {
[08:29:20.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.281]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.281]             }
[08:29:20.281]             base::options(...future.oldOptions)
[08:29:20.281]             if (.Platform$OS.type == "windows") {
[08:29:20.281]                 old_names <- names(...future.oldEnvVars)
[08:29:20.281]                 envs <- base::Sys.getenv()
[08:29:20.281]                 names <- names(envs)
[08:29:20.281]                 common <- intersect(names, old_names)
[08:29:20.281]                 added <- setdiff(names, old_names)
[08:29:20.281]                 removed <- setdiff(old_names, names)
[08:29:20.281]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.281]                   envs[common]]
[08:29:20.281]                 NAMES <- toupper(changed)
[08:29:20.281]                 args <- list()
[08:29:20.281]                 for (kk in seq_along(NAMES)) {
[08:29:20.281]                   name <- changed[[kk]]
[08:29:20.281]                   NAME <- NAMES[[kk]]
[08:29:20.281]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.281]                     next
[08:29:20.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.281]                 }
[08:29:20.281]                 NAMES <- toupper(added)
[08:29:20.281]                 for (kk in seq_along(NAMES)) {
[08:29:20.281]                   name <- added[[kk]]
[08:29:20.281]                   NAME <- NAMES[[kk]]
[08:29:20.281]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.281]                     next
[08:29:20.281]                   args[[name]] <- ""
[08:29:20.281]                 }
[08:29:20.281]                 NAMES <- toupper(removed)
[08:29:20.281]                 for (kk in seq_along(NAMES)) {
[08:29:20.281]                   name <- removed[[kk]]
[08:29:20.281]                   NAME <- NAMES[[kk]]
[08:29:20.281]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.281]                     next
[08:29:20.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.281]                 }
[08:29:20.281]                 if (length(args) > 0) 
[08:29:20.281]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.281]             }
[08:29:20.281]             else {
[08:29:20.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.281]             }
[08:29:20.281]             {
[08:29:20.281]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.281]                   0L) {
[08:29:20.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.281]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.281]                   base::options(opts)
[08:29:20.281]                 }
[08:29:20.281]                 {
[08:29:20.281]                   {
[08:29:20.281]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.281]                     NULL
[08:29:20.281]                   }
[08:29:20.281]                   options(future.plan = NULL)
[08:29:20.281]                   if (is.na(NA_character_)) 
[08:29:20.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.281]                     .init = FALSE)
[08:29:20.281]                 }
[08:29:20.281]             }
[08:29:20.281]         }
[08:29:20.281]     })
[08:29:20.281]     if (TRUE) {
[08:29:20.281]         base::sink(type = "output", split = FALSE)
[08:29:20.281]         if (TRUE) {
[08:29:20.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.281]         }
[08:29:20.281]         else {
[08:29:20.281]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.281]         }
[08:29:20.281]         base::close(...future.stdout)
[08:29:20.281]         ...future.stdout <- NULL
[08:29:20.281]     }
[08:29:20.281]     ...future.result$conditions <- ...future.conditions
[08:29:20.281]     ...future.result$finished <- base::Sys.time()
[08:29:20.281]     ...future.result
[08:29:20.281] }
[08:29:20.284] MultisessionFuture started
[08:29:20.284] - Launch lazy future ... done
[08:29:20.284] run() for ‘MultisessionFuture’ ... done
[08:29:20.294] run() for ‘Future’ ...
[08:29:20.295] - state: ‘created’
[08:29:20.295] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.309] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.309] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.309]   - Field: ‘node’
[08:29:20.309]   - Field: ‘label’
[08:29:20.309]   - Field: ‘local’
[08:29:20.309]   - Field: ‘owner’
[08:29:20.310]   - Field: ‘envir’
[08:29:20.310]   - Field: ‘workers’
[08:29:20.310]   - Field: ‘packages’
[08:29:20.310]   - Field: ‘gc’
[08:29:20.310]   - Field: ‘conditions’
[08:29:20.310]   - Field: ‘persistent’
[08:29:20.310]   - Field: ‘expr’
[08:29:20.310]   - Field: ‘uuid’
[08:29:20.310]   - Field: ‘seed’
[08:29:20.310]   - Field: ‘version’
[08:29:20.310]   - Field: ‘result’
[08:29:20.310]   - Field: ‘asynchronous’
[08:29:20.311]   - Field: ‘calls’
[08:29:20.311]   - Field: ‘globals’
[08:29:20.311]   - Field: ‘stdout’
[08:29:20.311]   - Field: ‘earlySignal’
[08:29:20.311]   - Field: ‘lazy’
[08:29:20.311]   - Field: ‘state’
[08:29:20.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.311] - Launch lazy future ...
[08:29:20.311] Packages needed by the future expression (n = 0): <none>
[08:29:20.312] Packages needed by future strategies (n = 0): <none>
[08:29:20.312] {
[08:29:20.312]     {
[08:29:20.312]         {
[08:29:20.312]             ...future.startTime <- base::Sys.time()
[08:29:20.312]             {
[08:29:20.312]                 {
[08:29:20.312]                   {
[08:29:20.312]                     {
[08:29:20.312]                       base::local({
[08:29:20.312]                         has_future <- base::requireNamespace("future", 
[08:29:20.312]                           quietly = TRUE)
[08:29:20.312]                         if (has_future) {
[08:29:20.312]                           ns <- base::getNamespace("future")
[08:29:20.312]                           version <- ns[[".package"]][["version"]]
[08:29:20.312]                           if (is.null(version)) 
[08:29:20.312]                             version <- utils::packageVersion("future")
[08:29:20.312]                         }
[08:29:20.312]                         else {
[08:29:20.312]                           version <- NULL
[08:29:20.312]                         }
[08:29:20.312]                         if (!has_future || version < "1.8.0") {
[08:29:20.312]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.312]                             "", base::R.version$version.string), 
[08:29:20.312]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.312]                               "release", "version")], collapse = " "), 
[08:29:20.312]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.312]                             info)
[08:29:20.312]                           info <- base::paste(info, collapse = "; ")
[08:29:20.312]                           if (!has_future) {
[08:29:20.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.312]                               info)
[08:29:20.312]                           }
[08:29:20.312]                           else {
[08:29:20.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.312]                               info, version)
[08:29:20.312]                           }
[08:29:20.312]                           base::stop(msg)
[08:29:20.312]                         }
[08:29:20.312]                       })
[08:29:20.312]                     }
[08:29:20.312]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.312]                     base::options(mc.cores = 1L)
[08:29:20.312]                   }
[08:29:20.312]                   ...future.strategy.old <- future::plan("list")
[08:29:20.312]                   options(future.plan = NULL)
[08:29:20.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.312]                 }
[08:29:20.312]                 ...future.workdir <- getwd()
[08:29:20.312]             }
[08:29:20.312]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.312]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.312]         }
[08:29:20.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.312]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.312]             base::names(...future.oldOptions))
[08:29:20.312]     }
[08:29:20.312]     if (FALSE) {
[08:29:20.312]     }
[08:29:20.312]     else {
[08:29:20.312]         if (TRUE) {
[08:29:20.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.312]                 open = "w")
[08:29:20.312]         }
[08:29:20.312]         else {
[08:29:20.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.312]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.312]         }
[08:29:20.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.312]             base::sink(type = "output", split = FALSE)
[08:29:20.312]             base::close(...future.stdout)
[08:29:20.312]         }, add = TRUE)
[08:29:20.312]     }
[08:29:20.312]     ...future.frame <- base::sys.nframe()
[08:29:20.312]     ...future.conditions <- base::list()
[08:29:20.312]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.312]     if (FALSE) {
[08:29:20.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.312]     }
[08:29:20.312]     ...future.result <- base::tryCatch({
[08:29:20.312]         base::withCallingHandlers({
[08:29:20.312]             ...future.value <- base::withVisible(base::local({
[08:29:20.312]                 ...future.makeSendCondition <- base::local({
[08:29:20.312]                   sendCondition <- NULL
[08:29:20.312]                   function(frame = 1L) {
[08:29:20.312]                     if (is.function(sendCondition)) 
[08:29:20.312]                       return(sendCondition)
[08:29:20.312]                     ns <- getNamespace("parallel")
[08:29:20.312]                     if (exists("sendData", mode = "function", 
[08:29:20.312]                       envir = ns)) {
[08:29:20.312]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.312]                         envir = ns)
[08:29:20.312]                       envir <- sys.frame(frame)
[08:29:20.312]                       master <- NULL
[08:29:20.312]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.312]                         !identical(envir, emptyenv())) {
[08:29:20.312]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.312]                           inherits = FALSE)) {
[08:29:20.312]                           master <- get("master", mode = "list", 
[08:29:20.312]                             envir = envir, inherits = FALSE)
[08:29:20.312]                           if (inherits(master, c("SOCKnode", 
[08:29:20.312]                             "SOCK0node"))) {
[08:29:20.312]                             sendCondition <<- function(cond) {
[08:29:20.312]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.312]                                 success = TRUE)
[08:29:20.312]                               parallel_sendData(master, data)
[08:29:20.312]                             }
[08:29:20.312]                             return(sendCondition)
[08:29:20.312]                           }
[08:29:20.312]                         }
[08:29:20.312]                         frame <- frame + 1L
[08:29:20.312]                         envir <- sys.frame(frame)
[08:29:20.312]                       }
[08:29:20.312]                     }
[08:29:20.312]                     sendCondition <<- function(cond) NULL
[08:29:20.312]                   }
[08:29:20.312]                 })
[08:29:20.312]                 withCallingHandlers({
[08:29:20.312]                   2
[08:29:20.312]                 }, immediateCondition = function(cond) {
[08:29:20.312]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.312]                   sendCondition(cond)
[08:29:20.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.312]                   {
[08:29:20.312]                     inherits <- base::inherits
[08:29:20.312]                     invokeRestart <- base::invokeRestart
[08:29:20.312]                     is.null <- base::is.null
[08:29:20.312]                     muffled <- FALSE
[08:29:20.312]                     if (inherits(cond, "message")) {
[08:29:20.312]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.312]                       if (muffled) 
[08:29:20.312]                         invokeRestart("muffleMessage")
[08:29:20.312]                     }
[08:29:20.312]                     else if (inherits(cond, "warning")) {
[08:29:20.312]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.312]                       if (muffled) 
[08:29:20.312]                         invokeRestart("muffleWarning")
[08:29:20.312]                     }
[08:29:20.312]                     else if (inherits(cond, "condition")) {
[08:29:20.312]                       if (!is.null(pattern)) {
[08:29:20.312]                         computeRestarts <- base::computeRestarts
[08:29:20.312]                         grepl <- base::grepl
[08:29:20.312]                         restarts <- computeRestarts(cond)
[08:29:20.312]                         for (restart in restarts) {
[08:29:20.312]                           name <- restart$name
[08:29:20.312]                           if (is.null(name)) 
[08:29:20.312]                             next
[08:29:20.312]                           if (!grepl(pattern, name)) 
[08:29:20.312]                             next
[08:29:20.312]                           invokeRestart(restart)
[08:29:20.312]                           muffled <- TRUE
[08:29:20.312]                           break
[08:29:20.312]                         }
[08:29:20.312]                       }
[08:29:20.312]                     }
[08:29:20.312]                     invisible(muffled)
[08:29:20.312]                   }
[08:29:20.312]                   muffleCondition(cond)
[08:29:20.312]                 })
[08:29:20.312]             }))
[08:29:20.312]             future::FutureResult(value = ...future.value$value, 
[08:29:20.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.312]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.312]                     ...future.globalenv.names))
[08:29:20.312]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.312]         }, condition = base::local({
[08:29:20.312]             c <- base::c
[08:29:20.312]             inherits <- base::inherits
[08:29:20.312]             invokeRestart <- base::invokeRestart
[08:29:20.312]             length <- base::length
[08:29:20.312]             list <- base::list
[08:29:20.312]             seq.int <- base::seq.int
[08:29:20.312]             signalCondition <- base::signalCondition
[08:29:20.312]             sys.calls <- base::sys.calls
[08:29:20.312]             `[[` <- base::`[[`
[08:29:20.312]             `+` <- base::`+`
[08:29:20.312]             `<<-` <- base::`<<-`
[08:29:20.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.312]                   3L)]
[08:29:20.312]             }
[08:29:20.312]             function(cond) {
[08:29:20.312]                 is_error <- inherits(cond, "error")
[08:29:20.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.312]                   NULL)
[08:29:20.312]                 if (is_error) {
[08:29:20.312]                   sessionInformation <- function() {
[08:29:20.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.312]                       search = base::search(), system = base::Sys.info())
[08:29:20.312]                   }
[08:29:20.312]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.312]                     cond$call), session = sessionInformation(), 
[08:29:20.312]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.312]                   signalCondition(cond)
[08:29:20.312]                 }
[08:29:20.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.312]                 "immediateCondition"))) {
[08:29:20.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.312]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.312]                   if (TRUE && !signal) {
[08:29:20.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.312]                     {
[08:29:20.312]                       inherits <- base::inherits
[08:29:20.312]                       invokeRestart <- base::invokeRestart
[08:29:20.312]                       is.null <- base::is.null
[08:29:20.312]                       muffled <- FALSE
[08:29:20.312]                       if (inherits(cond, "message")) {
[08:29:20.312]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.312]                         if (muffled) 
[08:29:20.312]                           invokeRestart("muffleMessage")
[08:29:20.312]                       }
[08:29:20.312]                       else if (inherits(cond, "warning")) {
[08:29:20.312]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.312]                         if (muffled) 
[08:29:20.312]                           invokeRestart("muffleWarning")
[08:29:20.312]                       }
[08:29:20.312]                       else if (inherits(cond, "condition")) {
[08:29:20.312]                         if (!is.null(pattern)) {
[08:29:20.312]                           computeRestarts <- base::computeRestarts
[08:29:20.312]                           grepl <- base::grepl
[08:29:20.312]                           restarts <- computeRestarts(cond)
[08:29:20.312]                           for (restart in restarts) {
[08:29:20.312]                             name <- restart$name
[08:29:20.312]                             if (is.null(name)) 
[08:29:20.312]                               next
[08:29:20.312]                             if (!grepl(pattern, name)) 
[08:29:20.312]                               next
[08:29:20.312]                             invokeRestart(restart)
[08:29:20.312]                             muffled <- TRUE
[08:29:20.312]                             break
[08:29:20.312]                           }
[08:29:20.312]                         }
[08:29:20.312]                       }
[08:29:20.312]                       invisible(muffled)
[08:29:20.312]                     }
[08:29:20.312]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.312]                   }
[08:29:20.312]                 }
[08:29:20.312]                 else {
[08:29:20.312]                   if (TRUE) {
[08:29:20.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.312]                     {
[08:29:20.312]                       inherits <- base::inherits
[08:29:20.312]                       invokeRestart <- base::invokeRestart
[08:29:20.312]                       is.null <- base::is.null
[08:29:20.312]                       muffled <- FALSE
[08:29:20.312]                       if (inherits(cond, "message")) {
[08:29:20.312]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.312]                         if (muffled) 
[08:29:20.312]                           invokeRestart("muffleMessage")
[08:29:20.312]                       }
[08:29:20.312]                       else if (inherits(cond, "warning")) {
[08:29:20.312]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.312]                         if (muffled) 
[08:29:20.312]                           invokeRestart("muffleWarning")
[08:29:20.312]                       }
[08:29:20.312]                       else if (inherits(cond, "condition")) {
[08:29:20.312]                         if (!is.null(pattern)) {
[08:29:20.312]                           computeRestarts <- base::computeRestarts
[08:29:20.312]                           grepl <- base::grepl
[08:29:20.312]                           restarts <- computeRestarts(cond)
[08:29:20.312]                           for (restart in restarts) {
[08:29:20.312]                             name <- restart$name
[08:29:20.312]                             if (is.null(name)) 
[08:29:20.312]                               next
[08:29:20.312]                             if (!grepl(pattern, name)) 
[08:29:20.312]                               next
[08:29:20.312]                             invokeRestart(restart)
[08:29:20.312]                             muffled <- TRUE
[08:29:20.312]                             break
[08:29:20.312]                           }
[08:29:20.312]                         }
[08:29:20.312]                       }
[08:29:20.312]                       invisible(muffled)
[08:29:20.312]                     }
[08:29:20.312]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.312]                   }
[08:29:20.312]                 }
[08:29:20.312]             }
[08:29:20.312]         }))
[08:29:20.312]     }, error = function(ex) {
[08:29:20.312]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.312]                 ...future.rng), started = ...future.startTime, 
[08:29:20.312]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.312]             version = "1.8"), class = "FutureResult")
[08:29:20.312]     }, finally = {
[08:29:20.312]         if (!identical(...future.workdir, getwd())) 
[08:29:20.312]             setwd(...future.workdir)
[08:29:20.312]         {
[08:29:20.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.312]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.312]             }
[08:29:20.312]             base::options(...future.oldOptions)
[08:29:20.312]             if (.Platform$OS.type == "windows") {
[08:29:20.312]                 old_names <- names(...future.oldEnvVars)
[08:29:20.312]                 envs <- base::Sys.getenv()
[08:29:20.312]                 names <- names(envs)
[08:29:20.312]                 common <- intersect(names, old_names)
[08:29:20.312]                 added <- setdiff(names, old_names)
[08:29:20.312]                 removed <- setdiff(old_names, names)
[08:29:20.312]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.312]                   envs[common]]
[08:29:20.312]                 NAMES <- toupper(changed)
[08:29:20.312]                 args <- list()
[08:29:20.312]                 for (kk in seq_along(NAMES)) {
[08:29:20.312]                   name <- changed[[kk]]
[08:29:20.312]                   NAME <- NAMES[[kk]]
[08:29:20.312]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.312]                     next
[08:29:20.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.312]                 }
[08:29:20.312]                 NAMES <- toupper(added)
[08:29:20.312]                 for (kk in seq_along(NAMES)) {
[08:29:20.312]                   name <- added[[kk]]
[08:29:20.312]                   NAME <- NAMES[[kk]]
[08:29:20.312]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.312]                     next
[08:29:20.312]                   args[[name]] <- ""
[08:29:20.312]                 }
[08:29:20.312]                 NAMES <- toupper(removed)
[08:29:20.312]                 for (kk in seq_along(NAMES)) {
[08:29:20.312]                   name <- removed[[kk]]
[08:29:20.312]                   NAME <- NAMES[[kk]]
[08:29:20.312]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.312]                     next
[08:29:20.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.312]                 }
[08:29:20.312]                 if (length(args) > 0) 
[08:29:20.312]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.312]             }
[08:29:20.312]             else {
[08:29:20.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.312]             }
[08:29:20.312]             {
[08:29:20.312]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.312]                   0L) {
[08:29:20.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.312]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.312]                   base::options(opts)
[08:29:20.312]                 }
[08:29:20.312]                 {
[08:29:20.312]                   {
[08:29:20.312]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.312]                     NULL
[08:29:20.312]                   }
[08:29:20.312]                   options(future.plan = NULL)
[08:29:20.312]                   if (is.na(NA_character_)) 
[08:29:20.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.312]                     .init = FALSE)
[08:29:20.312]                 }
[08:29:20.312]             }
[08:29:20.312]         }
[08:29:20.312]     })
[08:29:20.312]     if (TRUE) {
[08:29:20.312]         base::sink(type = "output", split = FALSE)
[08:29:20.312]         if (TRUE) {
[08:29:20.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.312]         }
[08:29:20.312]         else {
[08:29:20.312]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.312]         }
[08:29:20.312]         base::close(...future.stdout)
[08:29:20.312]         ...future.stdout <- NULL
[08:29:20.312]     }
[08:29:20.312]     ...future.result$conditions <- ...future.conditions
[08:29:20.312]     ...future.result$finished <- base::Sys.time()
[08:29:20.312]     ...future.result
[08:29:20.312] }
[08:29:20.315] MultisessionFuture started
[08:29:20.315] - Launch lazy future ... done
[08:29:20.315] run() for ‘MultisessionFuture’ ... done
[08:29:20.326]  length: 2 (resolved future 3)
[08:29:20.336] receiveMessageFromWorker() for ClusterFuture ...
[08:29:20.337] - Validating connection of MultisessionFuture
[08:29:20.337] - received message: FutureResult
[08:29:20.337] - Received FutureResult
[08:29:20.337] - Erased future from FutureRegistry
[08:29:20.337] result() for ClusterFuture ...
[08:29:20.337] - result already collected: FutureResult
[08:29:20.337] result() for ClusterFuture ... done
[08:29:20.337] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:20.337] Future #1
[08:29:20.338]  length: 1 (resolved future 1)
[08:29:20.359] receiveMessageFromWorker() for ClusterFuture ...
[08:29:20.359] - Validating connection of MultisessionFuture
[08:29:20.359] - received message: FutureResult
[08:29:20.359] - Received FutureResult
[08:29:20.359] - Erased future from FutureRegistry
[08:29:20.359] result() for ClusterFuture ...
[08:29:20.359] - result already collected: FutureResult
[08:29:20.359] result() for ClusterFuture ... done
[08:29:20.359] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:20.360] Future #2
[08:29:20.360]  length: 0 (resolved future 2)
[08:29:20.360] resolve() on list ... DONE
[08:29:20.360] getGlobalsAndPackages() ...
[08:29:20.360] Searching for globals...
[08:29:20.360] 
[08:29:20.360] Searching for globals ... DONE
[08:29:20.360] - globals: [0] <none>
[08:29:20.361] getGlobalsAndPackages() ... DONE
[08:29:20.361] run() for ‘Future’ ...
[08:29:20.361] - state: ‘created’
[08:29:20.361] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.375] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.375]   - Field: ‘node’
[08:29:20.375]   - Field: ‘label’
[08:29:20.375]   - Field: ‘local’
[08:29:20.375]   - Field: ‘owner’
[08:29:20.375]   - Field: ‘envir’
[08:29:20.375]   - Field: ‘workers’
[08:29:20.376]   - Field: ‘packages’
[08:29:20.376]   - Field: ‘gc’
[08:29:20.376]   - Field: ‘conditions’
[08:29:20.376]   - Field: ‘persistent’
[08:29:20.376]   - Field: ‘expr’
[08:29:20.376]   - Field: ‘uuid’
[08:29:20.376]   - Field: ‘seed’
[08:29:20.376]   - Field: ‘version’
[08:29:20.376]   - Field: ‘result’
[08:29:20.376]   - Field: ‘asynchronous’
[08:29:20.376]   - Field: ‘calls’
[08:29:20.377]   - Field: ‘globals’
[08:29:20.377]   - Field: ‘stdout’
[08:29:20.377]   - Field: ‘earlySignal’
[08:29:20.377]   - Field: ‘lazy’
[08:29:20.377]   - Field: ‘state’
[08:29:20.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.377] - Launch lazy future ...
[08:29:20.377] Packages needed by the future expression (n = 0): <none>
[08:29:20.377] Packages needed by future strategies (n = 0): <none>
[08:29:20.378] {
[08:29:20.378]     {
[08:29:20.378]         {
[08:29:20.378]             ...future.startTime <- base::Sys.time()
[08:29:20.378]             {
[08:29:20.378]                 {
[08:29:20.378]                   {
[08:29:20.378]                     {
[08:29:20.378]                       base::local({
[08:29:20.378]                         has_future <- base::requireNamespace("future", 
[08:29:20.378]                           quietly = TRUE)
[08:29:20.378]                         if (has_future) {
[08:29:20.378]                           ns <- base::getNamespace("future")
[08:29:20.378]                           version <- ns[[".package"]][["version"]]
[08:29:20.378]                           if (is.null(version)) 
[08:29:20.378]                             version <- utils::packageVersion("future")
[08:29:20.378]                         }
[08:29:20.378]                         else {
[08:29:20.378]                           version <- NULL
[08:29:20.378]                         }
[08:29:20.378]                         if (!has_future || version < "1.8.0") {
[08:29:20.378]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.378]                             "", base::R.version$version.string), 
[08:29:20.378]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.378]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.378]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.378]                               "release", "version")], collapse = " "), 
[08:29:20.378]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.378]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.378]                             info)
[08:29:20.378]                           info <- base::paste(info, collapse = "; ")
[08:29:20.378]                           if (!has_future) {
[08:29:20.378]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.378]                               info)
[08:29:20.378]                           }
[08:29:20.378]                           else {
[08:29:20.378]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.378]                               info, version)
[08:29:20.378]                           }
[08:29:20.378]                           base::stop(msg)
[08:29:20.378]                         }
[08:29:20.378]                       })
[08:29:20.378]                     }
[08:29:20.378]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.378]                     base::options(mc.cores = 1L)
[08:29:20.378]                   }
[08:29:20.378]                   ...future.strategy.old <- future::plan("list")
[08:29:20.378]                   options(future.plan = NULL)
[08:29:20.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.378]                 }
[08:29:20.378]                 ...future.workdir <- getwd()
[08:29:20.378]             }
[08:29:20.378]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.378]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.378]         }
[08:29:20.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.378]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.378]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.378]             base::names(...future.oldOptions))
[08:29:20.378]     }
[08:29:20.378]     if (FALSE) {
[08:29:20.378]     }
[08:29:20.378]     else {
[08:29:20.378]         if (TRUE) {
[08:29:20.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.378]                 open = "w")
[08:29:20.378]         }
[08:29:20.378]         else {
[08:29:20.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.378]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.378]         }
[08:29:20.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.378]             base::sink(type = "output", split = FALSE)
[08:29:20.378]             base::close(...future.stdout)
[08:29:20.378]         }, add = TRUE)
[08:29:20.378]     }
[08:29:20.378]     ...future.frame <- base::sys.nframe()
[08:29:20.378]     ...future.conditions <- base::list()
[08:29:20.378]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.378]     if (FALSE) {
[08:29:20.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.378]     }
[08:29:20.378]     ...future.result <- base::tryCatch({
[08:29:20.378]         base::withCallingHandlers({
[08:29:20.378]             ...future.value <- base::withVisible(base::local({
[08:29:20.378]                 ...future.makeSendCondition <- base::local({
[08:29:20.378]                   sendCondition <- NULL
[08:29:20.378]                   function(frame = 1L) {
[08:29:20.378]                     if (is.function(sendCondition)) 
[08:29:20.378]                       return(sendCondition)
[08:29:20.378]                     ns <- getNamespace("parallel")
[08:29:20.378]                     if (exists("sendData", mode = "function", 
[08:29:20.378]                       envir = ns)) {
[08:29:20.378]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.378]                         envir = ns)
[08:29:20.378]                       envir <- sys.frame(frame)
[08:29:20.378]                       master <- NULL
[08:29:20.378]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.378]                         !identical(envir, emptyenv())) {
[08:29:20.378]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.378]                           inherits = FALSE)) {
[08:29:20.378]                           master <- get("master", mode = "list", 
[08:29:20.378]                             envir = envir, inherits = FALSE)
[08:29:20.378]                           if (inherits(master, c("SOCKnode", 
[08:29:20.378]                             "SOCK0node"))) {
[08:29:20.378]                             sendCondition <<- function(cond) {
[08:29:20.378]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.378]                                 success = TRUE)
[08:29:20.378]                               parallel_sendData(master, data)
[08:29:20.378]                             }
[08:29:20.378]                             return(sendCondition)
[08:29:20.378]                           }
[08:29:20.378]                         }
[08:29:20.378]                         frame <- frame + 1L
[08:29:20.378]                         envir <- sys.frame(frame)
[08:29:20.378]                       }
[08:29:20.378]                     }
[08:29:20.378]                     sendCondition <<- function(cond) NULL
[08:29:20.378]                   }
[08:29:20.378]                 })
[08:29:20.378]                 withCallingHandlers({
[08:29:20.378]                   1
[08:29:20.378]                 }, immediateCondition = function(cond) {
[08:29:20.378]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.378]                   sendCondition(cond)
[08:29:20.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.378]                   {
[08:29:20.378]                     inherits <- base::inherits
[08:29:20.378]                     invokeRestart <- base::invokeRestart
[08:29:20.378]                     is.null <- base::is.null
[08:29:20.378]                     muffled <- FALSE
[08:29:20.378]                     if (inherits(cond, "message")) {
[08:29:20.378]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.378]                       if (muffled) 
[08:29:20.378]                         invokeRestart("muffleMessage")
[08:29:20.378]                     }
[08:29:20.378]                     else if (inherits(cond, "warning")) {
[08:29:20.378]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.378]                       if (muffled) 
[08:29:20.378]                         invokeRestart("muffleWarning")
[08:29:20.378]                     }
[08:29:20.378]                     else if (inherits(cond, "condition")) {
[08:29:20.378]                       if (!is.null(pattern)) {
[08:29:20.378]                         computeRestarts <- base::computeRestarts
[08:29:20.378]                         grepl <- base::grepl
[08:29:20.378]                         restarts <- computeRestarts(cond)
[08:29:20.378]                         for (restart in restarts) {
[08:29:20.378]                           name <- restart$name
[08:29:20.378]                           if (is.null(name)) 
[08:29:20.378]                             next
[08:29:20.378]                           if (!grepl(pattern, name)) 
[08:29:20.378]                             next
[08:29:20.378]                           invokeRestart(restart)
[08:29:20.378]                           muffled <- TRUE
[08:29:20.378]                           break
[08:29:20.378]                         }
[08:29:20.378]                       }
[08:29:20.378]                     }
[08:29:20.378]                     invisible(muffled)
[08:29:20.378]                   }
[08:29:20.378]                   muffleCondition(cond)
[08:29:20.378]                 })
[08:29:20.378]             }))
[08:29:20.378]             future::FutureResult(value = ...future.value$value, 
[08:29:20.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.378]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.378]                     ...future.globalenv.names))
[08:29:20.378]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.378]         }, condition = base::local({
[08:29:20.378]             c <- base::c
[08:29:20.378]             inherits <- base::inherits
[08:29:20.378]             invokeRestart <- base::invokeRestart
[08:29:20.378]             length <- base::length
[08:29:20.378]             list <- base::list
[08:29:20.378]             seq.int <- base::seq.int
[08:29:20.378]             signalCondition <- base::signalCondition
[08:29:20.378]             sys.calls <- base::sys.calls
[08:29:20.378]             `[[` <- base::`[[`
[08:29:20.378]             `+` <- base::`+`
[08:29:20.378]             `<<-` <- base::`<<-`
[08:29:20.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.378]                   3L)]
[08:29:20.378]             }
[08:29:20.378]             function(cond) {
[08:29:20.378]                 is_error <- inherits(cond, "error")
[08:29:20.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.378]                   NULL)
[08:29:20.378]                 if (is_error) {
[08:29:20.378]                   sessionInformation <- function() {
[08:29:20.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.378]                       search = base::search(), system = base::Sys.info())
[08:29:20.378]                   }
[08:29:20.378]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.378]                     cond$call), session = sessionInformation(), 
[08:29:20.378]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.378]                   signalCondition(cond)
[08:29:20.378]                 }
[08:29:20.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.378]                 "immediateCondition"))) {
[08:29:20.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.378]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.378]                   if (TRUE && !signal) {
[08:29:20.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.378]                     {
[08:29:20.378]                       inherits <- base::inherits
[08:29:20.378]                       invokeRestart <- base::invokeRestart
[08:29:20.378]                       is.null <- base::is.null
[08:29:20.378]                       muffled <- FALSE
[08:29:20.378]                       if (inherits(cond, "message")) {
[08:29:20.378]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.378]                         if (muffled) 
[08:29:20.378]                           invokeRestart("muffleMessage")
[08:29:20.378]                       }
[08:29:20.378]                       else if (inherits(cond, "warning")) {
[08:29:20.378]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.378]                         if (muffled) 
[08:29:20.378]                           invokeRestart("muffleWarning")
[08:29:20.378]                       }
[08:29:20.378]                       else if (inherits(cond, "condition")) {
[08:29:20.378]                         if (!is.null(pattern)) {
[08:29:20.378]                           computeRestarts <- base::computeRestarts
[08:29:20.378]                           grepl <- base::grepl
[08:29:20.378]                           restarts <- computeRestarts(cond)
[08:29:20.378]                           for (restart in restarts) {
[08:29:20.378]                             name <- restart$name
[08:29:20.378]                             if (is.null(name)) 
[08:29:20.378]                               next
[08:29:20.378]                             if (!grepl(pattern, name)) 
[08:29:20.378]                               next
[08:29:20.378]                             invokeRestart(restart)
[08:29:20.378]                             muffled <- TRUE
[08:29:20.378]                             break
[08:29:20.378]                           }
[08:29:20.378]                         }
[08:29:20.378]                       }
[08:29:20.378]                       invisible(muffled)
[08:29:20.378]                     }
[08:29:20.378]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.378]                   }
[08:29:20.378]                 }
[08:29:20.378]                 else {
[08:29:20.378]                   if (TRUE) {
[08:29:20.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.378]                     {
[08:29:20.378]                       inherits <- base::inherits
[08:29:20.378]                       invokeRestart <- base::invokeRestart
[08:29:20.378]                       is.null <- base::is.null
[08:29:20.378]                       muffled <- FALSE
[08:29:20.378]                       if (inherits(cond, "message")) {
[08:29:20.378]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.378]                         if (muffled) 
[08:29:20.378]                           invokeRestart("muffleMessage")
[08:29:20.378]                       }
[08:29:20.378]                       else if (inherits(cond, "warning")) {
[08:29:20.378]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.378]                         if (muffled) 
[08:29:20.378]                           invokeRestart("muffleWarning")
[08:29:20.378]                       }
[08:29:20.378]                       else if (inherits(cond, "condition")) {
[08:29:20.378]                         if (!is.null(pattern)) {
[08:29:20.378]                           computeRestarts <- base::computeRestarts
[08:29:20.378]                           grepl <- base::grepl
[08:29:20.378]                           restarts <- computeRestarts(cond)
[08:29:20.378]                           for (restart in restarts) {
[08:29:20.378]                             name <- restart$name
[08:29:20.378]                             if (is.null(name)) 
[08:29:20.378]                               next
[08:29:20.378]                             if (!grepl(pattern, name)) 
[08:29:20.378]                               next
[08:29:20.378]                             invokeRestart(restart)
[08:29:20.378]                             muffled <- TRUE
[08:29:20.378]                             break
[08:29:20.378]                           }
[08:29:20.378]                         }
[08:29:20.378]                       }
[08:29:20.378]                       invisible(muffled)
[08:29:20.378]                     }
[08:29:20.378]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.378]                   }
[08:29:20.378]                 }
[08:29:20.378]             }
[08:29:20.378]         }))
[08:29:20.378]     }, error = function(ex) {
[08:29:20.378]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.378]                 ...future.rng), started = ...future.startTime, 
[08:29:20.378]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.378]             version = "1.8"), class = "FutureResult")
[08:29:20.378]     }, finally = {
[08:29:20.378]         if (!identical(...future.workdir, getwd())) 
[08:29:20.378]             setwd(...future.workdir)
[08:29:20.378]         {
[08:29:20.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.378]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.378]             }
[08:29:20.378]             base::options(...future.oldOptions)
[08:29:20.378]             if (.Platform$OS.type == "windows") {
[08:29:20.378]                 old_names <- names(...future.oldEnvVars)
[08:29:20.378]                 envs <- base::Sys.getenv()
[08:29:20.378]                 names <- names(envs)
[08:29:20.378]                 common <- intersect(names, old_names)
[08:29:20.378]                 added <- setdiff(names, old_names)
[08:29:20.378]                 removed <- setdiff(old_names, names)
[08:29:20.378]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.378]                   envs[common]]
[08:29:20.378]                 NAMES <- toupper(changed)
[08:29:20.378]                 args <- list()
[08:29:20.378]                 for (kk in seq_along(NAMES)) {
[08:29:20.378]                   name <- changed[[kk]]
[08:29:20.378]                   NAME <- NAMES[[kk]]
[08:29:20.378]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.378]                     next
[08:29:20.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.378]                 }
[08:29:20.378]                 NAMES <- toupper(added)
[08:29:20.378]                 for (kk in seq_along(NAMES)) {
[08:29:20.378]                   name <- added[[kk]]
[08:29:20.378]                   NAME <- NAMES[[kk]]
[08:29:20.378]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.378]                     next
[08:29:20.378]                   args[[name]] <- ""
[08:29:20.378]                 }
[08:29:20.378]                 NAMES <- toupper(removed)
[08:29:20.378]                 for (kk in seq_along(NAMES)) {
[08:29:20.378]                   name <- removed[[kk]]
[08:29:20.378]                   NAME <- NAMES[[kk]]
[08:29:20.378]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.378]                     next
[08:29:20.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.378]                 }
[08:29:20.378]                 if (length(args) > 0) 
[08:29:20.378]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.378]             }
[08:29:20.378]             else {
[08:29:20.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.378]             }
[08:29:20.378]             {
[08:29:20.378]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.378]                   0L) {
[08:29:20.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.378]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.378]                   base::options(opts)
[08:29:20.378]                 }
[08:29:20.378]                 {
[08:29:20.378]                   {
[08:29:20.378]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.378]                     NULL
[08:29:20.378]                   }
[08:29:20.378]                   options(future.plan = NULL)
[08:29:20.378]                   if (is.na(NA_character_)) 
[08:29:20.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.378]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.378]                     .init = FALSE)
[08:29:20.378]                 }
[08:29:20.378]             }
[08:29:20.378]         }
[08:29:20.378]     })
[08:29:20.378]     if (TRUE) {
[08:29:20.378]         base::sink(type = "output", split = FALSE)
[08:29:20.378]         if (TRUE) {
[08:29:20.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.378]         }
[08:29:20.378]         else {
[08:29:20.378]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.378]         }
[08:29:20.378]         base::close(...future.stdout)
[08:29:20.378]         ...future.stdout <- NULL
[08:29:20.378]     }
[08:29:20.378]     ...future.result$conditions <- ...future.conditions
[08:29:20.378]     ...future.result$finished <- base::Sys.time()
[08:29:20.378]     ...future.result
[08:29:20.378] }
[08:29:20.381] MultisessionFuture started
[08:29:20.381] - Launch lazy future ... done
[08:29:20.381] run() for ‘MultisessionFuture’ ... done
[08:29:20.381] getGlobalsAndPackages() ...
[08:29:20.381] Searching for globals...
[08:29:20.382] - globals found: [2] ‘{’, ‘Sys.sleep’
[08:29:20.382] Searching for globals ... DONE
[08:29:20.382] Resolving globals: FALSE
[08:29:20.383] 
[08:29:20.383] 
[08:29:20.383] getGlobalsAndPackages() ... DONE
[08:29:20.383] run() for ‘Future’ ...
[08:29:20.383] - state: ‘created’
[08:29:20.383] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.397] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.397] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.397]   - Field: ‘node’
[08:29:20.397]   - Field: ‘label’
[08:29:20.398]   - Field: ‘local’
[08:29:20.398]   - Field: ‘owner’
[08:29:20.398]   - Field: ‘envir’
[08:29:20.398]   - Field: ‘workers’
[08:29:20.398]   - Field: ‘packages’
[08:29:20.398]   - Field: ‘gc’
[08:29:20.398]   - Field: ‘conditions’
[08:29:20.398]   - Field: ‘persistent’
[08:29:20.398]   - Field: ‘expr’
[08:29:20.398]   - Field: ‘uuid’
[08:29:20.398]   - Field: ‘seed’
[08:29:20.399]   - Field: ‘version’
[08:29:20.399]   - Field: ‘result’
[08:29:20.399]   - Field: ‘asynchronous’
[08:29:20.399]   - Field: ‘calls’
[08:29:20.399]   - Field: ‘globals’
[08:29:20.399]   - Field: ‘stdout’
[08:29:20.399]   - Field: ‘earlySignal’
[08:29:20.399]   - Field: ‘lazy’
[08:29:20.399]   - Field: ‘state’
[08:29:20.399] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.399] - Launch lazy future ...
[08:29:20.400] Packages needed by the future expression (n = 0): <none>
[08:29:20.400] Packages needed by future strategies (n = 0): <none>
[08:29:20.400] {
[08:29:20.400]     {
[08:29:20.400]         {
[08:29:20.400]             ...future.startTime <- base::Sys.time()
[08:29:20.400]             {
[08:29:20.400]                 {
[08:29:20.400]                   {
[08:29:20.400]                     {
[08:29:20.400]                       base::local({
[08:29:20.400]                         has_future <- base::requireNamespace("future", 
[08:29:20.400]                           quietly = TRUE)
[08:29:20.400]                         if (has_future) {
[08:29:20.400]                           ns <- base::getNamespace("future")
[08:29:20.400]                           version <- ns[[".package"]][["version"]]
[08:29:20.400]                           if (is.null(version)) 
[08:29:20.400]                             version <- utils::packageVersion("future")
[08:29:20.400]                         }
[08:29:20.400]                         else {
[08:29:20.400]                           version <- NULL
[08:29:20.400]                         }
[08:29:20.400]                         if (!has_future || version < "1.8.0") {
[08:29:20.400]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.400]                             "", base::R.version$version.string), 
[08:29:20.400]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.400]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.400]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.400]                               "release", "version")], collapse = " "), 
[08:29:20.400]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.400]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.400]                             info)
[08:29:20.400]                           info <- base::paste(info, collapse = "; ")
[08:29:20.400]                           if (!has_future) {
[08:29:20.400]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.400]                               info)
[08:29:20.400]                           }
[08:29:20.400]                           else {
[08:29:20.400]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.400]                               info, version)
[08:29:20.400]                           }
[08:29:20.400]                           base::stop(msg)
[08:29:20.400]                         }
[08:29:20.400]                       })
[08:29:20.400]                     }
[08:29:20.400]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.400]                     base::options(mc.cores = 1L)
[08:29:20.400]                   }
[08:29:20.400]                   ...future.strategy.old <- future::plan("list")
[08:29:20.400]                   options(future.plan = NULL)
[08:29:20.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.400]                 }
[08:29:20.400]                 ...future.workdir <- getwd()
[08:29:20.400]             }
[08:29:20.400]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.400]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.400]         }
[08:29:20.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.400]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.400]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.400]             base::names(...future.oldOptions))
[08:29:20.400]     }
[08:29:20.400]     if (FALSE) {
[08:29:20.400]     }
[08:29:20.400]     else {
[08:29:20.400]         if (TRUE) {
[08:29:20.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.400]                 open = "w")
[08:29:20.400]         }
[08:29:20.400]         else {
[08:29:20.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.400]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.400]         }
[08:29:20.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.400]             base::sink(type = "output", split = FALSE)
[08:29:20.400]             base::close(...future.stdout)
[08:29:20.400]         }, add = TRUE)
[08:29:20.400]     }
[08:29:20.400]     ...future.frame <- base::sys.nframe()
[08:29:20.400]     ...future.conditions <- base::list()
[08:29:20.400]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.400]     if (FALSE) {
[08:29:20.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.400]     }
[08:29:20.400]     ...future.result <- base::tryCatch({
[08:29:20.400]         base::withCallingHandlers({
[08:29:20.400]             ...future.value <- base::withVisible(base::local({
[08:29:20.400]                 ...future.makeSendCondition <- base::local({
[08:29:20.400]                   sendCondition <- NULL
[08:29:20.400]                   function(frame = 1L) {
[08:29:20.400]                     if (is.function(sendCondition)) 
[08:29:20.400]                       return(sendCondition)
[08:29:20.400]                     ns <- getNamespace("parallel")
[08:29:20.400]                     if (exists("sendData", mode = "function", 
[08:29:20.400]                       envir = ns)) {
[08:29:20.400]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.400]                         envir = ns)
[08:29:20.400]                       envir <- sys.frame(frame)
[08:29:20.400]                       master <- NULL
[08:29:20.400]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.400]                         !identical(envir, emptyenv())) {
[08:29:20.400]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.400]                           inherits = FALSE)) {
[08:29:20.400]                           master <- get("master", mode = "list", 
[08:29:20.400]                             envir = envir, inherits = FALSE)
[08:29:20.400]                           if (inherits(master, c("SOCKnode", 
[08:29:20.400]                             "SOCK0node"))) {
[08:29:20.400]                             sendCondition <<- function(cond) {
[08:29:20.400]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.400]                                 success = TRUE)
[08:29:20.400]                               parallel_sendData(master, data)
[08:29:20.400]                             }
[08:29:20.400]                             return(sendCondition)
[08:29:20.400]                           }
[08:29:20.400]                         }
[08:29:20.400]                         frame <- frame + 1L
[08:29:20.400]                         envir <- sys.frame(frame)
[08:29:20.400]                       }
[08:29:20.400]                     }
[08:29:20.400]                     sendCondition <<- function(cond) NULL
[08:29:20.400]                   }
[08:29:20.400]                 })
[08:29:20.400]                 withCallingHandlers({
[08:29:20.400]                   {
[08:29:20.400]                     Sys.sleep(0.5)
[08:29:20.400]                     2
[08:29:20.400]                   }
[08:29:20.400]                 }, immediateCondition = function(cond) {
[08:29:20.400]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.400]                   sendCondition(cond)
[08:29:20.400]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.400]                   {
[08:29:20.400]                     inherits <- base::inherits
[08:29:20.400]                     invokeRestart <- base::invokeRestart
[08:29:20.400]                     is.null <- base::is.null
[08:29:20.400]                     muffled <- FALSE
[08:29:20.400]                     if (inherits(cond, "message")) {
[08:29:20.400]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.400]                       if (muffled) 
[08:29:20.400]                         invokeRestart("muffleMessage")
[08:29:20.400]                     }
[08:29:20.400]                     else if (inherits(cond, "warning")) {
[08:29:20.400]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.400]                       if (muffled) 
[08:29:20.400]                         invokeRestart("muffleWarning")
[08:29:20.400]                     }
[08:29:20.400]                     else if (inherits(cond, "condition")) {
[08:29:20.400]                       if (!is.null(pattern)) {
[08:29:20.400]                         computeRestarts <- base::computeRestarts
[08:29:20.400]                         grepl <- base::grepl
[08:29:20.400]                         restarts <- computeRestarts(cond)
[08:29:20.400]                         for (restart in restarts) {
[08:29:20.400]                           name <- restart$name
[08:29:20.400]                           if (is.null(name)) 
[08:29:20.400]                             next
[08:29:20.400]                           if (!grepl(pattern, name)) 
[08:29:20.400]                             next
[08:29:20.400]                           invokeRestart(restart)
[08:29:20.400]                           muffled <- TRUE
[08:29:20.400]                           break
[08:29:20.400]                         }
[08:29:20.400]                       }
[08:29:20.400]                     }
[08:29:20.400]                     invisible(muffled)
[08:29:20.400]                   }
[08:29:20.400]                   muffleCondition(cond)
[08:29:20.400]                 })
[08:29:20.400]             }))
[08:29:20.400]             future::FutureResult(value = ...future.value$value, 
[08:29:20.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.400]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.400]                     ...future.globalenv.names))
[08:29:20.400]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.400]         }, condition = base::local({
[08:29:20.400]             c <- base::c
[08:29:20.400]             inherits <- base::inherits
[08:29:20.400]             invokeRestart <- base::invokeRestart
[08:29:20.400]             length <- base::length
[08:29:20.400]             list <- base::list
[08:29:20.400]             seq.int <- base::seq.int
[08:29:20.400]             signalCondition <- base::signalCondition
[08:29:20.400]             sys.calls <- base::sys.calls
[08:29:20.400]             `[[` <- base::`[[`
[08:29:20.400]             `+` <- base::`+`
[08:29:20.400]             `<<-` <- base::`<<-`
[08:29:20.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.400]                   3L)]
[08:29:20.400]             }
[08:29:20.400]             function(cond) {
[08:29:20.400]                 is_error <- inherits(cond, "error")
[08:29:20.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.400]                   NULL)
[08:29:20.400]                 if (is_error) {
[08:29:20.400]                   sessionInformation <- function() {
[08:29:20.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.400]                       search = base::search(), system = base::Sys.info())
[08:29:20.400]                   }
[08:29:20.400]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.400]                     cond$call), session = sessionInformation(), 
[08:29:20.400]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.400]                   signalCondition(cond)
[08:29:20.400]                 }
[08:29:20.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.400]                 "immediateCondition"))) {
[08:29:20.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.400]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.400]                   if (TRUE && !signal) {
[08:29:20.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.400]                     {
[08:29:20.400]                       inherits <- base::inherits
[08:29:20.400]                       invokeRestart <- base::invokeRestart
[08:29:20.400]                       is.null <- base::is.null
[08:29:20.400]                       muffled <- FALSE
[08:29:20.400]                       if (inherits(cond, "message")) {
[08:29:20.400]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.400]                         if (muffled) 
[08:29:20.400]                           invokeRestart("muffleMessage")
[08:29:20.400]                       }
[08:29:20.400]                       else if (inherits(cond, "warning")) {
[08:29:20.400]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.400]                         if (muffled) 
[08:29:20.400]                           invokeRestart("muffleWarning")
[08:29:20.400]                       }
[08:29:20.400]                       else if (inherits(cond, "condition")) {
[08:29:20.400]                         if (!is.null(pattern)) {
[08:29:20.400]                           computeRestarts <- base::computeRestarts
[08:29:20.400]                           grepl <- base::grepl
[08:29:20.400]                           restarts <- computeRestarts(cond)
[08:29:20.400]                           for (restart in restarts) {
[08:29:20.400]                             name <- restart$name
[08:29:20.400]                             if (is.null(name)) 
[08:29:20.400]                               next
[08:29:20.400]                             if (!grepl(pattern, name)) 
[08:29:20.400]                               next
[08:29:20.400]                             invokeRestart(restart)
[08:29:20.400]                             muffled <- TRUE
[08:29:20.400]                             break
[08:29:20.400]                           }
[08:29:20.400]                         }
[08:29:20.400]                       }
[08:29:20.400]                       invisible(muffled)
[08:29:20.400]                     }
[08:29:20.400]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.400]                   }
[08:29:20.400]                 }
[08:29:20.400]                 else {
[08:29:20.400]                   if (TRUE) {
[08:29:20.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.400]                     {
[08:29:20.400]                       inherits <- base::inherits
[08:29:20.400]                       invokeRestart <- base::invokeRestart
[08:29:20.400]                       is.null <- base::is.null
[08:29:20.400]                       muffled <- FALSE
[08:29:20.400]                       if (inherits(cond, "message")) {
[08:29:20.400]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.400]                         if (muffled) 
[08:29:20.400]                           invokeRestart("muffleMessage")
[08:29:20.400]                       }
[08:29:20.400]                       else if (inherits(cond, "warning")) {
[08:29:20.400]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.400]                         if (muffled) 
[08:29:20.400]                           invokeRestart("muffleWarning")
[08:29:20.400]                       }
[08:29:20.400]                       else if (inherits(cond, "condition")) {
[08:29:20.400]                         if (!is.null(pattern)) {
[08:29:20.400]                           computeRestarts <- base::computeRestarts
[08:29:20.400]                           grepl <- base::grepl
[08:29:20.400]                           restarts <- computeRestarts(cond)
[08:29:20.400]                           for (restart in restarts) {
[08:29:20.400]                             name <- restart$name
[08:29:20.400]                             if (is.null(name)) 
[08:29:20.400]                               next
[08:29:20.400]                             if (!grepl(pattern, name)) 
[08:29:20.400]                               next
[08:29:20.400]                             invokeRestart(restart)
[08:29:20.400]                             muffled <- TRUE
[08:29:20.400]                             break
[08:29:20.400]                           }
[08:29:20.400]                         }
[08:29:20.400]                       }
[08:29:20.400]                       invisible(muffled)
[08:29:20.400]                     }
[08:29:20.400]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.400]                   }
[08:29:20.400]                 }
[08:29:20.400]             }
[08:29:20.400]         }))
[08:29:20.400]     }, error = function(ex) {
[08:29:20.400]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.400]                 ...future.rng), started = ...future.startTime, 
[08:29:20.400]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.400]             version = "1.8"), class = "FutureResult")
[08:29:20.400]     }, finally = {
[08:29:20.400]         if (!identical(...future.workdir, getwd())) 
[08:29:20.400]             setwd(...future.workdir)
[08:29:20.400]         {
[08:29:20.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.400]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.400]             }
[08:29:20.400]             base::options(...future.oldOptions)
[08:29:20.400]             if (.Platform$OS.type == "windows") {
[08:29:20.400]                 old_names <- names(...future.oldEnvVars)
[08:29:20.400]                 envs <- base::Sys.getenv()
[08:29:20.400]                 names <- names(envs)
[08:29:20.400]                 common <- intersect(names, old_names)
[08:29:20.400]                 added <- setdiff(names, old_names)
[08:29:20.400]                 removed <- setdiff(old_names, names)
[08:29:20.400]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.400]                   envs[common]]
[08:29:20.400]                 NAMES <- toupper(changed)
[08:29:20.400]                 args <- list()
[08:29:20.400]                 for (kk in seq_along(NAMES)) {
[08:29:20.400]                   name <- changed[[kk]]
[08:29:20.400]                   NAME <- NAMES[[kk]]
[08:29:20.400]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.400]                     next
[08:29:20.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.400]                 }
[08:29:20.400]                 NAMES <- toupper(added)
[08:29:20.400]                 for (kk in seq_along(NAMES)) {
[08:29:20.400]                   name <- added[[kk]]
[08:29:20.400]                   NAME <- NAMES[[kk]]
[08:29:20.400]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.400]                     next
[08:29:20.400]                   args[[name]] <- ""
[08:29:20.400]                 }
[08:29:20.400]                 NAMES <- toupper(removed)
[08:29:20.400]                 for (kk in seq_along(NAMES)) {
[08:29:20.400]                   name <- removed[[kk]]
[08:29:20.400]                   NAME <- NAMES[[kk]]
[08:29:20.400]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.400]                     next
[08:29:20.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.400]                 }
[08:29:20.400]                 if (length(args) > 0) 
[08:29:20.400]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.400]             }
[08:29:20.400]             else {
[08:29:20.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.400]             }
[08:29:20.400]             {
[08:29:20.400]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.400]                   0L) {
[08:29:20.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.400]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.400]                   base::options(opts)
[08:29:20.400]                 }
[08:29:20.400]                 {
[08:29:20.400]                   {
[08:29:20.400]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.400]                     NULL
[08:29:20.400]                   }
[08:29:20.400]                   options(future.plan = NULL)
[08:29:20.400]                   if (is.na(NA_character_)) 
[08:29:20.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.400]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.400]                     .init = FALSE)
[08:29:20.400]                 }
[08:29:20.400]             }
[08:29:20.400]         }
[08:29:20.400]     })
[08:29:20.400]     if (TRUE) {
[08:29:20.400]         base::sink(type = "output", split = FALSE)
[08:29:20.400]         if (TRUE) {
[08:29:20.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.400]         }
[08:29:20.400]         else {
[08:29:20.400]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.400]         }
[08:29:20.400]         base::close(...future.stdout)
[08:29:20.400]         ...future.stdout <- NULL
[08:29:20.400]     }
[08:29:20.400]     ...future.result$conditions <- ...future.conditions
[08:29:20.400]     ...future.result$finished <- base::Sys.time()
[08:29:20.400]     ...future.result
[08:29:20.400] }
[08:29:20.403] MultisessionFuture started
[08:29:20.403] - Launch lazy future ... done
[08:29:20.403] run() for ‘MultisessionFuture’ ... done
[08:29:20.404] resolve() on list ...
[08:29:20.404]  recursive: 0
[08:29:20.404]  length: 1
[08:29:20.404] 
[08:29:20.425] receiveMessageFromWorker() for ClusterFuture ...
[08:29:20.425] - Validating connection of MultisessionFuture
[08:29:20.425] - received message: FutureResult
[08:29:20.425] - Received FutureResult
[08:29:20.426] - Erased future from FutureRegistry
[08:29:20.426] result() for ClusterFuture ...
[08:29:20.426] - result already collected: FutureResult
[08:29:20.426] result() for ClusterFuture ... done
[08:29:20.426] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:20.426] Future #1
[08:29:20.426]  length: 0 (resolved future 1)
[08:29:20.426] resolve() on list ... DONE
[08:29:20.426] resolve() on list ...
[08:29:20.427]  recursive: 0
[08:29:20.427]  length: 1
[08:29:20.427] 
[08:29:20.946] receiveMessageFromWorker() for ClusterFuture ...
[08:29:20.946] - Validating connection of MultisessionFuture
[08:29:20.946] - received message: FutureResult
[08:29:20.946] - Received FutureResult
[08:29:20.947] - Erased future from FutureRegistry
[08:29:20.947] result() for ClusterFuture ...
[08:29:20.947] - result already collected: FutureResult
[08:29:20.947] result() for ClusterFuture ... done
[08:29:20.947] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:20.947] Future #1
[08:29:20.947]  length: 0 (resolved future 1)
[08:29:20.947] resolve() on list ... DONE
[08:29:20.947] resolve() on list ...
[08:29:20.948]  recursive: 0
[08:29:20.948]  length: 1
[08:29:20.948] 
[08:29:20.948]  length: 0 (resolved future 1)
[08:29:20.948] resolve() on list ... DONE
[08:29:20.948] resolve() on list ...
[08:29:20.948]  recursive: 0
[08:29:20.948]  length: 4
[08:29:20.948] 
[08:29:20.948] Future #1
[08:29:20.949]  length: 3 (resolved future 1)
[08:29:20.949] Future #2
[08:29:20.949]  length: 2 (resolved future 2)
[08:29:20.949]  length: 1 (resolved future 3)
[08:29:20.949]  length: 0 (resolved future 4)
[08:29:20.949] resolve() on list ... DONE
[08:29:20.949] resolve() on list ...
[08:29:20.949]  recursive: 0
[08:29:20.949]  length: 4
[08:29:20.949] 
[08:29:20.949] Future #1
[08:29:20.950]  length: 3 (resolved future 1)
[08:29:20.950] Future #2
[08:29:20.950]  length: 2 (resolved future 2)
[08:29:20.950]  length: 1 (resolved future 3)
[08:29:20.950]  length: 0 (resolved future 4)
[08:29:20.950] resolve() on list ... DONE
[08:29:20.950] resolve() on list ...
[08:29:20.950]  recursive: 0
[08:29:20.950]  length: 1
[08:29:20.950] 
[08:29:20.951]  length: 0 (resolved future 1)
[08:29:20.951] resolve() on list ... DONE
[08:29:20.951] getGlobalsAndPackages() ...
[08:29:20.951] Searching for globals...
[08:29:20.952] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:20.952] Searching for globals ... DONE
[08:29:20.952] Resolving globals: FALSE
[08:29:20.952] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:20.953] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:20.953] - globals: [1] ‘kk’
[08:29:20.953] 
[08:29:20.953] getGlobalsAndPackages() ... DONE
[08:29:20.953] run() for ‘Future’ ...
[08:29:20.953] - state: ‘created’
[08:29:20.954] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.968] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.968] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.968]   - Field: ‘node’
[08:29:20.968]   - Field: ‘label’
[08:29:20.968]   - Field: ‘local’
[08:29:20.968]   - Field: ‘owner’
[08:29:20.968]   - Field: ‘envir’
[08:29:20.968]   - Field: ‘workers’
[08:29:20.968]   - Field: ‘packages’
[08:29:20.968]   - Field: ‘gc’
[08:29:20.968]   - Field: ‘conditions’
[08:29:20.969]   - Field: ‘persistent’
[08:29:20.969]   - Field: ‘expr’
[08:29:20.969]   - Field: ‘uuid’
[08:29:20.969]   - Field: ‘seed’
[08:29:20.969]   - Field: ‘version’
[08:29:20.969]   - Field: ‘result’
[08:29:20.969]   - Field: ‘asynchronous’
[08:29:20.969]   - Field: ‘calls’
[08:29:20.969]   - Field: ‘globals’
[08:29:20.969]   - Field: ‘stdout’
[08:29:20.969]   - Field: ‘earlySignal’
[08:29:20.969]   - Field: ‘lazy’
[08:29:20.970]   - Field: ‘state’
[08:29:20.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.970] - Launch lazy future ...
[08:29:20.970] Packages needed by the future expression (n = 0): <none>
[08:29:20.973] Packages needed by future strategies (n = 0): <none>
[08:29:20.973] {
[08:29:20.973]     {
[08:29:20.973]         {
[08:29:20.973]             ...future.startTime <- base::Sys.time()
[08:29:20.973]             {
[08:29:20.973]                 {
[08:29:20.973]                   {
[08:29:20.973]                     {
[08:29:20.973]                       base::local({
[08:29:20.973]                         has_future <- base::requireNamespace("future", 
[08:29:20.973]                           quietly = TRUE)
[08:29:20.973]                         if (has_future) {
[08:29:20.973]                           ns <- base::getNamespace("future")
[08:29:20.973]                           version <- ns[[".package"]][["version"]]
[08:29:20.973]                           if (is.null(version)) 
[08:29:20.973]                             version <- utils::packageVersion("future")
[08:29:20.973]                         }
[08:29:20.973]                         else {
[08:29:20.973]                           version <- NULL
[08:29:20.973]                         }
[08:29:20.973]                         if (!has_future || version < "1.8.0") {
[08:29:20.973]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.973]                             "", base::R.version$version.string), 
[08:29:20.973]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.973]                               "release", "version")], collapse = " "), 
[08:29:20.973]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.973]                             info)
[08:29:20.973]                           info <- base::paste(info, collapse = "; ")
[08:29:20.973]                           if (!has_future) {
[08:29:20.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.973]                               info)
[08:29:20.973]                           }
[08:29:20.973]                           else {
[08:29:20.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.973]                               info, version)
[08:29:20.973]                           }
[08:29:20.973]                           base::stop(msg)
[08:29:20.973]                         }
[08:29:20.973]                       })
[08:29:20.973]                     }
[08:29:20.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.973]                     base::options(mc.cores = 1L)
[08:29:20.973]                   }
[08:29:20.973]                   ...future.strategy.old <- future::plan("list")
[08:29:20.973]                   options(future.plan = NULL)
[08:29:20.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.973]                 }
[08:29:20.973]                 ...future.workdir <- getwd()
[08:29:20.973]             }
[08:29:20.973]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.973]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.973]         }
[08:29:20.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.973]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.973]             base::names(...future.oldOptions))
[08:29:20.973]     }
[08:29:20.973]     if (FALSE) {
[08:29:20.973]     }
[08:29:20.973]     else {
[08:29:20.973]         if (TRUE) {
[08:29:20.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.973]                 open = "w")
[08:29:20.973]         }
[08:29:20.973]         else {
[08:29:20.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.973]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.973]         }
[08:29:20.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.973]             base::sink(type = "output", split = FALSE)
[08:29:20.973]             base::close(...future.stdout)
[08:29:20.973]         }, add = TRUE)
[08:29:20.973]     }
[08:29:20.973]     ...future.frame <- base::sys.nframe()
[08:29:20.973]     ...future.conditions <- base::list()
[08:29:20.973]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.973]     if (FALSE) {
[08:29:20.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.973]     }
[08:29:20.973]     ...future.result <- base::tryCatch({
[08:29:20.973]         base::withCallingHandlers({
[08:29:20.973]             ...future.value <- base::withVisible(base::local({
[08:29:20.973]                 ...future.makeSendCondition <- base::local({
[08:29:20.973]                   sendCondition <- NULL
[08:29:20.973]                   function(frame = 1L) {
[08:29:20.973]                     if (is.function(sendCondition)) 
[08:29:20.973]                       return(sendCondition)
[08:29:20.973]                     ns <- getNamespace("parallel")
[08:29:20.973]                     if (exists("sendData", mode = "function", 
[08:29:20.973]                       envir = ns)) {
[08:29:20.973]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.973]                         envir = ns)
[08:29:20.973]                       envir <- sys.frame(frame)
[08:29:20.973]                       master <- NULL
[08:29:20.973]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.973]                         !identical(envir, emptyenv())) {
[08:29:20.973]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.973]                           inherits = FALSE)) {
[08:29:20.973]                           master <- get("master", mode = "list", 
[08:29:20.973]                             envir = envir, inherits = FALSE)
[08:29:20.973]                           if (inherits(master, c("SOCKnode", 
[08:29:20.973]                             "SOCK0node"))) {
[08:29:20.973]                             sendCondition <<- function(cond) {
[08:29:20.973]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.973]                                 success = TRUE)
[08:29:20.973]                               parallel_sendData(master, data)
[08:29:20.973]                             }
[08:29:20.973]                             return(sendCondition)
[08:29:20.973]                           }
[08:29:20.973]                         }
[08:29:20.973]                         frame <- frame + 1L
[08:29:20.973]                         envir <- sys.frame(frame)
[08:29:20.973]                       }
[08:29:20.973]                     }
[08:29:20.973]                     sendCondition <<- function(cond) NULL
[08:29:20.973]                   }
[08:29:20.973]                 })
[08:29:20.973]                 withCallingHandlers({
[08:29:20.973]                   {
[08:29:20.973]                     Sys.sleep(0.1)
[08:29:20.973]                     kk
[08:29:20.973]                   }
[08:29:20.973]                 }, immediateCondition = function(cond) {
[08:29:20.973]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.973]                   sendCondition(cond)
[08:29:20.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.973]                   {
[08:29:20.973]                     inherits <- base::inherits
[08:29:20.973]                     invokeRestart <- base::invokeRestart
[08:29:20.973]                     is.null <- base::is.null
[08:29:20.973]                     muffled <- FALSE
[08:29:20.973]                     if (inherits(cond, "message")) {
[08:29:20.973]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.973]                       if (muffled) 
[08:29:20.973]                         invokeRestart("muffleMessage")
[08:29:20.973]                     }
[08:29:20.973]                     else if (inherits(cond, "warning")) {
[08:29:20.973]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.973]                       if (muffled) 
[08:29:20.973]                         invokeRestart("muffleWarning")
[08:29:20.973]                     }
[08:29:20.973]                     else if (inherits(cond, "condition")) {
[08:29:20.973]                       if (!is.null(pattern)) {
[08:29:20.973]                         computeRestarts <- base::computeRestarts
[08:29:20.973]                         grepl <- base::grepl
[08:29:20.973]                         restarts <- computeRestarts(cond)
[08:29:20.973]                         for (restart in restarts) {
[08:29:20.973]                           name <- restart$name
[08:29:20.973]                           if (is.null(name)) 
[08:29:20.973]                             next
[08:29:20.973]                           if (!grepl(pattern, name)) 
[08:29:20.973]                             next
[08:29:20.973]                           invokeRestart(restart)
[08:29:20.973]                           muffled <- TRUE
[08:29:20.973]                           break
[08:29:20.973]                         }
[08:29:20.973]                       }
[08:29:20.973]                     }
[08:29:20.973]                     invisible(muffled)
[08:29:20.973]                   }
[08:29:20.973]                   muffleCondition(cond)
[08:29:20.973]                 })
[08:29:20.973]             }))
[08:29:20.973]             future::FutureResult(value = ...future.value$value, 
[08:29:20.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.973]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.973]                     ...future.globalenv.names))
[08:29:20.973]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.973]         }, condition = base::local({
[08:29:20.973]             c <- base::c
[08:29:20.973]             inherits <- base::inherits
[08:29:20.973]             invokeRestart <- base::invokeRestart
[08:29:20.973]             length <- base::length
[08:29:20.973]             list <- base::list
[08:29:20.973]             seq.int <- base::seq.int
[08:29:20.973]             signalCondition <- base::signalCondition
[08:29:20.973]             sys.calls <- base::sys.calls
[08:29:20.973]             `[[` <- base::`[[`
[08:29:20.973]             `+` <- base::`+`
[08:29:20.973]             `<<-` <- base::`<<-`
[08:29:20.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.973]                   3L)]
[08:29:20.973]             }
[08:29:20.973]             function(cond) {
[08:29:20.973]                 is_error <- inherits(cond, "error")
[08:29:20.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.973]                   NULL)
[08:29:20.973]                 if (is_error) {
[08:29:20.973]                   sessionInformation <- function() {
[08:29:20.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.973]                       search = base::search(), system = base::Sys.info())
[08:29:20.973]                   }
[08:29:20.973]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.973]                     cond$call), session = sessionInformation(), 
[08:29:20.973]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.973]                   signalCondition(cond)
[08:29:20.973]                 }
[08:29:20.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.973]                 "immediateCondition"))) {
[08:29:20.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.973]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.973]                   if (TRUE && !signal) {
[08:29:20.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.973]                     {
[08:29:20.973]                       inherits <- base::inherits
[08:29:20.973]                       invokeRestart <- base::invokeRestart
[08:29:20.973]                       is.null <- base::is.null
[08:29:20.973]                       muffled <- FALSE
[08:29:20.973]                       if (inherits(cond, "message")) {
[08:29:20.973]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.973]                         if (muffled) 
[08:29:20.973]                           invokeRestart("muffleMessage")
[08:29:20.973]                       }
[08:29:20.973]                       else if (inherits(cond, "warning")) {
[08:29:20.973]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.973]                         if (muffled) 
[08:29:20.973]                           invokeRestart("muffleWarning")
[08:29:20.973]                       }
[08:29:20.973]                       else if (inherits(cond, "condition")) {
[08:29:20.973]                         if (!is.null(pattern)) {
[08:29:20.973]                           computeRestarts <- base::computeRestarts
[08:29:20.973]                           grepl <- base::grepl
[08:29:20.973]                           restarts <- computeRestarts(cond)
[08:29:20.973]                           for (restart in restarts) {
[08:29:20.973]                             name <- restart$name
[08:29:20.973]                             if (is.null(name)) 
[08:29:20.973]                               next
[08:29:20.973]                             if (!grepl(pattern, name)) 
[08:29:20.973]                               next
[08:29:20.973]                             invokeRestart(restart)
[08:29:20.973]                             muffled <- TRUE
[08:29:20.973]                             break
[08:29:20.973]                           }
[08:29:20.973]                         }
[08:29:20.973]                       }
[08:29:20.973]                       invisible(muffled)
[08:29:20.973]                     }
[08:29:20.973]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.973]                   }
[08:29:20.973]                 }
[08:29:20.973]                 else {
[08:29:20.973]                   if (TRUE) {
[08:29:20.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.973]                     {
[08:29:20.973]                       inherits <- base::inherits
[08:29:20.973]                       invokeRestart <- base::invokeRestart
[08:29:20.973]                       is.null <- base::is.null
[08:29:20.973]                       muffled <- FALSE
[08:29:20.973]                       if (inherits(cond, "message")) {
[08:29:20.973]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.973]                         if (muffled) 
[08:29:20.973]                           invokeRestart("muffleMessage")
[08:29:20.973]                       }
[08:29:20.973]                       else if (inherits(cond, "warning")) {
[08:29:20.973]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.973]                         if (muffled) 
[08:29:20.973]                           invokeRestart("muffleWarning")
[08:29:20.973]                       }
[08:29:20.973]                       else if (inherits(cond, "condition")) {
[08:29:20.973]                         if (!is.null(pattern)) {
[08:29:20.973]                           computeRestarts <- base::computeRestarts
[08:29:20.973]                           grepl <- base::grepl
[08:29:20.973]                           restarts <- computeRestarts(cond)
[08:29:20.973]                           for (restart in restarts) {
[08:29:20.973]                             name <- restart$name
[08:29:20.973]                             if (is.null(name)) 
[08:29:20.973]                               next
[08:29:20.973]                             if (!grepl(pattern, name)) 
[08:29:20.973]                               next
[08:29:20.973]                             invokeRestart(restart)
[08:29:20.973]                             muffled <- TRUE
[08:29:20.973]                             break
[08:29:20.973]                           }
[08:29:20.973]                         }
[08:29:20.973]                       }
[08:29:20.973]                       invisible(muffled)
[08:29:20.973]                     }
[08:29:20.973]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.973]                   }
[08:29:20.973]                 }
[08:29:20.973]             }
[08:29:20.973]         }))
[08:29:20.973]     }, error = function(ex) {
[08:29:20.973]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.973]                 ...future.rng), started = ...future.startTime, 
[08:29:20.973]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.973]             version = "1.8"), class = "FutureResult")
[08:29:20.973]     }, finally = {
[08:29:20.973]         if (!identical(...future.workdir, getwd())) 
[08:29:20.973]             setwd(...future.workdir)
[08:29:20.973]         {
[08:29:20.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.973]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.973]             }
[08:29:20.973]             base::options(...future.oldOptions)
[08:29:20.973]             if (.Platform$OS.type == "windows") {
[08:29:20.973]                 old_names <- names(...future.oldEnvVars)
[08:29:20.973]                 envs <- base::Sys.getenv()
[08:29:20.973]                 names <- names(envs)
[08:29:20.973]                 common <- intersect(names, old_names)
[08:29:20.973]                 added <- setdiff(names, old_names)
[08:29:20.973]                 removed <- setdiff(old_names, names)
[08:29:20.973]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.973]                   envs[common]]
[08:29:20.973]                 NAMES <- toupper(changed)
[08:29:20.973]                 args <- list()
[08:29:20.973]                 for (kk in seq_along(NAMES)) {
[08:29:20.973]                   name <- changed[[kk]]
[08:29:20.973]                   NAME <- NAMES[[kk]]
[08:29:20.973]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.973]                     next
[08:29:20.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.973]                 }
[08:29:20.973]                 NAMES <- toupper(added)
[08:29:20.973]                 for (kk in seq_along(NAMES)) {
[08:29:20.973]                   name <- added[[kk]]
[08:29:20.973]                   NAME <- NAMES[[kk]]
[08:29:20.973]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.973]                     next
[08:29:20.973]                   args[[name]] <- ""
[08:29:20.973]                 }
[08:29:20.973]                 NAMES <- toupper(removed)
[08:29:20.973]                 for (kk in seq_along(NAMES)) {
[08:29:20.973]                   name <- removed[[kk]]
[08:29:20.973]                   NAME <- NAMES[[kk]]
[08:29:20.973]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.973]                     next
[08:29:20.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.973]                 }
[08:29:20.973]                 if (length(args) > 0) 
[08:29:20.973]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.973]             }
[08:29:20.973]             else {
[08:29:20.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.973]             }
[08:29:20.973]             {
[08:29:20.973]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.973]                   0L) {
[08:29:20.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.973]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.973]                   base::options(opts)
[08:29:20.973]                 }
[08:29:20.973]                 {
[08:29:20.973]                   {
[08:29:20.973]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.973]                     NULL
[08:29:20.973]                   }
[08:29:20.973]                   options(future.plan = NULL)
[08:29:20.973]                   if (is.na(NA_character_)) 
[08:29:20.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.973]                     .init = FALSE)
[08:29:20.973]                 }
[08:29:20.973]             }
[08:29:20.973]         }
[08:29:20.973]     })
[08:29:20.973]     if (TRUE) {
[08:29:20.973]         base::sink(type = "output", split = FALSE)
[08:29:20.973]         if (TRUE) {
[08:29:20.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.973]         }
[08:29:20.973]         else {
[08:29:20.973]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.973]         }
[08:29:20.973]         base::close(...future.stdout)
[08:29:20.973]         ...future.stdout <- NULL
[08:29:20.973]     }
[08:29:20.973]     ...future.result$conditions <- ...future.conditions
[08:29:20.973]     ...future.result$finished <- base::Sys.time()
[08:29:20.973]     ...future.result
[08:29:20.973] }
[08:29:20.976] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[08:29:20.976] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[08:29:20.977] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[08:29:20.977] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[08:29:20.977] MultisessionFuture started
[08:29:20.977] - Launch lazy future ... done
[08:29:20.977] run() for ‘MultisessionFuture’ ... done
[08:29:20.978] getGlobalsAndPackages() ...
[08:29:20.978] Searching for globals...
[08:29:20.979] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:20.979] Searching for globals ... DONE
[08:29:20.979] Resolving globals: FALSE
[08:29:20.979] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:20.979] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:20.980] - globals: [1] ‘kk’
[08:29:20.980] 
[08:29:20.980] getGlobalsAndPackages() ... DONE
[08:29:20.980] run() for ‘Future’ ...
[08:29:20.980] - state: ‘created’
[08:29:20.980] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:20.994] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:20.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:20.994]   - Field: ‘node’
[08:29:20.994]   - Field: ‘label’
[08:29:20.994]   - Field: ‘local’
[08:29:20.994]   - Field: ‘owner’
[08:29:20.995]   - Field: ‘envir’
[08:29:20.995]   - Field: ‘workers’
[08:29:20.995]   - Field: ‘packages’
[08:29:20.995]   - Field: ‘gc’
[08:29:20.995]   - Field: ‘conditions’
[08:29:20.995]   - Field: ‘persistent’
[08:29:20.995]   - Field: ‘expr’
[08:29:20.995]   - Field: ‘uuid’
[08:29:20.995]   - Field: ‘seed’
[08:29:20.995]   - Field: ‘version’
[08:29:20.995]   - Field: ‘result’
[08:29:20.995]   - Field: ‘asynchronous’
[08:29:20.996]   - Field: ‘calls’
[08:29:20.996]   - Field: ‘globals’
[08:29:20.996]   - Field: ‘stdout’
[08:29:20.996]   - Field: ‘earlySignal’
[08:29:20.996]   - Field: ‘lazy’
[08:29:20.996]   - Field: ‘state’
[08:29:20.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:20.996] - Launch lazy future ...
[08:29:20.996] Packages needed by the future expression (n = 0): <none>
[08:29:20.996] Packages needed by future strategies (n = 0): <none>
[08:29:20.997] {
[08:29:20.997]     {
[08:29:20.997]         {
[08:29:20.997]             ...future.startTime <- base::Sys.time()
[08:29:20.997]             {
[08:29:20.997]                 {
[08:29:20.997]                   {
[08:29:20.997]                     {
[08:29:20.997]                       base::local({
[08:29:20.997]                         has_future <- base::requireNamespace("future", 
[08:29:20.997]                           quietly = TRUE)
[08:29:20.997]                         if (has_future) {
[08:29:20.997]                           ns <- base::getNamespace("future")
[08:29:20.997]                           version <- ns[[".package"]][["version"]]
[08:29:20.997]                           if (is.null(version)) 
[08:29:20.997]                             version <- utils::packageVersion("future")
[08:29:20.997]                         }
[08:29:20.997]                         else {
[08:29:20.997]                           version <- NULL
[08:29:20.997]                         }
[08:29:20.997]                         if (!has_future || version < "1.8.0") {
[08:29:20.997]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:20.997]                             "", base::R.version$version.string), 
[08:29:20.997]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:20.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:20.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:20.997]                               "release", "version")], collapse = " "), 
[08:29:20.997]                             hostname = base::Sys.info()[["nodename"]])
[08:29:20.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:20.997]                             info)
[08:29:20.997]                           info <- base::paste(info, collapse = "; ")
[08:29:20.997]                           if (!has_future) {
[08:29:20.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:20.997]                               info)
[08:29:20.997]                           }
[08:29:20.997]                           else {
[08:29:20.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:20.997]                               info, version)
[08:29:20.997]                           }
[08:29:20.997]                           base::stop(msg)
[08:29:20.997]                         }
[08:29:20.997]                       })
[08:29:20.997]                     }
[08:29:20.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:20.997]                     base::options(mc.cores = 1L)
[08:29:20.997]                   }
[08:29:20.997]                   ...future.strategy.old <- future::plan("list")
[08:29:20.997]                   options(future.plan = NULL)
[08:29:20.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:20.997]                 }
[08:29:20.997]                 ...future.workdir <- getwd()
[08:29:20.997]             }
[08:29:20.997]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:20.997]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:20.997]         }
[08:29:20.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:20.997]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:20.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:20.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:20.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:20.997]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:20.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:20.997]             base::names(...future.oldOptions))
[08:29:20.997]     }
[08:29:20.997]     if (FALSE) {
[08:29:20.997]     }
[08:29:20.997]     else {
[08:29:20.997]         if (TRUE) {
[08:29:20.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:20.997]                 open = "w")
[08:29:20.997]         }
[08:29:20.997]         else {
[08:29:20.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:20.997]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:20.997]         }
[08:29:20.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:20.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:20.997]             base::sink(type = "output", split = FALSE)
[08:29:20.997]             base::close(...future.stdout)
[08:29:20.997]         }, add = TRUE)
[08:29:20.997]     }
[08:29:20.997]     ...future.frame <- base::sys.nframe()
[08:29:20.997]     ...future.conditions <- base::list()
[08:29:20.997]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:20.997]     if (FALSE) {
[08:29:20.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:20.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:20.997]     }
[08:29:20.997]     ...future.result <- base::tryCatch({
[08:29:20.997]         base::withCallingHandlers({
[08:29:20.997]             ...future.value <- base::withVisible(base::local({
[08:29:20.997]                 ...future.makeSendCondition <- base::local({
[08:29:20.997]                   sendCondition <- NULL
[08:29:20.997]                   function(frame = 1L) {
[08:29:20.997]                     if (is.function(sendCondition)) 
[08:29:20.997]                       return(sendCondition)
[08:29:20.997]                     ns <- getNamespace("parallel")
[08:29:20.997]                     if (exists("sendData", mode = "function", 
[08:29:20.997]                       envir = ns)) {
[08:29:20.997]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:20.997]                         envir = ns)
[08:29:20.997]                       envir <- sys.frame(frame)
[08:29:20.997]                       master <- NULL
[08:29:20.997]                       while (!identical(envir, .GlobalEnv) && 
[08:29:20.997]                         !identical(envir, emptyenv())) {
[08:29:20.997]                         if (exists("master", mode = "list", envir = envir, 
[08:29:20.997]                           inherits = FALSE)) {
[08:29:20.997]                           master <- get("master", mode = "list", 
[08:29:20.997]                             envir = envir, inherits = FALSE)
[08:29:20.997]                           if (inherits(master, c("SOCKnode", 
[08:29:20.997]                             "SOCK0node"))) {
[08:29:20.997]                             sendCondition <<- function(cond) {
[08:29:20.997]                               data <- list(type = "VALUE", value = cond, 
[08:29:20.997]                                 success = TRUE)
[08:29:20.997]                               parallel_sendData(master, data)
[08:29:20.997]                             }
[08:29:20.997]                             return(sendCondition)
[08:29:20.997]                           }
[08:29:20.997]                         }
[08:29:20.997]                         frame <- frame + 1L
[08:29:20.997]                         envir <- sys.frame(frame)
[08:29:20.997]                       }
[08:29:20.997]                     }
[08:29:20.997]                     sendCondition <<- function(cond) NULL
[08:29:20.997]                   }
[08:29:20.997]                 })
[08:29:20.997]                 withCallingHandlers({
[08:29:20.997]                   {
[08:29:20.997]                     Sys.sleep(0.1)
[08:29:20.997]                     kk
[08:29:20.997]                   }
[08:29:20.997]                 }, immediateCondition = function(cond) {
[08:29:20.997]                   sendCondition <- ...future.makeSendCondition()
[08:29:20.997]                   sendCondition(cond)
[08:29:20.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.997]                   {
[08:29:20.997]                     inherits <- base::inherits
[08:29:20.997]                     invokeRestart <- base::invokeRestart
[08:29:20.997]                     is.null <- base::is.null
[08:29:20.997]                     muffled <- FALSE
[08:29:20.997]                     if (inherits(cond, "message")) {
[08:29:20.997]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:20.997]                       if (muffled) 
[08:29:20.997]                         invokeRestart("muffleMessage")
[08:29:20.997]                     }
[08:29:20.997]                     else if (inherits(cond, "warning")) {
[08:29:20.997]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:20.997]                       if (muffled) 
[08:29:20.997]                         invokeRestart("muffleWarning")
[08:29:20.997]                     }
[08:29:20.997]                     else if (inherits(cond, "condition")) {
[08:29:20.997]                       if (!is.null(pattern)) {
[08:29:20.997]                         computeRestarts <- base::computeRestarts
[08:29:20.997]                         grepl <- base::grepl
[08:29:20.997]                         restarts <- computeRestarts(cond)
[08:29:20.997]                         for (restart in restarts) {
[08:29:20.997]                           name <- restart$name
[08:29:20.997]                           if (is.null(name)) 
[08:29:20.997]                             next
[08:29:20.997]                           if (!grepl(pattern, name)) 
[08:29:20.997]                             next
[08:29:20.997]                           invokeRestart(restart)
[08:29:20.997]                           muffled <- TRUE
[08:29:20.997]                           break
[08:29:20.997]                         }
[08:29:20.997]                       }
[08:29:20.997]                     }
[08:29:20.997]                     invisible(muffled)
[08:29:20.997]                   }
[08:29:20.997]                   muffleCondition(cond)
[08:29:20.997]                 })
[08:29:20.997]             }))
[08:29:20.997]             future::FutureResult(value = ...future.value$value, 
[08:29:20.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.997]                   ...future.rng), globalenv = if (FALSE) 
[08:29:20.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:20.997]                     ...future.globalenv.names))
[08:29:20.997]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:20.997]         }, condition = base::local({
[08:29:20.997]             c <- base::c
[08:29:20.997]             inherits <- base::inherits
[08:29:20.997]             invokeRestart <- base::invokeRestart
[08:29:20.997]             length <- base::length
[08:29:20.997]             list <- base::list
[08:29:20.997]             seq.int <- base::seq.int
[08:29:20.997]             signalCondition <- base::signalCondition
[08:29:20.997]             sys.calls <- base::sys.calls
[08:29:20.997]             `[[` <- base::`[[`
[08:29:20.997]             `+` <- base::`+`
[08:29:20.997]             `<<-` <- base::`<<-`
[08:29:20.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:20.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:20.997]                   3L)]
[08:29:20.997]             }
[08:29:20.997]             function(cond) {
[08:29:20.997]                 is_error <- inherits(cond, "error")
[08:29:20.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:20.997]                   NULL)
[08:29:20.997]                 if (is_error) {
[08:29:20.997]                   sessionInformation <- function() {
[08:29:20.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:20.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:20.997]                       search = base::search(), system = base::Sys.info())
[08:29:20.997]                   }
[08:29:20.997]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:20.997]                     cond$call), session = sessionInformation(), 
[08:29:20.997]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:20.997]                   signalCondition(cond)
[08:29:20.997]                 }
[08:29:20.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:20.997]                 "immediateCondition"))) {
[08:29:20.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:20.997]                   ...future.conditions[[length(...future.conditions) + 
[08:29:20.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:20.997]                   if (TRUE && !signal) {
[08:29:20.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.997]                     {
[08:29:20.997]                       inherits <- base::inherits
[08:29:20.997]                       invokeRestart <- base::invokeRestart
[08:29:20.997]                       is.null <- base::is.null
[08:29:20.997]                       muffled <- FALSE
[08:29:20.997]                       if (inherits(cond, "message")) {
[08:29:20.997]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.997]                         if (muffled) 
[08:29:20.997]                           invokeRestart("muffleMessage")
[08:29:20.997]                       }
[08:29:20.997]                       else if (inherits(cond, "warning")) {
[08:29:20.997]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.997]                         if (muffled) 
[08:29:20.997]                           invokeRestart("muffleWarning")
[08:29:20.997]                       }
[08:29:20.997]                       else if (inherits(cond, "condition")) {
[08:29:20.997]                         if (!is.null(pattern)) {
[08:29:20.997]                           computeRestarts <- base::computeRestarts
[08:29:20.997]                           grepl <- base::grepl
[08:29:20.997]                           restarts <- computeRestarts(cond)
[08:29:20.997]                           for (restart in restarts) {
[08:29:20.997]                             name <- restart$name
[08:29:20.997]                             if (is.null(name)) 
[08:29:20.997]                               next
[08:29:20.997]                             if (!grepl(pattern, name)) 
[08:29:20.997]                               next
[08:29:20.997]                             invokeRestart(restart)
[08:29:20.997]                             muffled <- TRUE
[08:29:20.997]                             break
[08:29:20.997]                           }
[08:29:20.997]                         }
[08:29:20.997]                       }
[08:29:20.997]                       invisible(muffled)
[08:29:20.997]                     }
[08:29:20.997]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.997]                   }
[08:29:20.997]                 }
[08:29:20.997]                 else {
[08:29:20.997]                   if (TRUE) {
[08:29:20.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:20.997]                     {
[08:29:20.997]                       inherits <- base::inherits
[08:29:20.997]                       invokeRestart <- base::invokeRestart
[08:29:20.997]                       is.null <- base::is.null
[08:29:20.997]                       muffled <- FALSE
[08:29:20.997]                       if (inherits(cond, "message")) {
[08:29:20.997]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:20.997]                         if (muffled) 
[08:29:20.997]                           invokeRestart("muffleMessage")
[08:29:20.997]                       }
[08:29:20.997]                       else if (inherits(cond, "warning")) {
[08:29:20.997]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:20.997]                         if (muffled) 
[08:29:20.997]                           invokeRestart("muffleWarning")
[08:29:20.997]                       }
[08:29:20.997]                       else if (inherits(cond, "condition")) {
[08:29:20.997]                         if (!is.null(pattern)) {
[08:29:20.997]                           computeRestarts <- base::computeRestarts
[08:29:20.997]                           grepl <- base::grepl
[08:29:20.997]                           restarts <- computeRestarts(cond)
[08:29:20.997]                           for (restart in restarts) {
[08:29:20.997]                             name <- restart$name
[08:29:20.997]                             if (is.null(name)) 
[08:29:20.997]                               next
[08:29:20.997]                             if (!grepl(pattern, name)) 
[08:29:20.997]                               next
[08:29:20.997]                             invokeRestart(restart)
[08:29:20.997]                             muffled <- TRUE
[08:29:20.997]                             break
[08:29:20.997]                           }
[08:29:20.997]                         }
[08:29:20.997]                       }
[08:29:20.997]                       invisible(muffled)
[08:29:20.997]                     }
[08:29:20.997]                     muffleCondition(cond, pattern = "^muffle")
[08:29:20.997]                   }
[08:29:20.997]                 }
[08:29:20.997]             }
[08:29:20.997]         }))
[08:29:20.997]     }, error = function(ex) {
[08:29:20.997]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:20.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:20.997]                 ...future.rng), started = ...future.startTime, 
[08:29:20.997]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:20.997]             version = "1.8"), class = "FutureResult")
[08:29:20.997]     }, finally = {
[08:29:20.997]         if (!identical(...future.workdir, getwd())) 
[08:29:20.997]             setwd(...future.workdir)
[08:29:20.997]         {
[08:29:20.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:20.997]                 ...future.oldOptions$nwarnings <- NULL
[08:29:20.997]             }
[08:29:20.997]             base::options(...future.oldOptions)
[08:29:20.997]             if (.Platform$OS.type == "windows") {
[08:29:20.997]                 old_names <- names(...future.oldEnvVars)
[08:29:20.997]                 envs <- base::Sys.getenv()
[08:29:20.997]                 names <- names(envs)
[08:29:20.997]                 common <- intersect(names, old_names)
[08:29:20.997]                 added <- setdiff(names, old_names)
[08:29:20.997]                 removed <- setdiff(old_names, names)
[08:29:20.997]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:20.997]                   envs[common]]
[08:29:20.997]                 NAMES <- toupper(changed)
[08:29:20.997]                 args <- list()
[08:29:20.997]                 for (kk in seq_along(NAMES)) {
[08:29:20.997]                   name <- changed[[kk]]
[08:29:20.997]                   NAME <- NAMES[[kk]]
[08:29:20.997]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.997]                     next
[08:29:20.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.997]                 }
[08:29:20.997]                 NAMES <- toupper(added)
[08:29:20.997]                 for (kk in seq_along(NAMES)) {
[08:29:20.997]                   name <- added[[kk]]
[08:29:20.997]                   NAME <- NAMES[[kk]]
[08:29:20.997]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.997]                     next
[08:29:20.997]                   args[[name]] <- ""
[08:29:20.997]                 }
[08:29:20.997]                 NAMES <- toupper(removed)
[08:29:20.997]                 for (kk in seq_along(NAMES)) {
[08:29:20.997]                   name <- removed[[kk]]
[08:29:20.997]                   NAME <- NAMES[[kk]]
[08:29:20.997]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:20.997]                     next
[08:29:20.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:20.997]                 }
[08:29:20.997]                 if (length(args) > 0) 
[08:29:20.997]                   base::do.call(base::Sys.setenv, args = args)
[08:29:20.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:20.997]             }
[08:29:20.997]             else {
[08:29:20.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:20.997]             }
[08:29:20.997]             {
[08:29:20.997]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:20.997]                   0L) {
[08:29:20.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:20.997]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:20.997]                   base::options(opts)
[08:29:20.997]                 }
[08:29:20.997]                 {
[08:29:20.997]                   {
[08:29:20.997]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:20.997]                     NULL
[08:29:20.997]                   }
[08:29:20.997]                   options(future.plan = NULL)
[08:29:20.997]                   if (is.na(NA_character_)) 
[08:29:20.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:20.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:20.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:20.997]                     .init = FALSE)
[08:29:20.997]                 }
[08:29:20.997]             }
[08:29:20.997]         }
[08:29:20.997]     })
[08:29:20.997]     if (TRUE) {
[08:29:20.997]         base::sink(type = "output", split = FALSE)
[08:29:20.997]         if (TRUE) {
[08:29:20.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:20.997]         }
[08:29:20.997]         else {
[08:29:20.997]             ...future.result["stdout"] <- base::list(NULL)
[08:29:20.997]         }
[08:29:20.997]         base::close(...future.stdout)
[08:29:20.997]         ...future.stdout <- NULL
[08:29:20.997]     }
[08:29:20.997]     ...future.result$conditions <- ...future.conditions
[08:29:20.997]     ...future.result$finished <- base::Sys.time()
[08:29:20.997]     ...future.result
[08:29:20.997] }
[08:29:20.999] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[08:29:21.000] Exporting ‘kk’ (35 bytes) to cluster node #2 ...
[08:29:21.000] Exporting ‘kk’ (35 bytes) to cluster node #2 ... DONE
[08:29:21.000] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[08:29:21.001] MultisessionFuture started
[08:29:21.001] - Launch lazy future ... done
[08:29:21.001] run() for ‘MultisessionFuture’ ... done
[08:29:21.001] getGlobalsAndPackages() ...
[08:29:21.001] Searching for globals...
[08:29:21.002] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:21.002] Searching for globals ... DONE
[08:29:21.002] Resolving globals: FALSE
[08:29:21.002] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:21.003] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:21.003] - globals: [1] ‘kk’
[08:29:21.003] 
[08:29:21.003] getGlobalsAndPackages() ... DONE
[08:29:21.003] run() for ‘Future’ ...
[08:29:21.003] - state: ‘created’
[08:29:21.003] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.017] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.017] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.017]   - Field: ‘node’
[08:29:21.017]   - Field: ‘label’
[08:29:21.017]   - Field: ‘local’
[08:29:21.018]   - Field: ‘owner’
[08:29:21.018]   - Field: ‘envir’
[08:29:21.018]   - Field: ‘workers’
[08:29:21.018]   - Field: ‘packages’
[08:29:21.018]   - Field: ‘gc’
[08:29:21.018]   - Field: ‘conditions’
[08:29:21.018]   - Field: ‘persistent’
[08:29:21.019]   - Field: ‘expr’
[08:29:21.019]   - Field: ‘uuid’
[08:29:21.019]   - Field: ‘seed’
[08:29:21.019]   - Field: ‘version’
[08:29:21.019]   - Field: ‘result’
[08:29:21.019]   - Field: ‘asynchronous’
[08:29:21.019]   - Field: ‘calls’
[08:29:21.019]   - Field: ‘globals’
[08:29:21.020]   - Field: ‘stdout’
[08:29:21.020]   - Field: ‘earlySignal’
[08:29:21.020]   - Field: ‘lazy’
[08:29:21.020]   - Field: ‘state’
[08:29:21.020] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.020] - Launch lazy future ...
[08:29:21.020] Packages needed by the future expression (n = 0): <none>
[08:29:21.020] Packages needed by future strategies (n = 0): <none>
[08:29:21.021] {
[08:29:21.021]     {
[08:29:21.021]         {
[08:29:21.021]             ...future.startTime <- base::Sys.time()
[08:29:21.021]             {
[08:29:21.021]                 {
[08:29:21.021]                   {
[08:29:21.021]                     {
[08:29:21.021]                       base::local({
[08:29:21.021]                         has_future <- base::requireNamespace("future", 
[08:29:21.021]                           quietly = TRUE)
[08:29:21.021]                         if (has_future) {
[08:29:21.021]                           ns <- base::getNamespace("future")
[08:29:21.021]                           version <- ns[[".package"]][["version"]]
[08:29:21.021]                           if (is.null(version)) 
[08:29:21.021]                             version <- utils::packageVersion("future")
[08:29:21.021]                         }
[08:29:21.021]                         else {
[08:29:21.021]                           version <- NULL
[08:29:21.021]                         }
[08:29:21.021]                         if (!has_future || version < "1.8.0") {
[08:29:21.021]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.021]                             "", base::R.version$version.string), 
[08:29:21.021]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.021]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.021]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.021]                               "release", "version")], collapse = " "), 
[08:29:21.021]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.021]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.021]                             info)
[08:29:21.021]                           info <- base::paste(info, collapse = "; ")
[08:29:21.021]                           if (!has_future) {
[08:29:21.021]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.021]                               info)
[08:29:21.021]                           }
[08:29:21.021]                           else {
[08:29:21.021]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.021]                               info, version)
[08:29:21.021]                           }
[08:29:21.021]                           base::stop(msg)
[08:29:21.021]                         }
[08:29:21.021]                       })
[08:29:21.021]                     }
[08:29:21.021]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.021]                     base::options(mc.cores = 1L)
[08:29:21.021]                   }
[08:29:21.021]                   ...future.strategy.old <- future::plan("list")
[08:29:21.021]                   options(future.plan = NULL)
[08:29:21.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.021]                 }
[08:29:21.021]                 ...future.workdir <- getwd()
[08:29:21.021]             }
[08:29:21.021]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.021]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.021]         }
[08:29:21.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.021]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.021]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.021]             base::names(...future.oldOptions))
[08:29:21.021]     }
[08:29:21.021]     if (FALSE) {
[08:29:21.021]     }
[08:29:21.021]     else {
[08:29:21.021]         if (TRUE) {
[08:29:21.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.021]                 open = "w")
[08:29:21.021]         }
[08:29:21.021]         else {
[08:29:21.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.021]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.021]         }
[08:29:21.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.021]             base::sink(type = "output", split = FALSE)
[08:29:21.021]             base::close(...future.stdout)
[08:29:21.021]         }, add = TRUE)
[08:29:21.021]     }
[08:29:21.021]     ...future.frame <- base::sys.nframe()
[08:29:21.021]     ...future.conditions <- base::list()
[08:29:21.021]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.021]     if (FALSE) {
[08:29:21.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.021]     }
[08:29:21.021]     ...future.result <- base::tryCatch({
[08:29:21.021]         base::withCallingHandlers({
[08:29:21.021]             ...future.value <- base::withVisible(base::local({
[08:29:21.021]                 ...future.makeSendCondition <- base::local({
[08:29:21.021]                   sendCondition <- NULL
[08:29:21.021]                   function(frame = 1L) {
[08:29:21.021]                     if (is.function(sendCondition)) 
[08:29:21.021]                       return(sendCondition)
[08:29:21.021]                     ns <- getNamespace("parallel")
[08:29:21.021]                     if (exists("sendData", mode = "function", 
[08:29:21.021]                       envir = ns)) {
[08:29:21.021]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.021]                         envir = ns)
[08:29:21.021]                       envir <- sys.frame(frame)
[08:29:21.021]                       master <- NULL
[08:29:21.021]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.021]                         !identical(envir, emptyenv())) {
[08:29:21.021]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.021]                           inherits = FALSE)) {
[08:29:21.021]                           master <- get("master", mode = "list", 
[08:29:21.021]                             envir = envir, inherits = FALSE)
[08:29:21.021]                           if (inherits(master, c("SOCKnode", 
[08:29:21.021]                             "SOCK0node"))) {
[08:29:21.021]                             sendCondition <<- function(cond) {
[08:29:21.021]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.021]                                 success = TRUE)
[08:29:21.021]                               parallel_sendData(master, data)
[08:29:21.021]                             }
[08:29:21.021]                             return(sendCondition)
[08:29:21.021]                           }
[08:29:21.021]                         }
[08:29:21.021]                         frame <- frame + 1L
[08:29:21.021]                         envir <- sys.frame(frame)
[08:29:21.021]                       }
[08:29:21.021]                     }
[08:29:21.021]                     sendCondition <<- function(cond) NULL
[08:29:21.021]                   }
[08:29:21.021]                 })
[08:29:21.021]                 withCallingHandlers({
[08:29:21.021]                   {
[08:29:21.021]                     Sys.sleep(0.1)
[08:29:21.021]                     kk
[08:29:21.021]                   }
[08:29:21.021]                 }, immediateCondition = function(cond) {
[08:29:21.021]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.021]                   sendCondition(cond)
[08:29:21.021]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.021]                   {
[08:29:21.021]                     inherits <- base::inherits
[08:29:21.021]                     invokeRestart <- base::invokeRestart
[08:29:21.021]                     is.null <- base::is.null
[08:29:21.021]                     muffled <- FALSE
[08:29:21.021]                     if (inherits(cond, "message")) {
[08:29:21.021]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.021]                       if (muffled) 
[08:29:21.021]                         invokeRestart("muffleMessage")
[08:29:21.021]                     }
[08:29:21.021]                     else if (inherits(cond, "warning")) {
[08:29:21.021]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.021]                       if (muffled) 
[08:29:21.021]                         invokeRestart("muffleWarning")
[08:29:21.021]                     }
[08:29:21.021]                     else if (inherits(cond, "condition")) {
[08:29:21.021]                       if (!is.null(pattern)) {
[08:29:21.021]                         computeRestarts <- base::computeRestarts
[08:29:21.021]                         grepl <- base::grepl
[08:29:21.021]                         restarts <- computeRestarts(cond)
[08:29:21.021]                         for (restart in restarts) {
[08:29:21.021]                           name <- restart$name
[08:29:21.021]                           if (is.null(name)) 
[08:29:21.021]                             next
[08:29:21.021]                           if (!grepl(pattern, name)) 
[08:29:21.021]                             next
[08:29:21.021]                           invokeRestart(restart)
[08:29:21.021]                           muffled <- TRUE
[08:29:21.021]                           break
[08:29:21.021]                         }
[08:29:21.021]                       }
[08:29:21.021]                     }
[08:29:21.021]                     invisible(muffled)
[08:29:21.021]                   }
[08:29:21.021]                   muffleCondition(cond)
[08:29:21.021]                 })
[08:29:21.021]             }))
[08:29:21.021]             future::FutureResult(value = ...future.value$value, 
[08:29:21.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.021]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.021]                     ...future.globalenv.names))
[08:29:21.021]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.021]         }, condition = base::local({
[08:29:21.021]             c <- base::c
[08:29:21.021]             inherits <- base::inherits
[08:29:21.021]             invokeRestart <- base::invokeRestart
[08:29:21.021]             length <- base::length
[08:29:21.021]             list <- base::list
[08:29:21.021]             seq.int <- base::seq.int
[08:29:21.021]             signalCondition <- base::signalCondition
[08:29:21.021]             sys.calls <- base::sys.calls
[08:29:21.021]             `[[` <- base::`[[`
[08:29:21.021]             `+` <- base::`+`
[08:29:21.021]             `<<-` <- base::`<<-`
[08:29:21.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.021]                   3L)]
[08:29:21.021]             }
[08:29:21.021]             function(cond) {
[08:29:21.021]                 is_error <- inherits(cond, "error")
[08:29:21.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.021]                   NULL)
[08:29:21.021]                 if (is_error) {
[08:29:21.021]                   sessionInformation <- function() {
[08:29:21.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.021]                       search = base::search(), system = base::Sys.info())
[08:29:21.021]                   }
[08:29:21.021]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.021]                     cond$call), session = sessionInformation(), 
[08:29:21.021]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.021]                   signalCondition(cond)
[08:29:21.021]                 }
[08:29:21.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.021]                 "immediateCondition"))) {
[08:29:21.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.021]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.021]                   if (TRUE && !signal) {
[08:29:21.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.021]                     {
[08:29:21.021]                       inherits <- base::inherits
[08:29:21.021]                       invokeRestart <- base::invokeRestart
[08:29:21.021]                       is.null <- base::is.null
[08:29:21.021]                       muffled <- FALSE
[08:29:21.021]                       if (inherits(cond, "message")) {
[08:29:21.021]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.021]                         if (muffled) 
[08:29:21.021]                           invokeRestart("muffleMessage")
[08:29:21.021]                       }
[08:29:21.021]                       else if (inherits(cond, "warning")) {
[08:29:21.021]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.021]                         if (muffled) 
[08:29:21.021]                           invokeRestart("muffleWarning")
[08:29:21.021]                       }
[08:29:21.021]                       else if (inherits(cond, "condition")) {
[08:29:21.021]                         if (!is.null(pattern)) {
[08:29:21.021]                           computeRestarts <- base::computeRestarts
[08:29:21.021]                           grepl <- base::grepl
[08:29:21.021]                           restarts <- computeRestarts(cond)
[08:29:21.021]                           for (restart in restarts) {
[08:29:21.021]                             name <- restart$name
[08:29:21.021]                             if (is.null(name)) 
[08:29:21.021]                               next
[08:29:21.021]                             if (!grepl(pattern, name)) 
[08:29:21.021]                               next
[08:29:21.021]                             invokeRestart(restart)
[08:29:21.021]                             muffled <- TRUE
[08:29:21.021]                             break
[08:29:21.021]                           }
[08:29:21.021]                         }
[08:29:21.021]                       }
[08:29:21.021]                       invisible(muffled)
[08:29:21.021]                     }
[08:29:21.021]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.021]                   }
[08:29:21.021]                 }
[08:29:21.021]                 else {
[08:29:21.021]                   if (TRUE) {
[08:29:21.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.021]                     {
[08:29:21.021]                       inherits <- base::inherits
[08:29:21.021]                       invokeRestart <- base::invokeRestart
[08:29:21.021]                       is.null <- base::is.null
[08:29:21.021]                       muffled <- FALSE
[08:29:21.021]                       if (inherits(cond, "message")) {
[08:29:21.021]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.021]                         if (muffled) 
[08:29:21.021]                           invokeRestart("muffleMessage")
[08:29:21.021]                       }
[08:29:21.021]                       else if (inherits(cond, "warning")) {
[08:29:21.021]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.021]                         if (muffled) 
[08:29:21.021]                           invokeRestart("muffleWarning")
[08:29:21.021]                       }
[08:29:21.021]                       else if (inherits(cond, "condition")) {
[08:29:21.021]                         if (!is.null(pattern)) {
[08:29:21.021]                           computeRestarts <- base::computeRestarts
[08:29:21.021]                           grepl <- base::grepl
[08:29:21.021]                           restarts <- computeRestarts(cond)
[08:29:21.021]                           for (restart in restarts) {
[08:29:21.021]                             name <- restart$name
[08:29:21.021]                             if (is.null(name)) 
[08:29:21.021]                               next
[08:29:21.021]                             if (!grepl(pattern, name)) 
[08:29:21.021]                               next
[08:29:21.021]                             invokeRestart(restart)
[08:29:21.021]                             muffled <- TRUE
[08:29:21.021]                             break
[08:29:21.021]                           }
[08:29:21.021]                         }
[08:29:21.021]                       }
[08:29:21.021]                       invisible(muffled)
[08:29:21.021]                     }
[08:29:21.021]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.021]                   }
[08:29:21.021]                 }
[08:29:21.021]             }
[08:29:21.021]         }))
[08:29:21.021]     }, error = function(ex) {
[08:29:21.021]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.021]                 ...future.rng), started = ...future.startTime, 
[08:29:21.021]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.021]             version = "1.8"), class = "FutureResult")
[08:29:21.021]     }, finally = {
[08:29:21.021]         if (!identical(...future.workdir, getwd())) 
[08:29:21.021]             setwd(...future.workdir)
[08:29:21.021]         {
[08:29:21.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.021]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.021]             }
[08:29:21.021]             base::options(...future.oldOptions)
[08:29:21.021]             if (.Platform$OS.type == "windows") {
[08:29:21.021]                 old_names <- names(...future.oldEnvVars)
[08:29:21.021]                 envs <- base::Sys.getenv()
[08:29:21.021]                 names <- names(envs)
[08:29:21.021]                 common <- intersect(names, old_names)
[08:29:21.021]                 added <- setdiff(names, old_names)
[08:29:21.021]                 removed <- setdiff(old_names, names)
[08:29:21.021]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.021]                   envs[common]]
[08:29:21.021]                 NAMES <- toupper(changed)
[08:29:21.021]                 args <- list()
[08:29:21.021]                 for (kk in seq_along(NAMES)) {
[08:29:21.021]                   name <- changed[[kk]]
[08:29:21.021]                   NAME <- NAMES[[kk]]
[08:29:21.021]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.021]                     next
[08:29:21.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.021]                 }
[08:29:21.021]                 NAMES <- toupper(added)
[08:29:21.021]                 for (kk in seq_along(NAMES)) {
[08:29:21.021]                   name <- added[[kk]]
[08:29:21.021]                   NAME <- NAMES[[kk]]
[08:29:21.021]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.021]                     next
[08:29:21.021]                   args[[name]] <- ""
[08:29:21.021]                 }
[08:29:21.021]                 NAMES <- toupper(removed)
[08:29:21.021]                 for (kk in seq_along(NAMES)) {
[08:29:21.021]                   name <- removed[[kk]]
[08:29:21.021]                   NAME <- NAMES[[kk]]
[08:29:21.021]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.021]                     next
[08:29:21.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.021]                 }
[08:29:21.021]                 if (length(args) > 0) 
[08:29:21.021]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.021]             }
[08:29:21.021]             else {
[08:29:21.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.021]             }
[08:29:21.021]             {
[08:29:21.021]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.021]                   0L) {
[08:29:21.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.021]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.021]                   base::options(opts)
[08:29:21.021]                 }
[08:29:21.021]                 {
[08:29:21.021]                   {
[08:29:21.021]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.021]                     NULL
[08:29:21.021]                   }
[08:29:21.021]                   options(future.plan = NULL)
[08:29:21.021]                   if (is.na(NA_character_)) 
[08:29:21.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.021]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.021]                     .init = FALSE)
[08:29:21.021]                 }
[08:29:21.021]             }
[08:29:21.021]         }
[08:29:21.021]     })
[08:29:21.021]     if (TRUE) {
[08:29:21.021]         base::sink(type = "output", split = FALSE)
[08:29:21.021]         if (TRUE) {
[08:29:21.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.021]         }
[08:29:21.021]         else {
[08:29:21.021]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.021]         }
[08:29:21.021]         base::close(...future.stdout)
[08:29:21.021]         ...future.stdout <- NULL
[08:29:21.021]     }
[08:29:21.021]     ...future.result$conditions <- ...future.conditions
[08:29:21.021]     ...future.result$finished <- base::Sys.time()
[08:29:21.021]     ...future.result
[08:29:21.021] }
[08:29:21.023] Poll #1 (0): usedNodes() = 2, workers = 2
[08:29:21.054] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[08:29:21.086] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[08:29:21.117] Poll #4 (0.09 secs): usedNodes() = 2, workers = 2
[08:29:21.128] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.128] - Validating connection of MultisessionFuture
[08:29:21.129] - received message: FutureResult
[08:29:21.129] - Received FutureResult
[08:29:21.129] - Erased future from FutureRegistry
[08:29:21.129] result() for ClusterFuture ...
[08:29:21.129] - result already collected: FutureResult
[08:29:21.129] result() for ClusterFuture ... done
[08:29:21.129] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.129] result() for ClusterFuture ...
[08:29:21.130] - result already collected: FutureResult
[08:29:21.130] result() for ClusterFuture ... done
[08:29:21.130] result() for ClusterFuture ...
[08:29:21.130] - result already collected: FutureResult
[08:29:21.130] result() for ClusterFuture ... done
[08:29:21.131] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[08:29:21.131] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[08:29:21.131] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[08:29:21.131] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[08:29:21.132] MultisessionFuture started
[08:29:21.132] - Launch lazy future ... done
[08:29:21.132] run() for ‘MultisessionFuture’ ... done
[08:29:21.132] resolve() on list ...
[08:29:21.132]  recursive: 0
[08:29:21.132]  length: 3
[08:29:21.132] 
[08:29:21.132] Future #1
[08:29:21.133]  length: 2 (resolved future 1)
[08:29:21.164] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.164] - Validating connection of MultisessionFuture
[08:29:21.164] - received message: FutureResult
[08:29:21.164] - Received FutureResult
[08:29:21.165] - Erased future from FutureRegistry
[08:29:21.165] result() for ClusterFuture ...
[08:29:21.165] - result already collected: FutureResult
[08:29:21.165] result() for ClusterFuture ... done
[08:29:21.165] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.165] Future #2
[08:29:21.165]  length: 1 (resolved future 2)
[08:29:21.274] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.274] - Validating connection of MultisessionFuture
[08:29:21.275] - received message: FutureResult
[08:29:21.275] - Received FutureResult
[08:29:21.275] - Erased future from FutureRegistry
[08:29:21.275] result() for ClusterFuture ...
[08:29:21.275] - result already collected: FutureResult
[08:29:21.275] result() for ClusterFuture ... done
[08:29:21.275] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.275] Future #3
[08:29:21.275]  length: 0 (resolved future 3)
[08:29:21.275] resolve() on list ... DONE
[08:29:21.276] getGlobalsAndPackages() ...
[08:29:21.276] Searching for globals...
[08:29:21.277] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:21.277] Searching for globals ... DONE
[08:29:21.277] Resolving globals: FALSE
[08:29:21.277] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:21.278] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:21.278] - globals: [1] ‘kk’
[08:29:21.278] 
[08:29:21.278] getGlobalsAndPackages() ... DONE
[08:29:21.278] getGlobalsAndPackages() ...
[08:29:21.278] Searching for globals...
[08:29:21.279] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:21.279] Searching for globals ... DONE
[08:29:21.279] Resolving globals: FALSE
[08:29:21.280] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:21.280] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:21.280] - globals: [1] ‘kk’
[08:29:21.280] 
[08:29:21.280] getGlobalsAndPackages() ... DONE
[08:29:21.280] getGlobalsAndPackages() ...
[08:29:21.281] Searching for globals...
[08:29:21.281] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[08:29:21.282] Searching for globals ... DONE
[08:29:21.282] Resolving globals: FALSE
[08:29:21.282] The total size of the 1 globals is 35 bytes (35 bytes)
[08:29:21.282] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[08:29:21.282] - globals: [1] ‘kk’
[08:29:21.282] 
[08:29:21.283] getGlobalsAndPackages() ... DONE
[08:29:21.283] resolve() on list ...
[08:29:21.283]  recursive: 0
[08:29:21.283]  length: 3
[08:29:21.283] 
[08:29:21.283] run() for ‘Future’ ...
[08:29:21.283] - state: ‘created’
[08:29:21.283] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.297] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.297]   - Field: ‘node’
[08:29:21.297]   - Field: ‘label’
[08:29:21.298]   - Field: ‘local’
[08:29:21.298]   - Field: ‘owner’
[08:29:21.298]   - Field: ‘envir’
[08:29:21.298]   - Field: ‘workers’
[08:29:21.298]   - Field: ‘packages’
[08:29:21.298]   - Field: ‘gc’
[08:29:21.298]   - Field: ‘conditions’
[08:29:21.298]   - Field: ‘persistent’
[08:29:21.298]   - Field: ‘expr’
[08:29:21.298]   - Field: ‘uuid’
[08:29:21.298]   - Field: ‘seed’
[08:29:21.298]   - Field: ‘version’
[08:29:21.299]   - Field: ‘result’
[08:29:21.299]   - Field: ‘asynchronous’
[08:29:21.299]   - Field: ‘calls’
[08:29:21.299]   - Field: ‘globals’
[08:29:21.299]   - Field: ‘stdout’
[08:29:21.299]   - Field: ‘earlySignal’
[08:29:21.299]   - Field: ‘lazy’
[08:29:21.299]   - Field: ‘state’
[08:29:21.299] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.299] - Launch lazy future ...
[08:29:21.300] Packages needed by the future expression (n = 0): <none>
[08:29:21.300] Packages needed by future strategies (n = 0): <none>
[08:29:21.300] {
[08:29:21.300]     {
[08:29:21.300]         {
[08:29:21.300]             ...future.startTime <- base::Sys.time()
[08:29:21.300]             {
[08:29:21.300]                 {
[08:29:21.300]                   {
[08:29:21.300]                     {
[08:29:21.300]                       base::local({
[08:29:21.300]                         has_future <- base::requireNamespace("future", 
[08:29:21.300]                           quietly = TRUE)
[08:29:21.300]                         if (has_future) {
[08:29:21.300]                           ns <- base::getNamespace("future")
[08:29:21.300]                           version <- ns[[".package"]][["version"]]
[08:29:21.300]                           if (is.null(version)) 
[08:29:21.300]                             version <- utils::packageVersion("future")
[08:29:21.300]                         }
[08:29:21.300]                         else {
[08:29:21.300]                           version <- NULL
[08:29:21.300]                         }
[08:29:21.300]                         if (!has_future || version < "1.8.0") {
[08:29:21.300]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.300]                             "", base::R.version$version.string), 
[08:29:21.300]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.300]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.300]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.300]                               "release", "version")], collapse = " "), 
[08:29:21.300]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.300]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.300]                             info)
[08:29:21.300]                           info <- base::paste(info, collapse = "; ")
[08:29:21.300]                           if (!has_future) {
[08:29:21.300]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.300]                               info)
[08:29:21.300]                           }
[08:29:21.300]                           else {
[08:29:21.300]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.300]                               info, version)
[08:29:21.300]                           }
[08:29:21.300]                           base::stop(msg)
[08:29:21.300]                         }
[08:29:21.300]                       })
[08:29:21.300]                     }
[08:29:21.300]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.300]                     base::options(mc.cores = 1L)
[08:29:21.300]                   }
[08:29:21.300]                   ...future.strategy.old <- future::plan("list")
[08:29:21.300]                   options(future.plan = NULL)
[08:29:21.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.300]                 }
[08:29:21.300]                 ...future.workdir <- getwd()
[08:29:21.300]             }
[08:29:21.300]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.300]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.300]         }
[08:29:21.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.300]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.300]             base::names(...future.oldOptions))
[08:29:21.300]     }
[08:29:21.300]     if (FALSE) {
[08:29:21.300]     }
[08:29:21.300]     else {
[08:29:21.300]         if (TRUE) {
[08:29:21.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.300]                 open = "w")
[08:29:21.300]         }
[08:29:21.300]         else {
[08:29:21.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.300]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.300]         }
[08:29:21.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.300]             base::sink(type = "output", split = FALSE)
[08:29:21.300]             base::close(...future.stdout)
[08:29:21.300]         }, add = TRUE)
[08:29:21.300]     }
[08:29:21.300]     ...future.frame <- base::sys.nframe()
[08:29:21.300]     ...future.conditions <- base::list()
[08:29:21.300]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.300]     if (FALSE) {
[08:29:21.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.300]     }
[08:29:21.300]     ...future.result <- base::tryCatch({
[08:29:21.300]         base::withCallingHandlers({
[08:29:21.300]             ...future.value <- base::withVisible(base::local({
[08:29:21.300]                 ...future.makeSendCondition <- base::local({
[08:29:21.300]                   sendCondition <- NULL
[08:29:21.300]                   function(frame = 1L) {
[08:29:21.300]                     if (is.function(sendCondition)) 
[08:29:21.300]                       return(sendCondition)
[08:29:21.300]                     ns <- getNamespace("parallel")
[08:29:21.300]                     if (exists("sendData", mode = "function", 
[08:29:21.300]                       envir = ns)) {
[08:29:21.300]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.300]                         envir = ns)
[08:29:21.300]                       envir <- sys.frame(frame)
[08:29:21.300]                       master <- NULL
[08:29:21.300]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.300]                         !identical(envir, emptyenv())) {
[08:29:21.300]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.300]                           inherits = FALSE)) {
[08:29:21.300]                           master <- get("master", mode = "list", 
[08:29:21.300]                             envir = envir, inherits = FALSE)
[08:29:21.300]                           if (inherits(master, c("SOCKnode", 
[08:29:21.300]                             "SOCK0node"))) {
[08:29:21.300]                             sendCondition <<- function(cond) {
[08:29:21.300]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.300]                                 success = TRUE)
[08:29:21.300]                               parallel_sendData(master, data)
[08:29:21.300]                             }
[08:29:21.300]                             return(sendCondition)
[08:29:21.300]                           }
[08:29:21.300]                         }
[08:29:21.300]                         frame <- frame + 1L
[08:29:21.300]                         envir <- sys.frame(frame)
[08:29:21.300]                       }
[08:29:21.300]                     }
[08:29:21.300]                     sendCondition <<- function(cond) NULL
[08:29:21.300]                   }
[08:29:21.300]                 })
[08:29:21.300]                 withCallingHandlers({
[08:29:21.300]                   {
[08:29:21.300]                     Sys.sleep(0.1)
[08:29:21.300]                     kk
[08:29:21.300]                   }
[08:29:21.300]                 }, immediateCondition = function(cond) {
[08:29:21.300]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.300]                   sendCondition(cond)
[08:29:21.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.300]                   {
[08:29:21.300]                     inherits <- base::inherits
[08:29:21.300]                     invokeRestart <- base::invokeRestart
[08:29:21.300]                     is.null <- base::is.null
[08:29:21.300]                     muffled <- FALSE
[08:29:21.300]                     if (inherits(cond, "message")) {
[08:29:21.300]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.300]                       if (muffled) 
[08:29:21.300]                         invokeRestart("muffleMessage")
[08:29:21.300]                     }
[08:29:21.300]                     else if (inherits(cond, "warning")) {
[08:29:21.300]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.300]                       if (muffled) 
[08:29:21.300]                         invokeRestart("muffleWarning")
[08:29:21.300]                     }
[08:29:21.300]                     else if (inherits(cond, "condition")) {
[08:29:21.300]                       if (!is.null(pattern)) {
[08:29:21.300]                         computeRestarts <- base::computeRestarts
[08:29:21.300]                         grepl <- base::grepl
[08:29:21.300]                         restarts <- computeRestarts(cond)
[08:29:21.300]                         for (restart in restarts) {
[08:29:21.300]                           name <- restart$name
[08:29:21.300]                           if (is.null(name)) 
[08:29:21.300]                             next
[08:29:21.300]                           if (!grepl(pattern, name)) 
[08:29:21.300]                             next
[08:29:21.300]                           invokeRestart(restart)
[08:29:21.300]                           muffled <- TRUE
[08:29:21.300]                           break
[08:29:21.300]                         }
[08:29:21.300]                       }
[08:29:21.300]                     }
[08:29:21.300]                     invisible(muffled)
[08:29:21.300]                   }
[08:29:21.300]                   muffleCondition(cond)
[08:29:21.300]                 })
[08:29:21.300]             }))
[08:29:21.300]             future::FutureResult(value = ...future.value$value, 
[08:29:21.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.300]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.300]                     ...future.globalenv.names))
[08:29:21.300]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.300]         }, condition = base::local({
[08:29:21.300]             c <- base::c
[08:29:21.300]             inherits <- base::inherits
[08:29:21.300]             invokeRestart <- base::invokeRestart
[08:29:21.300]             length <- base::length
[08:29:21.300]             list <- base::list
[08:29:21.300]             seq.int <- base::seq.int
[08:29:21.300]             signalCondition <- base::signalCondition
[08:29:21.300]             sys.calls <- base::sys.calls
[08:29:21.300]             `[[` <- base::`[[`
[08:29:21.300]             `+` <- base::`+`
[08:29:21.300]             `<<-` <- base::`<<-`
[08:29:21.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.300]                   3L)]
[08:29:21.300]             }
[08:29:21.300]             function(cond) {
[08:29:21.300]                 is_error <- inherits(cond, "error")
[08:29:21.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.300]                   NULL)
[08:29:21.300]                 if (is_error) {
[08:29:21.300]                   sessionInformation <- function() {
[08:29:21.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.300]                       search = base::search(), system = base::Sys.info())
[08:29:21.300]                   }
[08:29:21.300]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.300]                     cond$call), session = sessionInformation(), 
[08:29:21.300]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.300]                   signalCondition(cond)
[08:29:21.300]                 }
[08:29:21.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.300]                 "immediateCondition"))) {
[08:29:21.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.300]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.300]                   if (TRUE && !signal) {
[08:29:21.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.300]                     {
[08:29:21.300]                       inherits <- base::inherits
[08:29:21.300]                       invokeRestart <- base::invokeRestart
[08:29:21.300]                       is.null <- base::is.null
[08:29:21.300]                       muffled <- FALSE
[08:29:21.300]                       if (inherits(cond, "message")) {
[08:29:21.300]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.300]                         if (muffled) 
[08:29:21.300]                           invokeRestart("muffleMessage")
[08:29:21.300]                       }
[08:29:21.300]                       else if (inherits(cond, "warning")) {
[08:29:21.300]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.300]                         if (muffled) 
[08:29:21.300]                           invokeRestart("muffleWarning")
[08:29:21.300]                       }
[08:29:21.300]                       else if (inherits(cond, "condition")) {
[08:29:21.300]                         if (!is.null(pattern)) {
[08:29:21.300]                           computeRestarts <- base::computeRestarts
[08:29:21.300]                           grepl <- base::grepl
[08:29:21.300]                           restarts <- computeRestarts(cond)
[08:29:21.300]                           for (restart in restarts) {
[08:29:21.300]                             name <- restart$name
[08:29:21.300]                             if (is.null(name)) 
[08:29:21.300]                               next
[08:29:21.300]                             if (!grepl(pattern, name)) 
[08:29:21.300]                               next
[08:29:21.300]                             invokeRestart(restart)
[08:29:21.300]                             muffled <- TRUE
[08:29:21.300]                             break
[08:29:21.300]                           }
[08:29:21.300]                         }
[08:29:21.300]                       }
[08:29:21.300]                       invisible(muffled)
[08:29:21.300]                     }
[08:29:21.300]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.300]                   }
[08:29:21.300]                 }
[08:29:21.300]                 else {
[08:29:21.300]                   if (TRUE) {
[08:29:21.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.300]                     {
[08:29:21.300]                       inherits <- base::inherits
[08:29:21.300]                       invokeRestart <- base::invokeRestart
[08:29:21.300]                       is.null <- base::is.null
[08:29:21.300]                       muffled <- FALSE
[08:29:21.300]                       if (inherits(cond, "message")) {
[08:29:21.300]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.300]                         if (muffled) 
[08:29:21.300]                           invokeRestart("muffleMessage")
[08:29:21.300]                       }
[08:29:21.300]                       else if (inherits(cond, "warning")) {
[08:29:21.300]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.300]                         if (muffled) 
[08:29:21.300]                           invokeRestart("muffleWarning")
[08:29:21.300]                       }
[08:29:21.300]                       else if (inherits(cond, "condition")) {
[08:29:21.300]                         if (!is.null(pattern)) {
[08:29:21.300]                           computeRestarts <- base::computeRestarts
[08:29:21.300]                           grepl <- base::grepl
[08:29:21.300]                           restarts <- computeRestarts(cond)
[08:29:21.300]                           for (restart in restarts) {
[08:29:21.300]                             name <- restart$name
[08:29:21.300]                             if (is.null(name)) 
[08:29:21.300]                               next
[08:29:21.300]                             if (!grepl(pattern, name)) 
[08:29:21.300]                               next
[08:29:21.300]                             invokeRestart(restart)
[08:29:21.300]                             muffled <- TRUE
[08:29:21.300]                             break
[08:29:21.300]                           }
[08:29:21.300]                         }
[08:29:21.300]                       }
[08:29:21.300]                       invisible(muffled)
[08:29:21.300]                     }
[08:29:21.300]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.300]                   }
[08:29:21.300]                 }
[08:29:21.300]             }
[08:29:21.300]         }))
[08:29:21.300]     }, error = function(ex) {
[08:29:21.300]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.300]                 ...future.rng), started = ...future.startTime, 
[08:29:21.300]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.300]             version = "1.8"), class = "FutureResult")
[08:29:21.300]     }, finally = {
[08:29:21.300]         if (!identical(...future.workdir, getwd())) 
[08:29:21.300]             setwd(...future.workdir)
[08:29:21.300]         {
[08:29:21.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.300]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.300]             }
[08:29:21.300]             base::options(...future.oldOptions)
[08:29:21.300]             if (.Platform$OS.type == "windows") {
[08:29:21.300]                 old_names <- names(...future.oldEnvVars)
[08:29:21.300]                 envs <- base::Sys.getenv()
[08:29:21.300]                 names <- names(envs)
[08:29:21.300]                 common <- intersect(names, old_names)
[08:29:21.300]                 added <- setdiff(names, old_names)
[08:29:21.300]                 removed <- setdiff(old_names, names)
[08:29:21.300]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.300]                   envs[common]]
[08:29:21.300]                 NAMES <- toupper(changed)
[08:29:21.300]                 args <- list()
[08:29:21.300]                 for (kk in seq_along(NAMES)) {
[08:29:21.300]                   name <- changed[[kk]]
[08:29:21.300]                   NAME <- NAMES[[kk]]
[08:29:21.300]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.300]                     next
[08:29:21.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.300]                 }
[08:29:21.300]                 NAMES <- toupper(added)
[08:29:21.300]                 for (kk in seq_along(NAMES)) {
[08:29:21.300]                   name <- added[[kk]]
[08:29:21.300]                   NAME <- NAMES[[kk]]
[08:29:21.300]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.300]                     next
[08:29:21.300]                   args[[name]] <- ""
[08:29:21.300]                 }
[08:29:21.300]                 NAMES <- toupper(removed)
[08:29:21.300]                 for (kk in seq_along(NAMES)) {
[08:29:21.300]                   name <- removed[[kk]]
[08:29:21.300]                   NAME <- NAMES[[kk]]
[08:29:21.300]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.300]                     next
[08:29:21.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.300]                 }
[08:29:21.300]                 if (length(args) > 0) 
[08:29:21.300]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.300]             }
[08:29:21.300]             else {
[08:29:21.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.300]             }
[08:29:21.300]             {
[08:29:21.300]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.300]                   0L) {
[08:29:21.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.300]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.300]                   base::options(opts)
[08:29:21.300]                 }
[08:29:21.300]                 {
[08:29:21.300]                   {
[08:29:21.300]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.300]                     NULL
[08:29:21.300]                   }
[08:29:21.300]                   options(future.plan = NULL)
[08:29:21.300]                   if (is.na(NA_character_)) 
[08:29:21.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.300]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.300]                     .init = FALSE)
[08:29:21.300]                 }
[08:29:21.300]             }
[08:29:21.300]         }
[08:29:21.300]     })
[08:29:21.300]     if (TRUE) {
[08:29:21.300]         base::sink(type = "output", split = FALSE)
[08:29:21.300]         if (TRUE) {
[08:29:21.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.300]         }
[08:29:21.300]         else {
[08:29:21.300]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.300]         }
[08:29:21.300]         base::close(...future.stdout)
[08:29:21.300]         ...future.stdout <- NULL
[08:29:21.300]     }
[08:29:21.300]     ...future.result$conditions <- ...future.conditions
[08:29:21.300]     ...future.result$finished <- base::Sys.time()
[08:29:21.300]     ...future.result
[08:29:21.300] }
[08:29:21.303] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[08:29:21.303] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[08:29:21.303] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[08:29:21.303] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[08:29:21.304] MultisessionFuture started
[08:29:21.304] - Launch lazy future ... done
[08:29:21.304] run() for ‘MultisessionFuture’ ... done
[08:29:21.315] run() for ‘Future’ ...
[08:29:21.315] - state: ‘created’
[08:29:21.315] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.329] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.329]   - Field: ‘node’
[08:29:21.329]   - Field: ‘label’
[08:29:21.329]   - Field: ‘local’
[08:29:21.330]   - Field: ‘owner’
[08:29:21.330]   - Field: ‘envir’
[08:29:21.330]   - Field: ‘workers’
[08:29:21.330]   - Field: ‘packages’
[08:29:21.330]   - Field: ‘gc’
[08:29:21.330]   - Field: ‘conditions’
[08:29:21.330]   - Field: ‘persistent’
[08:29:21.330]   - Field: ‘expr’
[08:29:21.330]   - Field: ‘uuid’
[08:29:21.330]   - Field: ‘seed’
[08:29:21.330]   - Field: ‘version’
[08:29:21.330]   - Field: ‘result’
[08:29:21.331]   - Field: ‘asynchronous’
[08:29:21.331]   - Field: ‘calls’
[08:29:21.331]   - Field: ‘globals’
[08:29:21.331]   - Field: ‘stdout’
[08:29:21.331]   - Field: ‘earlySignal’
[08:29:21.331]   - Field: ‘lazy’
[08:29:21.331]   - Field: ‘state’
[08:29:21.331] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.331] - Launch lazy future ...
[08:29:21.331] Packages needed by the future expression (n = 0): <none>
[08:29:21.332] Packages needed by future strategies (n = 0): <none>
[08:29:21.332] {
[08:29:21.332]     {
[08:29:21.332]         {
[08:29:21.332]             ...future.startTime <- base::Sys.time()
[08:29:21.332]             {
[08:29:21.332]                 {
[08:29:21.332]                   {
[08:29:21.332]                     {
[08:29:21.332]                       base::local({
[08:29:21.332]                         has_future <- base::requireNamespace("future", 
[08:29:21.332]                           quietly = TRUE)
[08:29:21.332]                         if (has_future) {
[08:29:21.332]                           ns <- base::getNamespace("future")
[08:29:21.332]                           version <- ns[[".package"]][["version"]]
[08:29:21.332]                           if (is.null(version)) 
[08:29:21.332]                             version <- utils::packageVersion("future")
[08:29:21.332]                         }
[08:29:21.332]                         else {
[08:29:21.332]                           version <- NULL
[08:29:21.332]                         }
[08:29:21.332]                         if (!has_future || version < "1.8.0") {
[08:29:21.332]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.332]                             "", base::R.version$version.string), 
[08:29:21.332]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.332]                               "release", "version")], collapse = " "), 
[08:29:21.332]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.332]                             info)
[08:29:21.332]                           info <- base::paste(info, collapse = "; ")
[08:29:21.332]                           if (!has_future) {
[08:29:21.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.332]                               info)
[08:29:21.332]                           }
[08:29:21.332]                           else {
[08:29:21.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.332]                               info, version)
[08:29:21.332]                           }
[08:29:21.332]                           base::stop(msg)
[08:29:21.332]                         }
[08:29:21.332]                       })
[08:29:21.332]                     }
[08:29:21.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.332]                     base::options(mc.cores = 1L)
[08:29:21.332]                   }
[08:29:21.332]                   ...future.strategy.old <- future::plan("list")
[08:29:21.332]                   options(future.plan = NULL)
[08:29:21.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.332]                 }
[08:29:21.332]                 ...future.workdir <- getwd()
[08:29:21.332]             }
[08:29:21.332]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.332]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.332]         }
[08:29:21.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.332]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.332]             base::names(...future.oldOptions))
[08:29:21.332]     }
[08:29:21.332]     if (FALSE) {
[08:29:21.332]     }
[08:29:21.332]     else {
[08:29:21.332]         if (TRUE) {
[08:29:21.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.332]                 open = "w")
[08:29:21.332]         }
[08:29:21.332]         else {
[08:29:21.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.332]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.332]         }
[08:29:21.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.332]             base::sink(type = "output", split = FALSE)
[08:29:21.332]             base::close(...future.stdout)
[08:29:21.332]         }, add = TRUE)
[08:29:21.332]     }
[08:29:21.332]     ...future.frame <- base::sys.nframe()
[08:29:21.332]     ...future.conditions <- base::list()
[08:29:21.332]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.332]     if (FALSE) {
[08:29:21.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.332]     }
[08:29:21.332]     ...future.result <- base::tryCatch({
[08:29:21.332]         base::withCallingHandlers({
[08:29:21.332]             ...future.value <- base::withVisible(base::local({
[08:29:21.332]                 ...future.makeSendCondition <- base::local({
[08:29:21.332]                   sendCondition <- NULL
[08:29:21.332]                   function(frame = 1L) {
[08:29:21.332]                     if (is.function(sendCondition)) 
[08:29:21.332]                       return(sendCondition)
[08:29:21.332]                     ns <- getNamespace("parallel")
[08:29:21.332]                     if (exists("sendData", mode = "function", 
[08:29:21.332]                       envir = ns)) {
[08:29:21.332]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.332]                         envir = ns)
[08:29:21.332]                       envir <- sys.frame(frame)
[08:29:21.332]                       master <- NULL
[08:29:21.332]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.332]                         !identical(envir, emptyenv())) {
[08:29:21.332]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.332]                           inherits = FALSE)) {
[08:29:21.332]                           master <- get("master", mode = "list", 
[08:29:21.332]                             envir = envir, inherits = FALSE)
[08:29:21.332]                           if (inherits(master, c("SOCKnode", 
[08:29:21.332]                             "SOCK0node"))) {
[08:29:21.332]                             sendCondition <<- function(cond) {
[08:29:21.332]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.332]                                 success = TRUE)
[08:29:21.332]                               parallel_sendData(master, data)
[08:29:21.332]                             }
[08:29:21.332]                             return(sendCondition)
[08:29:21.332]                           }
[08:29:21.332]                         }
[08:29:21.332]                         frame <- frame + 1L
[08:29:21.332]                         envir <- sys.frame(frame)
[08:29:21.332]                       }
[08:29:21.332]                     }
[08:29:21.332]                     sendCondition <<- function(cond) NULL
[08:29:21.332]                   }
[08:29:21.332]                 })
[08:29:21.332]                 withCallingHandlers({
[08:29:21.332]                   {
[08:29:21.332]                     Sys.sleep(0.1)
[08:29:21.332]                     kk
[08:29:21.332]                   }
[08:29:21.332]                 }, immediateCondition = function(cond) {
[08:29:21.332]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.332]                   sendCondition(cond)
[08:29:21.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.332]                   {
[08:29:21.332]                     inherits <- base::inherits
[08:29:21.332]                     invokeRestart <- base::invokeRestart
[08:29:21.332]                     is.null <- base::is.null
[08:29:21.332]                     muffled <- FALSE
[08:29:21.332]                     if (inherits(cond, "message")) {
[08:29:21.332]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.332]                       if (muffled) 
[08:29:21.332]                         invokeRestart("muffleMessage")
[08:29:21.332]                     }
[08:29:21.332]                     else if (inherits(cond, "warning")) {
[08:29:21.332]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.332]                       if (muffled) 
[08:29:21.332]                         invokeRestart("muffleWarning")
[08:29:21.332]                     }
[08:29:21.332]                     else if (inherits(cond, "condition")) {
[08:29:21.332]                       if (!is.null(pattern)) {
[08:29:21.332]                         computeRestarts <- base::computeRestarts
[08:29:21.332]                         grepl <- base::grepl
[08:29:21.332]                         restarts <- computeRestarts(cond)
[08:29:21.332]                         for (restart in restarts) {
[08:29:21.332]                           name <- restart$name
[08:29:21.332]                           if (is.null(name)) 
[08:29:21.332]                             next
[08:29:21.332]                           if (!grepl(pattern, name)) 
[08:29:21.332]                             next
[08:29:21.332]                           invokeRestart(restart)
[08:29:21.332]                           muffled <- TRUE
[08:29:21.332]                           break
[08:29:21.332]                         }
[08:29:21.332]                       }
[08:29:21.332]                     }
[08:29:21.332]                     invisible(muffled)
[08:29:21.332]                   }
[08:29:21.332]                   muffleCondition(cond)
[08:29:21.332]                 })
[08:29:21.332]             }))
[08:29:21.332]             future::FutureResult(value = ...future.value$value, 
[08:29:21.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.332]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.332]                     ...future.globalenv.names))
[08:29:21.332]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.332]         }, condition = base::local({
[08:29:21.332]             c <- base::c
[08:29:21.332]             inherits <- base::inherits
[08:29:21.332]             invokeRestart <- base::invokeRestart
[08:29:21.332]             length <- base::length
[08:29:21.332]             list <- base::list
[08:29:21.332]             seq.int <- base::seq.int
[08:29:21.332]             signalCondition <- base::signalCondition
[08:29:21.332]             sys.calls <- base::sys.calls
[08:29:21.332]             `[[` <- base::`[[`
[08:29:21.332]             `+` <- base::`+`
[08:29:21.332]             `<<-` <- base::`<<-`
[08:29:21.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.332]                   3L)]
[08:29:21.332]             }
[08:29:21.332]             function(cond) {
[08:29:21.332]                 is_error <- inherits(cond, "error")
[08:29:21.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.332]                   NULL)
[08:29:21.332]                 if (is_error) {
[08:29:21.332]                   sessionInformation <- function() {
[08:29:21.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.332]                       search = base::search(), system = base::Sys.info())
[08:29:21.332]                   }
[08:29:21.332]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.332]                     cond$call), session = sessionInformation(), 
[08:29:21.332]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.332]                   signalCondition(cond)
[08:29:21.332]                 }
[08:29:21.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.332]                 "immediateCondition"))) {
[08:29:21.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.332]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.332]                   if (TRUE && !signal) {
[08:29:21.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.332]                     {
[08:29:21.332]                       inherits <- base::inherits
[08:29:21.332]                       invokeRestart <- base::invokeRestart
[08:29:21.332]                       is.null <- base::is.null
[08:29:21.332]                       muffled <- FALSE
[08:29:21.332]                       if (inherits(cond, "message")) {
[08:29:21.332]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.332]                         if (muffled) 
[08:29:21.332]                           invokeRestart("muffleMessage")
[08:29:21.332]                       }
[08:29:21.332]                       else if (inherits(cond, "warning")) {
[08:29:21.332]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.332]                         if (muffled) 
[08:29:21.332]                           invokeRestart("muffleWarning")
[08:29:21.332]                       }
[08:29:21.332]                       else if (inherits(cond, "condition")) {
[08:29:21.332]                         if (!is.null(pattern)) {
[08:29:21.332]                           computeRestarts <- base::computeRestarts
[08:29:21.332]                           grepl <- base::grepl
[08:29:21.332]                           restarts <- computeRestarts(cond)
[08:29:21.332]                           for (restart in restarts) {
[08:29:21.332]                             name <- restart$name
[08:29:21.332]                             if (is.null(name)) 
[08:29:21.332]                               next
[08:29:21.332]                             if (!grepl(pattern, name)) 
[08:29:21.332]                               next
[08:29:21.332]                             invokeRestart(restart)
[08:29:21.332]                             muffled <- TRUE
[08:29:21.332]                             break
[08:29:21.332]                           }
[08:29:21.332]                         }
[08:29:21.332]                       }
[08:29:21.332]                       invisible(muffled)
[08:29:21.332]                     }
[08:29:21.332]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.332]                   }
[08:29:21.332]                 }
[08:29:21.332]                 else {
[08:29:21.332]                   if (TRUE) {
[08:29:21.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.332]                     {
[08:29:21.332]                       inherits <- base::inherits
[08:29:21.332]                       invokeRestart <- base::invokeRestart
[08:29:21.332]                       is.null <- base::is.null
[08:29:21.332]                       muffled <- FALSE
[08:29:21.332]                       if (inherits(cond, "message")) {
[08:29:21.332]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.332]                         if (muffled) 
[08:29:21.332]                           invokeRestart("muffleMessage")
[08:29:21.332]                       }
[08:29:21.332]                       else if (inherits(cond, "warning")) {
[08:29:21.332]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.332]                         if (muffled) 
[08:29:21.332]                           invokeRestart("muffleWarning")
[08:29:21.332]                       }
[08:29:21.332]                       else if (inherits(cond, "condition")) {
[08:29:21.332]                         if (!is.null(pattern)) {
[08:29:21.332]                           computeRestarts <- base::computeRestarts
[08:29:21.332]                           grepl <- base::grepl
[08:29:21.332]                           restarts <- computeRestarts(cond)
[08:29:21.332]                           for (restart in restarts) {
[08:29:21.332]                             name <- restart$name
[08:29:21.332]                             if (is.null(name)) 
[08:29:21.332]                               next
[08:29:21.332]                             if (!grepl(pattern, name)) 
[08:29:21.332]                               next
[08:29:21.332]                             invokeRestart(restart)
[08:29:21.332]                             muffled <- TRUE
[08:29:21.332]                             break
[08:29:21.332]                           }
[08:29:21.332]                         }
[08:29:21.332]                       }
[08:29:21.332]                       invisible(muffled)
[08:29:21.332]                     }
[08:29:21.332]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.332]                   }
[08:29:21.332]                 }
[08:29:21.332]             }
[08:29:21.332]         }))
[08:29:21.332]     }, error = function(ex) {
[08:29:21.332]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.332]                 ...future.rng), started = ...future.startTime, 
[08:29:21.332]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.332]             version = "1.8"), class = "FutureResult")
[08:29:21.332]     }, finally = {
[08:29:21.332]         if (!identical(...future.workdir, getwd())) 
[08:29:21.332]             setwd(...future.workdir)
[08:29:21.332]         {
[08:29:21.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.332]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.332]             }
[08:29:21.332]             base::options(...future.oldOptions)
[08:29:21.332]             if (.Platform$OS.type == "windows") {
[08:29:21.332]                 old_names <- names(...future.oldEnvVars)
[08:29:21.332]                 envs <- base::Sys.getenv()
[08:29:21.332]                 names <- names(envs)
[08:29:21.332]                 common <- intersect(names, old_names)
[08:29:21.332]                 added <- setdiff(names, old_names)
[08:29:21.332]                 removed <- setdiff(old_names, names)
[08:29:21.332]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.332]                   envs[common]]
[08:29:21.332]                 NAMES <- toupper(changed)
[08:29:21.332]                 args <- list()
[08:29:21.332]                 for (kk in seq_along(NAMES)) {
[08:29:21.332]                   name <- changed[[kk]]
[08:29:21.332]                   NAME <- NAMES[[kk]]
[08:29:21.332]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.332]                     next
[08:29:21.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.332]                 }
[08:29:21.332]                 NAMES <- toupper(added)
[08:29:21.332]                 for (kk in seq_along(NAMES)) {
[08:29:21.332]                   name <- added[[kk]]
[08:29:21.332]                   NAME <- NAMES[[kk]]
[08:29:21.332]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.332]                     next
[08:29:21.332]                   args[[name]] <- ""
[08:29:21.332]                 }
[08:29:21.332]                 NAMES <- toupper(removed)
[08:29:21.332]                 for (kk in seq_along(NAMES)) {
[08:29:21.332]                   name <- removed[[kk]]
[08:29:21.332]                   NAME <- NAMES[[kk]]
[08:29:21.332]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.332]                     next
[08:29:21.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.332]                 }
[08:29:21.332]                 if (length(args) > 0) 
[08:29:21.332]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.332]             }
[08:29:21.332]             else {
[08:29:21.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.332]             }
[08:29:21.332]             {
[08:29:21.332]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.332]                   0L) {
[08:29:21.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.332]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.332]                   base::options(opts)
[08:29:21.332]                 }
[08:29:21.332]                 {
[08:29:21.332]                   {
[08:29:21.332]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.332]                     NULL
[08:29:21.332]                   }
[08:29:21.332]                   options(future.plan = NULL)
[08:29:21.332]                   if (is.na(NA_character_)) 
[08:29:21.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.332]                     .init = FALSE)
[08:29:21.332]                 }
[08:29:21.332]             }
[08:29:21.332]         }
[08:29:21.332]     })
[08:29:21.332]     if (TRUE) {
[08:29:21.332]         base::sink(type = "output", split = FALSE)
[08:29:21.332]         if (TRUE) {
[08:29:21.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.332]         }
[08:29:21.332]         else {
[08:29:21.332]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.332]         }
[08:29:21.332]         base::close(...future.stdout)
[08:29:21.332]         ...future.stdout <- NULL
[08:29:21.332]     }
[08:29:21.332]     ...future.result$conditions <- ...future.conditions
[08:29:21.332]     ...future.result$finished <- base::Sys.time()
[08:29:21.332]     ...future.result
[08:29:21.332] }
[08:29:21.335] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[08:29:21.335] Exporting ‘kk’ (35 bytes) to cluster node #2 ...
[08:29:21.335] Exporting ‘kk’ (35 bytes) to cluster node #2 ... DONE
[08:29:21.335] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[08:29:21.336] MultisessionFuture started
[08:29:21.336] - Launch lazy future ... done
[08:29:21.336] run() for ‘MultisessionFuture’ ... done
[08:29:21.346] run() for ‘Future’ ...
[08:29:21.347] - state: ‘created’
[08:29:21.347] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.361] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.361] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.361]   - Field: ‘node’
[08:29:21.361]   - Field: ‘label’
[08:29:21.361]   - Field: ‘local’
[08:29:21.361]   - Field: ‘owner’
[08:29:21.361]   - Field: ‘envir’
[08:29:21.361]   - Field: ‘workers’
[08:29:21.361]   - Field: ‘packages’
[08:29:21.361]   - Field: ‘gc’
[08:29:21.361]   - Field: ‘conditions’
[08:29:21.362]   - Field: ‘persistent’
[08:29:21.362]   - Field: ‘expr’
[08:29:21.362]   - Field: ‘uuid’
[08:29:21.362]   - Field: ‘seed’
[08:29:21.362]   - Field: ‘version’
[08:29:21.362]   - Field: ‘result’
[08:29:21.362]   - Field: ‘asynchronous’
[08:29:21.362]   - Field: ‘calls’
[08:29:21.362]   - Field: ‘globals’
[08:29:21.362]   - Field: ‘stdout’
[08:29:21.362]   - Field: ‘earlySignal’
[08:29:21.363]   - Field: ‘lazy’
[08:29:21.363]   - Field: ‘state’
[08:29:21.363] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.363] - Launch lazy future ...
[08:29:21.363] Packages needed by the future expression (n = 0): <none>
[08:29:21.363] Packages needed by future strategies (n = 0): <none>
[08:29:21.364] {
[08:29:21.364]     {
[08:29:21.364]         {
[08:29:21.364]             ...future.startTime <- base::Sys.time()
[08:29:21.364]             {
[08:29:21.364]                 {
[08:29:21.364]                   {
[08:29:21.364]                     {
[08:29:21.364]                       base::local({
[08:29:21.364]                         has_future <- base::requireNamespace("future", 
[08:29:21.364]                           quietly = TRUE)
[08:29:21.364]                         if (has_future) {
[08:29:21.364]                           ns <- base::getNamespace("future")
[08:29:21.364]                           version <- ns[[".package"]][["version"]]
[08:29:21.364]                           if (is.null(version)) 
[08:29:21.364]                             version <- utils::packageVersion("future")
[08:29:21.364]                         }
[08:29:21.364]                         else {
[08:29:21.364]                           version <- NULL
[08:29:21.364]                         }
[08:29:21.364]                         if (!has_future || version < "1.8.0") {
[08:29:21.364]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.364]                             "", base::R.version$version.string), 
[08:29:21.364]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.364]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.364]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.364]                               "release", "version")], collapse = " "), 
[08:29:21.364]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.364]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.364]                             info)
[08:29:21.364]                           info <- base::paste(info, collapse = "; ")
[08:29:21.364]                           if (!has_future) {
[08:29:21.364]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.364]                               info)
[08:29:21.364]                           }
[08:29:21.364]                           else {
[08:29:21.364]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.364]                               info, version)
[08:29:21.364]                           }
[08:29:21.364]                           base::stop(msg)
[08:29:21.364]                         }
[08:29:21.364]                       })
[08:29:21.364]                     }
[08:29:21.364]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.364]                     base::options(mc.cores = 1L)
[08:29:21.364]                   }
[08:29:21.364]                   ...future.strategy.old <- future::plan("list")
[08:29:21.364]                   options(future.plan = NULL)
[08:29:21.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.364]                 }
[08:29:21.364]                 ...future.workdir <- getwd()
[08:29:21.364]             }
[08:29:21.364]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.364]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.364]         }
[08:29:21.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.364]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.364]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.364]             base::names(...future.oldOptions))
[08:29:21.364]     }
[08:29:21.364]     if (FALSE) {
[08:29:21.364]     }
[08:29:21.364]     else {
[08:29:21.364]         if (TRUE) {
[08:29:21.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.364]                 open = "w")
[08:29:21.364]         }
[08:29:21.364]         else {
[08:29:21.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.364]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.364]         }
[08:29:21.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.364]             base::sink(type = "output", split = FALSE)
[08:29:21.364]             base::close(...future.stdout)
[08:29:21.364]         }, add = TRUE)
[08:29:21.364]     }
[08:29:21.364]     ...future.frame <- base::sys.nframe()
[08:29:21.364]     ...future.conditions <- base::list()
[08:29:21.364]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.364]     if (FALSE) {
[08:29:21.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.364]     }
[08:29:21.364]     ...future.result <- base::tryCatch({
[08:29:21.364]         base::withCallingHandlers({
[08:29:21.364]             ...future.value <- base::withVisible(base::local({
[08:29:21.364]                 ...future.makeSendCondition <- base::local({
[08:29:21.364]                   sendCondition <- NULL
[08:29:21.364]                   function(frame = 1L) {
[08:29:21.364]                     if (is.function(sendCondition)) 
[08:29:21.364]                       return(sendCondition)
[08:29:21.364]                     ns <- getNamespace("parallel")
[08:29:21.364]                     if (exists("sendData", mode = "function", 
[08:29:21.364]                       envir = ns)) {
[08:29:21.364]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.364]                         envir = ns)
[08:29:21.364]                       envir <- sys.frame(frame)
[08:29:21.364]                       master <- NULL
[08:29:21.364]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.364]                         !identical(envir, emptyenv())) {
[08:29:21.364]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.364]                           inherits = FALSE)) {
[08:29:21.364]                           master <- get("master", mode = "list", 
[08:29:21.364]                             envir = envir, inherits = FALSE)
[08:29:21.364]                           if (inherits(master, c("SOCKnode", 
[08:29:21.364]                             "SOCK0node"))) {
[08:29:21.364]                             sendCondition <<- function(cond) {
[08:29:21.364]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.364]                                 success = TRUE)
[08:29:21.364]                               parallel_sendData(master, data)
[08:29:21.364]                             }
[08:29:21.364]                             return(sendCondition)
[08:29:21.364]                           }
[08:29:21.364]                         }
[08:29:21.364]                         frame <- frame + 1L
[08:29:21.364]                         envir <- sys.frame(frame)
[08:29:21.364]                       }
[08:29:21.364]                     }
[08:29:21.364]                     sendCondition <<- function(cond) NULL
[08:29:21.364]                   }
[08:29:21.364]                 })
[08:29:21.364]                 withCallingHandlers({
[08:29:21.364]                   {
[08:29:21.364]                     Sys.sleep(0.1)
[08:29:21.364]                     kk
[08:29:21.364]                   }
[08:29:21.364]                 }, immediateCondition = function(cond) {
[08:29:21.364]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.364]                   sendCondition(cond)
[08:29:21.364]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.364]                   {
[08:29:21.364]                     inherits <- base::inherits
[08:29:21.364]                     invokeRestart <- base::invokeRestart
[08:29:21.364]                     is.null <- base::is.null
[08:29:21.364]                     muffled <- FALSE
[08:29:21.364]                     if (inherits(cond, "message")) {
[08:29:21.364]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.364]                       if (muffled) 
[08:29:21.364]                         invokeRestart("muffleMessage")
[08:29:21.364]                     }
[08:29:21.364]                     else if (inherits(cond, "warning")) {
[08:29:21.364]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.364]                       if (muffled) 
[08:29:21.364]                         invokeRestart("muffleWarning")
[08:29:21.364]                     }
[08:29:21.364]                     else if (inherits(cond, "condition")) {
[08:29:21.364]                       if (!is.null(pattern)) {
[08:29:21.364]                         computeRestarts <- base::computeRestarts
[08:29:21.364]                         grepl <- base::grepl
[08:29:21.364]                         restarts <- computeRestarts(cond)
[08:29:21.364]                         for (restart in restarts) {
[08:29:21.364]                           name <- restart$name
[08:29:21.364]                           if (is.null(name)) 
[08:29:21.364]                             next
[08:29:21.364]                           if (!grepl(pattern, name)) 
[08:29:21.364]                             next
[08:29:21.364]                           invokeRestart(restart)
[08:29:21.364]                           muffled <- TRUE
[08:29:21.364]                           break
[08:29:21.364]                         }
[08:29:21.364]                       }
[08:29:21.364]                     }
[08:29:21.364]                     invisible(muffled)
[08:29:21.364]                   }
[08:29:21.364]                   muffleCondition(cond)
[08:29:21.364]                 })
[08:29:21.364]             }))
[08:29:21.364]             future::FutureResult(value = ...future.value$value, 
[08:29:21.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.364]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.364]                     ...future.globalenv.names))
[08:29:21.364]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.364]         }, condition = base::local({
[08:29:21.364]             c <- base::c
[08:29:21.364]             inherits <- base::inherits
[08:29:21.364]             invokeRestart <- base::invokeRestart
[08:29:21.364]             length <- base::length
[08:29:21.364]             list <- base::list
[08:29:21.364]             seq.int <- base::seq.int
[08:29:21.364]             signalCondition <- base::signalCondition
[08:29:21.364]             sys.calls <- base::sys.calls
[08:29:21.364]             `[[` <- base::`[[`
[08:29:21.364]             `+` <- base::`+`
[08:29:21.364]             `<<-` <- base::`<<-`
[08:29:21.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.364]                   3L)]
[08:29:21.364]             }
[08:29:21.364]             function(cond) {
[08:29:21.364]                 is_error <- inherits(cond, "error")
[08:29:21.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.364]                   NULL)
[08:29:21.364]                 if (is_error) {
[08:29:21.364]                   sessionInformation <- function() {
[08:29:21.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.364]                       search = base::search(), system = base::Sys.info())
[08:29:21.364]                   }
[08:29:21.364]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.364]                     cond$call), session = sessionInformation(), 
[08:29:21.364]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.364]                   signalCondition(cond)
[08:29:21.364]                 }
[08:29:21.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.364]                 "immediateCondition"))) {
[08:29:21.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.364]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.364]                   if (TRUE && !signal) {
[08:29:21.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.364]                     {
[08:29:21.364]                       inherits <- base::inherits
[08:29:21.364]                       invokeRestart <- base::invokeRestart
[08:29:21.364]                       is.null <- base::is.null
[08:29:21.364]                       muffled <- FALSE
[08:29:21.364]                       if (inherits(cond, "message")) {
[08:29:21.364]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.364]                         if (muffled) 
[08:29:21.364]                           invokeRestart("muffleMessage")
[08:29:21.364]                       }
[08:29:21.364]                       else if (inherits(cond, "warning")) {
[08:29:21.364]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.364]                         if (muffled) 
[08:29:21.364]                           invokeRestart("muffleWarning")
[08:29:21.364]                       }
[08:29:21.364]                       else if (inherits(cond, "condition")) {
[08:29:21.364]                         if (!is.null(pattern)) {
[08:29:21.364]                           computeRestarts <- base::computeRestarts
[08:29:21.364]                           grepl <- base::grepl
[08:29:21.364]                           restarts <- computeRestarts(cond)
[08:29:21.364]                           for (restart in restarts) {
[08:29:21.364]                             name <- restart$name
[08:29:21.364]                             if (is.null(name)) 
[08:29:21.364]                               next
[08:29:21.364]                             if (!grepl(pattern, name)) 
[08:29:21.364]                               next
[08:29:21.364]                             invokeRestart(restart)
[08:29:21.364]                             muffled <- TRUE
[08:29:21.364]                             break
[08:29:21.364]                           }
[08:29:21.364]                         }
[08:29:21.364]                       }
[08:29:21.364]                       invisible(muffled)
[08:29:21.364]                     }
[08:29:21.364]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.364]                   }
[08:29:21.364]                 }
[08:29:21.364]                 else {
[08:29:21.364]                   if (TRUE) {
[08:29:21.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.364]                     {
[08:29:21.364]                       inherits <- base::inherits
[08:29:21.364]                       invokeRestart <- base::invokeRestart
[08:29:21.364]                       is.null <- base::is.null
[08:29:21.364]                       muffled <- FALSE
[08:29:21.364]                       if (inherits(cond, "message")) {
[08:29:21.364]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.364]                         if (muffled) 
[08:29:21.364]                           invokeRestart("muffleMessage")
[08:29:21.364]                       }
[08:29:21.364]                       else if (inherits(cond, "warning")) {
[08:29:21.364]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.364]                         if (muffled) 
[08:29:21.364]                           invokeRestart("muffleWarning")
[08:29:21.364]                       }
[08:29:21.364]                       else if (inherits(cond, "condition")) {
[08:29:21.364]                         if (!is.null(pattern)) {
[08:29:21.364]                           computeRestarts <- base::computeRestarts
[08:29:21.364]                           grepl <- base::grepl
[08:29:21.364]                           restarts <- computeRestarts(cond)
[08:29:21.364]                           for (restart in restarts) {
[08:29:21.364]                             name <- restart$name
[08:29:21.364]                             if (is.null(name)) 
[08:29:21.364]                               next
[08:29:21.364]                             if (!grepl(pattern, name)) 
[08:29:21.364]                               next
[08:29:21.364]                             invokeRestart(restart)
[08:29:21.364]                             muffled <- TRUE
[08:29:21.364]                             break
[08:29:21.364]                           }
[08:29:21.364]                         }
[08:29:21.364]                       }
[08:29:21.364]                       invisible(muffled)
[08:29:21.364]                     }
[08:29:21.364]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.364]                   }
[08:29:21.364]                 }
[08:29:21.364]             }
[08:29:21.364]         }))
[08:29:21.364]     }, error = function(ex) {
[08:29:21.364]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.364]                 ...future.rng), started = ...future.startTime, 
[08:29:21.364]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.364]             version = "1.8"), class = "FutureResult")
[08:29:21.364]     }, finally = {
[08:29:21.364]         if (!identical(...future.workdir, getwd())) 
[08:29:21.364]             setwd(...future.workdir)
[08:29:21.364]         {
[08:29:21.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.364]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.364]             }
[08:29:21.364]             base::options(...future.oldOptions)
[08:29:21.364]             if (.Platform$OS.type == "windows") {
[08:29:21.364]                 old_names <- names(...future.oldEnvVars)
[08:29:21.364]                 envs <- base::Sys.getenv()
[08:29:21.364]                 names <- names(envs)
[08:29:21.364]                 common <- intersect(names, old_names)
[08:29:21.364]                 added <- setdiff(names, old_names)
[08:29:21.364]                 removed <- setdiff(old_names, names)
[08:29:21.364]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.364]                   envs[common]]
[08:29:21.364]                 NAMES <- toupper(changed)
[08:29:21.364]                 args <- list()
[08:29:21.364]                 for (kk in seq_along(NAMES)) {
[08:29:21.364]                   name <- changed[[kk]]
[08:29:21.364]                   NAME <- NAMES[[kk]]
[08:29:21.364]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.364]                     next
[08:29:21.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.364]                 }
[08:29:21.364]                 NAMES <- toupper(added)
[08:29:21.364]                 for (kk in seq_along(NAMES)) {
[08:29:21.364]                   name <- added[[kk]]
[08:29:21.364]                   NAME <- NAMES[[kk]]
[08:29:21.364]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.364]                     next
[08:29:21.364]                   args[[name]] <- ""
[08:29:21.364]                 }
[08:29:21.364]                 NAMES <- toupper(removed)
[08:29:21.364]                 for (kk in seq_along(NAMES)) {
[08:29:21.364]                   name <- removed[[kk]]
[08:29:21.364]                   NAME <- NAMES[[kk]]
[08:29:21.364]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.364]                     next
[08:29:21.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.364]                 }
[08:29:21.364]                 if (length(args) > 0) 
[08:29:21.364]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.364]             }
[08:29:21.364]             else {
[08:29:21.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.364]             }
[08:29:21.364]             {
[08:29:21.364]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.364]                   0L) {
[08:29:21.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.364]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.364]                   base::options(opts)
[08:29:21.364]                 }
[08:29:21.364]                 {
[08:29:21.364]                   {
[08:29:21.364]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.364]                     NULL
[08:29:21.364]                   }
[08:29:21.364]                   options(future.plan = NULL)
[08:29:21.364]                   if (is.na(NA_character_)) 
[08:29:21.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.364]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.364]                     .init = FALSE)
[08:29:21.364]                 }
[08:29:21.364]             }
[08:29:21.364]         }
[08:29:21.364]     })
[08:29:21.364]     if (TRUE) {
[08:29:21.364]         base::sink(type = "output", split = FALSE)
[08:29:21.364]         if (TRUE) {
[08:29:21.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.364]         }
[08:29:21.364]         else {
[08:29:21.364]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.364]         }
[08:29:21.364]         base::close(...future.stdout)
[08:29:21.364]         ...future.stdout <- NULL
[08:29:21.364]     }
[08:29:21.364]     ...future.result$conditions <- ...future.conditions
[08:29:21.364]     ...future.result$finished <- base::Sys.time()
[08:29:21.364]     ...future.result
[08:29:21.364] }
[08:29:21.366] Poll #1 (0): usedNodes() = 2, workers = 2
[08:29:21.397] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[08:29:21.429] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[08:29:21.446] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.447] - Validating connection of MultisessionFuture
[08:29:21.447] - received message: FutureResult
[08:29:21.447] - Received FutureResult
[08:29:21.447] - Erased future from FutureRegistry
[08:29:21.447] result() for ClusterFuture ...
[08:29:21.447] - result already collected: FutureResult
[08:29:21.447] result() for ClusterFuture ... done
[08:29:21.448] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.448] result() for ClusterFuture ...
[08:29:21.448] - result already collected: FutureResult
[08:29:21.448] result() for ClusterFuture ... done
[08:29:21.448] result() for ClusterFuture ...
[08:29:21.448] - result already collected: FutureResult
[08:29:21.448] result() for ClusterFuture ... done
[08:29:21.449] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[08:29:21.449] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[08:29:21.449] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[08:29:21.449] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[08:29:21.450] MultisessionFuture started
[08:29:21.450] - Launch lazy future ... done
[08:29:21.450] run() for ‘MultisessionFuture’ ... done
[08:29:21.471] Future #1
[08:29:21.471]  length: 2 (resolved future 1)
[08:29:21.478] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.479] - Validating connection of MultisessionFuture
[08:29:21.479] - received message: FutureResult
[08:29:21.479] - Received FutureResult
[08:29:21.479] - Erased future from FutureRegistry
[08:29:21.479] result() for ClusterFuture ...
[08:29:21.479] - result already collected: FutureResult
[08:29:21.479] result() for ClusterFuture ... done
[08:29:21.479] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.479] Future #2
[08:29:21.480]  length: 1 (resolved future 2)
[08:29:21.592] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.593] - Validating connection of MultisessionFuture
[08:29:21.593] - received message: FutureResult
[08:29:21.593] - Received FutureResult
[08:29:21.593] - Erased future from FutureRegistry
[08:29:21.593] result() for ClusterFuture ...
[08:29:21.593] - result already collected: FutureResult
[08:29:21.593] result() for ClusterFuture ... done
[08:29:21.594] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.594] Future #3
[08:29:21.594]  length: 0 (resolved future 3)
[08:29:21.594] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[08:29:21.594] resolve() on environment ...
[08:29:21.595]  recursive: 0
[08:29:21.595]  elements: [2] ‘a’, ‘b’
[08:29:21.595]  length: 1 (resolved future 1)
[08:29:21.595]  length: 0 (resolved future 2)
[08:29:21.595] resolve() on environment ... DONE
[08:29:21.596] getGlobalsAndPackages() ...
[08:29:21.596] Searching for globals...
[08:29:21.596] 
[08:29:21.596] Searching for globals ... DONE
[08:29:21.596] - globals: [0] <none>
[08:29:21.596] getGlobalsAndPackages() ... DONE
[08:29:21.597] run() for ‘Future’ ...
[08:29:21.597] - state: ‘created’
[08:29:21.597] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.611] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.611] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.611]   - Field: ‘node’
[08:29:21.611]   - Field: ‘label’
[08:29:21.611]   - Field: ‘local’
[08:29:21.611]   - Field: ‘owner’
[08:29:21.611]   - Field: ‘envir’
[08:29:21.611]   - Field: ‘workers’
[08:29:21.612]   - Field: ‘packages’
[08:29:21.612]   - Field: ‘gc’
[08:29:21.612]   - Field: ‘conditions’
[08:29:21.612]   - Field: ‘persistent’
[08:29:21.612]   - Field: ‘expr’
[08:29:21.612]   - Field: ‘uuid’
[08:29:21.612]   - Field: ‘seed’
[08:29:21.612]   - Field: ‘version’
[08:29:21.612]   - Field: ‘result’
[08:29:21.612]   - Field: ‘asynchronous’
[08:29:21.612]   - Field: ‘calls’
[08:29:21.612]   - Field: ‘globals’
[08:29:21.613]   - Field: ‘stdout’
[08:29:21.613]   - Field: ‘earlySignal’
[08:29:21.613]   - Field: ‘lazy’
[08:29:21.613]   - Field: ‘state’
[08:29:21.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.613] - Launch lazy future ...
[08:29:21.613] Packages needed by the future expression (n = 0): <none>
[08:29:21.613] Packages needed by future strategies (n = 0): <none>
[08:29:21.614] {
[08:29:21.614]     {
[08:29:21.614]         {
[08:29:21.614]             ...future.startTime <- base::Sys.time()
[08:29:21.614]             {
[08:29:21.614]                 {
[08:29:21.614]                   {
[08:29:21.614]                     {
[08:29:21.614]                       base::local({
[08:29:21.614]                         has_future <- base::requireNamespace("future", 
[08:29:21.614]                           quietly = TRUE)
[08:29:21.614]                         if (has_future) {
[08:29:21.614]                           ns <- base::getNamespace("future")
[08:29:21.614]                           version <- ns[[".package"]][["version"]]
[08:29:21.614]                           if (is.null(version)) 
[08:29:21.614]                             version <- utils::packageVersion("future")
[08:29:21.614]                         }
[08:29:21.614]                         else {
[08:29:21.614]                           version <- NULL
[08:29:21.614]                         }
[08:29:21.614]                         if (!has_future || version < "1.8.0") {
[08:29:21.614]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.614]                             "", base::R.version$version.string), 
[08:29:21.614]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.614]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.614]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.614]                               "release", "version")], collapse = " "), 
[08:29:21.614]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.614]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.614]                             info)
[08:29:21.614]                           info <- base::paste(info, collapse = "; ")
[08:29:21.614]                           if (!has_future) {
[08:29:21.614]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.614]                               info)
[08:29:21.614]                           }
[08:29:21.614]                           else {
[08:29:21.614]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.614]                               info, version)
[08:29:21.614]                           }
[08:29:21.614]                           base::stop(msg)
[08:29:21.614]                         }
[08:29:21.614]                       })
[08:29:21.614]                     }
[08:29:21.614]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.614]                     base::options(mc.cores = 1L)
[08:29:21.614]                   }
[08:29:21.614]                   ...future.strategy.old <- future::plan("list")
[08:29:21.614]                   options(future.plan = NULL)
[08:29:21.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.614]                 }
[08:29:21.614]                 ...future.workdir <- getwd()
[08:29:21.614]             }
[08:29:21.614]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.614]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.614]         }
[08:29:21.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.614]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.614]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.614]             base::names(...future.oldOptions))
[08:29:21.614]     }
[08:29:21.614]     if (FALSE) {
[08:29:21.614]     }
[08:29:21.614]     else {
[08:29:21.614]         if (TRUE) {
[08:29:21.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.614]                 open = "w")
[08:29:21.614]         }
[08:29:21.614]         else {
[08:29:21.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.614]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.614]         }
[08:29:21.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.614]             base::sink(type = "output", split = FALSE)
[08:29:21.614]             base::close(...future.stdout)
[08:29:21.614]         }, add = TRUE)
[08:29:21.614]     }
[08:29:21.614]     ...future.frame <- base::sys.nframe()
[08:29:21.614]     ...future.conditions <- base::list()
[08:29:21.614]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.614]     if (FALSE) {
[08:29:21.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.614]     }
[08:29:21.614]     ...future.result <- base::tryCatch({
[08:29:21.614]         base::withCallingHandlers({
[08:29:21.614]             ...future.value <- base::withVisible(base::local({
[08:29:21.614]                 ...future.makeSendCondition <- base::local({
[08:29:21.614]                   sendCondition <- NULL
[08:29:21.614]                   function(frame = 1L) {
[08:29:21.614]                     if (is.function(sendCondition)) 
[08:29:21.614]                       return(sendCondition)
[08:29:21.614]                     ns <- getNamespace("parallel")
[08:29:21.614]                     if (exists("sendData", mode = "function", 
[08:29:21.614]                       envir = ns)) {
[08:29:21.614]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.614]                         envir = ns)
[08:29:21.614]                       envir <- sys.frame(frame)
[08:29:21.614]                       master <- NULL
[08:29:21.614]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.614]                         !identical(envir, emptyenv())) {
[08:29:21.614]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.614]                           inherits = FALSE)) {
[08:29:21.614]                           master <- get("master", mode = "list", 
[08:29:21.614]                             envir = envir, inherits = FALSE)
[08:29:21.614]                           if (inherits(master, c("SOCKnode", 
[08:29:21.614]                             "SOCK0node"))) {
[08:29:21.614]                             sendCondition <<- function(cond) {
[08:29:21.614]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.614]                                 success = TRUE)
[08:29:21.614]                               parallel_sendData(master, data)
[08:29:21.614]                             }
[08:29:21.614]                             return(sendCondition)
[08:29:21.614]                           }
[08:29:21.614]                         }
[08:29:21.614]                         frame <- frame + 1L
[08:29:21.614]                         envir <- sys.frame(frame)
[08:29:21.614]                       }
[08:29:21.614]                     }
[08:29:21.614]                     sendCondition <<- function(cond) NULL
[08:29:21.614]                   }
[08:29:21.614]                 })
[08:29:21.614]                 withCallingHandlers({
[08:29:21.614]                   1
[08:29:21.614]                 }, immediateCondition = function(cond) {
[08:29:21.614]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.614]                   sendCondition(cond)
[08:29:21.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.614]                   {
[08:29:21.614]                     inherits <- base::inherits
[08:29:21.614]                     invokeRestart <- base::invokeRestart
[08:29:21.614]                     is.null <- base::is.null
[08:29:21.614]                     muffled <- FALSE
[08:29:21.614]                     if (inherits(cond, "message")) {
[08:29:21.614]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.614]                       if (muffled) 
[08:29:21.614]                         invokeRestart("muffleMessage")
[08:29:21.614]                     }
[08:29:21.614]                     else if (inherits(cond, "warning")) {
[08:29:21.614]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.614]                       if (muffled) 
[08:29:21.614]                         invokeRestart("muffleWarning")
[08:29:21.614]                     }
[08:29:21.614]                     else if (inherits(cond, "condition")) {
[08:29:21.614]                       if (!is.null(pattern)) {
[08:29:21.614]                         computeRestarts <- base::computeRestarts
[08:29:21.614]                         grepl <- base::grepl
[08:29:21.614]                         restarts <- computeRestarts(cond)
[08:29:21.614]                         for (restart in restarts) {
[08:29:21.614]                           name <- restart$name
[08:29:21.614]                           if (is.null(name)) 
[08:29:21.614]                             next
[08:29:21.614]                           if (!grepl(pattern, name)) 
[08:29:21.614]                             next
[08:29:21.614]                           invokeRestart(restart)
[08:29:21.614]                           muffled <- TRUE
[08:29:21.614]                           break
[08:29:21.614]                         }
[08:29:21.614]                       }
[08:29:21.614]                     }
[08:29:21.614]                     invisible(muffled)
[08:29:21.614]                   }
[08:29:21.614]                   muffleCondition(cond)
[08:29:21.614]                 })
[08:29:21.614]             }))
[08:29:21.614]             future::FutureResult(value = ...future.value$value, 
[08:29:21.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.614]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.614]                     ...future.globalenv.names))
[08:29:21.614]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.614]         }, condition = base::local({
[08:29:21.614]             c <- base::c
[08:29:21.614]             inherits <- base::inherits
[08:29:21.614]             invokeRestart <- base::invokeRestart
[08:29:21.614]             length <- base::length
[08:29:21.614]             list <- base::list
[08:29:21.614]             seq.int <- base::seq.int
[08:29:21.614]             signalCondition <- base::signalCondition
[08:29:21.614]             sys.calls <- base::sys.calls
[08:29:21.614]             `[[` <- base::`[[`
[08:29:21.614]             `+` <- base::`+`
[08:29:21.614]             `<<-` <- base::`<<-`
[08:29:21.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.614]                   3L)]
[08:29:21.614]             }
[08:29:21.614]             function(cond) {
[08:29:21.614]                 is_error <- inherits(cond, "error")
[08:29:21.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.614]                   NULL)
[08:29:21.614]                 if (is_error) {
[08:29:21.614]                   sessionInformation <- function() {
[08:29:21.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.614]                       search = base::search(), system = base::Sys.info())
[08:29:21.614]                   }
[08:29:21.614]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.614]                     cond$call), session = sessionInformation(), 
[08:29:21.614]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.614]                   signalCondition(cond)
[08:29:21.614]                 }
[08:29:21.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.614]                 "immediateCondition"))) {
[08:29:21.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.614]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.614]                   if (TRUE && !signal) {
[08:29:21.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.614]                     {
[08:29:21.614]                       inherits <- base::inherits
[08:29:21.614]                       invokeRestart <- base::invokeRestart
[08:29:21.614]                       is.null <- base::is.null
[08:29:21.614]                       muffled <- FALSE
[08:29:21.614]                       if (inherits(cond, "message")) {
[08:29:21.614]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.614]                         if (muffled) 
[08:29:21.614]                           invokeRestart("muffleMessage")
[08:29:21.614]                       }
[08:29:21.614]                       else if (inherits(cond, "warning")) {
[08:29:21.614]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.614]                         if (muffled) 
[08:29:21.614]                           invokeRestart("muffleWarning")
[08:29:21.614]                       }
[08:29:21.614]                       else if (inherits(cond, "condition")) {
[08:29:21.614]                         if (!is.null(pattern)) {
[08:29:21.614]                           computeRestarts <- base::computeRestarts
[08:29:21.614]                           grepl <- base::grepl
[08:29:21.614]                           restarts <- computeRestarts(cond)
[08:29:21.614]                           for (restart in restarts) {
[08:29:21.614]                             name <- restart$name
[08:29:21.614]                             if (is.null(name)) 
[08:29:21.614]                               next
[08:29:21.614]                             if (!grepl(pattern, name)) 
[08:29:21.614]                               next
[08:29:21.614]                             invokeRestart(restart)
[08:29:21.614]                             muffled <- TRUE
[08:29:21.614]                             break
[08:29:21.614]                           }
[08:29:21.614]                         }
[08:29:21.614]                       }
[08:29:21.614]                       invisible(muffled)
[08:29:21.614]                     }
[08:29:21.614]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.614]                   }
[08:29:21.614]                 }
[08:29:21.614]                 else {
[08:29:21.614]                   if (TRUE) {
[08:29:21.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.614]                     {
[08:29:21.614]                       inherits <- base::inherits
[08:29:21.614]                       invokeRestart <- base::invokeRestart
[08:29:21.614]                       is.null <- base::is.null
[08:29:21.614]                       muffled <- FALSE
[08:29:21.614]                       if (inherits(cond, "message")) {
[08:29:21.614]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.614]                         if (muffled) 
[08:29:21.614]                           invokeRestart("muffleMessage")
[08:29:21.614]                       }
[08:29:21.614]                       else if (inherits(cond, "warning")) {
[08:29:21.614]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.614]                         if (muffled) 
[08:29:21.614]                           invokeRestart("muffleWarning")
[08:29:21.614]                       }
[08:29:21.614]                       else if (inherits(cond, "condition")) {
[08:29:21.614]                         if (!is.null(pattern)) {
[08:29:21.614]                           computeRestarts <- base::computeRestarts
[08:29:21.614]                           grepl <- base::grepl
[08:29:21.614]                           restarts <- computeRestarts(cond)
[08:29:21.614]                           for (restart in restarts) {
[08:29:21.614]                             name <- restart$name
[08:29:21.614]                             if (is.null(name)) 
[08:29:21.614]                               next
[08:29:21.614]                             if (!grepl(pattern, name)) 
[08:29:21.614]                               next
[08:29:21.614]                             invokeRestart(restart)
[08:29:21.614]                             muffled <- TRUE
[08:29:21.614]                             break
[08:29:21.614]                           }
[08:29:21.614]                         }
[08:29:21.614]                       }
[08:29:21.614]                       invisible(muffled)
[08:29:21.614]                     }
[08:29:21.614]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.614]                   }
[08:29:21.614]                 }
[08:29:21.614]             }
[08:29:21.614]         }))
[08:29:21.614]     }, error = function(ex) {
[08:29:21.614]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.614]                 ...future.rng), started = ...future.startTime, 
[08:29:21.614]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.614]             version = "1.8"), class = "FutureResult")
[08:29:21.614]     }, finally = {
[08:29:21.614]         if (!identical(...future.workdir, getwd())) 
[08:29:21.614]             setwd(...future.workdir)
[08:29:21.614]         {
[08:29:21.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.614]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.614]             }
[08:29:21.614]             base::options(...future.oldOptions)
[08:29:21.614]             if (.Platform$OS.type == "windows") {
[08:29:21.614]                 old_names <- names(...future.oldEnvVars)
[08:29:21.614]                 envs <- base::Sys.getenv()
[08:29:21.614]                 names <- names(envs)
[08:29:21.614]                 common <- intersect(names, old_names)
[08:29:21.614]                 added <- setdiff(names, old_names)
[08:29:21.614]                 removed <- setdiff(old_names, names)
[08:29:21.614]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.614]                   envs[common]]
[08:29:21.614]                 NAMES <- toupper(changed)
[08:29:21.614]                 args <- list()
[08:29:21.614]                 for (kk in seq_along(NAMES)) {
[08:29:21.614]                   name <- changed[[kk]]
[08:29:21.614]                   NAME <- NAMES[[kk]]
[08:29:21.614]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.614]                     next
[08:29:21.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.614]                 }
[08:29:21.614]                 NAMES <- toupper(added)
[08:29:21.614]                 for (kk in seq_along(NAMES)) {
[08:29:21.614]                   name <- added[[kk]]
[08:29:21.614]                   NAME <- NAMES[[kk]]
[08:29:21.614]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.614]                     next
[08:29:21.614]                   args[[name]] <- ""
[08:29:21.614]                 }
[08:29:21.614]                 NAMES <- toupper(removed)
[08:29:21.614]                 for (kk in seq_along(NAMES)) {
[08:29:21.614]                   name <- removed[[kk]]
[08:29:21.614]                   NAME <- NAMES[[kk]]
[08:29:21.614]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.614]                     next
[08:29:21.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.614]                 }
[08:29:21.614]                 if (length(args) > 0) 
[08:29:21.614]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.614]             }
[08:29:21.614]             else {
[08:29:21.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.614]             }
[08:29:21.614]             {
[08:29:21.614]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.614]                   0L) {
[08:29:21.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.614]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.614]                   base::options(opts)
[08:29:21.614]                 }
[08:29:21.614]                 {
[08:29:21.614]                   {
[08:29:21.614]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.614]                     NULL
[08:29:21.614]                   }
[08:29:21.614]                   options(future.plan = NULL)
[08:29:21.614]                   if (is.na(NA_character_)) 
[08:29:21.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.614]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.614]                     .init = FALSE)
[08:29:21.614]                 }
[08:29:21.614]             }
[08:29:21.614]         }
[08:29:21.614]     })
[08:29:21.614]     if (TRUE) {
[08:29:21.614]         base::sink(type = "output", split = FALSE)
[08:29:21.614]         if (TRUE) {
[08:29:21.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.614]         }
[08:29:21.614]         else {
[08:29:21.614]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.614]         }
[08:29:21.614]         base::close(...future.stdout)
[08:29:21.614]         ...future.stdout <- NULL
[08:29:21.614]     }
[08:29:21.614]     ...future.result$conditions <- ...future.conditions
[08:29:21.614]     ...future.result$finished <- base::Sys.time()
[08:29:21.614]     ...future.result
[08:29:21.614] }
[08:29:21.617] MultisessionFuture started
[08:29:21.617] - Launch lazy future ... done
[08:29:21.617] run() for ‘MultisessionFuture’ ... done
[08:29:21.617] getGlobalsAndPackages() ...
[08:29:21.617] Searching for globals...
[08:29:21.618] 
[08:29:21.618] Searching for globals ... DONE
[08:29:21.618] - globals: [0] <none>
[08:29:21.618] getGlobalsAndPackages() ... DONE
[08:29:21.618] run() for ‘Future’ ...
[08:29:21.618] - state: ‘created’
[08:29:21.618] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.632] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.632] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.632]   - Field: ‘node’
[08:29:21.632]   - Field: ‘label’
[08:29:21.632]   - Field: ‘local’
[08:29:21.632]   - Field: ‘owner’
[08:29:21.632]   - Field: ‘envir’
[08:29:21.633]   - Field: ‘workers’
[08:29:21.633]   - Field: ‘packages’
[08:29:21.633]   - Field: ‘gc’
[08:29:21.633]   - Field: ‘conditions’
[08:29:21.633]   - Field: ‘persistent’
[08:29:21.633]   - Field: ‘expr’
[08:29:21.633]   - Field: ‘uuid’
[08:29:21.633]   - Field: ‘seed’
[08:29:21.633]   - Field: ‘version’
[08:29:21.633]   - Field: ‘result’
[08:29:21.633]   - Field: ‘asynchronous’
[08:29:21.633]   - Field: ‘calls’
[08:29:21.634]   - Field: ‘globals’
[08:29:21.634]   - Field: ‘stdout’
[08:29:21.634]   - Field: ‘earlySignal’
[08:29:21.634]   - Field: ‘lazy’
[08:29:21.634]   - Field: ‘state’
[08:29:21.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.634] - Launch lazy future ...
[08:29:21.634] Packages needed by the future expression (n = 0): <none>
[08:29:21.634] Packages needed by future strategies (n = 0): <none>
[08:29:21.635] {
[08:29:21.635]     {
[08:29:21.635]         {
[08:29:21.635]             ...future.startTime <- base::Sys.time()
[08:29:21.635]             {
[08:29:21.635]                 {
[08:29:21.635]                   {
[08:29:21.635]                     {
[08:29:21.635]                       base::local({
[08:29:21.635]                         has_future <- base::requireNamespace("future", 
[08:29:21.635]                           quietly = TRUE)
[08:29:21.635]                         if (has_future) {
[08:29:21.635]                           ns <- base::getNamespace("future")
[08:29:21.635]                           version <- ns[[".package"]][["version"]]
[08:29:21.635]                           if (is.null(version)) 
[08:29:21.635]                             version <- utils::packageVersion("future")
[08:29:21.635]                         }
[08:29:21.635]                         else {
[08:29:21.635]                           version <- NULL
[08:29:21.635]                         }
[08:29:21.635]                         if (!has_future || version < "1.8.0") {
[08:29:21.635]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.635]                             "", base::R.version$version.string), 
[08:29:21.635]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.635]                               "release", "version")], collapse = " "), 
[08:29:21.635]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.635]                             info)
[08:29:21.635]                           info <- base::paste(info, collapse = "; ")
[08:29:21.635]                           if (!has_future) {
[08:29:21.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.635]                               info)
[08:29:21.635]                           }
[08:29:21.635]                           else {
[08:29:21.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.635]                               info, version)
[08:29:21.635]                           }
[08:29:21.635]                           base::stop(msg)
[08:29:21.635]                         }
[08:29:21.635]                       })
[08:29:21.635]                     }
[08:29:21.635]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.635]                     base::options(mc.cores = 1L)
[08:29:21.635]                   }
[08:29:21.635]                   ...future.strategy.old <- future::plan("list")
[08:29:21.635]                   options(future.plan = NULL)
[08:29:21.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.635]                 }
[08:29:21.635]                 ...future.workdir <- getwd()
[08:29:21.635]             }
[08:29:21.635]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.635]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.635]         }
[08:29:21.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.635]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.635]             base::names(...future.oldOptions))
[08:29:21.635]     }
[08:29:21.635]     if (FALSE) {
[08:29:21.635]     }
[08:29:21.635]     else {
[08:29:21.635]         if (TRUE) {
[08:29:21.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.635]                 open = "w")
[08:29:21.635]         }
[08:29:21.635]         else {
[08:29:21.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.635]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.635]         }
[08:29:21.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.635]             base::sink(type = "output", split = FALSE)
[08:29:21.635]             base::close(...future.stdout)
[08:29:21.635]         }, add = TRUE)
[08:29:21.635]     }
[08:29:21.635]     ...future.frame <- base::sys.nframe()
[08:29:21.635]     ...future.conditions <- base::list()
[08:29:21.635]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.635]     if (FALSE) {
[08:29:21.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.635]     }
[08:29:21.635]     ...future.result <- base::tryCatch({
[08:29:21.635]         base::withCallingHandlers({
[08:29:21.635]             ...future.value <- base::withVisible(base::local({
[08:29:21.635]                 ...future.makeSendCondition <- base::local({
[08:29:21.635]                   sendCondition <- NULL
[08:29:21.635]                   function(frame = 1L) {
[08:29:21.635]                     if (is.function(sendCondition)) 
[08:29:21.635]                       return(sendCondition)
[08:29:21.635]                     ns <- getNamespace("parallel")
[08:29:21.635]                     if (exists("sendData", mode = "function", 
[08:29:21.635]                       envir = ns)) {
[08:29:21.635]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.635]                         envir = ns)
[08:29:21.635]                       envir <- sys.frame(frame)
[08:29:21.635]                       master <- NULL
[08:29:21.635]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.635]                         !identical(envir, emptyenv())) {
[08:29:21.635]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.635]                           inherits = FALSE)) {
[08:29:21.635]                           master <- get("master", mode = "list", 
[08:29:21.635]                             envir = envir, inherits = FALSE)
[08:29:21.635]                           if (inherits(master, c("SOCKnode", 
[08:29:21.635]                             "SOCK0node"))) {
[08:29:21.635]                             sendCondition <<- function(cond) {
[08:29:21.635]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.635]                                 success = TRUE)
[08:29:21.635]                               parallel_sendData(master, data)
[08:29:21.635]                             }
[08:29:21.635]                             return(sendCondition)
[08:29:21.635]                           }
[08:29:21.635]                         }
[08:29:21.635]                         frame <- frame + 1L
[08:29:21.635]                         envir <- sys.frame(frame)
[08:29:21.635]                       }
[08:29:21.635]                     }
[08:29:21.635]                     sendCondition <<- function(cond) NULL
[08:29:21.635]                   }
[08:29:21.635]                 })
[08:29:21.635]                 withCallingHandlers({
[08:29:21.635]                   2
[08:29:21.635]                 }, immediateCondition = function(cond) {
[08:29:21.635]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.635]                   sendCondition(cond)
[08:29:21.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.635]                   {
[08:29:21.635]                     inherits <- base::inherits
[08:29:21.635]                     invokeRestart <- base::invokeRestart
[08:29:21.635]                     is.null <- base::is.null
[08:29:21.635]                     muffled <- FALSE
[08:29:21.635]                     if (inherits(cond, "message")) {
[08:29:21.635]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.635]                       if (muffled) 
[08:29:21.635]                         invokeRestart("muffleMessage")
[08:29:21.635]                     }
[08:29:21.635]                     else if (inherits(cond, "warning")) {
[08:29:21.635]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.635]                       if (muffled) 
[08:29:21.635]                         invokeRestart("muffleWarning")
[08:29:21.635]                     }
[08:29:21.635]                     else if (inherits(cond, "condition")) {
[08:29:21.635]                       if (!is.null(pattern)) {
[08:29:21.635]                         computeRestarts <- base::computeRestarts
[08:29:21.635]                         grepl <- base::grepl
[08:29:21.635]                         restarts <- computeRestarts(cond)
[08:29:21.635]                         for (restart in restarts) {
[08:29:21.635]                           name <- restart$name
[08:29:21.635]                           if (is.null(name)) 
[08:29:21.635]                             next
[08:29:21.635]                           if (!grepl(pattern, name)) 
[08:29:21.635]                             next
[08:29:21.635]                           invokeRestart(restart)
[08:29:21.635]                           muffled <- TRUE
[08:29:21.635]                           break
[08:29:21.635]                         }
[08:29:21.635]                       }
[08:29:21.635]                     }
[08:29:21.635]                     invisible(muffled)
[08:29:21.635]                   }
[08:29:21.635]                   muffleCondition(cond)
[08:29:21.635]                 })
[08:29:21.635]             }))
[08:29:21.635]             future::FutureResult(value = ...future.value$value, 
[08:29:21.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.635]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.635]                     ...future.globalenv.names))
[08:29:21.635]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.635]         }, condition = base::local({
[08:29:21.635]             c <- base::c
[08:29:21.635]             inherits <- base::inherits
[08:29:21.635]             invokeRestart <- base::invokeRestart
[08:29:21.635]             length <- base::length
[08:29:21.635]             list <- base::list
[08:29:21.635]             seq.int <- base::seq.int
[08:29:21.635]             signalCondition <- base::signalCondition
[08:29:21.635]             sys.calls <- base::sys.calls
[08:29:21.635]             `[[` <- base::`[[`
[08:29:21.635]             `+` <- base::`+`
[08:29:21.635]             `<<-` <- base::`<<-`
[08:29:21.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.635]                   3L)]
[08:29:21.635]             }
[08:29:21.635]             function(cond) {
[08:29:21.635]                 is_error <- inherits(cond, "error")
[08:29:21.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.635]                   NULL)
[08:29:21.635]                 if (is_error) {
[08:29:21.635]                   sessionInformation <- function() {
[08:29:21.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.635]                       search = base::search(), system = base::Sys.info())
[08:29:21.635]                   }
[08:29:21.635]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.635]                     cond$call), session = sessionInformation(), 
[08:29:21.635]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.635]                   signalCondition(cond)
[08:29:21.635]                 }
[08:29:21.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.635]                 "immediateCondition"))) {
[08:29:21.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.635]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.635]                   if (TRUE && !signal) {
[08:29:21.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.635]                     {
[08:29:21.635]                       inherits <- base::inherits
[08:29:21.635]                       invokeRestart <- base::invokeRestart
[08:29:21.635]                       is.null <- base::is.null
[08:29:21.635]                       muffled <- FALSE
[08:29:21.635]                       if (inherits(cond, "message")) {
[08:29:21.635]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.635]                         if (muffled) 
[08:29:21.635]                           invokeRestart("muffleMessage")
[08:29:21.635]                       }
[08:29:21.635]                       else if (inherits(cond, "warning")) {
[08:29:21.635]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.635]                         if (muffled) 
[08:29:21.635]                           invokeRestart("muffleWarning")
[08:29:21.635]                       }
[08:29:21.635]                       else if (inherits(cond, "condition")) {
[08:29:21.635]                         if (!is.null(pattern)) {
[08:29:21.635]                           computeRestarts <- base::computeRestarts
[08:29:21.635]                           grepl <- base::grepl
[08:29:21.635]                           restarts <- computeRestarts(cond)
[08:29:21.635]                           for (restart in restarts) {
[08:29:21.635]                             name <- restart$name
[08:29:21.635]                             if (is.null(name)) 
[08:29:21.635]                               next
[08:29:21.635]                             if (!grepl(pattern, name)) 
[08:29:21.635]                               next
[08:29:21.635]                             invokeRestart(restart)
[08:29:21.635]                             muffled <- TRUE
[08:29:21.635]                             break
[08:29:21.635]                           }
[08:29:21.635]                         }
[08:29:21.635]                       }
[08:29:21.635]                       invisible(muffled)
[08:29:21.635]                     }
[08:29:21.635]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.635]                   }
[08:29:21.635]                 }
[08:29:21.635]                 else {
[08:29:21.635]                   if (TRUE) {
[08:29:21.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.635]                     {
[08:29:21.635]                       inherits <- base::inherits
[08:29:21.635]                       invokeRestart <- base::invokeRestart
[08:29:21.635]                       is.null <- base::is.null
[08:29:21.635]                       muffled <- FALSE
[08:29:21.635]                       if (inherits(cond, "message")) {
[08:29:21.635]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.635]                         if (muffled) 
[08:29:21.635]                           invokeRestart("muffleMessage")
[08:29:21.635]                       }
[08:29:21.635]                       else if (inherits(cond, "warning")) {
[08:29:21.635]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.635]                         if (muffled) 
[08:29:21.635]                           invokeRestart("muffleWarning")
[08:29:21.635]                       }
[08:29:21.635]                       else if (inherits(cond, "condition")) {
[08:29:21.635]                         if (!is.null(pattern)) {
[08:29:21.635]                           computeRestarts <- base::computeRestarts
[08:29:21.635]                           grepl <- base::grepl
[08:29:21.635]                           restarts <- computeRestarts(cond)
[08:29:21.635]                           for (restart in restarts) {
[08:29:21.635]                             name <- restart$name
[08:29:21.635]                             if (is.null(name)) 
[08:29:21.635]                               next
[08:29:21.635]                             if (!grepl(pattern, name)) 
[08:29:21.635]                               next
[08:29:21.635]                             invokeRestart(restart)
[08:29:21.635]                             muffled <- TRUE
[08:29:21.635]                             break
[08:29:21.635]                           }
[08:29:21.635]                         }
[08:29:21.635]                       }
[08:29:21.635]                       invisible(muffled)
[08:29:21.635]                     }
[08:29:21.635]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.635]                   }
[08:29:21.635]                 }
[08:29:21.635]             }
[08:29:21.635]         }))
[08:29:21.635]     }, error = function(ex) {
[08:29:21.635]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.635]                 ...future.rng), started = ...future.startTime, 
[08:29:21.635]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.635]             version = "1.8"), class = "FutureResult")
[08:29:21.635]     }, finally = {
[08:29:21.635]         if (!identical(...future.workdir, getwd())) 
[08:29:21.635]             setwd(...future.workdir)
[08:29:21.635]         {
[08:29:21.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.635]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.635]             }
[08:29:21.635]             base::options(...future.oldOptions)
[08:29:21.635]             if (.Platform$OS.type == "windows") {
[08:29:21.635]                 old_names <- names(...future.oldEnvVars)
[08:29:21.635]                 envs <- base::Sys.getenv()
[08:29:21.635]                 names <- names(envs)
[08:29:21.635]                 common <- intersect(names, old_names)
[08:29:21.635]                 added <- setdiff(names, old_names)
[08:29:21.635]                 removed <- setdiff(old_names, names)
[08:29:21.635]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.635]                   envs[common]]
[08:29:21.635]                 NAMES <- toupper(changed)
[08:29:21.635]                 args <- list()
[08:29:21.635]                 for (kk in seq_along(NAMES)) {
[08:29:21.635]                   name <- changed[[kk]]
[08:29:21.635]                   NAME <- NAMES[[kk]]
[08:29:21.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.635]                     next
[08:29:21.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.635]                 }
[08:29:21.635]                 NAMES <- toupper(added)
[08:29:21.635]                 for (kk in seq_along(NAMES)) {
[08:29:21.635]                   name <- added[[kk]]
[08:29:21.635]                   NAME <- NAMES[[kk]]
[08:29:21.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.635]                     next
[08:29:21.635]                   args[[name]] <- ""
[08:29:21.635]                 }
[08:29:21.635]                 NAMES <- toupper(removed)
[08:29:21.635]                 for (kk in seq_along(NAMES)) {
[08:29:21.635]                   name <- removed[[kk]]
[08:29:21.635]                   NAME <- NAMES[[kk]]
[08:29:21.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.635]                     next
[08:29:21.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.635]                 }
[08:29:21.635]                 if (length(args) > 0) 
[08:29:21.635]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.635]             }
[08:29:21.635]             else {
[08:29:21.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.635]             }
[08:29:21.635]             {
[08:29:21.635]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.635]                   0L) {
[08:29:21.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.635]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.635]                   base::options(opts)
[08:29:21.635]                 }
[08:29:21.635]                 {
[08:29:21.635]                   {
[08:29:21.635]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.635]                     NULL
[08:29:21.635]                   }
[08:29:21.635]                   options(future.plan = NULL)
[08:29:21.635]                   if (is.na(NA_character_)) 
[08:29:21.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.635]                     .init = FALSE)
[08:29:21.635]                 }
[08:29:21.635]             }
[08:29:21.635]         }
[08:29:21.635]     })
[08:29:21.635]     if (TRUE) {
[08:29:21.635]         base::sink(type = "output", split = FALSE)
[08:29:21.635]         if (TRUE) {
[08:29:21.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.635]         }
[08:29:21.635]         else {
[08:29:21.635]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.635]         }
[08:29:21.635]         base::close(...future.stdout)
[08:29:21.635]         ...future.stdout <- NULL
[08:29:21.635]     }
[08:29:21.635]     ...future.result$conditions <- ...future.conditions
[08:29:21.635]     ...future.result$finished <- base::Sys.time()
[08:29:21.635]     ...future.result
[08:29:21.635] }
[08:29:21.638] MultisessionFuture started
[08:29:21.638] - Launch lazy future ... done
[08:29:21.638] run() for ‘MultisessionFuture’ ... done
[08:29:21.639] resolve() on environment ...
[08:29:21.639]  recursive: 0
[08:29:21.639]  elements: [3] ‘a’, ‘b’, ‘c’
[08:29:21.660]  length: 2 (resolved future 3)
[08:29:21.671] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.671] - Validating connection of MultisessionFuture
[08:29:21.671] - received message: FutureResult
[08:29:21.671] - Received FutureResult
[08:29:21.671] - Erased future from FutureRegistry
[08:29:21.671] result() for ClusterFuture ...
[08:29:21.672] - result already collected: FutureResult
[08:29:21.672] result() for ClusterFuture ... done
[08:29:21.672] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.672] Future #1
[08:29:21.672]  length: 1 (resolved future 1)
[08:29:21.680] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.680] - Validating connection of MultisessionFuture
[08:29:21.680] - received message: FutureResult
[08:29:21.680] - Received FutureResult
[08:29:21.681] - Erased future from FutureRegistry
[08:29:21.681] result() for ClusterFuture ...
[08:29:21.681] - result already collected: FutureResult
[08:29:21.681] result() for ClusterFuture ... done
[08:29:21.681] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.681] Future #2
[08:29:21.681]  length: 0 (resolved future 2)
[08:29:21.681] resolve() on environment ... DONE
[08:29:21.682] getGlobalsAndPackages() ...
[08:29:21.682] Searching for globals...
[08:29:21.683] - globals found: [1] ‘{’
[08:29:21.683] Searching for globals ... DONE
[08:29:21.683] Resolving globals: FALSE
[08:29:21.683] 
[08:29:21.683] 
[08:29:21.683] getGlobalsAndPackages() ... DONE
[08:29:21.684] run() for ‘Future’ ...
[08:29:21.684] - state: ‘created’
[08:29:21.684] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.697] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.698]   - Field: ‘node’
[08:29:21.698]   - Field: ‘label’
[08:29:21.698]   - Field: ‘local’
[08:29:21.698]   - Field: ‘owner’
[08:29:21.698]   - Field: ‘envir’
[08:29:21.698]   - Field: ‘workers’
[08:29:21.698]   - Field: ‘packages’
[08:29:21.698]   - Field: ‘gc’
[08:29:21.698]   - Field: ‘conditions’
[08:29:21.699]   - Field: ‘persistent’
[08:29:21.699]   - Field: ‘expr’
[08:29:21.699]   - Field: ‘uuid’
[08:29:21.699]   - Field: ‘seed’
[08:29:21.699]   - Field: ‘version’
[08:29:21.699]   - Field: ‘result’
[08:29:21.699]   - Field: ‘asynchronous’
[08:29:21.699]   - Field: ‘calls’
[08:29:21.699]   - Field: ‘globals’
[08:29:21.699]   - Field: ‘stdout’
[08:29:21.699]   - Field: ‘earlySignal’
[08:29:21.700]   - Field: ‘lazy’
[08:29:21.700]   - Field: ‘state’
[08:29:21.700] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.700] - Launch lazy future ...
[08:29:21.700] Packages needed by the future expression (n = 0): <none>
[08:29:21.700] Packages needed by future strategies (n = 0): <none>
[08:29:21.701] {
[08:29:21.701]     {
[08:29:21.701]         {
[08:29:21.701]             ...future.startTime <- base::Sys.time()
[08:29:21.701]             {
[08:29:21.701]                 {
[08:29:21.701]                   {
[08:29:21.701]                     {
[08:29:21.701]                       base::local({
[08:29:21.701]                         has_future <- base::requireNamespace("future", 
[08:29:21.701]                           quietly = TRUE)
[08:29:21.701]                         if (has_future) {
[08:29:21.701]                           ns <- base::getNamespace("future")
[08:29:21.701]                           version <- ns[[".package"]][["version"]]
[08:29:21.701]                           if (is.null(version)) 
[08:29:21.701]                             version <- utils::packageVersion("future")
[08:29:21.701]                         }
[08:29:21.701]                         else {
[08:29:21.701]                           version <- NULL
[08:29:21.701]                         }
[08:29:21.701]                         if (!has_future || version < "1.8.0") {
[08:29:21.701]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.701]                             "", base::R.version$version.string), 
[08:29:21.701]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.701]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.701]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.701]                               "release", "version")], collapse = " "), 
[08:29:21.701]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.701]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.701]                             info)
[08:29:21.701]                           info <- base::paste(info, collapse = "; ")
[08:29:21.701]                           if (!has_future) {
[08:29:21.701]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.701]                               info)
[08:29:21.701]                           }
[08:29:21.701]                           else {
[08:29:21.701]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.701]                               info, version)
[08:29:21.701]                           }
[08:29:21.701]                           base::stop(msg)
[08:29:21.701]                         }
[08:29:21.701]                       })
[08:29:21.701]                     }
[08:29:21.701]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.701]                     base::options(mc.cores = 1L)
[08:29:21.701]                   }
[08:29:21.701]                   ...future.strategy.old <- future::plan("list")
[08:29:21.701]                   options(future.plan = NULL)
[08:29:21.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.701]                 }
[08:29:21.701]                 ...future.workdir <- getwd()
[08:29:21.701]             }
[08:29:21.701]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.701]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.701]         }
[08:29:21.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.701]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.701]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.701]             base::names(...future.oldOptions))
[08:29:21.701]     }
[08:29:21.701]     if (FALSE) {
[08:29:21.701]     }
[08:29:21.701]     else {
[08:29:21.701]         if (TRUE) {
[08:29:21.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.701]                 open = "w")
[08:29:21.701]         }
[08:29:21.701]         else {
[08:29:21.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.701]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.701]         }
[08:29:21.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.701]             base::sink(type = "output", split = FALSE)
[08:29:21.701]             base::close(...future.stdout)
[08:29:21.701]         }, add = TRUE)
[08:29:21.701]     }
[08:29:21.701]     ...future.frame <- base::sys.nframe()
[08:29:21.701]     ...future.conditions <- base::list()
[08:29:21.701]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.701]     if (FALSE) {
[08:29:21.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.701]     }
[08:29:21.701]     ...future.result <- base::tryCatch({
[08:29:21.701]         base::withCallingHandlers({
[08:29:21.701]             ...future.value <- base::withVisible(base::local({
[08:29:21.701]                 ...future.makeSendCondition <- base::local({
[08:29:21.701]                   sendCondition <- NULL
[08:29:21.701]                   function(frame = 1L) {
[08:29:21.701]                     if (is.function(sendCondition)) 
[08:29:21.701]                       return(sendCondition)
[08:29:21.701]                     ns <- getNamespace("parallel")
[08:29:21.701]                     if (exists("sendData", mode = "function", 
[08:29:21.701]                       envir = ns)) {
[08:29:21.701]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.701]                         envir = ns)
[08:29:21.701]                       envir <- sys.frame(frame)
[08:29:21.701]                       master <- NULL
[08:29:21.701]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.701]                         !identical(envir, emptyenv())) {
[08:29:21.701]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.701]                           inherits = FALSE)) {
[08:29:21.701]                           master <- get("master", mode = "list", 
[08:29:21.701]                             envir = envir, inherits = FALSE)
[08:29:21.701]                           if (inherits(master, c("SOCKnode", 
[08:29:21.701]                             "SOCK0node"))) {
[08:29:21.701]                             sendCondition <<- function(cond) {
[08:29:21.701]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.701]                                 success = TRUE)
[08:29:21.701]                               parallel_sendData(master, data)
[08:29:21.701]                             }
[08:29:21.701]                             return(sendCondition)
[08:29:21.701]                           }
[08:29:21.701]                         }
[08:29:21.701]                         frame <- frame + 1L
[08:29:21.701]                         envir <- sys.frame(frame)
[08:29:21.701]                       }
[08:29:21.701]                     }
[08:29:21.701]                     sendCondition <<- function(cond) NULL
[08:29:21.701]                   }
[08:29:21.701]                 })
[08:29:21.701]                 withCallingHandlers({
[08:29:21.701]                   {
[08:29:21.701]                     1
[08:29:21.701]                   }
[08:29:21.701]                 }, immediateCondition = function(cond) {
[08:29:21.701]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.701]                   sendCondition(cond)
[08:29:21.701]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.701]                   {
[08:29:21.701]                     inherits <- base::inherits
[08:29:21.701]                     invokeRestart <- base::invokeRestart
[08:29:21.701]                     is.null <- base::is.null
[08:29:21.701]                     muffled <- FALSE
[08:29:21.701]                     if (inherits(cond, "message")) {
[08:29:21.701]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.701]                       if (muffled) 
[08:29:21.701]                         invokeRestart("muffleMessage")
[08:29:21.701]                     }
[08:29:21.701]                     else if (inherits(cond, "warning")) {
[08:29:21.701]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.701]                       if (muffled) 
[08:29:21.701]                         invokeRestart("muffleWarning")
[08:29:21.701]                     }
[08:29:21.701]                     else if (inherits(cond, "condition")) {
[08:29:21.701]                       if (!is.null(pattern)) {
[08:29:21.701]                         computeRestarts <- base::computeRestarts
[08:29:21.701]                         grepl <- base::grepl
[08:29:21.701]                         restarts <- computeRestarts(cond)
[08:29:21.701]                         for (restart in restarts) {
[08:29:21.701]                           name <- restart$name
[08:29:21.701]                           if (is.null(name)) 
[08:29:21.701]                             next
[08:29:21.701]                           if (!grepl(pattern, name)) 
[08:29:21.701]                             next
[08:29:21.701]                           invokeRestart(restart)
[08:29:21.701]                           muffled <- TRUE
[08:29:21.701]                           break
[08:29:21.701]                         }
[08:29:21.701]                       }
[08:29:21.701]                     }
[08:29:21.701]                     invisible(muffled)
[08:29:21.701]                   }
[08:29:21.701]                   muffleCondition(cond)
[08:29:21.701]                 })
[08:29:21.701]             }))
[08:29:21.701]             future::FutureResult(value = ...future.value$value, 
[08:29:21.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.701]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.701]                     ...future.globalenv.names))
[08:29:21.701]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.701]         }, condition = base::local({
[08:29:21.701]             c <- base::c
[08:29:21.701]             inherits <- base::inherits
[08:29:21.701]             invokeRestart <- base::invokeRestart
[08:29:21.701]             length <- base::length
[08:29:21.701]             list <- base::list
[08:29:21.701]             seq.int <- base::seq.int
[08:29:21.701]             signalCondition <- base::signalCondition
[08:29:21.701]             sys.calls <- base::sys.calls
[08:29:21.701]             `[[` <- base::`[[`
[08:29:21.701]             `+` <- base::`+`
[08:29:21.701]             `<<-` <- base::`<<-`
[08:29:21.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.701]                   3L)]
[08:29:21.701]             }
[08:29:21.701]             function(cond) {
[08:29:21.701]                 is_error <- inherits(cond, "error")
[08:29:21.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.701]                   NULL)
[08:29:21.701]                 if (is_error) {
[08:29:21.701]                   sessionInformation <- function() {
[08:29:21.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.701]                       search = base::search(), system = base::Sys.info())
[08:29:21.701]                   }
[08:29:21.701]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.701]                     cond$call), session = sessionInformation(), 
[08:29:21.701]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.701]                   signalCondition(cond)
[08:29:21.701]                 }
[08:29:21.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.701]                 "immediateCondition"))) {
[08:29:21.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.701]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.701]                   if (TRUE && !signal) {
[08:29:21.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.701]                     {
[08:29:21.701]                       inherits <- base::inherits
[08:29:21.701]                       invokeRestart <- base::invokeRestart
[08:29:21.701]                       is.null <- base::is.null
[08:29:21.701]                       muffled <- FALSE
[08:29:21.701]                       if (inherits(cond, "message")) {
[08:29:21.701]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.701]                         if (muffled) 
[08:29:21.701]                           invokeRestart("muffleMessage")
[08:29:21.701]                       }
[08:29:21.701]                       else if (inherits(cond, "warning")) {
[08:29:21.701]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.701]                         if (muffled) 
[08:29:21.701]                           invokeRestart("muffleWarning")
[08:29:21.701]                       }
[08:29:21.701]                       else if (inherits(cond, "condition")) {
[08:29:21.701]                         if (!is.null(pattern)) {
[08:29:21.701]                           computeRestarts <- base::computeRestarts
[08:29:21.701]                           grepl <- base::grepl
[08:29:21.701]                           restarts <- computeRestarts(cond)
[08:29:21.701]                           for (restart in restarts) {
[08:29:21.701]                             name <- restart$name
[08:29:21.701]                             if (is.null(name)) 
[08:29:21.701]                               next
[08:29:21.701]                             if (!grepl(pattern, name)) 
[08:29:21.701]                               next
[08:29:21.701]                             invokeRestart(restart)
[08:29:21.701]                             muffled <- TRUE
[08:29:21.701]                             break
[08:29:21.701]                           }
[08:29:21.701]                         }
[08:29:21.701]                       }
[08:29:21.701]                       invisible(muffled)
[08:29:21.701]                     }
[08:29:21.701]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.701]                   }
[08:29:21.701]                 }
[08:29:21.701]                 else {
[08:29:21.701]                   if (TRUE) {
[08:29:21.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.701]                     {
[08:29:21.701]                       inherits <- base::inherits
[08:29:21.701]                       invokeRestart <- base::invokeRestart
[08:29:21.701]                       is.null <- base::is.null
[08:29:21.701]                       muffled <- FALSE
[08:29:21.701]                       if (inherits(cond, "message")) {
[08:29:21.701]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.701]                         if (muffled) 
[08:29:21.701]                           invokeRestart("muffleMessage")
[08:29:21.701]                       }
[08:29:21.701]                       else if (inherits(cond, "warning")) {
[08:29:21.701]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.701]                         if (muffled) 
[08:29:21.701]                           invokeRestart("muffleWarning")
[08:29:21.701]                       }
[08:29:21.701]                       else if (inherits(cond, "condition")) {
[08:29:21.701]                         if (!is.null(pattern)) {
[08:29:21.701]                           computeRestarts <- base::computeRestarts
[08:29:21.701]                           grepl <- base::grepl
[08:29:21.701]                           restarts <- computeRestarts(cond)
[08:29:21.701]                           for (restart in restarts) {
[08:29:21.701]                             name <- restart$name
[08:29:21.701]                             if (is.null(name)) 
[08:29:21.701]                               next
[08:29:21.701]                             if (!grepl(pattern, name)) 
[08:29:21.701]                               next
[08:29:21.701]                             invokeRestart(restart)
[08:29:21.701]                             muffled <- TRUE
[08:29:21.701]                             break
[08:29:21.701]                           }
[08:29:21.701]                         }
[08:29:21.701]                       }
[08:29:21.701]                       invisible(muffled)
[08:29:21.701]                     }
[08:29:21.701]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.701]                   }
[08:29:21.701]                 }
[08:29:21.701]             }
[08:29:21.701]         }))
[08:29:21.701]     }, error = function(ex) {
[08:29:21.701]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.701]                 ...future.rng), started = ...future.startTime, 
[08:29:21.701]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.701]             version = "1.8"), class = "FutureResult")
[08:29:21.701]     }, finally = {
[08:29:21.701]         if (!identical(...future.workdir, getwd())) 
[08:29:21.701]             setwd(...future.workdir)
[08:29:21.701]         {
[08:29:21.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.701]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.701]             }
[08:29:21.701]             base::options(...future.oldOptions)
[08:29:21.701]             if (.Platform$OS.type == "windows") {
[08:29:21.701]                 old_names <- names(...future.oldEnvVars)
[08:29:21.701]                 envs <- base::Sys.getenv()
[08:29:21.701]                 names <- names(envs)
[08:29:21.701]                 common <- intersect(names, old_names)
[08:29:21.701]                 added <- setdiff(names, old_names)
[08:29:21.701]                 removed <- setdiff(old_names, names)
[08:29:21.701]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.701]                   envs[common]]
[08:29:21.701]                 NAMES <- toupper(changed)
[08:29:21.701]                 args <- list()
[08:29:21.701]                 for (kk in seq_along(NAMES)) {
[08:29:21.701]                   name <- changed[[kk]]
[08:29:21.701]                   NAME <- NAMES[[kk]]
[08:29:21.701]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.701]                     next
[08:29:21.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.701]                 }
[08:29:21.701]                 NAMES <- toupper(added)
[08:29:21.701]                 for (kk in seq_along(NAMES)) {
[08:29:21.701]                   name <- added[[kk]]
[08:29:21.701]                   NAME <- NAMES[[kk]]
[08:29:21.701]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.701]                     next
[08:29:21.701]                   args[[name]] <- ""
[08:29:21.701]                 }
[08:29:21.701]                 NAMES <- toupper(removed)
[08:29:21.701]                 for (kk in seq_along(NAMES)) {
[08:29:21.701]                   name <- removed[[kk]]
[08:29:21.701]                   NAME <- NAMES[[kk]]
[08:29:21.701]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.701]                     next
[08:29:21.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.701]                 }
[08:29:21.701]                 if (length(args) > 0) 
[08:29:21.701]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.701]             }
[08:29:21.701]             else {
[08:29:21.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.701]             }
[08:29:21.701]             {
[08:29:21.701]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.701]                   0L) {
[08:29:21.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.701]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.701]                   base::options(opts)
[08:29:21.701]                 }
[08:29:21.701]                 {
[08:29:21.701]                   {
[08:29:21.701]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.701]                     NULL
[08:29:21.701]                   }
[08:29:21.701]                   options(future.plan = NULL)
[08:29:21.701]                   if (is.na(NA_character_)) 
[08:29:21.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.701]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.701]                     .init = FALSE)
[08:29:21.701]                 }
[08:29:21.701]             }
[08:29:21.701]         }
[08:29:21.701]     })
[08:29:21.701]     if (TRUE) {
[08:29:21.701]         base::sink(type = "output", split = FALSE)
[08:29:21.701]         if (TRUE) {
[08:29:21.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.701]         }
[08:29:21.701]         else {
[08:29:21.701]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.701]         }
[08:29:21.701]         base::close(...future.stdout)
[08:29:21.701]         ...future.stdout <- NULL
[08:29:21.701]     }
[08:29:21.701]     ...future.result$conditions <- ...future.conditions
[08:29:21.701]     ...future.result$finished <- base::Sys.time()
[08:29:21.701]     ...future.result
[08:29:21.701] }
[08:29:21.704] MultisessionFuture started
[08:29:21.704] - Launch lazy future ... done
[08:29:21.704] run() for ‘MultisessionFuture’ ... done
[08:29:21.704] getGlobalsAndPackages() ...
[08:29:21.704] Searching for globals...
[08:29:21.705] - globals found: [1] ‘{’
[08:29:21.705] Searching for globals ... DONE
[08:29:21.705] Resolving globals: FALSE
[08:29:21.706] 
[08:29:21.706] 
[08:29:21.706] getGlobalsAndPackages() ... DONE
[08:29:21.706] run() for ‘Future’ ...
[08:29:21.706] - state: ‘created’
[08:29:21.706] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.720] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.720] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.720]   - Field: ‘node’
[08:29:21.720]   - Field: ‘label’
[08:29:21.720]   - Field: ‘local’
[08:29:21.720]   - Field: ‘owner’
[08:29:21.720]   - Field: ‘envir’
[08:29:21.720]   - Field: ‘workers’
[08:29:21.721]   - Field: ‘packages’
[08:29:21.721]   - Field: ‘gc’
[08:29:21.721]   - Field: ‘conditions’
[08:29:21.721]   - Field: ‘persistent’
[08:29:21.721]   - Field: ‘expr’
[08:29:21.721]   - Field: ‘uuid’
[08:29:21.721]   - Field: ‘seed’
[08:29:21.721]   - Field: ‘version’
[08:29:21.721]   - Field: ‘result’
[08:29:21.721]   - Field: ‘asynchronous’
[08:29:21.721]   - Field: ‘calls’
[08:29:21.721]   - Field: ‘globals’
[08:29:21.722]   - Field: ‘stdout’
[08:29:21.722]   - Field: ‘earlySignal’
[08:29:21.722]   - Field: ‘lazy’
[08:29:21.722]   - Field: ‘state’
[08:29:21.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.722] - Launch lazy future ...
[08:29:21.722] Packages needed by the future expression (n = 0): <none>
[08:29:21.722] Packages needed by future strategies (n = 0): <none>
[08:29:21.723] {
[08:29:21.723]     {
[08:29:21.723]         {
[08:29:21.723]             ...future.startTime <- base::Sys.time()
[08:29:21.723]             {
[08:29:21.723]                 {
[08:29:21.723]                   {
[08:29:21.723]                     {
[08:29:21.723]                       base::local({
[08:29:21.723]                         has_future <- base::requireNamespace("future", 
[08:29:21.723]                           quietly = TRUE)
[08:29:21.723]                         if (has_future) {
[08:29:21.723]                           ns <- base::getNamespace("future")
[08:29:21.723]                           version <- ns[[".package"]][["version"]]
[08:29:21.723]                           if (is.null(version)) 
[08:29:21.723]                             version <- utils::packageVersion("future")
[08:29:21.723]                         }
[08:29:21.723]                         else {
[08:29:21.723]                           version <- NULL
[08:29:21.723]                         }
[08:29:21.723]                         if (!has_future || version < "1.8.0") {
[08:29:21.723]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.723]                             "", base::R.version$version.string), 
[08:29:21.723]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.723]                               "release", "version")], collapse = " "), 
[08:29:21.723]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.723]                             info)
[08:29:21.723]                           info <- base::paste(info, collapse = "; ")
[08:29:21.723]                           if (!has_future) {
[08:29:21.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.723]                               info)
[08:29:21.723]                           }
[08:29:21.723]                           else {
[08:29:21.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.723]                               info, version)
[08:29:21.723]                           }
[08:29:21.723]                           base::stop(msg)
[08:29:21.723]                         }
[08:29:21.723]                       })
[08:29:21.723]                     }
[08:29:21.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.723]                     base::options(mc.cores = 1L)
[08:29:21.723]                   }
[08:29:21.723]                   ...future.strategy.old <- future::plan("list")
[08:29:21.723]                   options(future.plan = NULL)
[08:29:21.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.723]                 }
[08:29:21.723]                 ...future.workdir <- getwd()
[08:29:21.723]             }
[08:29:21.723]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.723]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.723]         }
[08:29:21.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.723]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.723]             base::names(...future.oldOptions))
[08:29:21.723]     }
[08:29:21.723]     if (FALSE) {
[08:29:21.723]     }
[08:29:21.723]     else {
[08:29:21.723]         if (TRUE) {
[08:29:21.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.723]                 open = "w")
[08:29:21.723]         }
[08:29:21.723]         else {
[08:29:21.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.723]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.723]         }
[08:29:21.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.723]             base::sink(type = "output", split = FALSE)
[08:29:21.723]             base::close(...future.stdout)
[08:29:21.723]         }, add = TRUE)
[08:29:21.723]     }
[08:29:21.723]     ...future.frame <- base::sys.nframe()
[08:29:21.723]     ...future.conditions <- base::list()
[08:29:21.723]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.723]     if (FALSE) {
[08:29:21.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.723]     }
[08:29:21.723]     ...future.result <- base::tryCatch({
[08:29:21.723]         base::withCallingHandlers({
[08:29:21.723]             ...future.value <- base::withVisible(base::local({
[08:29:21.723]                 ...future.makeSendCondition <- base::local({
[08:29:21.723]                   sendCondition <- NULL
[08:29:21.723]                   function(frame = 1L) {
[08:29:21.723]                     if (is.function(sendCondition)) 
[08:29:21.723]                       return(sendCondition)
[08:29:21.723]                     ns <- getNamespace("parallel")
[08:29:21.723]                     if (exists("sendData", mode = "function", 
[08:29:21.723]                       envir = ns)) {
[08:29:21.723]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.723]                         envir = ns)
[08:29:21.723]                       envir <- sys.frame(frame)
[08:29:21.723]                       master <- NULL
[08:29:21.723]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.723]                         !identical(envir, emptyenv())) {
[08:29:21.723]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.723]                           inherits = FALSE)) {
[08:29:21.723]                           master <- get("master", mode = "list", 
[08:29:21.723]                             envir = envir, inherits = FALSE)
[08:29:21.723]                           if (inherits(master, c("SOCKnode", 
[08:29:21.723]                             "SOCK0node"))) {
[08:29:21.723]                             sendCondition <<- function(cond) {
[08:29:21.723]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.723]                                 success = TRUE)
[08:29:21.723]                               parallel_sendData(master, data)
[08:29:21.723]                             }
[08:29:21.723]                             return(sendCondition)
[08:29:21.723]                           }
[08:29:21.723]                         }
[08:29:21.723]                         frame <- frame + 1L
[08:29:21.723]                         envir <- sys.frame(frame)
[08:29:21.723]                       }
[08:29:21.723]                     }
[08:29:21.723]                     sendCondition <<- function(cond) NULL
[08:29:21.723]                   }
[08:29:21.723]                 })
[08:29:21.723]                 withCallingHandlers({
[08:29:21.723]                   {
[08:29:21.723]                     2
[08:29:21.723]                   }
[08:29:21.723]                 }, immediateCondition = function(cond) {
[08:29:21.723]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.723]                   sendCondition(cond)
[08:29:21.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.723]                   {
[08:29:21.723]                     inherits <- base::inherits
[08:29:21.723]                     invokeRestart <- base::invokeRestart
[08:29:21.723]                     is.null <- base::is.null
[08:29:21.723]                     muffled <- FALSE
[08:29:21.723]                     if (inherits(cond, "message")) {
[08:29:21.723]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.723]                       if (muffled) 
[08:29:21.723]                         invokeRestart("muffleMessage")
[08:29:21.723]                     }
[08:29:21.723]                     else if (inherits(cond, "warning")) {
[08:29:21.723]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.723]                       if (muffled) 
[08:29:21.723]                         invokeRestart("muffleWarning")
[08:29:21.723]                     }
[08:29:21.723]                     else if (inherits(cond, "condition")) {
[08:29:21.723]                       if (!is.null(pattern)) {
[08:29:21.723]                         computeRestarts <- base::computeRestarts
[08:29:21.723]                         grepl <- base::grepl
[08:29:21.723]                         restarts <- computeRestarts(cond)
[08:29:21.723]                         for (restart in restarts) {
[08:29:21.723]                           name <- restart$name
[08:29:21.723]                           if (is.null(name)) 
[08:29:21.723]                             next
[08:29:21.723]                           if (!grepl(pattern, name)) 
[08:29:21.723]                             next
[08:29:21.723]                           invokeRestart(restart)
[08:29:21.723]                           muffled <- TRUE
[08:29:21.723]                           break
[08:29:21.723]                         }
[08:29:21.723]                       }
[08:29:21.723]                     }
[08:29:21.723]                     invisible(muffled)
[08:29:21.723]                   }
[08:29:21.723]                   muffleCondition(cond)
[08:29:21.723]                 })
[08:29:21.723]             }))
[08:29:21.723]             future::FutureResult(value = ...future.value$value, 
[08:29:21.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.723]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.723]                     ...future.globalenv.names))
[08:29:21.723]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.723]         }, condition = base::local({
[08:29:21.723]             c <- base::c
[08:29:21.723]             inherits <- base::inherits
[08:29:21.723]             invokeRestart <- base::invokeRestart
[08:29:21.723]             length <- base::length
[08:29:21.723]             list <- base::list
[08:29:21.723]             seq.int <- base::seq.int
[08:29:21.723]             signalCondition <- base::signalCondition
[08:29:21.723]             sys.calls <- base::sys.calls
[08:29:21.723]             `[[` <- base::`[[`
[08:29:21.723]             `+` <- base::`+`
[08:29:21.723]             `<<-` <- base::`<<-`
[08:29:21.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.723]                   3L)]
[08:29:21.723]             }
[08:29:21.723]             function(cond) {
[08:29:21.723]                 is_error <- inherits(cond, "error")
[08:29:21.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.723]                   NULL)
[08:29:21.723]                 if (is_error) {
[08:29:21.723]                   sessionInformation <- function() {
[08:29:21.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.723]                       search = base::search(), system = base::Sys.info())
[08:29:21.723]                   }
[08:29:21.723]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.723]                     cond$call), session = sessionInformation(), 
[08:29:21.723]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.723]                   signalCondition(cond)
[08:29:21.723]                 }
[08:29:21.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.723]                 "immediateCondition"))) {
[08:29:21.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.723]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.723]                   if (TRUE && !signal) {
[08:29:21.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.723]                     {
[08:29:21.723]                       inherits <- base::inherits
[08:29:21.723]                       invokeRestart <- base::invokeRestart
[08:29:21.723]                       is.null <- base::is.null
[08:29:21.723]                       muffled <- FALSE
[08:29:21.723]                       if (inherits(cond, "message")) {
[08:29:21.723]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.723]                         if (muffled) 
[08:29:21.723]                           invokeRestart("muffleMessage")
[08:29:21.723]                       }
[08:29:21.723]                       else if (inherits(cond, "warning")) {
[08:29:21.723]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.723]                         if (muffled) 
[08:29:21.723]                           invokeRestart("muffleWarning")
[08:29:21.723]                       }
[08:29:21.723]                       else if (inherits(cond, "condition")) {
[08:29:21.723]                         if (!is.null(pattern)) {
[08:29:21.723]                           computeRestarts <- base::computeRestarts
[08:29:21.723]                           grepl <- base::grepl
[08:29:21.723]                           restarts <- computeRestarts(cond)
[08:29:21.723]                           for (restart in restarts) {
[08:29:21.723]                             name <- restart$name
[08:29:21.723]                             if (is.null(name)) 
[08:29:21.723]                               next
[08:29:21.723]                             if (!grepl(pattern, name)) 
[08:29:21.723]                               next
[08:29:21.723]                             invokeRestart(restart)
[08:29:21.723]                             muffled <- TRUE
[08:29:21.723]                             break
[08:29:21.723]                           }
[08:29:21.723]                         }
[08:29:21.723]                       }
[08:29:21.723]                       invisible(muffled)
[08:29:21.723]                     }
[08:29:21.723]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.723]                   }
[08:29:21.723]                 }
[08:29:21.723]                 else {
[08:29:21.723]                   if (TRUE) {
[08:29:21.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.723]                     {
[08:29:21.723]                       inherits <- base::inherits
[08:29:21.723]                       invokeRestart <- base::invokeRestart
[08:29:21.723]                       is.null <- base::is.null
[08:29:21.723]                       muffled <- FALSE
[08:29:21.723]                       if (inherits(cond, "message")) {
[08:29:21.723]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.723]                         if (muffled) 
[08:29:21.723]                           invokeRestart("muffleMessage")
[08:29:21.723]                       }
[08:29:21.723]                       else if (inherits(cond, "warning")) {
[08:29:21.723]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.723]                         if (muffled) 
[08:29:21.723]                           invokeRestart("muffleWarning")
[08:29:21.723]                       }
[08:29:21.723]                       else if (inherits(cond, "condition")) {
[08:29:21.723]                         if (!is.null(pattern)) {
[08:29:21.723]                           computeRestarts <- base::computeRestarts
[08:29:21.723]                           grepl <- base::grepl
[08:29:21.723]                           restarts <- computeRestarts(cond)
[08:29:21.723]                           for (restart in restarts) {
[08:29:21.723]                             name <- restart$name
[08:29:21.723]                             if (is.null(name)) 
[08:29:21.723]                               next
[08:29:21.723]                             if (!grepl(pattern, name)) 
[08:29:21.723]                               next
[08:29:21.723]                             invokeRestart(restart)
[08:29:21.723]                             muffled <- TRUE
[08:29:21.723]                             break
[08:29:21.723]                           }
[08:29:21.723]                         }
[08:29:21.723]                       }
[08:29:21.723]                       invisible(muffled)
[08:29:21.723]                     }
[08:29:21.723]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.723]                   }
[08:29:21.723]                 }
[08:29:21.723]             }
[08:29:21.723]         }))
[08:29:21.723]     }, error = function(ex) {
[08:29:21.723]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.723]                 ...future.rng), started = ...future.startTime, 
[08:29:21.723]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.723]             version = "1.8"), class = "FutureResult")
[08:29:21.723]     }, finally = {
[08:29:21.723]         if (!identical(...future.workdir, getwd())) 
[08:29:21.723]             setwd(...future.workdir)
[08:29:21.723]         {
[08:29:21.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.723]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.723]             }
[08:29:21.723]             base::options(...future.oldOptions)
[08:29:21.723]             if (.Platform$OS.type == "windows") {
[08:29:21.723]                 old_names <- names(...future.oldEnvVars)
[08:29:21.723]                 envs <- base::Sys.getenv()
[08:29:21.723]                 names <- names(envs)
[08:29:21.723]                 common <- intersect(names, old_names)
[08:29:21.723]                 added <- setdiff(names, old_names)
[08:29:21.723]                 removed <- setdiff(old_names, names)
[08:29:21.723]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.723]                   envs[common]]
[08:29:21.723]                 NAMES <- toupper(changed)
[08:29:21.723]                 args <- list()
[08:29:21.723]                 for (kk in seq_along(NAMES)) {
[08:29:21.723]                   name <- changed[[kk]]
[08:29:21.723]                   NAME <- NAMES[[kk]]
[08:29:21.723]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.723]                     next
[08:29:21.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.723]                 }
[08:29:21.723]                 NAMES <- toupper(added)
[08:29:21.723]                 for (kk in seq_along(NAMES)) {
[08:29:21.723]                   name <- added[[kk]]
[08:29:21.723]                   NAME <- NAMES[[kk]]
[08:29:21.723]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.723]                     next
[08:29:21.723]                   args[[name]] <- ""
[08:29:21.723]                 }
[08:29:21.723]                 NAMES <- toupper(removed)
[08:29:21.723]                 for (kk in seq_along(NAMES)) {
[08:29:21.723]                   name <- removed[[kk]]
[08:29:21.723]                   NAME <- NAMES[[kk]]
[08:29:21.723]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.723]                     next
[08:29:21.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.723]                 }
[08:29:21.723]                 if (length(args) > 0) 
[08:29:21.723]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.723]             }
[08:29:21.723]             else {
[08:29:21.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.723]             }
[08:29:21.723]             {
[08:29:21.723]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.723]                   0L) {
[08:29:21.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.723]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.723]                   base::options(opts)
[08:29:21.723]                 }
[08:29:21.723]                 {
[08:29:21.723]                   {
[08:29:21.723]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.723]                     NULL
[08:29:21.723]                   }
[08:29:21.723]                   options(future.plan = NULL)
[08:29:21.723]                   if (is.na(NA_character_)) 
[08:29:21.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.723]                     .init = FALSE)
[08:29:21.723]                 }
[08:29:21.723]             }
[08:29:21.723]         }
[08:29:21.723]     })
[08:29:21.723]     if (TRUE) {
[08:29:21.723]         base::sink(type = "output", split = FALSE)
[08:29:21.723]         if (TRUE) {
[08:29:21.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.723]         }
[08:29:21.723]         else {
[08:29:21.723]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.723]         }
[08:29:21.723]         base::close(...future.stdout)
[08:29:21.723]         ...future.stdout <- NULL
[08:29:21.723]     }
[08:29:21.723]     ...future.result$conditions <- ...future.conditions
[08:29:21.723]     ...future.result$finished <- base::Sys.time()
[08:29:21.723]     ...future.result
[08:29:21.723] }
[08:29:21.726] MultisessionFuture started
[08:29:21.726] - Launch lazy future ... done
[08:29:21.726] run() for ‘MultisessionFuture’ ... done
[08:29:21.727] resolve() on environment ...
[08:29:21.727]  recursive: 0
[08:29:21.727]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[08:29:21.748]  length: 2 (resolved future 3)
[08:29:21.759] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.759] - Validating connection of MultisessionFuture
[08:29:21.759] - received message: FutureResult
[08:29:21.759] - Received FutureResult
[08:29:21.759] - Erased future from FutureRegistry
[08:29:21.759] result() for ClusterFuture ...
[08:29:21.759] - result already collected: FutureResult
[08:29:21.759] result() for ClusterFuture ... done
[08:29:21.760] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.760] Future #1
[08:29:21.760]  length: 1 (resolved future 1)
[08:29:21.768] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.768] - Validating connection of MultisessionFuture
[08:29:21.768] - received message: FutureResult
[08:29:21.768] - Received FutureResult
[08:29:21.769] - Erased future from FutureRegistry
[08:29:21.769] result() for ClusterFuture ...
[08:29:21.769] - result already collected: FutureResult
[08:29:21.769] result() for ClusterFuture ... done
[08:29:21.769] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.769] Future #2
[08:29:21.769]  length: 0 (resolved future 2)
[08:29:21.769] resolve() on environment ... DONE
[08:29:21.770] getGlobalsAndPackages() ...
[08:29:21.770] Searching for globals...
[08:29:21.770] - globals found: [1] ‘{’
[08:29:21.770] Searching for globals ... DONE
[08:29:21.771] Resolving globals: FALSE
[08:29:21.771] 
[08:29:21.771] 
[08:29:21.771] getGlobalsAndPackages() ... DONE
[08:29:21.771] run() for ‘Future’ ...
[08:29:21.771] - state: ‘created’
[08:29:21.771] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.785] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.785]   - Field: ‘node’
[08:29:21.786]   - Field: ‘label’
[08:29:21.786]   - Field: ‘local’
[08:29:21.786]   - Field: ‘owner’
[08:29:21.786]   - Field: ‘envir’
[08:29:21.786]   - Field: ‘workers’
[08:29:21.786]   - Field: ‘packages’
[08:29:21.786]   - Field: ‘gc’
[08:29:21.786]   - Field: ‘conditions’
[08:29:21.786]   - Field: ‘persistent’
[08:29:21.786]   - Field: ‘expr’
[08:29:21.786]   - Field: ‘uuid’
[08:29:21.787]   - Field: ‘seed’
[08:29:21.787]   - Field: ‘version’
[08:29:21.787]   - Field: ‘result’
[08:29:21.787]   - Field: ‘asynchronous’
[08:29:21.787]   - Field: ‘calls’
[08:29:21.787]   - Field: ‘globals’
[08:29:21.787]   - Field: ‘stdout’
[08:29:21.787]   - Field: ‘earlySignal’
[08:29:21.787]   - Field: ‘lazy’
[08:29:21.787]   - Field: ‘state’
[08:29:21.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.788] - Launch lazy future ...
[08:29:21.788] Packages needed by the future expression (n = 0): <none>
[08:29:21.788] Packages needed by future strategies (n = 0): <none>
[08:29:21.788] {
[08:29:21.788]     {
[08:29:21.788]         {
[08:29:21.788]             ...future.startTime <- base::Sys.time()
[08:29:21.788]             {
[08:29:21.788]                 {
[08:29:21.788]                   {
[08:29:21.788]                     {
[08:29:21.788]                       base::local({
[08:29:21.788]                         has_future <- base::requireNamespace("future", 
[08:29:21.788]                           quietly = TRUE)
[08:29:21.788]                         if (has_future) {
[08:29:21.788]                           ns <- base::getNamespace("future")
[08:29:21.788]                           version <- ns[[".package"]][["version"]]
[08:29:21.788]                           if (is.null(version)) 
[08:29:21.788]                             version <- utils::packageVersion("future")
[08:29:21.788]                         }
[08:29:21.788]                         else {
[08:29:21.788]                           version <- NULL
[08:29:21.788]                         }
[08:29:21.788]                         if (!has_future || version < "1.8.0") {
[08:29:21.788]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.788]                             "", base::R.version$version.string), 
[08:29:21.788]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.788]                               "release", "version")], collapse = " "), 
[08:29:21.788]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.788]                             info)
[08:29:21.788]                           info <- base::paste(info, collapse = "; ")
[08:29:21.788]                           if (!has_future) {
[08:29:21.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.788]                               info)
[08:29:21.788]                           }
[08:29:21.788]                           else {
[08:29:21.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.788]                               info, version)
[08:29:21.788]                           }
[08:29:21.788]                           base::stop(msg)
[08:29:21.788]                         }
[08:29:21.788]                       })
[08:29:21.788]                     }
[08:29:21.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.788]                     base::options(mc.cores = 1L)
[08:29:21.788]                   }
[08:29:21.788]                   ...future.strategy.old <- future::plan("list")
[08:29:21.788]                   options(future.plan = NULL)
[08:29:21.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.788]                 }
[08:29:21.788]                 ...future.workdir <- getwd()
[08:29:21.788]             }
[08:29:21.788]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.788]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.788]         }
[08:29:21.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.788]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.788]             base::names(...future.oldOptions))
[08:29:21.788]     }
[08:29:21.788]     if (FALSE) {
[08:29:21.788]     }
[08:29:21.788]     else {
[08:29:21.788]         if (TRUE) {
[08:29:21.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.788]                 open = "w")
[08:29:21.788]         }
[08:29:21.788]         else {
[08:29:21.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.788]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.788]         }
[08:29:21.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.788]             base::sink(type = "output", split = FALSE)
[08:29:21.788]             base::close(...future.stdout)
[08:29:21.788]         }, add = TRUE)
[08:29:21.788]     }
[08:29:21.788]     ...future.frame <- base::sys.nframe()
[08:29:21.788]     ...future.conditions <- base::list()
[08:29:21.788]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.788]     if (FALSE) {
[08:29:21.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.788]     }
[08:29:21.788]     ...future.result <- base::tryCatch({
[08:29:21.788]         base::withCallingHandlers({
[08:29:21.788]             ...future.value <- base::withVisible(base::local({
[08:29:21.788]                 ...future.makeSendCondition <- base::local({
[08:29:21.788]                   sendCondition <- NULL
[08:29:21.788]                   function(frame = 1L) {
[08:29:21.788]                     if (is.function(sendCondition)) 
[08:29:21.788]                       return(sendCondition)
[08:29:21.788]                     ns <- getNamespace("parallel")
[08:29:21.788]                     if (exists("sendData", mode = "function", 
[08:29:21.788]                       envir = ns)) {
[08:29:21.788]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.788]                         envir = ns)
[08:29:21.788]                       envir <- sys.frame(frame)
[08:29:21.788]                       master <- NULL
[08:29:21.788]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.788]                         !identical(envir, emptyenv())) {
[08:29:21.788]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.788]                           inherits = FALSE)) {
[08:29:21.788]                           master <- get("master", mode = "list", 
[08:29:21.788]                             envir = envir, inherits = FALSE)
[08:29:21.788]                           if (inherits(master, c("SOCKnode", 
[08:29:21.788]                             "SOCK0node"))) {
[08:29:21.788]                             sendCondition <<- function(cond) {
[08:29:21.788]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.788]                                 success = TRUE)
[08:29:21.788]                               parallel_sendData(master, data)
[08:29:21.788]                             }
[08:29:21.788]                             return(sendCondition)
[08:29:21.788]                           }
[08:29:21.788]                         }
[08:29:21.788]                         frame <- frame + 1L
[08:29:21.788]                         envir <- sys.frame(frame)
[08:29:21.788]                       }
[08:29:21.788]                     }
[08:29:21.788]                     sendCondition <<- function(cond) NULL
[08:29:21.788]                   }
[08:29:21.788]                 })
[08:29:21.788]                 withCallingHandlers({
[08:29:21.788]                   {
[08:29:21.788]                     1
[08:29:21.788]                   }
[08:29:21.788]                 }, immediateCondition = function(cond) {
[08:29:21.788]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.788]                   sendCondition(cond)
[08:29:21.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.788]                   {
[08:29:21.788]                     inherits <- base::inherits
[08:29:21.788]                     invokeRestart <- base::invokeRestart
[08:29:21.788]                     is.null <- base::is.null
[08:29:21.788]                     muffled <- FALSE
[08:29:21.788]                     if (inherits(cond, "message")) {
[08:29:21.788]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.788]                       if (muffled) 
[08:29:21.788]                         invokeRestart("muffleMessage")
[08:29:21.788]                     }
[08:29:21.788]                     else if (inherits(cond, "warning")) {
[08:29:21.788]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.788]                       if (muffled) 
[08:29:21.788]                         invokeRestart("muffleWarning")
[08:29:21.788]                     }
[08:29:21.788]                     else if (inherits(cond, "condition")) {
[08:29:21.788]                       if (!is.null(pattern)) {
[08:29:21.788]                         computeRestarts <- base::computeRestarts
[08:29:21.788]                         grepl <- base::grepl
[08:29:21.788]                         restarts <- computeRestarts(cond)
[08:29:21.788]                         for (restart in restarts) {
[08:29:21.788]                           name <- restart$name
[08:29:21.788]                           if (is.null(name)) 
[08:29:21.788]                             next
[08:29:21.788]                           if (!grepl(pattern, name)) 
[08:29:21.788]                             next
[08:29:21.788]                           invokeRestart(restart)
[08:29:21.788]                           muffled <- TRUE
[08:29:21.788]                           break
[08:29:21.788]                         }
[08:29:21.788]                       }
[08:29:21.788]                     }
[08:29:21.788]                     invisible(muffled)
[08:29:21.788]                   }
[08:29:21.788]                   muffleCondition(cond)
[08:29:21.788]                 })
[08:29:21.788]             }))
[08:29:21.788]             future::FutureResult(value = ...future.value$value, 
[08:29:21.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.788]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.788]                     ...future.globalenv.names))
[08:29:21.788]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.788]         }, condition = base::local({
[08:29:21.788]             c <- base::c
[08:29:21.788]             inherits <- base::inherits
[08:29:21.788]             invokeRestart <- base::invokeRestart
[08:29:21.788]             length <- base::length
[08:29:21.788]             list <- base::list
[08:29:21.788]             seq.int <- base::seq.int
[08:29:21.788]             signalCondition <- base::signalCondition
[08:29:21.788]             sys.calls <- base::sys.calls
[08:29:21.788]             `[[` <- base::`[[`
[08:29:21.788]             `+` <- base::`+`
[08:29:21.788]             `<<-` <- base::`<<-`
[08:29:21.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.788]                   3L)]
[08:29:21.788]             }
[08:29:21.788]             function(cond) {
[08:29:21.788]                 is_error <- inherits(cond, "error")
[08:29:21.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.788]                   NULL)
[08:29:21.788]                 if (is_error) {
[08:29:21.788]                   sessionInformation <- function() {
[08:29:21.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.788]                       search = base::search(), system = base::Sys.info())
[08:29:21.788]                   }
[08:29:21.788]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.788]                     cond$call), session = sessionInformation(), 
[08:29:21.788]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.788]                   signalCondition(cond)
[08:29:21.788]                 }
[08:29:21.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.788]                 "immediateCondition"))) {
[08:29:21.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.788]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.788]                   if (TRUE && !signal) {
[08:29:21.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.788]                     {
[08:29:21.788]                       inherits <- base::inherits
[08:29:21.788]                       invokeRestart <- base::invokeRestart
[08:29:21.788]                       is.null <- base::is.null
[08:29:21.788]                       muffled <- FALSE
[08:29:21.788]                       if (inherits(cond, "message")) {
[08:29:21.788]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.788]                         if (muffled) 
[08:29:21.788]                           invokeRestart("muffleMessage")
[08:29:21.788]                       }
[08:29:21.788]                       else if (inherits(cond, "warning")) {
[08:29:21.788]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.788]                         if (muffled) 
[08:29:21.788]                           invokeRestart("muffleWarning")
[08:29:21.788]                       }
[08:29:21.788]                       else if (inherits(cond, "condition")) {
[08:29:21.788]                         if (!is.null(pattern)) {
[08:29:21.788]                           computeRestarts <- base::computeRestarts
[08:29:21.788]                           grepl <- base::grepl
[08:29:21.788]                           restarts <- computeRestarts(cond)
[08:29:21.788]                           for (restart in restarts) {
[08:29:21.788]                             name <- restart$name
[08:29:21.788]                             if (is.null(name)) 
[08:29:21.788]                               next
[08:29:21.788]                             if (!grepl(pattern, name)) 
[08:29:21.788]                               next
[08:29:21.788]                             invokeRestart(restart)
[08:29:21.788]                             muffled <- TRUE
[08:29:21.788]                             break
[08:29:21.788]                           }
[08:29:21.788]                         }
[08:29:21.788]                       }
[08:29:21.788]                       invisible(muffled)
[08:29:21.788]                     }
[08:29:21.788]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.788]                   }
[08:29:21.788]                 }
[08:29:21.788]                 else {
[08:29:21.788]                   if (TRUE) {
[08:29:21.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.788]                     {
[08:29:21.788]                       inherits <- base::inherits
[08:29:21.788]                       invokeRestart <- base::invokeRestart
[08:29:21.788]                       is.null <- base::is.null
[08:29:21.788]                       muffled <- FALSE
[08:29:21.788]                       if (inherits(cond, "message")) {
[08:29:21.788]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.788]                         if (muffled) 
[08:29:21.788]                           invokeRestart("muffleMessage")
[08:29:21.788]                       }
[08:29:21.788]                       else if (inherits(cond, "warning")) {
[08:29:21.788]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.788]                         if (muffled) 
[08:29:21.788]                           invokeRestart("muffleWarning")
[08:29:21.788]                       }
[08:29:21.788]                       else if (inherits(cond, "condition")) {
[08:29:21.788]                         if (!is.null(pattern)) {
[08:29:21.788]                           computeRestarts <- base::computeRestarts
[08:29:21.788]                           grepl <- base::grepl
[08:29:21.788]                           restarts <- computeRestarts(cond)
[08:29:21.788]                           for (restart in restarts) {
[08:29:21.788]                             name <- restart$name
[08:29:21.788]                             if (is.null(name)) 
[08:29:21.788]                               next
[08:29:21.788]                             if (!grepl(pattern, name)) 
[08:29:21.788]                               next
[08:29:21.788]                             invokeRestart(restart)
[08:29:21.788]                             muffled <- TRUE
[08:29:21.788]                             break
[08:29:21.788]                           }
[08:29:21.788]                         }
[08:29:21.788]                       }
[08:29:21.788]                       invisible(muffled)
[08:29:21.788]                     }
[08:29:21.788]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.788]                   }
[08:29:21.788]                 }
[08:29:21.788]             }
[08:29:21.788]         }))
[08:29:21.788]     }, error = function(ex) {
[08:29:21.788]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.788]                 ...future.rng), started = ...future.startTime, 
[08:29:21.788]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.788]             version = "1.8"), class = "FutureResult")
[08:29:21.788]     }, finally = {
[08:29:21.788]         if (!identical(...future.workdir, getwd())) 
[08:29:21.788]             setwd(...future.workdir)
[08:29:21.788]         {
[08:29:21.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.788]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.788]             }
[08:29:21.788]             base::options(...future.oldOptions)
[08:29:21.788]             if (.Platform$OS.type == "windows") {
[08:29:21.788]                 old_names <- names(...future.oldEnvVars)
[08:29:21.788]                 envs <- base::Sys.getenv()
[08:29:21.788]                 names <- names(envs)
[08:29:21.788]                 common <- intersect(names, old_names)
[08:29:21.788]                 added <- setdiff(names, old_names)
[08:29:21.788]                 removed <- setdiff(old_names, names)
[08:29:21.788]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.788]                   envs[common]]
[08:29:21.788]                 NAMES <- toupper(changed)
[08:29:21.788]                 args <- list()
[08:29:21.788]                 for (kk in seq_along(NAMES)) {
[08:29:21.788]                   name <- changed[[kk]]
[08:29:21.788]                   NAME <- NAMES[[kk]]
[08:29:21.788]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.788]                     next
[08:29:21.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.788]                 }
[08:29:21.788]                 NAMES <- toupper(added)
[08:29:21.788]                 for (kk in seq_along(NAMES)) {
[08:29:21.788]                   name <- added[[kk]]
[08:29:21.788]                   NAME <- NAMES[[kk]]
[08:29:21.788]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.788]                     next
[08:29:21.788]                   args[[name]] <- ""
[08:29:21.788]                 }
[08:29:21.788]                 NAMES <- toupper(removed)
[08:29:21.788]                 for (kk in seq_along(NAMES)) {
[08:29:21.788]                   name <- removed[[kk]]
[08:29:21.788]                   NAME <- NAMES[[kk]]
[08:29:21.788]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.788]                     next
[08:29:21.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.788]                 }
[08:29:21.788]                 if (length(args) > 0) 
[08:29:21.788]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.788]             }
[08:29:21.788]             else {
[08:29:21.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.788]             }
[08:29:21.788]             {
[08:29:21.788]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.788]                   0L) {
[08:29:21.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.788]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.788]                   base::options(opts)
[08:29:21.788]                 }
[08:29:21.788]                 {
[08:29:21.788]                   {
[08:29:21.788]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.788]                     NULL
[08:29:21.788]                   }
[08:29:21.788]                   options(future.plan = NULL)
[08:29:21.788]                   if (is.na(NA_character_)) 
[08:29:21.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.788]                     .init = FALSE)
[08:29:21.788]                 }
[08:29:21.788]             }
[08:29:21.788]         }
[08:29:21.788]     })
[08:29:21.788]     if (TRUE) {
[08:29:21.788]         base::sink(type = "output", split = FALSE)
[08:29:21.788]         if (TRUE) {
[08:29:21.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.788]         }
[08:29:21.788]         else {
[08:29:21.788]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.788]         }
[08:29:21.788]         base::close(...future.stdout)
[08:29:21.788]         ...future.stdout <- NULL
[08:29:21.788]     }
[08:29:21.788]     ...future.result$conditions <- ...future.conditions
[08:29:21.788]     ...future.result$finished <- base::Sys.time()
[08:29:21.788]     ...future.result
[08:29:21.788] }
[08:29:21.791] MultisessionFuture started
[08:29:21.791] - Launch lazy future ... done
[08:29:21.792] run() for ‘MultisessionFuture’ ... done
[08:29:21.792] getGlobalsAndPackages() ...
[08:29:21.792] Searching for globals...
[08:29:21.793] - globals found: [1] ‘{’
[08:29:21.793] Searching for globals ... DONE
[08:29:21.793] Resolving globals: FALSE
[08:29:21.793] 
[08:29:21.793] 
[08:29:21.793] getGlobalsAndPackages() ... DONE
[08:29:21.793] run() for ‘Future’ ...
[08:29:21.794] - state: ‘created’
[08:29:21.794] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.808] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.808] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.808]   - Field: ‘node’
[08:29:21.808]   - Field: ‘label’
[08:29:21.808]   - Field: ‘local’
[08:29:21.808]   - Field: ‘owner’
[08:29:21.808]   - Field: ‘envir’
[08:29:21.808]   - Field: ‘workers’
[08:29:21.809]   - Field: ‘packages’
[08:29:21.809]   - Field: ‘gc’
[08:29:21.809]   - Field: ‘conditions’
[08:29:21.809]   - Field: ‘persistent’
[08:29:21.809]   - Field: ‘expr’
[08:29:21.809]   - Field: ‘uuid’
[08:29:21.809]   - Field: ‘seed’
[08:29:21.809]   - Field: ‘version’
[08:29:21.809]   - Field: ‘result’
[08:29:21.809]   - Field: ‘asynchronous’
[08:29:21.809]   - Field: ‘calls’
[08:29:21.810]   - Field: ‘globals’
[08:29:21.810]   - Field: ‘stdout’
[08:29:21.810]   - Field: ‘earlySignal’
[08:29:21.810]   - Field: ‘lazy’
[08:29:21.810]   - Field: ‘state’
[08:29:21.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.810] - Launch lazy future ...
[08:29:21.810] Packages needed by the future expression (n = 0): <none>
[08:29:21.810] Packages needed by future strategies (n = 0): <none>
[08:29:21.811] {
[08:29:21.811]     {
[08:29:21.811]         {
[08:29:21.811]             ...future.startTime <- base::Sys.time()
[08:29:21.811]             {
[08:29:21.811]                 {
[08:29:21.811]                   {
[08:29:21.811]                     {
[08:29:21.811]                       base::local({
[08:29:21.811]                         has_future <- base::requireNamespace("future", 
[08:29:21.811]                           quietly = TRUE)
[08:29:21.811]                         if (has_future) {
[08:29:21.811]                           ns <- base::getNamespace("future")
[08:29:21.811]                           version <- ns[[".package"]][["version"]]
[08:29:21.811]                           if (is.null(version)) 
[08:29:21.811]                             version <- utils::packageVersion("future")
[08:29:21.811]                         }
[08:29:21.811]                         else {
[08:29:21.811]                           version <- NULL
[08:29:21.811]                         }
[08:29:21.811]                         if (!has_future || version < "1.8.0") {
[08:29:21.811]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.811]                             "", base::R.version$version.string), 
[08:29:21.811]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.811]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.811]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.811]                               "release", "version")], collapse = " "), 
[08:29:21.811]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.811]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.811]                             info)
[08:29:21.811]                           info <- base::paste(info, collapse = "; ")
[08:29:21.811]                           if (!has_future) {
[08:29:21.811]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.811]                               info)
[08:29:21.811]                           }
[08:29:21.811]                           else {
[08:29:21.811]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.811]                               info, version)
[08:29:21.811]                           }
[08:29:21.811]                           base::stop(msg)
[08:29:21.811]                         }
[08:29:21.811]                       })
[08:29:21.811]                     }
[08:29:21.811]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.811]                     base::options(mc.cores = 1L)
[08:29:21.811]                   }
[08:29:21.811]                   ...future.strategy.old <- future::plan("list")
[08:29:21.811]                   options(future.plan = NULL)
[08:29:21.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.811]                 }
[08:29:21.811]                 ...future.workdir <- getwd()
[08:29:21.811]             }
[08:29:21.811]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.811]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.811]         }
[08:29:21.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.811]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.811]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.811]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.811]             base::names(...future.oldOptions))
[08:29:21.811]     }
[08:29:21.811]     if (FALSE) {
[08:29:21.811]     }
[08:29:21.811]     else {
[08:29:21.811]         if (TRUE) {
[08:29:21.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.811]                 open = "w")
[08:29:21.811]         }
[08:29:21.811]         else {
[08:29:21.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.811]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.811]         }
[08:29:21.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.811]             base::sink(type = "output", split = FALSE)
[08:29:21.811]             base::close(...future.stdout)
[08:29:21.811]         }, add = TRUE)
[08:29:21.811]     }
[08:29:21.811]     ...future.frame <- base::sys.nframe()
[08:29:21.811]     ...future.conditions <- base::list()
[08:29:21.811]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.811]     if (FALSE) {
[08:29:21.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.811]     }
[08:29:21.811]     ...future.result <- base::tryCatch({
[08:29:21.811]         base::withCallingHandlers({
[08:29:21.811]             ...future.value <- base::withVisible(base::local({
[08:29:21.811]                 ...future.makeSendCondition <- base::local({
[08:29:21.811]                   sendCondition <- NULL
[08:29:21.811]                   function(frame = 1L) {
[08:29:21.811]                     if (is.function(sendCondition)) 
[08:29:21.811]                       return(sendCondition)
[08:29:21.811]                     ns <- getNamespace("parallel")
[08:29:21.811]                     if (exists("sendData", mode = "function", 
[08:29:21.811]                       envir = ns)) {
[08:29:21.811]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.811]                         envir = ns)
[08:29:21.811]                       envir <- sys.frame(frame)
[08:29:21.811]                       master <- NULL
[08:29:21.811]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.811]                         !identical(envir, emptyenv())) {
[08:29:21.811]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.811]                           inherits = FALSE)) {
[08:29:21.811]                           master <- get("master", mode = "list", 
[08:29:21.811]                             envir = envir, inherits = FALSE)
[08:29:21.811]                           if (inherits(master, c("SOCKnode", 
[08:29:21.811]                             "SOCK0node"))) {
[08:29:21.811]                             sendCondition <<- function(cond) {
[08:29:21.811]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.811]                                 success = TRUE)
[08:29:21.811]                               parallel_sendData(master, data)
[08:29:21.811]                             }
[08:29:21.811]                             return(sendCondition)
[08:29:21.811]                           }
[08:29:21.811]                         }
[08:29:21.811]                         frame <- frame + 1L
[08:29:21.811]                         envir <- sys.frame(frame)
[08:29:21.811]                       }
[08:29:21.811]                     }
[08:29:21.811]                     sendCondition <<- function(cond) NULL
[08:29:21.811]                   }
[08:29:21.811]                 })
[08:29:21.811]                 withCallingHandlers({
[08:29:21.811]                   {
[08:29:21.811]                     2
[08:29:21.811]                   }
[08:29:21.811]                 }, immediateCondition = function(cond) {
[08:29:21.811]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.811]                   sendCondition(cond)
[08:29:21.811]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.811]                   {
[08:29:21.811]                     inherits <- base::inherits
[08:29:21.811]                     invokeRestart <- base::invokeRestart
[08:29:21.811]                     is.null <- base::is.null
[08:29:21.811]                     muffled <- FALSE
[08:29:21.811]                     if (inherits(cond, "message")) {
[08:29:21.811]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.811]                       if (muffled) 
[08:29:21.811]                         invokeRestart("muffleMessage")
[08:29:21.811]                     }
[08:29:21.811]                     else if (inherits(cond, "warning")) {
[08:29:21.811]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.811]                       if (muffled) 
[08:29:21.811]                         invokeRestart("muffleWarning")
[08:29:21.811]                     }
[08:29:21.811]                     else if (inherits(cond, "condition")) {
[08:29:21.811]                       if (!is.null(pattern)) {
[08:29:21.811]                         computeRestarts <- base::computeRestarts
[08:29:21.811]                         grepl <- base::grepl
[08:29:21.811]                         restarts <- computeRestarts(cond)
[08:29:21.811]                         for (restart in restarts) {
[08:29:21.811]                           name <- restart$name
[08:29:21.811]                           if (is.null(name)) 
[08:29:21.811]                             next
[08:29:21.811]                           if (!grepl(pattern, name)) 
[08:29:21.811]                             next
[08:29:21.811]                           invokeRestart(restart)
[08:29:21.811]                           muffled <- TRUE
[08:29:21.811]                           break
[08:29:21.811]                         }
[08:29:21.811]                       }
[08:29:21.811]                     }
[08:29:21.811]                     invisible(muffled)
[08:29:21.811]                   }
[08:29:21.811]                   muffleCondition(cond)
[08:29:21.811]                 })
[08:29:21.811]             }))
[08:29:21.811]             future::FutureResult(value = ...future.value$value, 
[08:29:21.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.811]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.811]                     ...future.globalenv.names))
[08:29:21.811]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.811]         }, condition = base::local({
[08:29:21.811]             c <- base::c
[08:29:21.811]             inherits <- base::inherits
[08:29:21.811]             invokeRestart <- base::invokeRestart
[08:29:21.811]             length <- base::length
[08:29:21.811]             list <- base::list
[08:29:21.811]             seq.int <- base::seq.int
[08:29:21.811]             signalCondition <- base::signalCondition
[08:29:21.811]             sys.calls <- base::sys.calls
[08:29:21.811]             `[[` <- base::`[[`
[08:29:21.811]             `+` <- base::`+`
[08:29:21.811]             `<<-` <- base::`<<-`
[08:29:21.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.811]                   3L)]
[08:29:21.811]             }
[08:29:21.811]             function(cond) {
[08:29:21.811]                 is_error <- inherits(cond, "error")
[08:29:21.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.811]                   NULL)
[08:29:21.811]                 if (is_error) {
[08:29:21.811]                   sessionInformation <- function() {
[08:29:21.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.811]                       search = base::search(), system = base::Sys.info())
[08:29:21.811]                   }
[08:29:21.811]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.811]                     cond$call), session = sessionInformation(), 
[08:29:21.811]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.811]                   signalCondition(cond)
[08:29:21.811]                 }
[08:29:21.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.811]                 "immediateCondition"))) {
[08:29:21.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.811]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.811]                   if (TRUE && !signal) {
[08:29:21.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.811]                     {
[08:29:21.811]                       inherits <- base::inherits
[08:29:21.811]                       invokeRestart <- base::invokeRestart
[08:29:21.811]                       is.null <- base::is.null
[08:29:21.811]                       muffled <- FALSE
[08:29:21.811]                       if (inherits(cond, "message")) {
[08:29:21.811]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.811]                         if (muffled) 
[08:29:21.811]                           invokeRestart("muffleMessage")
[08:29:21.811]                       }
[08:29:21.811]                       else if (inherits(cond, "warning")) {
[08:29:21.811]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.811]                         if (muffled) 
[08:29:21.811]                           invokeRestart("muffleWarning")
[08:29:21.811]                       }
[08:29:21.811]                       else if (inherits(cond, "condition")) {
[08:29:21.811]                         if (!is.null(pattern)) {
[08:29:21.811]                           computeRestarts <- base::computeRestarts
[08:29:21.811]                           grepl <- base::grepl
[08:29:21.811]                           restarts <- computeRestarts(cond)
[08:29:21.811]                           for (restart in restarts) {
[08:29:21.811]                             name <- restart$name
[08:29:21.811]                             if (is.null(name)) 
[08:29:21.811]                               next
[08:29:21.811]                             if (!grepl(pattern, name)) 
[08:29:21.811]                               next
[08:29:21.811]                             invokeRestart(restart)
[08:29:21.811]                             muffled <- TRUE
[08:29:21.811]                             break
[08:29:21.811]                           }
[08:29:21.811]                         }
[08:29:21.811]                       }
[08:29:21.811]                       invisible(muffled)
[08:29:21.811]                     }
[08:29:21.811]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.811]                   }
[08:29:21.811]                 }
[08:29:21.811]                 else {
[08:29:21.811]                   if (TRUE) {
[08:29:21.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.811]                     {
[08:29:21.811]                       inherits <- base::inherits
[08:29:21.811]                       invokeRestart <- base::invokeRestart
[08:29:21.811]                       is.null <- base::is.null
[08:29:21.811]                       muffled <- FALSE
[08:29:21.811]                       if (inherits(cond, "message")) {
[08:29:21.811]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.811]                         if (muffled) 
[08:29:21.811]                           invokeRestart("muffleMessage")
[08:29:21.811]                       }
[08:29:21.811]                       else if (inherits(cond, "warning")) {
[08:29:21.811]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.811]                         if (muffled) 
[08:29:21.811]                           invokeRestart("muffleWarning")
[08:29:21.811]                       }
[08:29:21.811]                       else if (inherits(cond, "condition")) {
[08:29:21.811]                         if (!is.null(pattern)) {
[08:29:21.811]                           computeRestarts <- base::computeRestarts
[08:29:21.811]                           grepl <- base::grepl
[08:29:21.811]                           restarts <- computeRestarts(cond)
[08:29:21.811]                           for (restart in restarts) {
[08:29:21.811]                             name <- restart$name
[08:29:21.811]                             if (is.null(name)) 
[08:29:21.811]                               next
[08:29:21.811]                             if (!grepl(pattern, name)) 
[08:29:21.811]                               next
[08:29:21.811]                             invokeRestart(restart)
[08:29:21.811]                             muffled <- TRUE
[08:29:21.811]                             break
[08:29:21.811]                           }
[08:29:21.811]                         }
[08:29:21.811]                       }
[08:29:21.811]                       invisible(muffled)
[08:29:21.811]                     }
[08:29:21.811]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.811]                   }
[08:29:21.811]                 }
[08:29:21.811]             }
[08:29:21.811]         }))
[08:29:21.811]     }, error = function(ex) {
[08:29:21.811]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.811]                 ...future.rng), started = ...future.startTime, 
[08:29:21.811]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.811]             version = "1.8"), class = "FutureResult")
[08:29:21.811]     }, finally = {
[08:29:21.811]         if (!identical(...future.workdir, getwd())) 
[08:29:21.811]             setwd(...future.workdir)
[08:29:21.811]         {
[08:29:21.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.811]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.811]             }
[08:29:21.811]             base::options(...future.oldOptions)
[08:29:21.811]             if (.Platform$OS.type == "windows") {
[08:29:21.811]                 old_names <- names(...future.oldEnvVars)
[08:29:21.811]                 envs <- base::Sys.getenv()
[08:29:21.811]                 names <- names(envs)
[08:29:21.811]                 common <- intersect(names, old_names)
[08:29:21.811]                 added <- setdiff(names, old_names)
[08:29:21.811]                 removed <- setdiff(old_names, names)
[08:29:21.811]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.811]                   envs[common]]
[08:29:21.811]                 NAMES <- toupper(changed)
[08:29:21.811]                 args <- list()
[08:29:21.811]                 for (kk in seq_along(NAMES)) {
[08:29:21.811]                   name <- changed[[kk]]
[08:29:21.811]                   NAME <- NAMES[[kk]]
[08:29:21.811]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.811]                     next
[08:29:21.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.811]                 }
[08:29:21.811]                 NAMES <- toupper(added)
[08:29:21.811]                 for (kk in seq_along(NAMES)) {
[08:29:21.811]                   name <- added[[kk]]
[08:29:21.811]                   NAME <- NAMES[[kk]]
[08:29:21.811]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.811]                     next
[08:29:21.811]                   args[[name]] <- ""
[08:29:21.811]                 }
[08:29:21.811]                 NAMES <- toupper(removed)
[08:29:21.811]                 for (kk in seq_along(NAMES)) {
[08:29:21.811]                   name <- removed[[kk]]
[08:29:21.811]                   NAME <- NAMES[[kk]]
[08:29:21.811]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.811]                     next
[08:29:21.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.811]                 }
[08:29:21.811]                 if (length(args) > 0) 
[08:29:21.811]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.811]             }
[08:29:21.811]             else {
[08:29:21.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.811]             }
[08:29:21.811]             {
[08:29:21.811]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.811]                   0L) {
[08:29:21.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.811]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.811]                   base::options(opts)
[08:29:21.811]                 }
[08:29:21.811]                 {
[08:29:21.811]                   {
[08:29:21.811]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.811]                     NULL
[08:29:21.811]                   }
[08:29:21.811]                   options(future.plan = NULL)
[08:29:21.811]                   if (is.na(NA_character_)) 
[08:29:21.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.811]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.811]                     .init = FALSE)
[08:29:21.811]                 }
[08:29:21.811]             }
[08:29:21.811]         }
[08:29:21.811]     })
[08:29:21.811]     if (TRUE) {
[08:29:21.811]         base::sink(type = "output", split = FALSE)
[08:29:21.811]         if (TRUE) {
[08:29:21.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.811]         }
[08:29:21.811]         else {
[08:29:21.811]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.811]         }
[08:29:21.811]         base::close(...future.stdout)
[08:29:21.811]         ...future.stdout <- NULL
[08:29:21.811]     }
[08:29:21.811]     ...future.result$conditions <- ...future.conditions
[08:29:21.811]     ...future.result$finished <- base::Sys.time()
[08:29:21.811]     ...future.result
[08:29:21.811] }
[08:29:21.814] MultisessionFuture started
[08:29:21.814] - Launch lazy future ... done
[08:29:21.814] run() for ‘MultisessionFuture’ ... done
[08:29:21.815] resolve() on environment ...
[08:29:21.815]  recursive: 0
[08:29:21.815]  elements: [3] ‘a’
[08:29:21.836]  length: 2 (resolved future 3)
[08:29:21.847] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.847] - Validating connection of MultisessionFuture
[08:29:21.847] - received message: FutureResult
[08:29:21.847] - Received FutureResult
[08:29:21.848] - Erased future from FutureRegistry
[08:29:21.848] result() for ClusterFuture ...
[08:29:21.848] - result already collected: FutureResult
[08:29:21.848] result() for ClusterFuture ... done
[08:29:21.848] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.848] Future #1
[08:29:21.848]  length: 1 (resolved future 1)
[08:29:21.856] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.856] - Validating connection of MultisessionFuture
[08:29:21.856] - received message: FutureResult
[08:29:21.856] - Received FutureResult
[08:29:21.857] - Erased future from FutureRegistry
[08:29:21.857] result() for ClusterFuture ...
[08:29:21.857] - result already collected: FutureResult
[08:29:21.857] result() for ClusterFuture ... done
[08:29:21.857] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.857] Future #2
[08:29:21.857]  length: 0 (resolved future 2)
[08:29:21.857] resolve() on environment ... DONE
[08:29:21.861] resolve() on environment ...
[08:29:21.861]  recursive: 0
[08:29:21.861]  elements: [3] ‘b’
[08:29:21.861] Future #1
[08:29:21.862]  length: 2 (resolved future 1)
[08:29:21.862] Future #2
[08:29:21.862]  length: 1 (resolved future 2)
[08:29:21.862]  length: 0 (resolved future 3)
[08:29:21.862] resolve() on environment ... DONE
[08:29:21.862] resolve() on environment ...
[08:29:21.863]  recursive: 0
[08:29:21.863]  elements: [3] ‘c’
[08:29:21.863] Future #1
[08:29:21.863]  length: 2 (resolved future 1)
[08:29:21.863] Future #2
[08:29:21.863]  length: 1 (resolved future 2)
[08:29:21.863]  length: 0 (resolved future 3)
[08:29:21.864] resolve() on environment ... DONE
[08:29:21.864] resolve() on environment ...
[08:29:21.864]  recursive: 0
[08:29:21.864]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[08:29:21.865] Future #1
[08:29:21.865] result() for ClusterFuture ...
[08:29:21.865] - result already collected: FutureResult
[08:29:21.865] result() for ClusterFuture ... done
[08:29:21.865] result() for ClusterFuture ...
[08:29:21.865] - result already collected: FutureResult
[08:29:21.865] result() for ClusterFuture ... done
[08:29:21.865]  length: 2 (resolved future 1)
[08:29:21.865] Future #2
[08:29:21.865] result() for ClusterFuture ...
[08:29:21.866] - result already collected: FutureResult
[08:29:21.866] result() for ClusterFuture ... done
[08:29:21.866] result() for ClusterFuture ...
[08:29:21.866] - result already collected: FutureResult
[08:29:21.866] result() for ClusterFuture ... done
[08:29:21.866]  length: 1 (resolved future 2)
[08:29:21.866]  length: 0 (resolved future 3)
[08:29:21.866] resolve() on environment ... DONE
[08:29:21.867] resolve() on environment ...
[08:29:21.867]  recursive: 99
[08:29:21.867]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[08:29:21.867] Future #1
[08:29:21.867] result() for ClusterFuture ...
[08:29:21.868] - result already collected: FutureResult
[08:29:21.868] result() for ClusterFuture ... done
[08:29:21.868] result() for ClusterFuture ...
[08:29:21.868] - result already collected: FutureResult
[08:29:21.868] result() for ClusterFuture ... done
[08:29:21.868] A MultisessionFuture was resolved
[08:29:21.868]  length: 2 (resolved future 1)
[08:29:21.868] Future #2
[08:29:21.868] result() for ClusterFuture ...
[08:29:21.868] - result already collected: FutureResult
[08:29:21.868] result() for ClusterFuture ... done
[08:29:21.869] result() for ClusterFuture ...
[08:29:21.869] - result already collected: FutureResult
[08:29:21.869] result() for ClusterFuture ... done
[08:29:21.869] A MultisessionFuture was resolved
[08:29:21.869]  length: 1 (resolved future 2)
[08:29:21.869]  length: 0 (resolved future 3)
[08:29:21.869] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[08:29:21.870] resolve() on list environment ...
[08:29:21.870]  recursive: 0
[08:29:21.870]  length: 2
[08:29:21.870]  elements: ‘a’, ‘b’
[08:29:21.871]  length: 1 (resolved future 1)
[08:29:21.871]  length: 0 (resolved future 2)
[08:29:21.871] resolve() on list environment ... DONE
[08:29:21.871] getGlobalsAndPackages() ...
[08:29:21.871] Searching for globals...
[08:29:21.871] 
[08:29:21.871] Searching for globals ... DONE
[08:29:21.871] - globals: [0] <none>
[08:29:21.872] getGlobalsAndPackages() ... DONE
[08:29:21.872] run() for ‘Future’ ...
[08:29:21.872] - state: ‘created’
[08:29:21.872] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.886] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.886]   - Field: ‘node’
[08:29:21.886]   - Field: ‘label’
[08:29:21.886]   - Field: ‘local’
[08:29:21.886]   - Field: ‘owner’
[08:29:21.886]   - Field: ‘envir’
[08:29:21.886]   - Field: ‘workers’
[08:29:21.887]   - Field: ‘packages’
[08:29:21.887]   - Field: ‘gc’
[08:29:21.887]   - Field: ‘conditions’
[08:29:21.887]   - Field: ‘persistent’
[08:29:21.887]   - Field: ‘expr’
[08:29:21.887]   - Field: ‘uuid’
[08:29:21.887]   - Field: ‘seed’
[08:29:21.887]   - Field: ‘version’
[08:29:21.887]   - Field: ‘result’
[08:29:21.887]   - Field: ‘asynchronous’
[08:29:21.887]   - Field: ‘calls’
[08:29:21.887]   - Field: ‘globals’
[08:29:21.888]   - Field: ‘stdout’
[08:29:21.888]   - Field: ‘earlySignal’
[08:29:21.888]   - Field: ‘lazy’
[08:29:21.888]   - Field: ‘state’
[08:29:21.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.888] - Launch lazy future ...
[08:29:21.888] Packages needed by the future expression (n = 0): <none>
[08:29:21.888] Packages needed by future strategies (n = 0): <none>
[08:29:21.889] {
[08:29:21.889]     {
[08:29:21.889]         {
[08:29:21.889]             ...future.startTime <- base::Sys.time()
[08:29:21.889]             {
[08:29:21.889]                 {
[08:29:21.889]                   {
[08:29:21.889]                     {
[08:29:21.889]                       base::local({
[08:29:21.889]                         has_future <- base::requireNamespace("future", 
[08:29:21.889]                           quietly = TRUE)
[08:29:21.889]                         if (has_future) {
[08:29:21.889]                           ns <- base::getNamespace("future")
[08:29:21.889]                           version <- ns[[".package"]][["version"]]
[08:29:21.889]                           if (is.null(version)) 
[08:29:21.889]                             version <- utils::packageVersion("future")
[08:29:21.889]                         }
[08:29:21.889]                         else {
[08:29:21.889]                           version <- NULL
[08:29:21.889]                         }
[08:29:21.889]                         if (!has_future || version < "1.8.0") {
[08:29:21.889]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.889]                             "", base::R.version$version.string), 
[08:29:21.889]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.889]                               "release", "version")], collapse = " "), 
[08:29:21.889]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.889]                             info)
[08:29:21.889]                           info <- base::paste(info, collapse = "; ")
[08:29:21.889]                           if (!has_future) {
[08:29:21.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.889]                               info)
[08:29:21.889]                           }
[08:29:21.889]                           else {
[08:29:21.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.889]                               info, version)
[08:29:21.889]                           }
[08:29:21.889]                           base::stop(msg)
[08:29:21.889]                         }
[08:29:21.889]                       })
[08:29:21.889]                     }
[08:29:21.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.889]                     base::options(mc.cores = 1L)
[08:29:21.889]                   }
[08:29:21.889]                   ...future.strategy.old <- future::plan("list")
[08:29:21.889]                   options(future.plan = NULL)
[08:29:21.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.889]                 }
[08:29:21.889]                 ...future.workdir <- getwd()
[08:29:21.889]             }
[08:29:21.889]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.889]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.889]         }
[08:29:21.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.889]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.889]             base::names(...future.oldOptions))
[08:29:21.889]     }
[08:29:21.889]     if (FALSE) {
[08:29:21.889]     }
[08:29:21.889]     else {
[08:29:21.889]         if (TRUE) {
[08:29:21.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.889]                 open = "w")
[08:29:21.889]         }
[08:29:21.889]         else {
[08:29:21.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.889]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.889]         }
[08:29:21.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.889]             base::sink(type = "output", split = FALSE)
[08:29:21.889]             base::close(...future.stdout)
[08:29:21.889]         }, add = TRUE)
[08:29:21.889]     }
[08:29:21.889]     ...future.frame <- base::sys.nframe()
[08:29:21.889]     ...future.conditions <- base::list()
[08:29:21.889]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.889]     if (FALSE) {
[08:29:21.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.889]     }
[08:29:21.889]     ...future.result <- base::tryCatch({
[08:29:21.889]         base::withCallingHandlers({
[08:29:21.889]             ...future.value <- base::withVisible(base::local({
[08:29:21.889]                 ...future.makeSendCondition <- base::local({
[08:29:21.889]                   sendCondition <- NULL
[08:29:21.889]                   function(frame = 1L) {
[08:29:21.889]                     if (is.function(sendCondition)) 
[08:29:21.889]                       return(sendCondition)
[08:29:21.889]                     ns <- getNamespace("parallel")
[08:29:21.889]                     if (exists("sendData", mode = "function", 
[08:29:21.889]                       envir = ns)) {
[08:29:21.889]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.889]                         envir = ns)
[08:29:21.889]                       envir <- sys.frame(frame)
[08:29:21.889]                       master <- NULL
[08:29:21.889]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.889]                         !identical(envir, emptyenv())) {
[08:29:21.889]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.889]                           inherits = FALSE)) {
[08:29:21.889]                           master <- get("master", mode = "list", 
[08:29:21.889]                             envir = envir, inherits = FALSE)
[08:29:21.889]                           if (inherits(master, c("SOCKnode", 
[08:29:21.889]                             "SOCK0node"))) {
[08:29:21.889]                             sendCondition <<- function(cond) {
[08:29:21.889]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.889]                                 success = TRUE)
[08:29:21.889]                               parallel_sendData(master, data)
[08:29:21.889]                             }
[08:29:21.889]                             return(sendCondition)
[08:29:21.889]                           }
[08:29:21.889]                         }
[08:29:21.889]                         frame <- frame + 1L
[08:29:21.889]                         envir <- sys.frame(frame)
[08:29:21.889]                       }
[08:29:21.889]                     }
[08:29:21.889]                     sendCondition <<- function(cond) NULL
[08:29:21.889]                   }
[08:29:21.889]                 })
[08:29:21.889]                 withCallingHandlers({
[08:29:21.889]                   1
[08:29:21.889]                 }, immediateCondition = function(cond) {
[08:29:21.889]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.889]                   sendCondition(cond)
[08:29:21.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.889]                   {
[08:29:21.889]                     inherits <- base::inherits
[08:29:21.889]                     invokeRestart <- base::invokeRestart
[08:29:21.889]                     is.null <- base::is.null
[08:29:21.889]                     muffled <- FALSE
[08:29:21.889]                     if (inherits(cond, "message")) {
[08:29:21.889]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.889]                       if (muffled) 
[08:29:21.889]                         invokeRestart("muffleMessage")
[08:29:21.889]                     }
[08:29:21.889]                     else if (inherits(cond, "warning")) {
[08:29:21.889]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.889]                       if (muffled) 
[08:29:21.889]                         invokeRestart("muffleWarning")
[08:29:21.889]                     }
[08:29:21.889]                     else if (inherits(cond, "condition")) {
[08:29:21.889]                       if (!is.null(pattern)) {
[08:29:21.889]                         computeRestarts <- base::computeRestarts
[08:29:21.889]                         grepl <- base::grepl
[08:29:21.889]                         restarts <- computeRestarts(cond)
[08:29:21.889]                         for (restart in restarts) {
[08:29:21.889]                           name <- restart$name
[08:29:21.889]                           if (is.null(name)) 
[08:29:21.889]                             next
[08:29:21.889]                           if (!grepl(pattern, name)) 
[08:29:21.889]                             next
[08:29:21.889]                           invokeRestart(restart)
[08:29:21.889]                           muffled <- TRUE
[08:29:21.889]                           break
[08:29:21.889]                         }
[08:29:21.889]                       }
[08:29:21.889]                     }
[08:29:21.889]                     invisible(muffled)
[08:29:21.889]                   }
[08:29:21.889]                   muffleCondition(cond)
[08:29:21.889]                 })
[08:29:21.889]             }))
[08:29:21.889]             future::FutureResult(value = ...future.value$value, 
[08:29:21.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.889]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.889]                     ...future.globalenv.names))
[08:29:21.889]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.889]         }, condition = base::local({
[08:29:21.889]             c <- base::c
[08:29:21.889]             inherits <- base::inherits
[08:29:21.889]             invokeRestart <- base::invokeRestart
[08:29:21.889]             length <- base::length
[08:29:21.889]             list <- base::list
[08:29:21.889]             seq.int <- base::seq.int
[08:29:21.889]             signalCondition <- base::signalCondition
[08:29:21.889]             sys.calls <- base::sys.calls
[08:29:21.889]             `[[` <- base::`[[`
[08:29:21.889]             `+` <- base::`+`
[08:29:21.889]             `<<-` <- base::`<<-`
[08:29:21.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.889]                   3L)]
[08:29:21.889]             }
[08:29:21.889]             function(cond) {
[08:29:21.889]                 is_error <- inherits(cond, "error")
[08:29:21.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.889]                   NULL)
[08:29:21.889]                 if (is_error) {
[08:29:21.889]                   sessionInformation <- function() {
[08:29:21.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.889]                       search = base::search(), system = base::Sys.info())
[08:29:21.889]                   }
[08:29:21.889]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.889]                     cond$call), session = sessionInformation(), 
[08:29:21.889]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.889]                   signalCondition(cond)
[08:29:21.889]                 }
[08:29:21.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.889]                 "immediateCondition"))) {
[08:29:21.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.889]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.889]                   if (TRUE && !signal) {
[08:29:21.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.889]                     {
[08:29:21.889]                       inherits <- base::inherits
[08:29:21.889]                       invokeRestart <- base::invokeRestart
[08:29:21.889]                       is.null <- base::is.null
[08:29:21.889]                       muffled <- FALSE
[08:29:21.889]                       if (inherits(cond, "message")) {
[08:29:21.889]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.889]                         if (muffled) 
[08:29:21.889]                           invokeRestart("muffleMessage")
[08:29:21.889]                       }
[08:29:21.889]                       else if (inherits(cond, "warning")) {
[08:29:21.889]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.889]                         if (muffled) 
[08:29:21.889]                           invokeRestart("muffleWarning")
[08:29:21.889]                       }
[08:29:21.889]                       else if (inherits(cond, "condition")) {
[08:29:21.889]                         if (!is.null(pattern)) {
[08:29:21.889]                           computeRestarts <- base::computeRestarts
[08:29:21.889]                           grepl <- base::grepl
[08:29:21.889]                           restarts <- computeRestarts(cond)
[08:29:21.889]                           for (restart in restarts) {
[08:29:21.889]                             name <- restart$name
[08:29:21.889]                             if (is.null(name)) 
[08:29:21.889]                               next
[08:29:21.889]                             if (!grepl(pattern, name)) 
[08:29:21.889]                               next
[08:29:21.889]                             invokeRestart(restart)
[08:29:21.889]                             muffled <- TRUE
[08:29:21.889]                             break
[08:29:21.889]                           }
[08:29:21.889]                         }
[08:29:21.889]                       }
[08:29:21.889]                       invisible(muffled)
[08:29:21.889]                     }
[08:29:21.889]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.889]                   }
[08:29:21.889]                 }
[08:29:21.889]                 else {
[08:29:21.889]                   if (TRUE) {
[08:29:21.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.889]                     {
[08:29:21.889]                       inherits <- base::inherits
[08:29:21.889]                       invokeRestart <- base::invokeRestart
[08:29:21.889]                       is.null <- base::is.null
[08:29:21.889]                       muffled <- FALSE
[08:29:21.889]                       if (inherits(cond, "message")) {
[08:29:21.889]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.889]                         if (muffled) 
[08:29:21.889]                           invokeRestart("muffleMessage")
[08:29:21.889]                       }
[08:29:21.889]                       else if (inherits(cond, "warning")) {
[08:29:21.889]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.889]                         if (muffled) 
[08:29:21.889]                           invokeRestart("muffleWarning")
[08:29:21.889]                       }
[08:29:21.889]                       else if (inherits(cond, "condition")) {
[08:29:21.889]                         if (!is.null(pattern)) {
[08:29:21.889]                           computeRestarts <- base::computeRestarts
[08:29:21.889]                           grepl <- base::grepl
[08:29:21.889]                           restarts <- computeRestarts(cond)
[08:29:21.889]                           for (restart in restarts) {
[08:29:21.889]                             name <- restart$name
[08:29:21.889]                             if (is.null(name)) 
[08:29:21.889]                               next
[08:29:21.889]                             if (!grepl(pattern, name)) 
[08:29:21.889]                               next
[08:29:21.889]                             invokeRestart(restart)
[08:29:21.889]                             muffled <- TRUE
[08:29:21.889]                             break
[08:29:21.889]                           }
[08:29:21.889]                         }
[08:29:21.889]                       }
[08:29:21.889]                       invisible(muffled)
[08:29:21.889]                     }
[08:29:21.889]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.889]                   }
[08:29:21.889]                 }
[08:29:21.889]             }
[08:29:21.889]         }))
[08:29:21.889]     }, error = function(ex) {
[08:29:21.889]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.889]                 ...future.rng), started = ...future.startTime, 
[08:29:21.889]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.889]             version = "1.8"), class = "FutureResult")
[08:29:21.889]     }, finally = {
[08:29:21.889]         if (!identical(...future.workdir, getwd())) 
[08:29:21.889]             setwd(...future.workdir)
[08:29:21.889]         {
[08:29:21.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.889]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.889]             }
[08:29:21.889]             base::options(...future.oldOptions)
[08:29:21.889]             if (.Platform$OS.type == "windows") {
[08:29:21.889]                 old_names <- names(...future.oldEnvVars)
[08:29:21.889]                 envs <- base::Sys.getenv()
[08:29:21.889]                 names <- names(envs)
[08:29:21.889]                 common <- intersect(names, old_names)
[08:29:21.889]                 added <- setdiff(names, old_names)
[08:29:21.889]                 removed <- setdiff(old_names, names)
[08:29:21.889]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.889]                   envs[common]]
[08:29:21.889]                 NAMES <- toupper(changed)
[08:29:21.889]                 args <- list()
[08:29:21.889]                 for (kk in seq_along(NAMES)) {
[08:29:21.889]                   name <- changed[[kk]]
[08:29:21.889]                   NAME <- NAMES[[kk]]
[08:29:21.889]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.889]                     next
[08:29:21.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.889]                 }
[08:29:21.889]                 NAMES <- toupper(added)
[08:29:21.889]                 for (kk in seq_along(NAMES)) {
[08:29:21.889]                   name <- added[[kk]]
[08:29:21.889]                   NAME <- NAMES[[kk]]
[08:29:21.889]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.889]                     next
[08:29:21.889]                   args[[name]] <- ""
[08:29:21.889]                 }
[08:29:21.889]                 NAMES <- toupper(removed)
[08:29:21.889]                 for (kk in seq_along(NAMES)) {
[08:29:21.889]                   name <- removed[[kk]]
[08:29:21.889]                   NAME <- NAMES[[kk]]
[08:29:21.889]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.889]                     next
[08:29:21.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.889]                 }
[08:29:21.889]                 if (length(args) > 0) 
[08:29:21.889]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.889]             }
[08:29:21.889]             else {
[08:29:21.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.889]             }
[08:29:21.889]             {
[08:29:21.889]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.889]                   0L) {
[08:29:21.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.889]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.889]                   base::options(opts)
[08:29:21.889]                 }
[08:29:21.889]                 {
[08:29:21.889]                   {
[08:29:21.889]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.889]                     NULL
[08:29:21.889]                   }
[08:29:21.889]                   options(future.plan = NULL)
[08:29:21.889]                   if (is.na(NA_character_)) 
[08:29:21.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.889]                     .init = FALSE)
[08:29:21.889]                 }
[08:29:21.889]             }
[08:29:21.889]         }
[08:29:21.889]     })
[08:29:21.889]     if (TRUE) {
[08:29:21.889]         base::sink(type = "output", split = FALSE)
[08:29:21.889]         if (TRUE) {
[08:29:21.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.889]         }
[08:29:21.889]         else {
[08:29:21.889]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.889]         }
[08:29:21.889]         base::close(...future.stdout)
[08:29:21.889]         ...future.stdout <- NULL
[08:29:21.889]     }
[08:29:21.889]     ...future.result$conditions <- ...future.conditions
[08:29:21.889]     ...future.result$finished <- base::Sys.time()
[08:29:21.889]     ...future.result
[08:29:21.889] }
[08:29:21.892] MultisessionFuture started
[08:29:21.892] - Launch lazy future ... done
[08:29:21.892] run() for ‘MultisessionFuture’ ... done
[08:29:21.892] getGlobalsAndPackages() ...
[08:29:21.892] Searching for globals...
[08:29:21.893] 
[08:29:21.893] Searching for globals ... DONE
[08:29:21.893] - globals: [0] <none>
[08:29:21.893] getGlobalsAndPackages() ... DONE
[08:29:21.893] run() for ‘Future’ ...
[08:29:21.893] - state: ‘created’
[08:29:21.893] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.908] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.909]   - Field: ‘node’
[08:29:21.909]   - Field: ‘label’
[08:29:21.909]   - Field: ‘local’
[08:29:21.909]   - Field: ‘owner’
[08:29:21.909]   - Field: ‘envir’
[08:29:21.909]   - Field: ‘workers’
[08:29:21.909]   - Field: ‘packages’
[08:29:21.909]   - Field: ‘gc’
[08:29:21.909]   - Field: ‘conditions’
[08:29:21.909]   - Field: ‘persistent’
[08:29:21.910]   - Field: ‘expr’
[08:29:21.910]   - Field: ‘uuid’
[08:29:21.910]   - Field: ‘seed’
[08:29:21.910]   - Field: ‘version’
[08:29:21.910]   - Field: ‘result’
[08:29:21.910]   - Field: ‘asynchronous’
[08:29:21.910]   - Field: ‘calls’
[08:29:21.910]   - Field: ‘globals’
[08:29:21.910]   - Field: ‘stdout’
[08:29:21.910]   - Field: ‘earlySignal’
[08:29:21.910]   - Field: ‘lazy’
[08:29:21.911]   - Field: ‘state’
[08:29:21.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.911] - Launch lazy future ...
[08:29:21.911] Packages needed by the future expression (n = 0): <none>
[08:29:21.911] Packages needed by future strategies (n = 0): <none>
[08:29:21.911] {
[08:29:21.911]     {
[08:29:21.911]         {
[08:29:21.911]             ...future.startTime <- base::Sys.time()
[08:29:21.911]             {
[08:29:21.911]                 {
[08:29:21.911]                   {
[08:29:21.911]                     {
[08:29:21.911]                       base::local({
[08:29:21.911]                         has_future <- base::requireNamespace("future", 
[08:29:21.911]                           quietly = TRUE)
[08:29:21.911]                         if (has_future) {
[08:29:21.911]                           ns <- base::getNamespace("future")
[08:29:21.911]                           version <- ns[[".package"]][["version"]]
[08:29:21.911]                           if (is.null(version)) 
[08:29:21.911]                             version <- utils::packageVersion("future")
[08:29:21.911]                         }
[08:29:21.911]                         else {
[08:29:21.911]                           version <- NULL
[08:29:21.911]                         }
[08:29:21.911]                         if (!has_future || version < "1.8.0") {
[08:29:21.911]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.911]                             "", base::R.version$version.string), 
[08:29:21.911]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.911]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.911]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.911]                               "release", "version")], collapse = " "), 
[08:29:21.911]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.911]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.911]                             info)
[08:29:21.911]                           info <- base::paste(info, collapse = "; ")
[08:29:21.911]                           if (!has_future) {
[08:29:21.911]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.911]                               info)
[08:29:21.911]                           }
[08:29:21.911]                           else {
[08:29:21.911]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.911]                               info, version)
[08:29:21.911]                           }
[08:29:21.911]                           base::stop(msg)
[08:29:21.911]                         }
[08:29:21.911]                       })
[08:29:21.911]                     }
[08:29:21.911]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.911]                     base::options(mc.cores = 1L)
[08:29:21.911]                   }
[08:29:21.911]                   ...future.strategy.old <- future::plan("list")
[08:29:21.911]                   options(future.plan = NULL)
[08:29:21.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.911]                 }
[08:29:21.911]                 ...future.workdir <- getwd()
[08:29:21.911]             }
[08:29:21.911]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.911]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.911]         }
[08:29:21.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.911]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.911]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.911]             base::names(...future.oldOptions))
[08:29:21.911]     }
[08:29:21.911]     if (FALSE) {
[08:29:21.911]     }
[08:29:21.911]     else {
[08:29:21.911]         if (TRUE) {
[08:29:21.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.911]                 open = "w")
[08:29:21.911]         }
[08:29:21.911]         else {
[08:29:21.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.911]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.911]         }
[08:29:21.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.911]             base::sink(type = "output", split = FALSE)
[08:29:21.911]             base::close(...future.stdout)
[08:29:21.911]         }, add = TRUE)
[08:29:21.911]     }
[08:29:21.911]     ...future.frame <- base::sys.nframe()
[08:29:21.911]     ...future.conditions <- base::list()
[08:29:21.911]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.911]     if (FALSE) {
[08:29:21.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.911]     }
[08:29:21.911]     ...future.result <- base::tryCatch({
[08:29:21.911]         base::withCallingHandlers({
[08:29:21.911]             ...future.value <- base::withVisible(base::local({
[08:29:21.911]                 ...future.makeSendCondition <- base::local({
[08:29:21.911]                   sendCondition <- NULL
[08:29:21.911]                   function(frame = 1L) {
[08:29:21.911]                     if (is.function(sendCondition)) 
[08:29:21.911]                       return(sendCondition)
[08:29:21.911]                     ns <- getNamespace("parallel")
[08:29:21.911]                     if (exists("sendData", mode = "function", 
[08:29:21.911]                       envir = ns)) {
[08:29:21.911]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.911]                         envir = ns)
[08:29:21.911]                       envir <- sys.frame(frame)
[08:29:21.911]                       master <- NULL
[08:29:21.911]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.911]                         !identical(envir, emptyenv())) {
[08:29:21.911]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.911]                           inherits = FALSE)) {
[08:29:21.911]                           master <- get("master", mode = "list", 
[08:29:21.911]                             envir = envir, inherits = FALSE)
[08:29:21.911]                           if (inherits(master, c("SOCKnode", 
[08:29:21.911]                             "SOCK0node"))) {
[08:29:21.911]                             sendCondition <<- function(cond) {
[08:29:21.911]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.911]                                 success = TRUE)
[08:29:21.911]                               parallel_sendData(master, data)
[08:29:21.911]                             }
[08:29:21.911]                             return(sendCondition)
[08:29:21.911]                           }
[08:29:21.911]                         }
[08:29:21.911]                         frame <- frame + 1L
[08:29:21.911]                         envir <- sys.frame(frame)
[08:29:21.911]                       }
[08:29:21.911]                     }
[08:29:21.911]                     sendCondition <<- function(cond) NULL
[08:29:21.911]                   }
[08:29:21.911]                 })
[08:29:21.911]                 withCallingHandlers({
[08:29:21.911]                   2
[08:29:21.911]                 }, immediateCondition = function(cond) {
[08:29:21.911]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.911]                   sendCondition(cond)
[08:29:21.911]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.911]                   {
[08:29:21.911]                     inherits <- base::inherits
[08:29:21.911]                     invokeRestart <- base::invokeRestart
[08:29:21.911]                     is.null <- base::is.null
[08:29:21.911]                     muffled <- FALSE
[08:29:21.911]                     if (inherits(cond, "message")) {
[08:29:21.911]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.911]                       if (muffled) 
[08:29:21.911]                         invokeRestart("muffleMessage")
[08:29:21.911]                     }
[08:29:21.911]                     else if (inherits(cond, "warning")) {
[08:29:21.911]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.911]                       if (muffled) 
[08:29:21.911]                         invokeRestart("muffleWarning")
[08:29:21.911]                     }
[08:29:21.911]                     else if (inherits(cond, "condition")) {
[08:29:21.911]                       if (!is.null(pattern)) {
[08:29:21.911]                         computeRestarts <- base::computeRestarts
[08:29:21.911]                         grepl <- base::grepl
[08:29:21.911]                         restarts <- computeRestarts(cond)
[08:29:21.911]                         for (restart in restarts) {
[08:29:21.911]                           name <- restart$name
[08:29:21.911]                           if (is.null(name)) 
[08:29:21.911]                             next
[08:29:21.911]                           if (!grepl(pattern, name)) 
[08:29:21.911]                             next
[08:29:21.911]                           invokeRestart(restart)
[08:29:21.911]                           muffled <- TRUE
[08:29:21.911]                           break
[08:29:21.911]                         }
[08:29:21.911]                       }
[08:29:21.911]                     }
[08:29:21.911]                     invisible(muffled)
[08:29:21.911]                   }
[08:29:21.911]                   muffleCondition(cond)
[08:29:21.911]                 })
[08:29:21.911]             }))
[08:29:21.911]             future::FutureResult(value = ...future.value$value, 
[08:29:21.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.911]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.911]                     ...future.globalenv.names))
[08:29:21.911]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.911]         }, condition = base::local({
[08:29:21.911]             c <- base::c
[08:29:21.911]             inherits <- base::inherits
[08:29:21.911]             invokeRestart <- base::invokeRestart
[08:29:21.911]             length <- base::length
[08:29:21.911]             list <- base::list
[08:29:21.911]             seq.int <- base::seq.int
[08:29:21.911]             signalCondition <- base::signalCondition
[08:29:21.911]             sys.calls <- base::sys.calls
[08:29:21.911]             `[[` <- base::`[[`
[08:29:21.911]             `+` <- base::`+`
[08:29:21.911]             `<<-` <- base::`<<-`
[08:29:21.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.911]                   3L)]
[08:29:21.911]             }
[08:29:21.911]             function(cond) {
[08:29:21.911]                 is_error <- inherits(cond, "error")
[08:29:21.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.911]                   NULL)
[08:29:21.911]                 if (is_error) {
[08:29:21.911]                   sessionInformation <- function() {
[08:29:21.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.911]                       search = base::search(), system = base::Sys.info())
[08:29:21.911]                   }
[08:29:21.911]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.911]                     cond$call), session = sessionInformation(), 
[08:29:21.911]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.911]                   signalCondition(cond)
[08:29:21.911]                 }
[08:29:21.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.911]                 "immediateCondition"))) {
[08:29:21.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.911]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.911]                   if (TRUE && !signal) {
[08:29:21.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.911]                     {
[08:29:21.911]                       inherits <- base::inherits
[08:29:21.911]                       invokeRestart <- base::invokeRestart
[08:29:21.911]                       is.null <- base::is.null
[08:29:21.911]                       muffled <- FALSE
[08:29:21.911]                       if (inherits(cond, "message")) {
[08:29:21.911]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.911]                         if (muffled) 
[08:29:21.911]                           invokeRestart("muffleMessage")
[08:29:21.911]                       }
[08:29:21.911]                       else if (inherits(cond, "warning")) {
[08:29:21.911]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.911]                         if (muffled) 
[08:29:21.911]                           invokeRestart("muffleWarning")
[08:29:21.911]                       }
[08:29:21.911]                       else if (inherits(cond, "condition")) {
[08:29:21.911]                         if (!is.null(pattern)) {
[08:29:21.911]                           computeRestarts <- base::computeRestarts
[08:29:21.911]                           grepl <- base::grepl
[08:29:21.911]                           restarts <- computeRestarts(cond)
[08:29:21.911]                           for (restart in restarts) {
[08:29:21.911]                             name <- restart$name
[08:29:21.911]                             if (is.null(name)) 
[08:29:21.911]                               next
[08:29:21.911]                             if (!grepl(pattern, name)) 
[08:29:21.911]                               next
[08:29:21.911]                             invokeRestart(restart)
[08:29:21.911]                             muffled <- TRUE
[08:29:21.911]                             break
[08:29:21.911]                           }
[08:29:21.911]                         }
[08:29:21.911]                       }
[08:29:21.911]                       invisible(muffled)
[08:29:21.911]                     }
[08:29:21.911]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.911]                   }
[08:29:21.911]                 }
[08:29:21.911]                 else {
[08:29:21.911]                   if (TRUE) {
[08:29:21.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.911]                     {
[08:29:21.911]                       inherits <- base::inherits
[08:29:21.911]                       invokeRestart <- base::invokeRestart
[08:29:21.911]                       is.null <- base::is.null
[08:29:21.911]                       muffled <- FALSE
[08:29:21.911]                       if (inherits(cond, "message")) {
[08:29:21.911]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.911]                         if (muffled) 
[08:29:21.911]                           invokeRestart("muffleMessage")
[08:29:21.911]                       }
[08:29:21.911]                       else if (inherits(cond, "warning")) {
[08:29:21.911]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.911]                         if (muffled) 
[08:29:21.911]                           invokeRestart("muffleWarning")
[08:29:21.911]                       }
[08:29:21.911]                       else if (inherits(cond, "condition")) {
[08:29:21.911]                         if (!is.null(pattern)) {
[08:29:21.911]                           computeRestarts <- base::computeRestarts
[08:29:21.911]                           grepl <- base::grepl
[08:29:21.911]                           restarts <- computeRestarts(cond)
[08:29:21.911]                           for (restart in restarts) {
[08:29:21.911]                             name <- restart$name
[08:29:21.911]                             if (is.null(name)) 
[08:29:21.911]                               next
[08:29:21.911]                             if (!grepl(pattern, name)) 
[08:29:21.911]                               next
[08:29:21.911]                             invokeRestart(restart)
[08:29:21.911]                             muffled <- TRUE
[08:29:21.911]                             break
[08:29:21.911]                           }
[08:29:21.911]                         }
[08:29:21.911]                       }
[08:29:21.911]                       invisible(muffled)
[08:29:21.911]                     }
[08:29:21.911]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.911]                   }
[08:29:21.911]                 }
[08:29:21.911]             }
[08:29:21.911]         }))
[08:29:21.911]     }, error = function(ex) {
[08:29:21.911]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.911]                 ...future.rng), started = ...future.startTime, 
[08:29:21.911]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.911]             version = "1.8"), class = "FutureResult")
[08:29:21.911]     }, finally = {
[08:29:21.911]         if (!identical(...future.workdir, getwd())) 
[08:29:21.911]             setwd(...future.workdir)
[08:29:21.911]         {
[08:29:21.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.911]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.911]             }
[08:29:21.911]             base::options(...future.oldOptions)
[08:29:21.911]             if (.Platform$OS.type == "windows") {
[08:29:21.911]                 old_names <- names(...future.oldEnvVars)
[08:29:21.911]                 envs <- base::Sys.getenv()
[08:29:21.911]                 names <- names(envs)
[08:29:21.911]                 common <- intersect(names, old_names)
[08:29:21.911]                 added <- setdiff(names, old_names)
[08:29:21.911]                 removed <- setdiff(old_names, names)
[08:29:21.911]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.911]                   envs[common]]
[08:29:21.911]                 NAMES <- toupper(changed)
[08:29:21.911]                 args <- list()
[08:29:21.911]                 for (kk in seq_along(NAMES)) {
[08:29:21.911]                   name <- changed[[kk]]
[08:29:21.911]                   NAME <- NAMES[[kk]]
[08:29:21.911]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.911]                     next
[08:29:21.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.911]                 }
[08:29:21.911]                 NAMES <- toupper(added)
[08:29:21.911]                 for (kk in seq_along(NAMES)) {
[08:29:21.911]                   name <- added[[kk]]
[08:29:21.911]                   NAME <- NAMES[[kk]]
[08:29:21.911]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.911]                     next
[08:29:21.911]                   args[[name]] <- ""
[08:29:21.911]                 }
[08:29:21.911]                 NAMES <- toupper(removed)
[08:29:21.911]                 for (kk in seq_along(NAMES)) {
[08:29:21.911]                   name <- removed[[kk]]
[08:29:21.911]                   NAME <- NAMES[[kk]]
[08:29:21.911]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.911]                     next
[08:29:21.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.911]                 }
[08:29:21.911]                 if (length(args) > 0) 
[08:29:21.911]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.911]             }
[08:29:21.911]             else {
[08:29:21.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.911]             }
[08:29:21.911]             {
[08:29:21.911]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.911]                   0L) {
[08:29:21.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.911]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.911]                   base::options(opts)
[08:29:21.911]                 }
[08:29:21.911]                 {
[08:29:21.911]                   {
[08:29:21.911]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.911]                     NULL
[08:29:21.911]                   }
[08:29:21.911]                   options(future.plan = NULL)
[08:29:21.911]                   if (is.na(NA_character_)) 
[08:29:21.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.911]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.911]                     .init = FALSE)
[08:29:21.911]                 }
[08:29:21.911]             }
[08:29:21.911]         }
[08:29:21.911]     })
[08:29:21.911]     if (TRUE) {
[08:29:21.911]         base::sink(type = "output", split = FALSE)
[08:29:21.911]         if (TRUE) {
[08:29:21.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.911]         }
[08:29:21.911]         else {
[08:29:21.911]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.911]         }
[08:29:21.911]         base::close(...future.stdout)
[08:29:21.911]         ...future.stdout <- NULL
[08:29:21.911]     }
[08:29:21.911]     ...future.result$conditions <- ...future.conditions
[08:29:21.911]     ...future.result$finished <- base::Sys.time()
[08:29:21.911]     ...future.result
[08:29:21.911] }
[08:29:21.914] MultisessionFuture started
[08:29:21.915] - Launch lazy future ... done
[08:29:21.915] run() for ‘MultisessionFuture’ ... done
[08:29:21.915] resolve() on list environment ...
[08:29:21.915]  recursive: 0
[08:29:21.916]  length: 3
[08:29:21.916]  elements: ‘a’, ‘b’, ‘c’
[08:29:21.937]  length: 2 (resolved future 3)
[08:29:21.948] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.948] - Validating connection of MultisessionFuture
[08:29:21.948] - received message: FutureResult
[08:29:21.948] - Received FutureResult
[08:29:21.948] - Erased future from FutureRegistry
[08:29:21.948] result() for ClusterFuture ...
[08:29:21.949] - result already collected: FutureResult
[08:29:21.949] result() for ClusterFuture ... done
[08:29:21.949] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.949] Future #1
[08:29:21.949]  length: 1 (resolved future 1)
[08:29:21.957] receiveMessageFromWorker() for ClusterFuture ...
[08:29:21.957] - Validating connection of MultisessionFuture
[08:29:21.957] - received message: FutureResult
[08:29:21.957] - Received FutureResult
[08:29:21.957] - Erased future from FutureRegistry
[08:29:21.958] result() for ClusterFuture ...
[08:29:21.958] - result already collected: FutureResult
[08:29:21.958] result() for ClusterFuture ... done
[08:29:21.958] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:21.958] Future #2
[08:29:21.958]  length: 0 (resolved future 2)
[08:29:21.958] resolve() on list environment ... DONE
[08:29:21.959] getGlobalsAndPackages() ...
[08:29:21.959] Searching for globals...
[08:29:21.959] - globals found: [1] ‘{’
[08:29:21.960] Searching for globals ... DONE
[08:29:21.960] Resolving globals: FALSE
[08:29:21.960] 
[08:29:21.960] 
[08:29:21.960] getGlobalsAndPackages() ... DONE
[08:29:21.960] run() for ‘Future’ ...
[08:29:21.960] - state: ‘created’
[08:29:21.961] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.974] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.975] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.975]   - Field: ‘node’
[08:29:21.975]   - Field: ‘label’
[08:29:21.975]   - Field: ‘local’
[08:29:21.975]   - Field: ‘owner’
[08:29:21.975]   - Field: ‘envir’
[08:29:21.975]   - Field: ‘workers’
[08:29:21.975]   - Field: ‘packages’
[08:29:21.975]   - Field: ‘gc’
[08:29:21.975]   - Field: ‘conditions’
[08:29:21.976]   - Field: ‘persistent’
[08:29:21.976]   - Field: ‘expr’
[08:29:21.976]   - Field: ‘uuid’
[08:29:21.976]   - Field: ‘seed’
[08:29:21.976]   - Field: ‘version’
[08:29:21.976]   - Field: ‘result’
[08:29:21.976]   - Field: ‘asynchronous’
[08:29:21.976]   - Field: ‘calls’
[08:29:21.976]   - Field: ‘globals’
[08:29:21.976]   - Field: ‘stdout’
[08:29:21.976]   - Field: ‘earlySignal’
[08:29:21.976]   - Field: ‘lazy’
[08:29:21.977]   - Field: ‘state’
[08:29:21.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.977] - Launch lazy future ...
[08:29:21.977] Packages needed by the future expression (n = 0): <none>
[08:29:21.977] Packages needed by future strategies (n = 0): <none>
[08:29:21.978] {
[08:29:21.978]     {
[08:29:21.978]         {
[08:29:21.978]             ...future.startTime <- base::Sys.time()
[08:29:21.978]             {
[08:29:21.978]                 {
[08:29:21.978]                   {
[08:29:21.978]                     {
[08:29:21.978]                       base::local({
[08:29:21.978]                         has_future <- base::requireNamespace("future", 
[08:29:21.978]                           quietly = TRUE)
[08:29:21.978]                         if (has_future) {
[08:29:21.978]                           ns <- base::getNamespace("future")
[08:29:21.978]                           version <- ns[[".package"]][["version"]]
[08:29:21.978]                           if (is.null(version)) 
[08:29:21.978]                             version <- utils::packageVersion("future")
[08:29:21.978]                         }
[08:29:21.978]                         else {
[08:29:21.978]                           version <- NULL
[08:29:21.978]                         }
[08:29:21.978]                         if (!has_future || version < "1.8.0") {
[08:29:21.978]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:21.978]                             "", base::R.version$version.string), 
[08:29:21.978]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:21.978]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:21.978]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:21.978]                               "release", "version")], collapse = " "), 
[08:29:21.978]                             hostname = base::Sys.info()[["nodename"]])
[08:29:21.978]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:21.978]                             info)
[08:29:21.978]                           info <- base::paste(info, collapse = "; ")
[08:29:21.978]                           if (!has_future) {
[08:29:21.978]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:21.978]                               info)
[08:29:21.978]                           }
[08:29:21.978]                           else {
[08:29:21.978]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:21.978]                               info, version)
[08:29:21.978]                           }
[08:29:21.978]                           base::stop(msg)
[08:29:21.978]                         }
[08:29:21.978]                       })
[08:29:21.978]                     }
[08:29:21.978]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:21.978]                     base::options(mc.cores = 1L)
[08:29:21.978]                   }
[08:29:21.978]                   ...future.strategy.old <- future::plan("list")
[08:29:21.978]                   options(future.plan = NULL)
[08:29:21.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:21.978]                 }
[08:29:21.978]                 ...future.workdir <- getwd()
[08:29:21.978]             }
[08:29:21.978]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:21.978]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:21.978]         }
[08:29:21.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:21.978]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:21.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:21.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:21.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:21.978]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:21.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:21.978]             base::names(...future.oldOptions))
[08:29:21.978]     }
[08:29:21.978]     if (FALSE) {
[08:29:21.978]     }
[08:29:21.978]     else {
[08:29:21.978]         if (TRUE) {
[08:29:21.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:21.978]                 open = "w")
[08:29:21.978]         }
[08:29:21.978]         else {
[08:29:21.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:21.978]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:21.978]         }
[08:29:21.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:21.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:21.978]             base::sink(type = "output", split = FALSE)
[08:29:21.978]             base::close(...future.stdout)
[08:29:21.978]         }, add = TRUE)
[08:29:21.978]     }
[08:29:21.978]     ...future.frame <- base::sys.nframe()
[08:29:21.978]     ...future.conditions <- base::list()
[08:29:21.978]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:21.978]     if (FALSE) {
[08:29:21.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:21.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:21.978]     }
[08:29:21.978]     ...future.result <- base::tryCatch({
[08:29:21.978]         base::withCallingHandlers({
[08:29:21.978]             ...future.value <- base::withVisible(base::local({
[08:29:21.978]                 ...future.makeSendCondition <- base::local({
[08:29:21.978]                   sendCondition <- NULL
[08:29:21.978]                   function(frame = 1L) {
[08:29:21.978]                     if (is.function(sendCondition)) 
[08:29:21.978]                       return(sendCondition)
[08:29:21.978]                     ns <- getNamespace("parallel")
[08:29:21.978]                     if (exists("sendData", mode = "function", 
[08:29:21.978]                       envir = ns)) {
[08:29:21.978]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:21.978]                         envir = ns)
[08:29:21.978]                       envir <- sys.frame(frame)
[08:29:21.978]                       master <- NULL
[08:29:21.978]                       while (!identical(envir, .GlobalEnv) && 
[08:29:21.978]                         !identical(envir, emptyenv())) {
[08:29:21.978]                         if (exists("master", mode = "list", envir = envir, 
[08:29:21.978]                           inherits = FALSE)) {
[08:29:21.978]                           master <- get("master", mode = "list", 
[08:29:21.978]                             envir = envir, inherits = FALSE)
[08:29:21.978]                           if (inherits(master, c("SOCKnode", 
[08:29:21.978]                             "SOCK0node"))) {
[08:29:21.978]                             sendCondition <<- function(cond) {
[08:29:21.978]                               data <- list(type = "VALUE", value = cond, 
[08:29:21.978]                                 success = TRUE)
[08:29:21.978]                               parallel_sendData(master, data)
[08:29:21.978]                             }
[08:29:21.978]                             return(sendCondition)
[08:29:21.978]                           }
[08:29:21.978]                         }
[08:29:21.978]                         frame <- frame + 1L
[08:29:21.978]                         envir <- sys.frame(frame)
[08:29:21.978]                       }
[08:29:21.978]                     }
[08:29:21.978]                     sendCondition <<- function(cond) NULL
[08:29:21.978]                   }
[08:29:21.978]                 })
[08:29:21.978]                 withCallingHandlers({
[08:29:21.978]                   {
[08:29:21.978]                     1
[08:29:21.978]                   }
[08:29:21.978]                 }, immediateCondition = function(cond) {
[08:29:21.978]                   sendCondition <- ...future.makeSendCondition()
[08:29:21.978]                   sendCondition(cond)
[08:29:21.978]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.978]                   {
[08:29:21.978]                     inherits <- base::inherits
[08:29:21.978]                     invokeRestart <- base::invokeRestart
[08:29:21.978]                     is.null <- base::is.null
[08:29:21.978]                     muffled <- FALSE
[08:29:21.978]                     if (inherits(cond, "message")) {
[08:29:21.978]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:21.978]                       if (muffled) 
[08:29:21.978]                         invokeRestart("muffleMessage")
[08:29:21.978]                     }
[08:29:21.978]                     else if (inherits(cond, "warning")) {
[08:29:21.978]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:21.978]                       if (muffled) 
[08:29:21.978]                         invokeRestart("muffleWarning")
[08:29:21.978]                     }
[08:29:21.978]                     else if (inherits(cond, "condition")) {
[08:29:21.978]                       if (!is.null(pattern)) {
[08:29:21.978]                         computeRestarts <- base::computeRestarts
[08:29:21.978]                         grepl <- base::grepl
[08:29:21.978]                         restarts <- computeRestarts(cond)
[08:29:21.978]                         for (restart in restarts) {
[08:29:21.978]                           name <- restart$name
[08:29:21.978]                           if (is.null(name)) 
[08:29:21.978]                             next
[08:29:21.978]                           if (!grepl(pattern, name)) 
[08:29:21.978]                             next
[08:29:21.978]                           invokeRestart(restart)
[08:29:21.978]                           muffled <- TRUE
[08:29:21.978]                           break
[08:29:21.978]                         }
[08:29:21.978]                       }
[08:29:21.978]                     }
[08:29:21.978]                     invisible(muffled)
[08:29:21.978]                   }
[08:29:21.978]                   muffleCondition(cond)
[08:29:21.978]                 })
[08:29:21.978]             }))
[08:29:21.978]             future::FutureResult(value = ...future.value$value, 
[08:29:21.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.978]                   ...future.rng), globalenv = if (FALSE) 
[08:29:21.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:21.978]                     ...future.globalenv.names))
[08:29:21.978]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:21.978]         }, condition = base::local({
[08:29:21.978]             c <- base::c
[08:29:21.978]             inherits <- base::inherits
[08:29:21.978]             invokeRestart <- base::invokeRestart
[08:29:21.978]             length <- base::length
[08:29:21.978]             list <- base::list
[08:29:21.978]             seq.int <- base::seq.int
[08:29:21.978]             signalCondition <- base::signalCondition
[08:29:21.978]             sys.calls <- base::sys.calls
[08:29:21.978]             `[[` <- base::`[[`
[08:29:21.978]             `+` <- base::`+`
[08:29:21.978]             `<<-` <- base::`<<-`
[08:29:21.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:21.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:21.978]                   3L)]
[08:29:21.978]             }
[08:29:21.978]             function(cond) {
[08:29:21.978]                 is_error <- inherits(cond, "error")
[08:29:21.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:21.978]                   NULL)
[08:29:21.978]                 if (is_error) {
[08:29:21.978]                   sessionInformation <- function() {
[08:29:21.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:21.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:21.978]                       search = base::search(), system = base::Sys.info())
[08:29:21.978]                   }
[08:29:21.978]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:21.978]                     cond$call), session = sessionInformation(), 
[08:29:21.978]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:21.978]                   signalCondition(cond)
[08:29:21.978]                 }
[08:29:21.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:21.978]                 "immediateCondition"))) {
[08:29:21.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:21.978]                   ...future.conditions[[length(...future.conditions) + 
[08:29:21.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:21.978]                   if (TRUE && !signal) {
[08:29:21.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.978]                     {
[08:29:21.978]                       inherits <- base::inherits
[08:29:21.978]                       invokeRestart <- base::invokeRestart
[08:29:21.978]                       is.null <- base::is.null
[08:29:21.978]                       muffled <- FALSE
[08:29:21.978]                       if (inherits(cond, "message")) {
[08:29:21.978]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.978]                         if (muffled) 
[08:29:21.978]                           invokeRestart("muffleMessage")
[08:29:21.978]                       }
[08:29:21.978]                       else if (inherits(cond, "warning")) {
[08:29:21.978]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.978]                         if (muffled) 
[08:29:21.978]                           invokeRestart("muffleWarning")
[08:29:21.978]                       }
[08:29:21.978]                       else if (inherits(cond, "condition")) {
[08:29:21.978]                         if (!is.null(pattern)) {
[08:29:21.978]                           computeRestarts <- base::computeRestarts
[08:29:21.978]                           grepl <- base::grepl
[08:29:21.978]                           restarts <- computeRestarts(cond)
[08:29:21.978]                           for (restart in restarts) {
[08:29:21.978]                             name <- restart$name
[08:29:21.978]                             if (is.null(name)) 
[08:29:21.978]                               next
[08:29:21.978]                             if (!grepl(pattern, name)) 
[08:29:21.978]                               next
[08:29:21.978]                             invokeRestart(restart)
[08:29:21.978]                             muffled <- TRUE
[08:29:21.978]                             break
[08:29:21.978]                           }
[08:29:21.978]                         }
[08:29:21.978]                       }
[08:29:21.978]                       invisible(muffled)
[08:29:21.978]                     }
[08:29:21.978]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.978]                   }
[08:29:21.978]                 }
[08:29:21.978]                 else {
[08:29:21.978]                   if (TRUE) {
[08:29:21.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:21.978]                     {
[08:29:21.978]                       inherits <- base::inherits
[08:29:21.978]                       invokeRestart <- base::invokeRestart
[08:29:21.978]                       is.null <- base::is.null
[08:29:21.978]                       muffled <- FALSE
[08:29:21.978]                       if (inherits(cond, "message")) {
[08:29:21.978]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:21.978]                         if (muffled) 
[08:29:21.978]                           invokeRestart("muffleMessage")
[08:29:21.978]                       }
[08:29:21.978]                       else if (inherits(cond, "warning")) {
[08:29:21.978]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:21.978]                         if (muffled) 
[08:29:21.978]                           invokeRestart("muffleWarning")
[08:29:21.978]                       }
[08:29:21.978]                       else if (inherits(cond, "condition")) {
[08:29:21.978]                         if (!is.null(pattern)) {
[08:29:21.978]                           computeRestarts <- base::computeRestarts
[08:29:21.978]                           grepl <- base::grepl
[08:29:21.978]                           restarts <- computeRestarts(cond)
[08:29:21.978]                           for (restart in restarts) {
[08:29:21.978]                             name <- restart$name
[08:29:21.978]                             if (is.null(name)) 
[08:29:21.978]                               next
[08:29:21.978]                             if (!grepl(pattern, name)) 
[08:29:21.978]                               next
[08:29:21.978]                             invokeRestart(restart)
[08:29:21.978]                             muffled <- TRUE
[08:29:21.978]                             break
[08:29:21.978]                           }
[08:29:21.978]                         }
[08:29:21.978]                       }
[08:29:21.978]                       invisible(muffled)
[08:29:21.978]                     }
[08:29:21.978]                     muffleCondition(cond, pattern = "^muffle")
[08:29:21.978]                   }
[08:29:21.978]                 }
[08:29:21.978]             }
[08:29:21.978]         }))
[08:29:21.978]     }, error = function(ex) {
[08:29:21.978]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:21.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:21.978]                 ...future.rng), started = ...future.startTime, 
[08:29:21.978]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:21.978]             version = "1.8"), class = "FutureResult")
[08:29:21.978]     }, finally = {
[08:29:21.978]         if (!identical(...future.workdir, getwd())) 
[08:29:21.978]             setwd(...future.workdir)
[08:29:21.978]         {
[08:29:21.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:21.978]                 ...future.oldOptions$nwarnings <- NULL
[08:29:21.978]             }
[08:29:21.978]             base::options(...future.oldOptions)
[08:29:21.978]             if (.Platform$OS.type == "windows") {
[08:29:21.978]                 old_names <- names(...future.oldEnvVars)
[08:29:21.978]                 envs <- base::Sys.getenv()
[08:29:21.978]                 names <- names(envs)
[08:29:21.978]                 common <- intersect(names, old_names)
[08:29:21.978]                 added <- setdiff(names, old_names)
[08:29:21.978]                 removed <- setdiff(old_names, names)
[08:29:21.978]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:21.978]                   envs[common]]
[08:29:21.978]                 NAMES <- toupper(changed)
[08:29:21.978]                 args <- list()
[08:29:21.978]                 for (kk in seq_along(NAMES)) {
[08:29:21.978]                   name <- changed[[kk]]
[08:29:21.978]                   NAME <- NAMES[[kk]]
[08:29:21.978]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.978]                     next
[08:29:21.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.978]                 }
[08:29:21.978]                 NAMES <- toupper(added)
[08:29:21.978]                 for (kk in seq_along(NAMES)) {
[08:29:21.978]                   name <- added[[kk]]
[08:29:21.978]                   NAME <- NAMES[[kk]]
[08:29:21.978]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.978]                     next
[08:29:21.978]                   args[[name]] <- ""
[08:29:21.978]                 }
[08:29:21.978]                 NAMES <- toupper(removed)
[08:29:21.978]                 for (kk in seq_along(NAMES)) {
[08:29:21.978]                   name <- removed[[kk]]
[08:29:21.978]                   NAME <- NAMES[[kk]]
[08:29:21.978]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:21.978]                     next
[08:29:21.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:21.978]                 }
[08:29:21.978]                 if (length(args) > 0) 
[08:29:21.978]                   base::do.call(base::Sys.setenv, args = args)
[08:29:21.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:21.978]             }
[08:29:21.978]             else {
[08:29:21.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:21.978]             }
[08:29:21.978]             {
[08:29:21.978]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:21.978]                   0L) {
[08:29:21.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:21.978]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:21.978]                   base::options(opts)
[08:29:21.978]                 }
[08:29:21.978]                 {
[08:29:21.978]                   {
[08:29:21.978]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:21.978]                     NULL
[08:29:21.978]                   }
[08:29:21.978]                   options(future.plan = NULL)
[08:29:21.978]                   if (is.na(NA_character_)) 
[08:29:21.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:21.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:21.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:21.978]                     .init = FALSE)
[08:29:21.978]                 }
[08:29:21.978]             }
[08:29:21.978]         }
[08:29:21.978]     })
[08:29:21.978]     if (TRUE) {
[08:29:21.978]         base::sink(type = "output", split = FALSE)
[08:29:21.978]         if (TRUE) {
[08:29:21.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:21.978]         }
[08:29:21.978]         else {
[08:29:21.978]             ...future.result["stdout"] <- base::list(NULL)
[08:29:21.978]         }
[08:29:21.978]         base::close(...future.stdout)
[08:29:21.978]         ...future.stdout <- NULL
[08:29:21.978]     }
[08:29:21.978]     ...future.result$conditions <- ...future.conditions
[08:29:21.978]     ...future.result$finished <- base::Sys.time()
[08:29:21.978]     ...future.result
[08:29:21.978] }
[08:29:21.981] MultisessionFuture started
[08:29:21.981] - Launch lazy future ... done
[08:29:21.981] run() for ‘MultisessionFuture’ ... done
[08:29:21.981] getGlobalsAndPackages() ...
[08:29:21.981] Searching for globals...
[08:29:21.982] - globals found: [1] ‘{’
[08:29:21.982] Searching for globals ... DONE
[08:29:21.982] Resolving globals: FALSE
[08:29:21.982] 
[08:29:21.982] 
[08:29:21.982] getGlobalsAndPackages() ... DONE
[08:29:21.983] run() for ‘Future’ ...
[08:29:21.983] - state: ‘created’
[08:29:21.983] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:21.997] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:21.997] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:21.997]   - Field: ‘node’
[08:29:21.997]   - Field: ‘label’
[08:29:21.997]   - Field: ‘local’
[08:29:21.997]   - Field: ‘owner’
[08:29:21.997]   - Field: ‘envir’
[08:29:21.997]   - Field: ‘workers’
[08:29:21.997]   - Field: ‘packages’
[08:29:21.997]   - Field: ‘gc’
[08:29:21.998]   - Field: ‘conditions’
[08:29:21.998]   - Field: ‘persistent’
[08:29:21.998]   - Field: ‘expr’
[08:29:21.998]   - Field: ‘uuid’
[08:29:21.998]   - Field: ‘seed’
[08:29:21.998]   - Field: ‘version’
[08:29:21.998]   - Field: ‘result’
[08:29:21.998]   - Field: ‘asynchronous’
[08:29:21.998]   - Field: ‘calls’
[08:29:21.998]   - Field: ‘globals’
[08:29:21.998]   - Field: ‘stdout’
[08:29:21.999]   - Field: ‘earlySignal’
[08:29:21.999]   - Field: ‘lazy’
[08:29:21.999]   - Field: ‘state’
[08:29:21.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:21.999] - Launch lazy future ...
[08:29:21.999] Packages needed by the future expression (n = 0): <none>
[08:29:21.999] Packages needed by future strategies (n = 0): <none>
[08:29:22.000] {
[08:29:22.000]     {
[08:29:22.000]         {
[08:29:22.000]             ...future.startTime <- base::Sys.time()
[08:29:22.000]             {
[08:29:22.000]                 {
[08:29:22.000]                   {
[08:29:22.000]                     {
[08:29:22.000]                       base::local({
[08:29:22.000]                         has_future <- base::requireNamespace("future", 
[08:29:22.000]                           quietly = TRUE)
[08:29:22.000]                         if (has_future) {
[08:29:22.000]                           ns <- base::getNamespace("future")
[08:29:22.000]                           version <- ns[[".package"]][["version"]]
[08:29:22.000]                           if (is.null(version)) 
[08:29:22.000]                             version <- utils::packageVersion("future")
[08:29:22.000]                         }
[08:29:22.000]                         else {
[08:29:22.000]                           version <- NULL
[08:29:22.000]                         }
[08:29:22.000]                         if (!has_future || version < "1.8.0") {
[08:29:22.000]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:22.000]                             "", base::R.version$version.string), 
[08:29:22.000]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:22.000]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:22.000]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:22.000]                               "release", "version")], collapse = " "), 
[08:29:22.000]                             hostname = base::Sys.info()[["nodename"]])
[08:29:22.000]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:22.000]                             info)
[08:29:22.000]                           info <- base::paste(info, collapse = "; ")
[08:29:22.000]                           if (!has_future) {
[08:29:22.000]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:22.000]                               info)
[08:29:22.000]                           }
[08:29:22.000]                           else {
[08:29:22.000]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:22.000]                               info, version)
[08:29:22.000]                           }
[08:29:22.000]                           base::stop(msg)
[08:29:22.000]                         }
[08:29:22.000]                       })
[08:29:22.000]                     }
[08:29:22.000]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:22.000]                     base::options(mc.cores = 1L)
[08:29:22.000]                   }
[08:29:22.000]                   ...future.strategy.old <- future::plan("list")
[08:29:22.000]                   options(future.plan = NULL)
[08:29:22.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:22.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:22.000]                 }
[08:29:22.000]                 ...future.workdir <- getwd()
[08:29:22.000]             }
[08:29:22.000]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:22.000]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:22.000]         }
[08:29:22.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:22.000]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:22.000]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:22.000]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:22.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:22.000]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:22.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:22.000]             base::names(...future.oldOptions))
[08:29:22.000]     }
[08:29:22.000]     if (FALSE) {
[08:29:22.000]     }
[08:29:22.000]     else {
[08:29:22.000]         if (TRUE) {
[08:29:22.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:22.000]                 open = "w")
[08:29:22.000]         }
[08:29:22.000]         else {
[08:29:22.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:22.000]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:22.000]         }
[08:29:22.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:22.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:22.000]             base::sink(type = "output", split = FALSE)
[08:29:22.000]             base::close(...future.stdout)
[08:29:22.000]         }, add = TRUE)
[08:29:22.000]     }
[08:29:22.000]     ...future.frame <- base::sys.nframe()
[08:29:22.000]     ...future.conditions <- base::list()
[08:29:22.000]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:22.000]     if (FALSE) {
[08:29:22.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:22.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:22.000]     }
[08:29:22.000]     ...future.result <- base::tryCatch({
[08:29:22.000]         base::withCallingHandlers({
[08:29:22.000]             ...future.value <- base::withVisible(base::local({
[08:29:22.000]                 ...future.makeSendCondition <- base::local({
[08:29:22.000]                   sendCondition <- NULL
[08:29:22.000]                   function(frame = 1L) {
[08:29:22.000]                     if (is.function(sendCondition)) 
[08:29:22.000]                       return(sendCondition)
[08:29:22.000]                     ns <- getNamespace("parallel")
[08:29:22.000]                     if (exists("sendData", mode = "function", 
[08:29:22.000]                       envir = ns)) {
[08:29:22.000]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:22.000]                         envir = ns)
[08:29:22.000]                       envir <- sys.frame(frame)
[08:29:22.000]                       master <- NULL
[08:29:22.000]                       while (!identical(envir, .GlobalEnv) && 
[08:29:22.000]                         !identical(envir, emptyenv())) {
[08:29:22.000]                         if (exists("master", mode = "list", envir = envir, 
[08:29:22.000]                           inherits = FALSE)) {
[08:29:22.000]                           master <- get("master", mode = "list", 
[08:29:22.000]                             envir = envir, inherits = FALSE)
[08:29:22.000]                           if (inherits(master, c("SOCKnode", 
[08:29:22.000]                             "SOCK0node"))) {
[08:29:22.000]                             sendCondition <<- function(cond) {
[08:29:22.000]                               data <- list(type = "VALUE", value = cond, 
[08:29:22.000]                                 success = TRUE)
[08:29:22.000]                               parallel_sendData(master, data)
[08:29:22.000]                             }
[08:29:22.000]                             return(sendCondition)
[08:29:22.000]                           }
[08:29:22.000]                         }
[08:29:22.000]                         frame <- frame + 1L
[08:29:22.000]                         envir <- sys.frame(frame)
[08:29:22.000]                       }
[08:29:22.000]                     }
[08:29:22.000]                     sendCondition <<- function(cond) NULL
[08:29:22.000]                   }
[08:29:22.000]                 })
[08:29:22.000]                 withCallingHandlers({
[08:29:22.000]                   {
[08:29:22.000]                     2
[08:29:22.000]                   }
[08:29:22.000]                 }, immediateCondition = function(cond) {
[08:29:22.000]                   sendCondition <- ...future.makeSendCondition()
[08:29:22.000]                   sendCondition(cond)
[08:29:22.000]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.000]                   {
[08:29:22.000]                     inherits <- base::inherits
[08:29:22.000]                     invokeRestart <- base::invokeRestart
[08:29:22.000]                     is.null <- base::is.null
[08:29:22.000]                     muffled <- FALSE
[08:29:22.000]                     if (inherits(cond, "message")) {
[08:29:22.000]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:22.000]                       if (muffled) 
[08:29:22.000]                         invokeRestart("muffleMessage")
[08:29:22.000]                     }
[08:29:22.000]                     else if (inherits(cond, "warning")) {
[08:29:22.000]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:22.000]                       if (muffled) 
[08:29:22.000]                         invokeRestart("muffleWarning")
[08:29:22.000]                     }
[08:29:22.000]                     else if (inherits(cond, "condition")) {
[08:29:22.000]                       if (!is.null(pattern)) {
[08:29:22.000]                         computeRestarts <- base::computeRestarts
[08:29:22.000]                         grepl <- base::grepl
[08:29:22.000]                         restarts <- computeRestarts(cond)
[08:29:22.000]                         for (restart in restarts) {
[08:29:22.000]                           name <- restart$name
[08:29:22.000]                           if (is.null(name)) 
[08:29:22.000]                             next
[08:29:22.000]                           if (!grepl(pattern, name)) 
[08:29:22.000]                             next
[08:29:22.000]                           invokeRestart(restart)
[08:29:22.000]                           muffled <- TRUE
[08:29:22.000]                           break
[08:29:22.000]                         }
[08:29:22.000]                       }
[08:29:22.000]                     }
[08:29:22.000]                     invisible(muffled)
[08:29:22.000]                   }
[08:29:22.000]                   muffleCondition(cond)
[08:29:22.000]                 })
[08:29:22.000]             }))
[08:29:22.000]             future::FutureResult(value = ...future.value$value, 
[08:29:22.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:22.000]                   ...future.rng), globalenv = if (FALSE) 
[08:29:22.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:22.000]                     ...future.globalenv.names))
[08:29:22.000]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:22.000]         }, condition = base::local({
[08:29:22.000]             c <- base::c
[08:29:22.000]             inherits <- base::inherits
[08:29:22.000]             invokeRestart <- base::invokeRestart
[08:29:22.000]             length <- base::length
[08:29:22.000]             list <- base::list
[08:29:22.000]             seq.int <- base::seq.int
[08:29:22.000]             signalCondition <- base::signalCondition
[08:29:22.000]             sys.calls <- base::sys.calls
[08:29:22.000]             `[[` <- base::`[[`
[08:29:22.000]             `+` <- base::`+`
[08:29:22.000]             `<<-` <- base::`<<-`
[08:29:22.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:22.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:22.000]                   3L)]
[08:29:22.000]             }
[08:29:22.000]             function(cond) {
[08:29:22.000]                 is_error <- inherits(cond, "error")
[08:29:22.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:22.000]                   NULL)
[08:29:22.000]                 if (is_error) {
[08:29:22.000]                   sessionInformation <- function() {
[08:29:22.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:22.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:22.000]                       search = base::search(), system = base::Sys.info())
[08:29:22.000]                   }
[08:29:22.000]                   ...future.conditions[[length(...future.conditions) + 
[08:29:22.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:22.000]                     cond$call), session = sessionInformation(), 
[08:29:22.000]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:22.000]                   signalCondition(cond)
[08:29:22.000]                 }
[08:29:22.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:22.000]                 "immediateCondition"))) {
[08:29:22.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:22.000]                   ...future.conditions[[length(...future.conditions) + 
[08:29:22.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:22.000]                   if (TRUE && !signal) {
[08:29:22.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.000]                     {
[08:29:22.000]                       inherits <- base::inherits
[08:29:22.000]                       invokeRestart <- base::invokeRestart
[08:29:22.000]                       is.null <- base::is.null
[08:29:22.000]                       muffled <- FALSE
[08:29:22.000]                       if (inherits(cond, "message")) {
[08:29:22.000]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:22.000]                         if (muffled) 
[08:29:22.000]                           invokeRestart("muffleMessage")
[08:29:22.000]                       }
[08:29:22.000]                       else if (inherits(cond, "warning")) {
[08:29:22.000]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:22.000]                         if (muffled) 
[08:29:22.000]                           invokeRestart("muffleWarning")
[08:29:22.000]                       }
[08:29:22.000]                       else if (inherits(cond, "condition")) {
[08:29:22.000]                         if (!is.null(pattern)) {
[08:29:22.000]                           computeRestarts <- base::computeRestarts
[08:29:22.000]                           grepl <- base::grepl
[08:29:22.000]                           restarts <- computeRestarts(cond)
[08:29:22.000]                           for (restart in restarts) {
[08:29:22.000]                             name <- restart$name
[08:29:22.000]                             if (is.null(name)) 
[08:29:22.000]                               next
[08:29:22.000]                             if (!grepl(pattern, name)) 
[08:29:22.000]                               next
[08:29:22.000]                             invokeRestart(restart)
[08:29:22.000]                             muffled <- TRUE
[08:29:22.000]                             break
[08:29:22.000]                           }
[08:29:22.000]                         }
[08:29:22.000]                       }
[08:29:22.000]                       invisible(muffled)
[08:29:22.000]                     }
[08:29:22.000]                     muffleCondition(cond, pattern = "^muffle")
[08:29:22.000]                   }
[08:29:22.000]                 }
[08:29:22.000]                 else {
[08:29:22.000]                   if (TRUE) {
[08:29:22.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.000]                     {
[08:29:22.000]                       inherits <- base::inherits
[08:29:22.000]                       invokeRestart <- base::invokeRestart
[08:29:22.000]                       is.null <- base::is.null
[08:29:22.000]                       muffled <- FALSE
[08:29:22.000]                       if (inherits(cond, "message")) {
[08:29:22.000]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:22.000]                         if (muffled) 
[08:29:22.000]                           invokeRestart("muffleMessage")
[08:29:22.000]                       }
[08:29:22.000]                       else if (inherits(cond, "warning")) {
[08:29:22.000]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:22.000]                         if (muffled) 
[08:29:22.000]                           invokeRestart("muffleWarning")
[08:29:22.000]                       }
[08:29:22.000]                       else if (inherits(cond, "condition")) {
[08:29:22.000]                         if (!is.null(pattern)) {
[08:29:22.000]                           computeRestarts <- base::computeRestarts
[08:29:22.000]                           grepl <- base::grepl
[08:29:22.000]                           restarts <- computeRestarts(cond)
[08:29:22.000]                           for (restart in restarts) {
[08:29:22.000]                             name <- restart$name
[08:29:22.000]                             if (is.null(name)) 
[08:29:22.000]                               next
[08:29:22.000]                             if (!grepl(pattern, name)) 
[08:29:22.000]                               next
[08:29:22.000]                             invokeRestart(restart)
[08:29:22.000]                             muffled <- TRUE
[08:29:22.000]                             break
[08:29:22.000]                           }
[08:29:22.000]                         }
[08:29:22.000]                       }
[08:29:22.000]                       invisible(muffled)
[08:29:22.000]                     }
[08:29:22.000]                     muffleCondition(cond, pattern = "^muffle")
[08:29:22.000]                   }
[08:29:22.000]                 }
[08:29:22.000]             }
[08:29:22.000]         }))
[08:29:22.000]     }, error = function(ex) {
[08:29:22.000]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:22.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:22.000]                 ...future.rng), started = ...future.startTime, 
[08:29:22.000]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:22.000]             version = "1.8"), class = "FutureResult")
[08:29:22.000]     }, finally = {
[08:29:22.000]         if (!identical(...future.workdir, getwd())) 
[08:29:22.000]             setwd(...future.workdir)
[08:29:22.000]         {
[08:29:22.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:22.000]                 ...future.oldOptions$nwarnings <- NULL
[08:29:22.000]             }
[08:29:22.000]             base::options(...future.oldOptions)
[08:29:22.000]             if (.Platform$OS.type == "windows") {
[08:29:22.000]                 old_names <- names(...future.oldEnvVars)
[08:29:22.000]                 envs <- base::Sys.getenv()
[08:29:22.000]                 names <- names(envs)
[08:29:22.000]                 common <- intersect(names, old_names)
[08:29:22.000]                 added <- setdiff(names, old_names)
[08:29:22.000]                 removed <- setdiff(old_names, names)
[08:29:22.000]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:22.000]                   envs[common]]
[08:29:22.000]                 NAMES <- toupper(changed)
[08:29:22.000]                 args <- list()
[08:29:22.000]                 for (kk in seq_along(NAMES)) {
[08:29:22.000]                   name <- changed[[kk]]
[08:29:22.000]                   NAME <- NAMES[[kk]]
[08:29:22.000]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.000]                     next
[08:29:22.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:22.000]                 }
[08:29:22.000]                 NAMES <- toupper(added)
[08:29:22.000]                 for (kk in seq_along(NAMES)) {
[08:29:22.000]                   name <- added[[kk]]
[08:29:22.000]                   NAME <- NAMES[[kk]]
[08:29:22.000]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.000]                     next
[08:29:22.000]                   args[[name]] <- ""
[08:29:22.000]                 }
[08:29:22.000]                 NAMES <- toupper(removed)
[08:29:22.000]                 for (kk in seq_along(NAMES)) {
[08:29:22.000]                   name <- removed[[kk]]
[08:29:22.000]                   NAME <- NAMES[[kk]]
[08:29:22.000]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.000]                     next
[08:29:22.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:22.000]                 }
[08:29:22.000]                 if (length(args) > 0) 
[08:29:22.000]                   base::do.call(base::Sys.setenv, args = args)
[08:29:22.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:22.000]             }
[08:29:22.000]             else {
[08:29:22.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:22.000]             }
[08:29:22.000]             {
[08:29:22.000]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:22.000]                   0L) {
[08:29:22.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:22.000]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:22.000]                   base::options(opts)
[08:29:22.000]                 }
[08:29:22.000]                 {
[08:29:22.000]                   {
[08:29:22.000]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:22.000]                     NULL
[08:29:22.000]                   }
[08:29:22.000]                   options(future.plan = NULL)
[08:29:22.000]                   if (is.na(NA_character_)) 
[08:29:22.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:22.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:22.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:22.000]                     .init = FALSE)
[08:29:22.000]                 }
[08:29:22.000]             }
[08:29:22.000]         }
[08:29:22.000]     })
[08:29:22.000]     if (TRUE) {
[08:29:22.000]         base::sink(type = "output", split = FALSE)
[08:29:22.000]         if (TRUE) {
[08:29:22.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:22.000]         }
[08:29:22.000]         else {
[08:29:22.000]             ...future.result["stdout"] <- base::list(NULL)
[08:29:22.000]         }
[08:29:22.000]         base::close(...future.stdout)
[08:29:22.000]         ...future.stdout <- NULL
[08:29:22.000]     }
[08:29:22.000]     ...future.result$conditions <- ...future.conditions
[08:29:22.000]     ...future.result$finished <- base::Sys.time()
[08:29:22.000]     ...future.result
[08:29:22.000] }
[08:29:22.003] MultisessionFuture started
[08:29:22.003] - Launch lazy future ... done
[08:29:22.003] run() for ‘MultisessionFuture’ ... done
[08:29:22.003] resolve() on list environment ...
[08:29:22.003]  recursive: 0
[08:29:22.004]  length: 3
[08:29:22.004]  elements: ‘a’, ‘b’, ‘c’
[08:29:22.025]  length: 2 (resolved future 3)
[08:29:22.036] receiveMessageFromWorker() for ClusterFuture ...
[08:29:22.036] - Validating connection of MultisessionFuture
[08:29:22.036] - received message: FutureResult
[08:29:22.036] - Received FutureResult
[08:29:22.036] - Erased future from FutureRegistry
[08:29:22.036] result() for ClusterFuture ...
[08:29:22.036] - result already collected: FutureResult
[08:29:22.036] result() for ClusterFuture ... done
[08:29:22.037] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:22.037] Future #1
[08:29:22.037]  length: 1 (resolved future 1)
[08:29:22.045] receiveMessageFromWorker() for ClusterFuture ...
[08:29:22.045] - Validating connection of MultisessionFuture
[08:29:22.045] - received message: FutureResult
[08:29:22.045] - Received FutureResult
[08:29:22.045] - Erased future from FutureRegistry
[08:29:22.046] result() for ClusterFuture ...
[08:29:22.046] - result already collected: FutureResult
[08:29:22.046] result() for ClusterFuture ... done
[08:29:22.046] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:22.046] Future #2
[08:29:22.046]  length: 0 (resolved future 2)
[08:29:22.046] resolve() on list environment ... DONE
[08:29:22.047] getGlobalsAndPackages() ...
[08:29:22.047] Searching for globals...
[08:29:22.047] - globals found: [1] ‘{’
[08:29:22.047] Searching for globals ... DONE
[08:29:22.047] Resolving globals: FALSE
[08:29:22.048] 
[08:29:22.048] 
[08:29:22.048] getGlobalsAndPackages() ... DONE
[08:29:22.048] run() for ‘Future’ ...
[08:29:22.048] - state: ‘created’
[08:29:22.048] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:22.062] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:22.062] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:22.062]   - Field: ‘node’
[08:29:22.063]   - Field: ‘label’
[08:29:22.063]   - Field: ‘local’
[08:29:22.063]   - Field: ‘owner’
[08:29:22.063]   - Field: ‘envir’
[08:29:22.063]   - Field: ‘workers’
[08:29:22.063]   - Field: ‘packages’
[08:29:22.063]   - Field: ‘gc’
[08:29:22.063]   - Field: ‘conditions’
[08:29:22.063]   - Field: ‘persistent’
[08:29:22.063]   - Field: ‘expr’
[08:29:22.063]   - Field: ‘uuid’
[08:29:22.064]   - Field: ‘seed’
[08:29:22.064]   - Field: ‘version’
[08:29:22.064]   - Field: ‘result’
[08:29:22.064]   - Field: ‘asynchronous’
[08:29:22.064]   - Field: ‘calls’
[08:29:22.064]   - Field: ‘globals’
[08:29:22.064]   - Field: ‘stdout’
[08:29:22.064]   - Field: ‘earlySignal’
[08:29:22.064]   - Field: ‘lazy’
[08:29:22.064]   - Field: ‘state’
[08:29:22.064] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:22.064] - Launch lazy future ...
[08:29:22.065] Packages needed by the future expression (n = 0): <none>
[08:29:22.065] Packages needed by future strategies (n = 0): <none>
[08:29:22.065] {
[08:29:22.065]     {
[08:29:22.065]         {
[08:29:22.065]             ...future.startTime <- base::Sys.time()
[08:29:22.065]             {
[08:29:22.065]                 {
[08:29:22.065]                   {
[08:29:22.065]                     {
[08:29:22.065]                       base::local({
[08:29:22.065]                         has_future <- base::requireNamespace("future", 
[08:29:22.065]                           quietly = TRUE)
[08:29:22.065]                         if (has_future) {
[08:29:22.065]                           ns <- base::getNamespace("future")
[08:29:22.065]                           version <- ns[[".package"]][["version"]]
[08:29:22.065]                           if (is.null(version)) 
[08:29:22.065]                             version <- utils::packageVersion("future")
[08:29:22.065]                         }
[08:29:22.065]                         else {
[08:29:22.065]                           version <- NULL
[08:29:22.065]                         }
[08:29:22.065]                         if (!has_future || version < "1.8.0") {
[08:29:22.065]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:22.065]                             "", base::R.version$version.string), 
[08:29:22.065]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:22.065]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:22.065]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:22.065]                               "release", "version")], collapse = " "), 
[08:29:22.065]                             hostname = base::Sys.info()[["nodename"]])
[08:29:22.065]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:22.065]                             info)
[08:29:22.065]                           info <- base::paste(info, collapse = "; ")
[08:29:22.065]                           if (!has_future) {
[08:29:22.065]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:22.065]                               info)
[08:29:22.065]                           }
[08:29:22.065]                           else {
[08:29:22.065]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:22.065]                               info, version)
[08:29:22.065]                           }
[08:29:22.065]                           base::stop(msg)
[08:29:22.065]                         }
[08:29:22.065]                       })
[08:29:22.065]                     }
[08:29:22.065]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:22.065]                     base::options(mc.cores = 1L)
[08:29:22.065]                   }
[08:29:22.065]                   ...future.strategy.old <- future::plan("list")
[08:29:22.065]                   options(future.plan = NULL)
[08:29:22.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:22.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:22.065]                 }
[08:29:22.065]                 ...future.workdir <- getwd()
[08:29:22.065]             }
[08:29:22.065]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:22.065]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:22.065]         }
[08:29:22.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:22.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:22.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:22.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:22.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:22.065]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:22.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:22.065]             base::names(...future.oldOptions))
[08:29:22.065]     }
[08:29:22.065]     if (FALSE) {
[08:29:22.065]     }
[08:29:22.065]     else {
[08:29:22.065]         if (TRUE) {
[08:29:22.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:22.065]                 open = "w")
[08:29:22.065]         }
[08:29:22.065]         else {
[08:29:22.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:22.065]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:22.065]         }
[08:29:22.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:22.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:22.065]             base::sink(type = "output", split = FALSE)
[08:29:22.065]             base::close(...future.stdout)
[08:29:22.065]         }, add = TRUE)
[08:29:22.065]     }
[08:29:22.065]     ...future.frame <- base::sys.nframe()
[08:29:22.065]     ...future.conditions <- base::list()
[08:29:22.065]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:22.065]     if (FALSE) {
[08:29:22.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:22.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:22.065]     }
[08:29:22.065]     ...future.result <- base::tryCatch({
[08:29:22.065]         base::withCallingHandlers({
[08:29:22.065]             ...future.value <- base::withVisible(base::local({
[08:29:22.065]                 ...future.makeSendCondition <- base::local({
[08:29:22.065]                   sendCondition <- NULL
[08:29:22.065]                   function(frame = 1L) {
[08:29:22.065]                     if (is.function(sendCondition)) 
[08:29:22.065]                       return(sendCondition)
[08:29:22.065]                     ns <- getNamespace("parallel")
[08:29:22.065]                     if (exists("sendData", mode = "function", 
[08:29:22.065]                       envir = ns)) {
[08:29:22.065]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:22.065]                         envir = ns)
[08:29:22.065]                       envir <- sys.frame(frame)
[08:29:22.065]                       master <- NULL
[08:29:22.065]                       while (!identical(envir, .GlobalEnv) && 
[08:29:22.065]                         !identical(envir, emptyenv())) {
[08:29:22.065]                         if (exists("master", mode = "list", envir = envir, 
[08:29:22.065]                           inherits = FALSE)) {
[08:29:22.065]                           master <- get("master", mode = "list", 
[08:29:22.065]                             envir = envir, inherits = FALSE)
[08:29:22.065]                           if (inherits(master, c("SOCKnode", 
[08:29:22.065]                             "SOCK0node"))) {
[08:29:22.065]                             sendCondition <<- function(cond) {
[08:29:22.065]                               data <- list(type = "VALUE", value = cond, 
[08:29:22.065]                                 success = TRUE)
[08:29:22.065]                               parallel_sendData(master, data)
[08:29:22.065]                             }
[08:29:22.065]                             return(sendCondition)
[08:29:22.065]                           }
[08:29:22.065]                         }
[08:29:22.065]                         frame <- frame + 1L
[08:29:22.065]                         envir <- sys.frame(frame)
[08:29:22.065]                       }
[08:29:22.065]                     }
[08:29:22.065]                     sendCondition <<- function(cond) NULL
[08:29:22.065]                   }
[08:29:22.065]                 })
[08:29:22.065]                 withCallingHandlers({
[08:29:22.065]                   {
[08:29:22.065]                     1
[08:29:22.065]                   }
[08:29:22.065]                 }, immediateCondition = function(cond) {
[08:29:22.065]                   sendCondition <- ...future.makeSendCondition()
[08:29:22.065]                   sendCondition(cond)
[08:29:22.065]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.065]                   {
[08:29:22.065]                     inherits <- base::inherits
[08:29:22.065]                     invokeRestart <- base::invokeRestart
[08:29:22.065]                     is.null <- base::is.null
[08:29:22.065]                     muffled <- FALSE
[08:29:22.065]                     if (inherits(cond, "message")) {
[08:29:22.065]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:22.065]                       if (muffled) 
[08:29:22.065]                         invokeRestart("muffleMessage")
[08:29:22.065]                     }
[08:29:22.065]                     else if (inherits(cond, "warning")) {
[08:29:22.065]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:22.065]                       if (muffled) 
[08:29:22.065]                         invokeRestart("muffleWarning")
[08:29:22.065]                     }
[08:29:22.065]                     else if (inherits(cond, "condition")) {
[08:29:22.065]                       if (!is.null(pattern)) {
[08:29:22.065]                         computeRestarts <- base::computeRestarts
[08:29:22.065]                         grepl <- base::grepl
[08:29:22.065]                         restarts <- computeRestarts(cond)
[08:29:22.065]                         for (restart in restarts) {
[08:29:22.065]                           name <- restart$name
[08:29:22.065]                           if (is.null(name)) 
[08:29:22.065]                             next
[08:29:22.065]                           if (!grepl(pattern, name)) 
[08:29:22.065]                             next
[08:29:22.065]                           invokeRestart(restart)
[08:29:22.065]                           muffled <- TRUE
[08:29:22.065]                           break
[08:29:22.065]                         }
[08:29:22.065]                       }
[08:29:22.065]                     }
[08:29:22.065]                     invisible(muffled)
[08:29:22.065]                   }
[08:29:22.065]                   muffleCondition(cond)
[08:29:22.065]                 })
[08:29:22.065]             }))
[08:29:22.065]             future::FutureResult(value = ...future.value$value, 
[08:29:22.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:22.065]                   ...future.rng), globalenv = if (FALSE) 
[08:29:22.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:22.065]                     ...future.globalenv.names))
[08:29:22.065]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:22.065]         }, condition = base::local({
[08:29:22.065]             c <- base::c
[08:29:22.065]             inherits <- base::inherits
[08:29:22.065]             invokeRestart <- base::invokeRestart
[08:29:22.065]             length <- base::length
[08:29:22.065]             list <- base::list
[08:29:22.065]             seq.int <- base::seq.int
[08:29:22.065]             signalCondition <- base::signalCondition
[08:29:22.065]             sys.calls <- base::sys.calls
[08:29:22.065]             `[[` <- base::`[[`
[08:29:22.065]             `+` <- base::`+`
[08:29:22.065]             `<<-` <- base::`<<-`
[08:29:22.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:22.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:22.065]                   3L)]
[08:29:22.065]             }
[08:29:22.065]             function(cond) {
[08:29:22.065]                 is_error <- inherits(cond, "error")
[08:29:22.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:22.065]                   NULL)
[08:29:22.065]                 if (is_error) {
[08:29:22.065]                   sessionInformation <- function() {
[08:29:22.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:22.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:22.065]                       search = base::search(), system = base::Sys.info())
[08:29:22.065]                   }
[08:29:22.065]                   ...future.conditions[[length(...future.conditions) + 
[08:29:22.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:22.065]                     cond$call), session = sessionInformation(), 
[08:29:22.065]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:22.065]                   signalCondition(cond)
[08:29:22.065]                 }
[08:29:22.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:22.065]                 "immediateCondition"))) {
[08:29:22.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:22.065]                   ...future.conditions[[length(...future.conditions) + 
[08:29:22.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:22.065]                   if (TRUE && !signal) {
[08:29:22.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.065]                     {
[08:29:22.065]                       inherits <- base::inherits
[08:29:22.065]                       invokeRestart <- base::invokeRestart
[08:29:22.065]                       is.null <- base::is.null
[08:29:22.065]                       muffled <- FALSE
[08:29:22.065]                       if (inherits(cond, "message")) {
[08:29:22.065]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:22.065]                         if (muffled) 
[08:29:22.065]                           invokeRestart("muffleMessage")
[08:29:22.065]                       }
[08:29:22.065]                       else if (inherits(cond, "warning")) {
[08:29:22.065]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:22.065]                         if (muffled) 
[08:29:22.065]                           invokeRestart("muffleWarning")
[08:29:22.065]                       }
[08:29:22.065]                       else if (inherits(cond, "condition")) {
[08:29:22.065]                         if (!is.null(pattern)) {
[08:29:22.065]                           computeRestarts <- base::computeRestarts
[08:29:22.065]                           grepl <- base::grepl
[08:29:22.065]                           restarts <- computeRestarts(cond)
[08:29:22.065]                           for (restart in restarts) {
[08:29:22.065]                             name <- restart$name
[08:29:22.065]                             if (is.null(name)) 
[08:29:22.065]                               next
[08:29:22.065]                             if (!grepl(pattern, name)) 
[08:29:22.065]                               next
[08:29:22.065]                             invokeRestart(restart)
[08:29:22.065]                             muffled <- TRUE
[08:29:22.065]                             break
[08:29:22.065]                           }
[08:29:22.065]                         }
[08:29:22.065]                       }
[08:29:22.065]                       invisible(muffled)
[08:29:22.065]                     }
[08:29:22.065]                     muffleCondition(cond, pattern = "^muffle")
[08:29:22.065]                   }
[08:29:22.065]                 }
[08:29:22.065]                 else {
[08:29:22.065]                   if (TRUE) {
[08:29:22.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.065]                     {
[08:29:22.065]                       inherits <- base::inherits
[08:29:22.065]                       invokeRestart <- base::invokeRestart
[08:29:22.065]                       is.null <- base::is.null
[08:29:22.065]                       muffled <- FALSE
[08:29:22.065]                       if (inherits(cond, "message")) {
[08:29:22.065]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:22.065]                         if (muffled) 
[08:29:22.065]                           invokeRestart("muffleMessage")
[08:29:22.065]                       }
[08:29:22.065]                       else if (inherits(cond, "warning")) {
[08:29:22.065]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:22.065]                         if (muffled) 
[08:29:22.065]                           invokeRestart("muffleWarning")
[08:29:22.065]                       }
[08:29:22.065]                       else if (inherits(cond, "condition")) {
[08:29:22.065]                         if (!is.null(pattern)) {
[08:29:22.065]                           computeRestarts <- base::computeRestarts
[08:29:22.065]                           grepl <- base::grepl
[08:29:22.065]                           restarts <- computeRestarts(cond)
[08:29:22.065]                           for (restart in restarts) {
[08:29:22.065]                             name <- restart$name
[08:29:22.065]                             if (is.null(name)) 
[08:29:22.065]                               next
[08:29:22.065]                             if (!grepl(pattern, name)) 
[08:29:22.065]                               next
[08:29:22.065]                             invokeRestart(restart)
[08:29:22.065]                             muffled <- TRUE
[08:29:22.065]                             break
[08:29:22.065]                           }
[08:29:22.065]                         }
[08:29:22.065]                       }
[08:29:22.065]                       invisible(muffled)
[08:29:22.065]                     }
[08:29:22.065]                     muffleCondition(cond, pattern = "^muffle")
[08:29:22.065]                   }
[08:29:22.065]                 }
[08:29:22.065]             }
[08:29:22.065]         }))
[08:29:22.065]     }, error = function(ex) {
[08:29:22.065]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:22.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:22.065]                 ...future.rng), started = ...future.startTime, 
[08:29:22.065]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:22.065]             version = "1.8"), class = "FutureResult")
[08:29:22.065]     }, finally = {
[08:29:22.065]         if (!identical(...future.workdir, getwd())) 
[08:29:22.065]             setwd(...future.workdir)
[08:29:22.065]         {
[08:29:22.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:22.065]                 ...future.oldOptions$nwarnings <- NULL
[08:29:22.065]             }
[08:29:22.065]             base::options(...future.oldOptions)
[08:29:22.065]             if (.Platform$OS.type == "windows") {
[08:29:22.065]                 old_names <- names(...future.oldEnvVars)
[08:29:22.065]                 envs <- base::Sys.getenv()
[08:29:22.065]                 names <- names(envs)
[08:29:22.065]                 common <- intersect(names, old_names)
[08:29:22.065]                 added <- setdiff(names, old_names)
[08:29:22.065]                 removed <- setdiff(old_names, names)
[08:29:22.065]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:22.065]                   envs[common]]
[08:29:22.065]                 NAMES <- toupper(changed)
[08:29:22.065]                 args <- list()
[08:29:22.065]                 for (kk in seq_along(NAMES)) {
[08:29:22.065]                   name <- changed[[kk]]
[08:29:22.065]                   NAME <- NAMES[[kk]]
[08:29:22.065]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.065]                     next
[08:29:22.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:22.065]                 }
[08:29:22.065]                 NAMES <- toupper(added)
[08:29:22.065]                 for (kk in seq_along(NAMES)) {
[08:29:22.065]                   name <- added[[kk]]
[08:29:22.065]                   NAME <- NAMES[[kk]]
[08:29:22.065]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.065]                     next
[08:29:22.065]                   args[[name]] <- ""
[08:29:22.065]                 }
[08:29:22.065]                 NAMES <- toupper(removed)
[08:29:22.065]                 for (kk in seq_along(NAMES)) {
[08:29:22.065]                   name <- removed[[kk]]
[08:29:22.065]                   NAME <- NAMES[[kk]]
[08:29:22.065]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.065]                     next
[08:29:22.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:22.065]                 }
[08:29:22.065]                 if (length(args) > 0) 
[08:29:22.065]                   base::do.call(base::Sys.setenv, args = args)
[08:29:22.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:22.065]             }
[08:29:22.065]             else {
[08:29:22.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:22.065]             }
[08:29:22.065]             {
[08:29:22.065]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:22.065]                   0L) {
[08:29:22.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:22.065]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:22.065]                   base::options(opts)
[08:29:22.065]                 }
[08:29:22.065]                 {
[08:29:22.065]                   {
[08:29:22.065]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:22.065]                     NULL
[08:29:22.065]                   }
[08:29:22.065]                   options(future.plan = NULL)
[08:29:22.065]                   if (is.na(NA_character_)) 
[08:29:22.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:22.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:22.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:22.065]                     .init = FALSE)
[08:29:22.065]                 }
[08:29:22.065]             }
[08:29:22.065]         }
[08:29:22.065]     })
[08:29:22.065]     if (TRUE) {
[08:29:22.065]         base::sink(type = "output", split = FALSE)
[08:29:22.065]         if (TRUE) {
[08:29:22.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:22.065]         }
[08:29:22.065]         else {
[08:29:22.065]             ...future.result["stdout"] <- base::list(NULL)
[08:29:22.065]         }
[08:29:22.065]         base::close(...future.stdout)
[08:29:22.065]         ...future.stdout <- NULL
[08:29:22.065]     }
[08:29:22.065]     ...future.result$conditions <- ...future.conditions
[08:29:22.065]     ...future.result$finished <- base::Sys.time()
[08:29:22.065]     ...future.result
[08:29:22.065] }
[08:29:22.068] MultisessionFuture started
[08:29:22.068] - Launch lazy future ... done
[08:29:22.068] run() for ‘MultisessionFuture’ ... done
[08:29:22.069] getGlobalsAndPackages() ...
[08:29:22.069] Searching for globals...
[08:29:22.070] - globals found: [2] ‘{’, ‘Sys.sleep’
[08:29:22.070] Searching for globals ... DONE
[08:29:22.070] Resolving globals: FALSE
[08:29:22.070] 
[08:29:22.071] 
[08:29:22.071] getGlobalsAndPackages() ... DONE
[08:29:22.071] run() for ‘Future’ ...
[08:29:22.071] - state: ‘created’
[08:29:22.071] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:22.090] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:22.090] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:22.091]   - Field: ‘node’
[08:29:22.091]   - Field: ‘label’
[08:29:22.091]   - Field: ‘local’
[08:29:22.091]   - Field: ‘owner’
[08:29:22.091]   - Field: ‘envir’
[08:29:22.091]   - Field: ‘workers’
[08:29:22.091]   - Field: ‘packages’
[08:29:22.091]   - Field: ‘gc’
[08:29:22.091]   - Field: ‘conditions’
[08:29:22.091]   - Field: ‘persistent’
[08:29:22.092]   - Field: ‘expr’
[08:29:22.092]   - Field: ‘uuid’
[08:29:22.092]   - Field: ‘seed’
[08:29:22.092]   - Field: ‘version’
[08:29:22.092]   - Field: ‘result’
[08:29:22.092]   - Field: ‘asynchronous’
[08:29:22.092]   - Field: ‘calls’
[08:29:22.092]   - Field: ‘globals’
[08:29:22.092]   - Field: ‘stdout’
[08:29:22.092]   - Field: ‘earlySignal’
[08:29:22.092]   - Field: ‘lazy’
[08:29:22.092]   - Field: ‘state’
[08:29:22.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:22.093] - Launch lazy future ...
[08:29:22.093] Packages needed by the future expression (n = 0): <none>
[08:29:22.093] Packages needed by future strategies (n = 0): <none>
[08:29:22.093] {
[08:29:22.093]     {
[08:29:22.093]         {
[08:29:22.093]             ...future.startTime <- base::Sys.time()
[08:29:22.093]             {
[08:29:22.093]                 {
[08:29:22.093]                   {
[08:29:22.093]                     {
[08:29:22.093]                       base::local({
[08:29:22.093]                         has_future <- base::requireNamespace("future", 
[08:29:22.093]                           quietly = TRUE)
[08:29:22.093]                         if (has_future) {
[08:29:22.093]                           ns <- base::getNamespace("future")
[08:29:22.093]                           version <- ns[[".package"]][["version"]]
[08:29:22.093]                           if (is.null(version)) 
[08:29:22.093]                             version <- utils::packageVersion("future")
[08:29:22.093]                         }
[08:29:22.093]                         else {
[08:29:22.093]                           version <- NULL
[08:29:22.093]                         }
[08:29:22.093]                         if (!has_future || version < "1.8.0") {
[08:29:22.093]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:22.093]                             "", base::R.version$version.string), 
[08:29:22.093]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:22.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:22.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:22.093]                               "release", "version")], collapse = " "), 
[08:29:22.093]                             hostname = base::Sys.info()[["nodename"]])
[08:29:22.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:22.093]                             info)
[08:29:22.093]                           info <- base::paste(info, collapse = "; ")
[08:29:22.093]                           if (!has_future) {
[08:29:22.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:22.093]                               info)
[08:29:22.093]                           }
[08:29:22.093]                           else {
[08:29:22.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:22.093]                               info, version)
[08:29:22.093]                           }
[08:29:22.093]                           base::stop(msg)
[08:29:22.093]                         }
[08:29:22.093]                       })
[08:29:22.093]                     }
[08:29:22.093]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:22.093]                     base::options(mc.cores = 1L)
[08:29:22.093]                   }
[08:29:22.093]                   ...future.strategy.old <- future::plan("list")
[08:29:22.093]                   options(future.plan = NULL)
[08:29:22.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:22.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:22.093]                 }
[08:29:22.093]                 ...future.workdir <- getwd()
[08:29:22.093]             }
[08:29:22.093]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:22.093]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:22.093]         }
[08:29:22.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:22.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:22.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:22.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:22.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:22.093]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:22.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:22.093]             base::names(...future.oldOptions))
[08:29:22.093]     }
[08:29:22.093]     if (FALSE) {
[08:29:22.093]     }
[08:29:22.093]     else {
[08:29:22.093]         if (TRUE) {
[08:29:22.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:22.093]                 open = "w")
[08:29:22.093]         }
[08:29:22.093]         else {
[08:29:22.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:22.093]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:22.093]         }
[08:29:22.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:22.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:22.093]             base::sink(type = "output", split = FALSE)
[08:29:22.093]             base::close(...future.stdout)
[08:29:22.093]         }, add = TRUE)
[08:29:22.093]     }
[08:29:22.093]     ...future.frame <- base::sys.nframe()
[08:29:22.093]     ...future.conditions <- base::list()
[08:29:22.093]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:22.093]     if (FALSE) {
[08:29:22.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:22.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:22.093]     }
[08:29:22.093]     ...future.result <- base::tryCatch({
[08:29:22.093]         base::withCallingHandlers({
[08:29:22.093]             ...future.value <- base::withVisible(base::local({
[08:29:22.093]                 ...future.makeSendCondition <- base::local({
[08:29:22.093]                   sendCondition <- NULL
[08:29:22.093]                   function(frame = 1L) {
[08:29:22.093]                     if (is.function(sendCondition)) 
[08:29:22.093]                       return(sendCondition)
[08:29:22.093]                     ns <- getNamespace("parallel")
[08:29:22.093]                     if (exists("sendData", mode = "function", 
[08:29:22.093]                       envir = ns)) {
[08:29:22.093]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:22.093]                         envir = ns)
[08:29:22.093]                       envir <- sys.frame(frame)
[08:29:22.093]                       master <- NULL
[08:29:22.093]                       while (!identical(envir, .GlobalEnv) && 
[08:29:22.093]                         !identical(envir, emptyenv())) {
[08:29:22.093]                         if (exists("master", mode = "list", envir = envir, 
[08:29:22.093]                           inherits = FALSE)) {
[08:29:22.093]                           master <- get("master", mode = "list", 
[08:29:22.093]                             envir = envir, inherits = FALSE)
[08:29:22.093]                           if (inherits(master, c("SOCKnode", 
[08:29:22.093]                             "SOCK0node"))) {
[08:29:22.093]                             sendCondition <<- function(cond) {
[08:29:22.093]                               data <- list(type = "VALUE", value = cond, 
[08:29:22.093]                                 success = TRUE)
[08:29:22.093]                               parallel_sendData(master, data)
[08:29:22.093]                             }
[08:29:22.093]                             return(sendCondition)
[08:29:22.093]                           }
[08:29:22.093]                         }
[08:29:22.093]                         frame <- frame + 1L
[08:29:22.093]                         envir <- sys.frame(frame)
[08:29:22.093]                       }
[08:29:22.093]                     }
[08:29:22.093]                     sendCondition <<- function(cond) NULL
[08:29:22.093]                   }
[08:29:22.093]                 })
[08:29:22.093]                 withCallingHandlers({
[08:29:22.093]                   {
[08:29:22.093]                     Sys.sleep(0.5)
[08:29:22.093]                     2
[08:29:22.093]                   }
[08:29:22.093]                 }, immediateCondition = function(cond) {
[08:29:22.093]                   sendCondition <- ...future.makeSendCondition()
[08:29:22.093]                   sendCondition(cond)
[08:29:22.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.093]                   {
[08:29:22.093]                     inherits <- base::inherits
[08:29:22.093]                     invokeRestart <- base::invokeRestart
[08:29:22.093]                     is.null <- base::is.null
[08:29:22.093]                     muffled <- FALSE
[08:29:22.093]                     if (inherits(cond, "message")) {
[08:29:22.093]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:22.093]                       if (muffled) 
[08:29:22.093]                         invokeRestart("muffleMessage")
[08:29:22.093]                     }
[08:29:22.093]                     else if (inherits(cond, "warning")) {
[08:29:22.093]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:22.093]                       if (muffled) 
[08:29:22.093]                         invokeRestart("muffleWarning")
[08:29:22.093]                     }
[08:29:22.093]                     else if (inherits(cond, "condition")) {
[08:29:22.093]                       if (!is.null(pattern)) {
[08:29:22.093]                         computeRestarts <- base::computeRestarts
[08:29:22.093]                         grepl <- base::grepl
[08:29:22.093]                         restarts <- computeRestarts(cond)
[08:29:22.093]                         for (restart in restarts) {
[08:29:22.093]                           name <- restart$name
[08:29:22.093]                           if (is.null(name)) 
[08:29:22.093]                             next
[08:29:22.093]                           if (!grepl(pattern, name)) 
[08:29:22.093]                             next
[08:29:22.093]                           invokeRestart(restart)
[08:29:22.093]                           muffled <- TRUE
[08:29:22.093]                           break
[08:29:22.093]                         }
[08:29:22.093]                       }
[08:29:22.093]                     }
[08:29:22.093]                     invisible(muffled)
[08:29:22.093]                   }
[08:29:22.093]                   muffleCondition(cond)
[08:29:22.093]                 })
[08:29:22.093]             }))
[08:29:22.093]             future::FutureResult(value = ...future.value$value, 
[08:29:22.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:22.093]                   ...future.rng), globalenv = if (FALSE) 
[08:29:22.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:22.093]                     ...future.globalenv.names))
[08:29:22.093]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:22.093]         }, condition = base::local({
[08:29:22.093]             c <- base::c
[08:29:22.093]             inherits <- base::inherits
[08:29:22.093]             invokeRestart <- base::invokeRestart
[08:29:22.093]             length <- base::length
[08:29:22.093]             list <- base::list
[08:29:22.093]             seq.int <- base::seq.int
[08:29:22.093]             signalCondition <- base::signalCondition
[08:29:22.093]             sys.calls <- base::sys.calls
[08:29:22.093]             `[[` <- base::`[[`
[08:29:22.093]             `+` <- base::`+`
[08:29:22.093]             `<<-` <- base::`<<-`
[08:29:22.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:22.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:22.093]                   3L)]
[08:29:22.093]             }
[08:29:22.093]             function(cond) {
[08:29:22.093]                 is_error <- inherits(cond, "error")
[08:29:22.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:22.093]                   NULL)
[08:29:22.093]                 if (is_error) {
[08:29:22.093]                   sessionInformation <- function() {
[08:29:22.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:22.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:22.093]                       search = base::search(), system = base::Sys.info())
[08:29:22.093]                   }
[08:29:22.093]                   ...future.conditions[[length(...future.conditions) + 
[08:29:22.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:22.093]                     cond$call), session = sessionInformation(), 
[08:29:22.093]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:22.093]                   signalCondition(cond)
[08:29:22.093]                 }
[08:29:22.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:22.093]                 "immediateCondition"))) {
[08:29:22.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:22.093]                   ...future.conditions[[length(...future.conditions) + 
[08:29:22.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:22.093]                   if (TRUE && !signal) {
[08:29:22.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.093]                     {
[08:29:22.093]                       inherits <- base::inherits
[08:29:22.093]                       invokeRestart <- base::invokeRestart
[08:29:22.093]                       is.null <- base::is.null
[08:29:22.093]                       muffled <- FALSE
[08:29:22.093]                       if (inherits(cond, "message")) {
[08:29:22.093]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:22.093]                         if (muffled) 
[08:29:22.093]                           invokeRestart("muffleMessage")
[08:29:22.093]                       }
[08:29:22.093]                       else if (inherits(cond, "warning")) {
[08:29:22.093]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:22.093]                         if (muffled) 
[08:29:22.093]                           invokeRestart("muffleWarning")
[08:29:22.093]                       }
[08:29:22.093]                       else if (inherits(cond, "condition")) {
[08:29:22.093]                         if (!is.null(pattern)) {
[08:29:22.093]                           computeRestarts <- base::computeRestarts
[08:29:22.093]                           grepl <- base::grepl
[08:29:22.093]                           restarts <- computeRestarts(cond)
[08:29:22.093]                           for (restart in restarts) {
[08:29:22.093]                             name <- restart$name
[08:29:22.093]                             if (is.null(name)) 
[08:29:22.093]                               next
[08:29:22.093]                             if (!grepl(pattern, name)) 
[08:29:22.093]                               next
[08:29:22.093]                             invokeRestart(restart)
[08:29:22.093]                             muffled <- TRUE
[08:29:22.093]                             break
[08:29:22.093]                           }
[08:29:22.093]                         }
[08:29:22.093]                       }
[08:29:22.093]                       invisible(muffled)
[08:29:22.093]                     }
[08:29:22.093]                     muffleCondition(cond, pattern = "^muffle")
[08:29:22.093]                   }
[08:29:22.093]                 }
[08:29:22.093]                 else {
[08:29:22.093]                   if (TRUE) {
[08:29:22.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.093]                     {
[08:29:22.093]                       inherits <- base::inherits
[08:29:22.093]                       invokeRestart <- base::invokeRestart
[08:29:22.093]                       is.null <- base::is.null
[08:29:22.093]                       muffled <- FALSE
[08:29:22.093]                       if (inherits(cond, "message")) {
[08:29:22.093]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:22.093]                         if (muffled) 
[08:29:22.093]                           invokeRestart("muffleMessage")
[08:29:22.093]                       }
[08:29:22.093]                       else if (inherits(cond, "warning")) {
[08:29:22.093]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:22.093]                         if (muffled) 
[08:29:22.093]                           invokeRestart("muffleWarning")
[08:29:22.093]                       }
[08:29:22.093]                       else if (inherits(cond, "condition")) {
[08:29:22.093]                         if (!is.null(pattern)) {
[08:29:22.093]                           computeRestarts <- base::computeRestarts
[08:29:22.093]                           grepl <- base::grepl
[08:29:22.093]                           restarts <- computeRestarts(cond)
[08:29:22.093]                           for (restart in restarts) {
[08:29:22.093]                             name <- restart$name
[08:29:22.093]                             if (is.null(name)) 
[08:29:22.093]                               next
[08:29:22.093]                             if (!grepl(pattern, name)) 
[08:29:22.093]                               next
[08:29:22.093]                             invokeRestart(restart)
[08:29:22.093]                             muffled <- TRUE
[08:29:22.093]                             break
[08:29:22.093]                           }
[08:29:22.093]                         }
[08:29:22.093]                       }
[08:29:22.093]                       invisible(muffled)
[08:29:22.093]                     }
[08:29:22.093]                     muffleCondition(cond, pattern = "^muffle")
[08:29:22.093]                   }
[08:29:22.093]                 }
[08:29:22.093]             }
[08:29:22.093]         }))
[08:29:22.093]     }, error = function(ex) {
[08:29:22.093]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:22.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:22.093]                 ...future.rng), started = ...future.startTime, 
[08:29:22.093]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:22.093]             version = "1.8"), class = "FutureResult")
[08:29:22.093]     }, finally = {
[08:29:22.093]         if (!identical(...future.workdir, getwd())) 
[08:29:22.093]             setwd(...future.workdir)
[08:29:22.093]         {
[08:29:22.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:22.093]                 ...future.oldOptions$nwarnings <- NULL
[08:29:22.093]             }
[08:29:22.093]             base::options(...future.oldOptions)
[08:29:22.093]             if (.Platform$OS.type == "windows") {
[08:29:22.093]                 old_names <- names(...future.oldEnvVars)
[08:29:22.093]                 envs <- base::Sys.getenv()
[08:29:22.093]                 names <- names(envs)
[08:29:22.093]                 common <- intersect(names, old_names)
[08:29:22.093]                 added <- setdiff(names, old_names)
[08:29:22.093]                 removed <- setdiff(old_names, names)
[08:29:22.093]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:22.093]                   envs[common]]
[08:29:22.093]                 NAMES <- toupper(changed)
[08:29:22.093]                 args <- list()
[08:29:22.093]                 for (kk in seq_along(NAMES)) {
[08:29:22.093]                   name <- changed[[kk]]
[08:29:22.093]                   NAME <- NAMES[[kk]]
[08:29:22.093]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.093]                     next
[08:29:22.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:22.093]                 }
[08:29:22.093]                 NAMES <- toupper(added)
[08:29:22.093]                 for (kk in seq_along(NAMES)) {
[08:29:22.093]                   name <- added[[kk]]
[08:29:22.093]                   NAME <- NAMES[[kk]]
[08:29:22.093]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.093]                     next
[08:29:22.093]                   args[[name]] <- ""
[08:29:22.093]                 }
[08:29:22.093]                 NAMES <- toupper(removed)
[08:29:22.093]                 for (kk in seq_along(NAMES)) {
[08:29:22.093]                   name <- removed[[kk]]
[08:29:22.093]                   NAME <- NAMES[[kk]]
[08:29:22.093]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.093]                     next
[08:29:22.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:22.093]                 }
[08:29:22.093]                 if (length(args) > 0) 
[08:29:22.093]                   base::do.call(base::Sys.setenv, args = args)
[08:29:22.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:22.093]             }
[08:29:22.093]             else {
[08:29:22.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:22.093]             }
[08:29:22.093]             {
[08:29:22.093]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:22.093]                   0L) {
[08:29:22.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:22.093]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:22.093]                   base::options(opts)
[08:29:22.093]                 }
[08:29:22.093]                 {
[08:29:22.093]                   {
[08:29:22.093]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:22.093]                     NULL
[08:29:22.093]                   }
[08:29:22.093]                   options(future.plan = NULL)
[08:29:22.093]                   if (is.na(NA_character_)) 
[08:29:22.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:22.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:22.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:22.093]                     .init = FALSE)
[08:29:22.093]                 }
[08:29:22.093]             }
[08:29:22.093]         }
[08:29:22.093]     })
[08:29:22.093]     if (TRUE) {
[08:29:22.093]         base::sink(type = "output", split = FALSE)
[08:29:22.093]         if (TRUE) {
[08:29:22.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:22.093]         }
[08:29:22.093]         else {
[08:29:22.093]             ...future.result["stdout"] <- base::list(NULL)
[08:29:22.093]         }
[08:29:22.093]         base::close(...future.stdout)
[08:29:22.093]         ...future.stdout <- NULL
[08:29:22.093]     }
[08:29:22.093]     ...future.result$conditions <- ...future.conditions
[08:29:22.093]     ...future.result$finished <- base::Sys.time()
[08:29:22.093]     ...future.result
[08:29:22.093] }
[08:29:22.096] MultisessionFuture started
[08:29:22.096] - Launch lazy future ... done
[08:29:22.097] run() for ‘MultisessionFuture’ ... done
[08:29:22.097] getGlobalsAndPackages() ...
[08:29:22.097] Searching for globals...
[08:29:22.098] - globals found: [1] ‘{’
[08:29:22.098] Searching for globals ... DONE
[08:29:22.098] Resolving globals: FALSE
[08:29:22.098] 
[08:29:22.098] 
[08:29:22.098] getGlobalsAndPackages() ... DONE
[08:29:22.098] run() for ‘Future’ ...
[08:29:22.099] - state: ‘created’
[08:29:22.099] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:29:22.113] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:29:22.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:29:22.113]   - Field: ‘node’
[08:29:22.113]   - Field: ‘label’
[08:29:22.113]   - Field: ‘local’
[08:29:22.113]   - Field: ‘owner’
[08:29:22.113]   - Field: ‘envir’
[08:29:22.113]   - Field: ‘workers’
[08:29:22.113]   - Field: ‘packages’
[08:29:22.113]   - Field: ‘gc’
[08:29:22.114]   - Field: ‘conditions’
[08:29:22.114]   - Field: ‘persistent’
[08:29:22.114]   - Field: ‘expr’
[08:29:22.114]   - Field: ‘uuid’
[08:29:22.114]   - Field: ‘seed’
[08:29:22.114]   - Field: ‘version’
[08:29:22.114]   - Field: ‘result’
[08:29:22.114]   - Field: ‘asynchronous’
[08:29:22.114]   - Field: ‘calls’
[08:29:22.114]   - Field: ‘globals’
[08:29:22.114]   - Field: ‘stdout’
[08:29:22.114]   - Field: ‘earlySignal’
[08:29:22.115]   - Field: ‘lazy’
[08:29:22.115]   - Field: ‘state’
[08:29:22.115] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:29:22.115] - Launch lazy future ...
[08:29:22.115] Packages needed by the future expression (n = 0): <none>
[08:29:22.115] Packages needed by future strategies (n = 0): <none>
[08:29:22.116] {
[08:29:22.116]     {
[08:29:22.116]         {
[08:29:22.116]             ...future.startTime <- base::Sys.time()
[08:29:22.116]             {
[08:29:22.116]                 {
[08:29:22.116]                   {
[08:29:22.116]                     {
[08:29:22.116]                       base::local({
[08:29:22.116]                         has_future <- base::requireNamespace("future", 
[08:29:22.116]                           quietly = TRUE)
[08:29:22.116]                         if (has_future) {
[08:29:22.116]                           ns <- base::getNamespace("future")
[08:29:22.116]                           version <- ns[[".package"]][["version"]]
[08:29:22.116]                           if (is.null(version)) 
[08:29:22.116]                             version <- utils::packageVersion("future")
[08:29:22.116]                         }
[08:29:22.116]                         else {
[08:29:22.116]                           version <- NULL
[08:29:22.116]                         }
[08:29:22.116]                         if (!has_future || version < "1.8.0") {
[08:29:22.116]                           info <- base::c(r_version = base::gsub("R version ", 
[08:29:22.116]                             "", base::R.version$version.string), 
[08:29:22.116]                             platform = base::sprintf("%s (%s-bit)", 
[08:29:22.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:29:22.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:29:22.116]                               "release", "version")], collapse = " "), 
[08:29:22.116]                             hostname = base::Sys.info()[["nodename"]])
[08:29:22.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:29:22.116]                             info)
[08:29:22.116]                           info <- base::paste(info, collapse = "; ")
[08:29:22.116]                           if (!has_future) {
[08:29:22.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:29:22.116]                               info)
[08:29:22.116]                           }
[08:29:22.116]                           else {
[08:29:22.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:29:22.116]                               info, version)
[08:29:22.116]                           }
[08:29:22.116]                           base::stop(msg)
[08:29:22.116]                         }
[08:29:22.116]                       })
[08:29:22.116]                     }
[08:29:22.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:29:22.116]                     base::options(mc.cores = 1L)
[08:29:22.116]                   }
[08:29:22.116]                   ...future.strategy.old <- future::plan("list")
[08:29:22.116]                   options(future.plan = NULL)
[08:29:22.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:29:22.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:29:22.116]                 }
[08:29:22.116]                 ...future.workdir <- getwd()
[08:29:22.116]             }
[08:29:22.116]             ...future.oldOptions <- base::as.list(base::.Options)
[08:29:22.116]             ...future.oldEnvVars <- base::Sys.getenv()
[08:29:22.116]         }
[08:29:22.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:29:22.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:29:22.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:29:22.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:29:22.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:29:22.116]             future.stdout.windows.reencode = NULL, width = 80L)
[08:29:22.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:29:22.116]             base::names(...future.oldOptions))
[08:29:22.116]     }
[08:29:22.116]     if (FALSE) {
[08:29:22.116]     }
[08:29:22.116]     else {
[08:29:22.116]         if (TRUE) {
[08:29:22.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:29:22.116]                 open = "w")
[08:29:22.116]         }
[08:29:22.116]         else {
[08:29:22.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:29:22.116]                 windows = "NUL", "/dev/null"), open = "w")
[08:29:22.116]         }
[08:29:22.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:29:22.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:29:22.116]             base::sink(type = "output", split = FALSE)
[08:29:22.116]             base::close(...future.stdout)
[08:29:22.116]         }, add = TRUE)
[08:29:22.116]     }
[08:29:22.116]     ...future.frame <- base::sys.nframe()
[08:29:22.116]     ...future.conditions <- base::list()
[08:29:22.116]     ...future.rng <- base::globalenv()$.Random.seed
[08:29:22.116]     if (FALSE) {
[08:29:22.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:29:22.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:29:22.116]     }
[08:29:22.116]     ...future.result <- base::tryCatch({
[08:29:22.116]         base::withCallingHandlers({
[08:29:22.116]             ...future.value <- base::withVisible(base::local({
[08:29:22.116]                 ...future.makeSendCondition <- base::local({
[08:29:22.116]                   sendCondition <- NULL
[08:29:22.116]                   function(frame = 1L) {
[08:29:22.116]                     if (is.function(sendCondition)) 
[08:29:22.116]                       return(sendCondition)
[08:29:22.116]                     ns <- getNamespace("parallel")
[08:29:22.116]                     if (exists("sendData", mode = "function", 
[08:29:22.116]                       envir = ns)) {
[08:29:22.116]                       parallel_sendData <- get("sendData", mode = "function", 
[08:29:22.116]                         envir = ns)
[08:29:22.116]                       envir <- sys.frame(frame)
[08:29:22.116]                       master <- NULL
[08:29:22.116]                       while (!identical(envir, .GlobalEnv) && 
[08:29:22.116]                         !identical(envir, emptyenv())) {
[08:29:22.116]                         if (exists("master", mode = "list", envir = envir, 
[08:29:22.116]                           inherits = FALSE)) {
[08:29:22.116]                           master <- get("master", mode = "list", 
[08:29:22.116]                             envir = envir, inherits = FALSE)
[08:29:22.116]                           if (inherits(master, c("SOCKnode", 
[08:29:22.116]                             "SOCK0node"))) {
[08:29:22.116]                             sendCondition <<- function(cond) {
[08:29:22.116]                               data <- list(type = "VALUE", value = cond, 
[08:29:22.116]                                 success = TRUE)
[08:29:22.116]                               parallel_sendData(master, data)
[08:29:22.116]                             }
[08:29:22.116]                             return(sendCondition)
[08:29:22.116]                           }
[08:29:22.116]                         }
[08:29:22.116]                         frame <- frame + 1L
[08:29:22.116]                         envir <- sys.frame(frame)
[08:29:22.116]                       }
[08:29:22.116]                     }
[08:29:22.116]                     sendCondition <<- function(cond) NULL
[08:29:22.116]                   }
[08:29:22.116]                 })
[08:29:22.116]                 withCallingHandlers({
[08:29:22.116]                   {
[08:29:22.116]                     3
[08:29:22.116]                   }
[08:29:22.116]                 }, immediateCondition = function(cond) {
[08:29:22.116]                   sendCondition <- ...future.makeSendCondition()
[08:29:22.116]                   sendCondition(cond)
[08:29:22.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.116]                   {
[08:29:22.116]                     inherits <- base::inherits
[08:29:22.116]                     invokeRestart <- base::invokeRestart
[08:29:22.116]                     is.null <- base::is.null
[08:29:22.116]                     muffled <- FALSE
[08:29:22.116]                     if (inherits(cond, "message")) {
[08:29:22.116]                       muffled <- grepl(pattern, "muffleMessage")
[08:29:22.116]                       if (muffled) 
[08:29:22.116]                         invokeRestart("muffleMessage")
[08:29:22.116]                     }
[08:29:22.116]                     else if (inherits(cond, "warning")) {
[08:29:22.116]                       muffled <- grepl(pattern, "muffleWarning")
[08:29:22.116]                       if (muffled) 
[08:29:22.116]                         invokeRestart("muffleWarning")
[08:29:22.116]                     }
[08:29:22.116]                     else if (inherits(cond, "condition")) {
[08:29:22.116]                       if (!is.null(pattern)) {
[08:29:22.116]                         computeRestarts <- base::computeRestarts
[08:29:22.116]                         grepl <- base::grepl
[08:29:22.116]                         restarts <- computeRestarts(cond)
[08:29:22.116]                         for (restart in restarts) {
[08:29:22.116]                           name <- restart$name
[08:29:22.116]                           if (is.null(name)) 
[08:29:22.116]                             next
[08:29:22.116]                           if (!grepl(pattern, name)) 
[08:29:22.116]                             next
[08:29:22.116]                           invokeRestart(restart)
[08:29:22.116]                           muffled <- TRUE
[08:29:22.116]                           break
[08:29:22.116]                         }
[08:29:22.116]                       }
[08:29:22.116]                     }
[08:29:22.116]                     invisible(muffled)
[08:29:22.116]                   }
[08:29:22.116]                   muffleCondition(cond)
[08:29:22.116]                 })
[08:29:22.116]             }))
[08:29:22.116]             future::FutureResult(value = ...future.value$value, 
[08:29:22.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:22.116]                   ...future.rng), globalenv = if (FALSE) 
[08:29:22.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:29:22.116]                     ...future.globalenv.names))
[08:29:22.116]                 else NULL, started = ...future.startTime, version = "1.8")
[08:29:22.116]         }, condition = base::local({
[08:29:22.116]             c <- base::c
[08:29:22.116]             inherits <- base::inherits
[08:29:22.116]             invokeRestart <- base::invokeRestart
[08:29:22.116]             length <- base::length
[08:29:22.116]             list <- base::list
[08:29:22.116]             seq.int <- base::seq.int
[08:29:22.116]             signalCondition <- base::signalCondition
[08:29:22.116]             sys.calls <- base::sys.calls
[08:29:22.116]             `[[` <- base::`[[`
[08:29:22.116]             `+` <- base::`+`
[08:29:22.116]             `<<-` <- base::`<<-`
[08:29:22.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:29:22.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:29:22.116]                   3L)]
[08:29:22.116]             }
[08:29:22.116]             function(cond) {
[08:29:22.116]                 is_error <- inherits(cond, "error")
[08:29:22.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:29:22.116]                   NULL)
[08:29:22.116]                 if (is_error) {
[08:29:22.116]                   sessionInformation <- function() {
[08:29:22.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:29:22.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:29:22.116]                       search = base::search(), system = base::Sys.info())
[08:29:22.116]                   }
[08:29:22.116]                   ...future.conditions[[length(...future.conditions) + 
[08:29:22.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:29:22.116]                     cond$call), session = sessionInformation(), 
[08:29:22.116]                     timestamp = base::Sys.time(), signaled = 0L)
[08:29:22.116]                   signalCondition(cond)
[08:29:22.116]                 }
[08:29:22.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:29:22.116]                 "immediateCondition"))) {
[08:29:22.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:29:22.116]                   ...future.conditions[[length(...future.conditions) + 
[08:29:22.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:29:22.116]                   if (TRUE && !signal) {
[08:29:22.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.116]                     {
[08:29:22.116]                       inherits <- base::inherits
[08:29:22.116]                       invokeRestart <- base::invokeRestart
[08:29:22.116]                       is.null <- base::is.null
[08:29:22.116]                       muffled <- FALSE
[08:29:22.116]                       if (inherits(cond, "message")) {
[08:29:22.116]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:22.116]                         if (muffled) 
[08:29:22.116]                           invokeRestart("muffleMessage")
[08:29:22.116]                       }
[08:29:22.116]                       else if (inherits(cond, "warning")) {
[08:29:22.116]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:22.116]                         if (muffled) 
[08:29:22.116]                           invokeRestart("muffleWarning")
[08:29:22.116]                       }
[08:29:22.116]                       else if (inherits(cond, "condition")) {
[08:29:22.116]                         if (!is.null(pattern)) {
[08:29:22.116]                           computeRestarts <- base::computeRestarts
[08:29:22.116]                           grepl <- base::grepl
[08:29:22.116]                           restarts <- computeRestarts(cond)
[08:29:22.116]                           for (restart in restarts) {
[08:29:22.116]                             name <- restart$name
[08:29:22.116]                             if (is.null(name)) 
[08:29:22.116]                               next
[08:29:22.116]                             if (!grepl(pattern, name)) 
[08:29:22.116]                               next
[08:29:22.116]                             invokeRestart(restart)
[08:29:22.116]                             muffled <- TRUE
[08:29:22.116]                             break
[08:29:22.116]                           }
[08:29:22.116]                         }
[08:29:22.116]                       }
[08:29:22.116]                       invisible(muffled)
[08:29:22.116]                     }
[08:29:22.116]                     muffleCondition(cond, pattern = "^muffle")
[08:29:22.116]                   }
[08:29:22.116]                 }
[08:29:22.116]                 else {
[08:29:22.116]                   if (TRUE) {
[08:29:22.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:29:22.116]                     {
[08:29:22.116]                       inherits <- base::inherits
[08:29:22.116]                       invokeRestart <- base::invokeRestart
[08:29:22.116]                       is.null <- base::is.null
[08:29:22.116]                       muffled <- FALSE
[08:29:22.116]                       if (inherits(cond, "message")) {
[08:29:22.116]                         muffled <- grepl(pattern, "muffleMessage")
[08:29:22.116]                         if (muffled) 
[08:29:22.116]                           invokeRestart("muffleMessage")
[08:29:22.116]                       }
[08:29:22.116]                       else if (inherits(cond, "warning")) {
[08:29:22.116]                         muffled <- grepl(pattern, "muffleWarning")
[08:29:22.116]                         if (muffled) 
[08:29:22.116]                           invokeRestart("muffleWarning")
[08:29:22.116]                       }
[08:29:22.116]                       else if (inherits(cond, "condition")) {
[08:29:22.116]                         if (!is.null(pattern)) {
[08:29:22.116]                           computeRestarts <- base::computeRestarts
[08:29:22.116]                           grepl <- base::grepl
[08:29:22.116]                           restarts <- computeRestarts(cond)
[08:29:22.116]                           for (restart in restarts) {
[08:29:22.116]                             name <- restart$name
[08:29:22.116]                             if (is.null(name)) 
[08:29:22.116]                               next
[08:29:22.116]                             if (!grepl(pattern, name)) 
[08:29:22.116]                               next
[08:29:22.116]                             invokeRestart(restart)
[08:29:22.116]                             muffled <- TRUE
[08:29:22.116]                             break
[08:29:22.116]                           }
[08:29:22.116]                         }
[08:29:22.116]                       }
[08:29:22.116]                       invisible(muffled)
[08:29:22.116]                     }
[08:29:22.116]                     muffleCondition(cond, pattern = "^muffle")
[08:29:22.116]                   }
[08:29:22.116]                 }
[08:29:22.116]             }
[08:29:22.116]         }))
[08:29:22.116]     }, error = function(ex) {
[08:29:22.116]         base::structure(base::list(value = NULL, visible = NULL, 
[08:29:22.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:29:22.116]                 ...future.rng), started = ...future.startTime, 
[08:29:22.116]             finished = Sys.time(), session_uuid = NA_character_, 
[08:29:22.116]             version = "1.8"), class = "FutureResult")
[08:29:22.116]     }, finally = {
[08:29:22.116]         if (!identical(...future.workdir, getwd())) 
[08:29:22.116]             setwd(...future.workdir)
[08:29:22.116]         {
[08:29:22.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:29:22.116]                 ...future.oldOptions$nwarnings <- NULL
[08:29:22.116]             }
[08:29:22.116]             base::options(...future.oldOptions)
[08:29:22.116]             if (.Platform$OS.type == "windows") {
[08:29:22.116]                 old_names <- names(...future.oldEnvVars)
[08:29:22.116]                 envs <- base::Sys.getenv()
[08:29:22.116]                 names <- names(envs)
[08:29:22.116]                 common <- intersect(names, old_names)
[08:29:22.116]                 added <- setdiff(names, old_names)
[08:29:22.116]                 removed <- setdiff(old_names, names)
[08:29:22.116]                 changed <- common[...future.oldEnvVars[common] != 
[08:29:22.116]                   envs[common]]
[08:29:22.116]                 NAMES <- toupper(changed)
[08:29:22.116]                 args <- list()
[08:29:22.116]                 for (kk in seq_along(NAMES)) {
[08:29:22.116]                   name <- changed[[kk]]
[08:29:22.116]                   NAME <- NAMES[[kk]]
[08:29:22.116]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.116]                     next
[08:29:22.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:22.116]                 }
[08:29:22.116]                 NAMES <- toupper(added)
[08:29:22.116]                 for (kk in seq_along(NAMES)) {
[08:29:22.116]                   name <- added[[kk]]
[08:29:22.116]                   NAME <- NAMES[[kk]]
[08:29:22.116]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.116]                     next
[08:29:22.116]                   args[[name]] <- ""
[08:29:22.116]                 }
[08:29:22.116]                 NAMES <- toupper(removed)
[08:29:22.116]                 for (kk in seq_along(NAMES)) {
[08:29:22.116]                   name <- removed[[kk]]
[08:29:22.116]                   NAME <- NAMES[[kk]]
[08:29:22.116]                   if (name != NAME && is.element(NAME, old_names)) 
[08:29:22.116]                     next
[08:29:22.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:29:22.116]                 }
[08:29:22.116]                 if (length(args) > 0) 
[08:29:22.116]                   base::do.call(base::Sys.setenv, args = args)
[08:29:22.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:29:22.116]             }
[08:29:22.116]             else {
[08:29:22.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:29:22.116]             }
[08:29:22.116]             {
[08:29:22.116]                 if (base::length(...future.futureOptionsAdded) > 
[08:29:22.116]                   0L) {
[08:29:22.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:29:22.116]                   base::names(opts) <- ...future.futureOptionsAdded
[08:29:22.116]                   base::options(opts)
[08:29:22.116]                 }
[08:29:22.116]                 {
[08:29:22.116]                   {
[08:29:22.116]                     base::options(mc.cores = ...future.mc.cores.old)
[08:29:22.116]                     NULL
[08:29:22.116]                   }
[08:29:22.116]                   options(future.plan = NULL)
[08:29:22.116]                   if (is.na(NA_character_)) 
[08:29:22.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:29:22.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:29:22.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:29:22.116]                     .init = FALSE)
[08:29:22.116]                 }
[08:29:22.116]             }
[08:29:22.116]         }
[08:29:22.116]     })
[08:29:22.116]     if (TRUE) {
[08:29:22.116]         base::sink(type = "output", split = FALSE)
[08:29:22.116]         if (TRUE) {
[08:29:22.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:29:22.116]         }
[08:29:22.116]         else {
[08:29:22.116]             ...future.result["stdout"] <- base::list(NULL)
[08:29:22.116]         }
[08:29:22.116]         base::close(...future.stdout)
[08:29:22.116]         ...future.stdout <- NULL
[08:29:22.116]     }
[08:29:22.116]     ...future.result$conditions <- ...future.conditions
[08:29:22.116]     ...future.result$finished <- base::Sys.time()
[08:29:22.116]     ...future.result
[08:29:22.116] }
[08:29:22.118] Poll #1 (0): usedNodes() = 2, workers = 2
[08:29:22.128] receiveMessageFromWorker() for ClusterFuture ...
[08:29:22.129] - Validating connection of MultisessionFuture
[08:29:22.129] - received message: FutureResult
[08:29:22.129] - Received FutureResult
[08:29:22.129] - Erased future from FutureRegistry
[08:29:22.129] result() for ClusterFuture ...
[08:29:22.129] - result already collected: FutureResult
[08:29:22.129] result() for ClusterFuture ... done
[08:29:22.129] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:22.130] result() for ClusterFuture ...
[08:29:22.130] - result already collected: FutureResult
[08:29:22.130] result() for ClusterFuture ... done
[08:29:22.130] result() for ClusterFuture ...
[08:29:22.130] - result already collected: FutureResult
[08:29:22.130] result() for ClusterFuture ... done
[08:29:22.131] MultisessionFuture started
[08:29:22.131] - Launch lazy future ... done
[08:29:22.131] run() for ‘MultisessionFuture’ ... done
[08:29:22.132] resolve() on list environment ...
[08:29:22.132]  recursive: 0
[08:29:22.132]  length: 4
[08:29:22.132]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:22.133] Future #1
[08:29:22.133]  length: 3 (resolved future 1)
[08:29:22.154]  length: 2 (resolved future 4)
[08:29:22.175] receiveMessageFromWorker() for ClusterFuture ...
[08:29:22.175] - Validating connection of MultisessionFuture
[08:29:22.175] - received message: FutureResult
[08:29:22.175] - Received FutureResult
[08:29:22.175] - Erased future from FutureRegistry
[08:29:22.175] result() for ClusterFuture ...
[08:29:22.176] - result already collected: FutureResult
[08:29:22.176] result() for ClusterFuture ... done
[08:29:22.176] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:22.176] Future #3
[08:29:22.176]  length: 1 (resolved future 3)
[08:29:22.640] receiveMessageFromWorker() for ClusterFuture ...
[08:29:22.640] - Validating connection of MultisessionFuture
[08:29:22.640] - received message: FutureResult
[08:29:22.640] - Received FutureResult
[08:29:22.641] - Erased future from FutureRegistry
[08:29:22.641] result() for ClusterFuture ...
[08:29:22.641] - result already collected: FutureResult
[08:29:22.641] result() for ClusterFuture ... done
[08:29:22.641] receiveMessageFromWorker() for ClusterFuture ... done
[08:29:22.641] Future #2
[08:29:22.641]  length: 0 (resolved future 2)
[08:29:22.641] resolve() on list environment ... DONE
[08:29:22.642] resolve() on list environment ...
[08:29:22.642]  recursive: 0
[08:29:22.642]  length: 4
[08:29:22.642]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:22.643] Future #1
[08:29:22.643]  length: 3 (resolved future 1)
[08:29:22.643] Future #2
[08:29:22.643]  length: 2 (resolved future 2)
[08:29:22.643] Future #3
[08:29:22.643]  length: 1 (resolved future 3)
[08:29:22.643]  length: 0 (resolved future 4)
[08:29:22.643] resolve() on list environment ... DONE
[08:29:22.644] resolve() on list environment ...
[08:29:22.644]  recursive: 0
[08:29:22.644]  length: 4
[08:29:22.645]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:22.645] Future #1
[08:29:22.645]  length: 3 (resolved future 1)
[08:29:22.645] Future #2
[08:29:22.645]  length: 2 (resolved future 2)
[08:29:22.645] Future #3
[08:29:22.645]  length: 1 (resolved future 3)
[08:29:22.645]  length: 0 (resolved future 4)
[08:29:22.645] resolve() on list environment ... DONE
[08:29:22.646] resolve() on list environment ...
[08:29:22.646]  recursive: 0
[08:29:22.646]  length: 4
[08:29:22.647]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:22.647] Future #1
[08:29:22.647]  length: 3 (resolved future 1)
[08:29:22.647] Future #2
[08:29:22.647]  length: 2 (resolved future 2)
[08:29:22.647] Future #3
[08:29:22.647]  length: 1 (resolved future 3)
[08:29:22.647]  length: 0 (resolved future 4)
[08:29:22.647] resolve() on list environment ... DONE
[08:29:22.648] resolve() on list environment ...
[08:29:22.648]  recursive: 0
[08:29:22.649]  length: 4
[08:29:22.649]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:22.649] Future #1
[08:29:22.650] result() for ClusterFuture ...
[08:29:22.650] - result already collected: FutureResult
[08:29:22.650] result() for ClusterFuture ... done
[08:29:22.650] result() for ClusterFuture ...
[08:29:22.650] - result already collected: FutureResult
[08:29:22.650] result() for ClusterFuture ... done
[08:29:22.650]  length: 3 (resolved future 1)
[08:29:22.650] Future #2
[08:29:22.650] result() for ClusterFuture ...
[08:29:22.650] - result already collected: FutureResult
[08:29:22.651] result() for ClusterFuture ... done
[08:29:22.651] result() for ClusterFuture ...
[08:29:22.651] - result already collected: FutureResult
[08:29:22.651] result() for ClusterFuture ... done
[08:29:22.651]  length: 2 (resolved future 2)
[08:29:22.651] Future #3
[08:29:22.651] result() for ClusterFuture ...
[08:29:22.651] - result already collected: FutureResult
[08:29:22.651] result() for ClusterFuture ... done
[08:29:22.651] result() for ClusterFuture ...
[08:29:22.651] - result already collected: FutureResult
[08:29:22.652] result() for ClusterFuture ... done
[08:29:22.652]  length: 1 (resolved future 3)
[08:29:22.652]  length: 0 (resolved future 4)
[08:29:22.652] resolve() on list environment ... DONE
[08:29:22.652] resolve() on list environment ...
[08:29:22.652]  recursive: 99
[08:29:22.653]  length: 4
[08:29:22.653]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[08:29:22.653] Future #1
[08:29:22.653] result() for ClusterFuture ...
[08:29:22.653] - result already collected: FutureResult
[08:29:22.653] result() for ClusterFuture ... done
[08:29:22.654] result() for ClusterFuture ...
[08:29:22.654] - result already collected: FutureResult
[08:29:22.654] result() for ClusterFuture ... done
[08:29:22.654] A MultisessionFuture was resolved
[08:29:22.654]  length: 3 (resolved future 1)
[08:29:22.654] Future #2
[08:29:22.654] result() for ClusterFuture ...
[08:29:22.654] - result already collected: FutureResult
[08:29:22.654] result() for ClusterFuture ... done
[08:29:22.654] result() for ClusterFuture ...
[08:29:22.654] - result already collected: FutureResult
[08:29:22.655] result() for ClusterFuture ... done
[08:29:22.655] A MultisessionFuture was resolved
[08:29:22.655]  length: 2 (resolved future 2)
[08:29:22.655] Future #3
[08:29:22.655] result() for ClusterFuture ...
[08:29:22.655] - result already collected: FutureResult
[08:29:22.655] result() for ClusterFuture ... done
[08:29:22.655] result() for ClusterFuture ...
[08:29:22.655] - result already collected: FutureResult
[08:29:22.655] result() for ClusterFuture ... done
[08:29:22.655] A MultisessionFuture was resolved
[08:29:22.656]  length: 1 (resolved future 3)
[08:29:22.656]  length: 0 (resolved future 4)
[08:29:22.656] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[08:29:22.659] resolve() on list ...
[08:29:22.659]  recursive: 0
[08:29:22.659]  length: 3
[08:29:22.659] 
[08:29:22.659]  length: 2 (resolved future 1)
[08:29:22.659]  length: 1 (resolved future 2)
[08:29:22.660]  length: 0 (resolved future 3)
[08:29:22.660] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[08:29:22.660] plan(): Setting new future strategy stack:
[08:29:22.661] List of future strategies:
[08:29:22.661] 1. FutureStrategy:
[08:29:22.661]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:29:22.661]    - tweaked: FALSE
[08:29:22.661]    - call: future::plan(oplan)
[08:29:22.661] plan(): nbrOfWorkers() = 1
> 
